{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/d6403d707e91fc177b267b1be79c7e875dbd5da2",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/d6403d707e91fc177b267b1be79c7e875dbd5da2/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/d6403d707e91fc177b267b1be79c7e875dbd5da2/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/d6403d707e91fc177b267b1be79c7e875dbd5da2/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 116,
          "old_api": "getKind",
          "new_api": "getOperand",
          "old_text": "Op->getKind()",
          "new_text": "I.getOperand(0)",
          "old_line_content": "           Op->getKind() == ValueKind::StructElementAddrInst) &&",
          "new_line_content": "      SILValue Op = I.getOperand(0);",
          "content_same": false
        },
        {
          "line": 117,
          "old_api": "hasOneUse",
          "new_api": "getKind",
          "old_text": "Op->hasOneUse()",
          "new_text": "Op->getKind()",
          "old_line_content": "          Op->hasOneUse())",
          "new_line_content": "      if ((Op->getKind() == ValueKind::TupleElementAddrInst ||",
          "content_same": false
        },
        {
          "line": 314,
          "old_api": "push_back",
          "new_api": "getArguments",
          "old_text": "Args.push_back(Arg)",
          "new_text": "AI->getArguments()",
          "old_line_content": "    Args.push_back(Arg);",
          "new_line_content": "    for (const auto &Arg : AI->getArguments())",
          "content_same": false
        },
        {
          "line": 348,
          "old_api": "back",
          "new_api": "size",
          "old_text": "Worklist.back()",
          "new_text": "Worklist.size()",
          "old_line_content": "    SILFunction *F = Worklist.back();",
          "new_line_content": "  while (Worklist.size()) {",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": "pop_back",
          "new_api": "back",
          "old_text": "Worklist.pop_back()",
          "new_text": "Worklist.back()",
          "old_line_content": "    Worklist.pop_back();",
          "new_line_content": "    SILFunction *F = Worklist.back();",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 260,
          "old_api": null,
          "new_api": "llvm::dbgs()",
          "old_text": null,
          "new_text": "llvm::dbgs()",
          "old_line_content": "  return Cost;",
          "new_line_content": "  DEBUG(llvm::dbgs() << \"  Found cost: \" << Cost << \"\\n\");",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "Caller->getName()",
          "old_line_content": "",
          "new_line_content": "  DEBUG(llvm::dbgs() << \"Visiting Function: \" << Caller->getName() << \"\\n\");",
          "content_same": false
        },
        {
          "line": 148,
          "old_api": null,
          "new_api": "getType",
          "old_text": null,
          "new_text": "I.getType(0).castTo<MetatypeType>()->isThin()",
          "old_line_content": "      // TODO: Thick metatypes are free if they don't require generic or lazy",
          "new_line_content": "      if (I.getType(0).castTo<MetatypeType>()->isThin())",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "BB.end()",
          "old_line_content": "    while (I != E) {",
          "new_line_content": "    auto I = BB.begin(), E = BB.end();",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": null,
          "new_api": "dyn_cast<ApplyInst>(I++)",
          "old_text": null,
          "new_text": "dyn_cast<ApplyInst>(I++)",
          "old_line_content": "      if (AI)",
          "new_line_content": "      ApplyInst *AI = dyn_cast<ApplyInst>(I++);",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "CallSites.push_back(AI)",
          "old_line_content": "    }",
          "new_line_content": "        CallSites.push_back(AI);",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": null,
          "new_api": "llvm::dbgs()",
          "old_text": null,
          "new_text": "llvm::dbgs()",
          "old_line_content": "",
          "new_line_content": "    DEBUG(llvm::dbgs() << \"  Found call site:\" <<  *AI);",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": null,
          "new_api": "getInlinableFunction",
          "old_text": null,
          "new_text": "getInlinableFunction(AI)",
          "old_line_content": "    if (!Callee)",
          "new_line_content": "    SILFunction *Callee = getInlinableFunction(AI);",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "Callee->getName()",
          "old_line_content": "",
          "new_line_content": "    DEBUG(llvm::dbgs() << \"  Found callee:\" <<  Callee->getName() << \".\\n\");",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": null,
          "new_api": "llvm::dbgs()",
          "old_text": null,
          "new_text": "llvm::dbgs()",
          "old_line_content": "      continue;",
          "new_line_content": "      DEBUG(llvm::dbgs() << \"  Skipping recursive calls.\\n\");",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": null,
          "new_api": "getFunctionCost",
          "old_text": null,
          "new_text": "getFunctionCost(Callee)",
          "old_line_content": "",
          "new_line_content": "    unsigned CalleeCost = getFunctionCost(Callee);",
          "content_same": false
        },
        {
          "line": 308,
          "old_api": null,
          "new_api": "llvm::dbgs()",
          "old_text": null,
          "new_text": "llvm::dbgs()",
          "old_line_content": "      continue;",
          "new_line_content": "      DEBUG(llvm::dbgs() << \"  Function too big to inline. Skipping.\\n\");",
          "content_same": false
        },
        {
          "line": 315,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "Args.push_back(Arg)",
          "old_line_content": "",
          "new_line_content": "    Args.push_back(Arg);",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "Caller->getName()",
          "old_line_content": "",
          "new_line_content": "          Caller->getName() << \"\\n\");",
          "content_same": false
        },
        {
          "line": 325,
          "old_api": null,
          "new_api": "ArrayRef<Substitution>()",
          "old_text": null,
          "new_text": "ArrayRef<Substitution>()",
          "old_line_content": "    NumFunctionsInlined++;",
          "new_line_content": "    Inliner.inlineFunction(AI, Callee, ArrayRef<Substitution>(), Args);",
          "content_same": false
        },
        {
          "line": 335,
          "old_api": null,
          "new_api": "llvm::dbgs()",
          "old_text": null,
          "new_text": "llvm::dbgs()",
          "old_line_content": "",
          "new_line_content": "  DEBUG(llvm::dbgs() << \"*** SIL Performance Inlining ***\\n\\n\");",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": null,
          "new_api": "llvm::dbgs()",
          "old_text": null,
          "new_text": "llvm::dbgs()",
          "old_line_content": "    return;",
          "new_line_content": "    DEBUG(llvm::dbgs() << \"*** The SIL performance Inliner is disabled ***\\n\");",
          "content_same": false
        },
        {
          "line": 344,
          "old_api": null,
          "new_api": "TopDownCallGraphOrder",
          "old_text": null,
          "new_text": "TopDownCallGraphOrder(M, Worklist)",
          "old_line_content": "",
          "new_line_content": "  TopDownCallGraphOrder(M, Worklist);",
          "content_same": false
        },
        {
          "line": 350,
          "old_api": null,
          "new_api": "pop_back",
          "old_text": null,
          "new_text": "Worklist.pop_back()",
          "old_line_content": "",
          "new_line_content": "    Worklist.pop_back();",
          "content_same": false
        },
        {
          "line": 225,
          "old_api": null,
          "new_api": "llvm_unreachable",
          "old_text": null,
          "new_text": "llvm_unreachable(\"Only instructions should be passed into this \"\n                       \"function.\")",
          "old_line_content": "                       \"function.\");    ",
          "new_line_content": "      llvm_unreachable(\"Only instructions should be passed into this \"",
          "content_same": false
        },
        {
          "line": 355,
          "old_api": null,
          "new_api": "inlineCallsIntoFunction",
          "old_text": null,
          "new_text": "inlineCallsIntoFunction(F)",
          "old_line_content": "  }",
          "new_line_content": "    inlineCallsIntoFunction(F);",
          "content_same": false
        },
        {
          "line": 229,
          "old_api": null,
          "new_api": "llvm_unreachable",
          "old_text": null,
          "new_text": "llvm_unreachable(\"not valid in canonical sil\")",
          "old_line_content": "  }",
          "new_line_content": "      llvm_unreachable(\"not valid in canonical sil\");",
          "content_same": false
        },
        {
          "line": 235,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "F->getName()",
          "old_line_content": "",
          "new_line_content": "  DEBUG(llvm::dbgs() << \"  Calculating cost for \" << F->getName() << \".\\n\");",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": null,
          "new_api": "isTransparent",
          "old_text": null,
          "new_text": "F->isTransparent()",
          "old_line_content": "    return 0;",
          "new_line_content": "  if (F->isTransparent() == IsTransparent_t::IsTransparent)",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": null,
          "new_api": "instructionInlineCost",
          "old_text": null,
          "new_text": "instructionInlineCost(I)",
          "old_line_content": "",
          "new_line_content": "      Cost += unsigned(instructionInlineCost(I));",
          "content_same": false
        },
        {
          "line": 118,
          "old_api": null,
          "new_api": "getKind",
          "old_text": null,
          "new_text": "Op->getKind()",
          "old_line_content": "        return InlineCost::Free;",
          "new_line_content": "           Op->getKind() == ValueKind::StructElementAddrInst) &&",
          "content_same": false
        },
        {
          "line": 119,
          "old_api": null,
          "new_api": "hasOneUse",
          "old_text": null,
          "new_text": "Op->hasOneUse()",
          "old_line_content": "    }",
          "new_line_content": "          Op->hasOneUse())",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 259,
          "old_api": "llvm::dbgs()",
          "new_api": null,
          "old_text": "llvm::dbgs()",
          "new_text": null,
          "old_line_content": "  DEBUG(llvm::dbgs() << \"  Found cost: \" << Cost << \"\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": "getName",
          "new_api": null,
          "old_text": "Caller->getName()",
          "new_text": null,
          "old_line_content": "  DEBUG(llvm::dbgs() << \"Visiting Function: \" << Caller->getName() << \"\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 146,
          "old_api": "getType",
          "new_api": null,
          "old_text": "I.getType(0).castTo<MetatypeType>()->isThin()",
          "new_text": null,
          "old_line_content": "      if (I.getType(0).castTo<MetatypeType>()->isThin())",
          "new_line_content": "    case ValueKind::MetatypeInst:",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": "end",
          "new_api": null,
          "old_text": "BB.end()",
          "new_text": null,
          "old_line_content": "    auto I = BB.begin(), E = BB.end();",
          "new_line_content": "  for (auto &BB : *Caller) {",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": "dyn_cast<ApplyInst>(I++)",
          "new_api": null,
          "old_text": "dyn_cast<ApplyInst>(I++)",
          "new_text": null,
          "old_line_content": "      ApplyInst *AI = dyn_cast<ApplyInst>(I++);",
          "new_line_content": "      // Check if this is a call site.",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "CallSites.push_back(AI)",
          "new_text": null,
          "old_line_content": "        CallSites.push_back(AI);",
          "new_line_content": "      if (AI)",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": "llvm::dbgs()",
          "new_api": null,
          "old_text": "llvm::dbgs()",
          "new_text": null,
          "old_line_content": "    DEBUG(llvm::dbgs() << \"  Found call site:\" <<  *AI);",
          "new_line_content": "  for (auto AI : CallSites) {",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": "getInlinableFunction",
          "new_api": null,
          "old_text": "getInlinableFunction(AI)",
          "new_text": null,
          "old_line_content": "    SILFunction *Callee = getInlinableFunction(AI);",
          "new_line_content": "    // Get the callee.",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": "getName",
          "new_api": null,
          "old_text": "Callee->getName()",
          "new_text": null,
          "old_line_content": "    DEBUG(llvm::dbgs() << \"  Found callee:\" <<  Callee->getName() << \".\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": "llvm::dbgs()",
          "new_api": null,
          "old_text": "llvm::dbgs()",
          "new_text": null,
          "old_line_content": "      DEBUG(llvm::dbgs() << \"  Skipping recursive calls.\\n\");",
          "new_line_content": "    if (Callee == Caller) {",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": "getFunctionCost",
          "new_api": null,
          "old_text": "getFunctionCost(Callee)",
          "new_text": null,
          "old_line_content": "    unsigned CalleeCost = getFunctionCost(Callee);",
          "new_line_content": "    // Calculate the inlining cost of the callee.",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": "llvm::dbgs()",
          "new_api": null,
          "old_text": "llvm::dbgs()",
          "new_text": null,
          "old_line_content": "      DEBUG(llvm::dbgs() << \"  Function too big to inline. Skipping.\\n\");",
          "new_line_content": "    if (CalleeCost > InlineCostThreshold) {",
          "content_same": false
        },
        {
          "line": 313,
          "old_api": "getArguments",
          "new_api": null,
          "old_text": "AI->getArguments()",
          "new_text": null,
          "old_line_content": "    for (const auto &Arg : AI->getArguments())",
          "new_line_content": "    SmallVector<SILValue, 8> Args;",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": "getName",
          "new_api": null,
          "old_text": "Callee->getName()",
          "new_text": null,
          "old_line_content": "    DEBUG(llvm::dbgs() << \"  Inlining \" << Callee->getName() << \" Into \" <<",
          "new_line_content": "    // Ok, we are within budget. Attempt to inline.",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": "ArrayRef<Substitution>()",
          "new_api": null,
          "old_text": "ArrayRef<Substitution>()",
          "new_text": null,
          "old_line_content": "    Inliner.inlineFunction(AI, Callee, ArrayRef<Substitution>(), Args);",
          "new_line_content": "    // our next invocation of the inliner.",
          "content_same": false
        },
        {
          "line": 334,
          "old_api": "llvm::dbgs()",
          "new_api": null,
          "old_text": "llvm::dbgs()",
          "new_text": null,
          "old_line_content": "  DEBUG(llvm::dbgs() << \"*** SIL Performance Inlining ***\\n\\n\");",
          "new_line_content": "void swift::performSILPerformanceInlining(SILModule *M) {",
          "content_same": false
        },
        {
          "line": 337,
          "old_api": "llvm::dbgs()",
          "new_api": null,
          "old_text": "llvm::dbgs()",
          "new_text": null,
          "old_line_content": "    DEBUG(llvm::dbgs() << \"*** The SIL performance Inliner is disabled ***\\n\");",
          "new_line_content": "  if (InlineCostThreshold == 0) {",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": "TopDownCallGraphOrder",
          "new_api": null,
          "old_text": "TopDownCallGraphOrder(M, Worklist)",
          "new_text": null,
          "old_line_content": "  TopDownCallGraphOrder(M, Worklist);",
          "new_line_content": "  std::vector<SILFunction *> Worklist;",
          "content_same": false
        },
        {
          "line": 347,
          "old_api": "size",
          "new_api": null,
          "old_text": "Worklist.size()",
          "new_text": null,
          "old_line_content": "  while (Worklist.size()) {",
          "new_line_content": "  // inst.",
          "content_same": false
        },
        {
          "line": 224,
          "old_api": "llvm_unreachable",
          "new_api": null,
          "old_text": "llvm_unreachable(\"Only instructions should be passed into this \"\n                       \"function.\")",
          "new_text": null,
          "old_line_content": "      llvm_unreachable(\"Only instructions should be passed into this \"",
          "new_line_content": "    case ValueKind::SILUndef:",
          "content_same": false
        },
        {
          "line": 354,
          "old_api": "inlineCallsIntoFunction",
          "new_api": null,
          "old_text": "inlineCallsIntoFunction(F)",
          "new_text": null,
          "old_line_content": "    inlineCallsIntoFunction(F);",
          "new_line_content": "    // transparent function.",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": "llvm_unreachable",
          "new_api": null,
          "old_text": "llvm_unreachable(\"not valid in canonical sil\")",
          "new_text": null,
          "old_line_content": "      llvm_unreachable(\"not valid in canonical sil\");",
          "new_line_content": "    case ValueKind::MarkUninitializedInst:",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": "getName",
          "new_api": null,
          "old_text": "F->getName()",
          "new_text": null,
          "old_line_content": "  DEBUG(llvm::dbgs() << \"  Calculating cost for \" << F->getName() << \".\\n\");",
          "new_line_content": "static unsigned getFunctionCost(SILFunction *F) {",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": "isTransparent",
          "new_api": null,
          "old_text": "F->isTransparent()",
          "new_text": null,
          "old_line_content": "  if (F->isTransparent() == IsTransparent_t::IsTransparent)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 114,
          "old_api": "getOperand",
          "new_api": null,
          "old_text": "I.getOperand(0)",
          "new_text": null,
          "old_line_content": "      SILValue Op = I.getOperand(0);",
          "new_line_content": "      // A gep whose operand is a gep with no other users will get folded by",
          "content_same": false
        },
        {
          "line": 115,
          "old_api": "getKind",
          "new_api": null,
          "old_text": "Op->getKind()",
          "new_text": null,
          "old_line_content": "      if ((Op->getKind() == ValueKind::TupleElementAddrInst ||",
          "new_line_content": "      // LLVM into one gep implying the second should be free.",
          "content_same": false
        },
        {
          "line": 242,
          "old_api": "instructionInlineCost",
          "new_api": null,
          "old_text": "instructionInlineCost(I)",
          "new_text": null,
          "old_line_content": "      Cost += unsigned(instructionInlineCost(I));",
          "new_line_content": "    for (auto &I : BB) {",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 5,
      "total_additions": 27,
      "total_deletions": 27,
      "total_api_changes": 59
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 3,
        "api_related_lines": 59,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          109,
          205,
          111
        ]
      }
    },
    "api_calls_before": 72,
    "api_calls_after": 72,
    "diff_info": {
      "added_lines": 2,
      "removed_lines": 1,
      "total_diff_lines": 23
    }
  }
}