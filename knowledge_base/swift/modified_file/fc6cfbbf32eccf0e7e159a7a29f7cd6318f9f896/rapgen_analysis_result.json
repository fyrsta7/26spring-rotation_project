{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/fc6cfbbf32eccf0e7e159a7a29f7cd6318f9f896",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/fc6cfbbf32eccf0e7e159a7a29f7cd6318f9f896/before.h",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/fc6cfbbf32eccf0e7e159a7a29f7cd6318f9f896/after.h",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/fc6cfbbf32eccf0e7e159a7a29f7cd6318f9f896/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 615,
          "old_api": "reinterpret_cast<const uintptr_t *>(adata)",
          "new_api": "end",
          "old_text": "reinterpret_cast<const uintptr_t *>(adata)",
          "new_text": "end()",
          "old_line_content": "    const uintptr_t *packCounts = reinterpret_cast<const uintptr_t *>(adata);",
          "new_line_content": "    auto asize = (uintptr_t)end() - (uintptr_t)adata;",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": "sizeInWords",
          "new_api": "assert",
          "old_text": "Layout.sizeInWords()",
          "new_text": "assert(packIdx == Layout.NumPacks && \"Missed a pack\")",
          "old_line_content": "  unsigned size() const { return Layout.sizeInWords(); }",
          "new_line_content": "    assert(packIdx == Layout.NumPacks && \"Missed a pack\");",
          "content_same": false
        },
        {
          "line": 902,
          "old_api": "setState",
          "new_api": "explicit",
          "old_text": "worker.setState(initialState)",
          "new_text": "explicit",
          "old_line_content": "    worker.setState(initialState);",
          "new_line_content": "  explicit PrivateMetadataTrackingInfo(PrivateMetadataState state,",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": "createQueue",
          "new_api": "reinterpret_cast<RawType>(queue)",
          "old_text": "worker.createQueue()",
          "new_text": "reinterpret_cast<RawType>(queue)",
          "old_line_content": "      return PrivateMetadataTrackingInfo(initialState, worker.createQueue());",
          "new_line_content": "    : Data(RawType(state) | reinterpret_cast<RawType>(queue)",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": "PrivateMetadataState",
          "new_api": "explicit",
          "old_text": "PrivateMetadataState(Data & StateMask)",
          "new_text": "explicit",
          "old_line_content": "    return PrivateMetadataState(Data & StateMask);",
          "new_line_content": "  explicit PrivateMetadataTrackingInfo(PrivateMetadataState state,",
          "content_same": false
        },
        {
          "line": 918,
          "old_api": "getState",
          "new_api": "setState",
          "old_text": "getState()",
          "new_text": "worker.setState(initialState)",
          "old_line_content": "    return getState() == PrivateMetadataState::Complete;",
          "new_line_content": "    worker.setState(initialState);",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": "hasWaitQueue",
          "new_api": "PrivateMetadataState",
          "old_text": "hasWaitQueue()",
          "new_text": "PrivateMetadataState(Data & StateMask)",
          "old_line_content": "    if (hasWaitQueue())",
          "new_line_content": "    return PrivateMetadataState(Data & StateMask);",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": "getSuspendedCompletion",
          "new_api": "hasWaitQueue",
          "old_text": "getSuspendedCompletion()",
          "new_text": "hasWaitQueue()",
          "old_line_content": "    if (auto dependency = getSuspendedCompletion())",
          "new_line_content": "    if (hasWaitQueue())",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": "getState",
          "new_api": "hasWaitQueue",
          "old_text": "getState()",
          "new_text": "hasWaitQueue()",
          "old_line_content": "    return swift::satisfies(getState(), requirement);",
          "new_line_content": "    if (!hasWaitQueue())",
          "content_same": false
        },
        {
          "line": 1009,
          "old_api": "swift_unreachable",
          "new_api": "isBlocking",
          "old_text": "swift_unreachable(\"initialization hasn't allocated?\")",
          "new_text": "request.isBlocking()",
          "old_line_content": "    swift_unreachable(\"initialization hasn't allocated?\");",
          "new_line_content": "      if (request.isBlocking())",
          "content_same": false
        },
        {
          "line": 1015,
          "old_api": "getState",
          "new_api": "swift_unreachable",
          "old_text": "request.getState()",
          "new_text": "swift_unreachable(\"bad state\")",
          "old_line_content": "    if (satisfies(currentState, request.getState()))",
          "new_line_content": "    swift_unreachable(\"bad state\");",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": "isWorkerThread",
          "new_api": "getState",
          "old_text": "worker.isWorkerThread()",
          "new_text": "worker.getState()",
          "old_line_content": "      assert(worker.isWorkerThread());",
          "new_line_content": "    auto state = worker.getState();",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": "std::forward<Args>(args)",
          "new_api": "verifyMangledNameRoundtrip",
          "old_text": "std::forward<Args>(args)",
          "new_text": "verifyMangledNameRoundtrip(value)",
          "old_line_content": "    if (asImpl().allowMangledNameVerification(std::forward<Args>(args)...))",
          "new_line_content": "        verifyMangledNameRoundtrip(value);",
          "content_same": false
        },
        {
          "line": 1262,
          "old_api": "assert",
          "new_api": "getState",
          "old_text": "assert(newState == PrivateMetadataState::Complete &&\n               \"initialization didn't report a dependency but isn't complete\")",
          "new_text": "worker.getState()",
          "old_line_content": "        assert(newState == PrivateMetadataState::Complete &&",
          "new_line_content": "      assert(worker.getState() < PrivateMetadataState::Complete);",
          "content_same": false
        },
        {
          "line": 1267,
          "old_api": "assert",
          "new_api": "tryInitialize",
          "old_text": "assert(newState != PrivateMetadataState::Complete &&\n               \"initialization reported a dependency but is complete\")",
          "new_text": "asImpl().tryInitialize(value, oldState, context)",
          "old_line_content": "        assert(newState != PrivateMetadataState::Complete &&",
          "new_line_content": "        asImpl().tryInitialize(value, oldState, context);",
          "content_same": false
        },
        {
          "line": 1270,
          "old_api": "shouldBlockInitialization",
          "new_api": "setState",
          "old_text": "shouldBlockInitialization(newState, request)",
          "new_text": "worker.setState(newState)",
          "old_line_content": "        willWait = shouldBlockInitialization(newState, request);",
          "new_line_content": "      worker.setState(newState);",
          "content_same": false
        },
        {
          "line": 1278,
          "old_api": "reset",
          "new_api": "assert",
          "old_text": "queue->PersistentContext.reset(\n            new PrivateMetadataCompletionContext(scratchContext))",
          "new_text": "assert(newState == PrivateMetadataState::Complete &&\n               \"initialization didn't report a dependency but isn't complete\")",
          "old_line_content": "          queue->PersistentContext.reset(",
          "new_line_content": "        assert(newState == PrivateMetadataState::Complete &&",
          "content_same": false
        },
        {
          "line": 1286,
          "old_api": "release",
          "new_api": "shouldBlockInitialization",
          "old_text": "queue->PersistentContext.release()",
          "new_text": "shouldBlockInitialization(newState, request)",
          "old_line_content": "                                 queue->PersistentContext.release());",
          "new_line_content": "        willWait = shouldBlockInitialization(newState, request);",
          "content_same": false
        },
        {
          "line": 1294,
          "old_api": "notifyWaitingThreadsOfProgress",
          "new_api": "reset",
          "old_text": "notifyWaitingThreadsOfProgress(worker, dependency)",
          "new_text": "queue->PersistentContext.reset(\n            new PrivateMetadataCompletionContext(scratchContext))",
          "old_line_content": "        notifyWaitingThreadsOfProgress(worker, dependency);",
          "new_line_content": "          queue->PersistentContext.reset(",
          "content_same": false
        },
        {
          "line": 1330,
          "old_api": "hasAllocatedMetadata",
          "new_api": "getState",
          "old_text": "newInfo.hasAllocatedMetadata()",
          "new_text": "worker.getState()",
          "old_line_content": "      assert(newInfo.hasAllocatedMetadata());",
          "new_line_content": "    auto newState = worker.getState();",
          "content_same": false
        },
        {
          "line": 1346,
          "old_api": "isUniquelyReferenced_locked",
          "new_api": "hasAllocatedMetadata",
          "old_text": "oldQueue->isUniquelyReferenced_locked()",
          "new_text": "newInfo.hasAllocatedMetadata()",
          "old_line_content": "      if (oldQueue->isUniquelyReferenced_locked()) {",
          "new_line_content": "      assert(newInfo.hasAllocatedMetadata());",
          "content_same": false
        },
        {
          "line": 1417,
          "old_api": "getWaitQueue",
          "new_api": "load",
          "old_text": "trackingInfo.getWaitQueue()",
          "new_text": "TrackingInfo.load(TrackingInfoIsLockedOrder)",
          "old_line_content": "        return op.waitAndRepeat(trackingInfo.getWaitQueue());",
          "new_line_content": "      trackingInfo = TrackingInfo.load(TrackingInfoIsLockedOrder);",
          "content_same": false
        },
        {
          "line": 1454,
          "old_api": "assert",
          "new_api": "reset",
          "old_text": "assert(checkResult == PrivateMetadataTrackingInfo::Satisfied ||\n             checkResult == PrivateMetadataTrackingInfo::Unsatisfied)",
          "new_text": "suspendedCompletionToDelete.reset(suspendedCompletion)",
          "old_line_content": "      assert(checkResult == PrivateMetadataTrackingInfo::Satisfied ||",
          "new_line_content": "          suspendedCompletionToDelete.reset(suspendedCompletion);",
          "content_same": false
        },
        {
          "line": 1462,
          "old_api": "doInitialization",
          "new_api": "flagQueueIsPublished",
          "old_text": "doInitialization(worker, request)",
          "new_text": "op.flagQueueIsPublished(queue)",
          "old_line_content": "    return doInitialization(worker, request);",
          "new_line_content": "        return op.flagQueueIsPublished(queue);",
          "content_same": false
        },
        {
          "line": 1470,
          "old_api": "isWorkerThread",
          "new_api": "assert",
          "old_text": "worker.isWorkerThread()",
          "new_text": "assert(checkResult == PrivateMetadataTrackingInfo::Satisfied ||\n             checkResult == PrivateMetadataTrackingInfo::Unsatisfied)",
          "old_line_content": "    assert(worker.isWorkerThread());",
          "new_line_content": "      assert(checkResult == PrivateMetadataTrackingInfo::Satisfied ||",
          "content_same": false
        },
        {
          "line": 1478,
          "old_api": "blockOnMetadataDependency",
          "new_api": "doInitialization",
          "old_text": "blockOnMetadataDependency(requestDependency, dependency)",
          "new_text": "doInitialization(worker, request)",
          "old_line_content": "    blockOnMetadataDependency(requestDependency, dependency);",
          "new_line_content": "    return doInitialization(worker, request);",
          "content_same": false
        },
        {
          "line": 1494,
          "old_api": "MetadataDependency",
          "new_api": "blockOnMetadataDependency",
          "old_text": "MetadataDependency()",
          "new_text": "blockOnMetadataDependency(requestDependency, dependency)",
          "old_line_content": "      return { curInfo.getState(), MetadataDependency() };",
          "new_line_content": "    blockOnMetadataDependency(requestDependency, dependency);",
          "content_same": false
        },
        {
          "line": 1582,
          "old_api": "getKey",
          "new_api": "assert",
          "old_text": "value.getKey()",
          "new_text": "assert((value != nullptr) ==\n           (initialState != PrivateMetadataState::Allocating))",
          "old_line_content": "    return hash_value(value.getKey());",
          "new_line_content": "    assert((value != nullptr) ==",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1025,
          "old_api": null,
          "new_api": "swift_unreachable",
          "old_text": null,
          "new_text": "swift_unreachable(\"initialization hasn't allocated?\")",
          "old_line_content": "",
          "new_line_content": "    swift_unreachable(\"initialization hasn't allocated?\");",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": null,
          "new_api": "getState",
          "old_text": null,
          "new_text": "request.getState()",
          "old_line_content": "/// The value type may be an arbitrary type, but it must be contextually",
          "new_line_content": "    if (satisfies(currentState, request.getState()))",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": null,
          "new_api": "isBlocking",
          "old_text": null,
          "new_text": "request.isBlocking()",
          "old_line_content": "/// state.",
          "new_line_content": "    return request.isBlocking();",
          "content_same": false
        },
        {
          "line": 1547,
          "old_api": null,
          "new_api": "sizeInWords",
          "old_text": null,
          "new_text": "Layout.sizeInWords()",
          "old_line_content": "  ValueType Value;",
          "new_line_content": "    return Layout.sizeInWords();",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": null,
          "new_api": "swift_unreachable",
          "old_text": null,
          "new_text": "swift_unreachable(\"bad state\")",
          "old_line_content": "/// In addition to the lookup members required by ConcurrentMap, concrete",
          "new_line_content": "  swift_unreachable(\"bad state\");",
          "content_same": false
        },
        {
          "line": 1554,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "key.size()",
          "old_line_content": "    Value = value;",
          "new_line_content": "    return key.size();",
          "content_same": false
        },
        {
          "line": 1579,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "key.layout()",
          "old_line_content": "  }",
          "new_line_content": "        Layout(key.layout()),",
          "content_same": false
        },
        {
          "line": 1580,
          "old_api": null,
          "new_api": "hash",
          "old_text": null,
          "new_text": "key.hash()",
          "old_line_content": "",
          "new_line_content": "        Hash(key.hash()),",
          "content_same": false
        },
        {
          "line": 1584,
          "old_api": null,
          "new_api": "this->template getTrailingObjects<const void *>()",
          "old_text": null,
          "new_text": "this->template getTrailingObjects<const void *>()",
          "old_line_content": "",
          "new_line_content": "    key.installInto(this->template getTrailingObjects<const void *>());",
          "content_same": false
        },
        {
          "line": 1588,
          "old_api": null,
          "new_api": "MetadataCacheKey",
          "old_text": null,
          "new_text": "MetadataCacheKey(Layout,\n                            this->template getTrailingObjects<const void*>(),\n                            Hash)",
          "old_line_content": "",
          "new_line_content": "    return MetadataCacheKey(Layout,",
          "content_same": false
        },
        {
          "line": 1589,
          "old_api": null,
          "new_api": "this->template getTrailingObjects<const void*>()",
          "old_text": null,
          "new_text": "this->template getTrailingObjects<const void*>()",
          "old_line_content": "  friend struct StaticAssertGenericMetadataCacheEntryValueOffset;",
          "new_line_content": "                            this->template getTrailingObjects<const void*>(),",
          "content_same": false
        },
        {
          "line": 1598,
          "old_api": null,
          "new_api": "getKey",
          "old_text": null,
          "new_text": "value.getKey()",
          "old_line_content": "} // namespace swift",
          "new_line_content": "    return hash_value(value.getKey());",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": null,
          "new_api": "getKey",
          "old_text": null,
          "new_text": "getKey()",
          "old_line_content": "",
          "new_line_content": "    return key == getKey();",
          "content_same": false
        },
        {
          "line": 1110,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "  /// Given that this thread doesn't own the right to initialize the",
          "new_line_content": "  static constexpr std::memory_order TrackingInfoIsLockedOrder =",
          "content_same": false
        },
        {
          "line": 1117,
          "old_api": null,
          "new_api": "PrivateMetadataTrackingInfo::initial(worker, initialState)",
          "old_text": null,
          "new_text": "PrivateMetadataTrackingInfo::initial(worker, initialState)",
          "old_line_content": "",
          "new_line_content": "      : TrackingInfo(PrivateMetadataTrackingInfo::initial(worker, initialState)) {",
          "content_same": false
        },
        {
          "line": 612,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "begin()",
          "old_line_content": "    // Compare the content.",
          "new_line_content": "    auto *adata = begin();",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "rhs.end()",
          "old_line_content": "",
          "new_line_content": "    auto bsize = (uintptr_t)rhs.end() - (uintptr_t)bdata;",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": null,
          "new_api": "awaitSatisfyingState",
          "old_text": null,
          "new_text": "awaitSatisfyingState(concurrency, request)",
          "old_line_content": "  std::optional<Status> beginAllocation(MetadataWaitQueue::Worker &worker,",
          "new_line_content": "    return awaitSatisfyingState(concurrency, request);",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(state != PrivateMetadataState::Allocating)",
          "old_line_content": "    // should only do it if we're reached PrivateMetadataState::Complete.",
          "new_line_content": "    assert(state != PrivateMetadataState::Allocating);",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": null,
          "new_api": "memcmp",
          "old_text": null,
          "new_text": "memcmp(adata, bdata, asize)",
          "old_line_content": "      ++argIdx;",
          "new_line_content": "    if (memcmp(adata, bdata, asize) == 0)",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": null,
          "new_api": "getAccomplishedRequestState",
          "old_text": null,
          "new_text": "getAccomplishedRequestState(state)",
          "old_line_content": "",
          "new_line_content": "    return { asImpl().getValue(), getAccomplishedRequestState(state) };",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": null,
          "new_api": "reinterpret_cast<const uintptr_t *>(adata)",
          "old_text": null,
          "new_text": "reinterpret_cast<const uintptr_t *>(adata)",
          "old_line_content": "    for (unsigned i = 0; i != Layout.NumKeyParameters; ++i) {",
          "new_line_content": "    const uintptr_t *packCounts = reinterpret_cast<const uintptr_t *>(adata);",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": null,
          "new_api": "std::forward<Args>(args)",
          "old_text": null,
          "new_text": "std::forward<Args>(args)",
          "old_line_content": "",
          "new_line_content": "      if (asImpl().allowMangledNameVerification(std::forward<Args>(args)...))",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": null,
          "new_api": "getValue",
          "old_text": null,
          "new_text": "asImpl().getValue()",
          "old_line_content": "    // Allocate the metadata.",
          "new_line_content": "        verifyMangledNameRoundtrip(asImpl().getValue());",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(packs[packIdx].ShapeClass < Layout.NumShapeClasses)",
          "old_line_content": "",
          "new_line_content": "        assert(packs[packIdx].ShapeClass < Layout.NumShapeClasses);",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": null,
          "new_api": "isWorkerThread",
          "old_text": null,
          "new_text": "worker.isWorkerThread()",
          "old_line_content": "",
          "new_line_content": "        assert(!worker.isWorkerThread());",
          "content_same": false
        },
        {
          "line": 1166,
          "old_api": null,
          "new_api": "getValue",
          "old_text": null,
          "new_text": "asImpl().getValue()",
          "old_line_content": "    // Set the self-link before publishing the new status.",
          "new_line_content": "        return Status{asImpl().getValue(), MetadataState::Complete};",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": null,
          "new_api": "areMetadataPacksEqual",
          "old_text": null,
          "new_text": "areMetadataPacksEqual(adata[argIdx], bdata[argIdx], count)",
          "old_line_content": "      // Is this entry a witness table pack?",
          "new_line_content": "        if (!areMetadataPacksEqual(adata[argIdx], bdata[argIdx], count))",
          "content_same": false
        },
        {
          "line": 1170,
          "old_api": null,
          "new_api": "isWorkerThread",
          "old_text": null,
          "new_text": "worker.isWorkerThread()",
          "old_line_content": "    // If allocation gave us complete metadata, we can short-circuit",
          "new_line_content": "      assert(worker.isWorkerThread());",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": null,
          "new_api": "isWorkerThread",
          "old_text": null,
          "new_text": "worker.isWorkerThread()",
          "old_line_content": "",
          "new_line_content": "    assert(worker.isWorkerThread());",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": null,
          "new_api": "setState",
          "old_text": null,
          "new_text": "worker.setState(state)",
          "old_line_content": "#endif",
          "new_line_content": "    worker.setState(state);",
          "content_same": false
        },
        {
          "line": 1183,
          "old_api": null,
          "new_api": "const_cast<ValueType>(allocationResult.Value)",
          "old_text": null,
          "new_text": "const_cast<ValueType>(allocationResult.Value)",
          "old_line_content": "    }",
          "new_line_content": "    auto value = const_cast<ValueType>(allocationResult.Value);",
          "content_same": false
        },
        {
          "line": 1184,
          "old_api": null,
          "new_api": "setValue",
          "old_text": null,
          "new_text": "asImpl().setValue(value)",
          "old_line_content": "",
          "new_line_content": "    asImpl().setValue(value);",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(packs[packIdx].ShapeClass < Layout.NumShapeClasses)",
          "old_line_content": "    }",
          "new_line_content": "        assert(packs[packIdx].ShapeClass < Layout.NumShapeClasses);",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": null,
          "new_api": "MetadataDependency",
          "old_text": null,
          "new_text": "MetadataDependency()",
          "old_line_content": "    // satisfiable.",
          "new_line_content": "      finishAndPublishProgress(worker, MetadataDependency(), nullptr);",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": null,
          "new_api": "areWitnessTablePacksEqual",
          "old_text": null,
          "new_text": "areWitnessTablePacksEqual(adata[argIdx], bdata[argIdx], count)",
          "old_line_content": "    return true;",
          "new_line_content": "        if (!areWitnessTablePacksEqual(adata[argIdx], bdata[argIdx], count))",
          "content_same": false
        },
        {
          "line": 1194,
          "old_api": null,
          "new_api": "std::forward<Args>(args)",
          "old_text": null,
          "new_text": "std::forward<Args>(args)",
          "old_line_content": "    // the mangled name round-trips.",
          "new_line_content": "      if (asImpl().allowMangledNameVerification(std::forward<Args>(args)...))",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": null,
          "new_api": "areWitnessTablesEqual",
          "old_text": null,
          "new_text": "areWitnessTablesEqual((const WitnessTable *)adata[argIdx],\n                                 (const WitnessTable *)bdata[argIdx])",
          "old_line_content": "",
          "new_line_content": "      if (!areWitnessTablesEqual((const WitnessTable *)adata[argIdx],",
          "content_same": false
        },
        {
          "line": 1206,
          "old_api": null,
          "new_api": "MetadataDependency",
          "old_text": null,
          "new_text": "MetadataDependency()",
          "old_line_content": "  }",
          "new_line_content": "    notifyWaitingThreadsOfProgress(worker, MetadataDependency());",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": null,
          "new_api": "std::forward<Args>(args)",
          "old_text": null,
          "new_text": "std::forward<Args>(args)",
          "old_line_content": "                             MetadataRequest request, Args &&...args) {",
          "new_line_content": "    if (asImpl().allowMangledNameVerification(std::forward<Args>(args)...))",
          "content_same": false
        },
        {
          "line": 1212,
          "old_api": null,
          "new_api": "verifyMangledNameRoundtrip",
          "old_text": null,
          "new_text": "verifyMangledNameRoundtrip(value)",
          "old_line_content": "    // Note that we ignore the extra arguments; those are just for the",
          "new_line_content": "      verifyMangledNameRoundtrip(value);",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "size()",
          "old_line_content": "    unsigned packIdx = 0;",
          "new_line_content": "  const void * const *end() const { return Data + size(); }",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": null,
          "new_api": "sizeInWords",
          "old_text": null,
          "new_text": "Layout.sizeInWords()",
          "old_line_content": "",
          "new_line_content": "  unsigned size() const { return Layout.sizeInWords(); }",
          "content_same": false
        },
        {
          "line": 712,
          "old_api": null,
          "new_api": "sizeInWords",
          "old_text": null,
          "new_text": "MetadataCacheKey::installGenericArguments(\n        Layout.sizeInWords(),\n        Layout.NumPacks,\n        Layout.PackShapeDescriptors,\n        buffer, Data)",
          "old_line_content": "      H ^= (value ^ (value >> 19));",
          "new_line_content": "    MetadataCacheKey::installGenericArguments(",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": null,
          "new_api": "sizeInWords",
          "old_text": null,
          "new_text": "Layout.sizeInWords()",
          "old_line_content": "    };",
          "new_line_content": "        Layout.sizeInWords(),",
          "content_same": false
        },
        {
          "line": 1230,
          "old_api": null,
          "new_api": "doInitialization",
          "old_text": null,
          "new_text": "doInitialization(worker, request)",
          "old_line_content": "    // Figure out a completion context to use.",
          "new_line_content": "    return doInitialization(worker, request);",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": null,
          "new_api": "isWorkerThread",
          "old_text": null,
          "new_text": "worker.isWorkerThread()",
          "old_line_content": "      context = &scratchContext;",
          "new_line_content": "    assert(worker.isWorkerThread());",
          "content_same": false
        },
        {
          "line": 1241,
          "old_api": null,
          "new_api": "getState",
          "old_text": null,
          "new_text": "worker.getState()",
          "old_line_content": "",
          "new_line_content": "    assert(worker.getState() > PrivateMetadataState::Allocating);",
          "content_same": false
        },
        {
          "line": 1242,
          "old_api": null,
          "new_api": "getValue",
          "old_text": null,
          "new_text": "asImpl().getValue()",
          "old_line_content": "    // Try the complete the metadata.  This only loops if initialization",
          "new_line_content": "    auto value = asImpl().getValue();",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": null,
          "new_api": "getPublishedQueue",
          "old_text": null,
          "new_text": "worker.getPublishedQueue()",
          "old_line_content": "    // add ourselves to its queue.",
          "new_line_content": "    auto queue = worker.getPublishedQueue();",
          "content_same": false
        },
        {
          "line": 1247,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "",
          "new_line_content": "    static const constexpr PrivateMetadataCompletionContext zeroContext = {};",
          "content_same": false
        },
        {
          "line": 1250,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "queue->PersistentContext.get()",
          "old_line_content": "      MetadataStateWithDependency MetadataStateWithDependency =",
          "new_line_content": "    if (auto persistent = queue->PersistentContext.get()) {",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(packs[packIdx].ShapeClass < Layout.NumShapeClasses)",
          "old_line_content": "    // Rotate right by 10 and then truncate to 32 bits.",
          "new_line_content": "        assert(packs[packIdx].ShapeClass < Layout.NumShapeClasses);",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": null,
          "new_api": "reinterpret_cast<uintptr_t>(Data[packs[packIdx].ShapeClass])",
          "old_text": null,
          "new_text": "reinterpret_cast<uintptr_t>(Data[packs[packIdx].ShapeClass])",
          "old_line_content": "    return uint32_t((H >> 10) | (H << ((sizeof(uintptr_t) * 8) - 10)));",
          "new_line_content": "        auto count = reinterpret_cast<uintptr_t>(Data[packs[packIdx].ShapeClass]);",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": null,
          "new_api": "getElements",
          "old_text": null,
          "new_text": "pack.getElements()",
          "old_line_content": "/// objects and automatically implements the getExtraAllocationSize methods",
          "new_line_content": "          update(reinterpret_cast<uintptr_t>(pack.getElements()[j]));",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": null,
          "new_api": "reinterpret_cast<uintptr_t>(Data[i])",
          "old_text": null,
          "new_text": "reinterpret_cast<uintptr_t>(Data[i])",
          "old_line_content": "///   static size_t numTrailingObjects(OverloadToken<T>, ...) const;",
          "new_line_content": "      update(reinterpret_cast<uintptr_t>(Data[i]));",
          "content_same": false
        },
        {
          "line": 1265,
          "old_api": null,
          "new_api": "getState",
          "old_text": null,
          "new_text": "worker.getState()",
          "old_line_content": "        willWait = false;",
          "new_line_content": "      auto oldState = worker.getState();",
          "content_same": false
        },
        {
          "line": 1272,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(oldState <= newState &&\n             \"initialization regressed to an earlier state\")",
          "old_line_content": "",
          "new_line_content": "      assert(oldState <= newState &&",
          "content_same": false
        },
        {
          "line": 1283,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(newState != PrivateMetadataState::Complete &&\n               \"initialization reported a dependency but is complete\")",
          "old_line_content": "      // execution.",
          "new_line_content": "        assert(newState != PrivateMetadataState::Complete &&",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": null,
          "new_api": "static_cast<Impl &>(*this)",
          "old_text": null,
          "new_text": "static_cast<Impl &>(*this)",
          "old_line_content": "  }",
          "new_line_content": "  Impl &asImpl() { return static_cast<Impl &>(*this); }",
          "content_same": false
        },
        {
          "line": 778,
          "old_api": null,
          "new_api": "static_cast<const Impl &>(*this)",
          "old_text": null,
          "new_text": "static_cast<const Impl &>(*this)",
          "old_line_content": "};",
          "new_line_content": "  const Impl &asImpl() const { return static_cast<const Impl &>(*this); }",
          "content_same": false
        },
        {
          "line": 1293,
          "old_api": null,
          "new_api": "memcmp",
          "old_text": null,
          "new_text": "memcmp(&scratchContext, &zeroContext, sizeof(zeroContext))",
          "old_line_content": "      if (oldState < newState) {",
          "new_line_content": "        if (memcmp(&scratchContext, &zeroContext, sizeof(zeroContext)) != 0)",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": null,
          "new_api": "TrailingObjects::template additionalSizeToAlloc<Objects...>(\n        Impl::numTrailingObjects(OverloadToken<Objects>(), key, args...)...)",
          "old_text": null,
          "new_text": "TrailingObjects::template additionalSizeToAlloc<Objects...>(\n        Impl::numTrailingObjects(OverloadToken<Objects>(), key, args...)...)",
          "old_line_content": "const size_t PrivateMetadataTrackingAlignment = 16;",
          "new_line_content": "    return TrailingObjects::template additionalSizeToAlloc<Objects...>(",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": null,
          "new_api": "OverloadToken<Objects>()",
          "old_text": null,
          "new_text": "OverloadToken<Objects>()",
          "old_line_content": "",
          "new_line_content": "        Impl::numTrailingObjects(OverloadToken<Objects>(), key, args...)...);",
          "content_same": false
        },
        {
          "line": 1301,
          "old_api": null,
          "new_api": "release",
          "old_text": null,
          "new_text": "finishAndPublishProgress(worker, dependency,\n                                 queue->PersistentContext.release())",
          "old_line_content": "      }",
          "new_line_content": "        finishAndPublishProgress(worker, dependency,",
          "content_same": false
        },
        {
          "line": 1302,
          "old_api": null,
          "new_api": "release",
          "old_text": null,
          "new_text": "queue->PersistentContext.release()",
          "old_line_content": "",
          "new_line_content": "                                 queue->PersistentContext.release());",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": null,
          "new_api": "numTrailingObjects",
          "old_text": null,
          "new_text": "TrailingObjects::template additionalSizeToAlloc<Objects...>(\n        asImpl().numTrailingObjects(OverloadToken<Objects>())...)",
          "old_line_content": "struct alignas(PrivateMetadataTrackingAlignment) MetadataWaitQueue :",
          "new_line_content": "    return TrailingObjects::template additionalSizeToAlloc<Objects...>(",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": null,
          "new_api": "OverloadToken<Objects>()",
          "old_text": null,
          "new_text": "OverloadToken<Objects>()",
          "old_line_content": "  public AtomicWaitQueue<MetadataWaitQueue, ConcurrencyControl::LockType> {",
          "new_line_content": "        asImpl().numTrailingObjects(OverloadToken<Objects>())...);",
          "content_same": false
        },
        {
          "line": 1303,
          "old_api": null,
          "new_api": "getStatusToReturn",
          "old_text": null,
          "new_text": "getStatusToReturn(newState)",
          "old_line_content": "      // Block on the target dependency.",
          "new_line_content": "        return getStatusToReturn(newState);",
          "content_same": false
        },
        {
          "line": 1310,
          "old_api": null,
          "new_api": "notifyWaitingThreadsOfProgress",
          "old_text": null,
          "new_text": "notifyWaitingThreadsOfProgress(worker, dependency)",
          "old_line_content": "  /// Publish a new metadata state.  Wake waiters if we had any.",
          "new_line_content": "        notifyWaitingThreadsOfProgress(worker, dependency);",
          "content_same": false
        },
        {
          "line": 1313,
          "old_api": null,
          "new_api": "getPublishedQueue",
          "old_text": null,
          "new_text": "worker.getPublishedQueue()",
          "old_line_content": "                                PrivateMetadataCompletionContext *context) {",
          "new_line_content": "        queue = worker.getPublishedQueue();",
          "content_same": false
        },
        {
          "line": 1315,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "assert(!queue->PersistentContext ||\n               queue->PersistentContext.get() == context)",
          "old_line_content": "",
          "new_line_content": "        assert(!queue->PersistentContext ||",
          "content_same": false
        },
        {
          "line": 1316,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "queue->PersistentContext.get()",
          "old_line_content": "    // Create a suspended completion if there's something to record there.",
          "new_line_content": "               queue->PersistentContext.get() == context);",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": null,
          "new_api": "blockOnDependency",
          "old_text": null,
          "new_text": "blockOnDependency(worker, request, MetadataStateWithDependency.Dependency)",
          "old_line_content": "    if (dependency || context) {",
          "new_line_content": "      blockOnDependency(worker, request, MetadataStateWithDependency.Dependency);",
          "content_same": false
        },
        {
          "line": 1337,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(newState != PrivateMetadataState::Complete)",
          "old_line_content": "  /// Notify any waiting threads that metadata has made progress.",
          "new_line_content": "      assert(newState != PrivateMetadataState::Complete);",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": null,
          "new_api": "finishAndUnpublishQueue",
          "old_text": null,
          "new_text": "worker.finishAndUnpublishQueue([&] { \n      auto newInfo = PrivateMetadataTrackingInfo(newState, suspended);\n      assert(newInfo.hasAllocatedMetadata());\n\n      // Set the new state and unpublish the reference to the queue.\n      TrackingInfo.store(newInfo, std::memory_order_release);\n    })",
          "old_line_content": "      // If there aren't any other references to the existing queue,",
          "new_line_content": "    worker.finishAndUnpublishQueue([&] { ",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": null,
          "new_api": "PrivateMetadataTrackingInfo",
          "old_text": null,
          "new_text": "PrivateMetadataTrackingInfo(newState, suspended)",
          "old_line_content": "      // we don't need to replace anything.",
          "new_line_content": "      auto newInfo = PrivateMetadataTrackingInfo(newState, suspended);",
          "content_same": false
        },
        {
          "line": 1349,
          "old_api": null,
          "new_api": "store",
          "old_text": null,
          "new_text": "TrackingInfo.store(newInfo, std::memory_order_release)",
          "old_line_content": "      // Otherwise, make a new queue.  Cycling queues this way allows",
          "new_line_content": "      TrackingInfo.store(newInfo, std::memory_order_release);",
          "content_same": false
        },
        {
          "line": 1356,
          "old_api": null,
          "new_api": "maybeReplaceQueue",
          "old_text": null,
          "new_text": "worker.maybeReplaceQueue([&] {\n      MetadataWaitQueue *oldQueue = worker.getPublishedQueue();\n      MetadataWaitQueue *newQueue;\n\n      // If there aren't any other references to the existing queue,\n      // we don't need to replace anything.\n      if (oldQueue->isUniquelyReferenced_locked()) {\n        newQueue = oldQueue;\n\n      // Otherwise, make a new queue.  Cycling queues this way allows\n      // waiting threads to unblock if they are satisfied with the given\n      // progress.  If they aren't, they'll wait on the new queue.\n      } else {\n        newQueue = worker.createReplacementQueue();\n        newQueue->PersistentContext = std::move(oldQueue->PersistentContext);\n      }\n\n      // Update the current blocking dependency.\n      newQueue->BlockingDependency = dependency;\n\n      // Only the worker thread modifies TrackingInfo, so we can do a\n      // simple store instead of a compare-exchange.\n      PrivateMetadataTrackingInfo newTrackingInfo =\n        PrivateMetadataTrackingInfo(worker.getState(), newQueue);\n      TrackingInfo.store(newTrackingInfo, std::memory_order_release);\n\n      // We signal to maybeReplaceQueue that replacement is required by\n      // returning a non-null queue.\n      return (newQueue != oldQueue ? newQueue : nullptr);\n    })",
          "old_line_content": "",
          "new_line_content": "    worker.maybeReplaceQueue([&] {",
          "content_same": false
        },
        {
          "line": 1357,
          "old_api": null,
          "new_api": "getPublishedQueue",
          "old_text": null,
          "new_text": "worker.getPublishedQueue()",
          "old_line_content": "      // Update the current blocking dependency.",
          "new_line_content": "      MetadataWaitQueue *oldQueue = worker.getPublishedQueue();",
          "content_same": false
        },
        {
          "line": 1362,
          "old_api": null,
          "new_api": "isUniquelyReferenced_locked",
          "old_text": null,
          "new_text": "oldQueue->isUniquelyReferenced_locked()",
          "old_line_content": "      PrivateMetadataTrackingInfo newTrackingInfo =",
          "new_line_content": "      if (oldQueue->isUniquelyReferenced_locked()) {",
          "content_same": false
        },
        {
          "line": 1369,
          "old_api": null,
          "new_api": "createReplacementQueue",
          "old_text": null,
          "new_text": "worker.createReplacementQueue()",
          "old_line_content": "    });",
          "new_line_content": "        newQueue = worker.createReplacementQueue();",
          "content_same": false
        },
        {
          "line": 1370,
          "old_api": null,
          "new_api": "std::move(oldQueue->PersistentContext)",
          "old_text": null,
          "new_text": "std::move(oldQueue->PersistentContext)",
          "old_line_content": "  }",
          "new_line_content": "        newQueue->PersistentContext = std::move(oldQueue->PersistentContext);",
          "content_same": false
        },
        {
          "line": 1379,
          "old_api": null,
          "new_api": "getState",
          "old_text": null,
          "new_text": "worker.getState()",
          "old_line_content": "  ///",
          "new_line_content": "        PrivateMetadataTrackingInfo(worker.getState(), newQueue);",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": null,
          "new_api": "store",
          "old_text": null,
          "new_text": "TrackingInfo.store(newTrackingInfo, std::memory_order_release)",
          "old_line_content": "  /// If the request is non-blocking, we do not wait, but we may need",
          "new_line_content": "      TrackingInfo.store(newTrackingInfo, std::memory_order_release);",
          "content_same": false
        },
        {
          "line": 1404,
          "old_api": null,
          "new_api": "check",
          "old_text": null,
          "new_text": "trackingInfo.check(request)",
          "old_line_content": "      switch (checkResult) {",
          "new_line_content": "    auto checkResult = trackingInfo.check(request);",
          "content_same": false
        },
        {
          "line": 1407,
          "old_api": null,
          "new_api": "getState",
          "old_text": null,
          "new_text": "trackingInfo.getState()",
          "old_line_content": "      case PrivateMetadataTrackingInfo::Satisfied:",
          "new_line_content": "      return getStatusToReturn(trackingInfo.getState());",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "  static PrivateMetadataTrackingInfo",
          "new_line_content": "  explicit PrivateMetadataTrackingInfo(PrivateMetadataState state)",
          "content_same": false
        },
        {
          "line": 900,
          "old_api": null,
          "new_api": "RawType",
          "old_text": null,
          "new_text": "RawType(state)",
          "old_line_content": "  initial(MetadataWaitQueue::Worker &worker,",
          "new_line_content": "    : Data(RawType(state)) {}",
          "content_same": false
        },
        {
          "line": 1412,
          "old_api": null,
          "new_api": "withLock",
          "old_text": null,
          "new_text": "worker.withLock([&](MetadataWaitQueue::Worker::Operation &op) {\n      assert(!worker.isWorkerThread());\n\n      // Reload the tracking info, since it might have been\n      // changed by a concurrent worker thread.\n      trackingInfo = TrackingInfo.load(TrackingInfoIsLockedOrder);\n      checkResult = trackingInfo.check(request);\n\n      switch (checkResult) {\n      // Either the request is satisfied or we should tell the\n      // requester immediately that it isn't.\n      case PrivateMetadataTrackingInfo::Satisfied:\n      case PrivateMetadataTrackingInfo::Unsatisfied:\n        return;\n\n      // There's currently an initializing thread for this metadata,\n      // and either we've got a blocking request that isn't yet\n      // satisfied or the metadata hasn't even been allocated yet.\n      // Wait on the thread and then call this lambda again.\n      case PrivateMetadataTrackingInfo::Wait:\n        assert(trackingInfo.hasWaitQueue());\n        return op.waitAndRepeat(trackingInfo.getWaitQueue());\n\n      // There isn't a thread currently building the metadata,\n      // and the request isn't satisfied.  Become the initializing\n      // thread and try to build the metadata ourselves.\n      case PrivateMetadataTrackingInfo::Resume: {\n        assert(!trackingInfo.hasWaitQueue());\n\n        // Create a queue and publish it, taking over execution.\n        auto queue = op.createQueue();\n\n        // Copy the information from the suspended completion, if any,\n        // into the queue.\n        if (auto suspendedCompletion =\n              trackingInfo.getSuspendedCompletion()) {\n          queue->BlockingDependency =\n            suspendedCompletion->BlockingDependency;\n          queue->PersistentContext =\n            std::move(suspendedCompletion->PersistentContext);\n\n          // Make sure we delete the suspended completion later.\n          suspendedCompletionToDelete.reset(suspendedCompletion);\n        }\n\n        // Publish the wait queue we just made.\n        auto newTrackingInfo =\n          PrivateMetadataTrackingInfo(trackingInfo.getState(), queue);\n        TrackingInfo.store(newTrackingInfo, std::memory_order_release);\n\n        return op.flagQueueIsPublished(queue);\n      }\n      }\n    })",
          "old_line_content": "      // and either we've got a blocking request that isn't yet",
          "new_line_content": "    worker.withLock([&](MetadataWaitQueue::Worker::Operation &op) {",
          "content_same": false
        },
        {
          "line": 1413,
          "old_api": null,
          "new_api": "isWorkerThread",
          "old_text": null,
          "new_text": "worker.isWorkerThread()",
          "old_line_content": "      // satisfied or the metadata hasn't even been allocated yet.",
          "new_line_content": "      assert(!worker.isWorkerThread());",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(queue)",
          "old_line_content": "  }",
          "new_line_content": "    assert(queue);",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": null,
          "new_api": "reinterpret_cast<RawType>(queue)",
          "old_text": null,
          "new_text": "reinterpret_cast<RawType>(queue)",
          "old_line_content": "",
          "new_line_content": "    assert(!(reinterpret_cast<RawType>(queue) & AllBitsMask));",
          "content_same": false
        },
        {
          "line": 1418,
          "old_api": null,
          "new_api": "check",
          "old_text": null,
          "new_text": "trackingInfo.check(request)",
          "old_line_content": "",
          "new_line_content": "      checkResult = trackingInfo.check(request);",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": null,
          "new_api": "reinterpret_cast<RawType>(suspended)",
          "old_text": null,
          "new_text": "reinterpret_cast<RawType>(suspended)",
          "old_line_content": "",
          "new_line_content": "    : Data(RawType(state) | reinterpret_cast<RawType>(suspended)) {",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": null,
          "new_api": "reinterpret_cast<RawType>(suspended)",
          "old_text": null,
          "new_text": "reinterpret_cast<RawType>(suspended)",
          "old_line_content": "  /// Does the state mean that we've allocated metadata?",
          "new_line_content": "    assert(!(reinterpret_cast<RawType>(suspended) & AllBitsMask));",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": null,
          "new_api": "createQueue",
          "old_text": null,
          "new_text": "worker.createQueue()",
          "old_line_content": "",
          "new_line_content": "      return PrivateMetadataTrackingInfo(initialState, worker.createQueue());",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": null,
          "new_api": "PrivateMetadataTrackingInfo",
          "old_text": null,
          "new_text": "PrivateMetadataTrackingInfo(initialState)",
          "old_line_content": "  bool hasWaitQueue() const {",
          "new_line_content": "    return PrivateMetadataTrackingInfo(initialState);",
          "content_same": false
        },
        {
          "line": 1432,
          "old_api": null,
          "new_api": "hasWaitQueue",
          "old_text": null,
          "new_text": "trackingInfo.hasWaitQueue()",
          "old_line_content": "          queue->BlockingDependency =",
          "new_line_content": "        assert(trackingInfo.hasWaitQueue());",
          "content_same": false
        },
        {
          "line": 1433,
          "old_api": null,
          "new_api": "getWaitQueue",
          "old_text": null,
          "new_text": "trackingInfo.getWaitQueue()",
          "old_line_content": "            suspendedCompletion->BlockingDependency;",
          "new_line_content": "        return op.waitAndRepeat(trackingInfo.getWaitQueue());",
          "content_same": false
        },
        {
          "line": 1439,
          "old_api": null,
          "new_api": "hasWaitQueue",
          "old_text": null,
          "new_text": "trackingInfo.hasWaitQueue()",
          "old_line_content": "        }",
          "new_line_content": "        assert(!trackingInfo.hasWaitQueue());",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": null,
          "new_api": "getState",
          "old_text": null,
          "new_text": "getState()",
          "old_line_content": "  SuspendedMetadataCompletion *getSuspendedCompletion() const {",
          "new_line_content": "    return getState() != PrivateMetadataState::Allocating;",
          "content_same": false
        },
        {
          "line": 1442,
          "old_api": null,
          "new_api": "createQueue",
          "old_text": null,
          "new_text": "op.createQueue()",
          "old_line_content": "        auto newTrackingInfo =",
          "new_line_content": "        auto queue = op.createQueue();",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": null,
          "new_api": "getState",
          "old_text": null,
          "new_text": "getState()",
          "old_line_content": "  }",
          "new_line_content": "    return getState() == PrivateMetadataState::Complete;",
          "content_same": false
        },
        {
          "line": 1447,
          "old_api": null,
          "new_api": "getSuspendedCompletion",
          "old_text": null,
          "new_text": "trackingInfo.getSuspendedCompletion()",
          "old_line_content": "      }",
          "new_line_content": "              trackingInfo.getSuspendedCompletion()) {",
          "content_same": false
        },
        {
          "line": 1451,
          "old_api": null,
          "new_api": "std::move(suspendedCompletion->PersistentContext)",
          "old_text": null,
          "new_text": "std::move(suspendedCompletion->PersistentContext)",
          "old_line_content": "    // If the check result wasn't Resume, it must have been Satisfied",
          "new_line_content": "            std::move(suspendedCompletion->PersistentContext);",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": null,
          "new_api": "reinterpret_cast<MetadataWaitQueue*>(Data & PointerMask)",
          "old_text": null,
          "new_text": "reinterpret_cast<MetadataWaitQueue*>(Data & PointerMask)",
          "old_line_content": "      return dependency->BlockingDependency;",
          "new_line_content": "      return reinterpret_cast<MetadataWaitQueue*>(Data & PointerMask);",
          "content_same": false
        },
        {
          "line": 1459,
          "old_api": null,
          "new_api": "getState",
          "old_text": null,
          "new_text": "trackingInfo.getState()",
          "old_line_content": "    // Otherwise, we published and are now the worker thread owning",
          "new_line_content": "          PrivateMetadataTrackingInfo(trackingInfo.getState(), queue);",
          "content_same": false
        },
        {
          "line": 948,
          "old_api": null,
          "new_api": "reinterpret_cast<SuspendedMetadataCompletion*>(Data & PointerMask)",
          "old_text": null,
          "new_text": "reinterpret_cast<SuspendedMetadataCompletion*>(Data & PointerMask)",
          "old_line_content": "  }",
          "new_line_content": "      return reinterpret_cast<SuspendedMetadataCompletion*>(Data & PointerMask);",
          "content_same": false
        },
        {
          "line": 1460,
          "old_api": null,
          "new_api": "store",
          "old_text": null,
          "new_text": "TrackingInfo.store(newTrackingInfo, std::memory_order_release)",
          "old_line_content": "    // this metadata's initialization.  Do the initialization.",
          "new_line_content": "        TrackingInfo.store(newTrackingInfo, std::memory_order_release);",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": null,
          "new_api": "getWaitQueue",
          "old_text": null,
          "new_text": "getWaitQueue()",
          "old_line_content": "    /// should report that immediately.",
          "new_line_content": "    if (auto queue = getWaitQueue())",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": null,
          "new_api": "getSuspendedCompletion",
          "old_text": null,
          "new_text": "getSuspendedCompletion()",
          "old_line_content": "",
          "new_line_content": "    if (auto dependency = getSuspendedCompletion())",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": null,
          "new_api": "MetadataDependency",
          "old_text": null,
          "new_text": "MetadataDependency()",
          "old_line_content": "    /// must wait for another thread to complete the initialization.",
          "new_line_content": "    return MetadataDependency();",
          "content_same": false
        },
        {
          "line": 1472,
          "old_api": null,
          "new_api": "getState",
          "old_text": null,
          "new_text": "trackingInfo.getState()",
          "old_line_content": "",
          "new_line_content": "      return getStatusToReturn(trackingInfo.getState());",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": null,
          "new_api": "getState",
          "old_text": null,
          "new_text": "getState()",
          "old_line_content": "    /// should try to complete the initialization itself.",
          "new_line_content": "    return swift::satisfies(getState(), requirement);",
          "content_same": false
        },
        {
          "line": 1477,
          "old_api": null,
          "new_api": "getState",
          "old_text": null,
          "new_text": "trackingInfo.getState()",
          "old_line_content": "    // Block on the metadata dependency.",
          "new_line_content": "    worker.setState(trackingInfo.getState());",
          "content_same": false
        },
        {
          "line": 1486,
          "old_api": null,
          "new_api": "isWorkerThread",
          "old_text": null,
          "new_text": "worker.isWorkerThread()",
          "old_line_content": "  /// other thread is currently still attempting to complete the first",
          "new_line_content": "    assert(worker.isWorkerThread());",
          "content_same": false
        },
        {
          "line": 1487,
          "old_api": null,
          "new_api": "isBlocking",
          "old_text": null,
          "new_text": "request.isBlocking()",
          "old_line_content": "  /// full round of attempted initialization.  It's also possible",
          "new_line_content": "    assert(request.isBlocking());",
          "content_same": false
        },
        {
          "line": 1490,
          "old_api": null,
          "new_api": "getValue",
          "old_text": null,
          "new_text": "asImpl().getValue()",
          "old_line_content": "  checkDependency(ConcurrencyControl &concurrency, MetadataState requirement) {",
          "new_line_content": "    auto requestDependency = MetadataDependency(asImpl().getValue(),",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": null,
          "new_api": "getState",
          "old_text": null,
          "new_text": "request.getState()",
          "old_line_content": "    // Do a quick check while not holding the lock.",
          "new_line_content": "                                                request.getState());",
          "content_same": false
        },
        {
          "line": 1508,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "TrackingInfo.load(std::memory_order_acquire)",
          "old_line_content": "",
          "new_line_content": "    auto curInfo = TrackingInfo.load(std::memory_order_acquire);",
          "content_same": false
        },
        {
          "line": 1509,
          "old_api": null,
          "new_api": "satisfies",
          "old_text": null,
          "new_text": "curInfo.satisfies(requirement)",
          "old_line_content": "/// An convenient subclass of MetadataCacheEntryBase which provides",
          "new_line_content": "    if (curInfo.satisfies(requirement))",
          "content_same": false
        },
        {
          "line": 1510,
          "old_api": null,
          "new_api": "MetadataDependency",
          "old_text": null,
          "new_text": "MetadataDependency()",
          "old_line_content": "/// metadata lookup using a variadic key.",
          "new_line_content": "      return { curInfo.getState(), MetadataDependency() };",
          "content_same": false
        },
        {
          "line": 1000,
          "old_api": null,
          "new_api": "getState",
          "old_text": null,
          "new_text": "request.getState()",
          "old_line_content": "  }",
          "new_line_content": "      if (satisfies(request.getState()))",
          "content_same": false
        },
        {
          "line": 1514,
          "old_api": null,
          "new_api": "withLock",
          "old_text": null,
          "new_text": "concurrency.Lock.withLock([&]() -> MetadataStateWithDependency {\n      curInfo = TrackingInfo.load(TrackingInfoIsLockedOrder);\n\n      if (curInfo.satisfies(requirement))\n        return { curInfo.getState(), MetadataDependency() };\n\n      return { curInfo.getState(), curInfo.getBlockingDependency_locked() };\n    })",
          "old_line_content": "  using super = MetadataCacheEntryBase<Impl, const void *, Objects...>;",
          "new_line_content": "    return concurrency.Lock.withLock([&]() -> MetadataStateWithDependency {",
          "content_same": false
        },
        {
          "line": 1515,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "TrackingInfo.load(TrackingInfoIsLockedOrder)",
          "old_line_content": "",
          "new_line_content": "      curInfo = TrackingInfo.load(TrackingInfoIsLockedOrder);",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": null,
          "new_api": "hasWaitQueue",
          "old_text": null,
          "new_text": "hasWaitQueue()",
          "old_line_content": "inline bool shouldBlockInitialization(PrivateMetadataState currentState,",
          "new_line_content": "      if (!hasWaitQueue())",
          "content_same": false
        },
        {
          "line": 1517,
          "old_api": null,
          "new_api": "satisfies",
          "old_text": null,
          "new_text": "curInfo.satisfies(requirement)",
          "old_line_content": "  using super::asImpl;",
          "new_line_content": "      if (curInfo.satisfies(requirement))",
          "content_same": false
        },
        {
          "line": 1518,
          "old_api": null,
          "new_api": "MetadataDependency",
          "old_text": null,
          "new_text": "MetadataDependency()",
          "old_line_content": "",
          "new_line_content": "        return { curInfo.getState(), MetadataDependency() };",
          "content_same": false
        },
        {
          "line": 1520,
          "old_api": null,
          "new_api": "getBlockingDependency_locked",
          "old_text": null,
          "new_text": "curInfo.getBlockingDependency_locked()",
          "old_line_content": "",
          "new_line_content": "      return { curInfo.getState(), curInfo.getBlockingDependency_locked() };",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1538,
          "old_api": "size",
          "new_api": null,
          "old_text": "key.size()",
          "new_text": null,
          "old_line_content": "    return key.size();",
          "new_line_content": "  friend TrailingObjectsEntry;",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": "swift_unreachable",
          "new_api": null,
          "old_text": "swift_unreachable(\"bad state\")",
          "new_text": null,
          "old_line_content": "  swift_unreachable(\"bad state\");",
          "new_line_content": "/// Given that this is the initializing thread, and we've reached the",
          "content_same": false
        },
        {
          "line": 1563,
          "old_api": "layout",
          "new_api": null,
          "old_text": "key.layout()",
          "new_text": null,
          "old_line_content": "        Layout(key.layout()),",
          "new_line_content": "  ValueType Value;",
          "content_same": false
        },
        {
          "line": 1564,
          "old_api": "hash",
          "new_api": null,
          "old_text": "key.hash()",
          "new_text": null,
          "old_line_content": "        Hash(key.hash()),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1566,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert((value != nullptr) ==\n           (initialState != PrivateMetadataState::Allocating))",
          "new_text": null,
          "old_line_content": "    assert((value != nullptr) ==",
          "new_line_content": "  ValueType getValue() {",
          "content_same": false
        },
        {
          "line": 1568,
          "old_api": "this->template getTrailingObjects<const void *>()",
          "new_api": null,
          "old_text": "this->template getTrailingObjects<const void *>()",
          "new_text": null,
          "old_line_content": "    key.installInto(this->template getTrailingObjects<const void *>());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1572,
          "old_api": "MetadataCacheKey",
          "new_api": null,
          "old_text": "MetadataCacheKey(Layout,\n                            this->template getTrailingObjects<const void*>(),\n                            Hash)",
          "new_text": null,
          "old_line_content": "    return MetadataCacheKey(Layout,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1573,
          "old_api": "this->template getTrailingObjects<const void*>()",
          "new_api": null,
          "old_text": "this->template getTrailingObjects<const void*>()",
          "new_text": null,
          "old_line_content": "                            this->template getTrailingObjects<const void*>(),",
          "new_line_content": "public:",
          "content_same": false
        },
        {
          "line": 1586,
          "old_api": "getKey",
          "new_api": null,
          "old_text": "getKey()",
          "new_text": null,
          "old_line_content": "    return key == getKey();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1094,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "  static constexpr std::memory_order TrackingInfoIsLockedOrder =",
          "new_line_content": "  /// path of several operations on the entry, most importantly",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": "PrivateMetadataTrackingInfo::initial(worker, initialState)",
          "new_api": null,
          "old_text": "PrivateMetadataTrackingInfo::initial(worker, initialState)",
          "new_text": null,
          "old_line_content": "      : TrackingInfo(PrivateMetadataTrackingInfo::initial(worker, initialState)) {",
          "new_line_content": "  ///   with the initializing thread.",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": "awaitSatisfyingState",
          "new_api": null,
          "old_text": "awaitSatisfyingState(concurrency, request)",
          "new_text": null,
          "old_line_content": "    return awaitSatisfyingState(concurrency, request);",
          "new_line_content": "                         PrivateMetadataState initialState =",
          "content_same": false
        },
        {
          "line": 1119,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(state != PrivateMetadataState::Allocating)",
          "new_text": null,
          "old_line_content": "    assert(state != PrivateMetadataState::Allocating);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": "getAccomplishedRequestState",
          "new_api": null,
          "old_text": "getAccomplishedRequestState(state)",
          "new_text": null,
          "old_line_content": "    return { asImpl().getValue(), getAccomplishedRequestState(state) };",
          "new_line_content": "  // Note that having an explicit destructor here is important to make this",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": "begin",
          "new_api": null,
          "old_text": "rhs.begin()",
          "new_text": null,
          "old_line_content": "    auto *bdata = rhs.begin();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1138,
          "old_api": "getState",
          "new_api": null,
          "old_text": "worker.getState()",
          "new_text": null,
          "old_line_content": "    auto state = worker.getState();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1143,
          "old_api": "std::forward<Args>(args)",
          "new_api": null,
          "old_text": "std::forward<Args>(args)",
          "new_text": null,
          "old_line_content": "      if (asImpl().allowMangledNameVerification(std::forward<Args>(args)...))",
          "new_line_content": "  };",
          "content_same": false
        },
        {
          "line": 1144,
          "old_api": "getValue",
          "new_api": null,
          "old_text": "asImpl().getValue()",
          "new_text": null,
          "old_line_content": "        verifyMangledNameRoundtrip(asImpl().getValue());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(packs[packIdx].ShapeClass < Layout.NumShapeClasses)",
          "new_text": null,
          "old_line_content": "        assert(packs[packIdx].ShapeClass < Layout.NumShapeClasses);",
          "new_line_content": "    for (unsigned i = 0; i != Layout.NumShapeClasses; ++i) {",
          "content_same": false
        },
        {
          "line": 1149,
          "old_api": "isWorkerThread",
          "new_api": null,
          "old_text": "worker.isWorkerThread()",
          "new_text": null,
          "old_line_content": "        assert(!worker.isWorkerThread());",
          "new_line_content": "                                        Args &&...args) {",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": "getValue",
          "new_api": null,
          "old_text": "asImpl().getValue()",
          "new_text": null,
          "old_line_content": "        return Status{asImpl().getValue(), MetadataState::Complete};",
          "new_line_content": "    // Returning a non-None value here will preempt initialization, so we",
          "content_same": false
        },
        {
          "line": 639,
          "old_api": "areMetadataPacksEqual",
          "new_api": null,
          "old_text": "areMetadataPacksEqual(adata[argIdx], bdata[argIdx], count)",
          "new_text": null,
          "old_line_content": "        if (!areMetadataPacksEqual(adata[argIdx], bdata[argIdx], count))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1158,
          "old_api": "isWorkerThread",
          "new_api": null,
          "old_text": "worker.isWorkerThread()",
          "new_text": null,
          "old_line_content": "    assert(worker.isWorkerThread());",
          "new_line_content": "      // so we can verify that the mangled name round-trips.",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": "std::forward<Args>(args)",
          "new_api": null,
          "old_text": "std::forward<Args>(args)",
          "new_text": null,
          "old_line_content": "      asImpl().allocate(std::forward<Args>(args)...);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1164,
          "old_api": "setState",
          "new_api": null,
          "old_text": "worker.setState(state)",
          "new_text": null,
          "old_line_content": "    worker.setState(state);",
          "new_line_content": "      if (state == PrivateMetadataState::Complete) {",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": "const_cast<ValueType>(allocationResult.Value)",
          "new_api": null,
          "old_text": "const_cast<ValueType>(allocationResult.Value)",
          "new_text": null,
          "old_line_content": "    auto value = const_cast<ValueType>(allocationResult.Value);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": "setValue",
          "new_api": null,
          "old_text": "asImpl().setValue(value)",
          "new_text": null,
          "old_line_content": "    asImpl().setValue(value);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(packs[packIdx].ShapeClass < Layout.NumShapeClasses)",
          "new_text": null,
          "old_line_content": "        assert(packs[packIdx].ShapeClass < Layout.NumShapeClasses);",
          "new_line_content": "        ++argIdx;",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": "MetadataDependency",
          "new_api": null,
          "old_text": "MetadataDependency()",
          "new_text": null,
          "old_line_content": "      finishAndPublishProgress(worker, MetadataDependency(), nullptr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": "areWitnessTablePacksEqual",
          "new_api": null,
          "old_text": "areWitnessTablePacksEqual(adata[argIdx], bdata[argIdx], count)",
          "new_text": null,
          "old_line_content": "        if (!areWitnessTablePacksEqual(adata[argIdx], bdata[argIdx], count))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1179,
          "old_api": "verifyMangledNameRoundtrip",
          "new_api": null,
          "old_text": "verifyMangledNameRoundtrip(value)",
          "new_text": null,
          "old_line_content": "        verifyMangledNameRoundtrip(value);",
          "new_line_content": "    state = allocationResult.State;",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": "areWitnessTablesEqual",
          "new_api": null,
          "old_text": "areWitnessTablesEqual((const WitnessTable *)adata[argIdx],\n                                 (const WitnessTable *)bdata[argIdx])",
          "new_text": null,
          "old_line_content": "      if (!areWitnessTablesEqual((const WitnessTable *)adata[argIdx],",
          "new_line_content": "    for (unsigned i = 0; i != Layout.NumWitnessTables; ++i) {",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(packIdx == Layout.NumPacks && \"Missed a pack\")",
          "new_text": null,
          "old_line_content": "    assert(packIdx == Layout.NumPacks && \"Missed a pack\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1190,
          "old_api": "MetadataDependency",
          "new_api": null,
          "old_text": "MetadataDependency()",
          "new_text": null,
          "old_line_content": "    notifyWaitingThreadsOfProgress(worker, MetadataDependency());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1196,
          "old_api": "verifyMangledNameRoundtrip",
          "new_api": null,
          "old_text": "verifyMangledNameRoundtrip(value)",
          "new_text": null,
          "old_line_content": "      verifyMangledNameRoundtrip(value);",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": "size",
          "new_api": null,
          "old_text": "size()",
          "new_text": null,
          "old_line_content": "  const void * const *end() const { return Data + size(); }",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 696,
          "old_api": "sizeInWords",
          "new_api": null,
          "old_text": "MetadataCacheKey::installGenericArguments(\n        Layout.sizeInWords(),\n        Layout.NumPacks,\n        Layout.PackShapeDescriptors,\n        buffer, Data)",
          "new_text": null,
          "old_line_content": "    MetadataCacheKey::installGenericArguments(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 697,
          "old_api": "sizeInWords",
          "new_api": null,
          "old_text": "Layout.sizeInWords()",
          "new_text": null,
          "old_line_content": "        Layout.sizeInWords(),",
          "new_line_content": "  uint32_t hash() const {",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": "doInitialization",
          "new_api": null,
          "old_text": "doInitialization(worker, request)",
          "new_text": null,
          "old_line_content": "    return doInitialization(worker, request);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1223,
          "old_api": "isWorkerThread",
          "new_api": null,
          "old_text": "worker.isWorkerThread()",
          "new_text": null,
          "old_line_content": "    assert(worker.isWorkerThread());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1225,
          "old_api": "getState",
          "new_api": null,
          "old_text": "worker.getState()",
          "new_text": null,
          "old_line_content": "    assert(worker.getState() > PrivateMetadataState::Allocating);",
          "new_line_content": "  template <class... Args>",
          "content_same": false
        },
        {
          "line": 1226,
          "old_api": "getValue",
          "new_api": null,
          "old_text": "asImpl().getValue()",
          "new_text": null,
          "old_line_content": "    auto value = asImpl().getValue();",
          "new_line_content": "  Status beginInitialization(WaitQueue::Worker &worker,",
          "content_same": false
        },
        {
          "line": 1228,
          "old_api": "getPublishedQueue",
          "new_api": null,
          "old_text": "worker.getPublishedQueue()",
          "new_text": null,
          "old_line_content": "    auto queue = worker.getPublishedQueue();",
          "new_line_content": "    // Note that we ignore the extra arguments; those are just for the",
          "content_same": false
        },
        {
          "line": 1231,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "    static const constexpr PrivateMetadataCompletionContext zeroContext = {};",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1234,
          "old_api": "get",
          "new_api": null,
          "old_text": "queue->PersistentContext.get()",
          "new_text": null,
          "old_line_content": "    if (auto persistent = queue->PersistentContext.get()) {",
          "new_line_content": "  /// Try to complete the metadata.",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(packs[packIdx].ShapeClass < Layout.NumShapeClasses)",
          "new_text": null,
          "old_line_content": "        assert(packs[packIdx].ShapeClass < Layout.NumShapeClasses);",
          "new_line_content": "    unsigned packIdx = 0;",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": "reinterpret_cast<uintptr_t>(Data[packs[packIdx].ShapeClass])",
          "new_api": null,
          "old_text": "reinterpret_cast<uintptr_t>(Data[packs[packIdx].ShapeClass])",
          "new_text": null,
          "old_line_content": "        auto count = reinterpret_cast<uintptr_t>(Data[packs[packIdx].ShapeClass]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": "getElements",
          "new_api": null,
          "old_text": "pack.getElements()",
          "new_text": null,
          "old_line_content": "          update(reinterpret_cast<uintptr_t>(pack.getElements()[j]));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1246,
          "old_api": "getState",
          "new_api": null,
          "old_text": "worker.getState()",
          "new_text": null,
          "old_line_content": "      assert(worker.getState() < PrivateMetadataState::Complete);",
          "new_line_content": "    // Figure out a completion context to use.",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": "reinterpret_cast<uintptr_t>(Data[i])",
          "new_api": null,
          "old_text": "reinterpret_cast<uintptr_t>(Data[i])",
          "new_text": null,
          "old_line_content": "      update(reinterpret_cast<uintptr_t>(Data[i]));",
          "new_line_content": "         i != e; ++i) {",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": "getState",
          "new_api": null,
          "old_text": "worker.getState()",
          "new_text": null,
          "old_line_content": "      auto oldState = worker.getState();",
          "new_line_content": "    PrivateMetadataCompletionContext *context;",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": "tryInitialize",
          "new_api": null,
          "old_text": "asImpl().tryInitialize(value, oldState, context)",
          "new_text": null,
          "old_line_content": "        asImpl().tryInitialize(value, oldState, context);",
          "new_line_content": "      context = persistent;",
          "content_same": false
        },
        {
          "line": 1254,
          "old_api": "setState",
          "new_api": null,
          "old_text": "worker.setState(newState)",
          "new_text": null,
          "old_line_content": "      worker.setState(newState);",
          "new_line_content": "      scratchContext = zeroContext;",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(oldState <= newState &&\n             \"initialization regressed to an earlier state\")",
          "new_text": null,
          "old_line_content": "      assert(oldState <= newState &&",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": "static_cast<Impl &>(*this)",
          "new_api": null,
          "old_text": "static_cast<Impl &>(*this)",
          "new_text": null,
          "old_line_content": "  Impl &asImpl() { return static_cast<Impl &>(*this); }",
          "new_line_content": "/// A helper class for ConcurrentMap entry types which allows trailing objects",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": "static_cast<const Impl &>(*this)",
          "new_api": null,
          "old_text": "static_cast<const Impl &>(*this)",
          "new_text": null,
          "old_line_content": "  const Impl &asImpl() const { return static_cast<const Impl &>(*this); }",
          "new_line_content": "/// objects and automatically implements the getExtraAllocationSize methods",
          "content_same": false
        },
        {
          "line": 1277,
          "old_api": "memcmp",
          "new_api": null,
          "old_text": "memcmp(&scratchContext, &zeroContext, sizeof(zeroContext))",
          "new_text": null,
          "old_line_content": "        if (memcmp(&scratchContext, &zeroContext, sizeof(zeroContext)) != 0)",
          "new_line_content": "      if (!dependency) {",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": "TrailingObjects::template additionalSizeToAlloc<Objects...>(\n        Impl::numTrailingObjects(OverloadToken<Objects>(), key, args...)...)",
          "new_api": null,
          "old_text": "TrailingObjects::template additionalSizeToAlloc<Objects...>(\n        Impl::numTrailingObjects(OverloadToken<Objects>(), key, args...)...)",
          "new_text": null,
          "old_line_content": "    return TrailingObjects::template additionalSizeToAlloc<Objects...>(",
          "new_line_content": "struct ConcurrentMapTrailingObjectsEntry",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": "OverloadToken<Objects>()",
          "new_api": null,
          "old_text": "OverloadToken<Objects>()",
          "new_text": null,
          "old_line_content": "        Impl::numTrailingObjects(OverloadToken<Objects>(), key, args...)...);",
          "new_line_content": "    : swift::ABI::TrailingObjects<Impl, Objects...> {",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": "release",
          "new_api": null,
          "old_text": "finishAndPublishProgress(worker, dependency,\n                                 queue->PersistentContext.release())",
          "new_text": null,
          "old_line_content": "        finishAndPublishProgress(worker, dependency,",
          "new_line_content": "        done = false;",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": "numTrailingObjects",
          "new_api": null,
          "old_text": "TrailingObjects::template additionalSizeToAlloc<Objects...>(\n        asImpl().numTrailingObjects(OverloadToken<Objects>())...)",
          "new_text": null,
          "old_line_content": "    return TrailingObjects::template additionalSizeToAlloc<Objects...>(",
          "new_line_content": "      swift::ABI::TrailingObjects<Impl, Objects...>;",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": "OverloadToken<Objects>()",
          "new_api": null,
          "old_text": "OverloadToken<Objects>()",
          "new_text": null,
          "old_line_content": "        asImpl().numTrailingObjects(OverloadToken<Objects>())...);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1287,
          "old_api": "getStatusToReturn",
          "new_api": null,
          "old_text": "getStatusToReturn(newState)",
          "new_text": null,
          "old_line_content": "        return getStatusToReturn(newState);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1297,
          "old_api": "getPublishedQueue",
          "new_api": null,
          "old_text": "worker.getPublishedQueue()",
          "new_text": null,
          "old_line_content": "        queue = worker.getPublishedQueue();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1299,
          "old_api": "get",
          "new_api": null,
          "old_text": "assert(!queue->PersistentContext ||\n               queue->PersistentContext.get() == context)",
          "new_text": null,
          "old_line_content": "        assert(!queue->PersistentContext ||",
          "new_line_content": "      // execution.",
          "content_same": false
        },
        {
          "line": 1300,
          "old_api": "get",
          "new_api": null,
          "old_text": "queue->PersistentContext.get()",
          "new_text": null,
          "old_line_content": "               queue->PersistentContext.get() == context);",
          "new_line_content": "      if (!willWait) {",
          "content_same": false
        },
        {
          "line": 1304,
          "old_api": "blockOnDependency",
          "new_api": null,
          "old_text": "blockOnDependency(worker, request, MetadataStateWithDependency.Dependency)",
          "new_text": null,
          "old_line_content": "      blockOnDependency(worker, request, MetadataStateWithDependency.Dependency);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1314,
          "old_api": "getState",
          "new_api": null,
          "old_text": "worker.getState()",
          "new_text": null,
          "old_line_content": "    auto newState = worker.getState();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1321,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(newState != PrivateMetadataState::Complete)",
          "new_text": null,
          "old_line_content": "      assert(newState != PrivateMetadataState::Complete);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1328,
          "old_api": "finishAndUnpublishQueue",
          "new_api": null,
          "old_text": "worker.finishAndUnpublishQueue([&] { \n      auto newInfo = PrivateMetadataTrackingInfo(newState, suspended);\n      assert(newInfo.hasAllocatedMetadata());\n\n      // Set the new state and unpublish the reference to the queue.\n      TrackingInfo.store(newInfo, std::memory_order_release);\n    })",
          "new_text": null,
          "old_line_content": "    worker.finishAndUnpublishQueue([&] { ",
          "new_line_content": "                                MetadataDependency dependency,",
          "content_same": false
        },
        {
          "line": 1329,
          "old_api": "PrivateMetadataTrackingInfo",
          "new_api": null,
          "old_text": "PrivateMetadataTrackingInfo(newState, suspended)",
          "new_text": null,
          "old_line_content": "      auto newInfo = PrivateMetadataTrackingInfo(newState, suspended);",
          "new_line_content": "                                PrivateMetadataCompletionContext *context) {",
          "content_same": false
        },
        {
          "line": 1333,
          "old_api": "store",
          "new_api": null,
          "old_text": "TrackingInfo.store(newInfo, std::memory_order_release)",
          "new_text": null,
          "old_line_content": "      TrackingInfo.store(newInfo, std::memory_order_release);",
          "new_line_content": "    // This will be deallocated when some other thread takes over",
          "content_same": false
        },
        {
          "line": 1340,
          "old_api": "maybeReplaceQueue",
          "new_api": null,
          "old_text": "worker.maybeReplaceQueue([&] {\n      MetadataWaitQueue *oldQueue = worker.getPublishedQueue();\n      MetadataWaitQueue *newQueue;\n\n      // If there aren't any other references to the existing queue,\n      // we don't need to replace anything.\n      if (oldQueue->isUniquelyReferenced_locked()) {\n        newQueue = oldQueue;\n\n      // Otherwise, make a new queue.  Cycling queues this way allows\n      // waiting threads to unblock if they are satisfied with the given\n      // progress.  If they aren't, they'll wait on the new queue.\n      } else {\n        newQueue = worker.createReplacementQueue();\n        newQueue->PersistentContext = std::move(oldQueue->PersistentContext);\n      }\n\n      // Update the current blocking dependency.\n      newQueue->BlockingDependency = dependency;\n\n      // Only the worker thread modifies TrackingInfo, so we can do a\n      // simple store instead of a compare-exchange.\n      PrivateMetadataTrackingInfo newTrackingInfo =\n        PrivateMetadataTrackingInfo(worker.getState(), newQueue);\n      TrackingInfo.store(newTrackingInfo, std::memory_order_release);\n\n      // We signal to maybeReplaceQueue that replacement is required by\n      // returning a non-null queue.\n      return (newQueue != oldQueue ? newQueue : nullptr);\n    })",
          "new_text": null,
          "old_line_content": "    worker.maybeReplaceQueue([&] {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1341,
          "old_api": "getPublishedQueue",
          "new_api": null,
          "old_text": "worker.getPublishedQueue()",
          "new_text": null,
          "old_line_content": "      MetadataWaitQueue *oldQueue = worker.getPublishedQueue();",
          "new_line_content": "    // We're done with this worker thread; replace the wait queue",
          "content_same": false
        },
        {
          "line": 1353,
          "old_api": "createReplacementQueue",
          "new_api": null,
          "old_text": "worker.createReplacementQueue()",
          "new_text": null,
          "old_line_content": "        newQueue = worker.createReplacementQueue();",
          "new_line_content": "  /// Notify any waiting threads that metadata has made progress.",
          "content_same": false
        },
        {
          "line": 1354,
          "old_api": "std::move(oldQueue->PersistentContext)",
          "new_api": null,
          "old_text": "std::move(oldQueue->PersistentContext)",
          "new_text": null,
          "old_line_content": "        newQueue->PersistentContext = std::move(oldQueue->PersistentContext);",
          "new_line_content": "  void notifyWaitingThreadsOfProgress(MetadataWaitQueue::Worker &worker,",
          "content_same": false
        },
        {
          "line": 1363,
          "old_api": "getState",
          "new_api": null,
          "old_text": "worker.getState()",
          "new_text": null,
          "old_line_content": "        PrivateMetadataTrackingInfo(worker.getState(), newQueue);",
          "new_line_content": "        newQueue = oldQueue;",
          "content_same": false
        },
        {
          "line": 1364,
          "old_api": "store",
          "new_api": null,
          "old_text": "TrackingInfo.store(newTrackingInfo, std::memory_order_release)",
          "new_text": null,
          "old_line_content": "      TrackingInfo.store(newTrackingInfo, std::memory_order_release);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1385,
          "old_api": "load",
          "new_api": null,
          "old_text": "TrackingInfo.load(std::memory_order_acquire)",
          "new_text": null,
          "old_line_content": "    auto trackingInfo = TrackingInfo.load(std::memory_order_acquire);",
          "new_line_content": "    });",
          "content_same": false
        },
        {
          "line": 1388,
          "old_api": "check",
          "new_api": null,
          "old_text": "trackingInfo.check(request)",
          "new_text": null,
          "old_line_content": "    auto checkResult = trackingInfo.check(request);",
          "new_line_content": "  /// Given that the request is not satisfied by the current state of",
          "content_same": false
        },
        {
          "line": 1391,
          "old_api": "getState",
          "new_api": null,
          "old_text": "trackingInfo.getState()",
          "new_text": null,
          "old_line_content": "      return getStatusToReturn(trackingInfo.getState());",
          "new_line_content": "  /// If there's a thread that currently owns initialization for this",
          "content_same": false
        },
        {
          "line": 883,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit PrivateMetadataTrackingInfo(PrivateMetadataState state)",
          "new_line_content": "    StateMask = 0x7,",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": "RawType",
          "new_api": null,
          "old_text": "RawType(state)",
          "new_text": null,
          "old_line_content": "    : Data(RawType(state)) {}",
          "new_line_content": "    PointerIsWaitQueueMask = 0x8,",
          "content_same": false
        },
        {
          "line": 1396,
          "old_api": "withLock",
          "new_api": null,
          "old_text": "worker.withLock([&](MetadataWaitQueue::Worker::Operation &op) {\n      assert(!worker.isWorkerThread());\n\n      // Reload the tracking info, since it might have been\n      // changed by a concurrent worker thread.\n      trackingInfo = TrackingInfo.load(TrackingInfoIsLockedOrder);\n      checkResult = trackingInfo.check(request);\n\n      switch (checkResult) {\n      // Either the request is satisfied or we should tell the\n      // requester immediately that it isn't.\n      case PrivateMetadataTrackingInfo::Satisfied:\n      case PrivateMetadataTrackingInfo::Unsatisfied:\n        return;\n\n      // There's currently an initializing thread for this metadata,\n      // and either we've got a blocking request that isn't yet\n      // satisfied or the metadata hasn't even been allocated yet.\n      // Wait on the thread and then call this lambda again.\n      case PrivateMetadataTrackingInfo::Wait:\n        assert(trackingInfo.hasWaitQueue());\n        return op.waitAndRepeat(trackingInfo.getWaitQueue());\n\n      // There isn't a thread currently building the metadata,\n      // and the request isn't satisfied.  Become the initializing\n      // thread and try to build the metadata ourselves.\n      case PrivateMetadataTrackingInfo::Resume: {\n        assert(!trackingInfo.hasWaitQueue());\n\n        // Create a queue and publish it, taking over execution.\n        auto queue = op.createQueue();\n\n        // Copy the information from the suspended completion, if any,\n        // into the queue.\n        if (auto suspendedCompletion =\n              trackingInfo.getSuspendedCompletion()) {\n          queue->BlockingDependency =\n            suspendedCompletion->BlockingDependency;\n          queue->PersistentContext =\n            std::move(suspendedCompletion->PersistentContext);\n\n          // Make sure we delete the suspended completion later.\n          suspendedCompletionToDelete.reset(suspendedCompletion);\n        }\n\n        // Publish the wait queue we just made.\n        auto newTrackingInfo =\n          PrivateMetadataTrackingInfo(trackingInfo.getState(), queue);\n        TrackingInfo.store(newTrackingInfo, std::memory_order_release);\n\n        return op.flagQueueIsPublished(queue);\n      }\n      }\n    })",
          "new_text": null,
          "old_line_content": "    worker.withLock([&](MetadataWaitQueue::Worker::Operation &op) {",
          "new_line_content": "  /// If the request is non-blocking, we do not wait, but we may need",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit PrivateMetadataTrackingInfo(PrivateMetadataState state,",
          "new_line_content": "    PointerMask = ~AllBitsMask,",
          "content_same": false
        },
        {
          "line": 1397,
          "old_api": "isWorkerThread",
          "new_api": null,
          "old_text": "worker.isWorkerThread()",
          "new_text": null,
          "old_line_content": "      assert(!worker.isWorkerThread());",
          "new_line_content": "  /// to take over initialization.",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": "reinterpret_cast<RawType>(queue)",
          "new_api": null,
          "old_text": "reinterpret_cast<RawType>(queue)",
          "new_text": null,
          "old_line_content": "    : Data(RawType(state) | reinterpret_cast<RawType>(queue)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(queue)",
          "new_text": null,
          "old_line_content": "    assert(queue);",
          "new_line_content": "                \"too many bits for alignment\");",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": "reinterpret_cast<RawType>(queue)",
          "new_api": null,
          "old_text": "reinterpret_cast<RawType>(queue)",
          "new_text": null,
          "old_line_content": "    assert(!(reinterpret_cast<RawType>(queue) & AllBitsMask));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1402,
          "old_api": "check",
          "new_api": null,
          "old_text": "trackingInfo.check(request)",
          "new_text": null,
          "old_line_content": "      checkResult = trackingInfo.check(request);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit PrivateMetadataTrackingInfo(PrivateMetadataState state,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": "reinterpret_cast<RawType>(suspended)",
          "new_api": null,
          "old_text": "reinterpret_cast<RawType>(suspended)",
          "new_text": null,
          "old_line_content": "    : Data(RawType(state) | reinterpret_cast<RawType>(suspended)) {",
          "new_line_content": "  // Some std::atomic implementations require a default constructor",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": "reinterpret_cast<RawType>(suspended)",
          "new_api": null,
          "old_text": "reinterpret_cast<RawType>(suspended)",
          "new_text": null,
          "old_line_content": "    assert(!(reinterpret_cast<RawType>(suspended) & AllBitsMask));",
          "new_line_content": "  // for no apparent reason.",
          "content_same": false
        },
        {
          "line": 1416,
          "old_api": "hasWaitQueue",
          "new_api": null,
          "old_text": "trackingInfo.hasWaitQueue()",
          "new_text": null,
          "old_line_content": "        assert(trackingInfo.hasWaitQueue());",
          "new_line_content": "      // changed by a concurrent worker thread.",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": "PrivateMetadataTrackingInfo",
          "new_api": null,
          "old_text": "PrivateMetadataTrackingInfo(initialState)",
          "new_text": null,
          "old_line_content": "    return PrivateMetadataTrackingInfo(initialState);",
          "new_line_content": "                          | PointerIsWaitQueueMask) {",
          "content_same": false
        },
        {
          "line": 1423,
          "old_api": "hasWaitQueue",
          "new_api": null,
          "old_text": "trackingInfo.hasWaitQueue()",
          "new_text": null,
          "old_line_content": "        assert(!trackingInfo.hasWaitQueue());",
          "new_line_content": "      case PrivateMetadataTrackingInfo::Satisfied:",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": "getState",
          "new_api": null,
          "old_text": "getState()",
          "new_text": null,
          "old_line_content": "    return getState() != PrivateMetadataState::Allocating;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1426,
          "old_api": "createQueue",
          "new_api": null,
          "old_text": "op.createQueue()",
          "new_text": null,
          "old_line_content": "        auto queue = op.createQueue();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1431,
          "old_api": "getSuspendedCompletion",
          "new_api": null,
          "old_text": "trackingInfo.getSuspendedCompletion()",
          "new_text": null,
          "old_line_content": "              trackingInfo.getSuspendedCompletion()) {",
          "new_line_content": "      case PrivateMetadataTrackingInfo::Wait:",
          "content_same": false
        },
        {
          "line": 1435,
          "old_api": "std::move(suspendedCompletion->PersistentContext)",
          "new_api": null,
          "old_text": "std::move(suspendedCompletion->PersistentContext)",
          "new_text": null,
          "old_line_content": "            std::move(suspendedCompletion->PersistentContext);",
          "new_line_content": "      // There isn't a thread currently building the metadata,",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": "reinterpret_cast<MetadataWaitQueue*>(Data & PointerMask)",
          "new_api": null,
          "old_text": "reinterpret_cast<MetadataWaitQueue*>(Data & PointerMask)",
          "new_text": null,
          "old_line_content": "      return reinterpret_cast<MetadataWaitQueue*>(Data & PointerMask);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1438,
          "old_api": "reset",
          "new_api": null,
          "old_text": "suspendedCompletionToDelete.reset(suspendedCompletion)",
          "new_text": null,
          "old_line_content": "          suspendedCompletionToDelete.reset(suspendedCompletion);",
          "new_line_content": "      case PrivateMetadataTrackingInfo::Resume: {",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": "hasWaitQueue",
          "new_api": null,
          "old_text": "hasWaitQueue()",
          "new_text": null,
          "old_line_content": "    if (!hasWaitQueue())",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": "reinterpret_cast<SuspendedMetadataCompletion*>(Data & PointerMask)",
          "new_api": null,
          "old_text": "reinterpret_cast<SuspendedMetadataCompletion*>(Data & PointerMask)",
          "new_text": null,
          "old_line_content": "      return reinterpret_cast<SuspendedMetadataCompletion*>(Data & PointerMask);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1443,
          "old_api": "getState",
          "new_api": null,
          "old_text": "trackingInfo.getState()",
          "new_text": null,
          "old_line_content": "          PrivateMetadataTrackingInfo(trackingInfo.getState(), queue);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1444,
          "old_api": "store",
          "new_api": null,
          "old_text": "TrackingInfo.store(newTrackingInfo, std::memory_order_release)",
          "new_text": null,
          "old_line_content": "        TrackingInfo.store(newTrackingInfo, std::memory_order_release);",
          "new_line_content": "        // Copy the information from the suspended completion, if any,",
          "content_same": false
        },
        {
          "line": 1446,
          "old_api": "flagQueueIsPublished",
          "new_api": null,
          "old_text": "op.flagQueueIsPublished(queue)",
          "new_text": null,
          "old_line_content": "        return op.flagQueueIsPublished(queue);",
          "new_line_content": "        if (auto suspendedCompletion =",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": "getWaitQueue",
          "new_api": null,
          "old_text": "getWaitQueue()",
          "new_text": null,
          "old_line_content": "    if (auto queue = getWaitQueue())",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": "MetadataDependency",
          "new_api": null,
          "old_text": "MetadataDependency()",
          "new_text": null,
          "old_line_content": "    return MetadataDependency();",
          "new_line_content": "    return nullptr;",
          "content_same": false
        },
        {
          "line": 1456,
          "old_api": "getState",
          "new_api": null,
          "old_text": "trackingInfo.getState()",
          "new_text": null,
          "old_line_content": "      return getStatusToReturn(trackingInfo.getState());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1461,
          "old_api": "getState",
          "new_api": null,
          "old_text": "trackingInfo.getState()",
          "new_text": null,
          "old_line_content": "    worker.setState(trackingInfo.getState());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1471,
          "old_api": "isBlocking",
          "new_api": null,
          "old_text": "request.isBlocking()",
          "new_text": null,
          "old_line_content": "    assert(request.isBlocking());",
          "new_line_content": "             checkResult == PrivateMetadataTrackingInfo::Unsatisfied);",
          "content_same": false
        },
        {
          "line": 1474,
          "old_api": "getValue",
          "new_api": null,
          "old_text": "asImpl().getValue()",
          "new_text": null,
          "old_line_content": "    auto requestDependency = MetadataDependency(asImpl().getValue(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1475,
          "old_api": "getState",
          "new_api": null,
          "old_text": "request.getState()",
          "new_text": null,
          "old_line_content": "                                                request.getState());",
          "new_line_content": "    // Otherwise, we published and are now the worker thread owning",
          "content_same": false
        },
        {
          "line": 968,
          "old_api": "getState",
          "new_api": null,
          "old_text": "getState()",
          "new_text": null,
          "old_line_content": "    switch (getState()) {",
          "new_line_content": "    Satisfied,",
          "content_same": false
        },
        {
          "line": 1492,
          "old_api": "load",
          "new_api": null,
          "old_text": "TrackingInfo.load(std::memory_order_acquire)",
          "new_text": null,
          "old_line_content": "    auto curInfo = TrackingInfo.load(std::memory_order_acquire);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1493,
          "old_api": "satisfies",
          "new_api": null,
          "old_text": "curInfo.satisfies(requirement)",
          "new_text": null,
          "old_line_content": "    if (curInfo.satisfies(requirement))",
          "new_line_content": "    // Block on the metadata dependency.",
          "content_same": false
        },
        {
          "line": 1498,
          "old_api": "withLock",
          "new_api": null,
          "old_text": "concurrency.Lock.withLock([&]() -> MetadataStateWithDependency {\n      curInfo = TrackingInfo.load(TrackingInfoIsLockedOrder);\n\n      if (curInfo.satisfies(requirement))\n        return { curInfo.getState(), MetadataDependency() };\n\n      return { curInfo.getState(), curInfo.getBlockingDependency_locked() };\n    })",
          "new_text": null,
          "old_line_content": "    return concurrency.Lock.withLock([&]() -> MetadataStateWithDependency {",
          "new_line_content": "  /// Check whether this metadata has reached the given state and,",
          "content_same": false
        },
        {
          "line": 1499,
          "old_api": "load",
          "new_api": null,
          "old_text": "TrackingInfo.load(TrackingInfoIsLockedOrder)",
          "new_text": null,
          "old_line_content": "      curInfo = TrackingInfo.load(TrackingInfoIsLockedOrder);",
          "new_line_content": "  /// if not, return a further metadata dependency if possible.",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": "hasWaitQueue",
          "new_api": null,
          "old_text": "hasWaitQueue()",
          "new_text": null,
          "old_line_content": "      if (!hasWaitQueue())",
          "new_line_content": "      return Wait;",
          "content_same": false
        },
        {
          "line": 1501,
          "old_api": "satisfies",
          "new_api": null,
          "old_text": "curInfo.satisfies(requirement)",
          "new_text": null,
          "old_line_content": "      if (curInfo.satisfies(requirement))",
          "new_line_content": "  /// It's possible for this to not return a dependency, but only if some",
          "content_same": false
        },
        {
          "line": 1502,
          "old_api": "MetadataDependency",
          "new_api": null,
          "old_text": "MetadataDependency()",
          "new_text": null,
          "old_line_content": "        return { curInfo.getState(), MetadataDependency() };",
          "new_line_content": "  /// other thread is currently still attempting to complete the first",
          "content_same": false
        },
        {
          "line": 1504,
          "old_api": "getBlockingDependency_locked",
          "new_api": null,
          "old_text": "curInfo.getBlockingDependency_locked()",
          "new_text": null,
          "old_line_content": "      return { curInfo.getState(), curInfo.getBlockingDependency_locked() };",
          "new_line_content": "  /// for the reported dependency to be out of date.",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": "isBlocking",
          "new_api": null,
          "old_text": "request.isBlocking()",
          "new_text": null,
          "old_line_content": "      if (request.isBlocking())",
          "new_line_content": "    case PrivateMetadataState::Complete:",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "swift_unreachable",
          "new_api": null,
          "old_text": "swift_unreachable(\"bad state\")",
          "new_text": null,
          "old_line_content": "    swift_unreachable(\"bad state\");",
          "new_line_content": "      // If the request is satisfied, we don't need to do anything.",
          "content_same": false
        },
        {
          "line": 1017,
          "old_api": "isBlocking",
          "new_api": null,
          "old_text": "request.isBlocking()",
          "new_text": null,
          "old_line_content": "    return request.isBlocking();",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 1531,
          "old_api": "sizeInWords",
          "new_api": null,
          "old_text": "Layout.sizeInWords()",
          "new_text": null,
          "old_line_content": "    return Layout.sizeInWords();",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 28,
      "total_additions": 130,
      "total_deletions": 127,
      "total_api_changes": 285
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 18,
        "api_related_lines": 285,
        "non_api_lines": 13,
        "non_api_line_numbers": [
          609,
          610,
          611,
          613,
          617,
          618,
          619,
          620,
          621,
          622,
          623,
          625,
          626
        ]
      }
    },
    "api_calls_before": 333,
    "api_calls_after": 336,
    "diff_info": {
      "added_lines": 18,
      "removed_lines": 2,
      "total_diff_lines": 36
    }
  }
}