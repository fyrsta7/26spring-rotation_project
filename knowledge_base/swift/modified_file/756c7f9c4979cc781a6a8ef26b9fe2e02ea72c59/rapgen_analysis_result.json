{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/756c7f9c4979cc781a6a8ef26b9fe2e02ea72c59",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/756c7f9c4979cc781a6a8ef26b9fe2e02ea72c59/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/756c7f9c4979cc781a6a8ef26b9fe2e02ea72c59/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/756c7f9c4979cc781a6a8ef26b9fe2e02ea72c59/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 920,
          "old_api": "sert",
          "new_api": "vm::reverse(AppliesToInline))",
          "old_text": "sert(Callee && \"apply_inst does not have a direct callee anymore\");\n",
          "new_text": "vm::reverse(AppliesToInline)) ",
          "old_line_content": "    assert(Callee && \"apply_inst does not have a direct callee anymore\");",
          "new_line_content": "  for (auto AI : llvm::reverse(AppliesToInline)) {",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": "shouldOptimize",
          "new_api": "sert",
          "old_text": "llee->shouldOptimize()) ",
          "new_text": "sert(Callee && \"apply_inst does not have a direct callee anymore\");\n",
          "old_line_content": "    if (!Callee->shouldOptimize()) {",
          "new_line_content": "    assert(Callee && \"apply_inst does not have a direct callee anymore\");",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": "size",
          "new_api": "vm::dbgs()",
          "old_text": "ller->size() <",
          "new_text": "vm::dbgs()\n ",
          "old_line_content": "                                   << Caller->size() << \"] \"",
          "new_line_content": "    LLVM_DEBUG(dumpCaller(Caller); llvm::dbgs()",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": "getName",
          "new_api": "size",
          "old_text": "llee->getName() <",
          "new_text": "llee->size() <",
          "old_line_content": "                                   << Callee->getName() << \"\\n\");",
          "new_line_content": "                                   << \"    inline [\" << Callee->size() << \"->\"",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": "n_cast<ApplyInst>(&I);",
          "new_api": "getNext",
          "old_text": "n_cast<ApplyInst>(&I);\n",
          "new_text": "mOrder.getNext()) ",
          "old_line_content": "      auto *AI = dyn_cast<ApplyInst>(&I);",
          "new_line_content": "  while (SILBasicBlock *block = domOrder.getNext()) {",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": "push_back",
          "new_api": "tEligibleFunction",
          "old_text": "pliesToInline.push_back(AI);\n",
          "new_text": "tEligibleFunction(AI, WhatToInline);\n",
          "old_line_content": "        AppliesToInline.push_back(AI);",
          "new_line_content": "      auto *Callee = getEligibleFunction(AI, WhatToInline);",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": "->getAnalysis<SideEffectAnalysis>();",
          "new_api": "->getAnalysis<DominanceAnalysis>();",
          "old_text": "->getAnalysis<SideEffectAnalysis>();\n",
          "new_text": "->getAnalysis<DominanceAnalysis>();\n",
          "old_line_content": "    SideEffectAnalysis *SEA = PM->getAnalysis<SideEffectAnalysis>();",
          "new_line_content": "    DominanceAnalysis *DA = PM->getAnalysis<DominanceAnalysis>();",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": "startPassPipeline",
          "new_api": "tFunction",
          "old_text": "startPassPipeline();\n",
          "new_text": "tFunction()))",
          "old_line_content": "      restartPassPipeline();",
          "new_line_content": "    if (Inliner.inlineCallsIntoFunction(getFunction())) {",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1026,
          "old_api": null,
          "new_api": "isDefinition",
          "old_text": null,
          "new_text": "tFunction()->isDefinition() &",
          "old_line_content": "",
          "new_line_content": "    assert(getFunction()->isDefinition() &&",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": null,
          "new_api": "validateAnalysis",
          "old_text": null,
          "new_text": "validateAnalysis(SILAnalysis::InvalidationKind::FunctionBody);\n",
          "old_line_content": "    }",
          "new_line_content": "      invalidateAnalysis(SILAnalysis::InvalidationKind::FunctionBody);",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": null,
          "new_api": "startPassPipeline",
          "old_text": null,
          "new_text": "startPassPipeline();\n",
          "old_line_content": "  }",
          "new_line_content": "      restartPassPipeline();",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": null,
          "new_api": "getReferencedFunctionOrNull",
          "old_text": null,
          "new_text": ".getReferencedFunctionOrNull();\n",
          "old_line_content": "",
          "new_line_content": "    SILFunction *Callee = AI.getReferencedFunctionOrNull();",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": null,
          "new_api": "shouldOptimize",
          "old_text": null,
          "new_text": "llee->shouldOptimize()) ",
          "old_line_content": "    }",
          "new_line_content": "    if (!Callee->shouldOptimize()) {",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": null,
          "new_api": "hasOwnership",
          "old_text": null,
          "new_text": "ller->hasOwnership()) ",
          "old_line_content": "    }",
          "new_line_content": "    if (!Callee->hasOwnership() && Caller->hasOwnership()) {",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "ller->size() <",
          "old_line_content": "",
          "new_line_content": "                                   << Caller->size() << \"] \"",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "llee->getName() <",
          "old_line_content": "    // Note that this must happen before inlining as the apply instruction",
          "new_line_content": "                                   << Callee->getName() << \"\\n\");",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": null,
          "new_api": "LInliner::invalidatesStackNesting(AI);",
          "old_text": null,
          "new_text": "LInliner::invalidatesStackNesting(AI);\n",
          "old_line_content": "    // We've already determined we should be able to inline this, so",
          "new_line_content": "    invalidatedStackNesting |= SILInliner::invalidatesStackNesting(AI);",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": null,
          "new_api": "LInliner::inlineFullApply(AI, SILInliner::InlineKind::PerformanceInline,\n                                FuncBuilder);",
          "old_text": null,
          "new_text": "LInliner::inlineFullApply(AI, SILInliner::InlineKind::PerformanceInline,\n                                FuncBuilder);\n",
          "old_line_content": "    NumFunctionsInlined++;",
          "new_line_content": "    SILInliner::inlineFullApply(AI, SILInliner::InlineKind::PerformanceInline,",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": null,
          "new_api": "rgeBasicBlocks",
          "old_text": null,
          "new_text": "rgeBasicBlocks(Caller);\n",
          "old_line_content": "  if (invalidatedStackNesting) {",
          "new_line_content": "  mergeBasicBlocks(Caller);",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": null,
          "new_api": "correctStackNesting",
          "old_text": null,
          "new_text": "ackNesting().correctStackNesting(Caller);\n",
          "old_line_content": "",
          "new_line_content": "    StackNesting().correctStackNesting(Caller);",
          "content_same": false
        },
        {
          "line": 965,
          "old_api": null,
          "new_api": "verify",
          "old_text": null,
          "new_text": "ller->verify();\n",
          "old_line_content": "",
          "new_line_content": "    Caller->verify();",
          "content_same": false
        },
        {
          "line": 979,
          "old_api": null,
          "new_api": "n_cast<ApplyInst>(&I);",
          "old_text": null,
          "new_text": "n_cast<ApplyInst>(&I);\n",
          "old_line_content": "        continue;",
          "new_line_content": "      auto *AI = dyn_cast<ApplyInst>(&I);",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": null,
          "new_api": "cideInColdBlock",
          "old_text": null,
          "new_text": "cideInColdBlock(AI, Callee)) ",
          "old_line_content": "      }",
          "new_line_content": "      if (Callee && decideInColdBlock(AI, Callee)) {",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "pliesToInline.push_back(AI);\n",
          "old_line_content": "    }",
          "new_line_content": "        AppliesToInline.push_back(AI);",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": null,
          "new_api": "pushChildren",
          "old_text": null,
          "new_text": "mOrder.pushChildren(block);\n",
          "old_line_content": "}",
          "new_line_content": "    domOrder.pushChildren(block);",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "ssName.append(\" Performance Inliner\");\n",
          "old_line_content": "",
          "new_line_content": "    PassName.append(\" Performance Inliner\");",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": null,
          "new_api": "->getAnalysis<SILLoopAnalysis>();",
          "old_text": null,
          "new_text": "->getAnalysis<SILLoopAnalysis>();\n",
          "old_line_content": "    OptRemark::Emitter ORE(DEBUG_TYPE, getFunction()->getModule());",
          "new_line_content": "    SILLoopAnalysis *LA = PM->getAnalysis<SILLoopAnalysis>();",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": null,
          "new_api": "->getAnalysis<SideEffectAnalysis>();",
          "old_text": null,
          "new_text": "->getAnalysis<SideEffectAnalysis>();\n",
          "old_line_content": "",
          "new_line_content": "    SideEffectAnalysis *SEA = PM->getAnalysis<SideEffectAnalysis>();",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": null,
          "new_api": "tOptions",
          "old_text": null,
          "new_text": "tOptions().I",
          "old_line_content": "    }",
          "new_line_content": "    if (getOptions().InlineThreshold == 0) {",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": null,
          "new_api": "getEffectiveOptimizationMode",
          "old_text": null,
          "new_text": "tFunction()->getEffectiveOptimizationMode();\n",
          "old_line_content": "    SILOptFunctionBuilder FuncBuilder(*this);",
          "new_line_content": "    auto OptMode = getFunction()->getEffectiveOptimizationMode();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1024,
          "old_api": "isDefinition",
          "new_api": null,
          "old_text": "tFunction()->isDefinition() &",
          "new_text": null,
          "old_line_content": "    assert(getFunction()->isDefinition() &&",
          "new_line_content": "\t\t\t\t  OptMode, ORE);",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": "tFunction",
          "new_api": null,
          "old_text": "tFunction()))",
          "new_text": null,
          "old_line_content": "    if (Inliner.inlineCallsIntoFunction(getFunction())) {",
          "new_line_content": "    // can further optimize this function before attempting to inline",
          "content_same": false
        },
        {
          "line": 1032,
          "old_api": "validateAnalysis",
          "new_api": null,
          "old_text": "validateAnalysis(SILAnalysis::InvalidationKind::FunctionBody);\n",
          "new_text": null,
          "old_line_content": "      invalidateAnalysis(SILAnalysis::InvalidationKind::FunctionBody);",
          "new_line_content": "    // in it again.",
          "content_same": false
        },
        {
          "line": 919,
          "old_api": "getReferencedFunctionOrNull",
          "new_api": null,
          "old_text": ".getReferencedFunctionOrNull();\n",
          "new_text": null,
          "old_line_content": "    SILFunction *Callee = AI.getReferencedFunctionOrNull();",
          "new_line_content": "  // to inline, splitting the block at every apply would be quadratic.",
          "content_same": false
        },
        {
          "line": 929,
          "old_api": "hasOwnership",
          "new_api": null,
          "old_text": "ller->hasOwnership()) ",
          "new_text": null,
          "old_line_content": "    if (!Callee->hasOwnership() && Caller->hasOwnership()) {",
          "new_line_content": "    // ownership... do not inline. The two modes are incompatible, so skip this",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": "vm::dbgs()",
          "new_api": null,
          "old_text": "vm::dbgs()\n ",
          "new_text": null,
          "old_line_content": "    LLVM_DEBUG(dumpCaller(Caller); llvm::dbgs()",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "size",
          "new_api": null,
          "old_text": "llee->size() <",
          "new_text": null,
          "old_line_content": "                                   << \"    inline [\" << Callee->size() << \"->\"",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": "LInliner::invalidatesStackNesting(AI);",
          "new_api": null,
          "old_text": "LInliner::invalidatesStackNesting(AI);\n",
          "new_text": null,
          "old_line_content": "    invalidatedStackNesting |= SILInliner::invalidatesStackNesting(AI);",
          "new_line_content": "    // Note that this must happen before inlining as the apply instruction",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": "LInliner::inlineFullApply(AI, SILInliner::InlineKind::PerformanceInline,\n                                FuncBuilder);",
          "new_api": null,
          "old_text": "LInliner::inlineFullApply(AI, SILInliner::InlineKind::PerformanceInline,\n                                FuncBuilder);\n",
          "new_text": null,
          "old_line_content": "    SILInliner::inlineFullApply(AI, SILInliner::InlineKind::PerformanceInline,",
          "new_line_content": "    // If for whatever reason we can not inline this function, inlineFullApply",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "rgeBasicBlocks",
          "new_api": null,
          "old_text": "rgeBasicBlocks(Caller);\n",
          "new_text": null,
          "old_line_content": "  mergeBasicBlocks(Caller);",
          "new_line_content": "  // The inliner splits blocks at call sites. Re-merge trivial branches to",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": "correctStackNesting",
          "new_api": null,
          "old_text": "ackNesting().correctStackNesting(Caller);\n",
          "new_text": null,
          "old_line_content": "    StackNesting().correctStackNesting(Caller);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": "verify",
          "new_api": null,
          "old_text": "ller->verify();\n",
          "new_text": null,
          "old_line_content": "    Caller->verify();",
          "new_line_content": "  // the inliner without running the entire inliner.",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": "getNext",
          "new_api": null,
          "old_text": "mOrder.getNext()) ",
          "new_text": null,
          "old_line_content": "  while (SILBasicBlock *block = domOrder.getNext()) {",
          "new_line_content": "    DominanceInfo *DT) {",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": "tEligibleFunction",
          "new_api": null,
          "old_text": "tEligibleFunction(AI, WhatToInline);\n",
          "new_text": null,
          "old_line_content": "      auto *Callee = getEligibleFunction(AI, WhatToInline);",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": "cideInColdBlock",
          "new_api": null,
          "old_text": "cideInColdBlock(AI, Callee)) ",
          "new_text": null,
          "old_line_content": "      if (Callee && decideInColdBlock(AI, Callee)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": "pushChildren",
          "new_api": null,
          "old_text": "mOrder.pushChildren(block);\n",
          "new_text": null,
          "old_line_content": "    domOrder.pushChildren(block);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": "append",
          "new_api": null,
          "old_text": "ssName.append(\" Performance Inliner\");\n",
          "new_text": null,
          "old_line_content": "    PassName.append(\" Performance Inliner\");",
          "new_line_content": "  SILPerformanceInlinerPass(InlineSelection WhatToInline, StringRef LevelName):",
          "content_same": false
        },
        {
          "line": 1009,
          "old_api": "->getAnalysis<DominanceAnalysis>();",
          "new_api": null,
          "old_text": "->getAnalysis<DominanceAnalysis>();\n",
          "new_text": null,
          "old_line_content": "    DominanceAnalysis *DA = PM->getAnalysis<DominanceAnalysis>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": "->getAnalysis<SILLoopAnalysis>();",
          "new_api": null,
          "old_text": "->getAnalysis<SILLoopAnalysis>();\n",
          "new_text": null,
          "old_line_content": "    SILLoopAnalysis *LA = PM->getAnalysis<SILLoopAnalysis>();",
          "new_line_content": "  void run() override {",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": "tOptions",
          "new_api": null,
          "old_text": "tOptions().I",
          "new_text": null,
          "old_line_content": "    if (getOptions().InlineThreshold == 0) {",
          "new_line_content": "    OptRemark::Emitter ORE(DEBUG_TYPE, getFunction()->getModule());",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": "getEffectiveOptimizationMode",
          "new_api": null,
          "old_text": "tFunction()->getEffectiveOptimizationMode();\n",
          "new_text": null,
          "old_line_content": "    auto OptMode = getFunction()->getEffectiveOptimizationMode();",
          "new_line_content": "    }",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 8,
      "total_additions": 22,
      "total_deletions": 21,
      "total_api_changes": 51
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 3,
        "api_related_lines": 51,
        "non_api_lines": 1,
        "non_api_line_numbers": [
          918
        ]
      }
    },
    "api_calls_before": 352,
    "api_calls_after": 353,
    "diff_info": {
      "added_lines": 3,
      "removed_lines": 1,
      "total_diff_lines": 16
    }
  }
}