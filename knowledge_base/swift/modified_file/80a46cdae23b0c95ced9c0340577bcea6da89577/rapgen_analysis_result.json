{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/80a46cdae23b0c95ced9c0340577bcea6da89577",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/80a46cdae23b0c95ced9c0340577bcea6da89577/before.h",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/80a46cdae23b0c95ced9c0340577bcea6da89577/after.h",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/80a46cdae23b0c95ced9c0340577bcea6da89577/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 187,
          "old_api": "assert",
          "new_api": "constexpr",
          "old_text": "assert(newval + quantum >= RC_ONE &&\n           \"releasing reference with a refcount of zero\")",
          "new_text": "constexpr",
          "old_line_content": "    assert(newval + quantum >= RC_ONE &&",
          "new_line_content": "    constexpr uint32_t quantum =",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 193,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(newval + quantum >= RC_ONE &&\n           \"releasing reference with a refcount of zero\")",
          "old_line_content": "    // unless the refcount is nonzero, and or'ing it in gives us a",
          "new_line_content": "    assert(newval + quantum >= RC_ONE &&",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": null,
          "new_api": "__atomic_add_fetch",
          "old_text": null,
          "new_text": "__atomic_add_fetch(&refCount, RC_ONE, __ATOMIC_RELAXED)",
          "old_line_content": "  // Decrement the weak reference count.",
          "new_line_content": "    uint32_t newval = __atomic_add_fetch(&refCount, RC_ONE, __ATOMIC_RELAXED);",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(newval >= RC_ONE  &&  \"weak refcount overflow\")",
          "old_line_content": "  // Return true if the caller should deallocate the object.",
          "new_line_content": "    assert(newval >= RC_ONE  &&  \"weak refcount overflow\");",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": null,
          "new_api": "__atomic_fetch_sub",
          "old_text": null,
          "new_text": "__atomic_fetch_sub(&refCount, RC_ONE, __ATOMIC_RELAXED)",
          "old_line_content": "",
          "new_line_content": "    uint32_t oldval = __atomic_fetch_sub(&refCount, RC_ONE, __ATOMIC_RELAXED);",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(oldval >= RC_ONE  &&  \"weak refcount underflow\")",
          "old_line_content": "",
          "new_line_content": "    assert(oldval >= RC_ONE  &&  \"weak refcount underflow\");",
          "content_same": false
        },
        {
          "line": 179,
          "old_api": null,
          "new_api": "__atomic_load_n",
          "old_text": null,
          "new_text": "__atomic_load_n(&refCount, __ATOMIC_RELAXED)",
          "old_line_content": "    // If we're being asked to clear the pinned flag, we can assume",
          "new_line_content": "    return __atomic_load_n(&refCount, __ATOMIC_RELAXED) & RC_DEALLOCATING_FLAG;",
          "content_same": false
        },
        {
          "line": 216,
          "old_api": null,
          "new_api": "__atomic_compare_exchange",
          "old_text": null,
          "new_text": "__atomic_compare_exchange(&refCount, &oldval, &newval, 0,\n                                     __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)",
          "old_line_content": "// Weak reference count.",
          "new_line_content": "    return __atomic_compare_exchange(&refCount, &oldval, &newval, 0,",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": null,
          "new_api": "__atomic_load_n",
          "old_text": null,
          "new_text": "__atomic_load_n(&refCount, __ATOMIC_RELAXED)",
          "old_line_content": "static_assert(swift::IsTriviallyConstructible<WeakRefCount>::value,",
          "new_line_content": "    return __atomic_load_n(&refCount, __ATOMIC_RELAXED) >> RC_FLAGS_COUNT;",
          "content_same": false
        },
        {
          "line": 189,
          "old_api": null,
          "new_api": "__atomic_sub_fetch",
          "old_text": null,
          "new_text": "__atomic_sub_fetch(&refCount, quantum, __ATOMIC_RELEASE)",
          "old_line_content": "",
          "new_line_content": "    uint32_t newval = __atomic_sub_fetch(&refCount, quantum, __ATOMIC_RELEASE);",
          "content_same": false
        },
        {
          "line": 254,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "",
          "new_line_content": "  constexpr WeakRefCount(Initialized_t)",
          "content_same": false
        },
        {
          "line": 191,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert((!ClearPinnedFlag || !(newval & RC_PINNED_FLAG)) &&\n           \"unpinning reference that was not pinned\")",
          "old_line_content": "    // deallocating flag is already set, we're done; don't start",
          "new_line_content": "    assert((!ClearPinnedFlag || !(newval & RC_PINNED_FLAG)) &&",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 258,
          "old_api": "__atomic_add_fetch",
          "new_api": null,
          "old_text": "__atomic_add_fetch(&refCount, RC_ONE, __ATOMIC_RELAXED)",
          "new_text": null,
          "old_line_content": "    uint32_t newval = __atomic_add_fetch(&refCount, RC_ONE, __ATOMIC_RELAXED);",
          "new_line_content": "    refCount = RC_ONE;",
          "content_same": false
        },
        {
          "line": 259,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(newval >= RC_ONE  &&  \"weak refcount overflow\")",
          "new_text": null,
          "old_line_content": "    assert(newval >= RC_ONE  &&  \"weak refcount overflow\");",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": "__atomic_fetch_sub",
          "new_api": null,
          "old_text": "__atomic_fetch_sub(&refCount, RC_ONE, __ATOMIC_RELAXED)",
          "new_text": null,
          "old_line_content": "    uint32_t oldval = __atomic_fetch_sub(&refCount, RC_ONE, __ATOMIC_RELAXED);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 268,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(oldval >= RC_ONE  &&  \"weak refcount underflow\")",
          "new_text": null,
          "old_line_content": "    assert(oldval >= RC_ONE  &&  \"weak refcount underflow\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 173,
          "old_api": "__atomic_load_n",
          "new_api": null,
          "old_text": "__atomic_load_n(&refCount, __ATOMIC_RELAXED)",
          "new_text": null,
          "old_line_content": "    return __atomic_load_n(&refCount, __ATOMIC_RELAXED) & RC_DEALLOCATING_FLAG;",
          "new_line_content": "    auto rotateRightByOne = ((value >> 1) | (value << (sizeof(value) * 8 - 1)));",
          "content_same": false
        },
        {
          "line": 210,
          "old_api": "__atomic_compare_exchange",
          "new_api": null,
          "old_text": "__atomic_compare_exchange(&refCount, &oldval, &newval, 0,\n                                     __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)",
          "new_text": null,
          "old_line_content": "    return __atomic_compare_exchange(&refCount, &oldval, &newval, 0,",
          "new_line_content": "    //",
          "content_same": false
        },
        {
          "line": 181,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "    constexpr uint32_t quantum =",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": "__atomic_load_n",
          "new_api": null,
          "old_text": "__atomic_load_n(&refCount, __ATOMIC_RELAXED)",
          "new_text": null,
          "old_line_content": "    return __atomic_load_n(&refCount, __ATOMIC_RELAXED) >> RC_FLAGS_COUNT;",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 183,
          "old_api": "__atomic_sub_fetch",
          "new_api": null,
          "old_text": "__atomic_sub_fetch(&refCount, quantum, __ATOMIC_RELEASE)",
          "new_text": null,
          "old_line_content": "    uint32_t newval = __atomic_sub_fetch(&refCount, quantum, __ATOMIC_RELEASE);",
          "new_line_content": "  template <bool ClearPinnedFlag>",
          "content_same": false
        },
        {
          "line": 248,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "  constexpr WeakRefCount(Initialized_t)",
          "new_line_content": "  // WeakRefCount must be trivially constructible to avoid ObjC++",
          "content_same": false
        },
        {
          "line": 185,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert((!ClearPinnedFlag || !(newval & RC_PINNED_FLAG)) &&\n           \"unpinning reference that was not pinned\")",
          "new_text": null,
          "old_line_content": "    assert((!ClearPinnedFlag || !(newval & RC_PINNED_FLAG)) &&",
          "new_line_content": "    // If we're being asked to clear the pinned flag, we can assume",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 1,
      "total_additions": 11,
      "total_deletions": 11,
      "total_api_changes": 23
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 7,
        "api_related_lines": 23,
        "non_api_lines": 6,
        "non_api_line_numbers": [
          168,
          169,
          170,
          171,
          172,
          174
        ]
      }
    },
    "api_calls_before": 23,
    "api_calls_after": 23,
    "diff_info": {
      "added_lines": 7,
      "removed_lines": 1,
      "total_diff_lines": 20
    }
  }
}