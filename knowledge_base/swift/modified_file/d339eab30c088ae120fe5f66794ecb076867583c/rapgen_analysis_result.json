{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/d339eab30c088ae120fe5f66794ecb076867583c",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/d339eab30c088ae120fe5f66794ecb076867583c/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/d339eab30c088ae120fe5f66794ecb076867583c/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/d339eab30c088ae120fe5f66794ecb076867583c/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 271,
          "old_api": "hasSelfParam",
          "new_api": "getFunction",
          "old_text": "Callee->hasSelfParam()",
          "new_text": "AI.getFunction()->isThunk()",
          "old_line_content": "    if (Callee->hasSelfParam()) {",
          "new_line_content": "    if (AI.getFunction()->isThunk())",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": "getFunction",
          "new_api": "getRepresentation",
          "old_text": "AI.getFunction()->getModule().getOptions()",
          "new_text": "Callee->getRepresentation()",
          "old_line_content": "    const uint64_t CallerBaseBenefitReductionFactor = AI.getFunction()->getModule().getOptions().CallerBaseBenefitReductionFactor;",
          "new_line_content": "          Callee->getRepresentation() == SILFunctionTypeRepresentation::Method)",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": "get",
          "new_api": "getSubstitutionMap",
          "old_text": "LA->get(Callee)",
          "new_text": "AI.getSubstitutionMap()",
          "old_line_content": "  SILLoopInfo *LI = LA->get(Callee);",
          "new_line_content": "  if (IsGeneric && canSpecializeGeneric(AI, Callee, AI.getSubstitutionMap())) {",
          "content_same": false
        },
        {
          "line": 303,
          "old_api": "get",
          "new_api": "getSPA",
          "old_text": "DA->get(Callee)",
          "new_text": "getSPA(Callee, LI)",
          "old_line_content": "  DominanceInfo *DT = DA->get(Callee);",
          "new_line_content": "  ShortestPathAnalysis *SPA = getSPA(Callee, LI);",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": "front",
          "new_api": "isValid",
          "old_text": "Callee->front()",
          "new_text": "SPA->isValid()",
          "old_line_content": "  SILBasicBlock *CalleeEntry = &Callee->front();",
          "new_line_content": "  assert(SPA->isValid());",
          "content_same": false
        },
        {
          "line": 326,
          "old_api": "getNext",
          "new_api": "updateBenefit",
          "old_text": "mOrder.getNext()) ",
          "new_text": "llerWeight.updateBenefit(Benefit, BaseBenefit);\n",
          "old_line_content": "  while (SILBasicBlock *block = domOrder.getNext()) {",
          "new_line_content": "  CallerWeight.updateBenefit(Benefit, BaseBenefit);",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": "trackInst",
          "new_api": "beginBlock",
          "old_text": "nstTracker.trackInst(&I);\n",
          "new_text": "nstTracker.beginBlock();\n",
          "old_line_content": "      constTracker.trackInst(&I);",
          "new_line_content": "    constTracker.beginBlock();",
          "content_same": false
        },
        {
          "line": 335,
          "old_api": "llApplySite::isa(&I))",
          "new_api": "trackInst",
          "old_text": "llApplySite::isa(&I)) ",
          "new_text": "nstTracker.trackInst(&I);\n",
          "old_line_content": "      if (FullApplySite FAI = FullApplySite::isa(&I)) {",
          "new_line_content": "      constTracker.trackInst(&I);",
          "content_same": false
        },
        {
          "line": 339,
          "old_api": "a<PartialApplyInst>(def)))",
          "new_api": "llApplySite::isa(&I))",
          "old_text": "a<PartialApplyInst>(def)))",
          "new_text": "llApplySite::isa(&I)) ",
          "old_line_content": "        if (def && (isa<FunctionRefInst>(def) || isa<PartialApplyInst>(def)))",
          "new_line_content": "      if (FullApplySite FAI = FullApplySite::isa(&I)) {",
          "content_same": false
        },
        {
          "line": 344,
          "old_api": "getCallee",
          "new_api": "updateBenefit",
          "old_text": "I.getCallee());",
          "new_text": "ockW.updateBenefit(Benefit, RemovedClosureBenefit);\n",
          "old_line_content": "          def = dyn_cast_or_null<SingleValueInstruction>(FAI.getCallee());",
          "new_line_content": "          BlockW.updateBenefit(Benefit, RemovedClosureBenefit);",
          "content_same": false
        },
        {
          "line": 356,
          "old_api": "a<WitnessMethodInst>(def))",
          "new_api": "empty",
          "old_text": "a<WitnessMethodInst>(def))\n",
          "new_text": "bs.empty())\n",
          "old_line_content": "            !isa<WitnessMethodInst>(def))",
          "new_line_content": "        if (!EnableSILInliningOfGenerics || Subs.empty())",
          "content_same": false
        },
        {
          "line": 369,
          "old_api": "a<SuperMethodInst>(def))",
          "new_api": "subst",
          "old_text": "a<SuperMethodInst>(def)) ",
          "new_text": "bs.subst(CalleeSubstMap);\n",
          "old_line_content": "            isa<SuperMethodInst>(def)) {",
          "new_line_content": "        auto SubMap = Subs.subst(CalleeSubstMap);",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": "vm::dbgs() <",
          "new_api": "a<WitnessMethodInst>(def) |",
          "old_text": "vm::dbgs() <",
          "new_text": "a<WitnessMethodInst>(def) |",
          "old_line_content": "            LLVM_DEBUG(llvm::dbgs() << \"Devirtualization will be possible \"",
          "new_line_content": "        if (isa<ClassMethodInst>(def) || isa<WitnessMethodInst>(def) ||",
          "content_same": false
        },
        {
          "line": 375,
          "old_api": "updateBenefit",
          "new_api": "nDevirtualizeApply",
          "old_text": "ockW.updateBenefit(Benefit, DevirtualizedCallBenefit);\n",
          "new_text": "nDevirtualizeApply(FAI, nullptr)) ",
          "old_line_content": "            BlockW.updateBenefit(Benefit, DevirtualizedCallBenefit);",
          "new_line_content": "          if (canDevirtualizeApply(FAI, nullptr)) {",
          "content_same": false
        },
        {
          "line": 384,
          "old_api": "vm::dbgs() <",
          "new_api": "a<FunctionRefInst>(def))",
          "old_text": "vm::dbgs() <",
          "new_text": "a<FunctionRefInst>(def)) ",
          "old_line_content": "          LLVM_DEBUG(llvm::dbgs() << \"Generic specialization will be possible \"",
          "new_line_content": "        if (isa<FunctionRefInst>(def)) {",
          "content_same": false
        },
        {
          "line": 386,
          "old_api": "getInstruction",
          "new_api": "nSpecializeGeneric",
          "old_text": "I.getInstruction()->dumpInContext());",
          "new_text": "nSpecializeGeneric(FAI, CalleeF, SubMap))\n",
          "old_line_content": "                     FAI.getInstruction()->dumpInContext());",
          "new_line_content": "          if (!canSpecializeGeneric(FAI, CalleeF, SubMap))",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": "updateBenefit",
          "new_api": "n_cast<LoadInst>(&I))",
          "old_text": "ockW.updateBenefit(Benefit, RemovedLoadBenefit);\n",
          "new_text": "n_cast<LoadInst>(&I)) ",
          "old_line_content": "          BlockW.updateBenefit(Benefit, RemovedLoadBenefit);",
          "new_line_content": "      } else if (auto *LI = dyn_cast<LoadInst>(&I)) {",
          "content_same": false
        },
        {
          "line": 397,
          "old_api": "getDest",
          "new_api": "updateBenefit",
          "old_text": "->getDest()))",
          "new_text": "ockW.updateBenefit(Benefit, RemovedLoadBenefit);\n",
          "old_line_content": "        if (constTracker.isStackAddrInCaller(SI->getDest()))",
          "new_line_content": "          BlockW.updateBenefit(Benefit, RemovedLoadBenefit);",
          "content_same": false
        },
        {
          "line": 398,
          "old_api": "updateBenefit",
          "new_api": "n_cast<StoreInst>(&I))",
          "old_text": "ockW.updateBenefit(Benefit, RemovedStoreBenefit);\n",
          "new_text": "n_cast<StoreInst>(&I)) ",
          "old_line_content": "          BlockW.updateBenefit(Benefit, RemovedStoreBenefit);",
          "new_line_content": "      } else if (auto *SI = dyn_cast<StoreInst>(&I)) {",
          "content_same": false
        },
        {
          "line": 401,
          "old_api": "n_cast<SILFunctionArgument>(Op))",
          "new_api": "getDest",
          "old_text": "n_cast<SILFunctionArgument>(Op)) ",
          "new_text": "->getDest()))",
          "old_line_content": "        if (auto *Arg = dyn_cast<SILFunctionArgument>(Op)) {",
          "new_line_content": "        if (constTracker.isStackAddrInCaller(SI->getDest()))",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": "getArgumentConvention",
          "new_api": "updateBenefit",
          "old_text": "g->getArgumentConvention() =",
          "new_text": "ockW.updateBenefit(Benefit, RemovedStoreBenefit);\n",
          "old_line_content": "          if (Arg->getArgumentConvention() ==",
          "new_line_content": "          BlockW.updateBenefit(Benefit, RemovedStoreBenefit);",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": "updateBenefit",
          "new_api": "getOperand",
          "old_text": "ockW.updateBenefit(Benefit, RefCountBenefit);\n",
          "new_text": "getOperand(0));",
          "old_line_content": "            BlockW.updateBenefit(Benefit, RefCountBenefit);",
          "new_line_content": "        SILValue Op = stripCasts(I.getOperand(0));",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": "getBuiltinInfo",
          "new_api": "updateBenefit",
          "old_text": "->getBuiltinInfo().I",
          "new_text": "ockW.updateBenefit(Benefit, RefCountBenefit);\n",
          "old_line_content": "        if (BI->getBuiltinInfo().ID == BuiltinValueKind::OnFastPath)",
          "new_line_content": "            BlockW.updateBenefit(Benefit, RefCountBenefit);",
          "content_same": false
        },
        {
          "line": 411,
          "old_api": "getEnforcement",
          "new_api": "n_cast<BuiltinInst>(&I))",
          "old_text": "I->getEnforcement() =",
          "new_text": "n_cast<BuiltinInst>(&I)) ",
          "old_line_content": "        if (BAI->getEnforcement() == SILAccessEnforcement::Dynamic) {",
          "new_line_content": "      } else if (auto *BI = dyn_cast<BuiltinInst>(&I)) {",
          "content_same": false
        },
        {
          "line": 420,
          "old_api": "updateBenefit",
          "new_api": "getSource",
          "old_text": "ockW.updateBenefit(ExclusivityBenefitWeight, ExclusivityBenefit);\n",
          "new_text": "I->getSource());",
          "old_line_content": "            BlockW.updateBenefit(ExclusivityBenefitWeight, ExclusivityBenefit);",
          "new_line_content": "              findAccessedStorageNonNested(BAI->getSource());",
          "content_same": false
        },
        {
          "line": 432,
          "old_api": "getSinglePredecessorBlock",
          "new_api": "getTerminator",
          "old_text": "ild->getSinglePredecessorBlock() !",
          "new_text": "ock->getTerminator());",
          "old_line_content": "        return child->getSinglePredecessorBlock() != block ||",
          "new_line_content": "    SILBasicBlock *takenBlock = constTracker.getTakenBlock(block->getTerminator());",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": "pushChildren",
          "new_api": "getSinglePredecessorBlock",
          "old_text": "mOrder.pushChildren(block);\n",
          "new_text": "ild->getSinglePredecessorBlock() !",
          "old_line_content": "      domOrder.pushChildren(block);",
          "new_line_content": "        return child->getSinglePredecessorBlock() != block ||",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": "(\"Cost\", CalleeCost)",
          "new_api": "emit",
          "old_text": "(\"Cost\", CalleeCost)\n ",
          "new_text": "E.emit([&]() {\n      using namespace OptRemark;\n      return RemarkMissed(\"NoInlinedCost\", *AI.getInstruction())\n             << \"Not profitable to inline function \" << NV(\"Callee\", Callee)\n             << \" (cost = \" << NV(\"Cost\", CalleeCost)\n             << \", benefit = \" << NV(\"Benefit\", Benefit) << \")\";\n    });\n",
          "old_line_content": "             << \" (cost = \" << NV(\"Cost\", CalleeCost)",
          "new_line_content": "    ORE.emit([&]() {",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": "size",
          "new_api": "vm::dbgs() <",
          "old_text": "llee->size()\n ",
          "new_text": "vm::dbgs() <",
          "old_line_content": "                          << \", bb=\" << Callee->size()",
          "new_line_content": "             llvm::dbgs() << \"    decision {c=\" << CalleeCost",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "getName",
          "new_api": "getScopeLength",
          "old_text": "llee->getName() <",
          "new_text": "A->getScopeLength(CalleeEntry, 0)\n ",
          "old_line_content": "                          << \"} \" << Callee->getName() << '\\n');",
          "new_line_content": "                          << \", l=\" << SPA->getScopeLength(CalleeEntry, 0)",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": "(\"Callee\", Callee) <",
          "new_api": "getName",
          "old_text": "(\"Callee\", Callee) <",
          "new_text": "llee->getName() <",
          "old_line_content": "           << NV(\"Callee\", Callee) << \" inlined into \"",
          "new_line_content": "                          << \"} \" << Callee->getName() << '\\n');",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": "getFunction",
          "new_api": "emit",
          "old_text": ".getFunction())\n",
          "new_text": "E.emit([&]() {\n    using namespace OptRemark;\n    return RemarkPassed(\"Inlined\", *AI.getInstruction())\n           << NV(\"Callee\", Callee) << \" inlined into \"\n           << NV(\"Caller\", AI.getFunction())\n           << \" (cost = \" << NV(\"Cost\", CalleeCost)\n           << \", benefit = \" << NV(\"Benefit\", Benefit) << \")\";\n  });\n",
          "old_line_content": "           << NV(\"Caller\", AI.getFunction())",
          "new_line_content": "  ORE.emit([&]() {",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": "(\"Benefit\", Benefit) <",
          "new_api": "getInstruction",
          "old_text": "(\"Benefit\", Benefit) <",
          "new_text": ".getInstruction())\n",
          "old_line_content": "           << \", benefit = \" << NV(\"Benefit\", Benefit) << \")\";",
          "new_line_content": "    return RemarkPassed(\"Inlined\", *AI.getInstruction())",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": "getFunction",
          "new_api": "isOnoneSupportModule",
          "old_text": ".getFunction()->isThunk())\n",
          "new_text": "iftModule->isOnoneSupportModule()))",
          "old_line_content": "  if (AI.getFunction()->isThunk())",
          "new_line_content": "      (SwiftModule->isStdlibModule() || SwiftModule->isOnoneSupportModule()))",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": "getValue",
          "new_api": "hasSubstitutions",
          "old_text": "ouldInlineGeneric.getValue();\n",
          "new_text": ".hasSubstitutions()) ",
          "old_line_content": "      return ShouldInlineGeneric.getValue();",
          "new_line_content": "  if (AI.hasSubstitutions()) {",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": "getReferencedFunction",
          "new_api": "hasValue",
          "old_text": ".getReferencedFunction();\n",
          "new_text": "ouldInlineGeneric.hasValue())\n",
          "old_line_content": "  SILFunction *Callee = AI.getReferencedFunction();",
          "new_line_content": "    if (ShouldInlineGeneric.hasValue())",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": "vm::dbgs() <",
          "new_api": "getReferencedFunction",
          "old_text": "vm::dbgs() <",
          "new_text": ".getReferencedFunction();\n",
          "old_line_content": "               llvm::dbgs() << \"    always-inline decision \"",
          "new_line_content": "  SILFunction *Callee = AI.getReferencedFunction();",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": "ProfitableToInline",
          "new_api": "getName",
          "old_text": "ProfitableToInline(AI, CallerWeight, callerTracker, NumCallerBlocks,\n                              BBToWeightMap);\n",
          "new_text": "llee->getName() <",
          "old_line_content": "  return isProfitableToInline(AI, CallerWeight, callerTracker, NumCallerBlocks,",
          "new_line_content": "                            << Callee->getName() << '\\n');",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": "getValue",
          "new_api": "hasSubstitutions",
          "old_text": "ouldInlineGeneric.getValue();\n",
          "new_text": ".hasSubstitutions()) ",
          "old_line_content": "      return ShouldInlineGeneric.getValue();",
          "new_line_content": "  if (AI.hasSubstitutions()) {",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": "size",
          "new_api": "getBlocks",
          "old_text": "ller->size());",
          "new_text": "ller->getBlocks()) ",
          "old_line_content": "  DominanceOrder domOrder(&Caller->front(), DT, Caller->size());",
          "new_line_content": "  for (auto &block : Caller->getBlocks()) {",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": "end",
          "new_api": "getValue",
          "old_text": "ToWeightMap.end() &",
          "new_text": "tryCount.getValue();\n",
          "old_line_content": "    assert(bbIt != BBToWeightMap.end() && \"Expected to find block in map\");",
          "new_line_content": "  BBToWeightMap[Caller->getEntryBlock()] = entryCount.getValue();",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": "getSecond",
          "new_api": "size",
          "old_text": "It->getSecond();\n",
          "new_text": "ller->size());",
          "old_line_content": "    auto bbCount = bbIt->getSecond();",
          "new_line_content": "  DominanceOrder domOrder(&Caller->front(), DT, Caller->size());",
          "content_same": false
        },
        {
          "line": 673,
          "old_api": "getTerminator",
          "new_api": "getNext",
          "old_text": "ock->getTerminator();\n",
          "new_text": "mOrder.getNext()) ",
          "old_line_content": "    auto *termInst = block->getTerminator();",
          "new_line_content": "  while (SILBasicBlock *block = domOrder.getNext()) {",
          "content_same": false
        },
        {
          "line": 674,
          "old_api": "ntainsWeight",
          "new_api": "find",
          "old_text": "ntainsWeight(termInst)) ",
          "new_text": "ToWeightMap.find(block);\n",
          "old_line_content": "    if (containsWeight(termInst)) {",
          "new_line_content": "    auto bbIt = BBToWeightMap.find(block);",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": "getSuccessors",
          "new_api": "ntainsWeight",
          "old_text": "rmInst->getSuccessors()) ",
          "new_text": "ntainsWeight(termInst)) ",
          "old_line_content": "      for (auto &succ : termInst->getSuccessors()) {",
          "new_line_content": "    if (containsWeight(termInst)) {",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": "getCount",
          "new_api": "getSuccessors",
          "old_text": "cc.getCount();\n",
          "new_text": "rmInst->getSuccessors()) ",
          "old_line_content": "        auto currCount = succ.getCount();",
          "new_line_content": "      for (auto &succ : termInst->getSuccessors()) {",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": "size",
          "new_api": "dToBBCounts",
          "old_text": "rmInst->getSuccessors().size();\n",
          "new_text": "dToBBCounts(BBToWeightMap, numToAdd, termInst);\n",
          "old_line_content": "      auto numOfSucc = termInst->getSuccessors().size();",
          "new_line_content": "        addToBBCounts(BBToWeightMap, numToAdd, termInst);",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": "get",
          "new_api": "dWeightCorrection",
          "old_text": "->get(Callee);\n",
          "new_text": "dWeightCorrection(FAS, WeightCorrections);\n",
          "old_line_content": "      SILLoopInfo *CalleeLI = LA->get(Callee);",
          "new_line_content": "    addWeightCorrection(FAS, WeightCorrections);",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "isValid",
          "new_api": "tEligibleFunction",
          "old_text": "lleeSPA->isValid()) ",
          "new_text": "tEligibleFunction(FAS, WhatToInline)) ",
          "old_line_content": "      if (!CalleeSPA->isValid()) {",
          "new_line_content": "    if (SILFunction *Callee = getEligibleFunction(FAS, WhatToInline)) {",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": "lculateBBWeights",
          "new_api": "size",
          "old_text": "lculateBBWeights(Caller, DT, BBToWeightMap);\n",
          "new_text": "ller->size());",
          "old_line_content": "  calculateBBWeights(Caller, DT, BBToWeightMap);",
          "new_line_content": "  DominanceOrder domOrder(&Caller->front(), DT, Caller->size());",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": "end",
          "new_api": "getNext",
          "old_text": "ock->end(); ",
          "new_text": "mOrder.getNext()) ",
          "old_line_content": "    for (auto I = block->begin(), E = block->end(); I != E; ++I) {",
          "new_line_content": "  while (SILBasicBlock *block = domOrder.getNext()) {",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": "trackInst",
          "new_api": "beginBlock",
          "old_text": "nstTracker.trackInst(&*I);\n",
          "new_text": "nstTracker.beginBlock();\n",
          "old_line_content": "      constTracker.trackInst(&*I);",
          "new_line_content": "    constTracker.beginBlock();",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "isValid",
          "new_api": "llApplySite",
          "old_text": "ockWeight.isValid())\n",
          "new_text": "llApplySite(&*I);\n",
          "old_line_content": "        if (!BlockWeight.isValid())",
          "new_line_content": "      FullApplySite AI = FullApplySite(&*I);",
          "content_same": false
        },
        {
          "line": 794,
          "old_api": "lookup",
          "new_api": "isValid",
          "old_text": "ightCorrections.lookup(AI));",
          "new_text": "ockWeight.isValid())\n",
          "old_line_content": "        Weight W(BlockWeight, WeightCorrections.lookup(AI));",
          "new_line_content": "        if (!BlockWeight.isValid())",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": "push_back",
          "new_api": "lookup",
          "old_text": "itialCandidates.push_back(AI);\n",
          "new_text": "ightCorrections.lookup(AI));",
          "old_line_content": "          InitialCandidates.push_back(AI);",
          "new_line_content": "        Weight W(BlockWeight, WeightCorrections.lookup(AI));",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": "push_back",
          "new_api": "sert",
          "old_text": "plies.push_back(AI);\n",
          "new_text": "sert(Callee && \"apply_inst does not have a direct callee anymore\");\n",
          "old_line_content": "      Applies.push_back(AI);",
          "new_line_content": "    assert(Callee && \"apply_inst does not have a direct callee anymore\");",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": "size",
          "new_api": "getArguments",
          "old_text": "llee->size() <",
          "new_text": ".getArguments())\n",
          "old_line_content": "               llvm::dbgs() << \"    inline [\" << Callee->size() << \"->\"",
          "new_line_content": "    for (const auto &Arg : AI.getArguments())",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": "size",
          "new_api": "push_back",
          "old_text": "ller->size()\n ",
          "new_text": "gs.push_back(Arg);\n",
          "old_line_content": "                            << Caller->size()",
          "new_line_content": "      Args.push_back(Arg);",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": "registerDeleteNotificationHandler",
          "new_api": "size",
          "old_text": "ller->getModule().registerDeleteNotificationHandler(\n        &OpenedArchetypesTracker);\n",
          "new_text": "ller->size()\n ",
          "old_line_content": "    Caller->getModule().registerDeleteNotificationHandler(",
          "new_line_content": "                            << Caller->size()",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": "getInstruction",
          "new_api": "registerDeleteNotificationHandler",
          "old_text": ".getInstruction());",
          "new_text": "ller->getModule().registerDeleteNotificationHandler(\n        &OpenedArchetypesTracker);\n",
          "old_line_content": "    OpenedArchetypesTracker.registerUsedOpenedArchetypes(AI.getInstruction());",
          "new_line_content": "    Caller->getModule().registerDeleteNotificationHandler(",
          "content_same": false
        },
        {
          "line": 902,
          "old_api": "tEligibleFunction",
          "new_api": "n_cast<ApplyInst>(&I);",
          "old_text": "tEligibleFunction(AI, WhatToInline);\n",
          "new_text": "n_cast<ApplyInst>(&I);\n",
          "old_line_content": "      auto *Callee = getEligibleFunction(AI, WhatToInline);",
          "new_line_content": "      auto *AI = dyn_cast<ApplyInst>(&I);",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": "pushChildren",
          "new_api": "cideInColdBlock",
          "old_text": "mOrder.pushChildren(block);\n",
          "new_text": "cideInColdBlock(AI, Callee)) ",
          "old_line_content": "    domOrder.pushChildren(block);",
          "new_line_content": "      if (Callee && decideInColdBlock(AI, Callee)) {",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": "->getAnalysis<DominanceAnalysis>();",
          "new_api": "append",
          "old_text": "->getAnalysis<DominanceAnalysis>();\n",
          "new_text": "ssName.append(\" Performance Inliner\");\n",
          "old_line_content": "    DominanceAnalysis *DA = PM->getAnalysis<DominanceAnalysis>();",
          "new_line_content": "    PassName.append(\" Performance Inliner\");",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": "tOptions",
          "new_api": "->getAnalysis<SILLoopAnalysis>();",
          "old_text": "tOptions().I",
          "new_text": "->getAnalysis<SILLoopAnalysis>();\n",
          "old_line_content": "    if (getOptions().InlineThreshold == 0) {",
          "new_line_content": "    SILLoopAnalysis *LA = PM->getAnalysis<SILLoopAnalysis>();",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": "getEffectiveOptimizationMode",
          "new_api": "tOptions",
          "old_text": "tFunction()->getEffectiveOptimizationMode();\n",
          "new_text": "tOptions().I",
          "old_line_content": "    auto OptMode = getFunction()->getEffectiveOptimizationMode();",
          "new_line_content": "    if (getOptions().InlineThreshold == 0) {",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 524,
          "old_api": null,
          "new_api": "hasSubstitutions",
          "old_text": null,
          "new_text": ".hasSubstitutions() &",
          "old_line_content": "",
          "new_line_content": "  assert(AI.hasSubstitutions() &&",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": null,
          "new_api": "getReferencedFunction",
          "old_text": null,
          "new_text": ".getReferencedFunction();\n",
          "old_line_content": "  // can properly optimize a user code later.",
          "new_line_content": "  SILFunction *Callee = AI.getReferencedFunction();",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": null,
          "new_api": "getSwiftModule",
          "old_text": null,
          "new_text": "llee->getModule().getSwiftModule();\n",
          "old_line_content": "",
          "new_line_content": "  ModuleDecl *SwiftModule = Callee->getModule().getSwiftModule();",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": null,
          "new_api": "hasSemanticsAttrThatStartsWith",
          "old_text": null,
          "new_text": "llee->hasSemanticsAttrThatStartsWith(\"array.\") &",
          "old_line_content": "  // Do not inline into thunks.",
          "new_line_content": "  if (Callee->hasSemanticsAttrThatStartsWith(\"array.\") &&",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": null,
          "new_api": "getFunction",
          "old_text": null,
          "new_text": ".getFunction()->isThunk())\n",
          "old_line_content": "  // AlwaysInline or transparent.",
          "new_line_content": "  if (AI.getFunction()->isThunk())",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": null,
          "new_api": "isTransparent",
          "old_text": null,
          "new_text": "llee->isTransparent())\n",
          "old_line_content": "  // is disabled.",
          "new_line_content": "  if (Callee->getInlineStrategy() == AlwaysInline || Callee->isTransparent())",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": null,
          "new_api": "getSubstitutionMap",
          "old_text": null,
          "new_text": ".getSubstitutionMap().hasArchetypes())\n",
          "old_line_content": "  return None;",
          "new_line_content": "  if (!AI.getSubstitutionMap().hasArchetypes())",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": null,
          "new_api": "ouldInlineGeneric",
          "old_text": null,
          "new_text": "ouldInlineGeneric(AI);\n",
          "old_line_content": "",
          "new_line_content": "    auto ShouldInlineGeneric = shouldInlineGeneric(AI);",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": null,
          "new_api": "getValue",
          "old_text": null,
          "new_text": "ouldInlineGeneric.getValue();\n",
          "old_line_content": "",
          "new_line_content": "      return ShouldInlineGeneric.getValue();",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": null,
          "new_api": "isTransparent",
          "old_text": null,
          "new_text": "llee->isTransparent()) ",
          "old_line_content": "    return true;",
          "new_line_content": "  if (Callee->getInlineStrategy() == AlwaysInline || Callee->isTransparent()) {",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": null,
          "new_api": "getFunction",
          "old_text": null,
          "new_text": ".getFunction());",
          "old_line_content": "  }",
          "new_line_content": "    LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": null,
          "new_api": "vm::dbgs() <",
          "old_text": null,
          "new_text": "vm::dbgs() <",
          "old_line_content": "",
          "new_line_content": "               llvm::dbgs() << \"    always-inline decision \"",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": null,
          "new_api": "ProfitableToInline",
          "old_text": null,
          "new_text": "ProfitableToInline(AI, CallerWeight, callerTracker, NumCallerBlocks,\n                              BBToWeightMap);\n",
          "old_line_content": "/// Return true if inlining this call site into a cold block is profitable.",
          "new_line_content": "  return isProfitableToInline(AI, CallerWeight, callerTracker, NumCallerBlocks,",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": null,
          "new_api": "ouldInlineGeneric",
          "old_text": null,
          "new_text": "ouldInlineGeneric(AI);\n",
          "old_line_content": "    return false;",
          "new_line_content": "    auto ShouldInlineGeneric = shouldInlineGeneric(AI);",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": null,
          "new_api": "hasValue",
          "old_text": null,
          "new_text": "ouldInlineGeneric.hasValue())\n",
          "old_line_content": "  }",
          "new_line_content": "    if (ShouldInlineGeneric.hasValue())",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": null,
          "new_api": "getValue",
          "old_text": null,
          "new_text": "ouldInlineGeneric.getValue();\n",
          "old_line_content": "",
          "new_line_content": "      return ShouldInlineGeneric.getValue();",
          "content_same": false
        },
        {
          "line": 597,
          "old_api": null,
          "new_api": "isTransparent",
          "old_text": null,
          "new_text": "llee->isTransparent()) ",
          "old_line_content": "    return true;",
          "new_line_content": "  if (Callee->getInlineStrategy() == AlwaysInline || Callee->isTransparent()) {",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": null,
          "new_api": "getFunction",
          "old_text": null,
          "new_text": ".getFunction());",
          "old_line_content": "  }",
          "new_line_content": "    LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "content_same": false
        },
        {
          "line": 599,
          "old_api": null,
          "new_api": "vm::dbgs() <",
          "old_text": null,
          "new_text": "vm::dbgs() <",
          "old_line_content": "",
          "new_line_content": "               llvm::dbgs() << \"    always-inline decision \"",
          "content_same": false
        },
        {
          "line": 600,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "llee->getName() <",
          "old_line_content": "  int CalleeCost = 0;",
          "new_line_content": "                            << Callee->getName() << '\\n');",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": null,
          "new_api": "structionInlineCost",
          "old_text": null,
          "new_text": "structionInlineCost(I));",
          "old_line_content": "  }",
          "new_line_content": "      CalleeCost += int(instructionInlineCost(I));",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": null,
          "new_api": "getFunction",
          "old_text": null,
          "new_text": ".getFunction());",
          "old_line_content": "}",
          "new_line_content": "  LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": null,
          "new_api": "vm::dbgs() <",
          "old_text": null,
          "new_text": "vm::dbgs() <",
          "old_line_content": "",
          "new_line_content": "             llvm::dbgs() << \"    cold decision {\" << CalleeCost << \"} \"",
          "content_same": false
        },
        {
          "line": 615,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "llee->getName() <",
          "old_line_content": "/// Record additional weight increases.",
          "new_line_content": "                          << Callee->getName() << '\\n');",
          "content_same": false
        },
        {
          "line": 626,
          "old_api": null,
          "new_api": "getReferencedFunction",
          "old_text": null,
          "new_text": "S.getReferencedFunction();\n",
          "old_line_content": "    // buffer allocation for the array. It is essential to inline it for stack",
          "new_line_content": "  SILFunction *Callee = FAS.getReferencedFunction();",
          "content_same": false
        },
        {
          "line": 627,
          "old_api": null,
          "new_api": "hasSemanticsAttr",
          "old_text": null,
          "new_text": "llee->hasSemanticsAttr(\"array.uninitialized\")) ",
          "old_line_content": "    // promotion of the array buffer.",
          "new_line_content": "  if (Callee && Callee->hasSemanticsAttr(\"array.uninitialized\")) {",
          "content_same": false
        },
        {
          "line": 632,
          "old_api": null,
          "new_api": "getArgument",
          "old_text": null,
          "new_text": "S.getArgument(0);\n",
          "old_line_content": "  }",
          "new_line_content": "    SILValue BufferArg = FAS.getArgument(0);",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": null,
          "new_api": "ripCasts",
          "old_text": null,
          "new_text": "ripCasts(BufferArg));",
          "old_line_content": "}",
          "new_line_content": "    SILValue Base = stripValueProjections(stripCasts(BufferArg));",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": null,
          "new_api": "llApplySite::isa(Base))",
          "old_text": null,
          "new_text": "llApplySite::isa(Base))\n",
          "old_line_content": "",
          "new_line_content": "    if (auto BaseApply = FullApplySite::isa(Base))",
          "content_same": false
        },
        {
          "line": 640,
          "old_api": null,
          "new_api": "getSuccessors",
          "old_text": null,
          "new_text": "st->getSuccessors()) ",
          "old_line_content": "  }",
          "new_line_content": "  for (auto &succ : inst->getSuccessors()) {",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": null,
          "new_api": "getCount",
          "old_text": null,
          "new_text": "cc.getCount()) ",
          "old_line_content": "  return false;",
          "new_line_content": "    if (succ.getCount()) {",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": null,
          "new_api": "getSuccessors",
          "old_text": null,
          "new_text": "rmInst->getSuccessors()) ",
          "old_line_content": "    BBToWeightMap[currBB] += numToAdd;",
          "new_line_content": "  for (auto &succ : termInst->getSuccessors()) {",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": null,
          "new_api": "getBB",
          "old_text": null,
          "new_text": "cc.getBB();\n",
          "old_line_content": "  }",
          "new_line_content": "    auto *currBB = succ.getBB();",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "ToWeightMap.end() &",
          "old_line_content": "}",
          "new_line_content": "    assert(BBToWeightMap.find(currBB) != BBToWeightMap.end() &&",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": null,
          "new_api": "getEntryCount",
          "old_text": null,
          "new_text": "ller->getEntryCount();\n",
          "old_line_content": "  }",
          "new_line_content": "  auto entryCount = Caller->getEntryCount();",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "ToWeightMap.end() &",
          "old_line_content": "      // Instruction already contains accurate counters - use them as-is",
          "new_line_content": "    assert(bbIt != BBToWeightMap.end() && \"Expected to find block in map\");",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": null,
          "new_api": "getSecond",
          "old_text": null,
          "new_text": "It->getSecond();\n",
          "old_line_content": "      uint64_t countSum = 0;",
          "new_line_content": "    auto bbCount = bbIt->getSecond();",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": null,
          "new_api": "getTerminator",
          "old_text": null,
          "new_text": "ock->getTerminator();\n",
          "old_line_content": "      uint64_t blocksWithoutCount = 0;",
          "new_line_content": "    auto *termInst = block->getTerminator();",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": null,
          "new_api": "getBB",
          "old_text": null,
          "new_text": "cc.getBB();\n",
          "old_line_content": "        if (!currCount) {",
          "new_line_content": "        auto *currBB = succ.getBB();",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "ToWeightMap.end() &",
          "old_line_content": "          ++blocksWithoutCount;",
          "new_line_content": "        assert(BBToWeightMap.find(currBB) != BBToWeightMap.end() &&",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": null,
          "new_api": "getCount",
          "old_text": null,
          "new_text": "cc.getCount();\n",
          "old_line_content": "        }",
          "new_line_content": "        auto currCount = succ.getCount();",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": null,
          "new_api": "getValue",
          "old_text": null,
          "new_text": "rrCount.getValue();\n",
          "old_line_content": "      if (countSum < bbCount) {",
          "new_line_content": "        auto currCountVal = currCount.getValue();",
          "content_same": false
        },
        {
          "line": 699,
          "old_api": null,
          "new_api": "getSuccessors",
          "old_text": null,
          "new_text": "rmInst->getSuccessors()) ",
          "old_line_content": "              BBToWeightMap[currBB] += numToAdd;",
          "new_line_content": "          for (auto &succ : termInst->getSuccessors()) {",
          "content_same": false
        },
        {
          "line": 700,
          "old_api": null,
          "new_api": "getBB",
          "old_text": null,
          "new_text": "cc.getBB();\n",
          "old_line_content": "            }",
          "new_line_content": "            auto *currBB = succ.getBB();",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": null,
          "new_api": "getCount",
          "old_text": null,
          "new_text": "cc.getCount();\n",
          "old_line_content": "          }",
          "new_line_content": "            auto currCount = succ.getCount();",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "rmInst->getSuccessors().size();\n",
          "old_line_content": "      }",
          "new_line_content": "        auto numOfSucc = termInst->getSuccessors().size();",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": null,
          "new_api": "sert",
          "old_text": null,
          "new_text": "sert(numOfSucc > 0 && \"Expected successors > 0\");\n",
          "old_line_content": "    } else {",
          "new_line_content": "        assert(numOfSucc > 0 && \"Expected successors > 0\");",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "rmInst->getSuccessors().size();\n",
          "old_line_content": "      }",
          "new_line_content": "      auto numOfSucc = termInst->getSuccessors().size();",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": null,
          "new_api": "dToBBCounts",
          "old_text": null,
          "new_text": "dToBBCounts(BBToWeightMap, numToAdd, termInst);\n",
          "old_line_content": "}",
          "new_line_content": "      addToBBCounts(BBToWeightMap, numToAdd, termInst);",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": null,
          "new_api": "pushChildrenIf",
          "old_text": null,
          "new_text": "mOrder.pushChildrenIf(block, [&](SILBasicBlock *child) { return true; });\n",
          "old_line_content": "void SILPerformanceInliner::collectAppliesToInline(",
          "new_line_content": "    domOrder.pushChildrenIf(block, [&](SILBasicBlock *child) { return true; });",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "->get(Caller);\n",
          "old_line_content": "",
          "new_line_content": "  DominanceInfo *DT = DA->get(Caller);",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "->get(Caller);\n",
          "old_line_content": "  // Compute the shortest-path analysis for the caller.",
          "new_line_content": "  SILLoopInfo *LI = LA->get(Caller);",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": null,
          "new_api": "tSPA",
          "old_text": null,
          "new_text": "tSPA(Caller, LI);\n",
          "old_line_content": "",
          "new_line_content": "  ShortestPathAnalysis *SPA = getSPA(Caller, LI);",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": null,
          "new_api": "analyze",
          "old_text": null,
          "new_text": "A->analyze(CBI, [&](FullApplySite FAS) -> int {\n  \n    // This closure returns the length of a called function.\n\n    // At this occasion we record additional weight increases.\n    addWeightCorrection(FAS, WeightCorrections);\n\n    if (SILFunction *Callee = getEligibleFunction(FAS, WhatToInline)) {\n      // Compute the shortest-path analysis for the callee.\n      SILLoopInfo *CalleeLI = LA->get(Callee);\n      ShortestPathAnalysis *CalleeSPA = getSPA(Callee, CalleeLI);\n      if (!CalleeSPA->isValid()) {\n        CalleeSPA->analyze(CBI, [](FullApplySite FAS) {\n          // We don't compute SPA for another call-level. Functions called from\n          // the callee are assumed to have DefaultApplyLength.\n          return DefaultApplyLength;\n        });\n      }\n      int CalleeLength = CalleeSPA->getScopeLength(&Callee->front(), 0);\n      // Just in case the callee is a noreturn function.\n      if (CalleeLength >= ShortestPathAnalysis::InitialDist)\n        return DefaultApplyLength;\n      return CalleeLength;\n    }\n    // Some unknown function.\n    return DefaultApplyLength;\n  });\n",
          "old_line_content": "    // At this occasion we record additional weight increases.",
          "new_line_content": "  SPA->analyze(CBI, [&](FullApplySite FAS) -> int {",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "->get(Callee);\n",
          "old_line_content": "          // We don't compute SPA for another call-level. Functions called from",
          "new_line_content": "      SILLoopInfo *CalleeLI = LA->get(Callee);",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": null,
          "new_api": "tSPA",
          "old_text": null,
          "new_text": "tSPA(Callee, CalleeLI);\n",
          "old_line_content": "          // the callee are assumed to have DefaultApplyLength.",
          "new_line_content": "      ShortestPathAnalysis *CalleeSPA = getSPA(Callee, CalleeLI);",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": null,
          "new_api": "isValid",
          "old_text": null,
          "new_text": "lleeSPA->isValid()) ",
          "old_line_content": "          return DefaultApplyLength;",
          "new_line_content": "      if (!CalleeSPA->isValid()) {",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": null,
          "new_api": "analyze",
          "old_text": null,
          "new_text": "lleeSPA->analyze(CBI, [](FullApplySite FAS) {\n          // We don't compute SPA for another call-level. Functions called from\n          // the callee are assumed to have DefaultApplyLength.\n          return DefaultApplyLength;\n        });\n",
          "old_line_content": "        });",
          "new_line_content": "        CalleeSPA->analyze(CBI, [](FullApplySite FAS) {",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "llee->front(), ",
          "old_line_content": "      return CalleeLength;",
          "new_line_content": "      int CalleeLength = CalleeSPA->getScopeLength(&Callee->front(), 0);",
          "content_same": false
        },
        {
          "line": 766,
          "old_api": null,
          "new_api": "dump",
          "old_text": null,
          "new_text": "A->dump();\n",
          "old_line_content": "  ConstantTracker constTracker(Caller);",
          "new_line_content": "    SPA->dump();",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "ller->size();\n",
          "old_line_content": "",
          "new_line_content": "  int NumCallerBlocks = (int)Caller->size();",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": null,
          "new_api": "lculateBBWeights",
          "old_text": null,
          "new_text": "lculateBBWeights(Caller, DT, BBToWeightMap);\n",
          "old_line_content": "  SmallVector<FullApplySite, 8> InitialCandidates;",
          "new_line_content": "  calculateBBWeights(Caller, DT, BBToWeightMap);",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": null,
          "new_api": "isa<BeginApplyInst>(AI)",
          "old_text": null,
          "new_text": "isa<BeginApplyInst>(AI)",
          "old_line_content": "",
          "new_line_content": "  if (OptMode == OptimizationMode::ForSize && !isa<BeginApplyInst>(AI)) {",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "ock->end(); ",
          "old_line_content": "        continue;",
          "new_line_content": "    for (auto I = block->begin(), E = block->end(); I != E; ++I) {",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": null,
          "new_api": "trackInst",
          "old_text": null,
          "new_text": "nstTracker.trackInst(&*I);\n",
          "old_line_content": "",
          "new_line_content": "      constTracker.trackInst(&*I);",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": null,
          "new_api": "hasSelfParam",
          "old_text": null,
          "new_text": "Callee->hasSelfParam()",
          "old_line_content": "        isClassMethodAtOsize = true;",
          "new_line_content": "    if (Callee->hasSelfParam()) {",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": null,
          "new_api": "getLoweredFunctionType",
          "old_text": null,
          "new_text": "Callee->getLoweredFunctionType()->getSelfInstanceType()",
          "old_line_content": "    }",
          "new_line_content": "      auto SelfTy = Callee->getLoweredFunctionType()->getSelfInstanceType();",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": null,
          "new_api": "mayHaveSuperclass",
          "old_text": null,
          "new_text": "SelfTy->mayHaveSuperclass()",
          "old_line_content": "    // Use command line option to control inlining in Osize mode.",
          "new_line_content": "      if (SelfTy->mayHaveSuperclass() &&",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": null,
          "new_api": "llApplySite::isa(&*I))",
          "old_text": null,
          "new_text": "llApplySite::isa(&*I))\n",
          "old_line_content": "",
          "new_line_content": "      if (!FullApplySite::isa(&*I))",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": null,
          "new_api": "tEligibleFunction",
          "old_text": null,
          "new_text": "tEligibleFunction(AI, WhatToInline);\n",
          "old_line_content": "",
          "new_line_content": "      auto *Callee = getEligibleFunction(AI, WhatToInline);",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": null,
          "new_api": "getFunction",
          "old_text": null,
          "new_text": "AI.getFunction()->getModule().getOptions()",
          "old_line_content": "  // It is always OK to inline a simple call.",
          "new_line_content": "    const uint64_t CallerBaseBenefitReductionFactor = AI.getFunction()->getModule().getOptions().CallerBaseBenefitReductionFactor;",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": null,
          "new_api": "ight",
          "old_text": null,
          "new_text": "ight(0, 0));",
          "old_line_content": "",
          "new_line_content": "          BlockWeight = SPA->getWeight(block, Weight(0, 0));",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": null,
          "new_api": "isPureCall",
          "old_text": null,
          "new_text": "isPureCall(AI, SEA)",
          "old_line_content": "    return true;",
          "new_line_content": "  if (isPureCall(AI, SEA)) {",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": null,
          "new_api": "getFunction",
          "old_text": null,
          "new_text": "AI.getFunction()",
          "old_line_content": "  }",
          "new_line_content": "    LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "content_same": false
        },
        {
          "line": 290,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "Callee->getName()",
          "old_line_content": "",
          "new_line_content": "               llvm::dbgs() << \"    pure-call decision \" << Callee->getName()",
          "content_same": false
        },
        {
          "line": 800,
          "old_api": null,
          "new_api": "cideInWarmBlock",
          "old_text": null,
          "new_text": "cideInWarmBlock(AI, W, constTracker, NumCallerBlocks,\n                              BBToWeightMap))\n",
          "old_line_content": "    }",
          "new_line_content": "        if (decideInWarmBlock(AI, W, constTracker, NumCallerBlocks,",
          "content_same": false
        },
        {
          "line": 802,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "itialCandidates.push_back(AI);\n",
          "old_line_content": "      break;",
          "new_line_content": "          InitialCandidates.push_back(AI);",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": null,
          "new_api": "pushChildrenIf",
          "old_text": null,
          "new_text": "mOrder.pushChildrenIf(block, [&] (SILBasicBlock *child) {\n      if (CBI.isSlowPath(block, child)) {\n        // Handle cold blocks separately.\n        visitColdBlocks(InitialCandidates, child, DT);\n        return false;\n      }\n      return true;\n    });\n",
          "old_line_content": "        return false;",
          "new_line_content": "    domOrder.pushChildrenIf(block, [&] (SILBasicBlock *child) {",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": null,
          "new_api": "isSlowPath",
          "old_text": null,
          "new_text": "I.isSlowPath(block, child)) ",
          "old_line_content": "      }",
          "new_line_content": "      if (CBI.isSlowPath(block, child)) {",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": null,
          "new_api": "sitColdBlocks",
          "old_text": null,
          "new_text": "sitColdBlocks(InitialCandidates, child, DT);\n",
          "old_line_content": "    });",
          "new_line_content": "        visitColdBlocks(InitialCandidates, child, DT);",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "LA->get(Callee)",
          "old_line_content": "  ConstantTracker constTracker(Callee, &callerTracker, AI);",
          "new_line_content": "  SILLoopInfo *LI = LA->get(Callee);",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "DA->get(Callee)",
          "old_line_content": "  // We don't want to blow up code-size",
          "new_line_content": "  DominanceInfo *DT = DA->get(Callee);",
          "content_same": false
        },
        {
          "line": 308,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "Callee->front()",
          "old_line_content": "  // We will only inline if *ALL* dynamic accesses are",
          "new_line_content": "  SILBasicBlock *CalleeEntry = &Callee->front();",
          "content_same": false
        },
        {
          "line": 309,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "Callee->size()",
          "old_line_content": "  // known and have no nested conflict",
          "new_line_content": "  DominanceOrder domOrder(CalleeEntry, DT, Callee->size());",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": null,
          "new_api": "getReferencedFunction",
          "old_text": null,
          "new_text": ".getReferencedFunction();\n",
          "old_line_content": "",
          "new_line_content": "    SILFunction *Callee = AI.getReferencedFunction();",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": null,
          "new_api": "sert",
          "old_text": null,
          "new_text": "sert(Callee && \"apply_inst does not have a direct callee anymore\");\n",
          "old_line_content": "  // Now copy each candidate callee that has a small enough number of",
          "new_line_content": "    assert(Callee && \"apply_inst does not have a direct callee anymore\");",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": null,
          "new_api": "getReferencedFunction",
          "old_text": null,
          "new_text": ".getReferencedFunction();\n",
          "old_line_content": "    if (CalleeCount[Callee] <= CallsToCalleeThreshold) {",
          "new_line_content": "    SILFunction *Callee = AI.getReferencedFunction();",
          "content_same": false
        },
        {
          "line": 834,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "plies.push_back(AI);\n",
          "old_line_content": "",
          "new_line_content": "      Applies.push_back(AI);",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": null,
          "new_api": "getSubstitutionMap",
          "old_text": null,
          "new_text": ".getSubstitutionMap();\n",
          "old_line_content": "  // Go through all blocks of the function, accumulate the cost and find",
          "new_line_content": "  SubstitutionMap CalleeSubstMap = AI.getSubstitutionMap();",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": null,
          "new_api": "getNext",
          "old_text": null,
          "new_text": "mOrder.getNext()) ",
          "old_line_content": "    for (SILInstruction &I : *block) {",
          "new_line_content": "  while (SILBasicBlock *block = domOrder.getNext()) {",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": null,
          "new_api": "shouldOptimize",
          "old_text": null,
          "new_text": "ller->shouldOptimize())\n",
          "old_line_content": "  // don't change anything yet so that the dominator information",
          "new_line_content": "  if (!Caller->shouldOptimize())",
          "content_same": false
        },
        {
          "line": 332,
          "old_api": null,
          "new_api": "getWeight",
          "old_text": null,
          "new_text": "A->getWeight(block, CallerWeight);\n",
          "old_line_content": "",
          "new_line_content": "    Weight BlockW = SPA->getWeight(block, CallerWeight);",
          "content_same": false
        },
        {
          "line": 337,
          "old_api": null,
          "new_api": "structionInlineCost",
          "old_text": null,
          "new_text": "structionInlineCost(I);\n",
          "old_line_content": "        // threshold, because inlining will (probably) eliminate the closure.",
          "new_line_content": "      CalleeCost += (int)instructionInlineCost(I);",
          "content_same": false
        },
        {
          "line": 850,
          "old_api": null,
          "new_api": "llectAppliesToInline",
          "old_text": null,
          "new_text": "llectAppliesToInline(Caller, AppliesToInline);\n",
          "old_line_content": "",
          "new_line_content": "  collectAppliesToInline(Caller, AppliesToInline);",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "pliesToInline.empty())\n",
          "old_line_content": "  for (auto AI : AppliesToInline) {",
          "new_line_content": "  if (AppliesToInline.empty())",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": null,
          "new_api": "getCallee",
          "old_text": null,
          "new_text": "I.getCallee());",
          "old_line_content": "        // optimizations like devirtualization or generic specialization. ",
          "new_line_content": "        SILInstruction *def = constTracker.getDefInCaller(FAI.getCallee());",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": null,
          "new_api": "a<PartialApplyInst>(def)))",
          "old_text": null,
          "new_text": "a<PartialApplyInst>(def)))",
          "old_line_content": "        if (!def)",
          "new_line_content": "        if (def && (isa<FunctionRefInst>(def) || isa<PartialApplyInst>(def)))",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": null,
          "new_api": "getReferencedFunction",
          "old_text": null,
          "new_text": ".getReferencedFunction();\n",
          "old_line_content": "      continue;",
          "new_line_content": "    SILFunction *Callee = AI.getReferencedFunction();",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": null,
          "new_api": "sert",
          "old_text": null,
          "new_text": "sert(Callee && \"apply_inst does not have a direct callee anymore\");\n",
          "old_line_content": "    }",
          "new_line_content": "    assert(Callee && \"apply_inst does not have a direct callee anymore\");",
          "content_same": false
        },
        {
          "line": 348,
          "old_api": null,
          "new_api": "getCallee",
          "old_text": null,
          "new_text": "I.getCallee());",
          "old_line_content": "",
          "new_line_content": "          def = dyn_cast_or_null<SingleValueInstruction>(FAI.getCallee());",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": null,
          "new_api": "shouldOptimize",
          "old_text": null,
          "new_text": "llee->shouldOptimize()) ",
          "old_line_content": "    SmallVector<SILValue, 8> Args;",
          "new_line_content": "    if (!Callee->shouldOptimize()) {",
          "content_same": false
        },
        {
          "line": 353,
          "old_api": null,
          "new_api": "getSubstitutionMap",
          "old_text": null,
          "new_text": "I.getSubstitutionMap();\n",
          "old_line_content": "          continue;",
          "new_line_content": "        auto Subs = FAI.getSubstitutionMap();",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "llee->size() <",
          "old_line_content": "    SILOpenedArchetypesTracker OpenedArchetypesTracker(Caller);",
          "new_line_content": "               llvm::dbgs() << \"    inline [\" << Callee->size() << \"->\"",
          "content_same": false
        },
        {
          "line": 359,
          "old_api": null,
          "new_api": "a<ClassMethodInst>(def) &",
          "old_text": null,
          "new_text": "a<ClassMethodInst>(def) &",
          "old_line_content": "        // It is a generic call inside the callee. Check if after inlining",
          "new_line_content": "        if (!isa<FunctionRefInst>(def) && !isa<ClassMethodInst>(def) &&",
          "content_same": false
        },
        {
          "line": 360,
          "old_api": null,
          "new_api": "a<WitnessMethodInst>(def))",
          "old_text": null,
          "new_text": "a<WitnessMethodInst>(def))\n",
          "old_line_content": "        // it will be possible to perform a generic specialization or",
          "new_line_content": "            !isa<WitnessMethodInst>(def))",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "llee->getName() <",
          "old_line_content": "        &OpenedArchetypesTracker);",
          "new_line_content": "                            << \"] \" << Callee->getName() << \"\\n\");",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": null,
          "new_api": "getInstruction",
          "old_text": null,
          "new_text": ".getInstruction());",
          "old_line_content": "",
          "new_line_content": "    OpenedArchetypesTracker.registerUsedOpenedArchetypes(AI.getInstruction());",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": null,
          "new_api": "getSubstitutionMap",
          "old_text": null,
          "new_text": ".getSubstitutionMap(), ",
          "old_line_content": "    //",
          "new_line_content": "                       AI.getSubstitutionMap(), OpenedArchetypesTracker);",
          "content_same": false
        },
        {
          "line": 373,
          "old_api": null,
          "new_api": "a<SuperMethodInst>(def))",
          "old_text": null,
          "new_text": "a<SuperMethodInst>(def)) ",
          "old_line_content": "                                       \"after inlining for the call:\\n\";",
          "new_line_content": "            isa<SuperMethodInst>(def)) {",
          "content_same": false
        },
        {
          "line": 376,
          "old_api": null,
          "new_api": "vm::dbgs() <",
          "old_text": null,
          "new_text": "vm::dbgs() <",
          "old_line_content": "          }",
          "new_line_content": "            LLVM_DEBUG(llvm::dbgs() << \"Devirtualization will be possible \"",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": null,
          "new_api": "inlineFunction",
          "old_text": null,
          "new_text": "liner.inlineFunction(Callee, AI, Args);\n",
          "old_line_content": "}",
          "new_line_content": "    Inliner.inlineFunction(Callee, AI, Args);",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": null,
          "new_api": "getInstruction",
          "old_text": null,
          "new_text": "I.getInstruction()->dumpInContext());",
          "old_line_content": "",
          "new_line_content": "                       FAI.getInstruction()->dumpInContext());",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": null,
          "new_api": "updateBenefit",
          "old_text": null,
          "new_text": "ockW.updateBenefit(Benefit, DevirtualizedCallBenefit);\n",
          "old_line_content": "        // Check if a generic specialization would be possible.",
          "new_line_content": "            BlockW.updateBenefit(Benefit, DevirtualizedCallBenefit);",
          "content_same": false
        },
        {
          "line": 385,
          "old_api": null,
          "new_api": "getCalleeFunction",
          "old_text": null,
          "new_text": "I.getCalleeFunction();\n",
          "old_line_content": "                                     \"after inlining for the call:\\n\";",
          "new_line_content": "          auto CalleeF = FAI.getCalleeFunction();",
          "content_same": false
        },
        {
          "line": 388,
          "old_api": null,
          "new_api": "vm::dbgs() <",
          "old_text": null,
          "new_text": "vm::dbgs() <",
          "old_line_content": "        }",
          "new_line_content": "          LLVM_DEBUG(llvm::dbgs() << \"Generic specialization will be possible \"",
          "content_same": false
        },
        {
          "line": 900,
          "old_api": null,
          "new_api": "getNext",
          "old_text": null,
          "new_text": "mOrder.getNext()) ",
          "old_line_content": "        continue;",
          "new_line_content": "  while (SILBasicBlock *block = domOrder.getNext()) {",
          "content_same": false
        },
        {
          "line": 390,
          "old_api": null,
          "new_api": "getInstruction",
          "old_text": null,
          "new_text": "I.getInstruction()->dumpInContext());",
          "old_line_content": "        // Check if it's a load from a stack location in the caller. Such a load",
          "new_line_content": "                     FAI.getInstruction()->dumpInContext());",
          "content_same": false
        },
        {
          "line": 391,
          "old_api": null,
          "new_api": "updateBenefit",
          "old_text": null,
          "new_text": "ockW.updateBenefit(Benefit, GenericSpecializationBenefit);\n",
          "old_line_content": "        // might be optimized away if inlined.",
          "new_line_content": "          BlockW.updateBenefit(Benefit, GenericSpecializationBenefit);",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": null,
          "new_api": "tEligibleFunction",
          "old_text": null,
          "new_text": "tEligibleFunction(AI, WhatToInline);\n",
          "old_line_content": "    }",
          "new_line_content": "      auto *Callee = getEligibleFunction(AI, WhatToInline);",
          "content_same": false
        },
        {
          "line": 396,
          "old_api": null,
          "new_api": "getOperand",
          "old_text": null,
          "new_text": "->getOperand()))",
          "old_line_content": "        // might be optimized away if inlined.",
          "new_line_content": "        if (constTracker.isStackAddrInCaller(LI->getOperand()))",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "pliesToInline.push_back(AI);\n",
          "old_line_content": "  }",
          "new_line_content": "        AppliesToInline.push_back(AI);",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": null,
          "new_api": "pushChildren",
          "old_text": null,
          "new_text": "mOrder.pushChildren(block);\n",
          "old_line_content": "",
          "new_line_content": "    domOrder.pushChildren(block);",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": null,
          "new_api": "a<ReleaseValueInst>(&I))",
          "old_text": null,
          "new_text": "a<ReleaseValueInst>(&I)) ",
          "old_line_content": "              SILArgumentConvention::Direct_Guaranteed) {",
          "new_line_content": "      } else if (isa<StrongReleaseInst>(&I) || isa<ReleaseValueInst>(&I)) {",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": null,
          "new_api": "n_cast<SILFunctionArgument>(Op))",
          "old_text": null,
          "new_text": "n_cast<SILFunctionArgument>(Op)) ",
          "old_line_content": "          }",
          "new_line_content": "        if (auto *Arg = dyn_cast<SILFunctionArgument>(Op)) {",
          "content_same": false
        },
        {
          "line": 406,
          "old_api": null,
          "new_api": "getArgumentConvention",
          "old_text": null,
          "new_text": "g->getArgumentConvention() =",
          "old_line_content": "        }",
          "new_line_content": "          if (Arg->getArgumentConvention() ==",
          "content_same": false
        },
        {
          "line": 412,
          "old_api": null,
          "new_api": "getBuiltinInfo",
          "old_text": null,
          "new_text": "->getBuiltinInfo().I",
          "old_line_content": "          // The access is dynamic and has no nested conflict",
          "new_line_content": "        if (BI->getBuiltinInfo().ID == BuiltinValueKind::OnFastPath)",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": null,
          "new_api": "updateBenefit",
          "old_text": null,
          "new_text": "ockW.updateBenefit(Benefit, FastPathBuiltinBenefit);\n",
          "old_line_content": "          // See if the storage location is considered by",
          "new_line_content": "          BlockW.updateBenefit(Benefit, FastPathBuiltinBenefit);",
          "content_same": false
        },
        {
          "line": 414,
          "old_api": null,
          "new_api": "n_cast<BeginAccessInst>(&I))",
          "old_text": null,
          "new_text": "n_cast<BeginAccessInst>(&I)) ",
          "old_line_content": "          // access enforcement optimizations",
          "new_line_content": "      } else if (auto *BAI = dyn_cast<BeginAccessInst>(&I)) {",
          "content_same": false
        },
        {
          "line": 415,
          "old_api": null,
          "new_api": "getEnforcement",
          "old_text": null,
          "new_text": "I->getEnforcement() =",
          "old_line_content": "          AccessedStorage storage =",
          "new_line_content": "        if (BAI->getEnforcement() == SILAccessEnforcement::Dynamic) {",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": null,
          "new_api": "hasNoNestedConflict",
          "old_text": null,
          "new_text": "I->hasNoNestedConflict() &",
          "old_line_content": "          } else {",
          "new_line_content": "          if (BAI->hasNoNestedConflict() &&",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": null,
          "new_api": "isUniquelyIdentified",
          "old_text": null,
          "new_text": "orage.isUniquelyIdentified() |",
          "old_line_content": "            AllAccessesBeneficialToInline = false;",
          "new_line_content": "              (storage.isUniquelyIdentified() ||",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": null,
          "new_api": "getKind",
          "old_text": null,
          "new_text": "orage.getKind() =",
          "old_line_content": "          }",
          "new_line_content": "               storage.getKind() == AccessedStorage::Class)) {",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": null,
          "new_api": "updateBenefit",
          "old_text": null,
          "new_text": "ockW.updateBenefit(ExclusivityBenefitWeight, ExclusivityBenefit);\n",
          "old_line_content": "        }",
          "new_line_content": "            BlockW.updateBenefit(ExclusivityBenefitWeight, ExclusivityBenefit);",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": null,
          "new_api": "->getAnalysis<DominanceAnalysis>();",
          "old_text": null,
          "new_text": "->getAnalysis<DominanceAnalysis>();\n",
          "old_line_content": "",
          "new_line_content": "    DominanceAnalysis *DA = PM->getAnalysis<DominanceAnalysis>();",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": null,
          "new_api": "->getAnalysis<SideEffectAnalysis>();",
          "old_text": null,
          "new_text": "->getAnalysis<SideEffectAnalysis>();\n",
          "old_line_content": "      return;",
          "new_line_content": "    SideEffectAnalysis *SEA = PM->getAnalysis<SideEffectAnalysis>();",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": null,
          "new_api": "getEffectiveOptimizationMode",
          "old_text": null,
          "new_text": "tFunction()->getEffectiveOptimizationMode();\n",
          "old_line_content": "\t\t\t\t  OptMode, ORE);",
          "new_line_content": "    auto OptMode = getFunction()->getEffectiveOptimizationMode();",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": null,
          "new_api": "updateBenefit",
          "old_text": null,
          "new_text": "ockW.updateBenefit(Benefit, RemovedTerminatorBenefit);\n",
          "old_line_content": "      });",
          "new_line_content": "      BlockW.updateBenefit(Benefit, RemovedTerminatorBenefit);",
          "content_same": false
        },
        {
          "line": 435,
          "old_api": null,
          "new_api": "pushChildrenIf",
          "old_text": null,
          "new_text": "mOrder.pushChildrenIf(block, [=](SILBasicBlock *child) {\n        return child->getSinglePredecessorBlock() != block ||\n               child == takenBlock;\n      });\n",
          "old_line_content": "    } else {",
          "new_line_content": "      domOrder.pushChildrenIf(block, [=](SILBasicBlock *child) {",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": null,
          "new_api": "isDefinition",
          "old_text": null,
          "new_text": "tFunction()->isDefinition() &",
          "old_line_content": "    // analyses for this function and restart the pipeline so that we",
          "new_line_content": "    assert(getFunction()->isDefinition() &&",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": null,
          "new_api": "pushChildren",
          "old_text": null,
          "new_text": "mOrder.pushChildren(block);\n",
          "old_line_content": "  if (AllAccessesBeneficialToInline) {",
          "new_line_content": "      domOrder.pushChildren(block);",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": null,
          "new_api": "tFunction",
          "old_text": null,
          "new_text": "tFunction()))",
          "old_line_content": "  }",
          "new_line_content": "    if (Inliner.inlineCallsIntoFunction(getFunction())) {",
          "content_same": false
        },
        {
          "line": 445,
          "old_api": null,
          "new_api": "d::max(Benefit, ExclusivityBenefitWeight);",
          "old_text": null,
          "new_text": "d::max(Benefit, ExclusivityBenefitWeight);\n",
          "old_line_content": "    // Only inline trivial functions into thunks (which will not increase the",
          "new_line_content": "    Benefit = std::max(Benefit, ExclusivityBenefitWeight);",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": null,
          "new_api": "validateAnalysis",
          "old_text": null,
          "new_text": "validateAnalysis(SILAnalysis::InvalidationKind::FunctionBody);\n",
          "old_line_content": "",
          "new_line_content": "      invalidateAnalysis(SILAnalysis::InvalidationKind::FunctionBody);",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": null,
          "new_api": "startPassPipeline",
          "old_text": null,
          "new_text": "startPassPipeline();\n",
          "old_line_content": "};",
          "new_line_content": "      restartPassPipeline();",
          "content_same": false
        },
        {
          "line": 448,
          "old_api": null,
          "new_api": "getFunction",
          "old_text": null,
          "new_text": ".getFunction()->isThunk()) ",
          "old_line_content": "      return false;",
          "new_line_content": "  if (AI.getFunction()->isThunk()) {",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": null,
          "new_api": "getFunction",
          "old_text": null,
          "new_text": ".getFunction());",
          "old_line_content": "  }",
          "new_line_content": "    LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": null,
          "new_api": "vm::dbgs() <",
          "old_text": null,
          "new_text": "vm::dbgs() <",
          "old_line_content": "",
          "new_line_content": "               llvm::dbgs() << \"    decision {\" << CalleeCost << \" into thunk} \"",
          "content_same": false
        },
        {
          "line": 457,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "llee->getName() <",
          "old_line_content": "  // We reduce the benefit if the caller is too large. For this we use a",
          "new_line_content": "                            << Callee->getName() << '\\n');",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": null,
          "new_api": "getInstruction",
          "old_text": null,
          "new_text": ".getInstruction()->getParent();\n",
          "old_line_content": "                                NumCallerBlocks, bbIt);",
          "new_line_content": "  auto *bb = AI.getInstruction()->getParent();",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "ToWeightMap.find(bb);\n",
          "old_line_content": "  }",
          "new_line_content": "  auto bbIt = BBToWeightMap.find(bb);",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "ToWeightMap.end()) ",
          "old_line_content": "  if (isClassMethodAtOsize && Benefit > OSizeClassMethodBenefit) {",
          "new_line_content": "  if (bbIt != BBToWeightMap.end()) {",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": null,
          "new_api": "ofileBasedDecision",
          "old_text": null,
          "new_text": "ofileBasedDecision(AI, Benefit, Callee, CalleeCost,\n                                NumCallerBlocks, bbIt);\n",
          "old_line_content": "    Benefit = OSizeClassMethodBenefit;",
          "new_line_content": "    return profileBasedDecision(AI, Benefit, Callee, CalleeCost,",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": null,
          "new_api": "getInstruction",
          "old_text": null,
          "new_text": ".getInstruction())\n",
          "old_line_content": "    });",
          "new_line_content": "      return RemarkMissed(\"NoInlinedCost\", *AI.getInstruction())",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": null,
          "new_api": "(\"Callee\", Callee)",
          "old_text": null,
          "new_text": "(\"Callee\", Callee)\n ",
          "old_line_content": "    return false;",
          "new_line_content": "             << \"Not profitable to inline function \" << NV(\"Callee\", Callee)",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": null,
          "new_api": "(\"Cost\", CalleeCost)",
          "old_text": null,
          "new_text": "(\"Cost\", CalleeCost)\n ",
          "old_line_content": "  }",
          "new_line_content": "             << \" (cost = \" << NV(\"Cost\", CalleeCost)",
          "content_same": false
        },
        {
          "line": 490,
          "old_api": null,
          "new_api": "(\"Benefit\", Benefit) <",
          "old_text": null,
          "new_text": "(\"Benefit\", Benefit) <",
          "old_line_content": "",
          "new_line_content": "             << \", benefit = \" << NV(\"Benefit\", Benefit) << \")\";",
          "content_same": false
        },
        {
          "line": 495,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "llee->size();\n",
          "old_line_content": "                          << \", b=\" << Benefit",
          "new_line_content": "  NumCallerBlocks += Callee->size();",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": null,
          "new_api": "getFunction",
          "old_text": null,
          "new_text": ".getFunction());",
          "old_line_content": "                          << \", c-w=\" << CallerWeight",
          "new_line_content": "  LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "llee->size()\n ",
          "old_line_content": "    using namespace OptRemark;",
          "new_line_content": "                          << \", bb=\" << Callee->size()",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": null,
          "new_api": "(\"Callee\", Callee) <",
          "old_text": null,
          "new_text": "(\"Callee\", Callee) <",
          "old_line_content": "  });",
          "new_line_content": "           << NV(\"Callee\", Callee) << \" inlined into \"",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": null,
          "new_api": "getFunction",
          "old_text": null,
          "new_text": ".getFunction())\n",
          "old_line_content": "",
          "new_line_content": "           << NV(\"Caller\", AI.getFunction())",
          "content_same": false
        },
        {
          "line": 510,
          "old_api": null,
          "new_api": "(\"Cost\", CalleeCost)",
          "old_text": null,
          "new_text": "(\"Cost\", CalleeCost)\n ",
          "old_line_content": "  return true;",
          "new_line_content": "           << \" (cost = \" << NV(\"Cost\", CalleeCost)",
          "content_same": false
        },
        {
          "line": 511,
          "old_api": null,
          "new_api": "(\"Benefit\", Benefit) <",
          "old_text": null,
          "new_text": "(\"Benefit\", Benefit) <",
          "old_line_content": "}",
          "new_line_content": "           << \", benefit = \" << NV(\"Benefit\", Benefit) << \")\";",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 520,
          "old_api": "hasSubstitutions",
          "new_api": null,
          "old_text": ".hasSubstitutions() &",
          "new_text": null,
          "old_line_content": "  assert(AI.hasSubstitutions() &&",
          "new_line_content": "/// It returns false if a function should not be inlined.",
          "content_same": false
        },
        {
          "line": 523,
          "old_api": "getReferencedFunction",
          "new_api": null,
          "old_text": ".getReferencedFunction();\n",
          "new_text": null,
          "old_line_content": "  SILFunction *Callee = AI.getReferencedFunction();",
          "new_line_content": "static Optional<bool> shouldInlineGeneric(FullApplySite AI) {",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": "getSwiftModule",
          "new_api": null,
          "old_text": "llee->getModule().getSwiftModule();\n",
          "new_text": null,
          "old_line_content": "  ModuleDecl *SwiftModule = Callee->getModule().getSwiftModule();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": "hasSemanticsAttrThatStartsWith",
          "new_api": null,
          "old_text": "llee->hasSemanticsAttrThatStartsWith(\"array.\") &",
          "new_text": null,
          "old_line_content": "  if (Callee->hasSemanticsAttrThatStartsWith(\"array.\") &&",
          "new_line_content": "  // Do not inline @_semantics functions when compiling the stdlib,",
          "content_same": false
        },
        {
          "line": 530,
          "old_api": "isOnoneSupportModule",
          "new_api": null,
          "old_text": "iftModule->isOnoneSupportModule()))",
          "new_text": null,
          "old_line_content": "      (SwiftModule->isStdlibModule() || SwiftModule->isOnoneSupportModule()))",
          "new_line_content": "  // because they need to be preserved, so that the optimizer",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": "isTransparent",
          "new_api": null,
          "old_text": "llee->isTransparent())\n",
          "new_text": null,
          "old_line_content": "  if (Callee->getInlineStrategy() == AlwaysInline || Callee->isTransparent())",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": "getSubstitutionMap",
          "new_api": null,
          "old_text": ".getSubstitutionMap().hasArchetypes())\n",
          "new_text": null,
          "old_line_content": "  if (!AI.getSubstitutionMap().hasArchetypes())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": "hasSubstitutions",
          "new_api": null,
          "old_text": ".hasSubstitutions()) ",
          "new_text": null,
          "old_line_content": "  if (AI.hasSubstitutions()) {",
          "new_line_content": "bool SILPerformanceInliner::decideInWarmBlock(",
          "content_same": false
        },
        {
          "line": 563,
          "old_api": "ouldInlineGeneric",
          "new_api": null,
          "old_text": "ouldInlineGeneric(AI);\n",
          "new_text": null,
          "old_line_content": "    auto ShouldInlineGeneric = shouldInlineGeneric(AI);",
          "new_line_content": "    int &NumCallerBlocks,",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": "hasValue",
          "new_api": null,
          "old_text": "ouldInlineGeneric.hasValue())\n",
          "new_text": null,
          "old_line_content": "    if (ShouldInlineGeneric.hasValue())",
          "new_line_content": "    const llvm::DenseMap<SILBasicBlock *, uint64_t> &BBToWeightMap) {",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": "isTransparent",
          "new_api": null,
          "old_text": "llee->isTransparent()) ",
          "new_text": null,
          "old_line_content": "  if (Callee->getInlineStrategy() == AlwaysInline || Callee->isTransparent()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": "getFunction",
          "new_api": null,
          "old_text": ".getFunction());",
          "new_text": null,
          "old_line_content": "    LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": "getName",
          "new_api": null,
          "old_text": "llee->getName() <",
          "new_text": null,
          "old_line_content": "                            << Callee->getName() << '\\n');",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": "hasSubstitutions",
          "new_api": null,
          "old_text": ".hasSubstitutions()) ",
          "new_text": null,
          "old_line_content": "  if (AI.hasSubstitutions()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": "ouldInlineGeneric",
          "new_api": null,
          "old_text": "ouldInlineGeneric(AI);\n",
          "new_text": null,
          "old_line_content": "    auto ShouldInlineGeneric = shouldInlineGeneric(AI);",
          "new_line_content": "bool SILPerformanceInliner::decideInColdBlock(FullApplySite AI,",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": "hasValue",
          "new_api": null,
          "old_text": "ouldInlineGeneric.hasValue())\n",
          "new_text": null,
          "old_line_content": "    if (ShouldInlineGeneric.hasValue())",
          "new_line_content": "                                              SILFunction *Callee) {",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": "isTransparent",
          "new_api": null,
          "old_text": "llee->isTransparent()) ",
          "new_text": null,
          "old_line_content": "  if (Callee->getInlineStrategy() == AlwaysInline || Callee->isTransparent()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": "getFunction",
          "new_api": null,
          "old_text": ".getFunction());",
          "new_text": null,
          "old_line_content": "    LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "vm::dbgs() <",
          "new_api": null,
          "old_text": "vm::dbgs() <",
          "new_text": null,
          "old_line_content": "               llvm::dbgs() << \"    always-inline decision \"",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": "getName",
          "new_api": null,
          "old_text": "llee->getName() <",
          "new_text": null,
          "old_line_content": "                            << Callee->getName() << '\\n');",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": "structionInlineCost",
          "new_api": null,
          "old_text": "structionInlineCost(I));",
          "new_text": null,
          "old_line_content": "      CalleeCost += int(instructionInlineCost(I));",
          "new_line_content": "  int CalleeCost = 0;",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": "getFunction",
          "new_api": null,
          "old_text": ".getFunction());",
          "new_text": null,
          "old_line_content": "  LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "new_line_content": "      if (CalleeCost > TrivialFunctionThreshold)",
          "content_same": false
        },
        {
          "line": 610,
          "old_api": "vm::dbgs() <",
          "new_api": null,
          "old_text": "vm::dbgs() <",
          "new_text": null,
          "old_line_content": "             llvm::dbgs() << \"    cold decision {\" << CalleeCost << \"} \"",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": "getName",
          "new_api": null,
          "old_text": "llee->getName() <",
          "new_text": null,
          "old_line_content": "                          << Callee->getName() << '\\n');",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": "getReferencedFunction",
          "new_api": null,
          "old_text": "S.getReferencedFunction();\n",
          "new_text": null,
          "old_line_content": "  SILFunction *Callee = FAS.getReferencedFunction();",
          "new_line_content": "/// the additional weight is for _another_ function than the current handled",
          "content_same": false
        },
        {
          "line": 623,
          "old_api": "hasSemanticsAttr",
          "new_api": null,
          "old_text": "llee->hasSemanticsAttr(\"array.uninitialized\")) ",
          "new_text": null,
          "old_line_content": "  if (Callee && Callee->hasSemanticsAttr(\"array.uninitialized\")) {",
          "new_line_content": "/// callee.",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": "getArgument",
          "new_api": null,
          "old_text": "S.getArgument(0);\n",
          "new_text": null,
          "old_line_content": "    SILValue BufferArg = FAS.getArgument(0);",
          "new_line_content": "    // We want to inline the argument to an array.uninitialized call, because",
          "content_same": false
        },
        {
          "line": 629,
          "old_api": "ripCasts",
          "new_api": null,
          "old_text": "ripCasts(BufferArg));",
          "new_text": null,
          "old_line_content": "    SILValue Base = stripValueProjections(stripCasts(BufferArg));",
          "new_line_content": "    // this argument is most likely a call to a function which contains the",
          "content_same": false
        },
        {
          "line": 630,
          "old_api": "llApplySite::isa(Base))",
          "new_api": null,
          "old_text": "llApplySite::isa(Base))\n",
          "new_text": null,
          "old_line_content": "    if (auto BaseApply = FullApplySite::isa(Base))",
          "new_line_content": "    // buffer allocation for the array. It is essential to inline it for stack",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": "getSuccessors",
          "new_api": null,
          "old_text": "st->getSuccessors()) ",
          "new_text": null,
          "old_line_content": "  for (auto &succ : inst->getSuccessors()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 637,
          "old_api": "getCount",
          "new_api": null,
          "old_text": "cc.getCount()) ",
          "new_text": null,
          "old_line_content": "    if (succ.getCount()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": "getSuccessors",
          "new_api": null,
          "old_text": "rmInst->getSuccessors()) ",
          "new_text": null,
          "old_line_content": "  for (auto &succ : termInst->getSuccessors()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": "getBB",
          "new_api": null,
          "old_text": "cc.getBB();\n",
          "new_text": null,
          "old_line_content": "    auto *currBB = succ.getBB();",
          "new_line_content": "static void",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": "end",
          "new_api": null,
          "old_text": "ToWeightMap.end() &",
          "new_text": null,
          "old_line_content": "    assert(BBToWeightMap.find(currBB) != BBToWeightMap.end() &&",
          "new_line_content": "addToBBCounts(llvm::DenseMap<SILBasicBlock *, uint64_t> &BBToWeightMap,",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": "getEntryCount",
          "new_api": null,
          "old_text": "ller->getEntryCount();\n",
          "new_text": null,
          "old_line_content": "  auto entryCount = Caller->getEntryCount();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": "getBlocks",
          "new_api": null,
          "old_text": "ller->getBlocks()) ",
          "new_text": null,
          "old_line_content": "  for (auto &block : Caller->getBlocks()) {",
          "new_line_content": "    // No profile for function - return",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": "getValue",
          "new_api": null,
          "old_text": "tryCount.getValue();\n",
          "new_text": null,
          "old_line_content": "  BBToWeightMap[Caller->getEntryBlock()] = entryCount.getValue();",
          "new_line_content": "  // Add all blocks to BBToWeightMap without count 0",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": "getNext",
          "new_api": null,
          "old_text": "mOrder.getNext()) ",
          "new_text": null,
          "old_line_content": "  while (SILBasicBlock *block = domOrder.getNext()) {",
          "new_line_content": "    BBToWeightMap[&block] = 0;",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": "find",
          "new_api": null,
          "old_text": "ToWeightMap.find(block);\n",
          "new_text": null,
          "old_line_content": "    auto bbIt = BBToWeightMap.find(block);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": "getBB",
          "new_api": null,
          "old_text": "cc.getBB();\n",
          "new_text": null,
          "old_line_content": "        auto *currBB = succ.getBB();",
          "new_line_content": "      // Instruction already contains accurate counters - use them as-is",
          "content_same": false
        },
        {
          "line": 680,
          "old_api": "end",
          "new_api": null,
          "old_text": "ToWeightMap.end() &",
          "new_text": null,
          "old_line_content": "        assert(BBToWeightMap.find(currBB) != BBToWeightMap.end() &&",
          "new_line_content": "      uint64_t countSum = 0;",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "getValue",
          "new_api": null,
          "old_text": "rrCount.getValue();\n",
          "new_text": null,
          "old_line_content": "        auto currCountVal = currCount.getValue();",
          "new_line_content": "        if (!currCount) {",
          "content_same": false
        },
        {
          "line": 695,
          "old_api": "getSuccessors",
          "new_api": null,
          "old_text": "rmInst->getSuccessors()) ",
          "new_text": null,
          "old_line_content": "          for (auto &succ : termInst->getSuccessors()) {",
          "new_line_content": "      if (countSum < bbCount) {",
          "content_same": false
        },
        {
          "line": 696,
          "old_api": "getBB",
          "new_api": null,
          "old_text": "cc.getBB();\n",
          "new_text": null,
          "old_line_content": "            auto *currBB = succ.getBB();",
          "new_line_content": "        // inaccurate profile - fill in the gaps for BBs without a count:",
          "content_same": false
        },
        {
          "line": 697,
          "old_api": "getCount",
          "new_api": null,
          "old_text": "cc.getCount();\n",
          "new_text": null,
          "old_line_content": "            auto currCount = succ.getCount();",
          "new_line_content": "        if (blocksWithoutCount > 0) {",
          "content_same": false
        },
        {
          "line": 704,
          "old_api": "size",
          "new_api": null,
          "old_text": "rmInst->getSuccessors().size();\n",
          "new_text": null,
          "old_line_content": "        auto numOfSucc = termInst->getSuccessors().size();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": "sert",
          "new_api": null,
          "old_text": "sert(numOfSucc > 0 && \"Expected successors > 0\");\n",
          "new_text": null,
          "old_line_content": "        assert(numOfSucc > 0 && \"Expected successors > 0\");",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 707,
          "old_api": "dToBBCounts",
          "new_api": null,
          "old_text": "dToBBCounts(BBToWeightMap, numToAdd, termInst);\n",
          "new_text": null,
          "old_line_content": "        addToBBCounts(BBToWeightMap, numToAdd, termInst);",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": "dToBBCounts",
          "new_api": null,
          "old_text": "dToBBCounts(BBToWeightMap, numToAdd, termInst);\n",
          "new_text": null,
          "old_line_content": "      addToBBCounts(BBToWeightMap, numToAdd, termInst);",
          "new_line_content": "        // No successors to fill",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": "pushChildrenIf",
          "new_api": null,
          "old_text": "mOrder.pushChildrenIf(block, [&](SILBasicBlock *child) { return true; });\n",
          "new_text": null,
          "old_line_content": "    domOrder.pushChildrenIf(block, [&](SILBasicBlock *child) { return true; });",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": "get",
          "new_api": null,
          "old_text": "->get(Caller);\n",
          "new_text": null,
          "old_line_content": "  DominanceInfo *DT = DA->get(Caller);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": "get",
          "new_api": null,
          "old_text": "->get(Caller);\n",
          "new_text": null,
          "old_line_content": "  SILLoopInfo *LI = LA->get(Caller);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": "tSPA",
          "new_api": null,
          "old_text": "tSPA(Caller, LI);\n",
          "new_text": null,
          "old_line_content": "  ShortestPathAnalysis *SPA = getSPA(Caller, LI);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 732,
          "old_api": "analyze",
          "new_api": null,
          "old_text": "A->analyze(CBI, [&](FullApplySite FAS) -> int {\n  \n    // This closure returns the length of a called function.\n\n    // At this occasion we record additional weight increases.\n    addWeightCorrection(FAS, WeightCorrections);\n\n    if (SILFunction *Callee = getEligibleFunction(FAS, WhatToInline)) {\n      // Compute the shortest-path analysis for the callee.\n      SILLoopInfo *CalleeLI = LA->get(Callee);\n      ShortestPathAnalysis *CalleeSPA = getSPA(Callee, CalleeLI);\n      if (!CalleeSPA->isValid()) {\n        CalleeSPA->analyze(CBI, [](FullApplySite FAS) {\n          // We don't compute SPA for another call-level. Functions called from\n          // the callee are assumed to have DefaultApplyLength.\n          return DefaultApplyLength;\n        });\n      }\n      int CalleeLength = CalleeSPA->getScopeLength(&Callee->front(), 0);\n      // Just in case the callee is a noreturn function.\n      if (CalleeLength >= ShortestPathAnalysis::InitialDist)\n        return DefaultApplyLength;\n      return CalleeLength;\n    }\n    // Some unknown function.\n    return DefaultApplyLength;\n  });\n",
          "new_text": null,
          "old_line_content": "  SPA->analyze(CBI, [&](FullApplySite FAS) -> int {",
          "new_line_content": "  llvm::DenseMap<FullApplySite, int> WeightCorrections;",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": "dWeightCorrection",
          "new_api": null,
          "old_text": "dWeightCorrection(FAS, WeightCorrections);\n",
          "new_text": null,
          "old_line_content": "    addWeightCorrection(FAS, WeightCorrections);",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": "tEligibleFunction",
          "new_api": null,
          "old_text": "tEligibleFunction(FAS, WhatToInline)) ",
          "new_text": null,
          "old_line_content": "    if (SILFunction *Callee = getEligibleFunction(FAS, WhatToInline)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": "tSPA",
          "new_api": null,
          "old_text": "tSPA(Callee, CalleeLI);\n",
          "new_text": null,
          "old_line_content": "      ShortestPathAnalysis *CalleeSPA = getSPA(Callee, CalleeLI);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": "analyze",
          "new_api": null,
          "old_text": "lleeSPA->analyze(CBI, [](FullApplySite FAS) {\n          // We don't compute SPA for another call-level. Functions called from\n          // the callee are assumed to have DefaultApplyLength.\n          return DefaultApplyLength;\n        });\n",
          "new_text": null,
          "old_line_content": "        CalleeSPA->analyze(CBI, [](FullApplySite FAS) {",
          "new_line_content": "      // Compute the shortest-path analysis for the callee.",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": "front",
          "new_api": null,
          "old_text": "llee->front(), ",
          "new_text": null,
          "old_line_content": "      int CalleeLength = CalleeSPA->getScopeLength(&Callee->front(), 0);",
          "new_line_content": "          // the callee are assumed to have DefaultApplyLength.",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": "dump",
          "new_api": null,
          "old_text": "A->dump();\n",
          "new_text": null,
          "old_line_content": "    SPA->dump();",
          "new_line_content": "  });",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": "size",
          "new_api": null,
          "old_text": "ller->size());",
          "new_text": null,
          "old_line_content": "  DominanceOrder domOrder(&Caller->front(), DT, Caller->size());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 768,
          "old_api": "size",
          "new_api": null,
          "old_text": "ller->size();\n",
          "new_text": null,
          "old_line_content": "  int NumCallerBlocks = (int)Caller->size();",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": "getNext",
          "new_api": null,
          "old_text": "mOrder.getNext()) ",
          "new_text": null,
          "old_line_content": "  while (SILBasicBlock *block = domOrder.getNext()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": "beginBlock",
          "new_api": null,
          "old_text": "nstTracker.beginBlock();\n",
          "new_text": null,
          "old_line_content": "    constTracker.beginBlock();",
          "new_line_content": "  // Go through all instructions and find candidates for inlining.",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": "getFunction",
          "new_api": null,
          "old_text": "AI.getFunction()->isThunk()",
          "new_text": null,
          "old_line_content": "    if (AI.getFunction()->isThunk())",
          "new_line_content": "  // more principled ways of getting this effect.",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": "llApplySite::isa(&*I))",
          "new_api": null,
          "old_text": "llApplySite::isa(&*I))\n",
          "new_text": null,
          "old_line_content": "      if (!FullApplySite::isa(&*I))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": "getLoweredFunctionType",
          "new_api": null,
          "old_text": "Callee->getLoweredFunctionType()->getSelfInstanceType()",
          "new_text": null,
          "old_line_content": "      auto SelfTy = Callee->getLoweredFunctionType()->getSelfInstanceType();",
          "new_line_content": "      return false;",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": "mayHaveSuperclass",
          "new_api": null,
          "old_text": "SelfTy->mayHaveSuperclass()",
          "new_text": null,
          "old_line_content": "      if (SelfTy->mayHaveSuperclass() &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": "getRepresentation",
          "new_api": null,
          "old_text": "Callee->getRepresentation()",
          "new_text": null,
          "old_line_content": "          Callee->getRepresentation() == SILFunctionTypeRepresentation::Method)",
          "new_line_content": "    // Don't inline class methods.",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": "llApplySite",
          "new_api": null,
          "old_text": "llApplySite(&*I);\n",
          "new_text": null,
          "old_line_content": "      FullApplySite AI = FullApplySite(&*I);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": "tEligibleFunction",
          "new_api": null,
          "old_text": "tEligibleFunction(AI, WhatToInline);\n",
          "new_text": null,
          "old_line_content": "      auto *Callee = getEligibleFunction(AI, WhatToInline);",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": "ight",
          "new_api": null,
          "old_text": "ight(0, 0));",
          "new_text": null,
          "old_line_content": "          BlockWeight = SPA->getWeight(block, Weight(0, 0));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": "isPureCall",
          "new_api": null,
          "old_text": "isPureCall(AI, SEA)",
          "new_text": null,
          "old_line_content": "  if (isPureCall(AI, SEA)) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": "getFunction",
          "new_api": null,
          "old_text": "AI.getFunction()",
          "new_text": null,
          "old_line_content": "    LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": "getName",
          "new_api": null,
          "old_text": "Callee->getName()",
          "new_text": null,
          "old_line_content": "               llvm::dbgs() << \"    pure-call decision \" << Callee->getName()",
          "new_line_content": "  // It is always OK to inline a simple call.",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": "cideInWarmBlock",
          "new_api": null,
          "old_text": "cideInWarmBlock(AI, W, constTracker, NumCallerBlocks,\n                              BBToWeightMap))\n",
          "new_text": null,
          "old_line_content": "        if (decideInWarmBlock(AI, W, constTracker, NumCallerBlocks,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": "pushChildrenIf",
          "new_api": null,
          "old_text": "mOrder.pushChildrenIf(block, [&] (SILBasicBlock *child) {\n      if (CBI.isSlowPath(block, child)) {\n        // Handle cold blocks separately.\n        visitColdBlocks(InitialCandidates, child, DT);\n        return false;\n      }\n      return true;\n    });\n",
          "new_text": null,
          "old_line_content": "    domOrder.pushChildrenIf(block, [&] (SILBasicBlock *child) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": "isSlowPath",
          "new_api": null,
          "old_text": "I.isSlowPath(block, child)) ",
          "new_text": null,
          "old_line_content": "      if (CBI.isSlowPath(block, child)) {",
          "new_line_content": "    if (NumCallerBlocks > OverallCallerBlockLimit)",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": "getSubstitutionMap",
          "new_api": null,
          "old_text": "AI.getSubstitutionMap()",
          "new_text": null,
          "old_line_content": "  if (IsGeneric && canSpecializeGeneric(AI, Callee, AI.getSubstitutionMap())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": "sitColdBlocks",
          "new_api": null,
          "old_text": "sitColdBlocks(InitialCandidates, child, DT);\n",
          "new_text": null,
          "old_line_content": "        visitColdBlocks(InitialCandidates, child, DT);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": "getSPA",
          "new_api": null,
          "old_text": "getSPA(Callee, LI)",
          "new_text": null,
          "old_line_content": "  ShortestPathAnalysis *SPA = getSPA(Callee, LI);",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": "isValid",
          "new_api": null,
          "old_text": "SPA->isValid()",
          "new_text": null,
          "old_line_content": "  assert(SPA->isValid());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": "size",
          "new_api": null,
          "old_text": "Callee->size()",
          "new_text": null,
          "old_line_content": "  DominanceOrder domOrder(CalleeEntry, DT, Callee->size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": "getReferencedFunction",
          "new_api": null,
          "old_text": ".getReferencedFunction();\n",
          "new_text": null,
          "old_line_content": "    SILFunction *Callee = AI.getReferencedFunction();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 818,
          "old_api": "sert",
          "new_api": null,
          "old_text": "sert(Callee && \"apply_inst does not have a direct callee anymore\");\n",
          "new_text": null,
          "old_line_content": "    assert(Callee && \"apply_inst does not have a direct callee anymore\");",
          "new_line_content": "  // Calculate how many times a callee is called from this caller.",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": "getReferencedFunction",
          "new_api": null,
          "old_text": ".getReferencedFunction();\n",
          "new_text": null,
          "old_line_content": "    SILFunction *Callee = AI.getReferencedFunction();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": "sert",
          "new_api": null,
          "old_text": "sert(Callee && \"apply_inst does not have a direct callee anymore\");\n",
          "new_text": null,
          "old_line_content": "    assert(Callee && \"apply_inst does not have a direct callee anymore\");",
          "new_line_content": "  // Now copy each candidate callee that has a small enough number of",
          "content_same": false
        },
        {
          "line": 320,
          "old_api": "getSubstitutionMap",
          "new_api": null,
          "old_text": ".getSubstitutionMap();\n",
          "new_text": null,
          "old_line_content": "  SubstitutionMap CalleeSubstMap = AI.getSubstitutionMap();",
          "new_line_content": "  // the exclusivity heuristic or not. We can *only* do that",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": "updateBenefit",
          "new_api": null,
          "old_text": "llerWeight.updateBenefit(Benefit, BaseBenefit);\n",
          "new_text": null,
          "old_line_content": "  CallerWeight.updateBenefit(Benefit, BaseBenefit);",
          "new_line_content": "  int ExclusivityBenefitWeight = 0;",
          "content_same": false
        },
        {
          "line": 327,
          "old_api": "beginBlock",
          "new_api": null,
          "old_text": "nstTracker.beginBlock();\n",
          "new_text": null,
          "old_line_content": "    constTracker.beginBlock();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 328,
          "old_api": "getWeight",
          "new_api": null,
          "old_text": "A->getWeight(block, CallerWeight);\n",
          "new_text": null,
          "old_line_content": "    Weight BlockW = SPA->getWeight(block, CallerWeight);",
          "new_line_content": "  // Go through all blocks of the function, accumulate the cost and find",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": "shouldOptimize",
          "new_api": null,
          "old_text": "ller->shouldOptimize())\n",
          "new_text": null,
          "old_line_content": "  if (!Caller->shouldOptimize())",
          "new_line_content": "/// \\brief Attempt to inline all calls smaller than our threshold.",
          "content_same": false
        },
        {
          "line": 333,
          "old_api": "structionInlineCost",
          "new_api": null,
          "old_text": "structionInlineCost(I);\n",
          "new_text": null,
          "old_line_content": "      CalleeCost += (int)instructionInlineCost(I);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 846,
          "old_api": "llectAppliesToInline",
          "new_api": null,
          "old_text": "llectAppliesToInline(Caller, AppliesToInline);\n",
          "new_text": null,
          "old_line_content": "  collectAppliesToInline(Caller, AppliesToInline);",
          "new_line_content": "  // First step: collect all the functions we want to inline.  We",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": "empty",
          "new_api": null,
          "old_text": "pliesToInline.empty())\n",
          "new_text": null,
          "old_line_content": "  if (AppliesToInline.empty())",
          "new_line_content": "  // remains valid.",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "I.getCallee());",
          "new_text": null,
          "old_line_content": "        SILInstruction *def = constTracker.getDefInCaller(FAI.getCallee());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 340,
          "old_api": "updateBenefit",
          "new_api": null,
          "old_text": "ockW.updateBenefit(Benefit, RemovedClosureBenefit);\n",
          "new_text": null,
          "old_line_content": "          BlockW.updateBenefit(Benefit, RemovedClosureBenefit);",
          "new_line_content": "        // Check if the callee is passed as an argument. If so, increase the",
          "content_same": false
        },
        {
          "line": 853,
          "old_api": "getReferencedFunction",
          "new_api": null,
          "old_text": ".getReferencedFunction();\n",
          "new_text": null,
          "old_line_content": "    SILFunction *Callee = AI.getReferencedFunction();",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 854,
          "old_api": "sert",
          "new_api": null,
          "old_text": "sert(Callee && \"apply_inst does not have a direct callee anymore\");\n",
          "new_text": null,
          "old_line_content": "    assert(Callee && \"apply_inst does not have a direct callee anymore\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": "shouldOptimize",
          "new_api": null,
          "old_text": "llee->shouldOptimize()) ",
          "new_text": null,
          "old_line_content": "    if (!Callee->shouldOptimize()) {",
          "new_line_content": "  for (auto AI : AppliesToInline) {",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": "getSubstitutionMap",
          "new_api": null,
          "old_text": "I.getSubstitutionMap();\n",
          "new_text": null,
          "old_line_content": "        auto Subs = FAI.getSubstitutionMap();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": "getArguments",
          "new_api": null,
          "old_text": ".getArguments())\n",
          "new_text": null,
          "old_line_content": "    for (const auto &Arg : AI.getArguments())",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "gs.push_back(Arg);\n",
          "new_text": null,
          "old_line_content": "      Args.push_back(Arg);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 352,
          "old_api": "empty",
          "new_api": null,
          "old_text": "bs.empty())\n",
          "new_text": null,
          "old_line_content": "        if (!EnableSILInliningOfGenerics || Subs.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 355,
          "old_api": "a<ClassMethodInst>(def) &",
          "new_api": null,
          "old_text": "a<ClassMethodInst>(def) &",
          "new_text": null,
          "old_line_content": "        if (!isa<FunctionRefInst>(def) && !isa<ClassMethodInst>(def) &&",
          "new_line_content": "        // Bail if it is not a generic call or inlining of generics is forbidden.",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": "getName",
          "new_api": null,
          "old_text": "llee->getName() <",
          "new_text": null,
          "old_line_content": "                            << \"] \" << Callee->getName() << \"\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": "subst",
          "new_api": null,
          "old_text": "bs.subst(CalleeSubstMap);\n",
          "new_text": null,
          "old_line_content": "        auto SubMap = Subs.subst(CalleeSubstMap);",
          "new_line_content": "        // devirtualization of this call.",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": "getSubstitutionMap",
          "new_api": null,
          "old_text": ".getSubstitutionMap(), ",
          "new_text": null,
          "old_line_content": "                       AI.getSubstitutionMap(), OpenedArchetypesTracker);",
          "new_line_content": "    // the substitution list.",
          "content_same": false
        },
        {
          "line": 368,
          "old_api": "a<WitnessMethodInst>(def) |",
          "new_api": null,
          "old_text": "a<WitnessMethodInst>(def) |",
          "new_text": null,
          "old_line_content": "        if (isa<ClassMethodInst>(def) || isa<WitnessMethodInst>(def) ||",
          "new_line_content": "        // inlining.",
          "content_same": false
        },
        {
          "line": 371,
          "old_api": "nDevirtualizeApply",
          "new_api": null,
          "old_text": "nDevirtualizeApply(FAI, nullptr)) ",
          "new_text": null,
          "old_line_content": "          if (canDevirtualizeApply(FAI, nullptr)) {",
          "new_line_content": "        // Check if the call can be devirtualized.",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": "inlineFunction",
          "new_api": null,
          "old_text": "liner.inlineFunction(Callee, AI, Args);\n",
          "new_text": null,
          "old_line_content": "    Inliner.inlineFunction(Callee, AI, Args);",
          "new_line_content": "    // unconditionally inline the function.",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": "getInstruction",
          "new_api": null,
          "old_text": "I.getInstruction()->dumpInContext());",
          "new_text": null,
          "old_line_content": "                       FAI.getInstruction()->dumpInContext());",
          "new_line_content": "          // TODO: Take AI.getSubstitutions() into account.",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": "a<FunctionRefInst>(def))",
          "new_api": null,
          "old_text": "a<FunctionRefInst>(def)) ",
          "new_text": null,
          "old_line_content": "        if (isa<FunctionRefInst>(def)) {",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": "getCalleeFunction",
          "new_api": null,
          "old_text": "I.getCalleeFunction();\n",
          "new_text": null,
          "old_line_content": "          auto CalleeF = FAI.getCalleeFunction();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": "nSpecializeGeneric",
          "new_api": null,
          "old_text": "nSpecializeGeneric(FAI, CalleeF, SubMap))\n",
          "new_text": null,
          "old_line_content": "          if (!canSpecializeGeneric(FAI, CalleeF, SubMap))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": "getNext",
          "new_api": null,
          "old_text": "mOrder.getNext()) ",
          "new_text": null,
          "old_line_content": "  while (SILBasicBlock *block = domOrder.getNext()) {",
          "new_line_content": "void SILPerformanceInliner::visitColdBlocks(",
          "content_same": false
        },
        {
          "line": 898,
          "old_api": "n_cast<ApplyInst>(&I);",
          "new_api": null,
          "old_text": "n_cast<ApplyInst>(&I);\n",
          "new_text": null,
          "old_line_content": "      auto *AI = dyn_cast<ApplyInst>(&I);",
          "new_line_content": "    DominanceInfo *DT) {",
          "content_same": false
        },
        {
          "line": 387,
          "old_api": "updateBenefit",
          "new_api": null,
          "old_text": "ockW.updateBenefit(Benefit, GenericSpecializationBenefit);\n",
          "new_text": null,
          "old_line_content": "          BlockW.updateBenefit(Benefit, GenericSpecializationBenefit);",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 389,
          "old_api": "n_cast<LoadInst>(&I))",
          "new_api": null,
          "old_text": "n_cast<LoadInst>(&I)) ",
          "new_text": null,
          "old_line_content": "      } else if (auto *LI = dyn_cast<LoadInst>(&I)) {",
          "new_line_content": "                                     \"after inlining for the call:\\n\";",
          "content_same": false
        },
        {
          "line": 903,
          "old_api": "cideInColdBlock",
          "new_api": null,
          "old_text": "cideInColdBlock(AI, Callee)) ",
          "new_text": null,
          "old_line_content": "      if (Callee && decideInColdBlock(AI, Callee)) {",
          "new_line_content": "      if (!AI)",
          "content_same": false
        },
        {
          "line": 392,
          "old_api": "getOperand",
          "new_api": null,
          "old_text": "->getOperand()))",
          "new_text": null,
          "old_line_content": "        if (constTracker.isStackAddrInCaller(LI->getOperand()))",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "pliesToInline.push_back(AI);\n",
          "new_text": null,
          "old_line_content": "        AppliesToInline.push_back(AI);",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": "n_cast<StoreInst>(&I))",
          "new_api": null,
          "old_text": "n_cast<StoreInst>(&I)) ",
          "new_text": null,
          "old_line_content": "      } else if (auto *SI = dyn_cast<StoreInst>(&I)) {",
          "new_line_content": "        // Check if it's a load from a stack location in the caller. Such a load",
          "content_same": false
        },
        {
          "line": 399,
          "old_api": "a<ReleaseValueInst>(&I))",
          "new_api": null,
          "old_text": "a<ReleaseValueInst>(&I)) ",
          "new_text": null,
          "old_line_content": "      } else if (isa<StrongReleaseInst>(&I) || isa<ReleaseValueInst>(&I)) {",
          "new_line_content": "        // Check if it's a store to a stack location in the caller. Such a load",
          "content_same": false
        },
        {
          "line": 400,
          "old_api": "getOperand",
          "new_api": null,
          "old_text": "getOperand(0));",
          "new_text": null,
          "old_line_content": "        SILValue Op = stripCasts(I.getOperand(0));",
          "new_line_content": "        // might be optimized away if inlined.",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": "n_cast<BuiltinInst>(&I))",
          "new_api": null,
          "old_text": "n_cast<BuiltinInst>(&I)) ",
          "new_text": null,
          "old_line_content": "      } else if (auto *BI = dyn_cast<BuiltinInst>(&I)) {",
          "new_line_content": "              SILArgumentConvention::Direct_Guaranteed) {",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": "updateBenefit",
          "new_api": null,
          "old_text": "ockW.updateBenefit(Benefit, FastPathBuiltinBenefit);\n",
          "new_text": null,
          "old_line_content": "          BlockW.updateBenefit(Benefit, FastPathBuiltinBenefit);",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": "n_cast<BeginAccessInst>(&I))",
          "new_api": null,
          "old_text": "n_cast<BeginAccessInst>(&I)) ",
          "new_text": null,
          "old_line_content": "      } else if (auto *BAI = dyn_cast<BeginAccessInst>(&I)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": "append",
          "new_api": null,
          "old_text": "ssName.append(\" Performance Inliner\");\n",
          "new_text": null,
          "old_line_content": "    PassName.append(\" Performance Inliner\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": "getSource",
          "new_api": null,
          "old_text": "I->getSource());",
          "new_text": null,
          "old_line_content": "              findAccessedStorageNonNested(BAI->getSource());",
          "new_line_content": "          // The access is dynamic and has no nested conflict",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": "hasNoNestedConflict",
          "new_api": null,
          "old_text": "I->hasNoNestedConflict() &",
          "new_text": null,
          "old_line_content": "          if (BAI->hasNoNestedConflict() &&",
          "new_line_content": "          // See if the storage location is considered by",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": "isUniquelyIdentified",
          "new_api": null,
          "old_text": "orage.isUniquelyIdentified() |",
          "new_text": null,
          "old_line_content": "              (storage.isUniquelyIdentified() ||",
          "new_line_content": "          // access enforcement optimizations",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": "getKind",
          "new_api": null,
          "old_text": "orage.getKind() =",
          "new_text": null,
          "old_line_content": "               storage.getKind() == AccessedStorage::Class)) {",
          "new_line_content": "          AccessedStorage storage =",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": "->getAnalysis<SILLoopAnalysis>();",
          "new_api": null,
          "old_text": "->getAnalysis<SILLoopAnalysis>();\n",
          "new_text": null,
          "old_line_content": "    SILLoopAnalysis *LA = PM->getAnalysis<SILLoopAnalysis>();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": "->getAnalysis<SideEffectAnalysis>();",
          "new_api": null,
          "old_text": "->getAnalysis<SideEffectAnalysis>();\n",
          "new_text": null,
          "old_line_content": "    SideEffectAnalysis *SEA = PM->getAnalysis<SideEffectAnalysis>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": "getTerminator",
          "new_api": null,
          "old_text": "ock->getTerminator());",
          "new_text": null,
          "old_line_content": "    SILBasicBlock *takenBlock = constTracker.getTakenBlock(block->getTerminator());",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": "updateBenefit",
          "new_api": null,
          "old_text": "ockW.updateBenefit(Benefit, RemovedTerminatorBenefit);\n",
          "new_text": null,
          "old_line_content": "      BlockW.updateBenefit(Benefit, RemovedTerminatorBenefit);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 431,
          "old_api": "pushChildrenIf",
          "new_api": null,
          "old_text": "mOrder.pushChildrenIf(block, [=](SILBasicBlock *child) {\n        return child->getSinglePredecessorBlock() != block ||\n               child == takenBlock;\n      });\n",
          "new_text": null,
          "old_line_content": "      domOrder.pushChildrenIf(block, [=](SILBasicBlock *child) {",
          "new_line_content": "    // Don't count costs in blocks which are dead after inlining.",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": "isDefinition",
          "new_api": null,
          "old_text": "tFunction()->isDefinition() &",
          "new_text": null,
          "old_line_content": "    assert(getFunction()->isDefinition() &&",
          "new_line_content": "    SILOptFunctionBuilder FuncBuilder(*this);",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": "tFunction",
          "new_api": null,
          "old_text": "tFunction()))",
          "new_text": null,
          "old_line_content": "    if (Inliner.inlineCallsIntoFunction(getFunction())) {",
          "new_line_content": "    // Inline things into this function, and if we do so invalidate",
          "content_same": false
        },
        {
          "line": 441,
          "old_api": "d::max(Benefit, ExclusivityBenefitWeight);",
          "new_api": null,
          "old_text": "d::max(Benefit, ExclusivityBenefitWeight);\n",
          "new_text": null,
          "old_line_content": "    Benefit = std::max(Benefit, ExclusivityBenefitWeight);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "validateAnalysis",
          "new_api": null,
          "old_text": "validateAnalysis(SILAnalysis::InvalidationKind::FunctionBody);\n",
          "new_text": null,
          "old_line_content": "      invalidateAnalysis(SILAnalysis::InvalidationKind::FunctionBody);",
          "new_line_content": "    // analyses for this function and restart the pipeline so that we",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": "startPassPipeline",
          "new_api": null,
          "old_text": "startPassPipeline();\n",
          "new_text": null,
          "old_line_content": "      restartPassPipeline();",
          "new_line_content": "    // can further optimize this function before attempting to inline",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": "getFunction",
          "new_api": null,
          "old_text": ".getFunction()->isThunk()) ",
          "new_text": null,
          "old_line_content": "  if (AI.getFunction()->isThunk()) {",
          "new_line_content": "  if (AllAccessesBeneficialToInline) {",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": "getFunction",
          "new_api": null,
          "old_text": ".getFunction());",
          "new_text": null,
          "old_line_content": "    LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "new_line_content": "    if (CalleeCost > TrivialFunctionThreshold) {",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": "vm::dbgs() <",
          "new_api": null,
          "old_text": "vm::dbgs() <",
          "new_text": null,
          "old_line_content": "               llvm::dbgs() << \"    decision {\" << CalleeCost << \" into thunk} \"",
          "new_line_content": "      return false;",
          "content_same": false
        },
        {
          "line": 453,
          "old_api": "getName",
          "new_api": null,
          "old_text": "llee->getName() <",
          "new_text": null,
          "old_line_content": "                            << Callee->getName() << '\\n');",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": "getInstruction",
          "new_api": null,
          "old_text": ".getInstruction()->getParent();\n",
          "new_text": null,
          "old_line_content": "  auto *bb = AI.getInstruction()->getParent();",
          "new_line_content": "    // The calculation in the if branch would overflow if we performed it.",
          "content_same": false
        },
        {
          "line": 470,
          "old_api": "find",
          "new_api": null,
          "old_text": "ToWeightMap.find(bb);\n",
          "new_text": null,
          "old_line_content": "  auto bbIt = BBToWeightMap.find(bb);",
          "new_line_content": "    Benefit = 0;",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": "end",
          "new_api": null,
          "old_text": "ToWeightMap.end()) ",
          "new_text": null,
          "old_line_content": "  if (bbIt != BBToWeightMap.end()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": "ofileBasedDecision",
          "new_api": null,
          "old_text": "ofileBasedDecision(AI, Benefit, Callee, CalleeCost,\n                                NumCallerBlocks, bbIt);\n",
          "new_text": null,
          "old_line_content": "    return profileBasedDecision(AI, Benefit, Callee, CalleeCost,",
          "new_line_content": "  // If we have profile info - use it for final inlining decision.",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": "emit",
          "new_api": null,
          "old_text": "E.emit([&]() {\n      using namespace OptRemark;\n      return RemarkMissed(\"NoInlinedCost\", *AI.getInstruction())\n             << \"Not profitable to inline function \" << NV(\"Callee\", Callee)\n             << \" (cost = \" << NV(\"Cost\", CalleeCost)\n             << \", benefit = \" << NV(\"Benefit\", Benefit) << \")\";\n    });\n",
          "new_text": null,
          "old_line_content": "    ORE.emit([&]() {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": "getInstruction",
          "new_api": null,
          "old_text": ".getInstruction())\n",
          "new_text": null,
          "old_line_content": "      return RemarkMissed(\"NoInlinedCost\", *AI.getInstruction())",
          "new_line_content": "  // This is the final inlining decision.",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": "(\"Callee\", Callee)",
          "new_api": null,
          "old_text": "(\"Callee\", Callee)\n ",
          "new_text": null,
          "old_line_content": "             << \"Not profitable to inline function \" << NV(\"Callee\", Callee)",
          "new_line_content": "  if (CalleeCost > Benefit) {",
          "content_same": false
        },
        {
          "line": 486,
          "old_api": "(\"Benefit\", Benefit) <",
          "new_api": null,
          "old_text": "(\"Benefit\", Benefit) <",
          "new_text": null,
          "old_line_content": "             << \", benefit = \" << NV(\"Benefit\", Benefit) << \")\";",
          "new_line_content": "      using namespace OptRemark;",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": "size",
          "new_api": null,
          "old_text": "llee->size();\n",
          "new_text": null,
          "old_line_content": "  NumCallerBlocks += Callee->size();",
          "new_line_content": "    });",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": "getFunction",
          "new_api": null,
          "old_text": ".getFunction());",
          "new_text": null,
          "old_line_content": "  LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": "vm::dbgs() <",
          "new_api": null,
          "old_text": "vm::dbgs() <",
          "new_text": null,
          "old_line_content": "             llvm::dbgs() << \"    decision {c=\" << CalleeCost",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 496,
          "old_api": "getScopeLength",
          "new_api": null,
          "old_text": "A->getScopeLength(CalleeEntry, 0)\n ",
          "new_text": null,
          "old_line_content": "                          << \", l=\" << SPA->getScopeLength(CalleeEntry, 0)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": "emit",
          "new_api": null,
          "old_text": "E.emit([&]() {\n    using namespace OptRemark;\n    return RemarkPassed(\"Inlined\", *AI.getInstruction())\n           << NV(\"Callee\", Callee) << \" inlined into \"\n           << NV(\"Caller\", AI.getFunction())\n           << \" (cost = \" << NV(\"Cost\", CalleeCost)\n           << \", benefit = \" << NV(\"Benefit\", Benefit) << \")\";\n  });\n",
          "new_text": null,
          "old_line_content": "  ORE.emit([&]() {",
          "new_line_content": "                          << \", c-w=\" << CallerWeight",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": "getInstruction",
          "new_api": null,
          "old_text": ".getInstruction())\n",
          "new_text": null,
          "old_line_content": "    return RemarkPassed(\"Inlined\", *AI.getInstruction())",
          "new_line_content": "                          << \", c-bb=\" << NumCallerBlocks",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": "(\"Cost\", CalleeCost)",
          "new_api": null,
          "old_text": "(\"Cost\", CalleeCost)\n ",
          "new_text": null,
          "old_line_content": "           << \" (cost = \" << NV(\"Cost\", CalleeCost)",
          "new_line_content": "    using namespace OptRemark;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 65,
      "total_additions": 163,
      "total_deletions": 162,
      "total_api_changes": 390
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 5,
        "api_related_lines": 390,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          264,
          265,
          266
        ]
      }
    },
    "api_calls_before": 333,
    "api_calls_after": 334,
    "diff_info": {
      "added_lines": 5,
      "removed_lines": 1,
      "total_diff_lines": 19
    }
  }
}