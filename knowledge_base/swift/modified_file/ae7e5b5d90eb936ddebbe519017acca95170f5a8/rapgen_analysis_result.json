{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/ae7e5b5d90eb936ddebbe519017acca95170f5a8",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/ae7e5b5d90eb936ddebbe519017acca95170f5a8/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/ae7e5b5d90eb936ddebbe519017acca95170f5a8/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/ae7e5b5d90eb936ddebbe519017acca95170f5a8/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 941,
          "old_api": "(AA, BCA, sideEffects, AI)) {",
          "new_api": "size",
          "old_text": "(AA, BCA, sideEffects, AI)) {\n      ",
          "new_text": "s.size() < 8000) {",
          "old_line_content": "    if (!mayWriteTo(AA, BCA, sideEffects, AI)) {",
          "new_line_content": "  if (ReadOnlyApplies.size() * sideEffects.size() < 8000) {",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": "empty",
          "new_api": "(AA, sideEffects, LI)) {",
          "old_text": "Calls.empty()) {\n    if",
          "new_text": "(AA, sideEffects, LI)) {\n      ",
          "old_line_content": "  if (!globalInitCalls.empty()) {",
          "new_line_content": "      if (!mayWriteTo(AA, sideEffects, LI)) {",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": "tWithGlobalInit",
          "new_api": ">getParent());\n    }",
          "old_text": "tWithGlobalInit(AA, sideEffects, ginitCall, Preheader,\n             postDomTree)) {\n      ",
          "new_text": ">getParent());\n    }\n ",
          "old_line_content": "        if (!mayConflictWithGlobalInit(AA, sideEffects, ginitCall, Preheader,",
          "new_line_content": "      postDomTree = PDA->get(Preheader->getParent());",
          "content_same": false
        },
        {
          "line": 961,
          "old_api": "sert",
          "new_api": "getRootNode",
          "old_text": "sert(ginitCall);\n        ",
          "new_text": "e->getRootNode()) {\n      ",
          "old_line_content": "          HoistUp.insert(ginitCall);",
          "new_line_content": "    if (postDomTree->getRootNode()) {",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": "count",
          "new_api": "t",
          "old_text": "reAddrs.count(accessPath)) {\n      ",
          "new_text": "t());\n    aut",
          "old_line_content": "        if (!LoadAndStoreAddrs.count(accessPath)) {",
          "new_line_content": "    auto access = AccessPathWithBase::compute(SI->getDest());",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": "insert",
          "new_api": "isValid",
          "old_text": "reAddrs.insert(accessPath);\n        ",
          "new_text": ".isValid() &&\n      ",
          "old_line_content": "            LoadAndStoreAddrs.insert(accessPath);",
          "new_line_content": "    if (accessPath.isValid() &&",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": "empty",
          "new_api": "insert",
          "old_text": "es.empty()) {\n    bo",
          "new_text": "reAddrs.insert(accessPath);\n        ",
          "old_line_content": "  if (!FixLifetimes.empty()) {",
          "new_line_content": "            LoadAndStoreAddrs.insert(accessPath);",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": "ush_back",
          "new_api": "empty",
          "old_text": "ush_back(FL);\n      }\n",
          "new_text": "es.empty()) {\n    bo",
          "old_line_content": "        SinkDown.push_back(FL);",
          "new_line_content": "  if (!FixLifetimes.empty()) {",
          "content_same": false
        },
        {
          "line": 1000,
          "old_api": "Accesses",
          "new_api": "(AA, sideEffects, FL)) {",
          "old_text": "Accesses(BI, Loop)) {\n      ",
          "new_text": "(AA, sideEffects, FL)) {\n      ",
          "old_line_content": "    if (!handledEndAccesses(BI, Loop)) {",
          "new_line_content": "      if (!sideEffectsMayRelease || !mayWriteTo(AA, sideEffects, FL)) {",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": "() << \"Skipp",
          "new_api": "ush_back",
          "old_text": "() << \"Skipp",
          "new_text": "ush_back(FL);\n      }\n",
          "old_line_content": "      LLVM_DEBUG(llvm::dbgs() << \"Skipping: \" << *BI);",
          "new_line_content": "        SinkDown.push_back(FL);",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": "push_back",
          "new_api": "() << \"Skipp",
          "old_text": "st.push_back(BI);\n    }\n  ",
          "new_text": "() << \"Skipp",
          "old_line_content": "      SpecialHoist.push_back(BI);",
          "new_line_content": "      LLVM_DEBUG(llvm::dbgs() << \"Skipping: \" << *BI);",
          "content_same": false
        },
        {
          "line": 1029,
          "old_api": "getIndex",
          "new_api": "lementAddrInst>(innerAddress)) {\n    re",
          "old_text": "getIndex());\n  SILVa",
          "new_text": "lementAddrInst>(innerAddress)) {\n    re",
          "old_line_content": "  reversePathIndices.push_back(innerPath.getIndex());",
          "new_line_content": "      && !isa<TupleElementAddrInst>(innerAddress)) {",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": "_back",
          "new_api": "getLoc",
          "old_text": "_back(load);\n    // R",
          "new_text": "ores[ldstIdx]->getLoc();\n  // Rec",
          "old_line_content": "    Loads.push_back(load);",
          "new_line_content": "  auto loc = LoadsAndStores[ldstIdx]->getLoc();",
          "content_same": false
        },
        {
          "line": 1059,
          "old_api": "() << \"Creat",
          "new_api": "eateLoad",
          "old_text": "() << \"Creat",
          "new_text": "eateLoad(loc, splitAddress,\n                                        LoadOwnershipQualifier::Unqualified);\n    Load",
          "old_line_content": "    LLVM_DEBUG(llvm::dbgs() << \"Created load from stored path: \" << *load);",
          "new_line_content": "    LoadInst *load = builder.createLoad(loc, splitAddress,",
          "content_same": false
        },
        {
          "line": 1070,
          "old_api": "etNumElements",
          "new_api": "begin",
          "old_text": "etNumElements())) {\n     ",
          "new_text": "ores.begin() + ldstIdx",
          "old_line_content": "    for (int tupleIdx : range(tupleTy->getNumElements())) {",
          "new_line_content": "    LoadsAndStores.insert(LoadsAndStores.begin() + ldstIdx + 1, newLoad);",
          "content_same": false
        },
        {
          "line": 1072,
          "old_api": "TupleElementType",
          "new_api": "back",
          "old_text": "TupleElementType(tupleIdx));\n      S",
          "new_text": "ath.back().getSubObjectIndex();\n  SILTyp",
          "old_line_content": "          loc, splitAddress, tupleIdx, loadTy.getTupleElementType(tupleIdx));",
          "new_line_content": "  auto subIndex = remainingPath.back().getSubObjectIndex();",
          "content_same": false
        },
        {
          "line": 1078,
          "old_api": "eateLoad",
          "new_api": "TupleElementType",
          "old_text": "eateLoad(loc, projection,\n                                        LoadOwnershipQualifier::Unqualified);\n        ",
          "new_text": "TupleElementType(tupleIdx));\n      S",
          "old_line_content": "        elementVal = builder.createLoad(loc, projection,",
          "new_line_content": "          loc, splitAddress, tupleIdx, loadTy.getTupleElementType(tupleIdx));",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": "eateTuple",
          "new_api": "eateLoad",
          "old_text": "eateTuple(loc, elements);\n  }\n  au",
          "new_text": "eateLoad(loc, projection,\n                                        LoadOwnershipQualifier::Unqualified);\n        ",
          "old_line_content": "    return builder.createTuple(loc, elements);",
          "new_line_content": "        elementVal = builder.createLoad(loc, projection,",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": "StructOrBoundGenericStruct",
          "new_api": "nst>(elementVal));\n      }",
          "old_text": "StructOrBoundGenericStruct();\n  assert",
          "new_text": "nst>(elementVal));\n      }",
          "old_line_content": "  auto structTy = loadTy.getStructOrBoundGenericStruct();",
          "new_line_content": "        recordDisjointLoad(cast<LoadInst>(elementVal));",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": "tModule",
          "new_api": "ush_back",
          "old_text": "tModule();\n  auto e",
          "new_text": "ush_back(elementVal);\n    }\n  ",
          "old_line_content": "  auto &module = builder.getModule();",
          "new_line_content": "      elements.push_back(elementVal);",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": "getStoredProperties",
          "new_api": "uctTy && \"tuple and struct elements are checked earlier\");\n  auto &",
          "old_text": "getStoredProperties()) {\n    SI",
          "new_text": "uctTy && \"tuple and struct elements are checked earlier\");\n  auto &",
          "old_line_content": "  for (auto *field : structTy->getStoredProperties()) {",
          "new_line_content": "  assert(structTy && \"tuple and struct elements are checked earlier\");",
          "content_same": false
        },
        {
          "line": 1094,
          "old_api": "FieldType",
          "new_api": "tModule",
          "old_text": "FieldType(field, module, expansionContext);\n    auto",
          "new_text": "tModule();\n  auto e",
          "old_line_content": "    SILType fieldTy = loadTy.getFieldType(field, module, expansionContext);",
          "new_line_content": "  auto &module = builder.getModule();",
          "content_same": false
        },
        {
          "line": 1099,
          "old_api": "drop_back",
          "new_api": "getStoredProperties",
          "old_text": "ath.drop_back(), builder,",
          "new_text": "getStoredProperties()) {\n    SI",
          "old_line_content": "      fieldVal = splitLoad(projection, remainingPath.drop_back(), builder,",
          "new_line_content": "  for (auto *field : structTy->getStoredProperties()) {",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": "eateLoad",
          "new_api": "eateStructElementAddr",
          "old_text": "eateLoad(loc, projection,\n                                    LoadOwnershipQualifier::Unqualified);\n      re",
          "new_text": "eateStructElementAddr(loc, splitAddress, field, fieldTy);\n    SILV",
          "old_line_content": "      fieldVal = builder.createLoad(loc, projection,",
          "new_line_content": "        builder.createStructElementAddr(loc, splitAddress, field, fieldTy);",
          "content_same": false
        },
        {
          "line": 1108,
          "old_api": "ObjectType",
          "new_api": "eateLoad",
          "old_text": "ObjectType(), elements",
          "new_text": "eateLoad(loc, projection,\n                                    LoadOwnershipQualifier::Unqualified);\n      re",
          "old_line_content": "  return builder.createStruct(loc, loadTy.getObjectType(), elements);",
          "new_line_content": "      fieldVal = builder.createLoad(loc, projection,",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": "dFromMemory",
          "new_api": "(); loadsIdx",
          "old_text": "dFromMemory(load, storeAddr))\n      co",
          "new_text": "(); loadsIdx",
          "old_line_content": "    if (!AA->mayReadFromMemory(load, storeAddr))",
          "new_line_content": "  for (unsigned loadsIdx = 0, endIdx = Loads.size(); loadsIdx != endIdx;",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": "perand",
          "new_api": "ount",
          "old_text": "perand());\n    if ",
          "new_text": "ount(load))\n      co",
          "old_line_content": "    AccessPath loadAccessPath = AccessPath::compute(load->getOperand());",
          "new_line_content": "    if (toDelete.count(load))",
          "content_same": false
        },
        {
          "line": 1138,
          "old_api": "getPathNode",
          "new_api": "contains",
          "old_text": "Path.getPathNode(),\n        ",
          "new_text": ".contains(loadAccessPath))\n      co",
          "old_line_content": "    if (!computeInnerAccessPath(loadAccessPath.getPathNode(),",
          "new_line_content": "    if (accessPath.contains(loadAccessPath))",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": "end",
          "new_api": "() >= endIdx",
          "old_text": "d]() {\n      auto ldstIter = llvm::find(LoadsAndStores, load);\n      assert(ldstIter != LoadsAndStores.end() && \"outerLoad missing\");\n      return std::distance(LoadsAndStores.begin(), ldstIter);\n    }();\n\n    SIL",
          "new_text": "() >= endIdx",
          "old_line_content": "    unsigned ldstIdx = [this, load]() {",
          "new_line_content": "    if (Loads.size() >= endIdx + 6) {",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": "(LoadsAndStores, load);\n      as",
          "new_api": "() << \"...Re",
          "old_text": "(LoadsAndStores, load);\n      as",
          "new_text": "() << \"...Re",
          "old_line_content": "      auto ldstIter = llvm::find(LoadsAndStores, load);",
          "new_line_content": "      LLVM_DEBUG(llvm::dbgs() << \"...Refusing to split more loads\\n\");",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": "perand",
          "new_api": "end",
          "old_text": "perand(), reverseP",
          "new_text": "ores.end() && \"outer",
          "old_line_content": "    SILValue aggregateVal = splitLoad(load->getOperand(), reversePathIndices,",
          "new_line_content": "      assert(ldstIter != LoadsAndStores.end() && \"outerLoad missing\");",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": "rAndInserted.second && \"the same load should only be split once\");\n  }\n  re",
          "new_api": "perand",
          "old_text": "rAndInserted.second && \"the same load should only be split once\");\n  }\n  re",
          "new_text": "perand(), reverseP",
          "old_line_content": "    assert(iterAndInserted.second && \"the same load should only be split once\");",
          "new_line_content": "    SILValue aggregateVal = splitLoad(load->getOperand(), reversePathIndices,",
          "content_same": false
        },
        {
          "line": 1188,
          "old_api": "uctions",
          "new_api": "getLoopPreheader",
          "old_text": "uctions(CurrentLoop, DomTree, HoistUp);\n  currCh",
          "new_text": "p->getLoopPreheader())\n    retu",
          "old_line_content": "  currChanged |= hoistInstructions(CurrentLoop, DomTree, HoistUp);",
          "new_line_content": "  if (!CurrentLoop->getLoopPreheader())",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": "alInstruction",
          "new_api": "adsAndStores",
          "old_text": "alInstruction(CurrSummary, DomTree, LoopInfo, SpecialHoist);\n\n  asser",
          "new_text": "adsAndStores(CurrentLoop))\n    retu",
          "old_line_content": "      hoistSpecialInstruction(CurrSummary, DomTree, LoopInfo, SpecialHoist);",
          "new_line_content": "  if (hoistAllLoadsAndStores(CurrentLoop))",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": "etParent",
          "new_api": "getPathNode",
          "old_text": "etParent(),\n        ",
          "new_text": ".getPathNode();\n  int el",
          "old_line_content": "        AccessPath(accessPath.getStorage(), pathNode.getParent(),",
          "new_line_content": "  auto pathNode = accessPath.getPathNode();",
          "content_same": false
        },
        {
          "line": 1212,
          "old_api": "getOffset",
          "new_api": "getSubObjectIndex",
          "old_text": ".getOffset()),\n       ",
          "new_text": "etIndex().getSubObjectIndex();\n  if (au",
          "old_line_content": "                   accessPath.getOffset()),",
          "new_line_content": "  int elementIdx = pathNode.getIndex().getSubObjectIndex();",
          "content_same": false
        },
        {
          "line": 1215,
          "old_api": "eld",
          "new_api": "getStorage",
          "old_text": "eld(),\n        ",
          "new_text": "dValue(\n        SEI->getOperand(),\n        AccessPath(accessPath.getStorage(), pathNode.getParent(),\n                   accessPath.getOffset()),\n        rootVal, rootAccessPath, beforeInst);\n    SILB",
          "old_line_content": "    return B.createStructExtract(beforeInst->getLoc(), val, SEI->getField(),",
          "new_line_content": "    SILValue val = projectLoadValue(",
          "content_same": false
        },
        {
          "line": 1216,
          "old_api": "getObjectType",
          "new_api": "erand",
          "old_text": "pe().getObjectType());\n  }\n  i",
          "new_text": "erand(),\n        ",
          "old_line_content": "                                 SEI->getType().getObjectType());",
          "new_line_content": "        SEI->getOperand(),",
          "content_same": false
        },
        {
          "line": 1218,
          "old_api": "upleElementAddrInst>(addr)) {\n    as",
          "new_api": "getOffset",
          "old_text": "upleElementAddrInst>(addr)) {\n    as",
          "new_text": ".getOffset()),\n       ",
          "old_line_content": "  if (auto *TEI = dyn_cast<TupleElementAddrInst>(addr)) {",
          "new_line_content": "                   accessPath.getOffset()),",
          "content_same": false
        },
        {
          "line": 1221,
          "old_api": "erand",
          "new_api": "eld",
          "old_text": "erand(),\n        ",
          "new_text": "eld(),\n        ",
          "old_line_content": "        TEI->getOperand(),",
          "new_line_content": "    return B.createStructExtract(beforeInst->getLoc(), val, SEI->getField(),",
          "content_same": false
        },
        {
          "line": 1222,
          "old_api": "etParent",
          "new_api": "getObjectType",
          "old_text": "etParent(),\n        ",
          "new_text": "pe().getObjectType());\n  }\n  i",
          "old_line_content": "        AccessPath(accessPath.getStorage(), pathNode.getParent(),",
          "new_line_content": "                                 SEI->getType().getObjectType());",
          "content_same": false
        },
        {
          "line": 1226,
          "old_api": "eldIndex",
          "new_api": "getStorage",
          "old_text": "eldIndex(),\n        ",
          "new_text": "dValue(\n        TEI->getOperand(),\n        AccessPath(accessPath.getStorage(), pathNode.getParent(),\n                   accessPath.getOffset()),\n        rootVal, rootAccessPath, beforeInst);\n    SILB",
          "old_line_content": "    return B.createTupleExtract(beforeInst->getLoc(), val, TEI->getFieldIndex(),",
          "new_line_content": "    SILValue val = projectLoadValue(",
          "content_same": false
        },
        {
          "line": 1227,
          "old_api": "getObjectType",
          "new_api": "erand",
          "old_text": "pe().getObjectType());\n  }\n  l",
          "new_text": "erand(),\n        ",
          "old_line_content": "                                TEI->getType().getObjectType());",
          "new_line_content": "        TEI->getOperand(),",
          "content_same": false
        },
        {
          "line": 1229,
          "old_api": "chable",
          "new_api": "getOffset",
          "old_text": "chable(\"unknown projection\");\n}\n\n/// R",
          "new_text": ".getOffset()),\n       ",
          "old_line_content": "  llvm_unreachable(\"unknown projection\");",
          "new_line_content": "                   accessPath.getOffset()),",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": "er",
          "new_api": "getParent",
          "old_text": "er();\n    if (",
          "new_text": "eader()->getParent());\n  Small",
          "old_line_content": "    SILInstruction *user = use->getUser();",
          "new_line_content": "  BasicBlockSet stores(loop->getHeader()->getParent());",
          "content_same": false
        },
        {
          "line": 1247,
          "old_api": "eader",
          "new_api": "unction",
          "old_text": "eader();\n  // If ",
          "new_text": "unction());\n  for (",
          "old_line_content": "  SILBasicBlock *header = loop->getHeader();",
          "new_line_content": "  accessPath.collectUses(uses, AccessUseType::Exact, loop->getFunction());",
          "content_same": false
        },
        {
          "line": 1250,
          "old_api": "tains",
          "new_api": "nst>(user))\n      st",
          "old_text": "tains(header))\n    retu",
          "new_text": "nst>(user))\n      st",
          "old_line_content": "  if (stores.contains(header))",
          "new_line_content": "    if (isa<StoreInst>(user))",
          "content_same": false
        },
        {
          "line": 1291,
          "old_api": "insert",
          "new_api": "oopPreheader",
          "old_text": "live.insert(header);\n  bool c",
          "new_text": "oopPreheader()))\n    ret",
          "old_line_content": "  storesNotAlive.insert(header);",
          "new_line_content": "  if (stores.contains(loop->getLoopPreheader()))",
          "content_same": false
        },
        {
          "line": 1296,
          "old_api": "contains",
          "new_api": "getParent",
          "old_text": "live.contains(block);\n      if",
          "new_text": "eader()->getParent());\n  store",
          "old_line_content": "      bool storeAlive = !storesNotAlive.contains(block);",
          "new_line_content": "  BasicBlockSet storesNotAlive(loop->getHeader()->getParent());",
          "content_same": false
        },
        {
          "line": 1297,
          "old_api": "tains",
          "new_api": "insert",
          "old_text": "tains(block) &&\n      ",
          "new_text": "live.insert(header);\n  bool c",
          "old_line_content": "      if (storeAlive && !stores.contains(block) &&",
          "new_line_content": "  storesNotAlive.insert(header);",
          "content_same": false
        },
        {
          "line": 1313,
          "old_api": "nd",
          "new_api": "erminator",
          "old_text": "nd(), isUnreac",
          "new_text": "erminator());\n  };\n\n ",
          "old_line_content": "    if (!std::any_of(eb->succ_begin(), eb->succ_end(), isUnreachableBlock) &&",
          "new_line_content": "    return isa<UnreachableInst>(succ->getTerminator());",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": "size",
          "new_api": "onlyDominateLoopExits",
          "old_text": "atchBlock->getSuccessors().size();\n        ",
          "new_text": "onlyDominateLoopExits(accessPath, loop,\n                                       exitingAndLatchBlocks))\n    retu",
          "old_line_content": "    for (unsigned idx = 0, e = exitingOrLatchBlock->getSuccessors().size();",
          "new_line_content": "  if (!storesCommonlyDominateLoopExits(accessPath, loop,",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": "oopPreheader",
          "new_api": "getTerminator",
          "old_text": "oopPreheader();\n  assert",
          "new_text": "atchBlock->getTerminator(), idx, Dom",
          "old_line_content": "  SILBasicBlock *preheader = loop->getLoopPreheader();",
          "new_line_content": "        splitCriticalEdge(exitingOrLatchBlock->getTerminator(), idx, DomTree,",
          "content_same": false
        },
        {
          "line": 1363,
          "old_api": "()), accessP",
          "new_api": "ccess",
          "old_text": "()), accessP",
          "new_text": "ccess(I, accessPath)) {\n      ",
          "old_line_content": "      if (isLoadWithinAccess(dyn_cast<LoadInst>(SI->getSrc()), accessPath))",
          "new_line_content": "    if (auto *SI = isStoreToAccess(I, accessPath)) {",
          "content_same": false
        },
        {
          "line": 1369,
          "old_api": ">getOwnershipKind());\n      }",
          "new_api": "()), accessP",
          "old_text": ">getOwnershipKind());\n      }",
          "new_text": "()), accessP",
          "old_line_content": "                              storeAddr->getOwnershipKind());",
          "new_line_content": "      if (isLoadWithinAccess(dyn_cast<LoadInst>(SI->getSrc()), accessPath))",
          "content_same": false
        },
        {
          "line": 1383,
          "old_api": "etParentBlock",
          "new_api": "());\n    }",
          "old_text": "etParentBlock(), preheade",
          "new_text": "());\n    }\n ",
          "old_line_content": "    if (DomTree->dominates(srcAddr->getParentBlock(), preheader))",
          "new_line_content": "      ssaUpdater.addAvailableValue(SI->getParent(), SI->getSrc());",
          "content_same": false
        },
        {
          "line": 1406,
          "old_api": "nt",
          "new_api": "addAvailableValue",
          "old_text": "nt();\n    if (",
          "new_text": ".addAvailableValue(preheader, initialLoad);\n\n  // Re",
          "old_line_content": "    SILBasicBlock *block = I->getParent();",
          "new_line_content": "  ssaUpdater.addAvailableValue(preheader, initialLoad);",
          "content_same": false
        },
        {
          "line": 1412,
          "old_api": "() << \"Delet",
          "new_api": "nt",
          "old_text": "() << \"Delet",
          "new_text": "nt();\n    if (",
          "old_line_content": "      LLVM_DEBUG(llvm::dbgs() << \"Deleting reloaded store \" << *SI);",
          "new_line_content": "    SILBasicBlock *block = I->getParent();",
          "content_same": false
        },
        {
          "line": 1417,
          "old_api": "inAccess",
          "new_api": "ccess",
          "old_text": "inAccess(I, accessPath);\n    if (",
          "new_text": "ccess(I, accessPath)) {\n      ",
          "old_line_content": "    auto loadWithAccess = isLoadWithinAccess(I, accessPath);",
          "new_line_content": "    if (auto *SI = isStoreToAccess(I, accessPath)) {",
          "content_same": false
        },
        {
          "line": 1430,
          "old_api": "() << \"Repla",
          "new_api": "getValueInMiddleOfBlock",
          "old_text": "() << \"Repla",
          "new_text": ".getValueInMiddleOfBlock(block);\n\n    Loa",
          "old_line_content": "    LLVM_DEBUG(llvm::dbgs() << \"Replacing stored load \" << *load << \" with \"",
          "new_line_content": "      currentVal = ssaUpdater.getValueInMiddleOfBlock(block);",
          "content_same": false
        },
        {
          "line": 1433,
          "old_api": "nsert",
          "new_api": "perand",
          "old_text": "nsert(load);\n  }\n\n  /",
          "new_text": "perand();\n    SILV",
          "old_line_content": "    toDelete.insert(load);",
          "new_line_content": "    auto loadAddress = load->getOperand();",
          "content_same": false
        },
        {
          "line": 1438,
          "old_api": "getSuccessors",
          "new_api": "aceAllUsesWith",
          "old_text": "atchBlock->getSuccessors()) {\n      ",
          "new_text": "aceAllUsesWith(projectedValue);\n    toDe",
          "old_line_content": "    for (SILBasicBlock *succ : exitingOrLatchBlock->getSuccessors()) {",
          "new_line_content": "    load->replaceAllUsesWith(projectedValue);",
          "content_same": false
        },
        {
          "line": 1439,
          "old_api": "ains",
          "new_api": "nsert",
          "old_text": "ains(succ))\n        ",
          "new_text": "nsert(load);\n  }\n\n  /",
          "old_line_content": "      if (loop->contains(succ))",
          "new_line_content": "    toDelete.insert(load);",
          "content_same": false
        },
        {
          "line": 1444,
          "old_api": "n",
          "new_api": "getSuccessors",
          "old_text": "n());\n      a",
          "new_text": "atchBlock->getSuccessors()) {\n      ",
          "old_line_content": "      SILBuilder B(succ->begin());",
          "new_line_content": "    for (SILBasicBlock *succ : exitingOrLatchBlock->getSuccessors()) {",
          "content_same": false
        },
        {
          "line": 1445,
          "old_api": "value",
          "new_api": "ains",
          "old_text": "ore(\n          loc.value(), ssaUpdater.getValueInMiddleOfBlock(succ), initialAddr,\n          StoreOwnershipQualifier::Unqualified);\n      (v",
          "new_text": "ains(succ))\n        ",
          "old_line_content": "      auto *SI = B.createStore(",
          "new_line_content": "      if (loop->contains(succ))",
          "content_same": false
        },
        {
          "line": 1468,
          "old_api": "yDeleteTriviallyDeadInstructions",
          "new_api": "clear",
          "old_text": "yDeleteTriviallyDeadInstructions(I, /*force*/ true);\n  }\n  to",
          "new_text": "reAddrs.clear();\n\n  if (t",
          "old_line_content": "    recursivelyDeleteTriviallyDeadInstructions(I, /*force*/ true);",
          "new_line_content": "  LoadAndStoreAddrs.clear();",
          "content_same": false
        },
        {
          "line": 1470,
          "old_api": "lear",
          "new_api": "mpty",
          "old_text": "lear();\n  return",
          "new_text": "mpty())\n    retu",
          "old_line_content": "  toDelete.clear();",
          "new_line_content": "  if (toDelete.empty())",
          "content_same": false
        },
        {
          "line": 1498,
          "old_api": "lysis<SILLoopAnalysis>();\n    SILL",
          "new_api": "n",
          "old_text": "lysis<SILLoopAnalysis>();\n    SILL",
          "new_text": "n();\n\n    // ",
          "old_line_content": "    SILLoopAnalysis *LA = PM->getAnalysis<SILLoopAnalysis>();",
          "new_line_content": "    SILFunction *F = getFunction();",
          "content_same": false
        },
        {
          "line": 1501,
          "old_api": "empty",
          "new_api": "rship",
          "old_text": "empty()) {\n      ",
          "new_text": "rship())\n      re",
          "old_line_content": "    if (LoopInfo->empty()) {",
          "new_line_content": "    if (F->hasOwnership())",
          "content_same": false
        },
        {
          "line": 1507,
          "old_api": "lysis<PostDominanceAnalysis>();\n    Alia",
          "new_api": "empty",
          "old_text": "lysis<PostDominanceAnalysis>();\n    Alia",
          "new_text": "empty()) {\n      ",
          "old_line_content": "    PostDominanceAnalysis *PDA = PM->getAnalysis<PostDominanceAnalysis>();",
          "new_line_content": "    if (LoopInfo->empty()) {",
          "content_same": false
        },
        {
          "line": 1508,
          "old_api": "lysis<AliasAnalysis>(F);\n    Basi",
          "new_api": "() << \"\\n\");",
          "old_text": "lysis<AliasAnalysis>(F);\n    Basi",
          "new_text": "() << \"\\n\");",
          "old_line_content": "    AliasAnalysis *AA = PM->getAnalysis<AliasAnalysis>(F);",
          "new_line_content": "      LLVM_DEBUG(llvm::dbgs() << \"No loops in \" << F->getName() << \"\\n\");",
          "content_same": false
        },
        {
          "line": 1513,
          "old_api": "() << \"\\n\");",
          "new_api": "lysis<PostDominanceAnalysis>();\n    Alia",
          "old_text": "() << \"\\n\");",
          "new_text": "lysis<PostDominanceAnalysis>();\n    Alia",
          "old_line_content": "    LLVM_DEBUG(llvm::dbgs() << \"Processing loops in \" << F->getName() << \"\\n\");",
          "new_line_content": "    PostDominanceAnalysis *PDA = PM->getAnalysis<PostDominanceAnalysis>();",
          "content_same": false
        },
        {
          "line": 1526,
          "old_api": "dateAnalysis",
          "new_api": "ze",
          "old_text": "dateAnalysis(F, SILAnalysis::InvalidationKind::FunctionBody);\n      LA",
          "new_text": "ze();\n    }\n\n ",
          "old_line_content": "      PM->invalidateAnalysis(F, SILAnalysis::InvalidationKind::FunctionBody);",
          "new_line_content": "      Changed |= Opt.optimize();",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1028,
          "old_api": null,
          "new_api": "ElementAddrInst>(innerAddress)\n      &&",
          "old_text": null,
          "new_text": "ElementAddrInst>(innerAddress)\n      && ",
          "old_line_content": "",
          "new_line_content": "  if (!isa<StructElementAddrInst>(innerAddress)",
          "content_same": false
        },
        {
          "line": 1032,
          "old_api": null,
          "new_api": "Index",
          "old_text": null,
          "new_text": "Index(innerAddress).Index\n   ",
          "old_line_content": "                              reversePathIndices)) {",
          "new_line_content": "  assert(ProjectionIndex(innerAddress).Index",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": null,
          "new_api": "getSubObjectIndex",
          "old_text": null,
          "new_text": "getIndex().getSubObjectIndex());\n\n  reve",
          "old_line_content": "    return false;",
          "new_line_content": "         == innerPath.getIndex().getSubObjectIndex());",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": null,
          "new_api": "getIndex",
          "old_text": null,
          "new_text": "getIndex());\n  SILVa",
          "old_line_content": "  return true;",
          "new_line_content": "  reversePathIndices.push_back(innerPath.getIndex());",
          "content_same": false
        },
        {
          "line": 1036,
          "old_api": null,
          "new_api": "getOperand",
          "old_text": null,
          "new_text": "eValueInstruction>(innerAddress)->getOperand(0);\n  if (!c",
          "old_line_content": "}",
          "new_line_content": "  SILValue srcAddr = cast<SingleValueInstruction>(innerAddress)->getOperand(0);",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": null,
          "new_api": "getParent",
          "old_text": null,
          "new_text": "getParent(), srcAddr,",
          "old_line_content": "",
          "new_line_content": "  if (!computeInnerAccessPath(outerPath, innerPath.getParent(), srcAddr,",
          "content_same": false
        },
        {
          "line": 1057,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "ath.empty()) {\n    //",
          "old_line_content": "    // sink. LoadsAndStores must remain in instruction order.",
          "new_line_content": "  if (remainingPath.empty()) {",
          "content_same": false
        },
        {
          "line": 1061,
          "old_api": null,
          "new_api": "_back",
          "old_text": null,
          "new_text": "_back(load);\n    // R",
          "old_line_content": "  }",
          "new_line_content": "    Loads.push_back(load);",
          "content_same": false
        },
        {
          "line": 1065,
          "old_api": null,
          "new_api": "() << \"Creat",
          "old_text": null,
          "new_text": "() << \"Creat",
          "old_line_content": "  };",
          "new_line_content": "    LLVM_DEBUG(llvm::dbgs() << \"Created load from stored path: \" << *load);",
          "content_same": false
        },
        {
          "line": 1069,
          "old_api": null,
          "new_api": "_back",
          "old_text": null,
          "new_text": "_back(newLoad);\n    Load",
          "old_line_content": "    SmallVector<SILValue, 4> elements;",
          "new_line_content": "    Loads.push_back(newLoad);",
          "content_same": false
        },
        {
          "line": 1073,
          "old_api": null,
          "new_api": "getType",
          "old_text": null,
          "new_text": "ss->getType();\n  if (Ca",
          "old_line_content": "      SILValue elementVal;",
          "new_line_content": "  SILType loadTy = splitAddress->getType();",
          "content_same": false
        },
        {
          "line": 1074,
          "old_api": null,
          "new_api": "As<TupleType>()) {\n    Sm",
          "old_text": null,
          "new_text": "As<TupleType>()) {\n    Sm",
          "old_line_content": "      if (tupleIdx == subIndex) {",
          "new_line_content": "  if (CanTupleType tupleTy = loadTy.getAs<TupleType>()) {",
          "content_same": false
        },
        {
          "line": 1076,
          "old_api": null,
          "new_api": "etNumElements",
          "old_text": null,
          "new_text": "etNumElements())) {\n     ",
          "old_line_content": "                               Loads, ldstIdx);",
          "new_line_content": "    for (int tupleIdx : range(tupleTy->getNumElements())) {",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": null,
          "new_api": "getTupleElementType",
          "old_text": null,
          "new_text": "eateTupleElementAddr(\n          loc, splitAddress, tupleIdx, loadTy.getTupleElementType(tupleIdx));\n      SI",
          "old_line_content": "      } else {",
          "new_line_content": "      auto *projection = builder.createTupleElementAddr(",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": null,
          "new_api": "drop_back",
          "old_text": null,
          "new_text": "ath.drop_back(), builder,",
          "old_line_content": "      }",
          "new_line_content": "        elementVal = splitLoad(projection, remainingPath.drop_back(), builder,",
          "content_same": false
        },
        {
          "line": 1090,
          "old_api": null,
          "new_api": "eateTuple",
          "old_text": null,
          "new_text": "eateTuple(loc, elements);\n  }\n  au",
          "old_line_content": "",
          "new_line_content": "    return builder.createTuple(loc, elements);",
          "content_same": false
        },
        {
          "line": 1092,
          "old_api": null,
          "new_api": "StructOrBoundGenericStruct",
          "old_text": null,
          "new_text": "StructOrBoundGenericStruct();\n  assert",
          "old_line_content": "  int fieldIdx = 0;",
          "new_line_content": "  auto structTy = loadTy.getStructOrBoundGenericStruct();",
          "content_same": false
        },
        {
          "line": 1095,
          "old_api": null,
          "new_api": "getTypeExpansionContext",
          "old_text": null,
          "new_text": "tFunction().getTypeExpansionContext();\n\n  Small",
          "old_line_content": "    auto *projection =",
          "new_line_content": "  auto expansionContext = builder.getFunction().getTypeExpansionContext();",
          "content_same": false
        },
        {
          "line": 1100,
          "old_api": null,
          "new_api": "FieldType",
          "old_text": null,
          "new_text": "FieldType(field, module, expansionContext);\n    auto",
          "old_line_content": "                           Loads, ldstIdx);",
          "new_line_content": "    SILType fieldTy = loadTy.getFieldType(field, module, expansionContext);",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": null,
          "new_api": "drop_back",
          "old_text": null,
          "new_text": "ath.drop_back(), builder,",
          "old_line_content": "    }",
          "new_line_content": "      fieldVal = splitLoad(projection, remainingPath.drop_back(), builder,",
          "content_same": false
        },
        {
          "line": 1110,
          "old_api": null,
          "new_api": "nst>(fieldVal));\n    }",
          "old_text": null,
          "new_text": "nst>(fieldVal));\n    }\n ",
          "old_line_content": "",
          "new_line_content": "      recordDisjointLoad(cast<LoadInst>(fieldVal));",
          "content_same": false
        },
        {
          "line": 1112,
          "old_api": null,
          "new_api": "ush_back",
          "old_text": null,
          "new_text": "ush_back(fieldVal);\n  }\n  re",
          "old_line_content": "/// identical accessPath and a set of non-overlapping loads. Add the new",
          "new_line_content": "    elements.push_back(fieldVal);",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": null,
          "new_api": "ObjectType",
          "old_text": null,
          "new_text": "ObjectType(), elements",
          "old_line_content": "///",
          "new_line_content": "  return builder.createStruct(loc, loadTy.getObjectType(), elements);",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": null,
          "new_api": "dFromMemory",
          "old_text": null,
          "new_text": "dFromMemory(load, storeAddr))\n      co",
          "old_line_content": "",
          "new_line_content": "    if (!AA->mayReadFromMemory(load, storeAddr))",
          "content_same": false
        },
        {
          "line": 1137,
          "old_api": null,
          "new_api": "perand",
          "old_text": null,
          "new_text": "perand());\n    if ",
          "old_line_content": "    SmallVector<AccessPath::Index, 4> reversePathIndices;",
          "new_line_content": "    AccessPath loadAccessPath = AccessPath::compute(load->getOperand());",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "Path.contains(accessPath));\n    LLV",
          "old_line_content": "      return false;",
          "new_line_content": "    assert(loadAccessPath.contains(accessPath));",
          "content_same": false
        },
        {
          "line": 1142,
          "old_api": null,
          "new_api": "() << \"Overl",
          "old_text": null,
          "new_text": "() << \"Overl",
          "old_line_content": "    }",
          "new_line_content": "    LLVM_DEBUG(llvm::dbgs() << \"Overlaps with loop stores: \" << *load);",
          "content_same": false
        },
        {
          "line": 1144,
          "old_api": null,
          "new_api": "getPathNode",
          "old_text": null,
          "new_text": "Path.getPathNode(),\n        ",
          "old_line_content": "    //",
          "new_line_content": "    if (!computeInnerAccessPath(loadAccessPath.getPathNode(),",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": null,
          "new_api": "getPathNode",
          "old_text": null,
          "new_text": ".getPathNode(), storeAdd",
          "old_line_content": "    // SplitLoads is called for each unique access path in the loop that is",
          "new_line_content": "                                accessPath.getPathNode(), storeAddr,",
          "content_same": false
        },
        {
          "line": 1163,
          "old_api": null,
          "new_api": "() << \"...Sp",
          "old_text": null,
          "new_text": "() << \"...Sp",
          "old_line_content": "    }();",
          "new_line_content": "    LLVM_DEBUG(llvm::dbgs() << \"...Splitting load\\n\");",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "d]() {\n      auto ldstIter = llvm::find(LoadsAndStores, load);\n      assert(ldstIter != LoadsAndStores.end() && \"outerLoad missing\");\n      return std::distance(LoadsAndStores.begin(), ldstIter);\n    }();\n\n    SIL",
          "old_line_content": "    SILBuilderWithScope builder(load);",
          "new_line_content": "    unsigned ldstIdx = [this, load]() {",
          "content_same": false
        },
        {
          "line": 1166,
          "old_api": null,
          "new_api": "(LoadsAndStores, load);\n      as",
          "old_text": null,
          "new_text": "(LoadsAndStores, load);\n      as",
          "old_line_content": "",
          "new_line_content": "      auto ldstIter = llvm::find(LoadsAndStores, load);",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "ores.begin(), ldstIter",
          "old_line_content": "                                      builder, Loads, ldstIdx);",
          "new_line_content": "      return std::distance(LoadsAndStores.begin(), ldstIter);",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": null,
          "new_api": "aceAllUsesWith",
          "old_text": null,
          "new_text": "aceAllUsesWith(aggregateVal);\n    auto",
          "old_line_content": "}",
          "new_line_content": "    load->replaceAllUsesWith(aggregateVal);",
          "content_same": false
        },
        {
          "line": 1177,
          "old_api": null,
          "new_api": "nsert",
          "old_text": null,
          "new_text": "nsert(load);\n    (voi",
          "old_line_content": "",
          "new_line_content": "    auto iterAndInserted = toDelete.insert(load);",
          "content_same": false
        },
        {
          "line": 1179,
          "old_api": null,
          "new_api": "rAndInserted.second && \"the same load should only be split once\");\n  }\n  re",
          "old_text": null,
          "new_text": "rAndInserted.second && \"the same load should only be split once\");\n  }\n  re",
          "old_line_content": "    std::unique_ptr<LoopNestSummary> &CurrSummary) {",
          "new_line_content": "    assert(iterAndInserted.second && \"the same load should only be split once\");",
          "content_same": false
        },
        {
          "line": 1194,
          "old_api": null,
          "new_api": "uctions",
          "old_text": null,
          "new_text": "uctions(CurrentLoop, DomTree, HoistUp);\n  currCh",
          "old_line_content": "  return currChanged;",
          "new_line_content": "  currChanged |= hoistInstructions(CurrentLoop, DomTree, HoistUp);",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": null,
          "new_api": "ctions",
          "old_text": null,
          "new_text": "ctions(CurrSummary, DomTree, LoopInfo, SinkDown);\n  currCh",
          "old_line_content": "}",
          "new_line_content": "  currChanged |= sinkInstructions(CurrSummary, DomTree, LoopInfo, SinkDown);",
          "content_same": false
        },
        {
          "line": 1197,
          "old_api": null,
          "new_api": "alInstruction",
          "old_text": null,
          "new_text": "alInstruction(CurrSummary, DomTree, LoopInfo, SpecialHoist);\n\n  asser",
          "old_line_content": "/// Creates a value projection from \\p rootVal based on the address projection",
          "new_line_content": "      hoistSpecialInstruction(CurrSummary, DomTree, LoopInfo, SpecialHoist);",
          "content_same": false
        },
        {
          "line": 1199,
          "old_api": null,
          "new_api": "mpty",
          "old_text": null,
          "new_text": "mpty() && \"only ",
          "old_line_content": "static SILValue projectLoadValue(SILValue addr, AccessPath accessPath,",
          "new_line_content": "  assert(toDelete.empty() && \"only hostAllLoadsAndStores deletes\");",
          "content_same": false
        },
        {
          "line": 1213,
          "old_api": null,
          "new_api": "tructElementAddrInst>(addr)) {\n    as",
          "old_text": null,
          "new_text": "tructElementAddrInst>(addr)) {\n    as",
          "old_line_content": "        rootVal, rootAccessPath, beforeInst);",
          "new_line_content": "  if (auto *SEI = dyn_cast<StructElementAddrInst>(addr)) {",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": null,
          "new_api": "Index",
          "old_text": null,
          "new_text": "Index(SEI).Index == ",
          "old_line_content": "    SILBuilder B(beforeInst);",
          "new_line_content": "    assert(ProjectionIndex(SEI).Index == elementIdx);",
          "content_same": false
        },
        {
          "line": 1217,
          "old_api": null,
          "new_api": "etParent",
          "old_text": null,
          "new_text": "etParent(),\n        ",
          "old_line_content": "  }",
          "new_line_content": "        AccessPath(accessPath.getStorage(), pathNode.getParent(),",
          "content_same": false
        },
        {
          "line": 1224,
          "old_api": null,
          "new_api": "upleElementAddrInst>(addr)) {\n    as",
          "old_text": null,
          "new_text": "upleElementAddrInst>(addr)) {\n    as",
          "old_line_content": "        rootVal, rootAccessPath, beforeInst);",
          "new_line_content": "  if (auto *TEI = dyn_cast<TupleElementAddrInst>(addr)) {",
          "content_same": false
        },
        {
          "line": 1225,
          "old_api": null,
          "new_api": "Index",
          "old_text": null,
          "new_text": "Index(TEI).Index == ",
          "old_line_content": "    SILBuilder B(beforeInst);",
          "new_line_content": "    assert(ProjectionIndex(TEI).Index == elementIdx);",
          "content_same": false
        },
        {
          "line": 1228,
          "old_api": null,
          "new_api": "etParent",
          "old_text": null,
          "new_text": "etParent(),\n        ",
          "old_line_content": "  }",
          "new_line_content": "        AccessPath(accessPath.getStorage(), pathNode.getParent(),",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": null,
          "new_api": "eldIndex",
          "old_text": null,
          "new_text": "eldIndex(),\n        ",
          "old_line_content": "/// Returns true if all stores to \\p addr commonly dominate the loop exits.",
          "new_line_content": "    return B.createTupleExtract(beforeInst->getLoc(), val, TEI->getFieldIndex(),",
          "content_same": false
        },
        {
          "line": 1233,
          "old_api": null,
          "new_api": "getObjectType",
          "old_text": null,
          "new_text": "pe().getObjectType());\n  }\n  l",
          "old_line_content": "static bool",
          "new_line_content": "                                TEI->getType().getObjectType());",
          "content_same": false
        },
        {
          "line": 1235,
          "old_api": null,
          "new_api": "chable",
          "old_text": null,
          "new_text": "chable(\"unknown projection\");\n}\n\n/// R",
          "old_line_content": "                                SILLoop *loop,",
          "new_line_content": "  llvm_unreachable(\"unknown projection\");",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": null,
          "new_api": "er",
          "old_text": null,
          "new_text": "er();\n    if (",
          "old_line_content": "  // loop exits.",
          "new_line_content": "    SILInstruction *user = use->getUser();",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": null,
          "new_api": "arent",
          "old_text": null,
          "new_text": "arent());\n  }\n  S",
          "old_line_content": "    return true;",
          "new_line_content": "      stores.insert(user->getParent());",
          "content_same": false
        },
        {
          "line": 1253,
          "old_api": null,
          "new_api": "eader",
          "old_text": null,
          "new_text": "eader();\n  // If ",
          "old_line_content": "  // Also a store in the pre-header dominates all exists. Although the situation",
          "new_line_content": "  SILBasicBlock *header = loop->getHeader();",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": null,
          "new_api": "tains",
          "old_text": null,
          "new_text": "tains(header))\n    retu",
          "old_line_content": "  // But even if the loop-stores are not dominating the loop exits, it",
          "new_line_content": "  if (stores.contains(header))",
          "content_same": false
        },
        {
          "line": 1301,
          "old_api": null,
          "new_api": "ks",
          "old_text": null,
          "new_text": "ks()) {\n      ",
          "old_line_content": "        changed = true;",
          "new_line_content": "    for (SILBasicBlock *block : loop->blocks()) {",
          "content_same": false
        },
        {
          "line": 1302,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "live.contains(block);\n      if",
          "old_line_content": "      }",
          "new_line_content": "      bool storeAlive = !storesNotAlive.contains(block);",
          "content_same": false
        },
        {
          "line": 1303,
          "old_api": null,
          "new_api": "tains",
          "old_text": null,
          "new_text": "tains(block) &&\n      ",
          "old_line_content": "    }",
          "new_line_content": "      if (storeAlive && !stores.contains(block) &&",
          "content_same": false
        },
        {
          "line": 1304,
          "old_api": null,
          "new_api": "d_end",
          "old_text": null,
          "new_text": "d_end(),\n        ",
          "old_line_content": "  } while (changed);",
          "new_line_content": "          std::any_of(block->pred_begin(), block->pred_end(),",
          "content_same": false
        },
        {
          "line": 1305,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "live.contains(b); })) {\n  ",
          "old_line_content": "",
          "new_line_content": "            [&](SILBasicBlock *b) { return storesNotAlive.contains(b); })) {",
          "content_same": false
        },
        {
          "line": 1306,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "live.insert(block);\n        ",
          "old_line_content": "  auto isUnreachableBlock = [](SILBasicBlock *succ) {",
          "new_line_content": "        storesNotAlive.insert(block);",
          "content_same": false
        },
        {
          "line": 1319,
          "old_api": null,
          "new_api": "nd",
          "old_text": null,
          "new_text": "nd(), isUnreac",
          "old_line_content": "}",
          "new_line_content": "    if (!std::any_of(eb->succ_begin(), eb->succ_end(), isUnreachableBlock) &&",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "live.contains(eb)) {\n      ",
          "old_line_content": "",
          "new_line_content": "        storesNotAlive.contains(eb)) {",
          "content_same": false
        },
        {
          "line": 1330,
          "old_api": null,
          "new_api": "xitingAndLatchBlocks",
          "old_text": null,
          "new_text": "xitingAndLatchBlocks(exitingAndLatchBlocks);\n\n  // Th",
          "old_line_content": "    return;",
          "new_line_content": "  loop->getExitingAndLatchBlocks(exitingAndLatchBlocks);",
          "content_same": false
        },
        {
          "line": 1340,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "atchBlock->getSuccessors().size();\n        ",
          "old_line_content": "                          LoopInfo);",
          "new_line_content": "    for (unsigned idx = 0, e = exitingOrLatchBlock->getSuccessors().size();",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": null,
          "new_api": "getSuccessors",
          "old_text": null,
          "new_text": "atchBlock->getSuccessors()[idx])) {\n",
          "old_line_content": "",
          "new_line_content": "      if (!loop->contains(exitingOrLatchBlock->getSuccessors()[idx])) {",
          "content_same": false
        },
        {
          "line": 1351,
          "old_api": null,
          "new_api": "oopPreheader",
          "old_text": null,
          "new_text": "oopPreheader();\n  assert",
          "old_line_content": "  SILSSAUpdater ssaUpdater;",
          "new_line_content": "  SILBasicBlock *preheader = loop->getLoopPreheader();",
          "content_same": false
        },
        {
          "line": 1352,
          "old_api": null,
          "new_api": "header && \"Expected a preheader\");\n\n  // In",
          "old_text": null,
          "new_text": "header && \"Expected a preheader\");\n\n  // In",
          "old_line_content": "",
          "new_line_content": "  assert(preheader && \"Expected a preheader\");",
          "content_same": false
        },
        {
          "line": 1355,
          "old_api": null,
          "new_api": ">getTerminator());\n  SILVa",
          "old_text": null,
          "new_text": ">getTerminator());\n  SILVa",
          "old_line_content": "  Optional<SILLocation> loc;",
          "new_line_content": "  SILBuilder B(preheader->getTerminator());",
          "content_same": false
        },
        {
          "line": 1364,
          "old_api": null,
          "new_api": "();\n\n      /",
          "old_text": null,
          "new_text": "();\n\n      /",
          "old_line_content": "        return;",
          "new_line_content": "      loc = SI->getLoc();",
          "content_same": false
        },
        {
          "line": 1373,
          "old_api": null,
          "new_api": "t",
          "old_text": null,
          "new_text": "t();\n        ",
          "old_line_content": "        // because of casting or payload extraction even though they have the",
          "new_line_content": "        storeAddr = SI->getDest();",
          "content_same": false
        },
        {
          "line": 1374,
          "old_api": null,
          "new_api": "getObjectType",
          "old_text": null,
          "new_text": ">getType().getObjectType(),\n        ",
          "old_line_content": "        // same access path.",
          "new_line_content": "        ssaUpdater.initialize(storeAddr->getType().getObjectType(),",
          "content_same": false
        },
        {
          "line": 1375,
          "old_api": null,
          "new_api": ">getOwnershipKind());\n      }",
          "old_text": null,
          "new_text": ">getOwnershipKind());\n      }",
          "old_line_content": "        return;",
          "new_line_content": "                              storeAddr->getOwnershipKind());",
          "content_same": false
        },
        {
          "line": 1376,
          "old_api": null,
          "new_api": ">getType()) {",
          "old_text": null,
          "new_text": ">getType()) {\n      ",
          "old_line_content": "      }",
          "new_line_content": "      } else if (SI->getDest()->getType() != storeAddr->getType()) {",
          "content_same": false
        },
        {
          "line": 1386,
          "old_api": null,
          "new_api": "reAddr && \"hoistLoadsAndStores requires a store in the loop\");\n  auto c",
          "old_text": null,
          "new_text": "reAddr && \"hoistLoadsAndStores requires a store in the loop\");\n  auto c",
          "old_line_content": "    // return an invalid SILValue to continue cloning.",
          "new_line_content": "  assert(storeAddr && \"hoistLoadsAndStores requires a store in the loop\");",
          "content_same": false
        },
        {
          "line": 1389,
          "old_api": null,
          "new_api": "etParentBlock",
          "old_text": null,
          "new_text": "etParentBlock(), preheade",
          "old_line_content": "  SILValue initialAddr =",
          "new_line_content": "    if (DomTree->dominates(srcAddr->getParentBlock(), preheader))",
          "content_same": false
        },
        {
          "line": 1393,
          "old_api": null,
          "new_api": ";\n  };\n  S",
          "old_text": null,
          "new_text": ";\n  };\n  S",
          "old_line_content": "  if (!initialAddr)",
          "new_line_content": "    return SILValue();",
          "content_same": false
        },
        {
          "line": 1396,
          "old_api": null,
          "new_api": ">getTerminator(), checkBas",
          "old_text": null,
          "new_text": ">getTerminator(), checkBas",
          "old_line_content": "  LoadInst *initialLoad =",
          "new_line_content": "      cloneUseDefChain(storeAddr, preheader->getTerminator(), checkBase);",
          "content_same": false
        },
        {
          "line": 1403,
          "old_api": null,
          "new_api": "getLoc",
          "old_text": null,
          "new_text": ">getTerminator()->getLoc(), initialA",
          "old_line_content": "  SILBasicBlock *currentBlock = nullptr;",
          "new_line_content": "      B.createLoad(preheader->getTerminator()->getLoc(), initialAddr,",
          "content_same": false
        },
        {
          "line": 1405,
          "old_api": null,
          "new_api": "() << \"Creat",
          "old_text": null,
          "new_text": "() << \"Creat",
          "old_line_content": "  for (SILInstruction *I : LoadsAndStores) {",
          "new_line_content": "  LLVM_DEBUG(llvm::dbgs() << \"Creating preload \" << *initialLoad);",
          "content_same": false
        },
        {
          "line": 1415,
          "old_api": null,
          "new_api": ";\n    }",
          "old_text": null,
          "new_text": ";\n    }\n  ",
          "old_line_content": "      continue;",
          "new_line_content": "      currentVal = SILValue();",
          "content_same": false
        },
        {
          "line": 1418,
          "old_api": null,
          "new_api": "() << \"Delet",
          "old_text": null,
          "new_text": "() << \"Delet",
          "old_line_content": "    if (!loadWithAccess) {",
          "new_line_content": "      LLVM_DEBUG(llvm::dbgs() << \"Deleting reloaded store \" << *SI);",
          "content_same": false
        },
        {
          "line": 1419,
          "old_api": null,
          "new_api": "();\n      to",
          "old_text": null,
          "new_text": "();\n      to",
          "old_line_content": "      continue;",
          "new_line_content": "      currentVal = SI->getSrc();",
          "content_same": false
        },
        {
          "line": 1420,
          "old_api": null,
          "new_api": "nsert",
          "old_text": null,
          "new_text": "nsert(SI);\n      co",
          "old_line_content": "    }",
          "new_line_content": "      toDelete.insert(SI);",
          "content_same": false
        },
        {
          "line": 1423,
          "old_api": null,
          "new_api": "inAccess",
          "old_text": null,
          "new_text": "inAccess(I, accessPath);\n    if (",
          "old_line_content": "    if (!currentVal)",
          "new_line_content": "    auto loadWithAccess = isLoadWithinAccess(I, accessPath);",
          "content_same": false
        },
        {
          "line": 1434,
          "old_api": null,
          "new_api": "dValue",
          "old_text": null,
          "new_text": "dValue(\n        loadAddress, loadWithAccess.accessPath, currentVal, accessPath, load);\n    LLVM",
          "old_line_content": "  }",
          "new_line_content": "    SILValue projectedValue = projectLoadValue(",
          "content_same": false
        },
        {
          "line": 1436,
          "old_api": null,
          "new_api": "() << \"Repla",
          "old_text": null,
          "new_text": "() << \"Repla",
          "old_line_content": "  // Store back the value at all loop exits.",
          "new_line_content": "    LLVM_DEBUG(llvm::dbgs() << \"Replacing stored load \" << *load << \" with \"",
          "content_same": false
        },
        {
          "line": 1448,
          "old_api": null,
          "new_api": "inglePredecessorBlock",
          "old_text": null,
          "new_text": "inglePredecessorBlock()\n         ",
          "old_line_content": "      (void)SI;",
          "new_line_content": "      assert(succ->getSinglePredecessorBlock()",
          "content_same": false
        },
        {
          "line": 1450,
          "old_api": null,
          "new_api": "n",
          "old_text": null,
          "new_text": "n());\n      a",
          "old_line_content": "    }",
          "new_line_content": "      SILBuilder B(succ->begin());",
          "content_same": false
        },
        {
          "line": 1451,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "ore(\n          loc.value(), ssaUpdater.getValueInMiddleOfBlock(succ), initialAddr,\n          StoreOwnershipQualifier::Unqualified);\n      (v",
          "old_line_content": "  }",
          "new_line_content": "      auto *SI = B.createStore(",
          "content_same": false
        },
        {
          "line": 1452,
          "old_api": null,
          "new_api": "getValueInMiddleOfBlock",
          "old_text": null,
          "new_text": ".getValueInMiddleOfBlock(succ), initialA",
          "old_line_content": "",
          "new_line_content": "          loc.value(), ssaUpdater.getValueInMiddleOfBlock(succ), initialAddr,",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": null,
          "new_api": "(AA, BCA, sideEffects, AI)) {",
          "old_text": null,
          "new_text": "(AA, BCA, sideEffects, AI)) {\n      ",
          "old_line_content": "    }",
          "new_line_content": "      if (!mayWriteTo(AA, BCA, sideEffects, AI)) {",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": null,
          "new_api": "sert",
          "old_text": null,
          "new_text": "sert(AI);\n      }\n",
          "old_line_content": "  }",
          "new_line_content": "        HoistUp.insert(AI);",
          "content_same": false
        },
        {
          "line": 1455,
          "old_api": null,
          "new_api": "() << \"Creat",
          "old_text": null,
          "new_text": "() << \"Creat",
          "old_line_content": "}",
          "new_line_content": "      LLVM_DEBUG(llvm::dbgs() << \"Creating loop-exit store \" << *SI);",
          "content_same": false
        },
        {
          "line": 1460,
          "old_api": null,
          "new_api": "eadInstruction",
          "old_text": null,
          "new_text": "eadInstruction(initialLoad);\n}\n\nbool ",
          "old_line_content": "  }",
          "new_line_content": "  eliminateDeadInstruction(initialLoad);",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "s.size() < 8000) {",
          "old_line_content": "  }",
          "new_line_content": "  if (Loads.size() * sideEffects.size() < 8000) {",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": null,
          "new_api": "sert",
          "old_text": null,
          "new_text": "sert(LI);\n      }\n",
          "old_line_content": "    if (!postDomTree) {",
          "new_line_content": "        HoistUp.insert(LI);",
          "content_same": false
        },
        {
          "line": 1465,
          "old_api": null,
          "new_api": "AndStores",
          "old_text": null,
          "new_text": "AndStores(accessPath, loop);\n  }\n  Lo",
          "old_line_content": "    return false;",
          "new_line_content": "    hoistLoadsAndStores(accessPath, loop);",
          "content_same": false
        },
        {
          "line": 1467,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "ores.clear();\n  LoadAn",
          "old_line_content": "  for (SILInstruction *I : toDelete) {",
          "new_line_content": "  LoadsAndStores.clear();",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "Calls.empty()) {\n    if",
          "old_line_content": "        // Check against side effects which are \"before\" (i.e. post-dominated",
          "new_line_content": "  if (!globalInitCalls.empty()) {",
          "content_same": false
        },
        {
          "line": 1474,
          "old_api": null,
          "new_api": "yDeleteTriviallyDeadInstructions",
          "old_text": null,
          "new_text": "yDeleteTriviallyDeadInstructions(I, /*force*/ true);\n  }\n  to",
          "old_line_content": "namespace {",
          "new_line_content": "    recursivelyDeleteTriviallyDeadInstructions(I, /*force*/ true);",
          "content_same": false
        },
        {
          "line": 1476,
          "old_api": null,
          "new_api": "lear",
          "old_text": null,
          "new_text": "lear();\n  return",
          "old_line_content": "///",
          "new_line_content": "  toDelete.clear();",
          "content_same": false
        },
        {
          "line": 965,
          "old_api": null,
          "new_api": "tWithGlobalInit",
          "old_text": null,
          "new_text": "tWithGlobalInit(AA, sideEffects, ginitCall, Preheader,\n             postDomTree)) {\n      ",
          "old_line_content": "  }",
          "new_line_content": "        if (!mayConflictWithGlobalInit(AA, sideEffects, ginitCall, Preheader,",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": null,
          "new_api": "sert",
          "old_text": null,
          "new_text": "sert(ginitCall);\n        ",
          "old_line_content": "  // Collect memory locations for which we can move all loads and stores out",
          "new_line_content": "          HoistUp.insert(ginitCall);",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": null,
          "new_api": "riant",
          "old_text": null,
          "new_text": "riant(access.base, Loop))) {\n     ",
          "old_line_content": "          }",
          "new_line_content": "        (access.base && isLoopInvariant(access.base, Loop))) {",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": null,
          "new_api": "t",
          "old_text": null,
          "new_text": "t(),\n        ",
          "old_line_content": "        }",
          "new_line_content": "      if (isOnlyLoadedAndStored(AA, sideEffects, Loads, Stores, SI->getDest(),",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "reAddrs.count(accessPath)) {\n      ",
          "old_line_content": "    }",
          "new_line_content": "        if (!LoadAndStoreAddrs.count(accessPath)) {",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": null,
          "new_api": "t",
          "old_text": null,
          "new_text": "t())) {\n     ",
          "old_line_content": "  }",
          "new_line_content": "          if (splitLoads(Loads, accessPath, SI->getDest())) {",
          "content_same": false
        },
        {
          "line": 1504,
          "old_api": null,
          "new_api": "lysis<SILLoopAnalysis>();\n    SILL",
          "old_text": null,
          "new_text": "lysis<SILLoopAnalysis>();\n    SILL",
          "old_line_content": "    }",
          "new_line_content": "    SILLoopAnalysis *LA = PM->getAnalysis<SILLoopAnalysis>();",
          "content_same": false
        },
        {
          "line": 1505,
          "old_api": null,
          "new_api": ";\n\n    if",
          "old_text": null,
          "new_text": ";\n\n    if ",
          "old_line_content": "",
          "new_line_content": "    SILLoopInfo *LoopInfo = LA->get(F);",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "s.end(),\n        ",
          "old_line_content": "    }",
          "new_line_content": "        std::any_of(sideEffects.begin(), sideEffects.end(),",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": null,
          "new_api": "ase",
          "old_text": null,
          "new_text": "ase(); });\n    ",
          "old_line_content": "  }",
          "new_line_content": "                    [&](SILInstruction *W) { return W->mayRelease(); });",
          "content_same": false
        },
        {
          "line": 1512,
          "old_api": null,
          "new_api": "lysis<DominanceAnalysis>();\n    Post",
          "old_text": null,
          "new_text": "lysis<DominanceAnalysis>();\n    Post",
          "old_line_content": "",
          "new_line_content": "    DominanceAnalysis *DA = PM->getAnalysis<DominanceAnalysis>();",
          "content_same": false
        },
        {
          "line": 1514,
          "old_api": null,
          "new_api": "lysis<AliasAnalysis>(F);\n    Basi",
          "old_text": null,
          "new_text": "lysis<AliasAnalysis>(F);\n    Basi",
          "old_line_content": "    bool Changed = false;",
          "new_line_content": "    AliasAnalysis *AA = PM->getAnalysis<AliasAnalysis>(F);",
          "content_same": false
        },
        {
          "line": 1515,
          "old_api": null,
          "new_api": "lysis<BasicCalleeAnalysis>();\n    Acce",
          "old_text": null,
          "new_text": "lysis<BasicCalleeAnalysis>();\n    Acce",
          "old_line_content": "",
          "new_line_content": "    BasicCalleeAnalysis *BCA = PM->getAnalysis<BasicCalleeAnalysis>();",
          "content_same": false
        },
        {
          "line": 1516,
          "old_api": null,
          "new_api": "s<AccessStorageAnalysis>();\n    Domi",
          "old_text": null,
          "new_text": "s<AccessStorageAnalysis>();\n    Domi",
          "old_line_content": "    for (auto *TopLevelLoop : *LoopInfo) {",
          "new_line_content": "    AccessStorageAnalysis *ASA = getAnalysis<AccessStorageAnalysis>();",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": null,
          "new_api": "Accesses",
          "old_text": null,
          "new_text": "Accesses(BI, Loop)) {\n      ",
          "old_line_content": "                           DomTree)) {",
          "new_line_content": "    if (!handledEndAccesses(BI, Loop)) {",
          "content_same": false
        },
        {
          "line": 1519,
          "old_api": null,
          "new_api": "() << \"\\n\");",
          "old_text": null,
          "new_text": "() << \"\\n\");",
          "old_line_content": "                               ASA, RunsOnHighLevelSil);",
          "new_line_content": "    LLVM_DEBUG(llvm::dbgs() << \"Processing loops in \" << F->getName() << \"\\n\");",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": null,
          "new_api": "() << \"Some",
          "old_text": null,
          "new_text": "() << \"Some ",
          "old_line_content": "    }",
          "new_line_content": "      LLVM_DEBUG(llvm::dbgs() << \"Some end accesses can't be handled\\n\");",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": null,
          "new_api": "inAccess",
          "old_text": null,
          "new_text": "inAccess(BI, BeginAccesses, fullApplies, sideEffects, ASA,\n                           DomTree)) {\n      ",
          "old_line_content": "",
          "new_line_content": "    if (analyzeBeginAccess(BI, BeginAccesses, fullApplies, sideEffects, ASA,",
          "content_same": false
        },
        {
          "line": 1523,
          "old_api": null,
          "new_api": ";\n      Lo",
          "old_text": null,
          "new_text": ";\n      Lo",
          "old_line_content": "    if (Changed) {",
          "new_line_content": "      if (!DomTree) DomTree = DA->get(F);",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "st.push_back(BI);\n    }\n  ",
          "old_line_content": "// projection chain from outerPath. Populate \\p reversePathIndices with the path",
          "new_line_content": "      SpecialHoist.push_back(BI);",
          "content_same": false
        },
        {
          "line": 1530,
          "old_api": null,
          "new_api": "validation",
          "old_text": null,
          "new_text": "validation();\n      DA",
          "old_line_content": "  }",
          "new_line_content": "      LA->lockInvalidation();",
          "content_same": false
        },
        {
          "line": 1531,
          "old_api": null,
          "new_api": "validation",
          "old_text": null,
          "new_text": "validation();\n      PM",
          "old_line_content": "};",
          "new_line_content": "      DA->lockInvalidation();",
          "content_same": false
        },
        {
          "line": 1532,
          "old_api": null,
          "new_api": "dateAnalysis",
          "old_text": null,
          "new_text": "dateAnalysis(F, SILAnalysis::InvalidationKind::FunctionBody);\n      LA",
          "old_line_content": "} // end anonymous namespace",
          "new_line_content": "      PM->invalidateAnalysis(F, SILAnalysis::InvalidationKind::FunctionBody);",
          "content_same": false
        },
        {
          "line": 1533,
          "old_api": null,
          "new_api": "Invalidation",
          "old_text": null,
          "new_text": "Invalidation();\n      DA",
          "old_line_content": "",
          "new_line_content": "      LA->unlockInvalidation();",
          "content_same": false
        },
        {
          "line": 1534,
          "old_api": null,
          "new_api": "Invalidation",
          "old_text": null,
          "new_text": "Invalidation();\n    }\n  ",
          "old_line_content": "SILTransform *swift::createLICM() {",
          "new_line_content": "      DA->unlockInvalidation();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1026,
          "old_api": "Index",
          "new_api": null,
          "old_text": "Index(innerAddress).Index\n   ",
          "new_text": null,
          "old_line_content": "  assert(ProjectionIndex(innerAddress).Index",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 1027,
          "old_api": "getSubObjectIndex",
          "new_api": null,
          "old_text": "getIndex().getSubObjectIndex());\n\n  reve",
          "new_text": null,
          "old_line_content": "         == innerPath.getIndex().getSubObjectIndex());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": "getOperand",
          "new_api": null,
          "old_text": "eValueInstruction>(innerAddress)->getOperand(0);\n  if (!c",
          "new_text": null,
          "old_line_content": "  SILValue srcAddr = cast<SingleValueInstruction>(innerAddress)->getOperand(0);",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": "getParent",
          "new_api": null,
          "old_text": "getParent(), srcAddr,",
          "new_text": null,
          "old_line_content": "  if (!computeInnerAccessPath(outerPath, innerPath.getParent(), srcAddr,",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": "getLoc",
          "new_api": null,
          "old_text": "ores[ldstIdx]->getLoc();\n  // Rec",
          "new_text": null,
          "old_line_content": "  auto loc = LoadsAndStores[ldstIdx]->getLoc();",
          "new_line_content": "/// \\p ldstIdx is the index into LoadsAndStores of the original outer load.",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": "empty",
          "new_api": null,
          "old_text": "ath.empty()) {\n    //",
          "new_text": null,
          "old_line_content": "  if (remainingPath.empty()) {",
          "new_line_content": "/// Return the aggregate produced by merging the loads.",
          "content_same": false
        },
        {
          "line": 1053,
          "old_api": "eateLoad",
          "new_api": null,
          "old_text": "eateLoad(loc, splitAddress,\n                                        LoadOwnershipQualifier::Unqualified);\n    Load",
          "new_text": null,
          "old_line_content": "    LoadInst *load = builder.createLoad(loc, splitAddress,",
          "new_line_content": "    SILValue splitAddress, ArrayRef<AccessPath::Index> remainingPath,",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": "_back",
          "new_api": null,
          "old_text": "_back(newLoad);\n    Load",
          "new_text": null,
          "old_line_content": "    Loads.push_back(newLoad);",
          "new_line_content": "    // sink. LoadsAndStores must remain in instruction order.",
          "content_same": false
        },
        {
          "line": 1064,
          "old_api": "begin",
          "new_api": null,
          "old_text": "ores.begin() + ldstIdx",
          "new_text": null,
          "old_line_content": "    LoadsAndStores.insert(LoadsAndStores.begin() + ldstIdx + 1, newLoad);",
          "new_line_content": "    LoadsAndStores[ldstIdx] = load;",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": "back",
          "new_api": null,
          "old_text": "ath.back().getSubObjectIndex();\n  SILTyp",
          "new_text": null,
          "old_line_content": "  auto subIndex = remainingPath.back().getSubObjectIndex();",
          "new_line_content": "    return load;",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": "getType",
          "new_api": null,
          "old_text": "ss->getType();\n  if (Ca",
          "new_text": null,
          "old_line_content": "  SILType loadTy = splitAddress->getType();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1068,
          "old_api": "As<TupleType>()) {\n    Sm",
          "new_api": null,
          "old_text": "As<TupleType>()) {\n    Sm",
          "new_text": null,
          "old_line_content": "  if (CanTupleType tupleTy = loadTy.getAs<TupleType>()) {",
          "new_line_content": "  auto recordDisjointLoad = [&](LoadInst *newLoad) {",
          "content_same": false
        },
        {
          "line": 1071,
          "old_api": "getTupleElementType",
          "new_api": null,
          "old_text": "eateTupleElementAddr(\n          loc, splitAddress, tupleIdx, loadTy.getTupleElementType(tupleIdx));\n      SI",
          "new_text": null,
          "old_line_content": "      auto *projection = builder.createTupleElementAddr(",
          "new_line_content": "  };",
          "content_same": false
        },
        {
          "line": 1075,
          "old_api": "drop_back",
          "new_api": null,
          "old_text": "ath.drop_back(), builder,",
          "new_text": null,
          "old_line_content": "        elementVal = splitLoad(projection, remainingPath.drop_back(), builder,",
          "new_line_content": "    SmallVector<SILValue, 4> elements;",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": "nst>(elementVal));\n      }",
          "new_api": null,
          "old_text": "nst>(elementVal));\n      }",
          "new_text": null,
          "old_line_content": "        recordDisjointLoad(cast<LoadInst>(elementVal));",
          "new_line_content": "      if (tupleIdx == subIndex) {",
          "content_same": false
        },
        {
          "line": 1082,
          "old_api": "ush_back",
          "new_api": null,
          "old_text": "ush_back(elementVal);\n    }\n  ",
          "new_text": null,
          "old_line_content": "      elements.push_back(elementVal);",
          "new_line_content": "                               Loads, ldstIdx);",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": "uctTy && \"tuple and struct elements are checked earlier\");\n  auto &",
          "new_api": null,
          "old_text": "uctTy && \"tuple and struct elements are checked earlier\");\n  auto &",
          "new_text": null,
          "old_line_content": "  assert(structTy && \"tuple and struct elements are checked earlier\");",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1089,
          "old_api": "getTypeExpansionContext",
          "new_api": null,
          "old_text": "tFunction().getTypeExpansionContext();\n\n  Small",
          "new_text": null,
          "old_line_content": "  auto expansionContext = builder.getFunction().getTypeExpansionContext();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1096,
          "old_api": "eateStructElementAddr",
          "new_api": null,
          "old_text": "eateStructElementAddr(loc, splitAddress, field, fieldTy);\n    SILV",
          "new_text": null,
          "old_line_content": "        builder.createStructElementAddr(loc, splitAddress, field, fieldTy);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1104,
          "old_api": "nst>(fieldVal));\n    }",
          "new_api": null,
          "old_text": "nst>(fieldVal));\n    }\n ",
          "new_text": null,
          "old_line_content": "      recordDisjointLoad(cast<LoadInst>(fieldVal));",
          "new_line_content": "    if (fieldIdx++ == subIndex)",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": "ush_back",
          "new_api": null,
          "old_text": "ush_back(fieldVal);\n  }\n  re",
          "new_text": null,
          "old_line_content": "    elements.push_back(fieldVal);",
          "new_line_content": "                           Loads, ldstIdx);",
          "content_same": false
        },
        {
          "line": 1122,
          "old_api": "(); loadsIdx",
          "new_api": null,
          "old_text": "(); loadsIdx",
          "new_text": null,
          "old_line_content": "  for (unsigned loadsIdx = 0, endIdx = Loads.size(); loadsIdx != endIdx;",
          "new_line_content": "/// AliasAnalysis interface that handles AccessPath.",
          "content_same": false
        },
        {
          "line": 1125,
          "old_api": "ount",
          "new_api": null,
          "old_text": "ount(load))\n      co",
          "new_text": null,
          "old_line_content": "    if (toDelete.count(load))",
          "new_line_content": "                                      SILValue storeAddr) {",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": "contains",
          "new_api": null,
          "old_text": ".contains(loadAccessPath))\n      co",
          "new_text": null,
          "old_line_content": "    if (accessPath.contains(loadAccessPath))",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": "contains",
          "new_api": null,
          "old_text": "Path.contains(accessPath));\n    LLV",
          "new_text": null,
          "old_line_content": "    assert(loadAccessPath.contains(accessPath));",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": "() << \"Overl",
          "new_api": null,
          "old_text": "() << \"Overl",
          "new_text": null,
          "old_line_content": "    LLVM_DEBUG(llvm::dbgs() << \"Overlaps with loop stores: \" << *load);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": "getPathNode",
          "new_api": null,
          "old_text": ".getPathNode(), storeAdd",
          "new_text": null,
          "old_line_content": "                                accessPath.getPathNode(), storeAddr,",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": "() >= endIdx",
          "new_api": null,
          "old_text": "() >= endIdx",
          "new_text": null,
          "old_line_content": "    if (Loads.size() >= endIdx + 6) {",
          "new_line_content": "    //   num-wide-loads x num-fields x num-loop-memops",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": "() << \"...Re",
          "new_api": null,
          "old_text": "() << \"...Re",
          "new_text": null,
          "old_line_content": "      LLVM_DEBUG(llvm::dbgs() << \"...Refusing to split more loads\\n\");",
          "new_line_content": "    //",
          "content_same": false
        },
        {
          "line": 1157,
          "old_api": "() << \"...Sp",
          "new_api": null,
          "old_text": "() << \"...Sp",
          "new_text": null,
          "old_line_content": "    LLVM_DEBUG(llvm::dbgs() << \"...Splitting load\\n\");",
          "new_line_content": "    // avoid super-linear behavior for large types (e.g. giant tuples), limit",
          "content_same": false
        },
        {
          "line": 1161,
          "old_api": "end",
          "new_api": null,
          "old_text": "ores.end() && \"outer",
          "new_text": null,
          "old_line_content": "      assert(ldstIter != LoadsAndStores.end() && \"outerLoad missing\");",
          "new_line_content": "      return false;",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": "begin",
          "new_api": null,
          "old_text": "ores.begin(), ldstIter",
          "new_text": null,
          "old_line_content": "      return std::distance(LoadsAndStores.begin(), ldstIter);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1170,
          "old_api": "aceAllUsesWith",
          "new_api": null,
          "old_text": "aceAllUsesWith(aggregateVal);\n    auto",
          "new_text": null,
          "old_line_content": "    load->replaceAllUsesWith(aggregateVal);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1171,
          "old_api": "nsert",
          "new_api": null,
          "old_text": "nsert(load);\n    (voi",
          "new_text": null,
          "old_line_content": "    auto iterAndInserted = toDelete.insert(load);",
          "new_line_content": "    SILBuilderWithScope builder(load);",
          "content_same": false
        },
        {
          "line": 1182,
          "old_api": "getLoopPreheader",
          "new_api": null,
          "old_text": "p->getLoopPreheader())\n    retu",
          "new_text": null,
          "old_line_content": "  if (!CurrentLoop->getLoopPreheader())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": "adsAndStores",
          "new_api": null,
          "old_text": "adsAndStores(CurrentLoop))\n    retu",
          "new_text": null,
          "old_line_content": "  if (hoistAllLoadsAndStores(CurrentLoop))",
          "new_line_content": "    std::unique_ptr<LoopNestSummary> &CurrSummary) {",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": "ctions",
          "new_api": null,
          "old_text": "ctions(CurrSummary, DomTree, LoopInfo, SinkDown);\n  currCh",
          "new_text": null,
          "old_line_content": "  currChanged |= sinkInstructions(CurrSummary, DomTree, LoopInfo, SinkDown);",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 1193,
          "old_api": "mpty",
          "new_api": null,
          "old_text": "mpty() && \"only ",
          "new_text": null,
          "old_line_content": "  assert(toDelete.empty() && \"only hostAllLoadsAndStores deletes\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1205,
          "old_api": "getPathNode",
          "new_api": null,
          "old_text": ".getPathNode();\n  int el",
          "new_text": null,
          "old_line_content": "  auto pathNode = accessPath.getPathNode();",
          "new_line_content": "static SILValue projectLoadValue(SILValue addr, AccessPath accessPath,",
          "content_same": false
        },
        {
          "line": 1206,
          "old_api": "getSubObjectIndex",
          "new_api": null,
          "old_text": "etIndex().getSubObjectIndex();\n  if (au",
          "new_text": null,
          "old_line_content": "  int elementIdx = pathNode.getIndex().getSubObjectIndex();",
          "new_line_content": "                                 SILValue rootVal, AccessPath rootAccessPath,",
          "content_same": false
        },
        {
          "line": 1207,
          "old_api": "tructElementAddrInst>(addr)) {\n    as",
          "new_api": null,
          "old_text": "tructElementAddrInst>(addr)) {\n    as",
          "new_text": null,
          "old_line_content": "  if (auto *SEI = dyn_cast<StructElementAddrInst>(addr)) {",
          "new_line_content": "                                 SILInstruction *beforeInst) {",
          "content_same": false
        },
        {
          "line": 1208,
          "old_api": "Index",
          "new_api": null,
          "old_text": "Index(SEI).Index == ",
          "new_text": null,
          "old_line_content": "    assert(ProjectionIndex(SEI).Index == elementIdx);",
          "new_line_content": "  if (accessPath == rootAccessPath)",
          "content_same": false
        },
        {
          "line": 1209,
          "old_api": "getStorage",
          "new_api": null,
          "old_text": "dValue(\n        SEI->getOperand(),\n        AccessPath(accessPath.getStorage(), pathNode.getParent(),\n                   accessPath.getOffset()),\n        rootVal, rootAccessPath, beforeInst);\n    SILB",
          "new_text": null,
          "old_line_content": "    SILValue val = projectLoadValue(",
          "new_line_content": "    return rootVal;",
          "content_same": false
        },
        {
          "line": 1210,
          "old_api": "erand",
          "new_api": null,
          "old_text": "erand(),\n        ",
          "new_text": null,
          "old_line_content": "        SEI->getOperand(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": "Index",
          "new_api": null,
          "old_text": "Index(TEI).Index == ",
          "new_text": null,
          "old_line_content": "    assert(ProjectionIndex(TEI).Index == elementIdx);",
          "new_line_content": "        rootVal, rootAccessPath, beforeInst);",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": "getStorage",
          "new_api": null,
          "old_text": "dValue(\n        TEI->getOperand(),\n        AccessPath(accessPath.getStorage(), pathNode.getParent(),\n                   accessPath.getOffset()),\n        rootVal, rootAccessPath, beforeInst);\n    SILB",
          "new_text": null,
          "old_line_content": "    SILValue val = projectLoadValue(",
          "new_line_content": "    SILBuilder B(beforeInst);",
          "content_same": false
        },
        {
          "line": 1223,
          "old_api": "getOffset",
          "new_api": null,
          "old_text": ".getOffset()),\n       ",
          "new_text": null,
          "old_line_content": "                   accessPath.getOffset()),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1237,
          "old_api": "getParent",
          "new_api": null,
          "old_text": "eader()->getParent());\n  Small",
          "new_text": null,
          "old_line_content": "  BasicBlockSet stores(loop->getHeader()->getParent());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1241,
          "old_api": "unction",
          "new_api": null,
          "old_text": "unction());\n  for (",
          "new_text": null,
          "old_line_content": "  accessPath.collectUses(uses, AccessUseType::Exact, loop->getFunction());",
          "new_line_content": "                                SILLoop *loop,",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": "nst>(user))\n      st",
          "new_api": null,
          "old_text": "nst>(user))\n      st",
          "new_text": null,
          "old_line_content": "    if (isa<StoreInst>(user))",
          "new_line_content": "  SmallVector<Operand *, 8> uses;",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": "arent",
          "new_api": null,
          "old_text": "arent());\n  }\n  S",
          "new_text": null,
          "old_line_content": "      stores.insert(user->getParent());",
          "new_line_content": "  // Collect as many recognizable stores as possible. It's ok if not all stores",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": "oopPreheader",
          "new_api": null,
          "old_text": "oopPreheader()))\n    ret",
          "new_text": null,
          "old_line_content": "  if (stores.contains(loop->getLoopPreheader()))",
          "new_line_content": "  //     br tail",
          "content_same": false
        },
        {
          "line": 1290,
          "old_api": "getParent",
          "new_api": null,
          "old_text": "eader()->getParent());\n  store",
          "new_text": null,
          "old_line_content": "  BasicBlockSet storesNotAlive(loop->getHeader()->getParent());",
          "new_line_content": "  //",
          "content_same": false
        },
        {
          "line": 1295,
          "old_api": "ks",
          "new_api": null,
          "old_text": "ks()) {\n      ",
          "new_text": null,
          "old_line_content": "    for (SILBasicBlock *block : loop->blocks()) {",
          "new_line_content": "  // starting at the header.",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": "d_end",
          "new_api": null,
          "old_text": "d_end(),\n        ",
          "new_text": null,
          "old_line_content": "          std::any_of(block->pred_begin(), block->pred_end(),",
          "new_line_content": "  bool changed = false;",
          "content_same": false
        },
        {
          "line": 1299,
          "old_api": "contains",
          "new_api": null,
          "old_text": "live.contains(b); })) {\n  ",
          "new_text": null,
          "old_line_content": "            [&](SILBasicBlock *b) { return storesNotAlive.contains(b); })) {",
          "new_line_content": "  do {",
          "content_same": false
        },
        {
          "line": 1300,
          "old_api": "insert",
          "new_api": null,
          "old_text": "live.insert(block);\n        ",
          "new_text": null,
          "old_line_content": "        storesNotAlive.insert(block);",
          "new_line_content": "    changed = false;",
          "content_same": false
        },
        {
          "line": 1307,
          "old_api": "erminator",
          "new_api": null,
          "old_text": "erminator());\n  };\n\n ",
          "new_text": null,
          "old_line_content": "    return isa<UnreachableInst>(succ->getTerminator());",
          "new_line_content": "        changed = true;",
          "content_same": false
        },
        {
          "line": 1314,
          "old_api": "contains",
          "new_api": null,
          "old_text": "live.contains(eb)) {\n      ",
          "new_text": null,
          "old_line_content": "        storesNotAlive.contains(eb)) {",
          "new_line_content": "  };",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": "xitingAndLatchBlocks",
          "new_api": null,
          "old_text": "xitingAndLatchBlocks(exitingAndLatchBlocks);\n\n  // Th",
          "new_text": null,
          "old_line_content": "  loop->getExitingAndLatchBlocks(exitingAndLatchBlocks);",
          "new_line_content": "  return true;",
          "content_same": false
        },
        {
          "line": 1328,
          "old_api": "onlyDominateLoopExits",
          "new_api": null,
          "old_text": "onlyDominateLoopExits(accessPath, loop,\n                                       exitingAndLatchBlocks))\n    retu",
          "new_text": null,
          "old_line_content": "  if (!storesCommonlyDominateLoopExits(accessPath, loop,",
          "new_line_content": "hoistLoadsAndStores(AccessPath accessPath, SILLoop *loop) {",
          "content_same": false
        },
        {
          "line": 1338,
          "old_api": "getSuccessors",
          "new_api": null,
          "old_text": "atchBlock->getSuccessors()[idx])) {\n",
          "new_text": null,
          "old_line_content": "      if (!loop->contains(exitingOrLatchBlock->getSuccessors()[idx])) {",
          "new_line_content": "  // Inserting the stores requires the exit edges to be not critical.",
          "content_same": false
        },
        {
          "line": 1339,
          "old_api": "getTerminator",
          "new_api": null,
          "old_text": "atchBlock->getTerminator(), idx, Dom",
          "new_text": null,
          "old_line_content": "        splitCriticalEdge(exitingOrLatchBlock->getTerminator(), idx, DomTree,",
          "new_line_content": "  for (SILBasicBlock *exitingOrLatchBlock : exitingAndLatchBlocks) {",
          "content_same": false
        },
        {
          "line": 1346,
          "old_api": "header && \"Expected a preheader\");\n\n  // In",
          "new_api": null,
          "old_text": "header && \"Expected a preheader\");\n\n  // In",
          "new_text": null,
          "old_line_content": "  assert(preheader && \"Expected a preheader\");",
          "new_line_content": "                          LoopInfo);",
          "content_same": false
        },
        {
          "line": 1349,
          "old_api": ">getTerminator());\n  SILVa",
          "new_api": null,
          "old_text": ">getTerminator());\n  SILVa",
          "new_text": null,
          "old_line_content": "  SILBuilder B(preheader->getTerminator());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1357,
          "old_api": "ccess",
          "new_api": null,
          "old_text": "ccess(I, accessPath)) {\n      ",
          "new_text": null,
          "old_line_content": "    if (auto *SI = isStoreToAccess(I, accessPath)) {",
          "new_line_content": "  SILSSAUpdater ssaUpdater;",
          "content_same": false
        },
        {
          "line": 1358,
          "old_api": "();\n\n      /",
          "new_api": null,
          "old_text": "();\n\n      /",
          "new_text": null,
          "old_line_content": "      loc = SI->getLoc();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1367,
          "old_api": "t",
          "new_api": null,
          "old_text": "t();\n        ",
          "new_text": null,
          "old_line_content": "        storeAddr = SI->getDest();",
          "new_line_content": "      // will be removed later, so it cannot be used as available value.",
          "content_same": false
        },
        {
          "line": 1368,
          "old_api": "getObjectType",
          "new_api": null,
          "old_text": ">getType().getObjectType(),\n        ",
          "new_text": null,
          "old_line_content": "        ssaUpdater.initialize(storeAddr->getType().getObjectType(),",
          "new_line_content": "      // This corner case is surprisingly hard to handle, so we just give up.",
          "content_same": false
        },
        {
          "line": 1370,
          "old_api": ">getType()) {",
          "new_api": null,
          "old_text": ">getType()) {\n      ",
          "new_text": null,
          "old_line_content": "      } else if (SI->getDest()->getType() != storeAddr->getType()) {",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 1377,
          "old_api": "());\n    }",
          "new_api": null,
          "old_text": "());\n    }\n ",
          "new_text": null,
          "old_line_content": "      ssaUpdater.addAvailableValue(SI->getParent(), SI->getSrc());",
          "new_line_content": "        // This transformation assumes that the values of all stores in the loop",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": "reAddr && \"hoistLoadsAndStores requires a store in the loop\");\n  auto c",
          "new_api": null,
          "old_text": "reAddr && \"hoistLoadsAndStores requires a store in the loop\");\n  auto c",
          "new_text": null,
          "old_line_content": "  assert(storeAddr && \"hoistLoadsAndStores requires a store in the loop\");",
          "new_line_content": "        // same access path.",
          "content_same": false
        },
        {
          "line": 1387,
          "old_api": ";\n  };\n  S",
          "new_api": null,
          "old_text": ";\n  };\n  S",
          "new_text": null,
          "old_line_content": "    return SILValue();",
          "new_line_content": "  auto checkBase = [&](SILValue srcAddr) {",
          "content_same": false
        },
        {
          "line": 1390,
          "old_api": ">getTerminator(), checkBas",
          "new_api": null,
          "old_text": ">getTerminator(), checkBas",
          "new_text": null,
          "old_line_content": "      cloneUseDefChain(storeAddr, preheader->getTerminator(), checkBase);",
          "new_line_content": "      return srcAddr;",
          "content_same": false
        },
        {
          "line": 1397,
          "old_api": "getLoc",
          "new_api": null,
          "old_text": ">getTerminator()->getLoc(), initialA",
          "new_text": null,
          "old_line_content": "      B.createLoad(preheader->getTerminator()->getLoc(), initialAddr,",
          "new_line_content": "  // cloneUseDefChain may currently fail if a begin_borrow or mark_dependence is",
          "content_same": false
        },
        {
          "line": 1399,
          "old_api": "() << \"Creat",
          "new_api": null,
          "old_text": "() << \"Creat",
          "new_text": null,
          "old_line_content": "  LLVM_DEBUG(llvm::dbgs() << \"Creating preload \" << *initialLoad);",
          "new_line_content": "  if (!initialAddr)",
          "content_same": false
        },
        {
          "line": 1400,
          "old_api": "addAvailableValue",
          "new_api": null,
          "old_text": ".addAvailableValue(preheader, initialLoad);\n\n  // Re",
          "new_text": null,
          "old_line_content": "  ssaUpdater.addAvailableValue(preheader, initialLoad);",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 1409,
          "old_api": ";\n    }",
          "new_api": null,
          "old_text": ";\n    }\n  ",
          "new_text": null,
          "old_line_content": "      currentVal = SILValue();",
          "new_line_content": "  SILBasicBlock *currentBlock = nullptr;",
          "content_same": false
        },
        {
          "line": 1411,
          "old_api": "ccess",
          "new_api": null,
          "old_text": "ccess(I, accessPath)) {\n      ",
          "new_text": null,
          "old_line_content": "    if (auto *SI = isStoreToAccess(I, accessPath)) {",
          "new_line_content": "  for (SILInstruction *I : LoadsAndStores) {",
          "content_same": false
        },
        {
          "line": 1413,
          "old_api": "();\n      to",
          "new_api": null,
          "old_text": "();\n      to",
          "new_text": null,
          "old_line_content": "      currentVal = SI->getSrc();",
          "new_line_content": "    if (block != currentBlock) {",
          "content_same": false
        },
        {
          "line": 1414,
          "old_api": "nsert",
          "new_api": null,
          "old_text": "nsert(SI);\n      co",
          "new_text": null,
          "old_line_content": "      toDelete.insert(SI);",
          "new_line_content": "      currentBlock = block;",
          "content_same": false
        },
        {
          "line": 1424,
          "old_api": "getValueInMiddleOfBlock",
          "new_api": null,
          "old_text": ".getValueInMiddleOfBlock(block);\n\n    Loa",
          "new_text": null,
          "old_line_content": "      currentVal = ssaUpdater.getValueInMiddleOfBlock(block);",
          "new_line_content": "    if (!loadWithAccess) {",
          "content_same": false
        },
        {
          "line": 1427,
          "old_api": "perand",
          "new_api": null,
          "old_text": "perand();\n    SILV",
          "new_text": null,
          "old_line_content": "    auto loadAddress = load->getOperand();",
          "new_line_content": "    // If we didn't see a store in this block yet, get the current value from",
          "content_same": false
        },
        {
          "line": 1428,
          "old_api": "dValue",
          "new_api": null,
          "old_text": "dValue(\n        loadAddress, loadWithAccess.accessPath, currentVal, accessPath, load);\n    LLVM",
          "new_text": null,
          "old_line_content": "    SILValue projectedValue = projectLoadValue(",
          "new_line_content": "    // the ssaUpdater.",
          "content_same": false
        },
        {
          "line": 1432,
          "old_api": "aceAllUsesWith",
          "new_api": null,
          "old_text": "aceAllUsesWith(projectedValue);\n    toDe",
          "new_text": null,
          "old_line_content": "    load->replaceAllUsesWith(projectedValue);",
          "new_line_content": "    LoadInst *load = loadWithAccess.li;",
          "content_same": false
        },
        {
          "line": 1442,
          "old_api": "inglePredecessorBlock",
          "new_api": null,
          "old_text": "inglePredecessorBlock()\n         ",
          "new_text": null,
          "old_line_content": "      assert(succ->getSinglePredecessorBlock()",
          "new_line_content": "  // Store back the value at all loop exits.",
          "content_same": false
        },
        {
          "line": 1446,
          "old_api": "getValueInMiddleOfBlock",
          "new_api": null,
          "old_text": ".getValueInMiddleOfBlock(succ), initialA",
          "new_text": null,
          "old_line_content": "          loc.value(), ssaUpdater.getValueInMiddleOfBlock(succ), initialAddr,",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 1449,
          "old_api": "() << \"Creat",
          "new_api": null,
          "old_text": "() << \"Creat",
          "new_text": null,
          "old_line_content": "      LLVM_DEBUG(llvm::dbgs() << \"Creating loop-exit store \" << *SI);",
          "new_line_content": "             && \"should have split critical edges\");",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": "sert",
          "new_api": null,
          "old_text": "sert(AI);\n    }\n  ",
          "new_text": null,
          "old_line_content": "      HoistUp.insert(AI);",
          "new_line_content": "    for (auto *AI : ReadOnlyApplies) {",
          "content_same": false
        },
        {
          "line": 1454,
          "old_api": "eadInstruction",
          "new_api": null,
          "old_text": "eadInstruction(initialLoad);\n}\n\nbool ",
          "new_text": null,
          "old_line_content": "  eliminateDeadInstruction(initialLoad);",
          "new_line_content": "      (void)SI;",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": "(AA, sideEffects, LI)) {",
          "new_api": null,
          "old_text": "(AA, sideEffects, LI)) {\n      ",
          "new_text": null,
          "old_line_content": "    if (!mayWriteTo(AA, sideEffects, LI)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": "sert",
          "new_api": null,
          "old_text": "sert(LI);\n    }\n  ",
          "new_text": null,
          "old_line_content": "      HoistUp.insert(LI);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1459,
          "old_api": "AndStores",
          "new_api": null,
          "old_text": "AndStores(accessPath, loop);\n  }\n  Lo",
          "new_text": null,
          "old_line_content": "    hoistLoadsAndStores(accessPath, loop);",
          "new_line_content": "  // In case the value is only stored but never loaded in the loop.",
          "content_same": false
        },
        {
          "line": 1461,
          "old_api": "clear",
          "new_api": null,
          "old_text": "ores.clear();\n  LoadAn",
          "new_text": null,
          "old_line_content": "  LoadsAndStores.clear();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1462,
          "old_api": "clear",
          "new_api": null,
          "old_text": "reAddrs.clear();\n\n  if (t",
          "new_text": null,
          "old_line_content": "  LoadAndStoreAddrs.clear();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1464,
          "old_api": "mpty",
          "new_api": null,
          "old_text": "mpty())\n    retu",
          "new_text": null,
          "old_line_content": "  if (toDelete.empty())",
          "new_line_content": "  for (AccessPath accessPath : LoadAndStoreAddrs) {",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": ">getParent());\n    }",
          "new_api": null,
          "old_text": ">getParent());\n    }\n ",
          "new_text": null,
          "old_line_content": "      postDomTree = PDA->get(Preheader->getParent());",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": "getRootNode",
          "new_api": null,
          "old_text": "e->getRootNode()) {\n      ",
          "new_text": null,
          "old_line_content": "    if (postDomTree->getRootNode()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": "t",
          "new_api": null,
          "old_text": "t());\n    aut",
          "new_text": null,
          "old_line_content": "    auto access = AccessPathWithBase::compute(SI->getDest());",
          "new_line_content": "  //",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": "isValid",
          "new_api": null,
          "old_text": ".isValid() &&\n      ",
          "new_text": null,
          "old_line_content": "    if (accessPath.isValid() &&",
          "new_line_content": "  for (StoreInst *SI : Stores) {",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "riant",
          "new_api": null,
          "old_text": "riant(access.base, Loop))) {\n     ",
          "new_text": null,
          "old_line_content": "        (access.base && isLoopInvariant(access.base, Loop))) {",
          "new_line_content": "    // Use AccessPathWithBase to recover a base address that can be used for",
          "content_same": false
        },
        {
          "line": 979,
          "old_api": "t",
          "new_api": null,
          "old_text": "t(),\n        ",
          "new_text": null,
          "old_line_content": "      if (isOnlyLoadedAndStored(AA, sideEffects, Loads, Stores, SI->getDest(),",
          "new_line_content": "    // newly inserted memory operations. If we instead teach hoistLoadsAndStores",
          "content_same": false
        },
        {
          "line": 1492,
          "old_api": "n",
          "new_api": null,
          "old_text": "n();\n\n    // ",
          "new_text": null,
          "old_line_content": "    SILFunction *F = getFunction();",
          "new_line_content": "  /// inlined yet. In this case some semantic calls can be hoisted.",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": "t",
          "new_api": null,
          "old_text": "t())) {\n     ",
          "new_text": null,
          "old_line_content": "          if (splitLoads(Loads, accessPath, SI->getDest())) {",
          "new_line_content": "    auto accessPath = access.accessPath;",
          "content_same": false
        },
        {
          "line": 1495,
          "old_api": "rship",
          "new_api": null,
          "old_text": "rship())\n      re",
          "new_text": null,
          "old_line_content": "    if (F->hasOwnership())",
          "new_line_content": "  bool RunsOnHighLevelSil;",
          "content_same": false
        },
        {
          "line": 1499,
          "old_api": ";\n\n    if",
          "new_api": null,
          "old_text": ";\n\n    if ",
          "new_text": null,
          "old_line_content": "    SILLoopInfo *LoopInfo = LA->get(F);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1502,
          "old_api": "() << \"\\n\");",
          "new_api": null,
          "old_text": "() << \"\\n\");",
          "new_text": null,
          "old_line_content": "      LLVM_DEBUG(llvm::dbgs() << \"No loops in \" << F->getName() << \"\\n\");",
          "new_line_content": "      return;",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": "end",
          "new_api": null,
          "old_text": "s.end(),\n        ",
          "new_text": null,
          "old_line_content": "        std::any_of(sideEffects.begin(), sideEffects.end(),",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": "ase",
          "new_api": null,
          "old_text": "ase(); });\n    ",
          "new_text": null,
          "old_line_content": "                    [&](SILInstruction *W) { return W->mayRelease(); });",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": "(AA, sideEffects, FL)) {",
          "new_api": null,
          "old_text": "(AA, sideEffects, FL)) {\n      ",
          "new_text": null,
          "old_line_content": "      if (!sideEffectsMayRelease || !mayWriteTo(AA, sideEffects, FL)) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1506,
          "old_api": "lysis<DominanceAnalysis>();\n    Post",
          "new_api": null,
          "old_text": "lysis<DominanceAnalysis>();\n    Post",
          "new_text": null,
          "old_line_content": "    DominanceAnalysis *DA = PM->getAnalysis<DominanceAnalysis>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1509,
          "old_api": "lysis<BasicCalleeAnalysis>();\n    Acce",
          "new_api": null,
          "old_text": "lysis<BasicCalleeAnalysis>();\n    Acce",
          "new_text": null,
          "old_line_content": "    BasicCalleeAnalysis *BCA = PM->getAnalysis<BasicCalleeAnalysis>();",
          "new_line_content": "      return;",
          "content_same": false
        },
        {
          "line": 1510,
          "old_api": "s<AccessStorageAnalysis>();\n    Domi",
          "new_api": null,
          "old_text": "s<AccessStorageAnalysis>();\n    Domi",
          "new_text": null,
          "old_line_content": "    AccessStorageAnalysis *ASA = getAnalysis<AccessStorageAnalysis>();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1002,
          "old_api": "() << \"Some",
          "new_api": null,
          "old_text": "() << \"Some ",
          "new_text": null,
          "old_line_content": "      LLVM_DEBUG(llvm::dbgs() << \"Some end accesses can't be handled\\n\");",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": "inAccess",
          "new_api": null,
          "old_text": "inAccess(BI, BeginAccesses, fullApplies, sideEffects, ASA,\n                           DomTree)) {\n      ",
          "new_text": null,
          "old_line_content": "    if (analyzeBeginAccess(BI, BeginAccesses, fullApplies, sideEffects, ASA,",
          "new_line_content": "  for (auto *BI : BeginAccesses) {",
          "content_same": false
        },
        {
          "line": 1517,
          "old_api": ";\n      Lo",
          "new_api": null,
          "old_text": ";\n      Lo",
          "new_text": null,
          "old_line_content": "      if (!DomTree) DomTree = DA->get(F);",
          "new_line_content": "    DominanceInfo *DomTree = nullptr;",
          "content_same": false
        },
        {
          "line": 1520,
          "old_api": "ze",
          "new_api": null,
          "old_text": "ze();\n    }\n\n ",
          "new_text": null,
          "old_line_content": "      Changed |= Opt.optimize();",
          "new_line_content": "    bool Changed = false;",
          "content_same": false
        },
        {
          "line": 1524,
          "old_api": "validation",
          "new_api": null,
          "old_text": "validation();\n      DA",
          "new_text": null,
          "old_line_content": "      LA->lockInvalidation();",
          "new_line_content": "      LoopTreeOptimization Opt(TopLevelLoop, LoopInfo, AA, BCA, DomTree, PDA,",
          "content_same": false
        },
        {
          "line": 1525,
          "old_api": "validation",
          "new_api": null,
          "old_text": "validation();\n      PM",
          "new_text": null,
          "old_line_content": "      DA->lockInvalidation();",
          "new_line_content": "                               ASA, RunsOnHighLevelSil);",
          "content_same": false
        },
        {
          "line": 1527,
          "old_api": "Invalidation",
          "new_api": null,
          "old_text": "Invalidation();\n      DA",
          "new_text": null,
          "old_line_content": "      LA->unlockInvalidation();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1528,
          "old_api": "Invalidation",
          "new_api": null,
          "old_text": "Invalidation();\n    }\n  ",
          "new_text": null,
          "old_line_content": "      DA->unlockInvalidation();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1022,
          "old_api": "ElementAddrInst>(innerAddress)\n      &&",
          "new_api": null,
          "old_text": "ElementAddrInst>(innerAddress)\n      && ",
          "new_text": null,
          "old_line_content": "  if (!isa<StructElementAddrInst>(innerAddress)",
          "new_line_content": "computeInnerAccessPath(AccessPath::PathNode outerPath,",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": "lementAddrInst>(innerAddress)) {\n    re",
          "new_api": null,
          "old_text": "lementAddrInst>(innerAddress)) {\n    re",
          "new_text": null,
          "old_line_content": "      && !isa<TupleElementAddrInst>(innerAddress)) {",
          "new_line_content": "                       AccessPath::PathNode innerPath, SILValue innerAddress,",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 73,
      "total_additions": 125,
      "total_deletions": 123,
      "total_api_changes": 321
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 14,
        "api_related_lines": 321,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          945,
          948,
          940,
          950
        ]
      }
    },
    "api_calls_before": 553,
    "api_calls_after": 557,
    "diff_info": {
      "added_lines": 12,
      "removed_lines": 6,
      "total_diff_lines": 32
    }
  }
}