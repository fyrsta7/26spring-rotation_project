{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/2a8a6b04d851e7c7d1df53bc415b7c41501233ac",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/2a8a6b04d851e7c7d1df53bc415b7c41501233ac/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/2a8a6b04d851e7c7d1df53bc415b7c41501233ac/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/2a8a6b04d851e7c7d1df53bc415b7c41501233ac/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 157,
          "old_api": "CreateCondBr",
          "new_api": "Condition",
          "old_text": "Builder.CreateCondBr(V, trueBB, falseDestBB)",
          "new_text": "Condition(trueBB, falseBB, contBB)",
          "old_line_content": "    Builder.CreateCondBr(V, trueBB, falseDestBB);",
          "new_line_content": "  return Condition(trueBB, falseBB, contBB);",
          "content_same": false
        },
        {
          "line": 187,
          "old_api": "hasValidIP",
          "new_api": "use_empty",
          "old_text": "IGF.Builder.hasValidIP()",
          "new_text": "ContBB->use_empty()",
          "old_line_content": "  if (!IGF.Builder.hasValidIP()) {",
          "new_line_content": "    assert(ContBB->use_empty() || !FalseBB);",
          "content_same": false
        },
        {
          "line": 238,
          "old_api": "hasValidIP",
          "new_api": "isUnconditional",
          "old_text": "IGF.Builder.hasValidIP()",
          "new_text": "Br->isUnconditional()",
          "old_line_content": "  } else if (!IGF.Builder.hasValidIP()) {",
          "new_line_content": "    assert(Br->isUnconditional());",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": "use_begin",
          "new_api": "getParent",
          "old_text": "ContBB->use_begin()",
          "new_text": "Br->getParent()",
          "old_line_content": "    llvm::BranchInst *Br = cast<llvm::BranchInst>(*ContBB->use_begin());",
          "new_line_content": "    IGF.Builder.SetInsertPoint(Br->getParent());",
          "content_same": false
        },
        {
          "line": 241,
          "old_api": "isUnconditional",
          "new_api": "eraseFromParent",
          "old_text": "Br->isUnconditional()",
          "new_text": "Br->eraseFromParent()",
          "old_line_content": "    assert(Br->isUnconditional());",
          "new_line_content": "    Br->eraseFromParent();",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": "hasPostTerminatorIP",
          "new_api": "emitBlockAnywhere",
          "old_text": "IGF.Builder.hasPostTerminatorIP()",
          "new_text": "IGF.Builder.emitBlockAnywhere(ContBB)",
          "old_line_content": "  assert(IGF.Builder.hasPostTerminatorIP() ||",
          "new_line_content": "  IGF.Builder.emitBlockAnywhere(ContBB);",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": "CleanupControl::forFlag(\n               reinterpret_cast<llvm::AllocaInst*>(ControlBegin))",
          "new_api": "CleanupControl::forIPRange(\n               IRBuilder::StableIP::getFromOpaqueValue(ControlBegin),\n               IRBuilder::StableIP::getFromOpaqueValue(ControlEnd))",
          "old_text": "CleanupControl::forFlag(\n               reinterpret_cast<llvm::AllocaInst*>(ControlBegin))",
          "new_text": "CleanupControl::forIPRange(\n               IRBuilder::StableIP::getFromOpaqueValue(ControlBegin),\n               IRBuilder::StableIP::getFromOpaqueValue(ControlEnd))",
          "old_line_content": "    return CleanupControl::forFlag(",
          "new_line_content": "  return CleanupControl::forIPRange(",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": "reinterpret_cast<llvm::AllocaInst*>(ControlBegin)",
          "new_api": "IRBuilder::StableIP::getFromOpaqueValue(ControlBegin)",
          "old_text": "reinterpret_cast<llvm::AllocaInst*>(ControlBegin)",
          "new_text": "IRBuilder::StableIP::getFromOpaqueValue(ControlBegin)",
          "old_line_content": "               reinterpret_cast<llvm::AllocaInst*>(ControlBegin));",
          "new_line_content": "               IRBuilder::StableIP::getFromOpaqueValue(ControlBegin),",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": "getFlag",
          "new_api": "getIPBegin",
          "old_text": "control.getFlag()",
          "new_text": "control.getIPBegin().getOpaqueValue()",
          "old_line_content": "    ControlBegin = control.getFlag();",
          "new_line_content": "    ControlBegin = control.getIPBegin().getOpaqueValue();",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": "getControl",
          "new_api": "isActive",
          "old_text": "cleanup.getControl()",
          "new_text": "cleanup.isActive()",
          "old_line_content": "  CleanupControl control = cleanup.getControl();",
          "new_line_content": "  bool isActiveNow = cleanup.isActive();",
          "content_same": false
        },
        {
          "line": 461,
          "old_api": "isActive",
          "new_api": "getIPBegin",
          "old_text": "cleanup.isActive()",
          "new_text": "control.getIPBegin()",
          "old_line_content": "  bool isActiveNow = cleanup.isActive();",
          "new_line_content": "  setFlagThen(IGF, control.getIPBegin(), flag, isActiveNow);",
          "content_same": false
        },
        {
          "line": 463,
          "old_api": "createControlFlag",
          "new_api": "hasValidIP",
          "old_text": "createControlFlag(IGF, cleanup)",
          "new_text": "IGF.Builder.hasValidIP()",
          "old_line_content": "  llvm::AllocaInst *flag = createControlFlag(IGF, cleanup);",
          "new_line_content": "  if (IGF.Builder.hasValidIP())",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": "getIPBegin",
          "new_api": "setFlagNow",
          "old_text": "control.getIPBegin()",
          "new_text": "setFlagNow(IGF, flag, isActiveNow)",
          "old_line_content": "  setFlagThen(IGF, control.getIPBegin(), flag, isActiveNow);",
          "new_line_content": "    setFlagNow(IGF, flag, isActiveNow);",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": "reinterpret_cast<const void*>(&cleanup)",
          "new_api": "data",
          "old_text": "reinterpret_cast<const void*>(&cleanup)",
          "new_text": "Data.data()",
          "old_line_content": "      memcpy(Data.data(), reinterpret_cast<const void*>(&cleanup), size);",
          "new_line_content": "    Cleanup &getCopy() { return *reinterpret_cast<Cleanup*>(Data.data()); }",
          "content_same": false
        },
        {
          "line": 490,
          "old_api": "getNormalEntryBlock",
          "new_api": "createBasicBlock",
          "old_text": "cleanup.getNormalEntryBlock()",
          "new_text": "IGF.createBasicBlock(\"cleanup\")",
          "old_line_content": "  llvm::BasicBlock *block = cleanup.getNormalEntryBlock();",
          "new_line_content": "  block = IGF.createBasicBlock(\"cleanup\");",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": "isUsedWhileActive",
          "new_api": "getOutflows",
          "old_text": "cleanup.isUsedWhileActive()",
          "new_text": "cleanup.getOutflows()",
          "old_line_content": "    if (cleanup.isUsedWhileActive())",
          "new_line_content": "    assert(!cleanup.getOutflows());",
          "content_same": false
        },
        {
          "line": 535,
          "old_api": "getControl",
          "new_api": "createBasicBlock",
          "old_text": "cleanup.getControl()",
          "new_text": "IGF.createBasicBlock(\"cleanup.cont\")",
          "old_line_content": "  CleanupControl control = cleanup.getControl();",
          "new_line_content": "    contBB = IGF.createBasicBlock(\"cleanup.cont\");",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": "hasValidIP",
          "new_api": "CreateBr",
          "old_text": "IGF.Builder.hasValidIP()",
          "new_text": "IGF.Builder.CreateBr(contBB)",
          "old_line_content": "  assert(IGF.Builder.hasValidIP());",
          "new_line_content": "    IGF.Builder.CreateBr(contBB);",
          "content_same": false
        },
        {
          "line": 563,
          "old_api": "begin",
          "new_api": "isUsedWhileActive",
          "old_text": "stack.begin()",
          "new_text": "stackCleanup.isUsedWhileActive()",
          "old_line_content": "  Cleanup &stackCleanup = *stack.begin();",
          "new_line_content": "  if (!stackCleanup.isUsedWhileActive()) {",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": "getNormalEntryBlock",
          "new_api": "getOutflows",
          "old_text": "stackCleanup.getNormalEntryBlock()",
          "new_text": "stackCleanup.getOutflows()",
          "old_line_content": "    assert(stackCleanup.getNormalEntryBlock() == nullptr);",
          "new_line_content": "    assert(stackCleanup.getOutflows() == nullptr);",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": "getCopy",
          "new_api": "pop",
          "old_text": "buffer.getCopy()",
          "new_text": "stack.pop()",
          "old_line_content": "  Cleanup &cleanup = buffer.getCopy();",
          "new_line_content": "  stack.pop();",
          "content_same": false
        },
        {
          "line": 602,
          "old_api": "hasOneUse",
          "new_api": "dyn_cast<llvm::BranchInst>(term)",
          "old_text": "entry->hasOneUse()",
          "new_text": "dyn_cast<llvm::BranchInst>(term)",
          "old_line_content": "  if (entry->hasOneUse()) {",
          "new_line_content": "    llvm::BranchInst *br = dyn_cast<llvm::BranchInst>(term);",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": "use_begin",
          "new_api": "getParent",
          "old_text": "entry->use_begin()",
          "new_text": "br->getParent()",
          "old_line_content": "      cast<llvm::TerminatorInst>(*entry->use_begin());",
          "new_line_content": "      trueEntry = br->getParent();",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": "dyn_cast<llvm::BranchInst>(term)",
          "new_api": "eraseFromParent",
          "old_text": "dyn_cast<llvm::BranchInst>(term)",
          "new_text": "br->eraseFromParent()",
          "old_line_content": "    llvm::BranchInst *br = dyn_cast<llvm::BranchInst>(term);",
          "new_line_content": "      br->eraseFromParent();",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": "emitCleanupHere",
          "new_api": "getOutflows",
          "old_text": "emitCleanupHere(IGF, cleanup)",
          "new_text": "cleanup.getOutflows()",
          "old_line_content": "  emitCleanupHere(IGF, cleanup);",
          "new_line_content": "  CleanupOutflows *outflows = cleanup.getOutflows();",
          "content_same": false
        },
        {
          "line": 640,
          "old_api": "hasFallthroughOutflow",
          "new_api": "getOrCreateNextNormalEntryBlock",
          "old_text": "cleanup.hasFallthroughOutflow()",
          "new_text": "getOrCreateNextNormalEntryBlock(IGF, stack)",
          "old_line_content": "    assert(cleanup.hasFallthroughOutflow());",
          "new_line_content": "    llvm::BasicBlock *next = getOrCreateNextNormalEntryBlock(IGF, stack);",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": "hasFallthroughOutflow",
          "new_api": "getUnreachableBlock",
          "old_text": "cleanup.hasFallthroughOutflow()",
          "new_text": "IGF.getUnreachableBlock()",
          "old_line_content": "  if (cleanup.hasFallthroughOutflow())",
          "new_line_content": "    defaultDest = IGF.getUnreachableBlock();",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": "checkIterator",
          "new_api": "empty",
          "old_text": "stack.checkIterator(end)",
          "new_text": "stack.empty()",
          "old_line_content": "  stack.checkIterator(end);",
          "new_line_content": "    assert(!stack.empty());",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": "empty",
          "new_api": "popAndEmitTopCleanup",
          "old_text": "stack.empty()",
          "new_text": "popAndEmitTopCleanup(IGF, stack)",
          "old_line_content": "    assert(!stack.empty());",
          "new_line_content": "    popAndEmitTopCleanup(IGF, stack);",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": "checkIterator",
          "new_api": "stable_begin",
          "old_text": "Cleanups.checkIterator(depth)",
          "new_text": "Cleanups.stable_begin()",
          "old_line_content": "  Cleanups.checkIterator(depth);",
          "new_line_content": "  if (Cleanups.stable_begin() == depth) {",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": "hasValidIP",
          "new_api": "JumpDest",
          "old_text": "Builder.hasValidIP()",
          "new_text": "JumpDest(contBB, depth)",
          "old_line_content": "  if (Builder.hasValidIP() &&",
          "new_line_content": "    emitBranch(JumpDest(contBB, depth));",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "stable_begin",
          "new_api": "begin",
          "old_text": "Cleanups.stable_begin()",
          "new_text": "Cleanups.begin()",
          "old_line_content": "  while (Cleanups.stable_begin() != depth) {",
          "new_line_content": "      setCleanupState(*Cleanups.begin(), CleanupState::Dead);",
          "content_same": false
        },
        {
          "line": 727,
          "old_api": "begin",
          "new_api": "popAndEmitTopCleanup",
          "old_text": "Cleanups.begin()",
          "new_text": "popAndEmitTopCleanup(*this, Cleanups)",
          "old_line_content": "      setCleanupState(*Cleanups.begin(), CleanupState::Dead);",
          "new_line_content": "    popAndEmitTopCleanup(*this, Cleanups);",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": "checkIterator",
          "new_api": "begin",
          "old_text": "Cleanups.checkIterator(InnermostScope)",
          "new_text": "Cleanups.begin()",
          "old_line_content": "  Cleanups.checkIterator(InnermostScope);",
          "new_line_content": "  endScope(Cleanups.stabilize(llvm::next(Cleanups.begin())));",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": "end",
          "new_api": "begin",
          "old_text": "Cleanups.end()",
          "new_text": "Cleanups.begin()",
          "old_line_content": "  assert(iter != Cleanups.end() && \"changing state of end of stack\");",
          "new_line_content": "  if (newState == CleanupState::Dead && iter == Cleanups.begin())",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": "setCleanupState",
          "new_api": "popAndEmitTopDeadCleanups",
          "old_text": "setCleanupState(*iter, newState)",
          "new_text": "popAndEmitTopDeadCleanups(*this, Cleanups, InnermostScope)",
          "old_line_content": "  setCleanupState(*iter, newState);",
          "new_line_content": "    popAndEmitTopDeadCleanups(*this, Cleanups, InnermostScope);",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": "getState",
          "new_api": "assert",
          "old_text": "cleanup.getState()",
          "new_text": "assert(newState != oldState && \"cleanup state is already active\")",
          "old_line_content": "  CleanupState oldState = cleanup.getState();",
          "new_line_content": "  assert(newState != oldState && \"cleanup state is already active\");",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": "assert",
          "new_api": "llvm_unreachable",
          "old_text": "assert(newState != oldState && \"cleanup state is already active\")",
          "new_text": "llvm_unreachable(\"changing state of dead cleanup\")",
          "old_line_content": "  assert(newState != oldState && \"cleanup state is already active\");",
          "new_line_content": "    llvm_unreachable(\"changing state of dead cleanup\");",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": "getControl",
          "new_api": "hasFlag",
          "old_text": "cleanup.getControl()",
          "new_text": "control.hasFlag()",
          "old_line_content": "      CleanupControl control = cleanup.getControl();",
          "new_line_content": "      if (control.hasFlag()) {",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": "getControl",
          "new_api": "hasFlag",
          "old_text": "cleanup.getControl()",
          "new_text": "control.hasFlag()",
          "old_line_content": "    CleanupControl control = cleanup.getControl();",
          "new_line_content": "    if (control.hasFlag()) {",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": "hasFlag",
          "new_api": "getFlag",
          "old_text": "control.hasFlag()",
          "new_text": "control.getFlag()",
          "old_line_content": "    if (control.hasFlag()) {",
          "new_line_content": "        setFlagNow(*this, control.getFlag(), false);",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": "getDepth",
          "new_api": "begin",
          "old_text": "dest.getDepth()",
          "new_text": "Cleanups.begin()",
          "old_line_content": "  auto depth = Cleanups.find(dest.getDepth());",
          "new_line_content": "  auto it = Cleanups.begin();",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": "getOrCreateOutflows",
          "new_api": "getBlock",
          "old_text": "getOrCreateOutflows(*outermost)",
          "new_text": "dest.getBlock()",
          "old_line_content": "  CleanupOutflows *outs = getOrCreateOutflows(*outermost);",
          "new_line_content": "  outs->add(labelValue, dest.getBlock());",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": "getBlock",
          "new_api": "addActiveUse",
          "old_text": "dest.getBlock()",
          "new_text": "outermost->addActiveUse()",
          "old_line_content": "  outs->add(labelValue, dest.getBlock());",
          "new_line_content": "  outermost->addActiveUse();",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": "setNextDestLabel",
          "new_api": "getJumpDestAlignment",
          "old_text": "outermost->setNextDestLabel(destLabel + 1)",
          "new_text": "getJumpDestAlignment()",
          "old_line_content": "  outermost->setNextDestLabel(destLabel + 1);",
          "new_line_content": "  Builder.CreateStore(labelValue, getJumpDestSlot(), getJumpDestAlignment());",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": "addFallthroughOutflow",
          "new_api": "setNextDestLabel",
          "old_text": "it->addFallthroughOutflow()",
          "new_text": "it->setNextDestLabel(destLabel + 1)",
          "old_line_content": "    it->addFallthroughOutflow();",
          "new_line_content": "    it->setNextDestLabel(destLabel + 1);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 513,
          "old_api": null,
          "new_api": "llvm_unreachable",
          "old_text": null,
          "new_text": "llvm_unreachable(\"ran out of cleanups looking for outflows!\")",
          "old_line_content": "",
          "new_line_content": "  llvm_unreachable(\"ran out of cleanups looking for outflows!\");",
          "content_same": false
        },
        {
          "line": 523,
          "old_api": null,
          "new_api": "getNextCleanupForFallthrough",
          "old_text": null,
          "new_text": "getNextCleanupForFallthrough(stack)",
          "old_line_content": "static llvm::BasicBlock *",
          "new_line_content": "  return getOrCreateNormalEntryBlock(IGF, getNextCleanupForFallthrough(stack));",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": null,
          "new_api": "hasValidIP",
          "old_text": null,
          "new_text": "IGF.Builder.hasValidIP()",
          "old_line_content": "",
          "new_line_content": "  assert(IGF.Builder.hasValidIP());",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": null,
          "new_api": "getControl",
          "old_text": null,
          "new_text": "cleanup.getControl()",
          "old_line_content": "",
          "new_line_content": "  CleanupControl control = cleanup.getControl();",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": null,
          "new_api": "hasFlag",
          "old_text": null,
          "new_text": "control.hasFlag()",
          "old_line_content": "  // to handle that here.",
          "new_line_content": "  if (control.hasFlag()) {",
          "content_same": false
        },
        {
          "line": 536,
          "old_api": null,
          "new_api": "createBasicBlock",
          "old_text": null,
          "new_text": "IGF.createBasicBlock(\"cleanup.body\")",
          "old_line_content": "  llvm::BasicBlock *contBB = nullptr;",
          "new_line_content": "    llvm::BasicBlock *bodyBB = IGF.createBasicBlock(\"cleanup.body\");",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": null,
          "new_api": "Alignment",
          "old_text": null,
          "new_text": "Alignment(1)",
          "old_line_content": "",
          "new_line_content": "      IGF.Builder.CreateLoad(control.getFlag(), Alignment(1));",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": null,
          "new_api": "CreateCondBr",
          "old_text": null,
          "new_text": "IGF.Builder.CreateCondBr(flagValue, bodyBB, contBB)",
          "old_line_content": "    // Branch on the control flag.",
          "new_line_content": "    IGF.Builder.CreateCondBr(flagValue, bodyBB, contBB);",
          "content_same": false
        },
        {
          "line": 542,
          "old_api": null,
          "new_api": "emitBlock",
          "old_text": null,
          "new_text": "IGF.Builder.emitBlock(bodyBB)",
          "old_line_content": "    llvm::Value *flagValue =",
          "new_line_content": "    IGF.Builder.emitBlock(bodyBB);",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": null,
          "new_api": "emit",
          "old_text": null,
          "new_text": "cleanup.emit(IGF)",
          "old_line_content": "  }",
          "new_line_content": "  cleanup.emit(IGF);",
          "content_same": false
        },
        {
          "line": 548,
          "old_api": null,
          "new_api": "hasValidIP",
          "old_text": null,
          "new_text": "IGF.Builder.hasValidIP()",
          "old_line_content": "  // Emit the cleanup body.",
          "new_line_content": "  assert(IGF.Builder.hasValidIP());",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": null,
          "new_api": "emitBlock",
          "old_text": null,
          "new_text": "IGF.Builder.emitBlock(contBB)",
          "old_line_content": "",
          "new_line_content": "    IGF.Builder.emitBlock(contBB);",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "stack.begin()",
          "old_line_content": "/// emission or forwarding necessary.",
          "new_line_content": "  Cleanup &stackCleanup = *stack.begin();",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": null,
          "new_api": "isDead",
          "old_text": null,
          "new_text": "stackCleanup.isDead()",
          "old_line_content": "static void popAndEmitTopCleanup(IRGenFunction &IGF,",
          "new_line_content": "  assert(stackCleanup.isDead() && \"popping a living cleanup\");",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": null,
          "new_api": "getNormalEntryBlock",
          "old_text": null,
          "new_text": "stackCleanup.getNormalEntryBlock()",
          "old_line_content": "    // emitBranch never directly branches to a cleanup that's currently",
          "new_line_content": "    assert(stackCleanup.getNormalEntryBlock() == nullptr);",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": null,
          "new_api": "getControl",
          "old_text": null,
          "new_text": "stackCleanup.getControl().hasFlag()",
          "old_line_content": "",
          "new_line_content": "    assert(!stackCleanup.getControl().hasFlag());",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": null,
          "new_api": "pop",
          "old_text": null,
          "new_text": "stack.pop()",
          "old_line_content": "",
          "new_line_content": "    stack.pop();",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": null,
          "new_api": "getCopy",
          "old_text": null,
          "new_text": "buffer.getCopy()",
          "old_line_content": "",
          "new_line_content": "  Cleanup &cleanup = buffer.getCopy();",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": null,
          "new_api": "getNormalEntryBlock",
          "old_text": null,
          "new_text": "cleanup.getNormalEntryBlock()",
          "old_line_content": "",
          "new_line_content": "  llvm::BasicBlock *entry = cleanup.getNormalEntryBlock();",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(entry && \"no entry block for referenced top cleanup\")",
          "old_line_content": "  // We must have an entry block.",
          "new_line_content": "  assert(entry && \"no entry block for referenced top cleanup\");",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": null,
          "new_api": "use_empty",
          "old_text": null,
          "new_text": "entry->use_empty()",
          "old_line_content": "  // TODO: avoid creating these in obvious cases.",
          "new_line_content": "  assert(!entry->use_empty() && \"unused entry block\");",
          "content_same": false
        },
        {
          "line": 599,
          "old_api": null,
          "new_api": "hasOneUse",
          "old_text": null,
          "new_text": "entry->hasOneUse()",
          "old_line_content": "",
          "new_line_content": "  if (entry->hasOneUse()) {",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": null,
          "new_api": "use_begin",
          "old_text": null,
          "new_text": "entry->use_begin()",
          "old_line_content": "  // unconditional branch, then merge this into its predecessor.",
          "new_line_content": "      cast<llvm::TerminatorInst>(*entry->use_begin());",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": null,
          "new_api": "isUnconditional",
          "old_text": null,
          "new_text": "br->isUnconditional()",
          "old_line_content": "    llvm::TerminatorInst *term =",
          "new_line_content": "    if (br && br->isUnconditional()) {",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": null,
          "new_api": "insertAfter",
          "old_text": null,
          "new_text": "entry->getParent()->getBasicBlockList()\n                         .insertAfter(term->getParent(), entry)",
          "old_line_content": "    // edge of a switch-out.",
          "new_line_content": "      entry->getParent()->getBasicBlockList()",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": null,
          "new_api": "getParent",
          "old_text": null,
          "new_text": "term->getParent()",
          "old_line_content": "    } else {",
          "new_line_content": "                         .insertAfter(term->getParent(), entry);",
          "content_same": false
        },
        {
          "line": 621,
          "old_api": null,
          "new_api": "insertBlockAnywhere",
          "old_text": null,
          "new_text": "IGF.Builder.insertBlockAnywhere(trueEntry)",
          "old_line_content": "  // Don't enter it yet, though.",
          "new_line_content": "    IGF.Builder.insertBlockAnywhere(trueEntry);",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": null,
          "new_api": "emitCleanupHere",
          "old_text": null,
          "new_text": "emitCleanupHere(IGF, cleanup)",
          "old_line_content": "  IRBuilder::ShiftIP shiftedIP(IGF.Builder, trueEntry);",
          "new_line_content": "  emitCleanupHere(IGF, cleanup);",
          "content_same": false
        },
        {
          "line": 637,
          "old_api": null,
          "new_api": "hasFallthroughOutflow",
          "old_text": null,
          "new_text": "cleanup.hasFallthroughOutflow()",
          "old_line_content": "  if (!outflows) {",
          "new_line_content": "    assert(cleanup.hasFallthroughOutflow());",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": null,
          "new_api": "CreateBr",
          "old_text": null,
          "new_text": "IGF.Builder.CreateBr(next)",
          "old_line_content": "",
          "new_line_content": "    IGF.Builder.CreateBr(next);",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "outflows->Outflows.empty()",
          "old_line_content": "    return;",
          "new_line_content": "  assert(!outflows->Outflows.empty());",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "outflows->Outflows.size()",
          "old_line_content": "",
          "new_line_content": "  if (!cleanup.hasFallthroughOutflow() && outflows->Outflows.size() == 1) {",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": null,
          "new_api": "CreateBr",
          "old_text": null,
          "new_text": "IGF.Builder.CreateBr(outflows->Outflows[0].DestBlock)",
          "old_line_content": "  // It's also straightforward if we have one branch outflow and",
          "new_line_content": "    IGF.Builder.CreateBr(outflows->Outflows[0].DestBlock);",
          "content_same": false
        },
        {
          "line": 140,
          "old_api": null,
          "new_api": "createBasicBlock",
          "old_text": null,
          "new_text": "createBasicBlock(\"condition.cont\")",
          "old_line_content": "    // If requested, invert the value.",
          "new_line_content": "    contBB = createBasicBlock(\"condition.cont\");",
          "content_same": false
        },
        {
          "line": 141,
          "old_api": null,
          "new_api": "createBasicBlock",
          "old_text": null,
          "new_text": "createBasicBlock(\"if.true\")",
          "old_line_content": "    if (invertValue)",
          "new_line_content": "    trueBB = createBasicBlock(\"if.true\");",
          "content_same": false
        },
        {
          "line": 145,
          "old_api": null,
          "new_api": "createBasicBlock",
          "old_text": null,
          "new_text": "createBasicBlock(\"if.false\")",
          "old_line_content": "    ",
          "new_line_content": "      falseBB = falseDestBB = createBasicBlock(\"if.false\");",
          "content_same": false
        },
        {
          "line": 660,
          "old_api": null,
          "new_api": "hasFallthroughOutflow",
          "old_text": null,
          "new_text": "cleanup.hasFallthroughOutflow()",
          "old_line_content": "  // The default destination is either the next entry block, if there",
          "new_line_content": "  if (cleanup.hasFallthroughOutflow())",
          "content_same": false
        },
        {
          "line": 661,
          "old_api": null,
          "new_api": "getOrCreateNextNormalEntryBlock",
          "old_text": null,
          "new_text": "getOrCreateNextNormalEntryBlock(IGF, stack)",
          "old_line_content": "  // are fallthroughs, or the unreachable block if there aren't.",
          "new_line_content": "    defaultDest = getOrCreateNextNormalEntryBlock(IGF, stack);",
          "content_same": false
        },
        {
          "line": 152,
          "old_api": null,
          "new_api": "CreateCondBr",
          "old_text": null,
          "new_text": "Builder.CreateCondBr(V, falseDestBB, trueBB)",
          "old_line_content": "    } else {",
          "new_line_content": "      Builder.CreateCondBr(V, falseDestBB, trueBB);",
          "content_same": false
        },
        {
          "line": 154,
          "old_api": null,
          "new_api": "CreateCondBr",
          "old_text": null,
          "new_text": "Builder.CreateCondBr(V, trueBB, falseDestBB)",
          "old_line_content": "      falseDestBB = contBB;",
          "new_line_content": "      Builder.CreateCondBr(V, trueBB, falseDestBB);",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": null,
          "new_api": "getJumpDestAlignment",
          "old_text": null,
          "new_text": "IGF.getJumpDestAlignment()",
          "old_line_content": "",
          "new_line_content": "    IGF.Builder.CreateLoad(IGF.getJumpDestSlot(), IGF.getJumpDestAlignment(),",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "outflows->Outflows.size()",
          "old_line_content": "                           \"jumpdest.switchvalue\");",
          "new_line_content": "    IGF.Builder.CreateSwitch(destValue, defaultDest, outflows->Outflows.size());",
          "content_same": false
        },
        {
          "line": 161,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(TrueBB)",
          "old_line_content": "}",
          "new_line_content": "  assert(TrueBB);",
          "content_same": false
        },
        {
          "line": 162,
          "old_api": null,
          "new_api": "hasValidIP",
          "old_text": null,
          "new_text": "IGF.Builder.hasValidIP()",
          "old_line_content": "",
          "new_line_content": "  assert(IGF.Builder.hasValidIP());",
          "content_same": false
        },
        {
          "line": 673,
          "old_api": null,
          "new_api": "addCase",
          "old_text": null,
          "new_text": "sw->addCase(outflow.DestLabel, outflow.DestBlock)",
          "old_line_content": "  llvm::SwitchInst *sw =",
          "new_line_content": "    sw->addCase(outflow.DestLabel, outflow.DestBlock);",
          "content_same": false
        },
        {
          "line": 168,
          "old_api": null,
          "new_api": "emitBlock",
          "old_text": null,
          "new_text": "IGF.Builder.emitBlock(TrueBB)",
          "old_line_content": "  // continuation block.",
          "new_line_content": "  IGF.Builder.emitBlock(TrueBB);",
          "content_same": false
        },
        {
          "line": 680,
          "old_api": null,
          "new_api": "checkIterator",
          "old_text": null,
          "new_text": "stack.checkIterator(end)",
          "old_line_content": "static void popAndEmitTopDeadCleanups(IRGenFunction &IGF,",
          "new_line_content": "  stack.checkIterator(end);",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "stack.begin()->isDead()",
          "old_line_content": "                                      CleanupsDepth end) {",
          "new_line_content": "  while (stack.stable_begin() != end && stack.begin()->isDead()) {",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": null,
          "new_api": "checkIterator",
          "old_text": null,
          "new_text": "stack.checkIterator(end)",
          "old_line_content": "",
          "new_line_content": "    stack.checkIterator(end);",
          "content_same": false
        },
        {
          "line": 178,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(!FalseBB && \"no continuation\")",
          "old_line_content": "  // end of the true case is unreachable.  In other words, there's",
          "new_line_content": "    assert(!FalseBB && \"no continuation\");",
          "content_same": false
        },
        {
          "line": 695,
          "old_api": null,
          "new_api": "isActive",
          "old_text": null,
          "new_text": "begin->isActive()",
          "old_line_content": "static bool hasAnyActiveCleanups(DiverseStackImpl<Cleanup>::iterator begin,",
          "new_line_content": "    if (begin->isActive())",
          "content_same": false
        },
        {
          "line": 184,
          "old_api": null,
          "new_api": "hasValidIP",
          "old_text": null,
          "new_text": "IGF.Builder.hasValidIP()",
          "old_line_content": "",
          "new_line_content": "  if (!IGF.Builder.hasValidIP()) {",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": null,
          "new_api": "checkIterator",
          "old_text": null,
          "new_text": "Cleanups.checkIterator(depth)",
          "old_line_content": "",
          "new_line_content": "  Cleanups.checkIterator(depth);",
          "content_same": false
        },
        {
          "line": 194,
          "old_api": null,
          "new_api": "CreateBr",
          "old_text": null,
          "new_text": "IGF.Builder.CreateBr(ContBB)",
          "old_line_content": "  // Otherwise, resume into the continuation block.  This branch might",
          "new_line_content": "  IGF.Builder.CreateBr(ContBB);",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": null,
          "new_api": "popAndEmitTopDeadCleanups",
          "old_text": null,
          "new_text": "popAndEmitTopDeadCleanups(*this, Cleanups, InnermostScope)",
          "old_line_content": "",
          "new_line_content": "    popAndEmitTopDeadCleanups(*this, Cleanups, InnermostScope);",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": null,
          "new_api": "hasValidIP",
          "old_text": null,
          "new_text": "Builder.hasValidIP()",
          "old_line_content": "  // Thread a branch through the cleanups if there are any active",
          "new_line_content": "  if (Builder.hasValidIP() &&",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "Cleanups.find(depth)",
          "old_line_content": "  // cleanups and we have a valid insertion point.",
          "new_line_content": "      hasAnyActiveCleanups(Cleanups.begin(), Cleanups.find(depth))) {",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": null,
          "new_api": "createBasicBlock",
          "old_text": null,
          "new_text": "createBasicBlock(\"cleanups.fallthrough\")",
          "old_line_content": "  llvm::BasicBlock *contBB = nullptr;",
          "new_line_content": "    contBB = createBasicBlock(\"cleanups.fallthrough\");",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(FalseBB && \"entering the false branch when it was not valid\")",
          "old_line_content": "}",
          "new_line_content": "  assert(FalseBB && \"entering the false branch when it was not valid\");",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": null,
          "new_api": "stable_begin",
          "old_text": null,
          "new_text": "Cleanups.stable_begin()",
          "old_line_content": "",
          "new_line_content": "  while (Cleanups.stable_begin() != depth) {",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "Cleanups.begin()->isDead()",
          "old_line_content": "  // Maybe we'd get better results if we marked them all dead in one shot?",
          "new_line_content": "    if (!Cleanups.begin()->isDead())",
          "content_same": false
        },
        {
          "line": 212,
          "old_api": null,
          "new_api": "emitBlockAnywhere",
          "old_text": null,
          "new_text": "IGF.Builder.emitBlockAnywhere(FalseBB)",
          "old_line_content": "",
          "new_line_content": "  IGF.Builder.emitBlockAnywhere(FalseBB);",
          "content_same": false
        },
        {
          "line": 732,
          "old_api": null,
          "new_api": "emitMergeableBlock",
          "old_text": null,
          "new_text": "Builder.emitMergeableBlock(contBB)",
          "old_line_content": "",
          "new_line_content": "    Builder.emitMergeableBlock(contBB);",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "Cleanups.empty()",
          "old_line_content": "",
          "new_line_content": "  assert(!Cleanups.empty() && \"popping empty stack!\");",
          "content_same": false
        },
        {
          "line": 227,
          "old_api": null,
          "new_api": "use_empty",
          "old_text": null,
          "new_text": "ContBB->use_empty()",
          "old_line_content": "  // we don't either, regardless of whether the current location",
          "new_line_content": "  if (ContBB->use_empty()) {",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": null,
          "new_api": "checkIterator",
          "old_text": null,
          "new_text": "Cleanups.checkIterator(InnermostScope)",
          "old_line_content": "/// End the scope induced by a single cleanup.",
          "new_line_content": "  Cleanups.checkIterator(InnermostScope);",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": null,
          "new_api": "stable_begin",
          "old_text": null,
          "new_text": "Cleanups.stable_begin()",
          "old_line_content": "void IRGenFunction::endSingleCleanupScope() {",
          "new_line_content": "  assert(Cleanups.stable_begin() != InnermostScope &&",
          "content_same": false
        },
        {
          "line": 235,
          "old_api": null,
          "new_api": "hasValidIP",
          "old_text": null,
          "new_text": "IGF.Builder.hasValidIP()",
          "old_line_content": "  //",
          "new_line_content": "  } else if (!IGF.Builder.hasValidIP()) {",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": null,
          "new_api": "hasOneUse",
          "old_text": null,
          "new_text": "ContBB->hasOneUse()",
          "old_line_content": "  // Note that doing this tends to strand the false code after",
          "new_line_content": "    assert(ContBB->hasOneUse());",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": null,
          "new_api": "use_begin",
          "old_text": null,
          "new_text": "ContBB->use_begin()",
          "old_line_content": "  // everything else in the function, so maybe it's not a great idea.",
          "new_line_content": "    llvm::BranchInst *Br = cast<llvm::BranchInst>(*ContBB->use_begin());",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": null,
          "new_api": "unsigned",
          "old_text": null,
          "new_text": "unsigned(state)",
          "old_line_content": "Cleanup &IRGenFunction::initCleanup(Cleanup &cleanup, size_t allocSize,",
          "new_line_content": "  cleanup.State = unsigned(state);",
          "content_same": false
        },
        {
          "line": 242,
          "old_api": null,
          "new_api": "use_empty",
          "old_text": null,
          "new_text": "ContBB->use_empty()",
          "old_line_content": "",
          "new_line_content": "    assert(ContBB->use_empty());",
          "content_same": false
        },
        {
          "line": 246,
          "old_api": null,
          "new_api": "CreateBr",
          "old_text": null,
          "new_text": "IGF.Builder.CreateBr(ContBB)",
          "old_line_content": "",
          "new_line_content": "    IGF.Builder.CreateBr(ContBB);",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": null,
          "new_api": "getStableIP",
          "old_text": null,
          "new_text": "Builder.getStableIP()",
          "old_line_content": "  //      ControlBegin set below",
          "new_line_content": "  cleanup.setControl(CleanupControl::forIP(Builder.getStableIP()));",
          "content_same": false
        },
        {
          "line": 256,
          "old_api": null,
          "new_api": "hasPostTerminatorIP",
          "old_text": null,
          "new_text": "IGF.Builder.hasPostTerminatorIP()",
          "old_line_content": "  // normal insertion state (i.e. not a post-terminator IP) with",
          "new_line_content": "    assert(!IGF.Builder.hasPostTerminatorIP());",
          "content_same": false
        },
        {
          "line": 768,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "Cleanups.find(depth)",
          "old_line_content": "/// Change the state of a cleanup.",
          "new_line_content": "  auto iter = Cleanups.find(depth);",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "Cleanups.end()",
          "old_line_content": "void IRGenFunction::setCleanupState(CleanupsDepth depth,",
          "new_line_content": "  assert(iter != Cleanups.end() && \"changing state of end of stack\");",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": null,
          "new_api": "setCleanupState",
          "old_text": null,
          "new_text": "setCleanupState(*iter, newState)",
          "old_line_content": "                                    CleanupState newState) {",
          "new_line_content": "  setCleanupState(*iter, newState);",
          "content_same": false
        },
        {
          "line": 263,
          "old_api": null,
          "new_api": "use_empty",
          "old_text": null,
          "new_text": "ContBB->use_empty()",
          "old_line_content": "  // Kill the continuation block if it's not being used.  Case-exits",
          "new_line_content": "  if (ContBB->use_empty()) {",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": null,
          "new_api": "hasPostTerminatorIP",
          "old_text": null,
          "new_text": "IGF.Builder.hasPostTerminatorIP()",
          "old_line_content": "  // only leave themselves post-terminator if they use the",
          "new_line_content": "    assert(!IGF.Builder.hasPostTerminatorIP());",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": null,
          "new_api": "hasValidIP",
          "old_text": null,
          "new_text": "Builder.hasValidIP()",
          "old_line_content": "}",
          "new_line_content": "  assert((newState != CleanupState::Active || Builder.hasValidIP()) &&",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": null,
          "new_api": "getState",
          "old_text": null,
          "new_text": "cleanup.getState()",
          "old_line_content": "         \"activating cleanup at invalid IP\");",
          "new_line_content": "  CleanupState oldState = cleanup.getState();",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": null,
          "new_api": "setState",
          "old_text": null,
          "new_text": "cleanup.setState(newState)",
          "old_line_content": "",
          "new_line_content": "  cleanup.setState(newState);",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": null,
          "new_api": "hasPostTerminatorIP",
          "old_text": null,
          "new_text": "IGF.Builder.hasPostTerminatorIP()",
          "old_line_content": "  // Okay, we need to insert the continuation block.  Usually we'll be",
          "new_line_content": "  assert(IGF.Builder.hasPostTerminatorIP() ||",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": null,
          "new_api": "hasValidIP",
          "old_text": null,
          "new_text": "IGF.Builder.hasValidIP()",
          "old_line_content": "  // post-terminator here, but we might not be if there is no false",
          "new_line_content": "         (!FalseBB && !IGF.Builder.hasValidIP()));",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": null,
          "new_api": "llvm_unreachable",
          "old_text": null,
          "new_text": "llvm_unreachable(\"no transition\")",
          "old_line_content": "  // We're either activating or killing off a dormant cleanup.",
          "new_line_content": "    case CleanupState::Dormant: llvm_unreachable(\"no transition\");",
          "content_same": false
        },
        {
          "line": 802,
          "old_api": null,
          "new_api": "getControl",
          "old_text": null,
          "new_text": "cleanup.getControl()",
          "old_line_content": "",
          "new_line_content": "      CleanupControl control = cleanup.getControl();",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": null,
          "new_api": "createBasicBlock",
          "old_text": null,
          "new_text": "createBasicBlock(\"unreachable\")",
          "old_line_content": "  if (UnreachableBB) return UnreachableBB;",
          "new_line_content": "  UnreachableBB = createBasicBlock(\"unreachable\");",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": null,
          "new_api": "getContext",
          "old_text": null,
          "new_text": "UnreachableBB->getContext()",
          "old_line_content": "",
          "new_line_content": "  new llvm::UnreachableInst(UnreachableBB->getContext(), UnreachableBB);",
          "content_same": false
        },
        {
          "line": 293,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "CurFn->getBasicBlockList().push_back(UnreachableBB)",
          "old_line_content": "  // Create it at the very end of the function.",
          "new_line_content": "  CurFn->getBasicBlockList().push_back(UnreachableBB);",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": null,
          "new_api": "getFlag",
          "old_text": null,
          "new_text": "control.getFlag()",
          "old_line_content": "",
          "new_line_content": "        setFlagNow(*this, control.getFlag(), true);",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": null,
          "new_api": "isUsedWhileInactive",
          "old_text": null,
          "new_text": "cleanup.isUsedWhileInactive()",
          "old_line_content": "      // was in an active state.",
          "new_line_content": "      if (cleanup.isUsedWhileActive() && cleanup.isUsedWhileInactive()) {",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": null,
          "new_api": "transitionControlToFlag",
          "old_text": null,
          "new_text": "transitionControlToFlag(*this, cleanup)",
          "old_line_content": "",
          "new_line_content": "        transitionControlToFlag(*this, cleanup);",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": null,
          "new_api": "CreateCall",
          "old_text": null,
          "new_text": "Builder.CreateCall(fn, args)",
          "old_line_content": "                                         ArrayRef<llvm::Value*> args,",
          "new_line_content": "  llvm::CallInst *call = Builder.CreateCall(fn, args);",
          "content_same": false
        },
        {
          "line": 308,
          "old_api": null,
          "new_api": "setAttributes",
          "old_text": null,
          "new_text": "call->setAttributes(attrs)",
          "old_line_content": "                                         const llvm::AttrListPtr &attrs) {",
          "new_line_content": "  call->setAttributes(attrs);",
          "content_same": false
        },
        {
          "line": 309,
          "old_api": null,
          "new_api": "setCallingConv",
          "old_text": null,
          "new_text": "call->setCallingConv(convention)",
          "old_line_content": "  // TODO: exceptions!",
          "new_line_content": "  call->setCallingConv(convention);",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": null,
          "new_api": "isUsedWhileInactive",
          "old_text": null,
          "new_text": "cleanup.isUsedWhileInactive()",
          "old_line_content": "",
          "new_line_content": "      if (!cleanup.isUsedWhileInactive())",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": null,
          "new_api": "isUsedWhileActive",
          "old_text": null,
          "new_text": "cleanup.isUsedWhileActive()",
          "old_line_content": "",
          "new_line_content": "      assert(!cleanup.isUsedWhileActive());",
          "content_same": false
        },
        {
          "line": 827,
          "old_api": null,
          "new_api": "getIPEnd",
          "old_text": null,
          "new_text": "control.getIPEnd()",
          "old_line_content": "      // Otherwise, we have uses while inactive but none while active.",
          "new_line_content": "      cleanup.setControl(CleanupControl::forIPRange(control.getIPEnd(),",
          "content_same": false
        },
        {
          "line": 828,
          "old_api": null,
          "new_api": "getStableIP",
          "old_text": null,
          "new_text": "Builder.getStableIP()",
          "old_line_content": "      // Set the range to the range of the dormant period.",
          "new_line_content": "                                                    Builder.getStableIP()));",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": null,
          "new_api": "llvm_unreachable",
          "old_text": null,
          "new_text": "llvm_unreachable(\"bad cleanup state\")",
          "old_line_content": "      return;",
          "new_line_content": "    llvm_unreachable(\"bad cleanup state\");",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": null,
          "new_api": "getControl",
          "old_text": null,
          "new_text": "cleanup.getControl()",
          "old_line_content": "  // We're deactivating an active cleanup, either temporarily or not.",
          "new_line_content": "    CleanupControl control = cleanup.getControl();",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": null,
          "new_api": "hasValidIP",
          "old_text": null,
          "new_text": "Builder.hasValidIP()",
          "old_line_content": "    // If we have a control flag already, just store to it.",
          "new_line_content": "      if (Builder.hasValidIP())",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "Outflows.push_back(outflow)",
          "old_line_content": "",
          "new_line_content": "    Outflows.push_back(outflow);",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": null,
          "new_api": "isUsedWhileInactive",
          "old_text": null,
          "new_text": "cleanup.isUsedWhileInactive()",
          "old_line_content": "    // was in a dormant state.",
          "new_line_content": "    if (cleanup.isUsedWhileActive() && cleanup.isUsedWhileInactive()) {",
          "content_same": false
        },
        {
          "line": 853,
          "old_api": null,
          "new_api": "transitionControlToFlag",
          "old_text": null,
          "new_text": "transitionControlToFlag(*this, cleanup)",
          "old_line_content": "",
          "new_line_content": "      transitionControlToFlag(*this, cleanup);",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": null,
          "new_api": "getOutflows",
          "old_text": null,
          "new_text": "cleanup.getOutflows()",
          "old_line_content": "};",
          "new_line_content": "  CleanupOutflows *outs = cleanup.getOutflows();",
          "content_same": false
        },
        {
          "line": 344,
          "old_api": null,
          "new_api": "setOutflows",
          "old_text": null,
          "new_text": "cleanup.setOutflows(outs = new CleanupOutflows())",
          "old_line_content": "",
          "new_line_content": "  if (!outs) cleanup.setOutflows(outs = new CleanupOutflows());",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": null,
          "new_api": "isUsedWhileActive",
          "old_text": null,
          "new_text": "cleanup.isUsedWhileActive()",
          "old_line_content": "",
          "new_line_content": "    if (cleanup.isUsedWhileActive()) {",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": null,
          "new_api": "isUsedWhileInactive",
          "old_text": null,
          "new_text": "cleanup.isUsedWhileInactive()",
          "old_line_content": "    // Otherwise, we have uses while active but none while inactive.",
          "new_line_content": "      assert(!cleanup.isUsedWhileInactive());",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": null,
          "new_api": "getIPEnd",
          "old_text": null,
          "new_text": "control.getIPEnd()",
          "old_line_content": "    // Set the range to the range of the active period.",
          "new_line_content": "      cleanup.setControl(CleanupControl::forIPRange(control.getIPEnd(),",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": null,
          "new_api": "getStableIP",
          "old_text": null,
          "new_text": "Builder.getStableIP()",
          "old_line_content": "    } else {",
          "new_line_content": "                                                    Builder.getStableIP()));",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": null,
          "new_api": "llvm_unreachable",
          "old_text": null,
          "new_text": "llvm_unreachable(\"bad cleanup state\")",
          "old_line_content": "    return;",
          "new_line_content": "  llvm_unreachable(\"bad cleanup state\");",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": null,
          "new_api": "hasValidIP",
          "old_text": null,
          "new_text": "Builder.hasValidIP()",
          "old_line_content": "/// any cleanups we might need to run.  Leaves the insertion point in",
          "new_line_content": "  assert(Builder.hasValidIP());",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": null,
          "new_api": "getDepth",
          "old_text": null,
          "new_text": "dest.getDepth()",
          "old_line_content": "void IRGenFunction::emitBranch(JumpDest dest) {",
          "new_line_content": "  auto depth = Cleanups.find(dest.getDepth());",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": null,
          "new_api": "isActive",
          "old_text": null,
          "new_text": "it->isActive()",
          "old_line_content": "  // Find the topmost active cleanup.",
          "new_line_content": "    if (it->isActive())",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": null,
          "new_api": "getBlock",
          "old_text": null,
          "new_text": "dest.getBlock()",
          "old_line_content": "",
          "new_line_content": "    Builder.CreateBr(dest.getBlock());",
          "content_same": false
        },
        {
          "line": 388,
          "old_api": null,
          "new_api": "forIPRange",
          "old_text": null,
          "new_text": "forIPRange(begin, begin)",
          "old_line_content": "  }",
          "new_line_content": "    return forIPRange(begin, begin);",
          "content_same": false
        },
        {
          "line": 392,
          "old_api": null,
          "new_api": "hasFlag",
          "old_text": null,
          "new_text": "hasFlag()",
          "old_line_content": "  }",
          "new_line_content": "  llvm::AllocaInst *getFlag() const { assert(hasFlag()); return Flag; }",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": null,
          "new_api": "isActive",
          "old_text": null,
          "new_text": "it->isActive()",
          "old_line_content": "    auto next = it; ++next;",
          "new_line_content": "    if (it->isActive())",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": null,
          "new_api": "hasFlag",
          "old_text": null,
          "new_text": "hasFlag()",
          "old_line_content": "  bool hasFlag() const { return Flag != nullptr; }",
          "new_line_content": "    assert(!hasFlag());",
          "content_same": false
        },
        {
          "line": 398,
          "old_api": null,
          "new_api": "hasFlag",
          "old_text": null,
          "new_text": "hasFlag()",
          "old_line_content": "    return IPBegin;",
          "new_line_content": "    assert(!hasFlag());",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": null,
          "new_api": "getNextDestLabel",
          "old_text": null,
          "new_text": "it->getNextDestLabel()",
          "old_line_content": "    // actually have to route through this cleanup if it's not active",
          "new_line_content": "    destLabel = std::max(destLabel, it->getNextDestLabel());",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": null,
          "new_api": "CleanupControl::forFlag(\n               reinterpret_cast<llvm::AllocaInst*>(ControlBegin))",
          "old_text": null,
          "new_text": "CleanupControl::forFlag(\n               reinterpret_cast<llvm::AllocaInst*>(ControlBegin))",
          "old_line_content": "",
          "new_line_content": "    return CleanupControl::forFlag(",
          "content_same": false
        },
        {
          "line": 406,
          "old_api": null,
          "new_api": "reinterpret_cast<llvm::AllocaInst*>(ControlBegin)",
          "old_text": null,
          "new_text": "reinterpret_cast<llvm::AllocaInst*>(ControlBegin)",
          "old_line_content": "CleanupControl Cleanup::getControl() const {",
          "new_line_content": "               reinterpret_cast<llvm::AllocaInst*>(ControlBegin));",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": null,
          "new_api": "isActive",
          "old_text": null,
          "new_text": "outermost->isActive()",
          "old_line_content": "    it = next;",
          "new_line_content": "  assert(outermost->isActive());",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": null,
          "new_api": "IRBuilder::StableIP::getFromOpaqueValue(ControlEnd)",
          "old_text": null,
          "new_text": "IRBuilder::StableIP::getFromOpaqueValue(ControlEnd)",
          "old_line_content": "",
          "new_line_content": "               IRBuilder::StableIP::getFromOpaqueValue(ControlEnd));",
          "content_same": false
        },
        {
          "line": 414,
          "old_api": null,
          "new_api": "hasFlag",
          "old_text": null,
          "new_text": "control.hasFlag()",
          "old_line_content": "}",
          "new_line_content": "  if (control.hasFlag()) {",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": null,
          "new_api": "getOrCreateOutflows",
          "old_text": null,
          "new_text": "getOrCreateOutflows(*outermost)",
          "old_line_content": "  // destination and cleanups.",
          "new_line_content": "  CleanupOutflows *outs = getOrCreateOutflows(*outermost);",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": null,
          "new_api": "getFlag",
          "old_text": null,
          "new_text": "control.getFlag()",
          "old_line_content": "void Cleanup::setControl(const CleanupControl &control) {",
          "new_line_content": "    ControlBegin = control.getFlag();",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": null,
          "new_api": "llvm::ConstantInt::get(IGM.Int32Ty,\n                                                         destLabel)",
          "old_text": null,
          "new_text": "llvm::ConstantInt::get(IGM.Int32Ty,\n                                                         destLabel)",
          "old_line_content": "  // FIXME: We should reuse labels for multiple jumps to the same",
          "new_line_content": "  llvm::ConstantInt *labelValue = llvm::ConstantInt::get(IGM.Int32Ty,",
          "content_same": false
        },
        {
          "line": 420,
          "old_api": null,
          "new_api": "getIPEnd",
          "old_text": null,
          "new_text": "control.getIPEnd().getOpaqueValue()",
          "old_line_content": "  } else {",
          "new_line_content": "    ControlEnd = control.getIPEnd().getOpaqueValue();",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": null,
          "new_api": "setNextDestLabel",
          "old_text": null,
          "new_text": "outermost->setNextDestLabel(destLabel + 1)",
          "old_line_content": "",
          "new_line_content": "  outermost->setNextDestLabel(destLabel + 1);",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": null,
          "new_api": "hasValidIP",
          "old_text": null,
          "new_text": "IGF.Builder.hasValidIP()",
          "old_line_content": "",
          "new_line_content": "  assert(IGF.Builder.hasValidIP());",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": null,
          "new_api": "Alignment",
          "old_text": null,
          "new_text": "Alignment(1)",
          "old_line_content": "/// Alter a control flag at the current insertion point (which must be valid).",
          "new_line_content": "  IGF.Builder.CreateStore(IGF.Builder.getInt1(value), flag, Alignment(1));",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": null,
          "new_api": "getOrCreateNormalEntryBlock",
          "old_text": null,
          "new_text": "getOrCreateNormalEntryBlock(*this, *innermost)",
          "old_line_content": "",
          "new_line_content": "  Builder.CreateBr(getOrCreateNormalEntryBlock(*this, *innermost));",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": null,
          "new_api": "addUse",
          "old_text": null,
          "new_text": "it->addUse()",
          "old_line_content": "",
          "new_line_content": "    it->addUse();",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": null,
          "new_api": "addFallthroughOutflow",
          "old_text": null,
          "new_text": "it->addFallthroughOutflow()",
          "old_line_content": "  // Walk through the intermediate cleanups again and add fallthrough outflows.",
          "new_line_content": "    it->addFallthroughOutflow();",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": null,
          "new_api": "isValid",
          "old_text": null,
          "new_text": "ip.isValid()",
          "old_line_content": "/// Alter a control flag at the given stable insertion point.",
          "new_line_content": "  if (!ip.isValid()) {",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(value == false && \"activation point is unreachable!\")",
          "old_line_content": "static void setFlagThen(IRGenFunction &IGF, IRBuilder::StableIP ip,",
          "new_line_content": "    assert(value == false && \"activation point is unreachable!\");",
          "content_same": false
        },
        {
          "line": 439,
          "old_api": null,
          "new_api": "getInt1",
          "old_text": null,
          "new_text": "IGF.Builder.getInt1(value)",
          "old_line_content": "  }",
          "new_line_content": "    new llvm::StoreInst(IGF.Builder.getInt1(value), flag);",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": null,
          "new_api": "setAlignment",
          "old_text": null,
          "new_text": "store->setAlignment(1)",
          "old_line_content": "",
          "new_line_content": "  store->setAlignment(1);",
          "content_same": false
        },
        {
          "line": 441,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "ip.insert(store)",
          "old_line_content": "  llvm::StoreInst *store =",
          "new_line_content": "  ip.insert(store);",
          "content_same": false
        },
        {
          "line": 448,
          "old_api": null,
          "new_api": "Alignment",
          "old_text": null,
          "new_text": "Alignment(1)",
          "old_line_content": "static llvm::AllocaInst *createControlFlag(IRGenFunction &IGF,",
          "new_line_content": "    IGF.createSupportAlloca(IGF.IGM.Int1Ty, Alignment(1), \"cleanup.isactive\");",
          "content_same": false
        },
        {
          "line": 449,
          "old_api": null,
          "new_api": "CleanupControl::forFlag(flag)",
          "old_text": null,
          "new_text": "CleanupControl::forFlag(flag)",
          "old_line_content": "                                           Cleanup &cleanup) {",
          "new_line_content": "  cleanup.setControl(CleanupControl::forFlag(flag));",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": null,
          "new_api": "getControl",
          "old_text": null,
          "new_text": "cleanup.getControl()",
          "old_line_content": "",
          "new_line_content": "  CleanupControl control = cleanup.getControl();",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": null,
          "new_api": "hasFlag",
          "old_text": null,
          "new_text": "control.hasFlag()",
          "old_line_content": "/// Transition the given cleanup to using a flag for control.",
          "new_line_content": "  assert(!control.hasFlag());",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": null,
          "new_api": "createControlFlag",
          "old_text": null,
          "new_text": "createControlFlag(IGF, cleanup)",
          "old_line_content": "",
          "new_line_content": "  llvm::AllocaInst *flag = createControlFlag(IGF, cleanup);",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": null,
          "new_api": "getIPEnd",
          "old_text": null,
          "new_text": "control.getIPEnd()",
          "old_line_content": "",
          "new_line_content": "  setFlagThen(IGF, control.getIPEnd(), flag, !isActiveNow);",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": null,
          "new_api": "allocated_size",
          "old_text": null,
          "new_text": "cleanup.allocated_size()",
          "old_line_content": "",
          "new_line_content": "      size_t size = cleanup.allocated_size();",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": null,
          "new_api": "set_size",
          "old_text": null,
          "new_text": "Data.set_size(size)",
          "old_line_content": "  public:",
          "new_line_content": "      Data.set_size(size);",
          "content_same": false
        },
        {
          "line": 477,
          "old_api": null,
          "new_api": "reinterpret_cast<const void*>(&cleanup)",
          "old_text": null,
          "new_text": "reinterpret_cast<const void*>(&cleanup)",
          "old_line_content": "    CleanupBuffer(const Cleanup &cleanup) {",
          "new_line_content": "      memcpy(Data.data(), reinterpret_cast<const void*>(&cleanup), size);",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": null,
          "new_api": "getNormalEntryBlock",
          "old_text": null,
          "new_text": "cleanup.getNormalEntryBlock()",
          "old_line_content": "/// Get or create a normal entry block on the given cleanup.",
          "new_line_content": "  llvm::BasicBlock *block = cleanup.getNormalEntryBlock();",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": null,
          "new_api": "setNormalEntryBlock",
          "old_text": null,
          "new_text": "cleanup.setNormalEntryBlock(block)",
          "old_line_content": "  if (block) return block;",
          "new_line_content": "  cleanup.setNormalEntryBlock(block);",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": null,
          "new_api": "isUsedWhileActive",
          "old_text": null,
          "new_text": "cleanup.isUsedWhileActive()",
          "old_line_content": "    // fallthrough branches began.  We only add non-fallthrough outflows",
          "new_line_content": "    if (cleanup.isUsedWhileActive())",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 516,
          "old_api": "llvm_unreachable",
          "new_api": null,
          "old_text": "llvm_unreachable(\"ran out of cleanups looking for outflows!\")",
          "new_text": null,
          "old_line_content": "  llvm_unreachable(\"ran out of cleanups looking for outflows!\");",
          "new_line_content": "/// Get or create a normal entry block for the next meaningful",
          "content_same": false
        },
        {
          "line": 526,
          "old_api": "getNextCleanupForFallthrough",
          "new_api": null,
          "old_text": "getNextCleanupForFallthrough(stack)",
          "new_text": null,
          "old_line_content": "  return getOrCreateNormalEntryBlock(IGF, getNextCleanupForFallthrough(stack));",
          "new_line_content": "/// Emit a cleanup at the current insertion point.",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": "hasValidIP",
          "new_api": null,
          "old_text": "IGF.Builder.hasValidIP()",
          "new_text": null,
          "old_line_content": "  assert(IGF.Builder.hasValidIP());",
          "new_line_content": "  // to handle that here.",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": "hasFlag",
          "new_api": null,
          "old_text": "control.hasFlag()",
          "new_text": null,
          "old_line_content": "  if (control.hasFlag()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": "createBasicBlock",
          "new_api": null,
          "old_text": "IGF.createBasicBlock(\"cleanup.cont\")",
          "new_text": null,
          "old_line_content": "    contBB = IGF.createBasicBlock(\"cleanup.cont\");",
          "new_line_content": "    // Branch on the control flag.",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": "createBasicBlock",
          "new_api": null,
          "old_text": "IGF.createBasicBlock(\"cleanup.body\")",
          "new_text": null,
          "old_line_content": "    llvm::BasicBlock *bodyBB = IGF.createBasicBlock(\"cleanup.body\");",
          "new_line_content": "    llvm::Value *flagValue =",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": "Alignment",
          "new_api": null,
          "old_text": "Alignment(1)",
          "new_text": null,
          "old_line_content": "      IGF.Builder.CreateLoad(control.getFlag(), Alignment(1));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": "CreateCondBr",
          "new_api": null,
          "old_text": "IGF.Builder.CreateCondBr(flagValue, bodyBB, contBB)",
          "new_text": null,
          "old_line_content": "    IGF.Builder.CreateCondBr(flagValue, bodyBB, contBB);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": "emitBlock",
          "new_api": null,
          "old_text": "IGF.Builder.emitBlock(bodyBB)",
          "new_text": null,
          "old_line_content": "    IGF.Builder.emitBlock(bodyBB);",
          "new_line_content": "  // Emit the cleanup body.",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": "emit",
          "new_api": null,
          "old_text": "cleanup.emit(IGF)",
          "new_text": null,
          "old_line_content": "  cleanup.emit(IGF);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": "CreateBr",
          "new_api": null,
          "old_text": "IGF.Builder.CreateBr(contBB)",
          "new_text": null,
          "old_line_content": "    IGF.Builder.CreateBr(contBB);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 555,
          "old_api": "emitBlock",
          "new_api": null,
          "old_text": "IGF.Builder.emitBlock(contBB)",
          "new_text": null,
          "old_line_content": "    IGF.Builder.emitBlock(contBB);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": "isDead",
          "new_api": null,
          "old_text": "stackCleanup.isDead()",
          "new_text": null,
          "old_line_content": "  assert(stackCleanup.isDead() && \"popping a living cleanup\");",
          "new_line_content": "    // emitBranch never directly branches to a cleanup that's currently",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": "isUsedWhileActive",
          "new_api": null,
          "old_text": "stackCleanup.isUsedWhileActive()",
          "new_text": null,
          "old_line_content": "  if (!stackCleanup.isUsedWhileActive()) {",
          "new_line_content": "    // cleanup that's never been active.",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": "getOutflows",
          "new_api": null,
          "old_text": "stackCleanup.getOutflows()",
          "new_text": null,
          "old_line_content": "    assert(stackCleanup.getOutflows() == nullptr);",
          "new_line_content": "    // existing on cleanups with both active and inactive references.",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": "getControl",
          "new_api": null,
          "old_text": "stackCleanup.getControl().hasFlag()",
          "new_text": null,
          "old_line_content": "    assert(!stackCleanup.getControl().hasFlag());",
          "new_line_content": "    // pop it.",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": "pop",
          "new_api": null,
          "old_text": "stack.pop()",
          "new_text": null,
          "old_line_content": "    stack.pop();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": "pop",
          "new_api": null,
          "old_text": "stack.pop()",
          "new_text": null,
          "old_line_content": "  stack.pop();",
          "new_line_content": "  // TODO: avoid creating these in obvious cases.",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": "getNormalEntryBlock",
          "new_api": null,
          "old_text": "cleanup.getNormalEntryBlock()",
          "new_text": null,
          "old_line_content": "  llvm::BasicBlock *entry = cleanup.getNormalEntryBlock();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(entry && \"no entry block for referenced top cleanup\")",
          "new_text": null,
          "old_line_content": "  assert(entry && \"no entry block for referenced top cleanup\");",
          "new_line_content": "  llvm::BasicBlock *trueEntry;",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": "use_empty",
          "new_api": null,
          "old_text": "entry->use_empty()",
          "new_text": null,
          "old_line_content": "  assert(!entry->use_empty() && \"unused entry block\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 606,
          "old_api": "isUnconditional",
          "new_api": null,
          "old_text": "br->isUnconditional()",
          "new_text": null,
          "old_line_content": "    if (br && br->isUnconditional()) {",
          "new_line_content": "      delete entry;",
          "content_same": false
        },
        {
          "line": 607,
          "old_api": "getParent",
          "new_api": null,
          "old_text": "br->getParent()",
          "new_text": null,
          "old_line_content": "      trueEntry = br->getParent();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": "eraseFromParent",
          "new_api": null,
          "old_text": "br->eraseFromParent()",
          "new_text": null,
          "old_line_content": "      br->eraseFromParent();",
          "new_line_content": "    // Even if it's not an unconditional branch, place the entry after",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": "insertAfter",
          "new_api": null,
          "old_text": "entry->getParent()->getBasicBlockList()\n                         .insertAfter(term->getParent(), entry)",
          "new_text": null,
          "old_line_content": "      entry->getParent()->getBasicBlockList()",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 617,
          "old_api": "getParent",
          "new_api": null,
          "old_text": "term->getParent()",
          "new_text": null,
          "old_line_content": "                         .insertAfter(term->getParent(), entry);",
          "new_line_content": "  // If the block has multiple uses, insert it at the next reasonable point.",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": "insertBlockAnywhere",
          "new_api": null,
          "old_text": "IGF.Builder.insertBlockAnywhere(trueEntry)",
          "new_text": null,
          "old_line_content": "    IGF.Builder.insertBlockAnywhere(trueEntry);",
          "new_line_content": "  // Temporarily enter the entry block.",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": "getOutflows",
          "new_api": null,
          "old_text": "cleanup.getOutflows()",
          "new_text": null,
          "old_line_content": "  CleanupOutflows *outflows = cleanup.getOutflows();",
          "new_line_content": "  if (!outflows) {",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": "getOrCreateNextNormalEntryBlock",
          "new_api": null,
          "old_text": "getOrCreateNextNormalEntryBlock(IGF, stack)",
          "new_text": null,
          "old_line_content": "    llvm::BasicBlock *next = getOrCreateNextNormalEntryBlock(IGF, stack);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": "CreateBr",
          "new_api": null,
          "old_text": "IGF.Builder.CreateBr(next)",
          "new_text": null,
          "old_line_content": "    IGF.Builder.CreateBr(next);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": "empty",
          "new_api": null,
          "old_text": "outflows->Outflows.empty()",
          "new_text": null,
          "old_line_content": "  assert(!outflows->Outflows.empty());",
          "new_line_content": "  // It's also straightforward if we have one branch outflow and",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": "size",
          "new_api": null,
          "old_text": "outflows->Outflows.size()",
          "new_text": null,
          "old_line_content": "  if (!cleanup.hasFallthroughOutflow() && outflows->Outflows.size() == 1) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 142,
          "old_api": "CreateXor",
          "new_api": null,
          "old_text": "Builder.CreateXor(V,\n                            llvm::Constant::getIntegerValue(IGM.Int1Ty,\n                                                            llvm::APInt(1, 1)))",
          "new_text": null,
          "old_line_content": "      V = Builder.CreateXor(V,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 143,
          "old_api": "llvm::Constant::getIntegerValue(IGM.Int1Ty,\n                                                            llvm::APInt(1, 1))",
          "new_api": null,
          "old_text": "llvm::Constant::getIntegerValue(IGM.Int1Ty,\n                                                            llvm::APInt(1, 1))",
          "new_text": null,
          "old_line_content": "                            llvm::Constant::getIntegerValue(IGM.Int1Ty,",
          "new_line_content": "    llvm::BasicBlock *falseDestBB;",
          "content_same": false
        },
        {
          "line": 144,
          "old_api": "llvm::APInt(1, 1)",
          "new_api": null,
          "old_text": "llvm::APInt(1, 1)",
          "new_text": null,
          "old_line_content": "                                                            llvm::APInt(1, 1)));",
          "new_line_content": "    if (hasFalseCode) {",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": "CreateBr",
          "new_api": null,
          "old_text": "IGF.Builder.CreateBr(outflows->Outflows[0].DestBlock)",
          "new_text": null,
          "old_line_content": "    IGF.Builder.CreateBr(outflows->Outflows[0].DestBlock);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 146,
          "old_api": "createBasicBlock",
          "new_api": null,
          "old_text": "createBasicBlock(\"condition.cont\")",
          "new_text": null,
          "old_line_content": "    contBB = createBasicBlock(\"condition.cont\");",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 147,
          "old_api": "createBasicBlock",
          "new_api": null,
          "old_text": "createBasicBlock(\"if.true\")",
          "new_text": null,
          "old_line_content": "    trueBB = createBasicBlock(\"if.true\");",
          "new_line_content": "      falseBB = nullptr;",
          "content_same": false
        },
        {
          "line": 151,
          "old_api": "createBasicBlock",
          "new_api": null,
          "old_text": "createBasicBlock(\"if.false\")",
          "new_text": null,
          "old_line_content": "      falseBB = falseDestBB = createBasicBlock(\"if.false\");",
          "new_line_content": "    if (invertValue)",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": "getOrCreateNextNormalEntryBlock",
          "new_api": null,
          "old_text": "getOrCreateNextNormalEntryBlock(IGF, stack)",
          "new_text": null,
          "old_line_content": "    defaultDest = getOrCreateNextNormalEntryBlock(IGF, stack);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": "getUnreachableBlock",
          "new_api": null,
          "old_text": "IGF.getUnreachableBlock()",
          "new_text": null,
          "old_line_content": "    defaultDest = IGF.getUnreachableBlock();",
          "new_line_content": "  llvm::Value *destValue =",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": "getJumpDestAlignment",
          "new_api": null,
          "old_text": "IGF.getJumpDestAlignment()",
          "new_text": null,
          "old_line_content": "    IGF.Builder.CreateLoad(IGF.getJumpDestSlot(), IGF.getJumpDestAlignment(),",
          "new_line_content": "  llvm::SwitchInst *sw =",
          "content_same": false
        },
        {
          "line": 160,
          "old_api": "Condition",
          "new_api": null,
          "old_text": "Condition(trueBB, falseBB, contBB)",
          "new_text": null,
          "old_line_content": "  return Condition(trueBB, falseBB, contBB);",
          "new_line_content": "void Condition::enterTrue(IRGenFunction &IGF) {",
          "content_same": false
        },
        {
          "line": 674,
          "old_api": "size",
          "new_api": null,
          "old_text": "outflows->Outflows.size()",
          "new_text": null,
          "old_line_content": "    IGF.Builder.CreateSwitch(destValue, defaultDest, outflows->Outflows.size());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 164,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(TrueBB)",
          "new_text": null,
          "old_line_content": "  assert(TrueBB);",
          "new_line_content": "  // TrueBB has already been inserted somewhere unless there's a",
          "content_same": false
        },
        {
          "line": 165,
          "old_api": "hasValidIP",
          "new_api": null,
          "old_text": "IGF.Builder.hasValidIP()",
          "new_text": null,
          "old_line_content": "  assert(IGF.Builder.hasValidIP());",
          "new_line_content": "  // continuation block.",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": "addCase",
          "new_api": null,
          "old_text": "sw->addCase(outflow.DestLabel, outflow.DestBlock)",
          "new_text": null,
          "old_line_content": "    sw->addCase(outflow.DestLabel, outflow.DestBlock);",
          "new_line_content": "/// Remove all the dead cleanups on the top of the cleanup stack.",
          "content_same": false
        },
        {
          "line": 171,
          "old_api": "emitBlock",
          "new_api": null,
          "old_text": "IGF.Builder.emitBlock(TrueBB)",
          "new_text": null,
          "old_line_content": "  IGF.Builder.emitBlock(TrueBB);",
          "new_line_content": "void Condition::exitTrue(IRGenFunction &IGF) {",
          "content_same": false
        },
        {
          "line": 685,
          "old_api": "begin",
          "new_api": null,
          "old_text": "stack.begin()->isDead()",
          "new_text": null,
          "old_line_content": "  while (stack.stable_begin() != end && stack.begin()->isDead()) {",
          "new_line_content": "    // We might get better results popping them all at once.",
          "content_same": false
        },
        {
          "line": 689,
          "old_api": "popAndEmitTopCleanup",
          "new_api": null,
          "old_text": "popAndEmitTopCleanup(IGF, stack)",
          "new_text": null,
          "old_line_content": "    popAndEmitTopCleanup(IGF, stack);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 690,
          "old_api": "checkIterator",
          "new_api": null,
          "old_text": "stack.checkIterator(end)",
          "new_text": null,
          "old_line_content": "    stack.checkIterator(end);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 181,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(!FalseBB && \"no continuation\")",
          "new_text": null,
          "old_line_content": "    assert(!FalseBB && \"no continuation\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": "isActive",
          "new_api": null,
          "old_text": "begin->isActive()",
          "new_text": null,
          "old_line_content": "    if (begin->isActive())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 190,
          "old_api": "use_empty",
          "new_api": null,
          "old_text": "ContBB->use_empty()",
          "new_text": null,
          "old_line_content": "    assert(ContBB->use_empty() || !FalseBB);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": "stable_begin",
          "new_api": null,
          "old_text": "Cleanups.stable_begin()",
          "new_text": null,
          "old_line_content": "  if (Cleanups.stable_begin() == depth) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 197,
          "old_api": "CreateBr",
          "new_api": null,
          "old_text": "IGF.Builder.CreateBr(ContBB)",
          "new_text": null,
          "old_line_content": "  IGF.Builder.CreateBr(ContBB);",
          "new_line_content": "  //   - a valid non-terminal IP, but only if there is no continuation",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": "popAndEmitTopDeadCleanups",
          "new_api": null,
          "old_text": "popAndEmitTopDeadCleanups(*this, Cleanups, InnermostScope)",
          "new_text": null,
          "old_line_content": "    popAndEmitTopDeadCleanups(*this, Cleanups, InnermostScope);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": "find",
          "new_api": null,
          "old_text": "Cleanups.find(depth)",
          "new_text": null,
          "old_line_content": "      hasAnyActiveCleanups(Cleanups.begin(), Cleanups.find(depth))) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": "createBasicBlock",
          "new_api": null,
          "old_text": "createBasicBlock(\"cleanups.fallthrough\")",
          "new_text": null,
          "old_line_content": "    contBB = createBasicBlock(\"cleanups.fallthrough\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 207,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(FalseBB && \"entering the false branch when it was not valid\")",
          "new_text": null,
          "old_line_content": "  assert(FalseBB && \"entering the false branch when it was not valid\");",
          "new_line_content": "  // continuation block.",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": "JumpDest",
          "new_api": null,
          "old_text": "JumpDest(contBB, depth)",
          "new_text": null,
          "old_line_content": "    emitBranch(JumpDest(contBB, depth));",
          "new_line_content": "  // Iteratively mark cleanups dead and pop them.",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": "begin",
          "new_api": null,
          "old_text": "Cleanups.begin()->isDead()",
          "new_text": null,
          "old_line_content": "    if (!Cleanups.begin()->isDead())",
          "new_line_content": "    // Pop it.",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": "emitBlockAnywhere",
          "new_api": null,
          "old_text": "IGF.Builder.emitBlockAnywhere(FalseBB)",
          "new_text": null,
          "old_line_content": "  IGF.Builder.emitBlockAnywhere(FalseBB);",
          "new_line_content": "void Condition::exitFalse(IRGenFunction &IGF) {",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": "popAndEmitTopCleanup",
          "new_api": null,
          "old_text": "popAndEmitTopCleanup(*this, Cleanups)",
          "new_text": null,
          "old_line_content": "    popAndEmitTopCleanup(*this, Cleanups);",
          "new_line_content": "  // Emit the continuation block if we made one.",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": "emitMergeableBlock",
          "new_api": null,
          "old_text": "Builder.emitMergeableBlock(contBB)",
          "new_text": null,
          "old_line_content": "    Builder.emitMergeableBlock(contBB);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": "empty",
          "new_api": null,
          "old_text": "Cleanups.empty()",
          "new_text": null,
          "old_line_content": "  assert(!Cleanups.empty() && \"popping empty stack!\");",
          "new_line_content": "         \"popping past innermost scope!\");",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": "use_empty",
          "new_api": null,
          "old_text": "ContBB->use_empty()",
          "new_text": null,
          "old_line_content": "  if (ContBB->use_empty()) {",
          "new_line_content": "  // case doesn't, just merge the continuation block back into its",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "stable_begin",
          "new_api": null,
          "old_text": "Cleanups.stable_begin()",
          "new_text": null,
          "old_line_content": "  assert(Cleanups.stable_begin() != InnermostScope &&",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": "begin",
          "new_api": null,
          "old_text": "Cleanups.begin()",
          "new_text": null,
          "old_line_content": "  endScope(Cleanups.stabilize(llvm::next(Cleanups.begin())));",
          "new_line_content": "/// Initialize a just-pushed cleanup.",
          "content_same": false
        },
        {
          "line": 239,
          "old_api": "hasOneUse",
          "new_api": null,
          "old_text": "ContBB->hasOneUse()",
          "new_text": null,
          "old_line_content": "    assert(ContBB->hasOneUse());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": "unsigned",
          "new_api": null,
          "old_text": "unsigned(state)",
          "new_text": null,
          "old_line_content": "  cleanup.State = unsigned(state);",
          "new_line_content": "  cleanup.HasFallthroughOutflow = false;",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": "getParent",
          "new_api": null,
          "old_text": "Br->getParent()",
          "new_text": null,
          "old_line_content": "    IGF.Builder.SetInsertPoint(Br->getParent());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": "eraseFromParent",
          "new_api": null,
          "old_text": "Br->eraseFromParent()",
          "new_text": null,
          "old_line_content": "    Br->eraseFromParent();",
          "new_line_content": "  // Otherwise, branch to the continuation block and start inserting there.",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": "use_empty",
          "new_api": null,
          "old_text": "ContBB->use_empty()",
          "new_text": null,
          "old_line_content": "    assert(ContBB->use_empty());",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": "CreateBr",
          "new_api": null,
          "old_text": "IGF.Builder.CreateBr(ContBB)",
          "new_text": null,
          "old_line_content": "    IGF.Builder.CreateBr(ContBB);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 763,
          "old_api": "getStableIP",
          "new_api": null,
          "old_text": "Builder.getStableIP()",
          "new_text": null,
          "old_line_content": "  cleanup.setControl(CleanupControl::forIP(Builder.getStableIP()));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 259,
          "old_api": "hasPostTerminatorIP",
          "new_api": null,
          "old_text": "IGF.Builder.hasPostTerminatorIP()",
          "new_text": null,
          "old_line_content": "    assert(!IGF.Builder.hasPostTerminatorIP());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": "find",
          "new_api": null,
          "old_text": "Cleanups.find(depth)",
          "new_text": null,
          "old_line_content": "  auto iter = Cleanups.find(depth);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": "begin",
          "new_api": null,
          "old_text": "Cleanups.begin()",
          "new_text": null,
          "old_line_content": "  if (newState == CleanupState::Dead && iter == Cleanups.begin())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": "popAndEmitTopDeadCleanups",
          "new_api": null,
          "old_text": "popAndEmitTopDeadCleanups(*this, Cleanups, InnermostScope)",
          "new_text": null,
          "old_line_content": "    popAndEmitTopDeadCleanups(*this, Cleanups, InnermostScope);",
          "new_line_content": "void IRGenFunction::setCleanupState(Cleanup &cleanup, CleanupState newState) {",
          "content_same": false
        },
        {
          "line": 266,
          "old_api": "use_empty",
          "new_api": null,
          "old_text": "ContBB->use_empty()",
          "new_text": null,
          "old_line_content": "  if (ContBB->use_empty()) {",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": "hasPostTerminatorIP",
          "new_api": null,
          "old_text": "IGF.Builder.hasPostTerminatorIP()",
          "new_text": null,
          "old_line_content": "    assert(!IGF.Builder.hasPostTerminatorIP());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": "hasValidIP",
          "new_api": null,
          "old_text": "Builder.hasValidIP()",
          "new_text": null,
          "old_line_content": "  assert((newState != CleanupState::Active || Builder.hasValidIP()) &&",
          "new_line_content": "  // Do the transition now to avoid doing it in N places below.",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": "setState",
          "new_api": null,
          "old_text": "cleanup.setState(newState)",
          "new_text": null,
          "old_line_content": "  cleanup.setState(newState);",
          "new_line_content": "  switch (oldState) {",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": "hasValidIP",
          "new_api": null,
          "old_text": "IGF.Builder.hasValidIP()",
          "new_text": null,
          "old_line_content": "         (!FalseBB && !IGF.Builder.hasValidIP()));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": "emitBlockAnywhere",
          "new_api": null,
          "old_text": "IGF.Builder.emitBlockAnywhere(ContBB)",
          "new_text": null,
          "old_line_content": "  IGF.Builder.emitBlockAnywhere(ContBB);",
          "new_line_content": "/// Get or create the jump-destination variable.",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "llvm_unreachable",
          "new_api": null,
          "old_text": "llvm_unreachable(\"changing state of dead cleanup\")",
          "new_text": null,
          "old_line_content": "    llvm_unreachable(\"changing state of dead cleanup\");",
          "new_line_content": "  case CleanupState::Dormant:",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": "llvm_unreachable",
          "new_api": null,
          "old_text": "llvm_unreachable(\"no transition\")",
          "new_text": null,
          "old_line_content": "    case CleanupState::Dormant: llvm_unreachable(\"no transition\");",
          "new_line_content": "    // This isn't a state transition we need to do anything about,",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": "createBasicBlock",
          "new_api": null,
          "old_text": "createBasicBlock(\"unreachable\")",
          "new_text": null,
          "old_line_content": "  UnreachableBB = createBasicBlock(\"unreachable\");",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": "getContext",
          "new_api": null,
          "old_text": "UnreachableBB->getContext()",
          "new_text": null,
          "old_line_content": "  new llvm::UnreachableInst(UnreachableBB->getContext(), UnreachableBB);",
          "new_line_content": "  return UnreachableBB;",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "CurFn->getBasicBlockList().push_back(UnreachableBB)",
          "new_text": null,
          "old_line_content": "  CurFn->getBasicBlockList().push_back(UnreachableBB);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": "hasFlag",
          "new_api": null,
          "old_text": "control.hasFlag()",
          "new_text": null,
          "old_line_content": "      if (control.hasFlag()) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": "getFlag",
          "new_api": null,
          "old_text": "control.getFlag()",
          "new_text": null,
          "old_line_content": "        setFlagNow(*this, control.getFlag(), true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": "isUsedWhileInactive",
          "new_api": null,
          "old_text": "cleanup.isUsedWhileInactive()",
          "new_text": null,
          "old_line_content": "      if (cleanup.isUsedWhileActive() && cleanup.isUsedWhileInactive()) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 818,
          "old_api": "transitionControlToFlag",
          "new_api": null,
          "old_text": "transitionControlToFlag(*this, cleanup)",
          "new_text": null,
          "old_line_content": "        transitionControlToFlag(*this, cleanup);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": "CreateCall",
          "new_api": null,
          "old_text": "Builder.CreateCall(fn, args)",
          "new_text": null,
          "old_line_content": "  llvm::CallInst *call = Builder.CreateCall(fn, args);",
          "new_line_content": "  return call;",
          "content_same": false
        },
        {
          "line": 311,
          "old_api": "setAttributes",
          "new_api": null,
          "old_text": "call->setAttributes(attrs)",
          "new_text": null,
          "old_line_content": "  call->setAttributes(attrs);",
          "new_line_content": "}                                        ",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": "setCallingConv",
          "new_api": null,
          "old_text": "call->setCallingConv(convention)",
          "new_text": null,
          "old_line_content": "  call->setCallingConv(convention);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": "isUsedWhileInactive",
          "new_api": null,
          "old_text": "cleanup.isUsedWhileInactive()",
          "new_text": null,
          "old_line_content": "      if (!cleanup.isUsedWhileInactive())",
          "new_line_content": "      // Otherwise, we have uses while inactive but none while active.",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "isUsedWhileActive",
          "new_api": null,
          "old_text": "cleanup.isUsedWhileActive()",
          "new_text": null,
          "old_line_content": "      assert(!cleanup.isUsedWhileActive());",
          "new_line_content": "      return;",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": "getIPEnd",
          "new_api": null,
          "old_text": "control.getIPEnd()",
          "new_text": null,
          "old_line_content": "      cleanup.setControl(CleanupControl::forIPRange(control.getIPEnd(),",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": "getStableIP",
          "new_api": null,
          "old_text": "Builder.getStableIP()",
          "new_text": null,
          "old_line_content": "                                                    Builder.getStableIP()));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": "llvm_unreachable",
          "new_api": null,
          "old_text": "llvm_unreachable(\"bad cleanup state\")",
          "new_text": null,
          "old_line_content": "    llvm_unreachable(\"bad cleanup state\");",
          "new_line_content": "  // The code is the same either way.",
          "content_same": false
        },
        {
          "line": 845,
          "old_api": "hasValidIP",
          "new_api": null,
          "old_text": "Builder.hasValidIP()",
          "new_text": null,
          "old_line_content": "      if (Builder.hasValidIP())",
          "new_line_content": "      return;",
          "content_same": false
        },
        {
          "line": 846,
          "old_api": "getFlag",
          "new_api": null,
          "old_text": "control.getFlag()",
          "new_text": null,
          "old_line_content": "        setFlagNow(*this, control.getFlag(), false);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 341,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "Outflows.push_back(outflow)",
          "new_text": null,
          "old_line_content": "    Outflows.push_back(outflow);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 855,
          "old_api": "isUsedWhileInactive",
          "new_api": null,
          "old_text": "cleanup.isUsedWhileInactive()",
          "new_text": null,
          "old_line_content": "    if (cleanup.isUsedWhileActive() && cleanup.isUsedWhileInactive()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": "transitionControlToFlag",
          "new_api": null,
          "old_text": "transitionControlToFlag(*this, cleanup)",
          "new_text": null,
          "old_line_content": "      transitionControlToFlag(*this, cleanup);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 346,
          "old_api": "getOutflows",
          "new_api": null,
          "old_text": "cleanup.getOutflows()",
          "new_text": null,
          "old_line_content": "  CleanupOutflows *outs = cleanup.getOutflows();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 347,
          "old_api": "setOutflows",
          "new_api": null,
          "old_text": "cleanup.setOutflows(outs = new CleanupOutflows())",
          "new_text": null,
          "old_line_content": "  if (!outs) cleanup.setOutflows(outs = new CleanupOutflows());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": "isUsedWhileActive",
          "new_api": null,
          "old_text": "cleanup.isUsedWhileActive()",
          "new_text": null,
          "old_line_content": "    if (cleanup.isUsedWhileActive()) {",
          "new_line_content": "    // Otherwise, we have uses while active but none while inactive.",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": "isUsedWhileInactive",
          "new_api": null,
          "old_text": "cleanup.isUsedWhileInactive()",
          "new_text": null,
          "old_line_content": "      assert(!cleanup.isUsedWhileInactive());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": "getIPEnd",
          "new_api": null,
          "old_text": "control.getIPEnd()",
          "new_text": null,
          "old_line_content": "      cleanup.setControl(CleanupControl::forIPRange(control.getIPEnd(),",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": "getStableIP",
          "new_api": null,
          "old_text": "Builder.getStableIP()",
          "new_text": null,
          "old_line_content": "                                                    Builder.getStableIP()));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": "llvm_unreachable",
          "new_api": null,
          "old_text": "llvm_unreachable(\"bad cleanup state\")",
          "new_text": null,
          "old_line_content": "  llvm_unreachable(\"bad cleanup state\");",
          "new_line_content": "/// Emit a branch to the given jump destination, threading out through",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": "hasValidIP",
          "new_api": null,
          "old_text": "Builder.hasValidIP()",
          "new_text": null,
          "old_line_content": "  assert(Builder.hasValidIP());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": "begin",
          "new_api": null,
          "old_text": "Cleanups.begin()",
          "new_text": null,
          "old_line_content": "  auto it = Cleanups.begin();",
          "new_line_content": "      break;",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": "isActive",
          "new_api": null,
          "old_text": "it->isActive()",
          "new_text": null,
          "old_line_content": "    if (it->isActive())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": "getBlock",
          "new_api": null,
          "old_text": "dest.getBlock()",
          "new_text": null,
          "old_line_content": "    Builder.CreateBr(dest.getBlock());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 391,
          "old_api": "forIPRange",
          "new_api": null,
          "old_text": "forIPRange(begin, begin)",
          "new_text": null,
          "old_line_content": "    return forIPRange(begin, begin);",
          "new_line_content": "  bool hasFlag() const { return Flag != nullptr; }",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": "hasFlag",
          "new_api": null,
          "old_text": "hasFlag()",
          "new_text": null,
          "old_line_content": "  llvm::AllocaInst *getFlag() const { assert(hasFlag()); return Flag; }",
          "new_line_content": "    return IPBegin;",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": "isActive",
          "new_api": null,
          "old_text": "it->isActive()",
          "new_text": null,
          "old_line_content": "    if (it->isActive())",
          "new_line_content": "    // Keep track of the biggest label that any of the cleanups we're",
          "content_same": false
        },
        {
          "line": 397,
          "old_api": "hasFlag",
          "new_api": null,
          "old_text": "hasFlag()",
          "new_text": null,
          "old_line_content": "    assert(!hasFlag());",
          "new_line_content": "  IRBuilder::StableIP getIPEnd() const {",
          "content_same": false
        },
        {
          "line": 401,
          "old_api": "hasFlag",
          "new_api": null,
          "old_text": "hasFlag()",
          "new_text": null,
          "old_line_content": "    assert(!hasFlag());",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 915,
          "old_api": "getNextDestLabel",
          "new_api": null,
          "old_text": "it->getNextDestLabel()",
          "new_text": null,
          "old_line_content": "    destLabel = std::max(destLabel, it->getNextDestLabel());",
          "new_line_content": "    if (next == depth) break;",
          "content_same": false
        },
        {
          "line": 411,
          "old_api": "CleanupControl::forIPRange(\n               IRBuilder::StableIP::getFromOpaqueValue(ControlBegin),\n               IRBuilder::StableIP::getFromOpaqueValue(ControlEnd))",
          "new_api": null,
          "old_text": "CleanupControl::forIPRange(\n               IRBuilder::StableIP::getFromOpaqueValue(ControlBegin),\n               IRBuilder::StableIP::getFromOpaqueValue(ControlEnd))",
          "new_text": null,
          "old_line_content": "  return CleanupControl::forIPRange(",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 412,
          "old_api": "IRBuilder::StableIP::getFromOpaqueValue(ControlBegin)",
          "new_api": null,
          "old_text": "IRBuilder::StableIP::getFromOpaqueValue(ControlBegin)",
          "new_text": null,
          "old_line_content": "               IRBuilder::StableIP::getFromOpaqueValue(ControlBegin),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": "IRBuilder::StableIP::getFromOpaqueValue(ControlEnd)",
          "new_api": null,
          "old_text": "IRBuilder::StableIP::getFromOpaqueValue(ControlEnd)",
          "new_text": null,
          "old_line_content": "               IRBuilder::StableIP::getFromOpaqueValue(ControlEnd));",
          "new_line_content": "void Cleanup::setControl(const CleanupControl &control) {",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": "isActive",
          "new_api": null,
          "old_text": "outermost->isActive()",
          "new_text": null,
          "old_line_content": "  assert(outermost->isActive());",
          "new_line_content": "  // destination and cleanups.",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": "hasFlag",
          "new_api": null,
          "old_text": "control.hasFlag()",
          "new_text": null,
          "old_line_content": "  if (control.hasFlag()) {",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": "llvm::ConstantInt::get(IGM.Int32Ty,\n                                                         destLabel)",
          "new_api": null,
          "old_text": "llvm::ConstantInt::get(IGM.Int32Ty,\n                                                         destLabel)",
          "new_text": null,
          "old_line_content": "  llvm::ConstantInt *labelValue = llvm::ConstantInt::get(IGM.Int32Ty,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": "getIPBegin",
          "new_api": null,
          "old_text": "control.getIPBegin().getOpaqueValue()",
          "new_text": null,
          "old_line_content": "    ControlBegin = control.getIPBegin().getOpaqueValue();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": "getIPEnd",
          "new_api": null,
          "old_text": "control.getIPEnd().getOpaqueValue()",
          "new_text": null,
          "old_line_content": "    ControlEnd = control.getIPEnd().getOpaqueValue();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": "addActiveUse",
          "new_api": null,
          "old_text": "outermost->addActiveUse()",
          "new_text": null,
          "old_line_content": "  outermost->addActiveUse();",
          "new_line_content": "  // Set the destination and branch to the innermost cleanup.",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": "getJumpDestAlignment",
          "new_api": null,
          "old_text": "getJumpDestAlignment()",
          "new_text": null,
          "old_line_content": "  Builder.CreateStore(labelValue, getJumpDestSlot(), getJumpDestAlignment());",
          "new_line_content": "  // Walk through the intermediate cleanups again and add fallthrough outflows.",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": "hasValidIP",
          "new_api": null,
          "old_text": "IGF.Builder.hasValidIP()",
          "new_text": null,
          "old_line_content": "  assert(IGF.Builder.hasValidIP());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": "Alignment",
          "new_api": null,
          "old_text": "Alignment(1)",
          "new_text": null,
          "old_line_content": "  IGF.Builder.CreateStore(IGF.Builder.getInt1(value), flag, Alignment(1));",
          "new_line_content": "/// Alter a control flag at the given stable insertion point.",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": "getOrCreateNormalEntryBlock",
          "new_api": null,
          "old_text": "getOrCreateNormalEntryBlock(*this, *innermost)",
          "new_text": null,
          "old_line_content": "  Builder.CreateBr(getOrCreateNormalEntryBlock(*this, *innermost));",
          "new_line_content": "  for (it = innermost; it != outermost; ++it) {",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": "addUse",
          "new_api": null,
          "old_text": "it->addUse()",
          "new_text": null,
          "old_line_content": "    it->addUse();",
          "new_line_content": "    // And tell each cleanup that the new label value has been reserved.",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": "isValid",
          "new_api": null,
          "old_text": "ip.isValid()",
          "new_text": null,
          "old_line_content": "  if (!ip.isValid()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 437,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(value == false && \"activation point is unreachable!\")",
          "new_text": null,
          "old_line_content": "    assert(value == false && \"activation point is unreachable!\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": "setNextDestLabel",
          "new_api": null,
          "old_text": "it->setNextDestLabel(destLabel + 1)",
          "new_text": null,
          "old_line_content": "    it->setNextDestLabel(destLabel + 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 442,
          "old_api": "getInt1",
          "new_api": null,
          "old_text": "IGF.Builder.getInt1(value)",
          "new_text": null,
          "old_line_content": "    new llvm::StoreInst(IGF.Builder.getInt1(value), flag);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": "setAlignment",
          "new_api": null,
          "old_text": "store->setAlignment(1)",
          "new_text": null,
          "old_line_content": "  store->setAlignment(1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": "insert",
          "new_api": null,
          "old_text": "ip.insert(store)",
          "new_text": null,
          "old_line_content": "  ip.insert(store);",
          "new_line_content": "/// Create a control flag and set it on a cleanup.",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": "Alignment",
          "new_api": null,
          "old_text": "Alignment(1)",
          "new_text": null,
          "old_line_content": "    IGF.createSupportAlloca(IGF.IGM.Int1Ty, Alignment(1), \"cleanup.isactive\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": "CleanupControl::forFlag(flag)",
          "new_api": null,
          "old_text": "CleanupControl::forFlag(flag)",
          "new_text": null,
          "old_line_content": "  cleanup.setControl(CleanupControl::forFlag(flag));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": "hasFlag",
          "new_api": null,
          "old_text": "control.hasFlag()",
          "new_text": null,
          "old_line_content": "  assert(!control.hasFlag());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": "getIPEnd",
          "new_api": null,
          "old_text": "control.getIPEnd()",
          "new_text": null,
          "old_line_content": "  setFlagThen(IGF, control.getIPEnd(), flag, !isActiveNow);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": "hasValidIP",
          "new_api": null,
          "old_text": "IGF.Builder.hasValidIP()",
          "new_text": null,
          "old_line_content": "  if (IGF.Builder.hasValidIP())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": "setFlagNow",
          "new_api": null,
          "old_text": "setFlagNow(IGF, flag, isActiveNow)",
          "new_text": null,
          "old_line_content": "    setFlagNow(IGF, flag, isActiveNow);",
          "new_line_content": "namespace {",
          "content_same": false
        },
        {
          "line": 478,
          "old_api": "allocated_size",
          "new_api": null,
          "old_text": "cleanup.allocated_size()",
          "new_text": null,
          "old_line_content": "      size_t size = cleanup.allocated_size();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 479,
          "old_api": "set_size",
          "new_api": null,
          "old_text": "Data.set_size(size)",
          "new_text": null,
          "old_line_content": "      Data.set_size(size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": "data",
          "new_api": null,
          "old_text": "Data.data()",
          "new_text": null,
          "old_line_content": "    Cleanup &getCopy() { return *reinterpret_cast<Cleanup*>(Data.data()); }",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": "createBasicBlock",
          "new_api": null,
          "old_text": "IGF.createBasicBlock(\"cleanup\")",
          "new_text": null,
          "old_line_content": "  block = IGF.createBasicBlock(\"cleanup\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": "setNormalEntryBlock",
          "new_api": null,
          "old_text": "cleanup.setNormalEntryBlock(block)",
          "new_text": null,
          "old_line_content": "  cleanup.setNormalEntryBlock(block);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 511,
          "old_api": "getOutflows",
          "new_api": null,
          "old_text": "cleanup.getOutflows()",
          "new_text": null,
          "old_line_content": "    assert(!cleanup.getOutflows());",
          "new_line_content": "  // We can't get out here because the existence of fallthroughs",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 46,
      "total_additions": 155,
      "total_deletions": 157,
      "total_api_changes": 358
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 11,
        "api_related_lines": 358,
        "non_api_lines": 1,
        "non_api_line_numbers": [
          153
        ]
      }
    },
    "api_calls_before": 324,
    "api_calls_after": 322,
    "diff_info": {
      "added_lines": 4,
      "removed_lines": 7,
      "total_diff_lines": 30
    }
  }
}