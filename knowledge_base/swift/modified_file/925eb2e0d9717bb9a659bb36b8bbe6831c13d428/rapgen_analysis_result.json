{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/925eb2e0d9717bb9a659bb36b8bbe6831c13d428",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/925eb2e0d9717bb9a659bb36b8bbe6831c13d428/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/925eb2e0d9717bb9a659bb36b8bbe6831c13d428/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/925eb2e0d9717bb9a659bb36b8bbe6831c13d428/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 570,
          "old_api": "std::next(Iter)",
          "new_api": "pred_begin",
          "old_text": "std::next(Iter)",
          "new_text": "BB->pred_begin()",
          "old_line_content": "  Iter = std::next(Iter);",
          "new_line_content": "  auto Iter = BB->pred_begin();",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": "pred_end",
          "new_api": "getBlockState",
          "old_text": "BB->pred_end()",
          "new_text": "Ctx.getBlockState(*Iter)",
          "old_line_content": "  for (auto EndIter = BB->pred_end(); Iter != EndIter; ++Iter) {",
          "new_line_content": "  ForwardSetMax = Ctx.getBlockState(*Iter).ForwardSetMax;",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": "getBlockState",
          "new_api": "std::next(Iter)",
          "old_text": "Ctx.getBlockState(*Iter)",
          "new_text": "std::next(Iter)",
          "old_line_content": "    ForwardSetMax &= Ctx.getBlockState(*Iter).ForwardSetMax;",
          "new_line_content": "  Iter = std::next(Iter);",
          "content_same": false
        },
        {
          "line": 585,
          "old_api": "std::next(Iter)",
          "new_api": "pred_begin",
          "old_text": "std::next(Iter)",
          "new_text": "BB->pred_begin()",
          "old_line_content": "  Iter = std::next(Iter);",
          "new_line_content": "  auto Iter = BB->pred_begin();",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": "pred_end",
          "new_api": "getBlockState",
          "old_text": "BB->pred_end()",
          "new_text": "Ctx.getBlockState(*Iter)",
          "old_line_content": "  for (auto EndIter = BB->pred_end(); Iter != EndIter; ++Iter) {",
          "new_line_content": "  ForwardSetIn = Ctx.getBlockState(*Iter).ForwardSetOut;",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": "getBlockState",
          "new_api": "std::next(Iter)",
          "old_text": "Ctx.getBlockState(*Iter)",
          "new_text": "std::next(Iter)",
          "old_line_content": "    ForwardSetIn &= Ctx.getBlockState(*Iter).ForwardSetOut;",
          "new_line_content": "  Iter = std::next(Iter);",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "clear",
          "new_api": "end",
          "old_text": "ForwardValIn.clear()",
          "new_text": "BB->getPreds().end()",
          "old_line_content": "    ForwardValIn.clear();",
          "new_line_content": "  if (BB->getPreds().begin() == BB->getPreds().end()) {",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": "getBlockState",
          "new_api": "pred_begin",
          "old_text": "Ctx.getBlockState(*Iter)",
          "new_text": "BB->pred_begin()",
          "old_line_content": "  ForwardValIn = Ctx.getBlockState(*Iter).ForwardValOut;",
          "new_line_content": "  auto Iter = BB->pred_begin();",
          "content_same": false
        },
        {
          "line": 602,
          "old_api": "std::next(Iter)",
          "new_api": "getBlockState",
          "old_text": "std::next(Iter)",
          "new_text": "Ctx.getBlockState(*Iter)",
          "old_line_content": "  Iter = std::next(Iter);",
          "new_line_content": "  ForwardSetIn = Ctx.getBlockState(*Iter).ForwardSetOut;",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": "pred_end",
          "new_api": "getBlockState",
          "old_text": "BB->pred_end()",
          "new_text": "Ctx.getBlockState(*Iter)",
          "old_line_content": "  for (auto EndIter = BB->pred_end(); Iter != EndIter; ++Iter) {",
          "new_line_content": "  ForwardValIn = Ctx.getBlockState(*Iter).ForwardValOut;",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": "getBlockState",
          "new_api": "std::next(Iter)",
          "old_text": "Ctx.getBlockState(*Iter)",
          "new_text": "std::next(Iter)",
          "old_line_content": "    BlockState &OtherState = Ctx.getBlockState(*Iter);",
          "new_line_content": "  Iter = std::next(Iter);",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": "updateForwardSetOut",
          "new_api": "reset",
          "old_text": "updateForwardSetOut()",
          "new_text": "ForwardSetIn.reset(BBKillSet)",
          "old_line_content": "  return updateForwardSetOut();",
          "new_line_content": "  ForwardSetIn.reset(BBKillSet);",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": "getLocationBit",
          "new_api": "getForwardValOut",
          "old_text": "Ctx.getLocationBit(Locs[i])",
          "new_text": "getForwardValOut()",
          "old_line_content": "    Values[Locs[i]] = Ctx.getValue(OTM[Ctx.getLocationBit(Locs[i])]);",
          "new_line_content": "  ValueTableMap &OTM = getForwardValOut();",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": "isTrackingLocation",
          "new_api": "getLocation",
          "old_text": "isTrackingLocation(ForwardSetMax, i)",
          "new_text": "Ctx.getLocation(B)",
          "old_line_content": "    if (!isTrackingLocation(ForwardSetMax, i))",
          "new_line_content": "  LSLocation &R = Ctx.getLocation(B);",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": "getLocation",
          "new_api": "isTrackingLocation",
          "old_text": "Ctx.getLocation(i)",
          "new_text": "isTrackingLocation(ForwardSetMax, i)",
          "old_line_content": "    LSLocation &L = Ctx.getLocation(i);",
          "new_line_content": "    if (!isTrackingLocation(ForwardSetMax, i))",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": "isTrackingLocation",
          "new_api": "getLocation",
          "old_text": "isTrackingLocation(ForwardSetIn, i)",
          "new_text": "Ctx.getLocation(B)",
          "old_line_content": "    if (!isTrackingLocation(ForwardSetIn, i))",
          "new_line_content": "  LSLocation &R = Ctx.getLocation(B);",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": "getLocation",
          "new_api": "isTrackingLocation",
          "old_text": "Ctx.getLocation(i)",
          "new_text": "isTrackingLocation(ForwardSetIn, i)",
          "old_line_content": "    LSLocation &L = Ctx.getLocation(i);",
          "new_line_content": "    if (!isTrackingLocation(ForwardSetIn, i))",
          "content_same": false
        },
        {
          "line": 778,
          "old_api": "isTrackingLocation",
          "new_api": "getLocation",
          "old_text": "isTrackingLocation(ForwardSetIn, i)",
          "new_text": "Ctx.getLocation(L)",
          "old_line_content": "    if (!isTrackingLocation(ForwardSetIn, i))",
          "new_line_content": "  LSLocation &R = Ctx.getLocation(L);",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": "getLocation",
          "new_api": "isTrackingLocation",
          "old_text": "Ctx.getLocation(i)",
          "new_text": "isTrackingLocation(ForwardSetIn, i)",
          "old_line_content": "    LSLocation &L = Ctx.getLocation(i);",
          "new_line_content": "    if (!isTrackingLocation(ForwardSetIn, i))",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": "isComputeAvailSetMax",
          "new_api": "getTE",
          "old_text": "isComputeAvailSetMax(Kind)",
          "new_text": "Ctx.getTE()",
          "old_line_content": "  if (isComputeAvailSetMax(Kind)) {",
          "new_line_content": "  LSLocation::expand(L, &I->getModule(), Locs, Ctx.getTE());",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": "getLocationBit",
          "new_api": "isComputeAvailSetMax",
          "old_text": "Ctx.getLocationBit(Locs[i])",
          "new_text": "isComputeAvailSetMax(Kind)",
          "old_line_content": "      updateMaxAvailSetForWrite(Ctx, Ctx.getLocationBit(Locs[i]));",
          "new_line_content": "  if (isComputeAvailSetMax(Kind)) {",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": "getLocationBit",
          "new_api": "isComputeAvailGenKillSet",
          "old_text": "Ctx.getLocationBit(Locs[i])",
          "new_text": "isComputeAvailGenKillSet(Kind)",
          "old_line_content": "      updateGenKillSetForWrite(Ctx, Ctx.getLocationBit(Locs[i]));",
          "new_line_content": "  if (isComputeAvailGenKillSet(Kind)) {",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": "size",
          "new_api": "getTE",
          "old_text": "Locs.size()",
          "new_text": "Ctx.getTE()",
          "old_line_content": "    for (unsigned i = 0; i < Locs.size(); ++i) {",
          "new_line_content": "  LSValue::expand(Val, &I->getModule(), Vals, Ctx.getTE());",
          "content_same": false
        },
        {
          "line": 841,
          "old_api": "getLocationBit",
          "new_api": "isPerformingRLE",
          "old_text": "Ctx.getLocationBit(Locs[i])",
          "new_text": "isPerformingRLE(Kind)",
          "old_line_content": "      updateForwardSetAndValForWrite(Ctx, Ctx.getLocationBit(Locs[i]),",
          "new_line_content": "  if (isComputeAvailValue(Kind) || isPerformingRLE(Kind)) {",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": "getValueBit",
          "new_api": "size",
          "old_text": "Ctx.getValueBit(Vals[i])",
          "new_text": "Locs.size()",
          "old_line_content": "                                     Ctx.getValueBit(Vals[i]));",
          "new_line_content": "    for (unsigned i = 0; i < Locs.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": "isComputeAvailSetMax",
          "new_api": "getTE",
          "old_text": "isComputeAvailSetMax(Kind)",
          "new_text": "Ctx.getTE()",
          "old_line_content": "  if (isComputeAvailSetMax(Kind)) {",
          "new_line_content": "  LSLocation::expand(L, &I->getModule(), Locs, Ctx.getTE());",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": "getLocationBit",
          "new_api": "isComputeAvailSetMax",
          "old_text": "Ctx.getLocationBit(Locs[i])",
          "new_text": "isComputeAvailSetMax(Kind)",
          "old_line_content": "      updateMaxAvailSetForRead(Ctx, Ctx.getLocationBit(Locs[i]));",
          "new_line_content": "  if (isComputeAvailSetMax(Kind)) {",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": "getLocationBit",
          "new_api": "isComputeAvailGenKillSet",
          "old_text": "Ctx.getLocationBit(Locs[i])",
          "new_text": "isComputeAvailGenKillSet(Kind)",
          "old_line_content": "      updateGenKillSetForRead(Ctx, Ctx.getLocationBit(Locs[i]));",
          "new_line_content": "  if (isComputeAvailGenKillSet(Kind)) {",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": "size",
          "new_api": "getTE",
          "old_text": "Locs.size()",
          "new_text": "Ctx.getTE()",
          "old_line_content": "    for (unsigned i = 0; i < Locs.size(); ++i) {",
          "new_line_content": "  LSValue::expand(Val, &I->getModule(), Vals, Ctx.getTE());",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": "getLocationBit",
          "new_api": "isPerformingRLE",
          "old_text": "Ctx.getLocationBit(Locs[i])",
          "new_text": "isPerformingRLE(Kind)",
          "old_line_content": "      if (isTrackingLocation(ForwardSetIn, Ctx.getLocationBit(Locs[i])))",
          "new_line_content": "  if (isComputeAvailValue(Kind) || isPerformingRLE(Kind)) {",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": "isTrackingLocation",
          "new_api": "getAA",
          "old_text": "isTrackingLocation(ForwardSetMax, i)",
          "new_text": "Ctx.getAA()",
          "old_line_content": "    if (!isTrackingLocation(ForwardSetMax, i))",
          "new_line_content": "  auto *AA = Ctx.getAA();",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": "isTrackingLocation",
          "new_api": "getAA",
          "old_text": "isTrackingLocation(ForwardSetIn, i)",
          "new_text": "Ctx.getAA()",
          "old_line_content": "    if (!isTrackingLocation(ForwardSetIn, i))",
          "new_line_content": "  auto *AA = Ctx.getAA();",
          "content_same": false
        },
        {
          "line": 1021,
          "old_api": "getReversePostOrder",
          "new_api": "get",
          "old_text": "PO->getReversePostOrder()",
          "new_text": "PM->getAnalysis<PostOrderAnalysis>()->get(Fn)",
          "old_line_content": "  for (SILBasicBlock *B : PO->getReversePostOrder()) {",
          "new_line_content": "  auto *PO = PM->getAnalysis<PostOrderAnalysis>()->get(Fn);",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": "getPreds",
          "new_api": "getReversePostOrder",
          "old_text": "B->getPreds()",
          "new_text": "PO->getReversePostOrder()",
          "old_line_content": "    for (auto X : B->getPreds()) {",
          "new_line_content": "  for (SILBasicBlock *B : PO->getReversePostOrder()) {",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": "push_back",
          "new_api": "end",
          "old_text": "LSValueVault.push_back(Val)",
          "new_text": "ValToBitIndex.end()",
          "old_line_content": "    LSValueVault.push_back(Val);",
          "new_line_content": "  if (Iter == ValToBitIndex.end()) {",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": "getForwardValOut",
          "new_api": "getTE",
          "old_text": "getForwardValOut()",
          "new_text": "Ctx.getTE()",
          "old_line_content": "  ValueTableMap &OTM = getForwardValOut();",
          "new_line_content": "  LSLocation::expand(L, &BB->getModule(), Locs, Ctx.getTE());",
          "content_same": false
        },
        {
          "line": 1103,
          "old_api": "getLocationBit",
          "new_api": "getForwardValOut",
          "old_text": "Ctx.getLocationBit(X)",
          "new_text": "getForwardValOut()",
          "old_line_content": "    LSValue &V = Ctx.getValue(OTM[Ctx.getLocationBit(X)]);",
          "new_line_content": "  ValueTableMap &OTM = getForwardValOut();",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": "getBlockState",
          "new_api": "empty",
          "old_text": "getBlockState(CurBB)",
          "new_text": "WorkList.empty()",
          "old_line_content": "    BlockState &Forwarder = getBlockState(CurBB);",
          "new_line_content": "  while (!WorkList.empty()) {",
          "content_same": false
        },
        {
          "line": 1157,
          "old_api": "end",
          "new_api": "isCoverValues",
          "old_text": "HandledBBs.end()",
          "new_text": "Forwarder.isCoverValues(*this, L)",
          "old_line_content": "        if (HandledBBs.find(Pred) != HandledBBs.end())",
          "new_line_content": "    if (Forwarder.isCoverValues(*this, L)) {",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": "push_back",
          "new_api": "end",
          "old_text": "WorkList.push_back(Pred)",
          "new_text": "HandledBBs.end()",
          "old_line_content": "        WorkList.push_back(Pred);",
          "new_line_content": "        if (HandledBBs.find(Pred) != HandledBBs.end())",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": "AddAvailableValue",
          "new_api": "getModule",
          "old_text": "Updater.AddAvailableValue(V.first, V.second)",
          "new_text": "BB->getModule()",
          "old_line_content": "    Updater.AddAvailableValue(V.first, V.second);",
          "new_line_content": "  Updater.Initialize(L.getType(&BB->getModule()).getObjectType());",
          "content_same": false
        },
        {
          "line": 1200,
          "old_api": "insert",
          "new_api": "isCoveringValue",
          "old_text": "CSLocs.insert(X)",
          "new_text": "Values[X].isCoveringValue()",
          "old_line_content": "    CSLocs.insert(X);",
          "new_line_content": "    if (!Values[X].isCoveringValue())",
          "content_same": false
        },
        {
          "line": 1222,
          "old_api": "size",
          "new_api": "LSValue::expand(V, Mod, Vals, TE)",
          "old_text": "Locs.size()",
          "new_text": "LSValue::expand(V, Mod, Vals, TE)",
          "old_line_content": "    for (unsigned i = 0; i < Locs.size(); ++i) {",
          "new_line_content": "    LSValue::expand(V, Mod, Vals, TE);",
          "content_same": false
        },
        {
          "line": 1224,
          "old_api": "isValid",
          "new_api": "size",
          "old_text": "Values[Locs[i]].isValid()",
          "new_text": "Locs.size()",
          "old_line_content": "      assert(Values[Locs[i]].isValid() && \"Invalid load store value\");",
          "new_line_content": "    for (unsigned i = 0; i < Locs.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": "processLoadInst",
          "new_api": "end",
          "old_text": "S.processLoadInst(*this, LI, RLEKind::ComputeAvailSetMax)",
          "new_text": "BB->end()",
          "old_line_content": "        S.processLoadInst(*this, LI, RLEKind::ComputeAvailSetMax);",
          "new_line_content": "    for (auto I = BB->begin(), E = BB->end(); I != E; ++I) {",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": "dyn_cast<StoreInst>(&*I)",
          "new_api": "processLoadInst",
          "old_text": "dyn_cast<StoreInst>(&*I)",
          "new_text": "S.processLoadInst(*this, LI, RLEKind::ComputeAvailSetMax)",
          "old_line_content": "      if (auto *SI = dyn_cast<StoreInst>(&*I)) {",
          "new_line_content": "        S.processLoadInst(*this, LI, RLEKind::ComputeAvailSetMax);",
          "content_same": false
        },
        {
          "line": 1265,
          "old_api": "insert",
          "new_api": "getPostOrder",
          "old_text": "HandledBBs.insert(BB)",
          "new_text": "PO->getPostOrder()",
          "old_line_content": "    HandledBBs.insert(BB);",
          "new_line_content": "  for (SILBasicBlock *BB : PO->getPostOrder()) {",
          "content_same": false
        },
        {
          "line": 1267,
          "old_api": "empty",
          "new_api": "insert",
          "old_text": "WorkList.empty()",
          "new_text": "HandledBBs.insert(BB)",
          "old_line_content": "  while (!WorkList.empty()) {",
          "new_line_content": "    HandledBBs.insert(BB);",
          "content_same": false
        },
        {
          "line": 1269,
          "old_api": "erase",
          "new_api": "empty",
          "old_text": "HandledBBs.erase(BB)",
          "new_text": "WorkList.empty()",
          "old_line_content": "    HandledBBs.erase(BB);",
          "new_line_content": "  while (!WorkList.empty()) {",
          "content_same": false
        },
        {
          "line": 1274,
          "old_api": "mergePredecessorAvailSet",
          "new_api": "getBlockState",
          "old_text": "Forwarder.mergePredecessorAvailSet(*this)",
          "new_text": "getBlockState(BB)",
          "old_line_content": "    Forwarder.mergePredecessorAvailSet(*this);",
          "new_line_content": "    BlockState &Forwarder = getBlockState(BB);",
          "content_same": false
        },
        {
          "line": 1276,
          "old_api": "processBasicBlockWithGenKillSet",
          "new_api": "mergePredecessorAvailSet",
          "old_text": "Forwarder.processBasicBlockWithGenKillSet()",
          "new_text": "Forwarder.mergePredecessorAvailSet(*this)",
          "old_line_content": "    if (Forwarder.processBasicBlockWithGenKillSet()) {",
          "new_line_content": "    Forwarder.mergePredecessorAvailSet(*this);",
          "content_same": false
        },
        {
          "line": 1282,
          "old_api": "push_back",
          "new_api": "end",
          "old_text": "WorkList.push_back(X)",
          "new_text": "HandledBBs.end()",
          "old_line_content": "        WorkList.push_back(X);",
          "new_line_content": "        if (HandledBBs.find(X) != HandledBBs.end())",
          "content_same": false
        },
        {
          "line": 1410,
          "old_api": "recursivelyDeleteTriviallyDeadInstructions",
          "new_api": "use_empty",
          "old_text": "recursivelyDeleteTriviallyDeadInstructions(X, true)",
          "new_text": "X->use_empty()",
          "old_line_content": "    recursivelyDeleteTriviallyDeadInstructions(X, true);",
          "new_line_content": "    if (!X->use_empty())",
          "content_same": false
        },
        {
          "line": 1430,
          "old_api": "PM->getAnalysis<AliasAnalysis>()",
          "new_api": "getName",
          "old_text": "PM->getAnalysis<AliasAnalysis>()",
          "new_text": "F->getName()",
          "old_line_content": "    auto *AA = PM->getAnalysis<AliasAnalysis>();",
          "new_line_content": "    DEBUG(llvm::dbgs() << \"*** RLE on function: \" << F->getName() << \" ***\\n\");",
          "content_same": false
        },
        {
          "line": 1432,
          "old_api": "get",
          "new_api": "PM->getAnalysis<AliasAnalysis>()",
          "old_text": "PM->getAnalysis<PostOrderAnalysis>()->get(F)",
          "new_text": "PM->getAnalysis<AliasAnalysis>()",
          "old_line_content": "    auto *PO = PM->getAnalysis<PostOrderAnalysis>()->get(F);",
          "new_line_content": "    auto *AA = PM->getAnalysis<AliasAnalysis>();",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1025,
          "old_api": null,
          "new_api": "getPreds",
          "old_text": null,
          "new_text": "B->getPreds()",
          "old_line_content": "        RunOneIteration = false;",
          "new_line_content": "    for (auto X : B->getPreds()) {",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "HandledBBs.end()",
          "old_line_content": "        break;",
          "new_line_content": "      if (HandledBBs.find(X) == HandledBBs.end()) {",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "HandledBBs.insert(B)",
          "old_line_content": "",
          "new_line_content": "    HandledBBs.insert(B);",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "VM.erase(B)",
          "old_line_content": " ",
          "new_line_content": "  VM.erase(B);",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": null,
          "new_api": "test",
          "old_text": null,
          "new_text": "BV.test(B)",
          "old_line_content": " ",
          "new_line_content": "  return BV.test(B);",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": null,
          "new_api": "set",
          "old_text": null,
          "new_text": "BV.set(B)",
          "old_line_content": " ",
          "new_line_content": "  BV.set(B);",
          "content_same": false
        },
        {
          "line": 1069,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "LocToBitIndex.find(Loc)",
          "old_line_content": "  return Iter->second;",
          "new_line_content": "  auto Iter = LocToBitIndex.find(Loc);",
          "content_same": false
        },
        {
          "line": 1070,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "LocToBitIndex.end()",
          "old_line_content": "}",
          "new_line_content": "  assert(Iter != LocToBitIndex.end() && \"Location should have been enum'ed\");",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "BV.reset(B)",
          "old_line_content": "",
          "new_line_content": "  BV.reset(B);",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": null,
          "new_api": "pred_empty",
          "old_text": null,
          "new_text": "BB->pred_empty()",
          "old_line_content": "    return;",
          "new_line_content": "  if (BB->pred_empty()) {",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "ForwardSetMax.reset()",
          "old_line_content": "  }",
          "new_line_content": "    ForwardSetMax.reset();",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "ValToBitIndex.find(Val)",
          "old_line_content": "  // We do not walk over the function and find all the possible LSValues",
          "new_line_content": "  auto Iter = ValToBitIndex.find(Val);",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": null,
          "new_api": "pred_end",
          "old_text": null,
          "new_text": "BB->pred_end()",
          "old_line_content": "  }",
          "new_line_content": "  for (auto EndIter = BB->pred_end(); Iter != EndIter; ++Iter) {",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": null,
          "new_api": "getBlockState",
          "old_text": null,
          "new_text": "Ctx.getBlockState(*Iter)",
          "old_line_content": "}",
          "new_line_content": "    ForwardSetMax &= Ctx.getBlockState(*Iter).ForwardSetMax;",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "LSValueVault.size()",
          "old_line_content": "    return ValToBitIndex[Val];",
          "new_line_content": "    ValToBitIndex[Val] = LSValueVault.size();",
          "content_same": false
        },
        {
          "line": 1089,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "LSValueVault.push_back(Val)",
          "old_line_content": "  }",
          "new_line_content": "    LSValueVault.push_back(Val);",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "BB->getPreds().end()",
          "old_line_content": "    return;",
          "new_line_content": "  if (BB->getPreds().begin() == BB->getPreds().end()) {",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "ForwardSetIn.reset()",
          "old_line_content": "  }",
          "new_line_content": "    ForwardSetIn.reset();",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": null,
          "new_api": "pred_end",
          "old_text": null,
          "new_text": "BB->pred_end()",
          "old_line_content": "  }",
          "new_line_content": "  for (auto EndIter = BB->pred_end(); Iter != EndIter; ++Iter) {",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": null,
          "new_api": "getBlockState",
          "old_text": null,
          "new_text": "Ctx.getBlockState(*Iter)",
          "old_line_content": "}",
          "new_line_content": "    ForwardSetIn &= Ctx.getBlockState(*Iter).ForwardSetOut;",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": null,
          "new_api": "getLocationBit",
          "old_text": null,
          "new_text": "Ctx.getLocationBit(X)",
          "old_line_content": "      ++CSCount;",
          "new_line_content": "    LSValue &V = Ctx.getValue(OTM[Ctx.getLocationBit(X)]);",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": null,
          "new_api": "isCoveringValue",
          "old_text": null,
          "new_text": "V.isCoveringValue()",
          "old_line_content": "      continue;",
          "new_line_content": "    if (V.isCoveringValue()) {",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "ForwardSetIn.reset()",
          "old_line_content": "    return;",
          "new_line_content": "    ForwardSetIn.reset();",
          "content_same": false
        },
        {
          "line": 597,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "ForwardValIn.clear()",
          "old_line_content": "  }",
          "new_line_content": "    ForwardValIn.clear();",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "Locs.size()",
          "old_line_content": "  return ValueState::CoverAndConcreteValues;",
          "new_line_content": "  if (CTCount == Locs.size())",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": null,
          "new_api": "pred_end",
          "old_text": null,
          "new_text": "BB->pred_end()",
          "old_line_content": "    ForwardSetIn &= OtherState.ForwardSetOut;",
          "new_line_content": "  for (auto EndIter = BB->pred_end(); Iter != EndIter; ++Iter) {",
          "content_same": false
        },
        {
          "line": 606,
          "old_api": null,
          "new_api": "getBlockState",
          "old_text": null,
          "new_text": "Ctx.getBlockState(*Iter)",
          "old_line_content": "",
          "new_line_content": "    BlockState &OtherState = Ctx.getBlockState(*Iter);",
          "content_same": false
        },
        {
          "line": 615,
          "old_api": null,
          "new_api": "LSValue",
          "old_text": null,
          "new_text": "LSValue(true)",
          "old_line_content": "      }",
          "new_line_content": "        ForwardValIn[i] = Ctx.getValueBit(LSValue(true));",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": null,
          "new_api": "getPreds",
          "old_text": null,
          "new_text": "BB->getPreds()",
          "old_line_content": "  }",
          "new_line_content": "  for (auto Pred : BB->getPreds()) {",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "WorkList.push_back(Pred)",
          "old_line_content": "",
          "new_line_content": "    WorkList.push_back(Pred);",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": null,
          "new_api": "stopTrackingValue",
          "old_text": null,
          "new_text": "stopTrackingValue(ForwardValIn, i)",
          "old_line_content": "    }",
          "new_line_content": "      stopTrackingValue(ForwardValIn, i);",
          "content_same": false
        },
        {
          "line": 620,
          "old_api": null,
          "new_api": "stopTrackingLocation",
          "old_text": null,
          "new_text": "stopTrackingLocation(ForwardSetIn, i)",
          "old_line_content": "  }",
          "new_line_content": "      stopTrackingLocation(ForwardSetIn, i);",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": null,
          "new_api": "pop_back_val",
          "old_text": null,
          "new_text": "WorkList.pop_back_val()",
          "old_line_content": "",
          "new_line_content": "    auto *CurBB = WorkList.pop_back_val();",
          "content_same": false
        },
        {
          "line": 1133,
          "old_api": null,
          "new_api": "getBlockState",
          "old_text": null,
          "new_text": "getBlockState(CurBB)",
          "old_line_content": "    // Mark this basic block as processed.",
          "new_line_content": "    BlockState &Forwarder = getBlockState(CurBB);",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "HandledBBs.insert(CurBB)",
          "old_line_content": "    // There are 3 cases that can happen here.",
          "new_line_content": "    HandledBBs.insert(CurBB);",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": null,
          "new_api": "processInstructionWithKind",
          "old_text": null,
          "new_text": "processInstructionWithKind(Ctx, &II, Kind)",
          "old_line_content": "}",
          "new_line_content": "    processInstructionWithKind(Ctx, &II, Kind);",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": null,
          "new_api": "updateForwardSetOut",
          "old_text": null,
          "new_text": "updateForwardSetOut()",
          "old_line_content": "",
          "new_line_content": "  return updateForwardSetOut();",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": null,
          "new_api": "isConcreteValues",
          "old_text": null,
          "new_text": "Forwarder.isConcreteValues(*this, L)",
          "old_line_content": "      continue;",
          "new_line_content": "    if (Forwarder.isConcreteValues(*this, L)) {",
          "content_same": false
        },
        {
          "line": 1151,
          "old_api": null,
          "new_api": "reduceValuesAtEndOfBlock",
          "old_text": null,
          "new_text": "Forwarder.reduceValuesAtEndOfBlock(*this, L)",
          "old_line_content": "    }",
          "new_line_content": "      Values[CurBB] = Forwarder.reduceValuesAtEndOfBlock(*this, L);",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": null,
          "new_api": "getTE",
          "old_text": null,
          "new_text": "Ctx.getTE()",
          "old_line_content": "  // Find the values that this basic block defines and the locations which",
          "new_line_content": "  LSLocation::expand(L, &BB->getModule(), Locs, Ctx.getTE());",
          "content_same": false
        },
        {
          "line": 1158,
          "old_api": null,
          "new_api": "getPreds",
          "old_text": null,
          "new_text": "CurBB->getPreds()",
          "old_line_content": "          continue;",
          "new_line_content": "      for (auto Pred : CurBB->getPreds()) {",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "Locs.size()",
          "old_line_content": "  }",
          "new_line_content": "  for (unsigned i = 0; i < Locs.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": null,
          "new_api": "getLocationBit",
          "old_text": null,
          "new_text": "Ctx.getLocationBit(Locs[i])",
          "old_line_content": "",
          "new_line_content": "    Values[Locs[i]] = Ctx.getValue(OTM[Ctx.getLocationBit(Locs[i])]);",
          "content_same": false
        },
        {
          "line": 1161,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "WorkList.push_back(Pred)",
          "old_line_content": "      continue;",
          "new_line_content": "        WorkList.push_back(Pred);",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": null,
          "new_api": "getModule",
          "old_text": null,
          "new_text": "BB->getModule()",
          "old_line_content": "  /// Return the forwarding value.",
          "new_line_content": "  TheForwardingValue = LSValue::reduce(L, &BB->getModule(), Values,",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": null,
          "new_api": "getTE",
          "old_text": null,
          "new_text": "Ctx.getTE()",
          "old_line_content": "  return TheForwardingValue;",
          "new_line_content": "                                       BB->getTerminator(), Ctx.getTE());",
          "content_same": false
        },
        {
          "line": 1170,
          "old_api": null,
          "new_api": "getForwardValOut",
          "old_text": null,
          "new_text": "Forwarder.getForwardValOut()",
          "old_line_content": "",
          "new_line_content": "    if (!collectLocationValues(CurBB, L, LSValues, Forwarder.getForwardValOut()))",
          "content_same": false
        },
        {
          "line": 1171,
          "old_api": null,
          "new_api": "SILValue",
          "old_text": null,
          "new_text": "SILValue()",
          "old_line_content": "    // Reduce the available values into a single SILValue we can use to forward",
          "new_line_content": "      return SILValue();",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": null,
          "new_api": "getTerminator",
          "old_text": null,
          "new_text": "CurBB->getTerminator()",
          "old_line_content": "  }",
          "new_line_content": "    SILInstruction *IPt = CurBB->getTerminator();",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": null,
          "new_api": "getModule",
          "old_text": null,
          "new_text": "BB->getModule()",
          "old_line_content": "",
          "new_line_content": "    Values[CurBB] = LSValue::reduce(L, &BB->getModule(), LSValues, IPt, TE);",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": null,
          "new_api": "getBM",
          "old_text": null,
          "new_text": "Ctx.getBM()",
          "old_line_content": "    L = BaseToLocIndex[Mem];",
          "new_line_content": "  LSLocationBaseMap &BaseToLocIndex = Ctx.getBM();",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "BaseToLocIndex.end()",
          "old_line_content": "  } else {",
          "new_line_content": "  if (BaseToLocIndex.find(Mem) != BaseToLocIndex.end()) {",
          "content_same": false
        },
        {
          "line": 1182,
          "old_api": null,
          "new_api": "AddAvailableValue",
          "old_text": null,
          "new_text": "Updater.AddAvailableValue(V.first, V.second)",
          "old_line_content": "",
          "new_line_content": "    Updater.AddAvailableValue(V.first, V.second);",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": null,
          "new_api": "getUnderlyingObject",
          "old_text": null,
          "new_text": "getUnderlyingObject(Mem)",
          "old_line_content": "  }",
          "new_line_content": "    SILValue UO = getUnderlyingObject(Mem);",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": null,
          "new_api": "NewProjectionPath::getProjectionPath(UO, Mem)",
          "old_text": null,
          "new_text": "NewProjectionPath::getProjectionPath(UO, Mem)",
          "old_line_content": "",
          "new_line_content": "    L = LSLocation(UO, NewProjectionPath::getProjectionPath(UO, Mem));",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": null,
          "new_api": "GetValueInMiddleOfBlock",
          "old_text": null,
          "new_text": "Updater.GetValueInMiddleOfBlock(BB)",
          "old_line_content": "",
          "new_line_content": "  return Updater.GetValueInMiddleOfBlock(BB);",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": null,
          "new_api": "getForwardValIn",
          "old_text": null,
          "new_text": "getForwardValIn()",
          "old_line_content": "",
          "new_line_content": "  if (!Ctx.collectLocationValues(I->getParent(), L, Values, getForwardValIn()))",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": null,
          "new_api": "getModule",
          "old_text": null,
          "new_text": "I->getModule()",
          "old_line_content": "  if (!TheForwardingValue)",
          "new_line_content": "  SILModule *Mod = &I->getModule();",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": null,
          "new_api": "getTE",
          "old_text": null,
          "new_text": "Ctx.getTE()",
          "old_line_content": "    return false;",
          "new_line_content": "  SILValue TheForwardingValue = LSValue::reduce(L, Mod, Values, I, Ctx.getTE());",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": null,
          "new_api": "getModule",
          "old_text": null,
          "new_text": "BB->getModule()",
          "old_line_content": "  // we do not have a concrete value in the current basic block.",
          "new_line_content": "  auto *Mod = &BB->getModule();",
          "content_same": false
        },
        {
          "line": 1199,
          "old_api": null,
          "new_api": "getLocationBit",
          "old_text": null,
          "new_text": "getLocationBit(X)",
          "old_line_content": "      continue;",
          "new_line_content": "    Values[X] = getValue(VM[getLocationBit(X)]);",
          "content_same": false
        },
        {
          "line": 1202,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "CSLocs.insert(X)",
          "old_line_content": "",
          "new_line_content": "    CSLocs.insert(X);",
          "content_same": false
        },
        {
          "line": 1208,
          "old_api": null,
          "new_api": "LSLocation::reduce(L, Mod, CSLocs, TE)",
          "old_text": null,
          "new_text": "LSLocation::reduce(L, Mod, CSLocs, TE)",
          "old_line_content": "  // To handle covering value, we need to go to the predecessors and",
          "new_line_content": "  LSLocation::reduce(L, Mod, CSLocs, TE);",
          "content_same": false
        },
        {
          "line": 1213,
          "old_api": null,
          "new_api": "computePredecessorLocationValue",
          "old_text": null,
          "new_text": "computePredecessorLocationValue(BB, X)",
          "old_line_content": "      return false;",
          "new_line_content": "    SILValue V = computePredecessorLocationValue(BB, X);",
          "content_same": false
        },
        {
          "line": 1221,
          "old_api": null,
          "new_api": "LSLocation::expand(X, Mod, Locs, TE)",
          "old_text": null,
          "new_text": "LSLocation::expand(X, Mod, Locs, TE)",
          "old_line_content": "",
          "new_line_content": "    LSLocation::expand(X, Mod, Locs, TE);",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": null,
          "new_api": "startTrackingLocation",
          "old_text": null,
          "new_text": "startTrackingLocation(ForwardSetIn, B)",
          "old_line_content": "",
          "new_line_content": "  startTrackingLocation(ForwardSetIn, B);",
          "content_same": false
        },
        {
          "line": 1226,
          "old_api": null,
          "new_api": "isValid",
          "old_text": null,
          "new_text": "Values[Locs[i]].isValid()",
          "old_line_content": "  }",
          "new_line_content": "      assert(Values[Locs[i]].isValid() && \"Invalid load store value\");",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": null,
          "new_api": "startTrackingLocation",
          "old_text": null,
          "new_text": "startTrackingLocation(BBGenSet, B)",
          "old_line_content": "}",
          "new_line_content": "  startTrackingLocation(BBGenSet, B);",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": null,
          "new_api": "stopTrackingLocation",
          "old_text": null,
          "new_text": "stopTrackingLocation(BBKillSet, B)",
          "old_line_content": "",
          "new_line_content": "  stopTrackingLocation(BBKillSet, B);",
          "content_same": false
        },
        {
          "line": 1233,
          "old_api": null,
          "new_api": "getReversePostOrder",
          "old_text": null,
          "new_text": "PO->getReversePostOrder()",
          "old_line_content": "",
          "new_line_content": "  for (SILBasicBlock *BB : PO->getReversePostOrder()) {",
          "content_same": false
        },
        {
          "line": 1234,
          "old_api": null,
          "new_api": "getBlockState",
          "old_text": null,
          "new_text": "getBlockState(BB)",
          "old_line_content": "    // Compute the AvailSetMax at the beginning of the basic block.",
          "new_line_content": "    BlockState &S = getBlockState(BB);",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": null,
          "new_api": "startTrackingValue",
          "old_text": null,
          "new_text": "startTrackingValue(ForwardValIn, L, V)",
          "old_line_content": "}",
          "new_line_content": "  startTrackingValue(ForwardValIn, L, V);",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": null,
          "new_api": "startTrackingLocation",
          "old_text": null,
          "new_text": "startTrackingLocation(ForwardSetIn, L)",
          "old_line_content": "",
          "new_line_content": "  startTrackingLocation(ForwardSetIn, L);",
          "content_same": false
        },
        {
          "line": 1237,
          "old_api": null,
          "new_api": "mergePredecessorsAvailSetMax",
          "old_text": null,
          "new_text": "S.mergePredecessorsAvailSetMax(*this)",
          "old_line_content": "    // Compute the genset and killset. ",
          "new_line_content": "    S.mergePredecessorsAvailSetMax(*this);",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": null,
          "new_api": "dyn_cast<LoadInst>(&*I)",
          "old_text": null,
          "new_text": "dyn_cast<LoadInst>(&*I)",
          "old_line_content": "      }",
          "new_line_content": "      if (auto *LI = dyn_cast<LoadInst>(&*I)) {",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": null,
          "new_api": "getLocation",
          "old_text": null,
          "new_text": "Ctx.getLocation(i)",
          "old_line_content": "      continue;",
          "new_line_content": "    LSLocation &L = Ctx.getLocation(i);",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": null,
          "new_api": "getAA",
          "old_text": null,
          "new_text": "Ctx.getAA()",
          "old_line_content": "    // MayAlias, invalidate the location.",
          "new_line_content": "    if (!L.isMayAliasLSLocation(R, Ctx.getAA()))",
          "content_same": false
        },
        {
          "line": 1247,
          "old_api": null,
          "new_api": "dyn_cast<StoreInst>(&*I)",
          "old_text": null,
          "new_text": "dyn_cast<StoreInst>(&*I)",
          "old_line_content": "      }",
          "new_line_content": "      if (auto *SI = dyn_cast<StoreInst>(&*I)) {",
          "content_same": false
        },
        {
          "line": 1248,
          "old_api": null,
          "new_api": "processStoreInst",
          "old_text": null,
          "new_text": "S.processStoreInst(*this, SI, RLEKind::ComputeAvailSetMax)",
          "old_line_content": "",
          "new_line_content": "        S.processStoreInst(*this, SI, RLEKind::ComputeAvailSetMax);",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": null,
          "new_api": "stopTrackingLocation",
          "old_text": null,
          "new_text": "stopTrackingLocation(BBGenSet, i)",
          "old_line_content": "  }",
          "new_line_content": "    stopTrackingLocation(BBGenSet, i);",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": null,
          "new_api": "startTrackingLocation",
          "old_text": null,
          "new_text": "startTrackingLocation(BBKillSet, i)",
          "old_line_content": "",
          "new_line_content": "    startTrackingLocation(BBKillSet, i);",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": null,
          "new_api": "processInstructionWithKind",
          "old_text": null,
          "new_text": "S.processInstructionWithKind(*this, &*I, RLEKind::ComputeAvailGenKillSet)",
          "old_line_content": "  }",
          "new_line_content": "      S.processInstructionWithKind(*this, &*I, RLEKind::ComputeAvailGenKillSet);",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": null,
          "new_api": "startTrackingLocation",
          "old_text": null,
          "new_text": "startTrackingLocation(BBGenSet, B)",
          "old_line_content": "}",
          "new_line_content": "  startTrackingLocation(BBGenSet, B);",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": null,
          "new_api": "stopTrackingLocation",
          "old_text": null,
          "new_text": "stopTrackingLocation(BBKillSet, B)",
          "old_line_content": "",
          "new_line_content": "  stopTrackingLocation(BBKillSet, B);",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": null,
          "new_api": "startTrackingLocation",
          "old_text": null,
          "new_text": "startTrackingLocation(ForwardSetMax, B)",
          "old_line_content": "",
          "new_line_content": "  startTrackingLocation(ForwardSetMax, B);",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": null,
          "new_api": "startTrackingLocation",
          "old_text": null,
          "new_text": "startTrackingLocation(ForwardSetMax, B)",
          "old_line_content": "",
          "new_line_content": "  startTrackingLocation(ForwardSetMax, B);",
          "content_same": false
        },
        {
          "line": 1266,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "WorkList.push_back(BB)",
          "old_line_content": "  }",
          "new_line_content": "    WorkList.push_back(BB);",
          "content_same": false
        },
        {
          "line": 1270,
          "old_api": null,
          "new_api": "pop_back_val",
          "old_text": null,
          "new_text": "WorkList.pop_back_val()",
          "old_line_content": "",
          "new_line_content": "    SILBasicBlock *BB = WorkList.pop_back_val();",
          "content_same": false
        },
        {
          "line": 1271,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "HandledBBs.erase(BB)",
          "old_line_content": "    // Intersection.",
          "new_line_content": "    HandledBBs.erase(BB);",
          "content_same": false
        },
        {
          "line": 763,
          "old_api": null,
          "new_api": "getLocation",
          "old_text": null,
          "new_text": "Ctx.getLocation(i)",
          "old_line_content": "      continue;",
          "new_line_content": "    LSLocation &L = Ctx.getLocation(i);",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": null,
          "new_api": "getAA",
          "old_text": null,
          "new_text": "Ctx.getAA()",
          "old_line_content": "    // MayAlias, invalidate the location.",
          "new_line_content": "    if (!L.isMayAliasLSLocation(R, Ctx.getAA()))",
          "content_same": false
        },
        {
          "line": 1278,
          "old_api": null,
          "new_api": "processBasicBlockWithGenKillSet",
          "old_text": null,
          "new_text": "Forwarder.processBasicBlockWithGenKillSet()",
          "old_line_content": "        // We do not push basic block into the worklist if its already",
          "new_line_content": "    if (Forwarder.processBasicBlockWithGenKillSet()) {",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": null,
          "new_api": "stopTrackingLocation",
          "old_text": null,
          "new_text": "stopTrackingLocation(ForwardSetIn, i)",
          "old_line_content": "",
          "new_line_content": "    stopTrackingLocation(ForwardSetIn, i);",
          "content_same": false
        },
        {
          "line": 1279,
          "old_api": null,
          "new_api": "getSuccessors",
          "old_text": null,
          "new_text": "BB->getSuccessors()",
          "old_line_content": "        // in the worklist.",
          "new_line_content": "      for (auto &X : BB->getSuccessors()) {",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": null,
          "new_api": "startTrackingLocation",
          "old_text": null,
          "new_text": "startTrackingLocation(ForwardSetIn, B)",
          "old_line_content": "",
          "new_line_content": "  startTrackingLocation(ForwardSetIn, B);",
          "content_same": false
        },
        {
          "line": 1284,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "WorkList.push_back(X)",
          "old_line_content": "    }",
          "new_line_content": "        WorkList.push_back(X);",
          "content_same": false
        },
        {
          "line": 1291,
          "old_api": null,
          "new_api": "getReversePostOrder",
          "old_text": null,
          "new_text": "PO->getReversePostOrder()",
          "old_line_content": "",
          "new_line_content": "  for (SILBasicBlock *BB : PO->getReversePostOrder()) {",
          "content_same": false
        },
        {
          "line": 1292,
          "old_api": null,
          "new_api": "getBlockState",
          "old_text": null,
          "new_text": "getBlockState(BB)",
          "old_line_content": "    // Merge the predecessors. After merging, BlockState now contains",
          "new_line_content": "    BlockState &Forwarder = getBlockState(BB);",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": null,
          "new_api": "getLocation",
          "old_text": null,
          "new_text": "Ctx.getLocation(i)",
          "old_line_content": "      continue;",
          "new_line_content": "    LSLocation &L = Ctx.getLocation(i);",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": null,
          "new_api": "getAA",
          "old_text": null,
          "new_text": "Ctx.getAA()",
          "old_line_content": "    // MayAlias, invalidate the location and value.",
          "new_line_content": "    if (!L.isMayAliasLSLocation(R, Ctx.getAA()))",
          "content_same": false
        },
        {
          "line": 1297,
          "old_api": null,
          "new_api": "mergePredecessorAvailSetAndValue",
          "old_text": null,
          "new_text": "Forwarder.mergePredecessorAvailSetAndValue(*this)",
          "old_line_content": "    // Merge duplicate loads, and forward stores to",
          "new_line_content": "    Forwarder.mergePredecessorAvailSetAndValue(*this);",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": null,
          "new_api": "stopTrackingValue",
          "old_text": null,
          "new_text": "stopTrackingValue(ForwardValIn, i)",
          "old_line_content": "  }",
          "new_line_content": "    stopTrackingValue(ForwardValIn, i);",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": null,
          "new_api": "stopTrackingLocation",
          "old_text": null,
          "new_text": "stopTrackingLocation(ForwardSetIn, i)",
          "old_line_content": "",
          "new_line_content": "    stopTrackingLocation(ForwardSetIn, i);",
          "content_same": false
        },
        {
          "line": 1302,
          "old_api": null,
          "new_api": "processBasicBlockWithKind",
          "old_text": null,
          "new_text": "Forwarder.processBasicBlockWithKind(*this, RLEKind::ComputeAvailValue)",
          "old_line_content": "    // Update the locations with available values. We do not need to update",
          "new_line_content": "    Forwarder.processBasicBlockWithKind(*this, RLEKind::ComputeAvailValue);",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": null,
          "new_api": "startTrackingLocation",
          "old_text": null,
          "new_text": "startTrackingLocation(ForwardSetIn, L)",
          "old_line_content": "}",
          "new_line_content": "  startTrackingLocation(ForwardSetIn, L);",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": null,
          "new_api": "startTrackingValue",
          "old_text": null,
          "new_text": "startTrackingValue(ForwardValIn, L, V)",
          "old_line_content": "",
          "new_line_content": "  startTrackingValue(ForwardValIn, L, V);",
          "content_same": false
        },
        {
          "line": 1307,
          "old_api": null,
          "new_api": "updateForwardValOut",
          "old_text": null,
          "new_text": "Forwarder.updateForwardValOut()",
          "old_line_content": "}",
          "new_line_content": "    Forwarder.updateForwardValOut();",
          "content_same": false
        },
        {
          "line": 799,
          "old_api": null,
          "new_api": "getBM",
          "old_text": null,
          "new_text": "Ctx.getBM()",
          "old_line_content": "    L = BaseToLocIndex[Mem];",
          "new_line_content": "  LSLocationBaseMap &BaseToLocIndex = Ctx.getBM();",
          "content_same": false
        },
        {
          "line": 800,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "BaseToLocIndex.end()",
          "old_line_content": "  } else {",
          "new_line_content": "  if (BaseToLocIndex.find(Mem) != BaseToLocIndex.end()) {",
          "content_same": false
        },
        {
          "line": 1312,
          "old_api": null,
          "new_api": "getReversePostOrder",
          "old_text": null,
          "new_text": "PO->getReversePostOrder()",
          "old_line_content": "",
          "new_line_content": "  for (SILBasicBlock *BB : PO->getReversePostOrder()) {",
          "content_same": false
        },
        {
          "line": 1313,
          "old_api": null,
          "new_api": "getBlockState",
          "old_text": null,
          "new_text": "getBlockState(BB)",
          "old_line_content": "    // Merge the predecessors. After merging, BlockState now contains",
          "new_line_content": "    BlockState &Forwarder = getBlockState(BB);",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": null,
          "new_api": "getUnderlyingObject",
          "old_text": null,
          "new_text": "getUnderlyingObject(Mem)",
          "old_line_content": "  }",
          "new_line_content": "    SILValue UO = getUnderlyingObject(Mem);",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": null,
          "new_api": "NewProjectionPath::getProjectionPath(UO, Mem)",
          "old_text": null,
          "new_text": "NewProjectionPath::getProjectionPath(UO, Mem)",
          "old_line_content": "",
          "new_line_content": "    L = LSLocation(UO, NewProjectionPath::getProjectionPath(UO, Mem));",
          "content_same": false
        },
        {
          "line": 1318,
          "old_api": null,
          "new_api": "mergePredecessorAvailSetAndValue",
          "old_text": null,
          "new_text": "Forwarder.mergePredecessorAvailSetAndValue(*this)",
          "old_line_content": "    // Perform the actual redundant load elimination.",
          "new_line_content": "    Forwarder.mergePredecessorAvailSetAndValue(*this);",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": null,
          "new_api": "isValid",
          "old_text": null,
          "new_text": "L.isValid()",
          "old_line_content": "    // AvailSetMax.",
          "new_line_content": "  if (!L.isValid()) {",
          "content_same": false
        },
        {
          "line": 1321,
          "old_api": null,
          "new_api": "processBasicBlockWithKind",
          "old_text": null,
          "new_text": "Forwarder.processBasicBlockWithKind(*this, RLEKind::PerformRLE)",
          "old_line_content": "    // Update the locations with available values and their values.",
          "new_line_content": "    Forwarder.processBasicBlockWithKind(*this, RLEKind::PerformRLE);",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": null,
          "new_api": "isComputeAvailSetMax",
          "old_text": null,
          "new_text": "isComputeAvailSetMax(Kind)",
          "old_line_content": "    }",
          "new_line_content": "    if (!isComputeAvailSetMax(Kind)) {",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": null,
          "new_api": "processUnknownWriteInst",
          "old_text": null,
          "new_text": "processUnknownWriteInst(Ctx, I, Kind)",
          "old_line_content": "    return;",
          "new_line_content": "      processUnknownWriteInst(Ctx, I, Kind);",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": null,
          "new_api": "updateForwardSetOut",
          "old_text": null,
          "new_text": "Forwarder.updateForwardSetOut()",
          "old_line_content": "  }",
          "new_line_content": "    Forwarder.updateForwardSetOut();",
          "content_same": false
        },
        {
          "line": 1325,
          "old_api": null,
          "new_api": "updateForwardValOut",
          "old_text": null,
          "new_text": "Forwarder.updateForwardValOut()",
          "old_line_content": "}",
          "new_line_content": "    Forwarder.updateForwardValOut();",
          "content_same": false
        },
        {
          "line": 1331,
          "old_api": null,
          "new_api": "processBasicBlocksForGenKillSet",
          "old_text": null,
          "new_text": "processBasicBlocksForGenKillSet()",
          "old_line_content": "  // Process basic blocks in RPO. After the data flow converges, run last",
          "new_line_content": "  processBasicBlocksForGenKillSet();",
          "content_same": false
        },
        {
          "line": 1335,
          "old_api": null,
          "new_api": "processBasicBlocksWithGenKillSet",
          "old_text": null,
          "new_text": "processBasicBlocksWithGenKillSet()",
          "old_line_content": "  // We have computed the available value bit, now go through every basic",
          "new_line_content": "  processBasicBlocksWithGenKillSet();",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "Locs.size()",
          "old_line_content": "    }",
          "new_line_content": "    for (unsigned i = 0; i < Locs.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": null,
          "new_api": "getLocationBit",
          "old_text": null,
          "new_text": "Ctx.getLocationBit(Locs[i])",
          "old_line_content": "    return;",
          "new_line_content": "      updateMaxAvailSetForWrite(Ctx, Ctx.getLocationBit(Locs[i]));",
          "content_same": false
        },
        {
          "line": 1342,
          "old_api": null,
          "new_api": "processBasicBlocksForAvailValue",
          "old_text": null,
          "new_text": "processBasicBlocksForAvailValue()",
          "old_line_content": "",
          "new_line_content": "  processBasicBlocksForAvailValue();",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "Locs.size()",
          "old_line_content": "    }",
          "new_line_content": "    for (unsigned i = 0; i < Locs.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": null,
          "new_api": "getLocationBit",
          "old_text": null,
          "new_text": "Ctx.getLocationBit(Locs[i])",
          "old_line_content": "    return;",
          "new_line_content": "      updateGenKillSetForWrite(Ctx, Ctx.getLocationBit(Locs[i]));",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "BBGenSet.resize(LocationNum, false)",
          "old_line_content": "  }",
          "new_line_content": "    BBGenSet.resize(LocationNum, false);",
          "content_same": false
        },
        {
          "line": 332,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "BBKillSet.resize(LocationNum, false)",
          "old_line_content": "",
          "new_line_content": "    BBKillSet.resize(LocationNum, false);",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": null,
          "new_api": "getLocationBit",
          "old_text": null,
          "new_text": "Ctx.getLocationBit(Locs[i])",
          "old_line_content": "    }",
          "new_line_content": "      updateForwardSetAndValForWrite(Ctx, Ctx.getLocationBit(Locs[i]),",
          "content_same": false
        },
        {
          "line": 844,
          "old_api": null,
          "new_api": "getValueBit",
          "old_text": null,
          "new_text": "Ctx.getValueBit(Vals[i])",
          "old_line_content": "    return;",
          "new_line_content": "                                     Ctx.getValueBit(Vals[i]));",
          "content_same": false
        },
        {
          "line": 1360,
          "old_api": null,
          "new_api": "LSLocation::enumerateLSLocations(*Fn, LocationVault, LocToBitIndex,\n                                   BaseToLocIndex, TE)",
          "old_text": null,
          "new_text": "LSLocation::enumerateLSLocations(*Fn, LocationVault, LocToBitIndex,\n                                   BaseToLocIndex, TE)",
          "old_line_content": "",
          "new_line_content": "  LSLocation::enumerateLSLocations(*Fn, LocationVault, LocToBitIndex,",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": null,
          "new_api": "llvm_unreachable",
          "old_text": null,
          "new_text": "llvm_unreachable(\"Unknown RLE compute kind\")",
          "old_line_content": "",
          "new_line_content": "  llvm_unreachable(\"Unknown RLE compute kind\");",
          "content_same": false
        },
        {
          "line": 1364,
          "old_api": null,
          "new_api": "getProcessFunctionKind",
          "old_text": null,
          "new_text": "getProcessFunctionKind()",
          "old_line_content": "  // We do not optimize this function at all.",
          "new_line_content": "  ProcessKind Kind = getProcessFunctionKind();",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": null,
          "new_api": "getBM",
          "old_text": null,
          "new_text": "Ctx.getBM()",
          "old_line_content": "    L = BaseToLocIndex[Mem];",
          "new_line_content": "  LSLocationBaseMap &BaseToLocIndex = Ctx.getBM();",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "BaseToLocIndex.end()",
          "old_line_content": "  } else {",
          "new_line_content": "  if (BaseToLocIndex.find(Mem) != BaseToLocIndex.end()) {",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": null,
          "new_api": "getUnderlyingObject",
          "old_text": null,
          "new_text": "getUnderlyingObject(Mem)",
          "old_line_content": "  }",
          "new_line_content": "    SILValue UO = getUnderlyingObject(Mem);",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": null,
          "new_api": "NewProjectionPath::getProjectionPath(UO, Mem)",
          "old_text": null,
          "new_text": "NewProjectionPath::getProjectionPath(UO, Mem)",
          "old_line_content": "",
          "new_line_content": "    L = LSLocation(UO, NewProjectionPath::getProjectionPath(UO, Mem));",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": null,
          "new_api": "isValid",
          "old_text": null,
          "new_text": "L.isValid()",
          "old_line_content": "",
          "new_line_content": "  if (!L.isValid())",
          "content_same": false
        },
        {
          "line": 1378,
          "old_api": null,
          "new_api": "BlockState",
          "old_text": null,
          "new_text": "BlockState()",
          "old_line_content": "  }",
          "new_line_content": "    BBToLocState[&B] = BlockState();",
          "content_same": false
        },
        {
          "line": 1379,
          "old_api": null,
          "new_api": "isReachable",
          "old_text": null,
          "new_text": "isReachable(&B)",
          "old_line_content": "",
          "new_line_content": "    BBToLocState[&B].init(&B, LocationVault.size(), MultiIteration && isReachable(&B));",
          "content_same": false
        },
        {
          "line": 1383,
          "old_api": null,
          "new_api": "runIterativeRLE",
          "old_text": null,
          "new_text": "runIterativeRLE()",
          "old_line_content": "  // We have the available value bit computed and the local forwarding value.",
          "new_line_content": "    runIterativeRLE();",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "Locs.size()",
          "old_line_content": "    }",
          "new_line_content": "    for (unsigned i = 0; i < Locs.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": null,
          "new_api": "getLocationBit",
          "old_text": null,
          "new_text": "Ctx.getLocationBit(Locs[i])",
          "old_line_content": "    return;",
          "new_line_content": "      updateMaxAvailSetForRead(Ctx, Ctx.getLocationBit(Locs[i]));",
          "content_same": false
        },
        {
          "line": 1387,
          "old_api": null,
          "new_api": "processBasicBlocksForRLE",
          "old_text": null,
          "new_text": "processBasicBlocksForRLE()",
          "old_line_content": "  // Finally, perform the redundant load replacements.",
          "new_line_content": "  processBasicBlocksForRLE();",
          "content_same": false
        },
        {
          "line": 1393,
          "old_api": null,
          "new_api": "getRL",
          "old_text": null,
          "new_text": "X.second.getRL()",
          "old_line_content": "                         << F.second);",
          "new_line_content": "    for (auto &F : X.second.getRL()) {",
          "content_same": false
        },
        {
          "line": 1394,
          "old_api": null,
          "new_api": "SILValue",
          "old_text": null,
          "new_text": "SILValue(F.first)",
          "old_line_content": "      SILChanged = true;",
          "new_line_content": "      DEBUG(llvm::dbgs() << \"Replacing  \" << SILValue(F.first) << \"With \"",
          "content_same": false
        },
        {
          "line": 883,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "Locs.size()",
          "old_line_content": "    }",
          "new_line_content": "    for (unsigned i = 0; i < Locs.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": null,
          "new_api": "getLocationBit",
          "old_text": null,
          "new_text": "Ctx.getLocationBit(Locs[i])",
          "old_line_content": "    return;",
          "new_line_content": "      updateGenKillSetForRead(Ctx, Ctx.getLocationBit(Locs[i]));",
          "content_same": false
        },
        {
          "line": 1397,
          "old_api": null,
          "new_api": "replaceAllUsesWith",
          "old_text": null,
          "new_text": "F.first->replaceAllUsesWith(F.second)",
          "old_line_content": "      ++NumForwardedLoads;",
          "new_line_content": "      F.first->replaceAllUsesWith(F.second);",
          "content_same": false
        },
        {
          "line": 1398,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "InstsToDelete.insert(F.first)",
          "old_line_content": "    }",
          "new_line_content": "      InstsToDelete.insert(F.first);",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": null,
          "new_api": "getValueStateAtEndOfBlock",
          "old_text": null,
          "new_text": "getValueStateAtEndOfBlock(Ctx, L)",
          "old_line_content": "  bool isConcreteValues(RLEContext &Ctx, LSLocation &L) {",
          "new_line_content": "    return getValueStateAtEndOfBlock(Ctx, L) == ValueState::CoverValues;",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": null,
          "new_api": "getValueStateAtEndOfBlock",
          "old_text": null,
          "new_text": "getValueStateAtEndOfBlock(Ctx, L)",
          "old_line_content": "",
          "new_line_content": "    return getValueStateAtEndOfBlock(Ctx, L) == ValueState::ConcreteValues;",
          "content_same": false
        },
        {
          "line": 894,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "Locs.size()",
          "old_line_content": "        continue;",
          "new_line_content": "    for (unsigned i = 0; i < Locs.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 897,
          "old_api": null,
          "new_api": "getLocationBit",
          "old_text": null,
          "new_text": "Ctx.getLocationBit(Locs[i])",
          "old_line_content": "      // We can not perform the forwarding as we are at least missing",
          "new_line_content": "      updateForwardSetAndValForRead(Ctx, Ctx.getLocationBit(Locs[i]),",
          "content_same": false
        },
        {
          "line": 898,
          "old_api": null,
          "new_api": "getValueBit",
          "old_text": null,
          "new_text": "Ctx.getValueBit(Vals[i])",
          "old_line_content": "      // some pieces of the read location.",
          "new_line_content": "                                    Ctx.getValueBit(Vals[i]));",
          "content_same": false
        },
        {
          "line": 1412,
          "old_api": null,
          "new_api": "recursivelyDeleteTriviallyDeadInstructions",
          "old_text": null,
          "new_text": "recursivelyDeleteTriviallyDeadInstructions(X, true)",
          "old_line_content": "  return SILChanged;",
          "new_line_content": "    recursivelyDeleteTriviallyDeadInstructions(X, true);",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": null,
          "new_api": "isPerformingRLE",
          "old_text": null,
          "new_text": "isPerformingRLE(Kind)",
          "old_line_content": "",
          "new_line_content": "  if (!isPerformingRLE(Kind) || !CanForward)",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": null,
          "new_api": "setupRLE",
          "old_text": null,
          "new_text": "setupRLE(Ctx, I, Mem)",
          "old_line_content": "",
          "new_line_content": "  setupRLE(Ctx, I, Mem);",
          "content_same": false
        },
        {
          "line": 915,
          "old_api": null,
          "new_api": "getSrc",
          "old_text": null,
          "new_text": "SI->getSrc()",
          "old_line_content": "",
          "new_line_content": "  processWrite(Ctx, SI, SI->getDest(), SI->getSrc(), Kind);",
          "content_same": false
        },
        {
          "line": 1429,
          "old_api": null,
          "new_api": "getFunction",
          "old_text": null,
          "new_text": "getFunction()",
          "old_line_content": "",
          "new_line_content": "    SILFunction *F = getFunction();",
          "content_same": false
        },
        {
          "line": 919,
          "old_api": null,
          "new_api": "SILValue",
          "old_text": null,
          "new_text": "SILValue(LI)",
          "old_line_content": "",
          "new_line_content": "  processRead(Ctx, LI, LI->getOperand(), SILValue(LI), Kind);",
          "content_same": false
        },
        {
          "line": 1433,
          "old_api": null,
          "new_api": "PM->getAnalysis<TypeExpansionAnalysis>()",
          "old_text": null,
          "new_text": "PM->getAnalysis<TypeExpansionAnalysis>()",
          "old_line_content": "",
          "new_line_content": "    auto *TE = PM->getAnalysis<TypeExpansionAnalysis>();",
          "content_same": false
        },
        {
          "line": 1434,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "PM->getAnalysis<PostOrderAnalysis>()->get(F)",
          "old_line_content": "    RLEContext RLE(F, PM, AA, TE, PO);",
          "new_line_content": "    auto *PO = PM->getAnalysis<PostOrderAnalysis>()->get(F);",
          "content_same": false
        },
        {
          "line": 1437,
          "old_api": null,
          "new_api": "run",
          "old_text": null,
          "new_text": "RLE.run()",
          "old_line_content": "    }",
          "new_line_content": "    if (RLE.run()) {",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": null,
          "new_api": "isTrackingLocation",
          "old_text": null,
          "new_text": "isTrackingLocation(ForwardSetMax, i)",
          "old_line_content": "    // Invalidate any location this instruction may write to.",
          "new_line_content": "    if (!isTrackingLocation(ForwardSetMax, i))",
          "content_same": false
        },
        {
          "line": 1438,
          "old_api": null,
          "new_api": "invalidateAnalysis",
          "old_text": null,
          "new_text": "invalidateAnalysis(SILAnalysis::InvalidationKind::Instructions)",
          "old_line_content": "  }",
          "new_line_content": "      invalidateAnalysis(SILAnalysis::InvalidationKind::Instructions);",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": null,
          "new_api": "getLocation",
          "old_text": null,
          "new_text": "Ctx.getLocation(i)",
          "old_line_content": "      continue;",
          "new_line_content": "    LSLocation &R = Ctx.getLocation(i);",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": null,
          "new_api": "getBase",
          "old_text": null,
          "new_text": "R.getBase()",
          "old_line_content": "    // MayAlias.",
          "new_line_content": "    if (!AA->mayWriteToMemory(I, R.getBase()))",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": null,
          "new_api": "stopTrackingLocation",
          "old_text": null,
          "new_text": "stopTrackingLocation(BBGenSet, i)",
          "old_line_content": "  }",
          "new_line_content": "    stopTrackingLocation(BBGenSet, i);",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": null,
          "new_api": "startTrackingLocation",
          "old_text": null,
          "new_text": "startTrackingLocation(BBKillSet, i)",
          "old_line_content": "}",
          "new_line_content": "    startTrackingLocation(BBKillSet, i);",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": null,
          "new_api": "isTrackingLocation",
          "old_text": null,
          "new_text": "isTrackingLocation(ForwardSetIn, i)",
          "old_line_content": "    // Invalidate any location this instruction may write to.",
          "new_line_content": "    if (!isTrackingLocation(ForwardSetIn, i))",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": null,
          "new_api": "getLocation",
          "old_text": null,
          "new_text": "Ctx.getLocation(i)",
          "old_line_content": "      continue;",
          "new_line_content": "    LSLocation &R = Ctx.getLocation(i);",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": null,
          "new_api": "getBase",
          "old_text": null,
          "new_text": "R.getBase()",
          "old_line_content": "    // MayAlias.",
          "new_line_content": "    if (!AA->mayWriteToMemory(I, R.getBase()))",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": null,
          "new_api": "stopTrackingLocation",
          "old_text": null,
          "new_text": "stopTrackingLocation(ForwardSetIn, i)",
          "old_line_content": "  }",
          "new_line_content": "    stopTrackingLocation(ForwardSetIn, i);",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": null,
          "new_api": "stopTrackingValue",
          "old_text": null,
          "new_text": "stopTrackingValue(ForwardValIn, i)",
          "old_line_content": "}",
          "new_line_content": "    stopTrackingValue(ForwardValIn, i);",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": null,
          "new_api": "isComputeAvailGenKillSet",
          "old_text": null,
          "new_text": "isComputeAvailGenKillSet(Kind)",
          "old_line_content": "    return;",
          "new_line_content": "  if (isComputeAvailGenKillSet(Kind)) {",
          "content_same": false
        },
        {
          "line": 964,
          "old_api": null,
          "new_api": "processUnknownWriteInstForGenKillSet",
          "old_text": null,
          "new_text": "processUnknownWriteInstForGenKillSet(Ctx, I)",
          "old_line_content": "  }",
          "new_line_content": "    processUnknownWriteInstForGenKillSet(Ctx, I);",
          "content_same": false
        },
        {
          "line": 969,
          "old_api": null,
          "new_api": "isPerformingRLE",
          "old_text": null,
          "new_text": "isPerformingRLE(Kind)",
          "old_line_content": "    return;",
          "new_line_content": "  if (isComputeAvailValue(Kind) || isPerformingRLE(Kind)) {",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": null,
          "new_api": "processUnknownWriteInstForRLE",
          "old_text": null,
          "new_text": "processUnknownWriteInstForRLE(Ctx, I)",
          "old_line_content": "  }",
          "new_line_content": "    processUnknownWriteInstForRLE(Ctx, I);",
          "content_same": false
        },
        {
          "line": 974,
          "old_api": null,
          "new_api": "llvm_unreachable",
          "old_text": null,
          "new_text": "llvm_unreachable(\"Unknown RLE compute kind\")",
          "old_line_content": "",
          "new_line_content": "  llvm_unreachable(\"Unknown RLE compute kind\");",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": null,
          "new_api": "dyn_cast<StoreInst>(Inst)",
          "old_text": null,
          "new_text": "dyn_cast<StoreInst>(Inst)",
          "old_line_content": "    return;",
          "new_line_content": "  if (auto *SI = dyn_cast<StoreInst>(Inst)) {",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": null,
          "new_api": "processStoreInst",
          "old_text": null,
          "new_text": "processStoreInst(Ctx, SI, Kind)",
          "old_line_content": "  }",
          "new_line_content": "    processStoreInst(Ctx, SI, Kind);",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": null,
          "new_api": "dyn_cast<LoadInst>(Inst)",
          "old_text": null,
          "new_text": "dyn_cast<LoadInst>(Inst)",
          "old_line_content": "    return;",
          "new_line_content": "  if (auto *LI = dyn_cast<LoadInst>(Inst)) {",
          "content_same": false
        },
        {
          "line": 990,
          "old_api": null,
          "new_api": "processLoadInst",
          "old_text": null,
          "new_text": "processLoadInst(Ctx, LI, Kind)",
          "old_line_content": "  }",
          "new_line_content": "    processLoadInst(Ctx, LI, Kind);",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": null,
          "new_api": "isRLEInertInstruction",
          "old_text": null,
          "new_text": "isRLEInertInstruction(Inst)",
          "old_line_content": "",
          "new_line_content": "  if (isRLEInertInstruction(Inst))",
          "content_same": false
        },
        {
          "line": 1000,
          "old_api": null,
          "new_api": "mayReadOrWriteMemory",
          "old_text": null,
          "new_text": "Inst->mayReadOrWriteMemory()",
          "old_line_content": "",
          "new_line_content": "  if (!Inst->mayReadOrWriteMemory())",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": null,
          "new_api": "mayWriteToMemory",
          "old_text": null,
          "new_text": "Inst->mayWriteToMemory()",
          "old_line_content": "    return;",
          "new_line_content": "  if (Inst->mayWriteToMemory()) {",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": null,
          "new_api": "processUnknownWriteInst",
          "old_text": null,
          "new_text": "processUnknownWriteInst(Ctx, Inst, Kind)",
          "old_line_content": "  }",
          "new_line_content": "    processUnknownWriteInst(Ctx, Inst, Kind);",
          "content_same": false
        },
        {
          "line": 1015,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "LocationVault.size()",
          "old_line_content": "  // If all basic blocks will have their predecessors processed if",
          "new_line_content": "  unsigned LocationCount = LocationVault.size();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1024,
          "old_api": "end",
          "new_api": null,
          "old_text": "HandledBBs.end()",
          "new_text": null,
          "old_line_content": "      if (HandledBBs.find(X) == HandledBBs.end()) {",
          "new_line_content": "    ++BBCount;",
          "content_same": false
        },
        {
          "line": 1029,
          "old_api": "insert",
          "new_api": null,
          "old_text": "HandledBBs.insert(B)",
          "new_text": null,
          "old_line_content": "    HandledBBs.insert(B);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": "erase",
          "new_api": null,
          "old_text": "VM.erase(B)",
          "new_text": null,
          "old_line_content": "  VM.erase(B);",
          "new_line_content": " ",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": "test",
          "new_api": null,
          "old_text": "BV.test(B)",
          "new_text": null,
          "old_line_content": "  return BV.test(B);",
          "new_line_content": " ",
          "content_same": false
        },
        {
          "line": 555,
          "old_api": "set",
          "new_api": null,
          "old_text": "BV.set(B)",
          "new_text": null,
          "old_line_content": "  BV.set(B);",
          "new_line_content": " ",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": "find",
          "new_api": null,
          "old_text": "LocToBitIndex.find(Loc)",
          "new_text": null,
          "old_line_content": "  auto Iter = LocToBitIndex.find(Loc);",
          "new_line_content": "  // We should have the location populated by the enumerateLSLocation at this",
          "content_same": false
        },
        {
          "line": 1068,
          "old_api": "end",
          "new_api": null,
          "old_text": "LocToBitIndex.end()",
          "new_text": null,
          "old_line_content": "  assert(Iter != LocToBitIndex.end() && \"Location should have been enum'ed\");",
          "new_line_content": "  // point.",
          "content_same": false
        },
        {
          "line": 559,
          "old_api": "reset",
          "new_api": null,
          "old_text": "BV.reset(B)",
          "new_text": null,
          "old_line_content": "  BV.reset(B);",
          "new_line_content": " ",
          "content_same": false
        },
        {
          "line": 563,
          "old_api": "pred_empty",
          "new_api": null,
          "old_text": "BB->pred_empty()",
          "new_text": null,
          "old_line_content": "  if (BB->pred_empty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": "reset",
          "new_api": null,
          "old_text": "ForwardSetMax.reset()",
          "new_text": null,
          "old_line_content": "    ForwardSetMax.reset();",
          "new_line_content": "void BlockState::mergePredecessorsAvailSetMax(RLEContext &Ctx) {",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": "find",
          "new_api": null,
          "old_text": "ValToBitIndex.find(Val)",
          "new_text": null,
          "old_line_content": "  auto Iter = ValToBitIndex.find(Val);",
          "new_line_content": "  // Return the bit position of the given Val in the LSValueVault. The bit",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": "pred_begin",
          "new_api": null,
          "old_text": "BB->pred_begin()",
          "new_text": null,
          "old_line_content": "  auto Iter = BB->pred_begin();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": "getBlockState",
          "new_api": null,
          "old_text": "Ctx.getBlockState(*Iter)",
          "new_text": null,
          "old_line_content": "  ForwardSetMax = Ctx.getBlockState(*Iter).ForwardSetMax;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": "end",
          "new_api": null,
          "old_text": "ValToBitIndex.end()",
          "new_text": null,
          "old_line_content": "  if (Iter == ValToBitIndex.end()) {",
          "new_line_content": "  // if the LoadInst that generates this value is actually RLE'ed.",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": "size",
          "new_api": null,
          "old_text": "LSValueVault.size()",
          "new_text": null,
          "old_line_content": "    ValToBitIndex[Val] = LSValueVault.size();",
          "new_line_content": "  // Instead, we create the LSValues when we need them.",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": "end",
          "new_api": null,
          "old_text": "BB->getPreds().end()",
          "new_text": null,
          "old_line_content": "  if (BB->getPreds().begin() == BB->getPreds().end()) {",
          "new_line_content": "void BlockState::mergePredecessorAvailSet(RLEContext &Ctx) {",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": "reset",
          "new_api": null,
          "old_text": "ForwardSetIn.reset()",
          "new_text": null,
          "old_line_content": "    ForwardSetIn.reset();",
          "new_line_content": "  // Clear the state if the basic block has no predecessor.",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": "pred_begin",
          "new_api": null,
          "old_text": "BB->pred_begin()",
          "new_text": null,
          "old_line_content": "  auto Iter = BB->pred_begin();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": "getBlockState",
          "new_api": null,
          "old_text": "Ctx.getBlockState(*Iter)",
          "new_text": null,
          "old_line_content": "  ForwardSetIn = Ctx.getBlockState(*Iter).ForwardSetOut;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1099,
          "old_api": "getTE",
          "new_api": null,
          "old_text": "Ctx.getTE()",
          "new_text": null,
          "old_line_content": "  LSLocation::expand(L, &BB->getModule(), Locs, Ctx.getTE());",
          "new_line_content": "  unsigned CSCount = 0, CTCount = 0;",
          "content_same": false
        },
        {
          "line": 1104,
          "old_api": "isCoveringValue",
          "new_api": null,
          "old_text": "V.isCoveringValue()",
          "new_text": null,
          "old_line_content": "    if (V.isCoveringValue()) {",
          "new_line_content": "  for (auto &X : Locs) {",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": "end",
          "new_api": null,
          "old_text": "BB->getPreds().end()",
          "new_text": null,
          "old_line_content": "  if (BB->getPreds().begin() == BB->getPreds().end()) {",
          "new_line_content": "void BlockState::mergePredecessorAvailSetAndValue(RLEContext &Ctx) {",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": "reset",
          "new_api": null,
          "old_text": "ForwardSetIn.reset()",
          "new_text": null,
          "old_line_content": "    ForwardSetIn.reset();",
          "new_line_content": "  // Clear the state if the basic block has no predecessor.",
          "content_same": false
        },
        {
          "line": 599,
          "old_api": "pred_begin",
          "new_api": null,
          "old_text": "BB->pred_begin()",
          "new_text": null,
          "old_line_content": "  auto Iter = BB->pred_begin();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 600,
          "old_api": "getBlockState",
          "new_api": null,
          "old_text": "Ctx.getBlockState(*Iter)",
          "new_text": null,
          "old_line_content": "  ForwardSetIn = Ctx.getBlockState(*Iter).ForwardSetOut;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1111,
          "old_api": "size",
          "new_api": null,
          "old_text": "Locs.size()",
          "new_text": null,
          "old_line_content": "  if (CSCount == Locs.size())",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": "LSValue",
          "new_api": null,
          "old_text": "LSValue(true)",
          "new_text": null,
          "old_line_content": "        ForwardValIn[i] = Ctx.getValueBit(LSValue(true));",
          "new_line_content": "        // a covering value. We do not need to track the value itself, as we",
          "content_same": false
        },
        {
          "line": 1125,
          "old_api": "getPreds",
          "new_api": null,
          "old_text": "BB->getPreds()",
          "new_text": null,
          "old_line_content": "  for (auto Pred : BB->getPreds()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "WorkList.push_back(Pred)",
          "new_text": null,
          "old_line_content": "    WorkList.push_back(Pred);",
          "new_line_content": "  // Push in all the predecessors to get started.",
          "content_same": false
        },
        {
          "line": 617,
          "old_api": "stopTrackingValue",
          "new_api": null,
          "old_text": "stopTrackingValue(ForwardValIn, i)",
          "new_text": null,
          "old_line_content": "      stopTrackingValue(ForwardValIn, i);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": "stopTrackingLocation",
          "new_api": null,
          "old_text": "stopTrackingLocation(ForwardSetIn, i)",
          "new_text": null,
          "old_line_content": "      stopTrackingLocation(ForwardSetIn, i);",
          "new_line_content": "      // If this location does have an available value, then clear it.",
          "content_same": false
        },
        {
          "line": 1129,
          "old_api": "empty",
          "new_api": null,
          "old_text": "WorkList.empty()",
          "new_text": null,
          "old_line_content": "  while (!WorkList.empty()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1130,
          "old_api": "pop_back_val",
          "new_api": null,
          "old_text": "WorkList.pop_back_val()",
          "new_text": null,
          "old_line_content": "    auto *CurBB = WorkList.pop_back_val();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": "insert",
          "new_api": null,
          "old_text": "HandledBBs.insert(CurBB)",
          "new_text": null,
          "old_line_content": "    HandledBBs.insert(CurBB);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 626,
          "old_api": "processInstructionWithKind",
          "new_api": null,
          "old_text": "processInstructionWithKind(Ctx, &II, Kind)",
          "new_text": null,
          "old_line_content": "    processInstructionWithKind(Ctx, &II, Kind);",
          "new_line_content": "  // Iterate over instructions in forward order.",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": "reset",
          "new_api": null,
          "old_text": "ForwardSetIn.reset(BBKillSet)",
          "new_text": null,
          "old_line_content": "  ForwardSetIn.reset(BBKillSet);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1148,
          "old_api": "isConcreteValues",
          "new_api": null,
          "old_text": "Forwarder.isConcreteValues(*this, L)",
          "new_text": null,
          "old_line_content": "    if (Forwarder.isConcreteValues(*this, L)) {",
          "new_line_content": "    // locations, collect and reduce them into a single value in the current",
          "content_same": false
        },
        {
          "line": 1149,
          "old_api": "reduceValuesAtEndOfBlock",
          "new_api": null,
          "old_text": "Forwarder.reduceValuesAtEndOfBlock(*this, L)",
          "new_text": null,
          "old_line_content": "      Values[CurBB] = Forwarder.reduceValuesAtEndOfBlock(*this, L);",
          "new_line_content": "    // basic block.",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": "getTE",
          "new_api": null,
          "old_text": "Ctx.getTE()",
          "new_text": null,
          "old_line_content": "  LSLocation::expand(L, &BB->getModule(), Locs, Ctx.getTE());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1155,
          "old_api": "isCoverValues",
          "new_api": null,
          "old_text": "Forwarder.isCoverValues(*this, L)",
          "new_text": null,
          "old_line_content": "    if (Forwarder.isCoverValues(*this, L)) {",
          "new_line_content": "    // This BlockState does not contain concrete value for any of the expanded",
          "content_same": false
        },
        {
          "line": 1156,
          "old_api": "getPreds",
          "new_api": null,
          "old_text": "CurBB->getPreds()",
          "new_text": null,
          "old_line_content": "      for (auto Pred : CurBB->getPreds()) {",
          "new_line_content": "    // locations, collect in this block's predecessors.",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": "getForwardValOut",
          "new_api": null,
          "old_text": "getForwardValOut()",
          "new_text": null,
          "old_line_content": "  ValueTableMap &OTM = getForwardValOut();",
          "new_line_content": "  // Find the values that this basic block defines and the locations which",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": "size",
          "new_api": null,
          "old_text": "Locs.size()",
          "new_text": null,
          "old_line_content": "  for (unsigned i = 0; i < Locs.size(); ++i) {",
          "new_line_content": "  // we do not have a concrete value in the current basic block.",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": "getModule",
          "new_api": null,
          "old_text": "BB->getModule()",
          "new_text": null,
          "old_line_content": "  TheForwardingValue = LSValue::reduce(L, &BB->getModule(), Values,",
          "new_line_content": "  // forward.",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": "getTE",
          "new_api": null,
          "old_text": "Ctx.getTE()",
          "new_text": null,
          "old_line_content": "                                       BB->getTerminator(), Ctx.getTE());",
          "new_line_content": "  SILValue TheForwardingValue;",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": "getForwardValOut",
          "new_api": null,
          "old_text": "Forwarder.getForwardValOut()",
          "new_text": null,
          "old_line_content": "    if (!collectLocationValues(CurBB, L, LSValues, Forwarder.getForwardValOut()))",
          "new_line_content": "    // value that reaches this basic block.",
          "content_same": false
        },
        {
          "line": 1169,
          "old_api": "SILValue",
          "new_api": null,
          "old_text": "SILValue()",
          "new_text": null,
          "old_line_content": "      return SILValue();",
          "new_line_content": "    LSLocationValueMap LSValues;",
          "content_same": false
        },
        {
          "line": 1172,
          "old_api": "getTerminator",
          "new_api": null,
          "old_text": "CurBB->getTerminator()",
          "new_text": null,
          "old_line_content": "    SILInstruction *IPt = CurBB->getTerminator();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": "getModule",
          "new_api": null,
          "old_text": "BB->getModule()",
          "new_text": null,
          "old_line_content": "    Values[CurBB] = LSValue::reduce(L, &BB->getModule(), LSValues, IPt, TE);",
          "new_line_content": "    // Reduce the available values into a single SILValue we can use to forward",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": "getBM",
          "new_api": null,
          "old_text": "Ctx.getBM()",
          "new_text": null,
          "old_line_content": "  LSLocationBaseMap &BaseToLocIndex = Ctx.getBM();",
          "new_line_content": "  // Collect the locations and their corresponding values into a map.",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": "end",
          "new_api": null,
          "old_text": "BaseToLocIndex.end()",
          "new_text": null,
          "old_line_content": "  if (BaseToLocIndex.find(Mem) != BaseToLocIndex.end()) {",
          "new_line_content": "  LSLocation L;",
          "content_same": false
        },
        {
          "line": 1178,
          "old_api": "getModule",
          "new_api": null,
          "old_text": "BB->getModule()",
          "new_text": null,
          "old_line_content": "  Updater.Initialize(L.getType(&BB->getModule()).getObjectType());",
          "new_line_content": "  // Finally, collect all the values for the SILArgument, materialize it using",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": "getUnderlyingObject",
          "new_api": null,
          "old_text": "getUnderlyingObject(Mem)",
          "new_text": null,
          "old_line_content": "    SILValue UO = getUnderlyingObject(Mem);",
          "new_line_content": "    L = BaseToLocIndex[Mem];",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": "NewProjectionPath::getProjectionPath(UO, Mem)",
          "new_api": null,
          "old_text": "NewProjectionPath::getProjectionPath(UO, Mem)",
          "new_text": null,
          "old_line_content": "    L = LSLocation(UO, NewProjectionPath::getProjectionPath(UO, Mem));",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 1183,
          "old_api": "GetValueInMiddleOfBlock",
          "new_api": null,
          "old_text": "Updater.GetValueInMiddleOfBlock(BB)",
          "new_text": null,
          "old_line_content": "  return Updater.GetValueInMiddleOfBlock(BB);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": "getForwardValIn",
          "new_api": null,
          "old_text": "getForwardValIn()",
          "new_text": null,
          "old_line_content": "  if (!Ctx.collectLocationValues(I->getParent(), L, Values, getForwardValIn()))",
          "new_line_content": "  LSLocationValueMap Values;",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": "getModule",
          "new_api": null,
          "old_text": "I->getModule()",
          "new_text": null,
          "old_line_content": "  SILModule *Mod = &I->getModule();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 680,
          "old_api": "getTE",
          "new_api": null,
          "old_text": "Ctx.getTE()",
          "new_text": null,
          "old_line_content": "  SILValue TheForwardingValue = LSValue::reduce(L, Mod, Values, I, Ctx.getTE());",
          "new_line_content": "  // Reduce the available values into a single SILValue we can use to forward.",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": "getModule",
          "new_api": null,
          "old_text": "BB->getModule()",
          "new_text": null,
          "old_line_content": "  LSLocation::expand(L, &BB->getModule(), Locs, TE);",
          "new_line_content": "  LSLocationSet CSLocs;",
          "content_same": false
        },
        {
          "line": 1197,
          "old_api": "getLocationBit",
          "new_api": null,
          "old_text": "getLocationBit(X)",
          "new_text": null,
          "old_line_content": "    Values[X] = getValue(VM[getLocationBit(X)]);",
          "new_line_content": "  // we do not have a concrete value in the current basic block.",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": "isCoveringValue",
          "new_api": null,
          "old_text": "Values[X].isCoveringValue()",
          "new_text": null,
          "old_line_content": "    if (!Values[X].isCoveringValue())",
          "new_line_content": "  for (auto &X : Locs) {",
          "content_same": false
        },
        {
          "line": 1206,
          "old_api": "LSLocation::reduce(L, Mod, CSLocs, TE)",
          "new_api": null,
          "old_text": "LSLocation::reduce(L, Mod, CSLocs, TE)",
          "new_text": null,
          "old_line_content": "  LSLocation::reduce(L, Mod, CSLocs, TE);",
          "new_line_content": "  // block, try to reduce it to the minimum # of locations possible, this",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": "computePredecessorLocationValue",
          "new_api": null,
          "old_text": "computePredecessorLocationValue(BB, X)",
          "new_text": null,
          "old_line_content": "    SILValue V = computePredecessorLocationValue(BB, X);",
          "new_line_content": "  // materialize them there.",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": "LSLocation::expand(X, Mod, Locs, TE)",
          "new_api": null,
          "old_text": "LSLocation::expand(X, Mod, Locs, TE)",
          "new_text": null,
          "old_line_content": "    LSLocation::expand(X, Mod, Locs, TE);",
          "new_line_content": "    LSLocationList Locs;",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": "LSValue::expand(V, Mod, Vals, TE)",
          "new_api": null,
          "old_text": "LSValue::expand(V, Mod, Vals, TE)",
          "new_text": null,
          "old_line_content": "    LSValue::expand(V, Mod, Vals, TE);",
          "new_line_content": "    LSValueList Vals;",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": "startTrackingLocation",
          "new_api": null,
          "old_text": "startTrackingLocation(ForwardSetIn, B)",
          "new_text": null,
          "old_line_content": "  startTrackingLocation(ForwardSetIn, B);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": "startTrackingLocation",
          "new_api": null,
          "old_text": "startTrackingLocation(BBGenSet, B)",
          "new_text": null,
          "old_line_content": "  startTrackingLocation(BBGenSet, B);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": "stopTrackingLocation",
          "new_api": null,
          "old_text": "stopTrackingLocation(BBKillSet, B)",
          "new_text": null,
          "old_line_content": "  stopTrackingLocation(BBKillSet, B);",
          "new_line_content": "void BlockState::updateGenKillSetForRead(RLEContext &Ctx, unsigned B) {",
          "content_same": false
        },
        {
          "line": 1231,
          "old_api": "getReversePostOrder",
          "new_api": null,
          "old_text": "PO->getReversePostOrder()",
          "new_text": null,
          "old_line_content": "  for (SILBasicBlock *BB : PO->getReversePostOrder()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": "getBlockState",
          "new_api": null,
          "old_text": "getBlockState(BB)",
          "new_text": null,
          "old_line_content": "    BlockState &S = getBlockState(BB);",
          "new_line_content": "void RLEContext::processBasicBlocksForGenKillSet() {",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": "startTrackingValue",
          "new_api": null,
          "old_text": "startTrackingValue(ForwardValIn, L, V)",
          "new_text": null,
          "old_line_content": "  startTrackingValue(ForwardValIn, L, V);",
          "new_line_content": "                                               unsigned V) {",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": "startTrackingLocation",
          "new_api": null,
          "old_text": "startTrackingLocation(ForwardSetIn, L)",
          "new_text": null,
          "old_line_content": "  startTrackingLocation(ForwardSetIn, L);",
          "new_line_content": "  // Track the new location and value.",
          "content_same": false
        },
        {
          "line": 1235,
          "old_api": "mergePredecessorsAvailSetMax",
          "new_api": null,
          "old_text": "S.mergePredecessorsAvailSetMax(*this)",
          "new_text": null,
          "old_line_content": "    S.mergePredecessorsAvailSetMax(*this);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": "getLocation",
          "new_api": null,
          "old_text": "Ctx.getLocation(B)",
          "new_text": null,
          "old_line_content": "  LSLocation &R = Ctx.getLocation(B);",
          "new_line_content": "  // This is a store, invalidate any location that this location may alias, as",
          "content_same": false
        },
        {
          "line": 1241,
          "old_api": "end",
          "new_api": null,
          "old_text": "BB->end()",
          "new_text": null,
          "old_line_content": "    for (auto I = BB->begin(), E = BB->end(); I != E; ++I) {",
          "new_line_content": "    // To optimize this process, we also compute the AvailSetMax at particular",
          "content_same": false
        },
        {
          "line": 1242,
          "old_api": "dyn_cast<LoadInst>(&*I)",
          "new_api": null,
          "old_text": "dyn_cast<LoadInst>(&*I)",
          "new_text": null,
          "old_line_content": "      if (auto *LI = dyn_cast<LoadInst>(&*I)) {",
          "new_line_content": "    // point in the basic block.",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": "getAA",
          "new_api": null,
          "old_text": "Ctx.getAA()",
          "new_text": null,
          "old_line_content": "    if (!L.isMayAliasLSLocation(R, Ctx.getAA()))",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 1246,
          "old_api": "processStoreInst",
          "new_api": null,
          "old_text": "S.processStoreInst(*this, SI, RLEKind::ComputeAvailSetMax)",
          "new_text": null,
          "old_line_content": "        S.processStoreInst(*this, SI, RLEKind::ComputeAvailSetMax);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": "stopTrackingLocation",
          "new_api": null,
          "old_text": "stopTrackingLocation(BBGenSet, i)",
          "new_text": null,
          "old_line_content": "    stopTrackingLocation(BBGenSet, i);",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": "startTrackingLocation",
          "new_api": null,
          "old_text": "startTrackingLocation(BBKillSet, i)",
          "new_text": null,
          "old_line_content": "    startTrackingLocation(BBKillSet, i);",
          "new_line_content": "    // MayAlias, invalidate the location.",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": "processInstructionWithKind",
          "new_api": null,
          "old_text": "S.processInstructionWithKind(*this, &*I, RLEKind::ComputeAvailGenKillSet)",
          "new_text": null,
          "old_line_content": "      S.processInstructionWithKind(*this, &*I, RLEKind::ComputeAvailGenKillSet);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": "startTrackingLocation",
          "new_api": null,
          "old_text": "startTrackingLocation(BBGenSet, B)",
          "new_text": null,
          "old_line_content": "  startTrackingLocation(BBGenSet, B);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "stopTrackingLocation",
          "new_api": null,
          "old_text": "stopTrackingLocation(BBKillSet, B)",
          "new_text": null,
          "old_line_content": "  stopTrackingLocation(BBKillSet, B);",
          "new_line_content": "  // Start tracking this location.",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": "startTrackingLocation",
          "new_api": null,
          "old_text": "startTrackingLocation(ForwardSetMax, B)",
          "new_text": null,
          "old_line_content": "  startTrackingLocation(ForwardSetMax, B);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": "startTrackingLocation",
          "new_api": null,
          "old_text": "startTrackingLocation(ForwardSetMax, B)",
          "new_text": null,
          "old_line_content": "  startTrackingLocation(ForwardSetMax, B);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1263,
          "old_api": "getPostOrder",
          "new_api": null,
          "old_text": "PO->getPostOrder()",
          "new_text": null,
          "old_line_content": "  for (SILBasicBlock *BB : PO->getPostOrder()) {",
          "new_line_content": "  // Push into the worklist in post order so that we can pop from the back and",
          "content_same": false
        },
        {
          "line": 1264,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "WorkList.push_back(BB)",
          "new_text": null,
          "old_line_content": "    WorkList.push_back(BB);",
          "new_line_content": "  // get reverse post order.",
          "content_same": false
        },
        {
          "line": 1268,
          "old_api": "pop_back_val",
          "new_api": null,
          "old_text": "WorkList.pop_back_val()",
          "new_text": null,
          "old_line_content": "    SILBasicBlock *BB = WorkList.pop_back_val();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": "getLocation",
          "new_api": null,
          "old_text": "Ctx.getLocation(B)",
          "new_text": null,
          "old_line_content": "  LSLocation &R = Ctx.getLocation(B);",
          "new_line_content": "  // This is a store, invalidate any location that this location may alias, as",
          "content_same": false
        },
        {
          "line": 1272,
          "old_api": "getBlockState",
          "new_api": null,
          "old_text": "getBlockState(BB)",
          "new_text": null,
          "old_line_content": "    BlockState &Forwarder = getBlockState(BB);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": "getAA",
          "new_api": null,
          "old_text": "Ctx.getAA()",
          "new_text": null,
          "old_line_content": "    if (!L.isMayAliasLSLocation(R, Ctx.getAA()))",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": "stopTrackingLocation",
          "new_api": null,
          "old_text": "stopTrackingLocation(ForwardSetIn, i)",
          "new_text": null,
          "old_line_content": "    stopTrackingLocation(ForwardSetIn, i);",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 1277,
          "old_api": "getSuccessors",
          "new_api": null,
          "old_text": "BB->getSuccessors()",
          "new_text": null,
          "old_line_content": "      for (auto &X : BB->getSuccessors()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1280,
          "old_api": "end",
          "new_api": null,
          "old_text": "HandledBBs.end()",
          "new_text": null,
          "old_line_content": "        if (HandledBBs.find(X) != HandledBBs.end())",
          "new_line_content": "        // We do not push basic block into the worklist if its already",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": "startTrackingLocation",
          "new_api": null,
          "old_text": "startTrackingLocation(ForwardSetIn, B)",
          "new_text": null,
          "old_line_content": "  startTrackingLocation(ForwardSetIn, B);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": "getLocation",
          "new_api": null,
          "old_text": "Ctx.getLocation(L)",
          "new_text": null,
          "old_line_content": "  LSLocation &R = Ctx.getLocation(L);",
          "new_line_content": "  // This is a store, invalidate any location that this location may alias, as",
          "content_same": false
        },
        {
          "line": 1289,
          "old_api": "getReversePostOrder",
          "new_api": null,
          "old_text": "PO->getReversePostOrder()",
          "new_text": null,
          "old_line_content": "  for (SILBasicBlock *BB : PO->getReversePostOrder()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1290,
          "old_api": "getBlockState",
          "new_api": null,
          "old_text": "getBlockState(BB)",
          "new_text": null,
          "old_line_content": "    BlockState &Forwarder = getBlockState(BB);",
          "new_line_content": "void RLEContext::processBasicBlocksForAvailValue() {",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": "getAA",
          "new_api": null,
          "old_text": "Ctx.getAA()",
          "new_text": null,
          "old_line_content": "    if (!L.isMayAliasLSLocation(R, Ctx.getAA()))",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 1295,
          "old_api": "mergePredecessorAvailSetAndValue",
          "new_api": null,
          "old_text": "Forwarder.mergePredecessorAvailSetAndValue(*this)",
          "new_text": null,
          "old_line_content": "    Forwarder.mergePredecessorAvailSetAndValue(*this);",
          "new_line_content": "    // lists of available LSLocations and their values that reach the",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": "stopTrackingValue",
          "new_api": null,
          "old_text": "stopTrackingValue(ForwardValIn, i)",
          "new_text": null,
          "old_line_content": "    stopTrackingValue(ForwardValIn, i);",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": "stopTrackingLocation",
          "new_api": null,
          "old_text": "stopTrackingLocation(ForwardSetIn, i)",
          "new_text": null,
          "old_line_content": "    stopTrackingLocation(ForwardSetIn, i);",
          "new_line_content": "    // MayAlias, invalidate the location and value.",
          "content_same": false
        },
        {
          "line": 1300,
          "old_api": "processBasicBlockWithKind",
          "new_api": null,
          "old_text": "Forwarder.processBasicBlockWithKind(*this, RLEKind::ComputeAvailValue)",
          "new_text": null,
          "old_line_content": "    Forwarder.processBasicBlockWithKind(*this, RLEKind::ComputeAvailValue);",
          "new_line_content": "    // loads. We also update lists of stores|loads to reflect the end",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": "startTrackingLocation",
          "new_api": null,
          "old_text": "startTrackingLocation(ForwardSetIn, L)",
          "new_text": null,
          "old_line_content": "  startTrackingLocation(ForwardSetIn, L);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "startTrackingValue",
          "new_api": null,
          "old_text": "startTrackingValue(ForwardValIn, L, V)",
          "new_text": null,
          "old_line_content": "  startTrackingValue(ForwardValIn, L, V);",
          "new_line_content": "  // Start tracking this location and value.",
          "content_same": false
        },
        {
          "line": 1305,
          "old_api": "updateForwardValOut",
          "new_api": null,
          "old_text": "Forwarder.updateForwardValOut()",
          "new_text": null,
          "old_line_content": "    Forwarder.updateForwardValOut();",
          "new_line_content": "    // the available BitVector here as they should have been initialized and",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": "getBM",
          "new_api": null,
          "old_text": "Ctx.getBM()",
          "new_text": null,
          "old_line_content": "  LSLocationBaseMap &BaseToLocIndex = Ctx.getBM();",
          "new_line_content": "  // Initialize the LSLocation.",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": "end",
          "new_api": null,
          "old_text": "BaseToLocIndex.end()",
          "new_text": null,
          "old_line_content": "  if (BaseToLocIndex.find(Mem) != BaseToLocIndex.end()) {",
          "new_line_content": "  LSLocation L;",
          "content_same": false
        },
        {
          "line": 1310,
          "old_api": "getReversePostOrder",
          "new_api": null,
          "old_text": "PO->getReversePostOrder()",
          "new_text": null,
          "old_line_content": "  for (SILBasicBlock *BB : PO->getReversePostOrder()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1311,
          "old_api": "getBlockState",
          "new_api": null,
          "old_text": "getBlockState(BB)",
          "new_text": null,
          "old_line_content": "    BlockState &Forwarder = getBlockState(BB);",
          "new_line_content": "void RLEContext::processBasicBlocksForRLE() {",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": "getUnderlyingObject",
          "new_api": null,
          "old_text": "getUnderlyingObject(Mem)",
          "new_text": null,
          "old_line_content": "    SILValue UO = getUnderlyingObject(Mem);",
          "new_line_content": "    L = BaseToLocIndex[Mem];",
          "content_same": false
        },
        {
          "line": 802,
          "old_api": "NewProjectionPath::getProjectionPath(UO, Mem)",
          "new_api": null,
          "old_text": "NewProjectionPath::getProjectionPath(UO, Mem)",
          "new_text": null,
          "old_line_content": "    L = LSLocation(UO, NewProjectionPath::getProjectionPath(UO, Mem));",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 1316,
          "old_api": "mergePredecessorAvailSetAndValue",
          "new_api": null,
          "old_text": "Forwarder.mergePredecessorAvailSetAndValue(*this)",
          "new_text": null,
          "old_line_content": "    Forwarder.mergePredecessorAvailSetAndValue(*this);",
          "new_line_content": "    // lists of available LSLocations and their values that reach the",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": "isValid",
          "new_api": null,
          "old_text": "L.isValid()",
          "new_text": null,
          "old_line_content": "  if (!L.isValid()) {",
          "new_line_content": "  // If we cant figure out the Base or Projection Path for the write,",
          "content_same": false
        },
        {
          "line": 1319,
          "old_api": "processBasicBlockWithKind",
          "new_api": null,
          "old_text": "Forwarder.processBasicBlockWithKind(*this, RLEKind::PerformRLE)",
          "new_text": null,
          "old_line_content": "    Forwarder.processBasicBlockWithKind(*this, RLEKind::PerformRLE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": "isComputeAvailSetMax",
          "new_api": null,
          "old_text": "isComputeAvailSetMax(Kind)",
          "new_text": null,
          "old_line_content": "    if (!isComputeAvailSetMax(Kind)) {",
          "new_line_content": "    // we can ignore unknown store instructions if we are computing the",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": "processUnknownWriteInst",
          "new_api": null,
          "old_text": "processUnknownWriteInst(Ctx, I, Kind)",
          "new_text": null,
          "old_line_content": "      processUnknownWriteInst(Ctx, I, Kind);",
          "new_line_content": "    // AvailSetMax.",
          "content_same": false
        },
        {
          "line": 1322,
          "old_api": "updateForwardSetOut",
          "new_api": null,
          "old_text": "Forwarder.updateForwardSetOut()",
          "new_text": null,
          "old_line_content": "    Forwarder.updateForwardSetOut();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1323,
          "old_api": "updateForwardValOut",
          "new_api": null,
          "old_text": "Forwarder.updateForwardValOut()",
          "new_text": null,
          "old_line_content": "    Forwarder.updateForwardValOut();",
          "new_line_content": "    // Update the locations with available values and their values.",
          "content_same": false
        },
        {
          "line": 1329,
          "old_api": "processBasicBlocksForGenKillSet",
          "new_api": null,
          "old_text": "processBasicBlocksForGenKillSet()",
          "new_text": null,
          "old_line_content": "  processBasicBlocksForGenKillSet();",
          "new_line_content": "void RLEContext::runIterativeRLE() {",
          "content_same": false
        },
        {
          "line": 819,
          "old_api": "getTE",
          "new_api": null,
          "old_text": "Ctx.getTE()",
          "new_text": null,
          "old_line_content": "  LSLocation::expand(L, &I->getModule(), Locs, Ctx.getTE());",
          "new_line_content": "  // them as separate writes.",
          "content_same": false
        },
        {
          "line": 1333,
          "old_api": "processBasicBlocksWithGenKillSet",
          "new_api": null,
          "old_text": "processBasicBlocksWithGenKillSet()",
          "new_text": null,
          "old_line_content": "  processBasicBlocksWithGenKillSet();",
          "new_line_content": "  // Process basic blocks in RPO. After the data flow converges, run last",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": "size",
          "new_api": null,
          "old_text": "Locs.size()",
          "new_text": null,
          "old_line_content": "    for (unsigned i = 0; i < Locs.size(); ++i) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1340,
          "old_api": "processBasicBlocksForAvailValue",
          "new_api": null,
          "old_text": "processBasicBlocksForAvailValue()",
          "new_text": null,
          "old_line_content": "  processBasicBlocksForAvailValue();",
          "new_line_content": "  // predecessor blocks which have not been processed when a basic block is",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "isComputeAvailGenKillSet",
          "new_api": null,
          "old_text": "isComputeAvailGenKillSet(Kind)",
          "new_text": null,
          "old_line_content": "  if (isComputeAvailGenKillSet(Kind)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": "size",
          "new_api": null,
          "old_text": "Locs.size()",
          "new_text": null,
          "old_line_content": "    for (unsigned i = 0; i < Locs.size(); ++i) {",
          "new_line_content": "  // Are we computing the genset and killset ?",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": "getTE",
          "new_api": null,
          "old_text": "Ctx.getTE()",
          "new_text": null,
          "old_line_content": "  LSValue::expand(Val, &I->getModule(), Vals, Ctx.getTE());",
          "new_line_content": "  // Are we computing available value or performing RLE?",
          "content_same": false
        },
        {
          "line": 327,
          "old_api": "resize",
          "new_api": null,
          "old_text": "ForwardSetMax.resize(LocationNum, true)",
          "new_text": null,
          "old_line_content": "    ForwardSetMax.resize(LocationNum, true);",
          "new_line_content": "    // If we are running an optimsitic data flow, set forward max to true",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": "isPerformingRLE",
          "new_api": null,
          "old_text": "isPerformingRLE(Kind)",
          "new_text": null,
          "old_line_content": "  if (isComputeAvailValue(Kind) || isPerformingRLE(Kind)) {",
          "new_line_content": "  LSValueList Vals;",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": "resize",
          "new_api": null,
          "old_text": "BBKillSet.resize(LocationNum, false)",
          "new_text": null,
          "old_line_content": "    BBKillSet.resize(LocationNum, false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1358,
          "old_api": "LSLocation::enumerateLSLocations(*Fn, LocationVault, LocToBitIndex,\n                                   BaseToLocIndex, TE)",
          "new_api": null,
          "old_text": "LSLocation::enumerateLSLocations(*Fn, LocationVault, LocToBitIndex,\n                                   BaseToLocIndex, TE)",
          "new_text": null,
          "old_line_content": "  LSLocation::enumerateLSLocations(*Fn, LocationVault, LocToBitIndex,",
          "new_line_content": "  // Walk over the function and find all the locations accessed by",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": "llvm_unreachable",
          "new_api": null,
          "old_text": "llvm_unreachable(\"Unknown RLE compute kind\")",
          "new_text": null,
          "old_line_content": "  llvm_unreachable(\"Unknown RLE compute kind\");",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1362,
          "old_api": "getProcessFunctionKind",
          "new_api": null,
          "old_text": "getProcessFunctionKind()",
          "new_text": null,
          "old_line_content": "  ProcessKind Kind = getProcessFunctionKind();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 854,
          "old_api": "getBM",
          "new_api": null,
          "old_text": "Ctx.getBM()",
          "new_text": null,
          "old_line_content": "  LSLocationBaseMap &BaseToLocIndex = Ctx.getBM();",
          "new_line_content": "  // Initialize the LSLocation.",
          "content_same": false
        },
        {
          "line": 855,
          "old_api": "end",
          "new_api": null,
          "old_text": "BaseToLocIndex.end()",
          "new_text": null,
          "old_line_content": "  if (BaseToLocIndex.find(Mem) != BaseToLocIndex.end()) {",
          "new_line_content": "  LSLocation L;",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": "getUnderlyingObject",
          "new_api": null,
          "old_text": "getUnderlyingObject(Mem)",
          "new_text": null,
          "old_line_content": "    SILValue UO = getUnderlyingObject(Mem);",
          "new_line_content": "    L = BaseToLocIndex[Mem];",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": "NewProjectionPath::getProjectionPath(UO, Mem)",
          "new_api": null,
          "old_text": "NewProjectionPath::getProjectionPath(UO, Mem)",
          "new_text": null,
          "old_line_content": "    L = LSLocation(UO, NewProjectionPath::getProjectionPath(UO, Mem));",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 864,
          "old_api": "isValid",
          "new_api": null,
          "old_text": "L.isValid()",
          "new_text": null,
          "old_line_content": "  if (!L.isValid())",
          "new_line_content": "  // If we cant figure out the Base or Projection Path for the read, simply",
          "content_same": false
        },
        {
          "line": 1376,
          "old_api": "BlockState",
          "new_api": null,
          "old_text": "BlockState()",
          "new_text": null,
          "old_line_content": "    BBToLocState[&B] = BlockState();",
          "new_line_content": "  // vector to the appropriate size.",
          "content_same": false
        },
        {
          "line": 1377,
          "old_api": "isReachable",
          "new_api": null,
          "old_text": "isReachable(&B)",
          "new_text": null,
          "old_line_content": "    BBToLocState[&B].init(&B, LocationVault.size(), MultiIteration && isReachable(&B));",
          "new_line_content": "  for (auto &B : *Fn) {",
          "content_same": false
        },
        {
          "line": 1381,
          "old_api": "runIterativeRLE",
          "new_api": null,
          "old_text": "runIterativeRLE()",
          "new_text": null,
          "old_line_content": "    runIterativeRLE();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": "getTE",
          "new_api": null,
          "old_text": "Ctx.getTE()",
          "new_text": null,
          "old_line_content": "  LSLocation::expand(L, &I->getModule(), Locs, Ctx.getTE());",
          "new_line_content": "  // them as separate reads.",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": "size",
          "new_api": null,
          "old_text": "Locs.size()",
          "new_text": null,
          "old_line_content": "    for (unsigned i = 0; i < Locs.size(); ++i) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1385,
          "old_api": "processBasicBlocksForRLE",
          "new_api": null,
          "old_text": "processBasicBlocksForRLE()",
          "new_text": null,
          "old_line_content": "  processBasicBlocksForRLE();",
          "new_line_content": "  // We have the available value bit computed and the local forwarding value.",
          "content_same": false
        },
        {
          "line": 1391,
          "old_api": "getRL",
          "new_api": null,
          "old_text": "X.second.getRL()",
          "new_text": null,
          "old_line_content": "    for (auto &F : X.second.getRL()) {",
          "new_line_content": "  bool SILChanged = false;",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": "isComputeAvailGenKillSet",
          "new_api": null,
          "old_text": "isComputeAvailGenKillSet(Kind)",
          "new_text": null,
          "old_line_content": "  if (isComputeAvailGenKillSet(Kind)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": "size",
          "new_api": null,
          "old_text": "Locs.size()",
          "new_text": null,
          "old_line_content": "    for (unsigned i = 0; i < Locs.size(); ++i) {",
          "new_line_content": "  // Are we computing the genset and killset.",
          "content_same": false
        },
        {
          "line": 1392,
          "old_api": "SILValue",
          "new_api": null,
          "old_text": "SILValue(F.first)",
          "new_text": null,
          "old_line_content": "      DEBUG(llvm::dbgs() << \"Replacing  \" << SILValue(F.first) << \"With \"",
          "new_line_content": "  for (auto &X : BBToLocState) {",
          "content_same": false
        },
        {
          "line": 1395,
          "old_api": "replaceAllUsesWith",
          "new_api": null,
          "old_text": "F.first->replaceAllUsesWith(F.second)",
          "new_text": null,
          "old_line_content": "      F.first->replaceAllUsesWith(F.second);",
          "new_line_content": "                         << F.second);",
          "content_same": false
        },
        {
          "line": 1396,
          "old_api": "insert",
          "new_api": null,
          "old_text": "InstsToDelete.insert(F.first)",
          "new_text": null,
          "old_line_content": "      InstsToDelete.insert(F.first);",
          "new_line_content": "      SILChanged = true;",
          "content_same": false
        },
        {
          "line": 376,
          "old_api": "getValueStateAtEndOfBlock",
          "new_api": null,
          "old_text": "getValueStateAtEndOfBlock(Ctx, L)",
          "new_text": null,
          "old_line_content": "    return getValueStateAtEndOfBlock(Ctx, L) == ValueState::CoverValues;",
          "new_line_content": "  /// Wrappers to query the value state of the location in this BlockState.",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": "getTE",
          "new_api": null,
          "old_text": "Ctx.getTE()",
          "new_text": null,
          "old_line_content": "  LSValue::expand(Val, &I->getModule(), Vals, Ctx.getTE());",
          "new_line_content": "  bool CanForward = true;",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": "getValueStateAtEndOfBlock",
          "new_api": null,
          "old_text": "getValueStateAtEndOfBlock(Ctx, L)",
          "new_text": null,
          "old_line_content": "    return getValueStateAtEndOfBlock(Ctx, L) == ValueState::ConcreteValues;",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": "isPerformingRLE",
          "new_api": null,
          "old_text": "isPerformingRLE(Kind)",
          "new_text": null,
          "old_line_content": "  if (isComputeAvailValue(Kind) || isPerformingRLE(Kind)) {",
          "new_line_content": "  LSValueList Vals;",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": "getValueBit",
          "new_api": null,
          "old_text": "Ctx.getValueBit(Vals[i])",
          "new_text": null,
          "old_line_content": "                                    Ctx.getValueBit(Vals[i]));",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 1408,
          "old_api": "use_empty",
          "new_api": null,
          "old_text": "X->use_empty()",
          "new_text": null,
          "old_line_content": "    if (!X->use_empty())",
          "new_line_content": "    //",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": "isPerformingRLE",
          "new_api": null,
          "old_text": "isPerformingRLE(Kind)",
          "new_text": null,
          "old_line_content": "  if (!isPerformingRLE(Kind) || !CanForward)",
          "new_line_content": "  // Simply return if we are not performing RLE or we do not have all the",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": "setupRLE",
          "new_api": null,
          "old_text": "setupRLE(Ctx, I, Mem)",
          "new_text": null,
          "old_line_content": "  setupRLE(Ctx, I, Mem);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": "getSrc",
          "new_api": null,
          "old_text": "SI->getSrc()",
          "new_text": null,
          "old_line_content": "  processWrite(Ctx, SI, SI->getDest(), SI->getSrc(), Kind);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1427,
          "old_api": "getFunction",
          "new_api": null,
          "old_text": "getFunction()",
          "new_text": null,
          "old_line_content": "    SILFunction *F = getFunction();",
          "new_line_content": "  /// The entry point to the transformation.",
          "content_same": false
        },
        {
          "line": 1428,
          "old_api": "getName",
          "new_api": null,
          "old_text": "F->getName()",
          "new_text": null,
          "old_line_content": "    DEBUG(llvm::dbgs() << \"*** RLE on function: \" << F->getName() << \" ***\\n\");",
          "new_line_content": "  void run() override {",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": "SILValue",
          "new_api": null,
          "old_text": "SILValue(LI)",
          "new_text": null,
          "old_line_content": "  processRead(Ctx, LI, LI->getOperand(), SILValue(LI), Kind);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1431,
          "old_api": "PM->getAnalysis<TypeExpansionAnalysis>()",
          "new_api": null,
          "old_text": "PM->getAnalysis<TypeExpansionAnalysis>()",
          "new_text": null,
          "old_line_content": "    auto *TE = PM->getAnalysis<TypeExpansionAnalysis>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": "getAA",
          "new_api": null,
          "old_text": "Ctx.getAA()",
          "new_text": null,
          "old_line_content": "  auto *AA = Ctx.getAA();",
          "new_line_content": "void BlockState::processUnknownWriteInstForGenKillSet(RLEContext &Ctx,",
          "content_same": false
        },
        {
          "line": 1435,
          "old_api": "run",
          "new_api": null,
          "old_text": "RLE.run()",
          "new_text": null,
          "old_line_content": "    if (RLE.run()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1436,
          "old_api": "invalidateAnalysis",
          "new_api": null,
          "old_text": "invalidateAnalysis(SILAnalysis::InvalidationKind::Instructions)",
          "new_text": null,
          "old_line_content": "      invalidateAnalysis(SILAnalysis::InvalidationKind::Instructions);",
          "new_line_content": "    RLEContext RLE(F, PM, AA, TE, PO);",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": "getLocation",
          "new_api": null,
          "old_text": "Ctx.getLocation(i)",
          "new_text": null,
          "old_line_content": "    LSLocation &R = Ctx.getLocation(i);",
          "new_line_content": "    // TODO: checking may alias with Base is overly conservative,",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": "getBase",
          "new_api": null,
          "old_text": "R.getBase()",
          "new_text": null,
          "old_line_content": "    if (!AA->mayWriteToMemory(I, R.getBase()))",
          "new_line_content": "    // we should check may alias with base plus projection path.",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "stopTrackingLocation",
          "new_api": null,
          "old_text": "stopTrackingLocation(BBGenSet, i)",
          "new_text": null,
          "old_line_content": "    stopTrackingLocation(BBGenSet, i);",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": "startTrackingLocation",
          "new_api": null,
          "old_text": "startTrackingLocation(BBKillSet, i)",
          "new_text": null,
          "old_line_content": "    startTrackingLocation(BBKillSet, i);",
          "new_line_content": "    // MayAlias.",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": "getAA",
          "new_api": null,
          "old_text": "Ctx.getAA()",
          "new_text": null,
          "old_line_content": "  auto *AA = Ctx.getAA();",
          "new_line_content": "void BlockState::processUnknownWriteInstForRLE(RLEContext &Ctx,",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": "getLocation",
          "new_api": null,
          "old_text": "Ctx.getLocation(i)",
          "new_text": null,
          "old_line_content": "    LSLocation &R = Ctx.getLocation(i);",
          "new_line_content": "    // TODO: checking may alias with Base is overly conservative,",
          "content_same": false
        },
        {
          "line": 950,
          "old_api": "getBase",
          "new_api": null,
          "old_text": "R.getBase()",
          "new_text": null,
          "old_line_content": "    if (!AA->mayWriteToMemory(I, R.getBase()))",
          "new_line_content": "    // we should check may alias with base plus projection path.",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "stopTrackingLocation",
          "new_api": null,
          "old_text": "stopTrackingLocation(ForwardSetIn, i)",
          "new_text": null,
          "old_line_content": "    stopTrackingLocation(ForwardSetIn, i);",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": "stopTrackingValue",
          "new_api": null,
          "old_text": "stopTrackingValue(ForwardValIn, i)",
          "new_text": null,
          "old_line_content": "    stopTrackingValue(ForwardValIn, i);",
          "new_line_content": "    // MayAlias.",
          "content_same": false
        },
        {
          "line": 961,
          "old_api": "isComputeAvailGenKillSet",
          "new_api": null,
          "old_text": "isComputeAvailGenKillSet(Kind)",
          "new_text": null,
          "old_line_content": "  if (isComputeAvailGenKillSet(Kind)) {",
          "new_line_content": "                                         RLEKind Kind) {",
          "content_same": false
        },
        {
          "line": 962,
          "old_api": "processUnknownWriteInstForGenKillSet",
          "new_api": null,
          "old_text": "processUnknownWriteInstForGenKillSet(Ctx, I)",
          "new_text": null,
          "old_line_content": "    processUnknownWriteInstForGenKillSet(Ctx, I);",
          "new_line_content": "  // Are we computing the genset and killset ?",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": "isPerformingRLE",
          "new_api": null,
          "old_text": "isPerformingRLE(Kind)",
          "new_text": null,
          "old_line_content": "  if (isComputeAvailValue(Kind) || isPerformingRLE(Kind)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 968,
          "old_api": "processUnknownWriteInstForRLE",
          "new_api": null,
          "old_text": "processUnknownWriteInstForRLE(Ctx, I)",
          "new_text": null,
          "old_line_content": "    processUnknownWriteInstForRLE(Ctx, I);",
          "new_line_content": "  // Are we computing the available value or doing RLE ?",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": "llvm_unreachable",
          "new_api": null,
          "old_text": "llvm_unreachable(\"Unknown RLE compute kind\")",
          "new_text": null,
          "old_line_content": "  llvm_unreachable(\"Unknown RLE compute kind\");",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": "dyn_cast<StoreInst>(Inst)",
          "new_api": null,
          "old_text": "dyn_cast<StoreInst>(Inst)",
          "new_text": null,
          "old_line_content": "  if (auto *SI = dyn_cast<StoreInst>(Inst)) {",
          "new_line_content": "                                            RLEKind Kind) {",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": "processStoreInst",
          "new_api": null,
          "old_text": "processStoreInst(Ctx, SI, Kind)",
          "new_text": null,
          "old_line_content": "    processStoreInst(Ctx, SI, Kind);",
          "new_line_content": "  // This is a StoreInst, try to see whether it clobbers any forwarding value",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": "dyn_cast<LoadInst>(Inst)",
          "new_api": null,
          "old_text": "dyn_cast<LoadInst>(Inst)",
          "new_text": null,
          "old_line_content": "  if (auto *LI = dyn_cast<LoadInst>(Inst)) {",
          "new_line_content": "  // This is a LoadInst. Let's see if we can find a previous loaded, stored",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": "processLoadInst",
          "new_api": null,
          "old_text": "processLoadInst(Ctx, LI, Kind)",
          "new_text": null,
          "old_line_content": "    processLoadInst(Ctx, LI, Kind);",
          "new_line_content": "  // value to use instead of this load.",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": "isRLEInertInstruction",
          "new_api": null,
          "old_text": "isRLEInertInstruction(Inst)",
          "new_text": null,
          "old_line_content": "  if (isRLEInertInstruction(Inst))",
          "new_line_content": "  // If this instruction has side effects, but is inert from a load store",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": "mayReadOrWriteMemory",
          "new_api": null,
          "old_text": "Inst->mayReadOrWriteMemory()",
          "new_text": null,
          "old_line_content": "  if (!Inst->mayReadOrWriteMemory())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": "mayWriteToMemory",
          "new_api": null,
          "old_text": "Inst->mayWriteToMemory()",
          "new_text": null,
          "old_line_content": "  if (Inst->mayWriteToMemory()) {",
          "new_line_content": "  // that it and its operands cannot alias a load we have visited,",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": "processUnknownWriteInst",
          "new_api": null,
          "old_text": "processUnknownWriteInst(Ctx, Inst, Kind)",
          "new_text": null,
          "old_line_content": "    processUnknownWriteInst(Ctx, Inst, Kind);",
          "new_line_content": "  // invalidate that load.",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": "size",
          "new_api": null,
          "old_text": "LocationVault.size()",
          "new_text": null,
          "old_line_content": "  unsigned LocationCount = LocationVault.size();",
          "new_line_content": "  bool RunOneIteration = true;",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": "get",
          "new_api": null,
          "old_text": "PM->getAnalysis<PostOrderAnalysis>()->get(Fn)",
          "new_text": null,
          "old_line_content": "  auto *PO = PM->getAnalysis<PostOrderAnalysis>()->get(Fn);",
          "new_line_content": "  // Then this function can be processed in one iteration, i.e. no",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 55,
      "total_additions": 190,
      "total_deletions": 190,
      "total_api_changes": 435
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 3,
        "api_related_lines": 435,
        "non_api_lines": 2,
        "non_api_line_numbers": [
          328,
          329
        ]
      }
    },
    "api_calls_before": 337,
    "api_calls_after": 337,
    "diff_info": {
      "added_lines": 3,
      "removed_lines": 1,
      "total_diff_lines": 16
    }
  }
}