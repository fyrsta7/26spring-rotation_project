{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/13dad3ad4751ce2dff042208d98a92cd70a522cd",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/13dad3ad4751ce2dff042208d98a92cd70a522cd/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/13dad3ad4751ce2dff042208d98a92cd70a522cd/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/13dad3ad4751ce2dff042208d98a92cd70a522cd/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 417,
          "old_api": "beginBlock",
          "new_api": "getNext",
          "old_text": "nstTracker.beginBlock();\n",
          "new_text": "mOrder.getNext()) ",
          "old_line_content": "    constTracker.beginBlock();",
          "new_line_content": "  while (SILBasicBlock *block = domOrder.getNext()) {",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": "getWeight",
          "new_api": "beginBlock",
          "old_text": "A->getWeight(block, CallerWeight);\n",
          "new_text": "nstTracker.beginBlock();\n",
          "old_line_content": "    Weight BlockW = SPA->getWeight(block, CallerWeight);",
          "new_line_content": "    constTracker.beginBlock();",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": "a<PartialApplyInst>(def)))",
          "new_api": "getCallee",
          "old_text": "a<PartialApplyInst>(def)))",
          "new_text": "I.getCallee());",
          "old_line_content": "        if (def && (isa<FunctionRefInst>(def) || isa<PartialApplyInst>(def)))",
          "new_line_content": "        SILInstruction *def = constTracker.getDefInCaller(FAI.getCallee());",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": "updateBenefit",
          "new_api": "a<PartialApplyInst>(def)))",
          "old_text": "ockW.updateBenefit(Benefit, RemovedClosureBenefit);\n",
          "new_text": "a<PartialApplyInst>(def)))",
          "old_line_content": "          BlockW.updateBenefit(Benefit, RemovedClosureBenefit);",
          "new_line_content": "        if (def && (isa<FunctionRefInst>(def) || isa<PartialApplyInst>(def)))",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": "a<WitnessMethodInst>(def))",
          "new_api": "a<ClassMethodInst>(def) &",
          "old_text": "a<WitnessMethodInst>(def))\n",
          "new_text": "a<ClassMethodInst>(def) &",
          "old_line_content": "            !isa<WitnessMethodInst>(def))",
          "new_line_content": "        if (!isa<FunctionRefInst>(def) && !isa<ClassMethodInst>(def) &&",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": "a<SuperMethodInst>(def))",
          "new_api": "a<WitnessMethodInst>(def) |",
          "old_text": "a<SuperMethodInst>(def)) ",
          "new_text": "a<WitnessMethodInst>(def) |",
          "old_line_content": "            isa<SuperMethodInst>(def)) {",
          "new_line_content": "        if (isa<ClassMethodInst>(def) || isa<WitnessMethodInst>(def) ||",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": "vm::dbgs() <",
          "new_api": "nDevirtualizeApply",
          "old_text": "vm::dbgs() <",
          "new_text": "nDevirtualizeApply(FAI, nullptr)) ",
          "old_line_content": "            LLVM_DEBUG(llvm::dbgs() << \"Devirtualization will be possible \"",
          "new_line_content": "          if (canDevirtualizeApply(FAI, nullptr)) {",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": "updateBenefit",
          "new_api": "getInstruction",
          "old_text": "ockW.updateBenefit(Benefit, DevirtualizedCallBenefit);\n",
          "new_text": "I.getInstruction()->dumpInContext());",
          "old_line_content": "            BlockW.updateBenefit(Benefit, DevirtualizedCallBenefit);",
          "new_line_content": "                       FAI.getInstruction()->dumpInContext());",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": "getCalleeFunction",
          "new_api": "a<FunctionRefInst>(def))",
          "old_text": "I.getCalleeFunction();\n",
          "new_text": "a<FunctionRefInst>(def)) ",
          "old_line_content": "          auto CalleeF = FAI.getCalleeFunction();",
          "new_line_content": "        if (isa<FunctionRefInst>(def)) {",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": "nSpecializeGeneric",
          "new_api": "getCalleeFunction",
          "old_text": "nSpecializeGeneric(FAI, CalleeF, SubMap))\n",
          "new_text": "I.getCalleeFunction();\n",
          "old_line_content": "          if (!canSpecializeGeneric(FAI, CalleeF, SubMap))",
          "new_line_content": "          auto CalleeF = FAI.getCalleeFunction();",
          "content_same": false
        },
        {
          "line": 477,
          "old_api": "updateBenefit",
          "new_api": "getInstruction",
          "old_text": "ockW.updateBenefit(Benefit, GenericSpecializationBenefit);\n",
          "new_text": "I.getInstruction()->dumpInContext());",
          "old_line_content": "          BlockW.updateBenefit(Benefit, GenericSpecializationBenefit);",
          "new_line_content": "                     FAI.getInstruction()->dumpInContext());",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": "updateBenefit",
          "new_api": "getOperand",
          "old_text": "ockW.updateBenefit(Benefit, RemovedLoadBenefit);\n",
          "new_text": "->getOperand()))",
          "old_line_content": "          BlockW.updateBenefit(Benefit, RemovedLoadBenefit);",
          "new_line_content": "        if (constTracker.isStackAddrInCaller(LI->getOperand()))",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": "n_cast<StoreInst>(&I))",
          "new_api": "updateBenefit",
          "old_text": "n_cast<StoreInst>(&I)) ",
          "new_text": "ockW.updateBenefit(Benefit, RemovedLoadBenefit);\n",
          "old_line_content": "      } else if (auto *SI = dyn_cast<StoreInst>(&I)) {",
          "new_line_content": "          BlockW.updateBenefit(Benefit, RemovedLoadBenefit);",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": "updateBenefit",
          "new_api": "getDest",
          "old_text": "ockW.updateBenefit(Benefit, RemovedStoreBenefit);\n",
          "new_text": "->getDest()))",
          "old_line_content": "          BlockW.updateBenefit(Benefit, RemovedStoreBenefit);",
          "new_line_content": "        if (constTracker.isStackAddrInCaller(SI->getDest()))",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": "a<ReleaseValueInst>(&I))",
          "new_api": "updateBenefit",
          "old_text": "a<ReleaseValueInst>(&I)) ",
          "new_text": "ockW.updateBenefit(Benefit, RemovedStoreBenefit);\n",
          "old_line_content": "      } else if (isa<StrongReleaseInst>(&I) || isa<ReleaseValueInst>(&I)) {",
          "new_line_content": "          BlockW.updateBenefit(Benefit, RemovedStoreBenefit);",
          "content_same": false
        },
        {
          "line": 490,
          "old_api": "getOperand",
          "new_api": "a<ReleaseValueInst>(&I))",
          "old_text": "getOperand(0));",
          "new_text": "a<ReleaseValueInst>(&I)) ",
          "old_line_content": "        SILValue Op = stripCasts(I.getOperand(0));",
          "new_line_content": "      } else if (isa<StrongReleaseInst>(&I) || isa<ReleaseValueInst>(&I)) {",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": "n_cast<SILFunctionArgument>(Op))",
          "new_api": "getOperand",
          "old_text": "n_cast<SILFunctionArgument>(Op)) ",
          "new_text": "getOperand(0));",
          "old_line_content": "        if (auto *Arg = dyn_cast<SILFunctionArgument>(Op)) {",
          "new_line_content": "        SILValue Op = stripCasts(I.getOperand(0));",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": "getArgumentConvention",
          "new_api": "n_cast<SILFunctionArgument>(Op))",
          "old_text": "g->getArgumentConvention() =",
          "new_text": "n_cast<SILFunctionArgument>(Op)) ",
          "old_line_content": "          if (Arg->getArgumentConvention() ==",
          "new_line_content": "        if (auto *Arg = dyn_cast<SILFunctionArgument>(Op)) {",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": "getBuiltinInfo",
          "new_api": "n_cast<BuiltinInst>(&I))",
          "old_text": "->getBuiltinInfo().I",
          "new_text": "n_cast<BuiltinInst>(&I)) ",
          "old_line_content": "        if (BI->getBuiltinInfo().ID == BuiltinValueKind::OnFastPath)",
          "new_line_content": "      } else if (auto *BI = dyn_cast<BuiltinInst>(&I)) {",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": "updateBenefit",
          "new_api": "getBuiltinInfo",
          "old_text": "ockW.updateBenefit(Benefit, FastPathBuiltinBenefit);\n",
          "new_text": "->getBuiltinInfo().I",
          "old_line_content": "          BlockW.updateBenefit(Benefit, FastPathBuiltinBenefit);",
          "new_line_content": "        if (BI->getBuiltinInfo().ID == BuiltinValueKind::OnFastPath)",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "n_cast<BeginAccessInst>(&I))",
          "new_api": "updateBenefit",
          "old_text": "n_cast<BeginAccessInst>(&I)) ",
          "new_text": "ockW.updateBenefit(Benefit, FastPathBuiltinBenefit);\n",
          "old_line_content": "      } else if (auto *BAI = dyn_cast<BeginAccessInst>(&I)) {",
          "new_line_content": "          BlockW.updateBenefit(Benefit, FastPathBuiltinBenefit);",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": "getEnforcement",
          "new_api": "n_cast<BeginAccessInst>(&I))",
          "old_text": "I->getEnforcement() =",
          "new_text": "n_cast<BeginAccessInst>(&I)) ",
          "old_line_content": "        if (BAI->getEnforcement() == SILAccessEnforcement::Dynamic) {",
          "new_line_content": "      } else if (auto *BAI = dyn_cast<BeginAccessInst>(&I)) {",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": "isFormalAccessBase",
          "new_api": "getSource",
          "old_text": "orage.isFormalAccessBase()))",
          "new_text": "I->getSource());",
          "old_line_content": "          if (BAI->hasNoNestedConflict() && (storage.isFormalAccessBase())) {",
          "new_line_content": "          auto storage = AccessStorage::compute(BAI->getSource());",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": "updateBenefit",
          "new_api": "isFormalAccessBase",
          "old_text": "ockW.updateBenefit(ExclusivityBenefitWeight,\n                                 ExclusivityBenefitBase);\n",
          "new_text": "orage.isFormalAccessBase()))",
          "old_line_content": "            BlockW.updateBenefit(ExclusivityBenefitWeight,",
          "new_line_content": "          if (BAI->hasNoNestedConflict() && (storage.isFormalAccessBase())) {",
          "content_same": false
        },
        {
          "line": 516,
          "old_api": "getTerminator",
          "new_api": "n_cast<UpcastInst>(retVal))",
          "old_text": "ock->getTerminator());",
          "new_text": "n_cast<UpcastInst>(retVal))\n",
          "old_line_content": "    SILBasicBlock *takenBlock = constTracker.getTakenBlock(block->getTerminator());",
          "new_line_content": "        if (auto *uci = dyn_cast<UpcastInst>(retVal))",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": "d::max(Benefit, ExclusivityBenefitWeight);",
          "new_api": "getTerminator",
          "old_text": "d::max(Benefit, ExclusivityBenefitWeight);\n",
          "new_text": "ock->getTerminator());",
          "old_line_content": "    Benefit = std::max(Benefit, ExclusivityBenefitWeight);",
          "new_line_content": "    SILBasicBlock *takenBlock = constTracker.getTakenBlock(block->getTerminator());",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": "getFunction",
          "new_api": "pushChildrenIf",
          "old_text": ".getFunction()->isThunk()) ",
          "new_text": "mOrder.pushChildrenIf(block, [=](SILBasicBlock *child) {\n        return child->getSinglePredecessorBlock() != block ||\n               child == takenBlock;\n      });\n",
          "old_line_content": "  if (AI.getFunction()->isThunk()) {",
          "new_line_content": "      domOrder.pushChildrenIf(block, [=](SILBasicBlock *child) {",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": "getInstruction",
          "new_api": "end",
          "old_text": ".getInstruction())\n",
          "new_text": "ToWeightMap.end()) ",
          "old_line_content": "      return RemarkMissed(\"Inline\", *AI.getInstruction())",
          "new_line_content": "  if (bbIt != BBToWeightMap.end()) {",
          "content_same": false
        },
        {
          "line": 599,
          "old_api": "getScopeLength",
          "new_api": "getInstruction",
          "old_text": "A->getScopeLength(CalleeEntry, 0)\n ",
          "new_text": "tRemark::Emitter::emitOrDebug(DEBUG_TYPE, &ORE, [&]() {\n      using namespace OptRemark;\n      return RemarkMissed(\"Inline\", *AI.getInstruction())\n             << \"Not profitable to inline function \" << NV(\"Callee\", Callee)\n             << \" (cost = \" << NV(\"Cost\", CalleeCost)\n             << \", benefit = \" << NV(\"Benefit\", Benefit) << \")\";\n    });\n",
          "old_line_content": "                          << \", l=\" << SPA->getScopeLength(CalleeEntry, 0)",
          "new_line_content": "    OptRemark::Emitter::emitOrDebug(DEBUG_TYPE, &ORE, [&]() {",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": "size",
          "new_api": "getInstruction",
          "old_text": "llee->size()\n ",
          "new_text": ".getInstruction())\n",
          "old_line_content": "                          << \", bb=\" << Callee->size()",
          "new_line_content": "      return RemarkMissed(\"Inline\", *AI.getInstruction())",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": "getName",
          "new_api": "(\"Cost\", CalleeCost)",
          "old_text": "llee->getName() <",
          "new_text": "(\"Cost\", CalleeCost)\n ",
          "old_line_content": "                          << \"} \" << Callee->getName() << '\\n');",
          "new_line_content": "             << \" (cost = \" << NV(\"Cost\", CalleeCost)",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": "getInstruction",
          "new_api": "(\"Benefit\", Benefit) <",
          "old_text": "tRemark::Emitter::emitOrDebug(DEBUG_TYPE, &ORE, [&]() {\n    using namespace OptRemark;\n    return RemarkPassed(\"Inlined\", *AI.getInstruction())\n           << NV(\"Callee\", Callee) << \" inlined into \"\n           << NV(\"Caller\", AI.getFunction())\n           << \" (cost = \" << NV(\"Cost\", CalleeCost)\n           << \", benefit = \" << NV(\"Benefit\", Benefit) << \")\";\n  });\n",
          "new_text": "(\"Benefit\", Benefit) <",
          "old_line_content": "  OptRemark::Emitter::emitOrDebug(DEBUG_TYPE, &ORE, [&]() {",
          "new_line_content": "             << \", benefit = \" << NV(\"Benefit\", Benefit) << \")\";",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": "(\"Cost\", CalleeCost)",
          "new_api": "size",
          "old_text": "(\"Cost\", CalleeCost)\n ",
          "new_text": "llee->size();\n",
          "old_line_content": "           << \" (cost = \" << NV(\"Cost\", CalleeCost)",
          "new_line_content": "  NumCallerBlocks += Callee->size();",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": "getTerminator",
          "new_api": "getName",
          "old_text": ".getTerminator()))",
          "new_text": "llee->getName() <",
          "old_line_content": "    if (auto *RI = dyn_cast<ReturnInst>(BB.getTerminator())) {",
          "new_line_content": "                          << \"} \" << Callee->getName() << '\\n');",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": "getOperand",
          "new_api": "getInstruction",
          "old_text": "->getOperand());",
          "new_text": "tRemark::Emitter::emitOrDebug(DEBUG_TYPE, &ORE, [&]() {\n    using namespace OptRemark;\n    return RemarkPassed(\"Inlined\", *AI.getInstruction())\n           << NV(\"Callee\", Callee) << \" inlined into \"\n           << NV(\"Caller\", AI.getFunction())\n           << \" (cost = \" << NV(\"Cost\", CalleeCost)\n           << \", benefit = \" << NV(\"Benefit\", Benefit) << \")\";\n  });\n",
          "old_line_content": "      return isa<PartialApplyInst>(RI->getOperand());",
          "new_line_content": "  OptRemark::Emitter::emitOrDebug(DEBUG_TYPE, &ORE, [&]() {",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": "hasSubstitutions",
          "new_api": "isTransparent",
          "old_text": ".hasSubstitutions() &",
          "new_text": "llee->isTransparent())\n",
          "old_line_content": "  assert(AI.hasSubstitutions() &&",
          "new_line_content": "  if (Callee->isTransparent())",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": "getReferencedFunctionOrNull",
          "new_api": "getOptions",
          "old_text": ".getReferencedFunctionOrNull();\n",
          "new_text": "llee->getModule().getOptions().I",
          "old_line_content": "  SILFunction *Callee = AI.getReferencedFunctionOrNull();",
          "new_line_content": "    if (!Callee->getModule().getOptions().IgnoreAlwaysInline)",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": "getSubstitutionMap",
          "new_api": "isOnoneSupportModule",
          "old_text": ".getSubstitutionMap().hasArchetypes())\n",
          "new_text": "iftModule->isOnoneSupportModule()))",
          "old_line_content": "  if (!AI.getSubstitutionMap().hasArchetypes())",
          "new_line_content": "      (SwiftModule->isStdlibModule() || SwiftModule->isOnoneSupportModule()))",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": "ouldInlineGeneric",
          "new_api": "getFunction",
          "old_text": "ouldInlineGeneric(AI);\n",
          "new_text": ".getFunction());",
          "old_line_content": "    auto ShouldInlineGeneric = shouldInlineGeneric(AI);",
          "new_line_content": "    LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "hasValue",
          "new_api": "vm::dbgs() <",
          "old_text": "ouldInlineGeneric.hasValue())\n",
          "new_text": "vm::dbgs() <",
          "old_line_content": "    if (ShouldInlineGeneric.hasValue())",
          "new_line_content": "               llvm::dbgs() << \"    always-inline decision \"",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": "getValue",
          "new_api": "getName",
          "old_text": "ouldInlineGeneric.getValue();\n",
          "new_text": "llee->getName() <",
          "old_line_content": "      return ShouldInlineGeneric.getValue();",
          "new_line_content": "                            << Callee->getName() << '\\n');",
          "content_same": false
        },
        {
          "line": 774,
          "old_api": "getCount",
          "new_api": "getReferencedFunctionOrNull",
          "old_text": "cc.getCount()) ",
          "new_text": "S.getReferencedFunctionOrNull();\n",
          "old_line_content": "    if (succ.getCount()) {",
          "new_line_content": "  SILFunction *Callee = FAS.getReferencedFunctionOrNull();",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": "getTerminator",
          "new_api": "getEntryCount",
          "old_text": "ock->getTerminator();\n",
          "new_text": "ller->getEntryCount();\n",
          "old_line_content": "    auto *termInst = block->getTerminator();",
          "new_line_content": "  auto entryCount = Caller->getEntryCount();",
          "content_same": false
        },
        {
          "line": 819,
          "old_api": "getCount",
          "new_api": "getValue",
          "old_text": "cc.getCount();\n",
          "new_text": "tryCount.getValue();\n",
          "old_line_content": "        auto currCount = succ.getCount();",
          "new_line_content": "  BBToWeightMap[Caller->getEntryBlock()] = entryCount.getValue();",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": "getValue",
          "new_api": "getSecond",
          "old_text": "rrCount.getValue();\n",
          "new_text": "It->getSecond();\n",
          "old_line_content": "        auto currCountVal = currCount.getValue();",
          "new_line_content": "    auto bbCount = bbIt->getSecond();",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": "getSuccessors",
          "new_api": "end",
          "old_text": "rmInst->getSuccessors()) ",
          "new_text": "ToWeightMap.end() &",
          "old_line_content": "          for (auto &succ : termInst->getSuccessors()) {",
          "new_line_content": "        assert(BBToWeightMap.find(currBB) != BBToWeightMap.end() &&",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": "size",
          "new_api": "getBB",
          "old_text": "rmInst->getSuccessors().size();\n",
          "new_text": "cc.getBB();\n",
          "old_line_content": "      auto numOfSucc = termInst->getSuccessors().size();",
          "new_line_content": "            auto *currBB = succ.getBB();",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": "pushChildrenIf",
          "new_api": "size",
          "old_text": "mOrder.pushChildrenIf(block, [&](SILBasicBlock *child) { return true; });\n",
          "new_text": "rmInst->getSuccessors().size();\n",
          "old_line_content": "    domOrder.pushChildrenIf(block, [&](SILBasicBlock *child) { return true; });",
          "new_line_content": "        auto numOfSucc = termInst->getSuccessors().size();",
          "content_same": false
        },
        {
          "line": 863,
          "old_api": "get",
          "new_api": "size",
          "old_text": "->get(Caller);\n",
          "new_text": "rmInst->getSuccessors().size();\n",
          "old_line_content": "  SILLoopInfo *LI = LA->get(Caller);",
          "new_line_content": "      auto numOfSucc = termInst->getSuccessors().size();",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": "analyze",
          "new_api": "dToBBCounts",
          "old_text": "A->analyze(CBI, [&](FullApplySite FAS) -> int {\n  \n    // This closure returns the length of a called function.\n\n    // At this occasion we record additional weight increases.\n    addWeightCorrection(FAS, WeightCorrections);\n\n    if (SILFunction *Callee = getEligibleFunction(FAS, WhatToInline)) {\n      // Compute the shortest-path analysis for the callee.\n      SILLoopInfo *CalleeLI = LA->get(Callee);\n      ShortestPathAnalysis *CalleeSPA = getSPA(Callee, CalleeLI);\n      if (!CalleeSPA->isValid()) {\n        CalleeSPA->analyze(CBI, [](FullApplySite FAS) {\n          // We don't compute SPA for another call-level. Functions called from\n          // the callee are assumed to have DefaultApplyLength.\n          return DefaultApplyLength;\n        });\n      }\n      int CalleeLength = CalleeSPA->getScopeLength(&Callee->front(), 0);\n      // Just in case the callee is a noreturn function.\n      if (CalleeLength >= ShortestPathAnalysis::InitialDist)\n        return DefaultApplyLength;\n      return CalleeLength;\n    }\n    // Some unknown function.\n    return DefaultApplyLength;\n  });\n",
          "new_text": "dToBBCounts(BBToWeightMap, numToAdd, termInst);\n",
          "old_line_content": "  SPA->analyze(CBI, [&](FullApplySite FAS) -> int {",
          "new_line_content": "      addToBBCounts(BBToWeightMap, numToAdd, termInst);",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": "beginBlock",
          "new_api": "dump",
          "old_text": "nstTracker.beginBlock();\n",
          "new_text": "A->dump();\n",
          "old_line_content": "    constTracker.beginBlock();",
          "new_line_content": "    SPA->dump();",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": "llApplySite::isa(&*I))",
          "new_api": "size",
          "old_text": "llApplySite::isa(&*I))\n",
          "new_text": "ller->size();\n",
          "old_line_content": "      if (!FullApplySite::isa(&*I))",
          "new_line_content": "  int NumCallerBlocks = (int)Caller->size();",
          "content_same": false
        },
        {
          "line": 923,
          "old_api": "llApplySite",
          "new_api": "lculateBBWeights",
          "old_text": "llApplySite(&*I);\n",
          "new_text": "lculateBBWeights(Caller, DT, BBToWeightMap);\n",
          "old_line_content": "      FullApplySite AI = FullApplySite(&*I);",
          "new_line_content": "  calculateBBWeights(Caller, DT, BBToWeightMap);",
          "content_same": false
        },
        {
          "line": 929,
          "old_api": "InlineAlwaysCallSite",
          "new_api": "beginBlock",
          "old_text": "InlineAlwaysCallSite(Callee)) ",
          "new_text": "nstTracker.beginBlock();\n",
          "old_line_content": "        if (isInlineAlwaysCallSite(Callee)) {",
          "new_line_content": "    constTracker.beginBlock();",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": "isValid",
          "new_api": "InlineAlwaysCallSite",
          "old_text": "ockWeight.isValid())\n",
          "new_text": "InlineAlwaysCallSite(Callee)) ",
          "old_line_content": "        if (!BlockWeight.isValid())",
          "new_line_content": "        if (isInlineAlwaysCallSite(Callee)) {",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": "ight",
          "new_api": "size",
          "old_text": "ight(0, 0));",
          "new_text": "llee->size();\n",
          "old_line_content": "          BlockWeight = SPA->getWeight(block, Weight(0, 0));",
          "new_line_content": "          NumCallerBlocks += Callee->size();",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": "sitColdBlocks",
          "new_api": "isValid",
          "old_text": "sitColdBlocks(InitialCandidates, child, DT);\n",
          "new_text": "ockWeight.isValid())\n",
          "old_line_content": "        visitColdBlocks(InitialCandidates, child, DT);",
          "new_line_content": "        if (!BlockWeight.isValid())",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": "shouldOptimize",
          "new_api": "llectAppliesToInline",
          "old_text": "llee->shouldOptimize()) ",
          "new_text": "llectAppliesToInline(Caller, AppliesToInline);\n",
          "old_line_content": "    if (!Callee->shouldOptimize()) {",
          "new_line_content": "  collectAppliesToInline(Caller, AppliesToInline);",
          "content_same": false
        },
        {
          "line": 1024,
          "old_api": "vm::dbgs()",
          "new_api": "vm::reverse(AppliesToInline))",
          "old_text": "vm::dbgs()\n ",
          "new_text": "vm::reverse(AppliesToInline)) ",
          "old_line_content": "    LLVM_DEBUG(dumpCaller(Caller); llvm::dbgs()",
          "new_line_content": "  for (auto AI : llvm::reverse(AppliesToInline)) {",
          "content_same": false
        },
        {
          "line": 1025,
          "old_api": "size",
          "new_api": "getReferencedFunctionOrNull",
          "old_text": "llee->size() <",
          "new_text": ".getReferencedFunctionOrNull();\n",
          "old_line_content": "                                   << \"    inline [\" << Callee->size() << \"->\"",
          "new_line_content": "    SILFunction *Callee = AI.getReferencedFunctionOrNull();",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": "size",
          "new_api": "sert",
          "old_text": "ller->size() <",
          "new_text": "sert(Callee && \"apply_inst does not have a direct callee anymore\");\n",
          "old_line_content": "                                   << Caller->size() << \"] \"",
          "new_line_content": "    assert(Callee && \"apply_inst does not have a direct callee anymore\");",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": "isDefinition",
          "new_api": "->getAnalysis<SILLoopAnalysis>();",
          "old_text": "tFunction()->isDefinition() &",
          "new_text": "->getAnalysis<SILLoopAnalysis>();\n",
          "old_line_content": "    assert(getFunction()->isDefinition() &&",
          "new_line_content": "    SILLoopAnalysis *LA = PM->getAnalysis<SILLoopAnalysis>();",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": "validateAnalysis",
          "new_api": "getEffectiveOptimizationMode",
          "old_text": "validateAnalysis(SILAnalysis::InvalidationKind::FunctionBody);\n",
          "new_text": "tFunction()->getEffectiveOptimizationMode();\n",
          "old_line_content": "      invalidateAnalysis(SILAnalysis::InvalidationKind::FunctionBody);",
          "new_line_content": "    auto OptMode = getFunction()->getEffectiveOptimizationMode();",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 514,
          "old_api": null,
          "new_api": "n_cast<ReturnInst>(&I))",
          "old_text": null,
          "new_text": "n_cast<ReturnInst>(&I)) ",
          "old_line_content": "    }",
          "new_line_content": "      } else if (auto ri = dyn_cast<ReturnInst>(&I)) {",
          "content_same": false
        },
        {
          "line": 515,
          "old_api": null,
          "new_api": "getOperand",
          "old_text": null,
          "new_text": "->getOperand();\n",
          "old_line_content": "    // Don't count costs in blocks which are dead after inlining.",
          "new_line_content": "        SILValue retVal = ri->getOperand();",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": null,
          "new_api": "shouldOptimize",
          "old_text": null,
          "new_text": "llee->shouldOptimize()) ",
          "old_line_content": "",
          "new_line_content": "    if (!Callee->shouldOptimize()) {",
          "content_same": false
        },
        {
          "line": 517,
          "old_api": null,
          "new_api": "getOperand",
          "old_text": null,
          "new_text": "i->getOperand();\n",
          "old_line_content": "    if (takenBlock) {",
          "new_line_content": "          retVal = uci->getOperand();",
          "content_same": false
        },
        {
          "line": 522,
          "old_api": null,
          "new_api": "a<PartialApplyInst>(retVal))",
          "old_text": null,
          "new_text": "a<PartialApplyInst>(retVal)) ",
          "old_line_content": "      });",
          "new_line_content": "        if (isa<AllocationInst>(retVal) || isa<PartialApplyInst>(retVal)) {",
          "content_same": false
        },
        {
          "line": 523,
          "old_api": null,
          "new_api": "updateBenefit",
          "old_text": null,
          "new_text": "ockW.updateBenefit(Benefit, RemovedCallBenefit + 10);\n",
          "old_line_content": "    } else {",
          "new_line_content": "          BlockW.updateBenefit(Benefit, RemovedCallBenefit + 10);",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": null,
          "new_api": "hasOwnership",
          "old_text": null,
          "new_text": "ller->hasOwnership()) ",
          "old_line_content": "    }",
          "new_line_content": "    if (!Callee->hasOwnership() && Caller->hasOwnership()) {",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": null,
          "new_api": "vm::dbgs()",
          "old_text": null,
          "new_text": "vm::dbgs()\n ",
          "old_line_content": "    // We've already determined we should be able to inline this, so",
          "new_line_content": "    LLVM_DEBUG(dumpCaller(Caller); llvm::dbgs()",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "llee->size() <",
          "old_line_content": "    // unconditionally inline the function.",
          "new_line_content": "                                   << \"    inline [\" << Callee->size() << \"->\"",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "ller->size() <",
          "old_line_content": "    //",
          "new_line_content": "                                   << Caller->size() << \"] \"",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "llee->getName() <",
          "old_line_content": "    // If for whatever reason we can not inline this function, inlineFullApply",
          "new_line_content": "                                   << Callee->getName() << \"\\n\");",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": null,
          "new_api": "updateBenefit",
          "old_text": null,
          "new_text": "ockW.updateBenefit(Benefit, RemovedTerminatorBenefit);\n",
          "old_line_content": "",
          "new_line_content": "      BlockW.updateBenefit(Benefit, RemovedTerminatorBenefit);",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": null,
          "new_api": "getSinglePredecessorBlock",
          "old_text": null,
          "new_text": "ild->getSinglePredecessorBlock() !",
          "old_line_content": "    // Only inline trivial functions into thunks (which will not increase the",
          "new_line_content": "        return child->getSinglePredecessorBlock() != block ||",
          "content_same": false
        },
        {
          "line": 1046,
          "old_api": null,
          "new_api": "LInliner::invalidatesStackNesting(AI);",
          "old_text": null,
          "new_text": "LInliner::invalidatesStackNesting(AI);\n",
          "old_line_content": "    ++NumFunctionsInlined;",
          "new_line_content": "    invalidatedStackNesting |= SILInliner::invalidatesStackNesting(AI);",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": null,
          "new_api": "pushChildren",
          "old_text": null,
          "new_text": "mOrder.pushChildren(block);\n",
          "old_line_content": "    }",
          "new_line_content": "      domOrder.pushChildren(block);",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": null,
          "new_api": "intInliningDetailsCallee",
          "old_text": null,
          "new_text": "intInliningDetailsCallee(PassName, Caller, Callee);\n",
          "old_line_content": "    }",
          "new_line_content": "      printInliningDetailsCallee(PassName, Caller, Callee);",
          "content_same": false
        },
        {
          "line": 1052,
          "old_api": null,
          "new_api": "intInliningDetailsCallerBefore",
          "old_text": null,
          "new_text": "intInliningDetailsCallerBefore(PassName, Caller, Callee);\n",
          "old_line_content": "  ",
          "new_line_content": "      printInliningDetailsCallerBefore(PassName, Caller, Callee);",
          "content_same": false
        },
        {
          "line": 542,
          "old_api": null,
          "new_api": "d::max(Benefit, ExclusivityBenefitWeight);",
          "old_text": null,
          "new_text": "d::max(Benefit, ExclusivityBenefitWeight);\n",
          "old_line_content": "    return true;",
          "new_line_content": "    Benefit = std::max(Benefit, ExclusivityBenefitWeight);",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": null,
          "new_api": "getFunction",
          "old_text": null,
          "new_text": ".getFunction()->isThunk()) ",
          "old_line_content": "  // We reduce the benefit if the caller is too large. For this we use a",
          "new_line_content": "  if (AI.getFunction()->isThunk()) {",
          "content_same": false
        },
        {
          "line": 1059,
          "old_api": null,
          "new_api": "LInliner::inlineFullApply(AI, SILInliner::InlineKind::PerformanceInline,\n                                FuncBuilder, deleter);",
          "old_text": null,
          "new_text": "LInliner::inlineFullApply(AI, SILInliner::InlineKind::PerformanceInline,\n                                FuncBuilder, deleter);\n",
          "old_line_content": "  }",
          "new_line_content": "    SILInliner::inlineFullApply(AI, SILInliner::InlineKind::PerformanceInline,",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": null,
          "new_api": "intInliningDetailsCallerAfter",
          "old_text": null,
          "new_text": "intInliningDetailsCallerAfter(PassName, Caller, Callee);\n",
          "old_line_content": "  // the inliner without running the entire inliner.",
          "new_line_content": "      printInliningDetailsCallerAfter(PassName, Caller, Callee);",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": null,
          "new_api": "getFunction",
          "old_text": null,
          "new_text": ".getFunction());",
          "old_line_content": "  else",
          "new_line_content": "    LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": null,
          "new_api": "vm::dbgs() <",
          "old_text": null,
          "new_text": "vm::dbgs() <",
          "old_line_content": "    // The calculation in the if branch would overflow if we performed it.",
          "new_line_content": "               llvm::dbgs() << \"    decision {\" << CalleeCost << \" into thunk} \"",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "llee->getName() <",
          "old_line_content": "    Benefit = 0;",
          "new_line_content": "                            << Callee->getName() << '\\n');",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": null,
          "new_api": "cleanupDeadInstructions",
          "old_text": null,
          "new_text": "leter.cleanupDeadInstructions();\n",
          "old_line_content": "  }",
          "new_line_content": "  deleter.cleanupDeadInstructions();",
          "content_same": false
        },
        {
          "line": 1070,
          "old_api": null,
          "new_api": "rgeBasicBlocks",
          "old_text": null,
          "new_text": "rgeBasicBlocks(Caller);\n",
          "old_line_content": "",
          "new_line_content": "  mergeBasicBlocks(Caller);",
          "content_same": false
        },
        {
          "line": 1073,
          "old_api": null,
          "new_api": "ackNesting::fixNesting(Caller);",
          "old_text": null,
          "new_text": "ackNesting::fixNesting(Caller);\n",
          "old_line_content": "void SILPerformanceInliner::visitColdBlocks(",
          "new_line_content": "    StackNesting::fixNesting(Caller);",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": null,
          "new_api": "verify",
          "old_text": null,
          "new_text": "ller->verify();\n",
          "old_line_content": "      if (!AI)",
          "new_line_content": "    Caller->verify();",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "ToWeightMap.find(bb);\n",
          "old_line_content": "      using namespace OptRemark;",
          "new_line_content": "  auto bbIt = BBToWeightMap.find(bb);",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": null,
          "new_api": "ofileBasedDecision",
          "old_text": null,
          "new_text": "ofileBasedDecision(AI, Benefit, Callee, CalleeCost, NumCallerBlocks,\n                             bbIt)) ",
          "old_line_content": "             << \"Not profitable due to provided profile\";",
          "new_line_content": "    if (profileBasedDecision(AI, Benefit, Callee, CalleeCost, NumCallerBlocks,",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": null,
          "new_api": "getInstruction",
          "old_text": null,
          "new_text": "tRemark::Emitter::emitOrDebug(DEBUG_TYPE, &ORE, [&]() {\n        using namespace OptRemark;\n        return RemarkPassed(\"Inline\", *AI.getInstruction())\n               << \"Profitable due to provided profile\";\n      });\n",
          "old_line_content": "    return false;",
          "new_line_content": "      OptRemark::Emitter::emitOrDebug(DEBUG_TYPE, &ORE, [&]() {",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": null,
          "new_api": "getInstruction",
          "old_text": null,
          "new_text": ".getInstruction())\n",
          "old_line_content": "",
          "new_line_content": "        return RemarkPassed(\"Inline\", *AI.getInstruction())",
          "content_same": false
        },
        {
          "line": 1092,
          "old_api": null,
          "new_api": "getNext",
          "old_text": null,
          "new_text": "mOrder.getNext()) ",
          "old_line_content": "",
          "new_line_content": "  while (SILBasicBlock *block = domOrder.getNext()) {",
          "content_same": false
        },
        {
          "line": 1094,
          "old_api": null,
          "new_api": "n_cast<ApplyInst>(&I);",
          "old_text": null,
          "new_text": "n_cast<ApplyInst>(&I);\n",
          "old_line_content": "//                          Performance Inliner Pass",
          "new_line_content": "      auto *AI = dyn_cast<ApplyInst>(&I);",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": null,
          "new_api": "getInstruction",
          "old_text": null,
          "new_text": "tRemark::Emitter::emitOrDebug(DEBUG_TYPE, &ORE, [&]() {\n      using namespace OptRemark;\n      return RemarkMissed(\"Inline\", *AI.getInstruction())\n             << \"Not profitable due to provided profile\";\n    });\n",
          "old_line_content": "  if (CalleeCost > Benefit) {",
          "new_line_content": "    OptRemark::Emitter::emitOrDebug(DEBUG_TYPE, &ORE, [&]() {",
          "content_same": false
        },
        {
          "line": 585,
          "old_api": null,
          "new_api": "getInstruction",
          "old_text": null,
          "new_text": ".getInstruction())\n",
          "old_line_content": "      using namespace OptRemark;",
          "new_line_content": "      return RemarkMissed(\"Inline\", *AI.getInstruction())",
          "content_same": false
        },
        {
          "line": 1098,
          "old_api": null,
          "new_api": "tEligibleFunction",
          "old_text": null,
          "new_text": "tEligibleFunction(AI, WhatToInline);\n",
          "old_line_content": "class SILPerformanceInlinerPass : public SILFunctionTransform {",
          "new_line_content": "      auto *Callee = getEligibleFunction(AI, WhatToInline);",
          "content_same": false
        },
        {
          "line": 1099,
          "old_api": null,
          "new_api": "cideInColdBlock",
          "old_text": null,
          "new_text": "cideInColdBlock(AI, Callee)) ",
          "old_line_content": "  /// Specifies which functions not to inline, based on @_semantics and",
          "new_line_content": "      if (Callee && decideInColdBlock(AI, Callee)) {",
          "content_same": false
        },
        {
          "line": 1100,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "pliesToInline.push_back(AI);\n",
          "old_line_content": "  /// global_init attributes.",
          "new_line_content": "        AppliesToInline.push_back(AI);",
          "content_same": false
        },
        {
          "line": 1103,
          "old_api": null,
          "new_api": "pushChildren",
          "old_text": null,
          "new_text": "mOrder.pushChildren(block);\n",
          "old_line_content": "",
          "new_line_content": "    domOrder.pushChildren(block);",
          "content_same": false
        },
        {
          "line": 602,
          "old_api": null,
          "new_api": "(\"Callee\", Callee)",
          "old_text": null,
          "new_text": "(\"Callee\", Callee)\n ",
          "old_line_content": "                          << \", c-bb=\" << NumCallerBlocks",
          "new_line_content": "             << \"Not profitable to inline function \" << NV(\"Callee\", Callee)",
          "content_same": false
        },
        {
          "line": 1122,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "ssName.append(\" Performance Inliner\");\n",
          "old_line_content": "    SILOptFunctionBuilder FuncBuilder(*this);",
          "new_line_content": "    PassName.append(\" Performance Inliner\");",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": null,
          "new_api": "getFunction",
          "old_text": null,
          "new_text": ".getFunction());",
          "old_line_content": "  });",
          "new_line_content": "  LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "content_same": false
        },
        {
          "line": 612,
          "old_api": null,
          "new_api": "vm::dbgs() <",
          "old_text": null,
          "new_text": "vm::dbgs() <",
          "old_line_content": "",
          "new_line_content": "             llvm::dbgs() << \"    decision {c=\" << CalleeCost",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": null,
          "new_api": "getScopeLength",
          "old_text": null,
          "new_text": "A->getScopeLength(CalleeEntry, 0)\n ",
          "old_line_content": "}",
          "new_line_content": "                          << \", l=\" << SPA->getScopeLength(CalleeEntry, 0)",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": null,
          "new_api": "->getAnalysis<DominanceAnalysis>();",
          "old_text": null,
          "new_text": "->getAnalysis<DominanceAnalysis>();\n",
          "old_line_content": "",
          "new_line_content": "    DominanceAnalysis *DA = PM->getAnalysis<DominanceAnalysis>();",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "llee->size()\n ",
          "old_line_content": "static bool returnsClosure(SILFunction *F) {",
          "new_line_content": "                          << \", bb=\" << Callee->size()",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": null,
          "new_api": "->getAnalysis<SideEffectAnalysis>();",
          "old_text": null,
          "new_text": "->getAnalysis<SideEffectAnalysis>();\n",
          "old_line_content": "           \"Expected only functions with bodies!\");",
          "new_line_content": "    SideEffectAnalysis *SEA = PM->getAnalysis<SideEffectAnalysis>();",
          "content_same": false
        },
        {
          "line": 1129,
          "old_api": null,
          "new_api": "tFunction",
          "old_text": null,
          "new_text": "tFunction());",
          "old_line_content": "",
          "new_line_content": "    OptRemark::Emitter ORE(DEBUG_TYPE, *getFunction());",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": null,
          "new_api": "tOptions",
          "old_text": null,
          "new_text": "tOptions().I",
          "old_line_content": "    // analyses for this function and restart the pipeline so that we",
          "new_line_content": "    if (getOptions().InlineThreshold == 0) {",
          "content_same": false
        },
        {
          "line": 621,
          "old_api": null,
          "new_api": "getInstruction",
          "old_text": null,
          "new_text": ".getInstruction())\n",
          "old_line_content": "  }",
          "new_line_content": "    return RemarkPassed(\"Inlined\", *AI.getInstruction())",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": null,
          "new_api": "(\"Callee\", Callee) <",
          "old_text": null,
          "new_text": "(\"Callee\", Callee) <",
          "old_line_content": "  return false;",
          "new_line_content": "           << NV(\"Callee\", Callee) << \" inlined into \"",
          "content_same": false
        },
        {
          "line": 623,
          "old_api": null,
          "new_api": "getFunction",
          "old_text": null,
          "new_text": ".getFunction())\n",
          "old_line_content": "}",
          "new_line_content": "           << NV(\"Caller\", AI.getFunction())",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": null,
          "new_api": "(\"Cost\", CalleeCost)",
          "old_text": null,
          "new_text": "(\"Cost\", CalleeCost)\n ",
          "old_line_content": "",
          "new_line_content": "           << \" (cost = \" << NV(\"Cost\", CalleeCost)",
          "content_same": false
        },
        {
          "line": 625,
          "old_api": null,
          "new_api": "(\"Benefit\", Benefit) <",
          "old_text": null,
          "new_text": "(\"Benefit\", Benefit) <",
          "old_line_content": "static bool isInlineAlwaysCallSite(SILFunction *Callee) {",
          "new_line_content": "           << \", benefit = \" << NV(\"Benefit\", Benefit) << \")\";",
          "content_same": false
        },
        {
          "line": 1142,
          "old_api": null,
          "new_api": "isDefinition",
          "old_text": null,
          "new_text": "tFunction()->isDefinition() &",
          "old_line_content": "",
          "new_line_content": "    assert(getFunction()->isDefinition() &&",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": null,
          "new_api": "getTerminator",
          "old_text": null,
          "new_text": ".getTerminator()))",
          "old_line_content": "",
          "new_line_content": "    if (auto *RI = dyn_cast<ReturnInst>(BB.getTerminator())) {",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": null,
          "new_api": "getOperand",
          "old_text": null,
          "new_text": "->getOperand());",
          "old_line_content": "/// Checks if a given generic apply should be inlined unconditionally, i.e.",
          "new_line_content": "      return isa<PartialApplyInst>(RI->getOperand());",
          "content_same": false
        },
        {
          "line": 1149,
          "old_api": null,
          "new_api": "tFunction",
          "old_text": null,
          "new_text": "tFunction()))",
          "old_line_content": "/// the @_semantics, @_effects or global_init attributes.",
          "new_line_content": "    if (Inliner.inlineCallsIntoFunction(getFunction())) {",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": null,
          "new_api": "validateAnalysis",
          "old_text": null,
          "new_text": "validateAnalysis(SILAnalysis::InvalidationKind::FunctionBody);\n",
          "old_line_content": "SILTransform *swift::createEarlyInliner() {",
          "new_line_content": "      invalidateAnalysis(SILAnalysis::InvalidationKind::FunctionBody);",
          "content_same": false
        },
        {
          "line": 1151,
          "old_api": null,
          "new_api": "startPassPipeline",
          "old_text": null,
          "new_text": "startPassPipeline();\n",
          "old_line_content": "  return new SILPerformanceInlinerPass(",
          "new_line_content": "      restartPassPipeline();",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": null,
          "new_api": "getInlineStrategy",
          "old_text": null,
          "new_text": "llee->getInlineStrategy() =",
          "old_line_content": "",
          "new_line_content": "  if (Callee->getInlineStrategy() == AlwaysInline)",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": null,
          "new_api": "hasSubstitutions",
          "old_text": null,
          "new_text": ".hasSubstitutions() &",
          "old_line_content": "    return false;",
          "new_line_content": "  assert(AI.hasSubstitutions() &&",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": null,
          "new_api": "getReferencedFunctionOrNull",
          "old_text": null,
          "new_text": ".getReferencedFunctionOrNull();\n",
          "old_line_content": "  // AlwaysInline or transparent.",
          "new_line_content": "  SILFunction *Callee = AI.getReferencedFunctionOrNull();",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "getSwiftModule",
          "old_text": null,
          "new_text": "llee->getModule().getSwiftModule();\n",
          "old_line_content": "  // generic inlining. Let the generic specializer create a specialized",
          "new_line_content": "  ModuleDecl *SwiftModule = Callee->getModule().getSwiftModule();",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": null,
          "new_api": "hasSemanticsAttrThatStartsWith",
          "old_text": null,
          "new_text": "llee->hasSemanticsAttrThatStartsWith(\"array.\") &",
          "old_line_content": "  // function and then decide if it is beneficial to inline it.",
          "new_line_content": "  if (Callee->hasSemanticsAttrThatStartsWith(\"array.\") &&",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": null,
          "new_api": "getFunction",
          "old_text": null,
          "new_text": ".getFunction()->isThunk())\n",
          "old_line_content": "      SILCoroutineKind::None) {",
          "new_line_content": "  if (AI.getFunction()->isThunk())",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": null,
          "new_api": "InlineAlwaysCallSite",
          "old_text": null,
          "new_text": "InlineAlwaysCallSite(Callee))\n",
          "old_line_content": "    return None;",
          "new_line_content": "  if (isInlineAlwaysCallSite(Callee))",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": null,
          "new_api": "getSubstitutionMap",
          "old_text": null,
          "new_text": ".getSubstitutionMap().hasArchetypes())\n",
          "old_line_content": "  // they are generic.",
          "new_line_content": "  if (!AI.getSubstitutionMap().hasArchetypes())",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": null,
          "new_api": "getLoweredFunctionType",
          "old_text": null,
          "new_text": "llee->getLoweredFunctionType()->getCoroutineKind() !",
          "old_line_content": "",
          "new_line_content": "  if (Callee->getLoweredFunctionType()->getCoroutineKind() !=",
          "content_same": false
        },
        {
          "line": 697,
          "old_api": null,
          "new_api": "turnsClosure",
          "old_text": null,
          "new_text": "turnsClosure(Callee))\n",
          "old_line_content": "    const llvm::DenseMap<SILBasicBlock *, uint64_t> &BBToWeightMap) {",
          "new_line_content": "  if (Callee->isThunk() && returnsClosure(Callee))",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": null,
          "new_api": "hasSubstitutions",
          "old_text": null,
          "new_text": ".hasSubstitutions()) ",
          "old_line_content": "",
          "new_line_content": "  if (AI.hasSubstitutions()) {",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": null,
          "new_api": "ouldInlineGeneric",
          "old_text": null,
          "new_text": "ouldInlineGeneric(AI);\n",
          "old_line_content": "                              BBToWeightMap);",
          "new_line_content": "    auto ShouldInlineGeneric = shouldInlineGeneric(AI);",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": null,
          "new_api": "hasValue",
          "old_text": null,
          "new_text": "ouldInlineGeneric.hasValue())\n",
          "old_line_content": "}",
          "new_line_content": "    if (ShouldInlineGeneric.hasValue())",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": null,
          "new_api": "getValue",
          "old_text": null,
          "new_text": "ouldInlineGeneric.getValue();\n",
          "old_line_content": "",
          "new_line_content": "      return ShouldInlineGeneric.getValue();",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": null,
          "new_api": "getReferencedFunctionOrNull",
          "old_text": null,
          "new_text": ".getReferencedFunctionOrNull();\n",
          "old_line_content": "                                              SILFunction *Callee) {",
          "new_line_content": "  SILFunction *Callee = AI.getReferencedFunctionOrNull();",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": null,
          "new_api": "InlineAlwaysCallSite",
          "old_text": null,
          "new_text": "InlineAlwaysCallSite(Callee)) ",
          "old_line_content": "    // Only inline generics if definitively clear that it should be done.",
          "new_line_content": "  if (isInlineAlwaysCallSite(Callee)) {",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": null,
          "new_api": "ProfitableToInline",
          "old_text": null,
          "new_text": "ProfitableToInline(AI, CallerWeight, callerTracker, NumCallerBlocks,\n                              BBToWeightMap);\n",
          "old_line_content": "",
          "new_line_content": "  return isProfitableToInline(AI, CallerWeight, callerTracker, NumCallerBlocks,",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": null,
          "new_api": "hasSubstitutions",
          "old_text": null,
          "new_text": ".hasSubstitutions()) ",
          "old_line_content": "",
          "new_line_content": "  if (AI.hasSubstitutions()) {",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": null,
          "new_api": "ouldInlineGeneric",
          "old_text": null,
          "new_text": "ouldInlineGeneric(AI);\n",
          "old_line_content": "",
          "new_line_content": "    auto ShouldInlineGeneric = shouldInlineGeneric(AI);",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": null,
          "new_api": "hasValue",
          "old_text": null,
          "new_text": "ouldInlineGeneric.hasValue())\n",
          "old_line_content": "  for (SILBasicBlock &Block : *Callee) {",
          "new_line_content": "    if (ShouldInlineGeneric.hasValue())",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": null,
          "new_api": "getValue",
          "old_text": null,
          "new_text": "ouldInlineGeneric.getValue();\n",
          "old_line_content": "    for (SILInstruction &I : Block) {",
          "new_line_content": "      return ShouldInlineGeneric.getValue();",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": null,
          "new_api": "InlineAlwaysCallSite",
          "old_text": null,
          "new_text": "InlineAlwaysCallSite(Callee)) ",
          "old_line_content": "  }",
          "new_line_content": "  if (isInlineAlwaysCallSite(Callee)) {",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": null,
          "new_api": "structionInlineCost",
          "old_text": null,
          "new_text": "structionInlineCost(I));",
          "old_line_content": "/// callee.",
          "new_line_content": "      CalleeCost += int(instructionInlineCost(I));",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": null,
          "new_api": "getFunction",
          "old_text": null,
          "new_text": ".getFunction());",
          "old_line_content": "    // We want to inline the argument to an array.uninitialized call, because",
          "new_line_content": "  LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": null,
          "new_api": "vm::dbgs() <",
          "old_text": null,
          "new_text": "vm::dbgs() <",
          "old_line_content": "    // this argument is most likely a call to a function which contains the",
          "new_line_content": "             llvm::dbgs() << \"    cold decision {\" << CalleeCost << \"} \"",
          "content_same": false
        },
        {
          "line": 763,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "llee->getName() <",
          "old_line_content": "    // buffer allocation for the array. It is essential to inline it for stack",
          "new_line_content": "                          << Callee->getName() << '\\n');",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": null,
          "new_api": "hasSemanticsAttr",
          "old_text": null,
          "new_text": "llee->hasSemanticsAttr(semantics::ARRAY_UNINITIALIZED)) ",
          "old_line_content": "      return true;",
          "new_line_content": "  if (Callee && Callee->hasSemanticsAttr(semantics::ARRAY_UNINITIALIZED)) {",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": null,
          "new_api": "getArgument",
          "old_text": null,
          "new_text": "S.getArgument(0);\n",
          "old_line_content": "",
          "new_line_content": "    SILValue BufferArg = FAS.getArgument(0);",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": null,
          "new_api": "ripCasts",
          "old_text": null,
          "new_text": "ripCasts(BufferArg));",
          "old_line_content": "static void",
          "new_line_content": "    SILValue Base = stripValueProjections(stripCasts(BufferArg));",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": null,
          "new_api": "llApplySite::isa(Base))",
          "old_text": null,
          "new_text": "llApplySite::isa(Base))\n",
          "old_line_content": "addToBBCounts(llvm::DenseMap<SILBasicBlock *, uint64_t> &BBToWeightMap,",
          "new_line_content": "    if (auto BaseApply = FullApplySite::isa(Base))",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": null,
          "new_api": "getSuccessors",
          "old_text": null,
          "new_text": "st->getSuccessors()) ",
          "old_line_content": "    BBToWeightMap[currBB] += numToAdd;",
          "new_line_content": "  for (auto &succ : inst->getSuccessors()) {",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": null,
          "new_api": "getCount",
          "old_text": null,
          "new_text": "cc.getCount()) ",
          "old_line_content": "  }",
          "new_line_content": "    if (succ.getCount()) {",
          "content_same": false
        },
        {
          "line": 799,
          "old_api": null,
          "new_api": "getSuccessors",
          "old_text": null,
          "new_text": "rmInst->getSuccessors()) ",
          "old_line_content": "  }",
          "new_line_content": "  for (auto &succ : termInst->getSuccessors()) {",
          "content_same": false
        },
        {
          "line": 800,
          "old_api": null,
          "new_api": "getBB",
          "old_text": null,
          "new_text": "cc.getBB();\n",
          "old_line_content": "  // Add all blocks to BBToWeightMap without count 0",
          "new_line_content": "    auto *currBB = succ.getBB();",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "ToWeightMap.end() &",
          "old_line_content": "  for (auto &block : *Caller) {",
          "new_line_content": "    assert(BBToWeightMap.find(currBB) != BBToWeightMap.end() &&",
          "content_same": false
        },
        {
          "line": 820,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "ller->size());",
          "old_line_content": "        if (!currCount) {",
          "new_line_content": "  DominanceOrder domOrder(&Caller->front(), DT, Caller->size());",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": null,
          "new_api": "getNext",
          "old_text": null,
          "new_text": "mOrder.getNext()) ",
          "old_line_content": "          ++blocksWithoutCount;",
          "new_line_content": "  while (SILBasicBlock *block = domOrder.getNext()) {",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "ToWeightMap.find(block);\n",
          "old_line_content": "          continue;",
          "new_line_content": "    auto bbIt = BBToWeightMap.find(block);",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "ToWeightMap.end() &",
          "old_line_content": "        }",
          "new_line_content": "    assert(bbIt != BBToWeightMap.end() && \"Expected to find block in map\");",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": null,
          "new_api": "getTerminator",
          "old_text": null,
          "new_text": "ock->getTerminator();\n",
          "old_line_content": "        countSum += currCountVal;",
          "new_line_content": "    auto *termInst = block->getTerminator();",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": null,
          "new_api": "ntainsWeight",
          "old_text": null,
          "new_text": "ntainsWeight(termInst)) ",
          "old_line_content": "        BBToWeightMap[currBB] += currCountVal;",
          "new_line_content": "    if (containsWeight(termInst)) {",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": null,
          "new_api": "getSuccessors",
          "old_text": null,
          "new_text": "rmInst->getSuccessors()) ",
          "old_line_content": "        if (blocksWithoutCount > 0) {",
          "new_line_content": "      for (auto &succ : termInst->getSuccessors()) {",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": null,
          "new_api": "getBB",
          "old_text": null,
          "new_text": "cc.getBB();\n",
          "old_line_content": "          auto numToAdd = (bbCount - countSum) / blocksWithoutCount;",
          "new_line_content": "        auto *currBB = succ.getBB();",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": null,
          "new_api": "getValue",
          "old_text": null,
          "new_text": "rrCount.getValue();\n",
          "old_line_content": "        }",
          "new_line_content": "        auto currCountVal = currCount.getValue();",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": null,
          "new_api": "getSuccessors",
          "old_text": null,
          "new_text": "rmInst->getSuccessors()) ",
          "old_line_content": "      // Fill counters speculatively",
          "new_line_content": "          for (auto &succ : termInst->getSuccessors()) {",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": null,
          "new_api": "getCount",
          "old_text": null,
          "new_text": "cc.getCount();\n",
          "old_line_content": "      if (numOfSucc == 0) {",
          "new_line_content": "            auto currCount = succ.getCount();",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": null,
          "new_api": "sert",
          "old_text": null,
          "new_text": "sert(numOfSucc > 0 && \"Expected successors > 0\");\n",
          "old_line_content": "  }",
          "new_line_content": "        assert(numOfSucc > 0 && \"Expected successors > 0\");",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": null,
          "new_api": "dToBBCounts",
          "old_text": null,
          "new_text": "dToBBCounts(BBToWeightMap, numToAdd, termInst);\n",
          "old_line_content": "",
          "new_line_content": "        addToBBCounts(BBToWeightMap, numToAdd, termInst);",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": null,
          "new_api": "pushChildrenIf",
          "old_text": null,
          "new_text": "mOrder.pushChildrenIf(block, [&](SILBasicBlock *child) { return true; });\n",
          "old_line_content": "    // This closure returns the length of a called function.",
          "new_line_content": "    domOrder.pushChildrenIf(block, [&](SILBasicBlock *child) { return true; });",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "->get(Caller);\n",
          "old_line_content": "      // Compute the shortest-path analysis for the callee.",
          "new_line_content": "  DominanceInfo *DT = DA->get(Caller);",
          "content_same": false
        },
        {
          "line": 883,
          "old_api": null,
          "new_api": "tSPA",
          "old_text": null,
          "new_text": "tSPA(Caller, LI);\n",
          "old_line_content": "          // the callee are assumed to have DefaultApplyLength.",
          "new_line_content": "  ShortestPathAnalysis *SPA = getSPA(Caller, LI);",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": null,
          "new_api": "analyze",
          "old_text": null,
          "new_text": "A->analyze(CBI, [&](FullApplySite FAS) -> int {\n  \n    // This closure returns the length of a called function.\n\n    // At this occasion we record additional weight increases.\n    addWeightCorrection(FAS, WeightCorrections);\n\n    if (SILFunction *Callee = getEligibleFunction(FAS, WhatToInline)) {\n      // Compute the shortest-path analysis for the callee.\n      SILLoopInfo *CalleeLI = LA->get(Callee);\n      ShortestPathAnalysis *CalleeSPA = getSPA(Callee, CalleeLI);\n      if (!CalleeSPA->isValid()) {\n        CalleeSPA->analyze(CBI, [](FullApplySite FAS) {\n          // We don't compute SPA for another call-level. Functions called from\n          // the callee are assumed to have DefaultApplyLength.\n          return DefaultApplyLength;\n        });\n      }\n      int CalleeLength = CalleeSPA->getScopeLength(&Callee->front(), 0);\n      // Just in case the callee is a noreturn function.\n      if (CalleeLength >= ShortestPathAnalysis::InitialDist)\n        return DefaultApplyLength;\n      return CalleeLength;\n    }\n    // Some unknown function.\n    return DefaultApplyLength;\n  });\n",
          "old_line_content": "          return DefaultApplyLength;",
          "new_line_content": "  SPA->analyze(CBI, [&](FullApplySite FAS) -> int {",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": null,
          "new_api": "dWeightCorrection",
          "old_text": null,
          "new_text": "dWeightCorrection(FAS, WeightCorrections);\n",
          "old_line_content": "      if (CalleeLength >= ShortestPathAnalysis::InitialDist)",
          "new_line_content": "    addWeightCorrection(FAS, WeightCorrections);",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": null,
          "new_api": "tEligibleFunction",
          "old_text": null,
          "new_text": "tEligibleFunction(FAS, WhatToInline)) ",
          "old_line_content": "      return CalleeLength;",
          "new_line_content": "    if (SILFunction *Callee = getEligibleFunction(FAS, WhatToInline)) {",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "->get(Callee);\n",
          "old_line_content": "    // Some unknown function.",
          "new_line_content": "      SILLoopInfo *CalleeLI = LA->get(Callee);",
          "content_same": false
        },
        {
          "line": 894,
          "old_api": null,
          "new_api": "tSPA",
          "old_text": null,
          "new_text": "tSPA(Callee, CalleeLI);\n",
          "old_line_content": "    return DefaultApplyLength;",
          "new_line_content": "      ShortestPathAnalysis *CalleeSPA = getSPA(Callee, CalleeLI);",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": null,
          "new_api": "isValid",
          "old_text": null,
          "new_text": "lleeSPA->isValid()) ",
          "old_line_content": "  });",
          "new_line_content": "      if (!CalleeSPA->isValid()) {",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": null,
          "new_api": "analyze",
          "old_text": null,
          "new_text": "lleeSPA->analyze(CBI, [](FullApplySite FAS) {\n          // We don't compute SPA for another call-level. Functions called from\n          // the callee are assumed to have DefaultApplyLength.\n          return DefaultApplyLength;\n        });\n",
          "old_line_content": "",
          "new_line_content": "        CalleeSPA->analyze(CBI, [](FullApplySite FAS) {",
          "content_same": false
        },
        {
          "line": 902,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "llee->front(), ",
          "old_line_content": "",
          "new_line_content": "      int CalleeLength = CalleeSPA->getScopeLength(&Callee->front(), 0);",
          "content_same": false
        },
        {
          "line": 919,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "ller->size());",
          "old_line_content": "",
          "new_line_content": "  DominanceOrder domOrder(&Caller->front(), DT, Caller->size());",
          "content_same": false
        },
        {
          "line": 411,
          "old_api": null,
          "new_api": "getSubstitutionMap",
          "old_text": null,
          "new_text": ".getSubstitutionMap();\n",
          "old_line_content": "",
          "new_line_content": "  SubstitutionMap CalleeSubstMap = AI.getSubstitutionMap();",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": null,
          "new_api": "updateBenefit",
          "old_text": null,
          "new_text": "llerWeight.updateBenefit(Benefit, BaseBenefit);\n",
          "old_line_content": "",
          "new_line_content": "  CallerWeight.updateBenefit(Benefit, BaseBenefit);",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": null,
          "new_api": "getNext",
          "old_text": null,
          "new_text": "mOrder.getNext()) ",
          "old_line_content": "        // just add it to our final Applies list and continue.",
          "new_line_content": "  while (SILBasicBlock *block = domOrder.getNext()) {",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": null,
          "new_api": "getWeight",
          "old_text": null,
          "new_text": "A->getWeight(block, CallerWeight);\n",
          "old_line_content": "",
          "new_line_content": "    Weight BlockW = SPA->getWeight(block, CallerWeight);",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "ock->end(); ",
          "old_line_content": "          continue;",
          "new_line_content": "    for (auto I = block->begin(), E = block->end(); I != E; ++I) {",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": null,
          "new_api": "trackInst",
          "old_text": null,
          "new_text": "nstTracker.trackInst(&*I);\n",
          "old_line_content": "        }",
          "new_line_content": "      constTracker.trackInst(&*I);",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": null,
          "new_api": "trackInst",
          "old_text": null,
          "new_text": "nstTracker.trackInst(&I);\n",
          "old_line_content": "",
          "new_line_content": "      constTracker.trackInst(&I);",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": null,
          "new_api": "llApplySite::isa(&*I))",
          "old_text": null,
          "new_text": "llApplySite::isa(&*I))\n",
          "old_line_content": "        // Next make sure that we do not have more blocks than our overall",
          "new_line_content": "      if (!FullApplySite::isa(&*I))",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": null,
          "new_api": "structionInlineCost",
          "old_text": null,
          "new_text": "structionInlineCost(I);\n",
          "old_line_content": "",
          "new_line_content": "      CalleeCost += (int)instructionInlineCost(I);",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": null,
          "new_api": "llApplySite::isa(&I))",
          "old_text": null,
          "new_text": "llApplySite::isa(&I)) ",
          "old_line_content": "        // Check if the callee is passed as an argument. If so, increase the",
          "new_line_content": "      if (FullApplySite FAI = FullApplySite::isa(&I)) {",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": null,
          "new_api": "llApplySite",
          "old_text": null,
          "new_text": "llApplySite(&*I);\n",
          "old_line_content": "        // but we /do/ inline any inline_always functions remaining.",
          "new_line_content": "      FullApplySite AI = FullApplySite(&*I);",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": null,
          "new_api": "tEligibleFunction",
          "old_text": null,
          "new_text": "tEligibleFunction(AI, WhatToInline);\n",
          "old_line_content": "          continue;",
          "new_line_content": "      auto *Callee = getEligibleFunction(AI, WhatToInline);",
          "content_same": false
        },
        {
          "line": 431,
          "old_api": null,
          "new_api": "updateBenefit",
          "old_text": null,
          "new_text": "ockW.updateBenefit(Benefit, RemovedClosureBenefit);\n",
          "old_line_content": "        // Check if inlining the callee would allow for further",
          "new_line_content": "          BlockW.updateBenefit(Benefit, RemovedClosureBenefit);",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "plies.push_back(AI);\n",
          "old_line_content": "",
          "new_line_content": "          Applies.push_back(AI);",
          "content_same": false
        },
        {
          "line": 435,
          "old_api": null,
          "new_api": "getCallee",
          "old_text": null,
          "new_text": "I.getCallee());",
          "old_line_content": "",
          "new_line_content": "          def = dyn_cast_or_null<SingleValueInstruction>(FAI.getCallee());",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": null,
          "new_api": "getSubstitutionMap",
          "old_text": null,
          "new_text": "I.getSubstitutionMap();\n",
          "old_line_content": "",
          "new_line_content": "        auto Subs = FAI.getSubstitutionMap();",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": null,
          "new_api": "hasAnySubstitutableParams",
          "old_text": null,
          "new_text": "bs.hasAnySubstitutableParams())\n",
          "old_line_content": "          continue;",
          "new_line_content": "        if (!EnableSILInliningOfGenerics || !Subs.hasAnySubstitutableParams())",
          "content_same": false
        },
        {
          "line": 447,
          "old_api": null,
          "new_api": "a<WitnessMethodInst>(def))",
          "old_text": null,
          "new_text": "a<WitnessMethodInst>(def))\n",
          "old_line_content": "          continue;",
          "new_line_content": "            !isa<WitnessMethodInst>(def))",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": null,
          "new_api": "ight",
          "old_text": null,
          "new_text": "ight(0, 0));",
          "old_line_content": "        return false;",
          "new_line_content": "          BlockWeight = SPA->getWeight(block, Weight(0, 0));",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": null,
          "new_api": "lookup",
          "old_text": null,
          "new_text": "ightCorrections.lookup(AI));",
          "old_line_content": "    });",
          "new_line_content": "        Weight W(BlockWeight, WeightCorrections.lookup(AI));",
          "content_same": false
        },
        {
          "line": 965,
          "old_api": null,
          "new_api": "cideInWarmBlock",
          "old_text": null,
          "new_text": "cideInWarmBlock(AI, W, constTracker, NumCallerBlocks,\n                              BBToWeightMap))\n",
          "old_line_content": "",
          "new_line_content": "        if (decideInWarmBlock(AI, W, constTracker, NumCallerBlocks,",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "itialCandidates.push_back(AI);\n",
          "old_line_content": "  llvm::DenseMap<SILFunction *, unsigned> CalleeCount;",
          "new_line_content": "          InitialCandidates.push_back(AI);",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": null,
          "new_api": "subst",
          "old_text": null,
          "new_text": "bs.subst(CalleeSubstMap);\n",
          "old_line_content": "",
          "new_line_content": "        auto SubMap = Subs.subst(CalleeSubstMap);",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": null,
          "new_api": "pushChildrenIf",
          "old_text": null,
          "new_text": "mOrder.pushChildrenIf(block, [&] (SILBasicBlock *child) {\n      if (CBI.isSlowPath(block, child)) {\n        // Handle cold blocks separately.\n        visitColdBlocks(InitialCandidates, child, DT);\n        return false;\n      }\n      return true;\n    });\n",
          "old_line_content": "    ++CalleeCount[Callee];",
          "new_line_content": "    domOrder.pushChildrenIf(block, [&] (SILBasicBlock *child) {",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": null,
          "new_api": "a<SuperMethodInst>(def))",
          "old_text": null,
          "new_text": "a<SuperMethodInst>(def)) ",
          "old_line_content": "          // TODO: Take AI.getSubstitutions() into account.",
          "new_line_content": "            isa<SuperMethodInst>(def)) {",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": null,
          "new_api": "isSlowPath",
          "old_text": null,
          "new_text": "I.isSlowPath(block, child)) ",
          "old_line_content": "  }",
          "new_line_content": "      if (CBI.isSlowPath(block, child)) {",
          "content_same": false
        },
        {
          "line": 974,
          "old_api": null,
          "new_api": "sitColdBlocks",
          "old_text": null,
          "new_text": "sitColdBlocks(InitialCandidates, child, DT);\n",
          "old_line_content": "  // Now copy each candidate callee that has a small enough number of",
          "new_line_content": "        visitColdBlocks(InitialCandidates, child, DT);",
          "content_same": false
        },
        {
          "line": 463,
          "old_api": null,
          "new_api": "vm::dbgs() <",
          "old_text": null,
          "new_text": "vm::dbgs() <",
          "old_line_content": "                                       \"after inlining for the call:\\n\";",
          "new_line_content": "            LLVM_DEBUG(llvm::dbgs() << \"Devirtualization will be possible \"",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": null,
          "new_api": "updateBenefit",
          "old_text": null,
          "new_text": "ockW.updateBenefit(Benefit, DevirtualizedCallBenefit);\n",
          "old_line_content": "          }",
          "new_line_content": "            BlockW.updateBenefit(Benefit, DevirtualizedCallBenefit);",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": null,
          "new_api": "getReferencedFunctionOrNull",
          "old_text": null,
          "new_text": ".getReferencedFunctionOrNull();\n",
          "old_line_content": "  }",
          "new_line_content": "    SILFunction *Callee = AI.getReferencedFunctionOrNull();",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": null,
          "new_api": "nSpecializeGeneric",
          "old_text": null,
          "new_text": "nSpecializeGeneric(FAI, CalleeF, SubMap))\n",
          "old_line_content": "            continue;",
          "new_line_content": "          if (!canSpecializeGeneric(FAI, CalleeF, SubMap))",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": null,
          "new_api": "sert",
          "old_text": null,
          "new_text": "sert(Callee && \"apply_inst does not have a direct callee anymore\");\n",
          "old_line_content": "}",
          "new_line_content": "    assert(Callee && \"apply_inst does not have a direct callee anymore\");",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": null,
          "new_api": "vm::dbgs() <",
          "old_text": null,
          "new_text": "vm::dbgs() <",
          "old_line_content": "                                     \"after inlining for the call:\\n\";",
          "new_line_content": "          LLVM_DEBUG(llvm::dbgs() << \"Generic specialization will be possible \"",
          "content_same": false
        },
        {
          "line": 478,
          "old_api": null,
          "new_api": "updateBenefit",
          "old_text": null,
          "new_text": "ockW.updateBenefit(Benefit, GenericSpecializationBenefit);\n",
          "old_line_content": "        }",
          "new_line_content": "          BlockW.updateBenefit(Benefit, GenericSpecializationBenefit);",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": null,
          "new_api": "n_cast<LoadInst>(&I))",
          "old_text": null,
          "new_text": "n_cast<LoadInst>(&I)) ",
          "old_line_content": "        // Check if it's a load from a stack location in the caller. Such a load",
          "new_line_content": "      } else if (auto *LI = dyn_cast<LoadInst>(&I)) {",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": null,
          "new_api": "getReferencedFunctionOrNull",
          "old_text": null,
          "new_text": ".getReferencedFunctionOrNull();\n",
          "old_line_content": "    return false;",
          "new_line_content": "    SILFunction *Callee = AI.getReferencedFunctionOrNull();",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": null,
          "new_api": "sert",
          "old_text": null,
          "new_text": "sert(Callee && \"apply_inst does not have a direct callee anymore\");\n",
          "old_line_content": "",
          "new_line_content": "    assert(Callee && \"apply_inst does not have a direct callee anymore\");",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": null,
          "new_api": "n_cast<StoreInst>(&I))",
          "old_text": null,
          "new_text": "n_cast<StoreInst>(&I)) ",
          "old_line_content": "        // Check if it's a store to a stack location in the caller. Such a load",
          "new_line_content": "      } else if (auto *SI = dyn_cast<StoreInst>(&I)) {",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "plies.push_back(AI);\n",
          "old_line_content": "  SmallVector<FullApplySite, 8> AppliesToInline;",
          "new_line_content": "      Applies.push_back(AI);",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": null,
          "new_api": "getArgumentConvention",
          "old_text": null,
          "new_text": "g->getArgumentConvention() =",
          "old_line_content": "              SILArgumentConvention::Direct_Guaranteed) {",
          "new_line_content": "          if (Arg->getArgumentConvention() ==",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": null,
          "new_api": "shouldOptimize",
          "old_text": null,
          "new_text": "ller->shouldOptimize())\n",
          "old_line_content": "  // Second step: do the actual inlining.",
          "new_line_content": "  if (!Caller->shouldOptimize())",
          "content_same": false
        },
        {
          "line": 495,
          "old_api": null,
          "new_api": "updateBenefit",
          "old_text": null,
          "new_text": "ockW.updateBenefit(Benefit, RefCountBenefit);\n",
          "old_line_content": "          }",
          "new_line_content": "            BlockW.updateBenefit(Benefit, RefCountBenefit);",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": null,
          "new_api": "getEnforcement",
          "old_text": null,
          "new_text": "I->getEnforcement() =",
          "old_line_content": "          // The access is dynamic and has no nested conflict",
          "new_line_content": "        if (BAI->getEnforcement() == SILAccessEnforcement::Dynamic) {",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "pliesToInline.empty())\n",
          "old_line_content": "",
          "new_line_content": "  if (AppliesToInline.empty())",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": null,
          "new_api": "updateBenefit",
          "old_text": null,
          "new_text": "ockW.updateBenefit(ExclusivityBenefitWeight,\n                                 ExclusivityBenefitBase);\n",
          "old_line_content": "                                 ExclusivityBenefitBase);",
          "new_line_content": "            BlockW.updateBenefit(ExclusivityBenefitWeight,",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1027,
          "old_api": "getName",
          "new_api": null,
          "old_text": "llee->getName() <",
          "new_text": null,
          "old_line_content": "                                   << Callee->getName() << \"\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 518,
          "old_api": "updateBenefit",
          "new_api": null,
          "old_text": "ockW.updateBenefit(Benefit, RemovedTerminatorBenefit);\n",
          "new_text": null,
          "old_line_content": "      BlockW.updateBenefit(Benefit, RemovedTerminatorBenefit);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": "LInliner::invalidatesStackNesting(AI);",
          "new_api": null,
          "old_text": "LInliner::invalidatesStackNesting(AI);\n",
          "new_text": null,
          "old_line_content": "    invalidatedStackNesting |= SILInliner::invalidatesStackNesting(AI);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 520,
          "old_api": "getSinglePredecessorBlock",
          "new_api": null,
          "old_text": "ild->getSinglePredecessorBlock() !",
          "new_text": null,
          "old_line_content": "        return child->getSinglePredecessorBlock() != block ||",
          "new_line_content": "        // most likely has a benefit in the caller, because e.g. it can enable",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": "pushChildrenIf",
          "new_api": null,
          "old_text": "mOrder.pushChildrenIf(block, [=](SILBasicBlock *child) {\n        return child->getSinglePredecessorBlock() != block ||\n               child == takenBlock;\n      });\n",
          "new_text": null,
          "old_line_content": "      domOrder.pushChildrenIf(block, [=](SILBasicBlock *child) {",
          "new_line_content": "        // Inlining functions which return an allocated object or partial_apply",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": "intInliningDetailsCallee",
          "new_api": null,
          "old_text": "intInliningDetailsCallee(PassName, Caller, Callee);\n",
          "new_text": null,
          "old_line_content": "      printInliningDetailsCallee(PassName, Caller, Callee);",
          "new_line_content": "    // apply site for now.",
          "content_same": false
        },
        {
          "line": 524,
          "old_api": "pushChildren",
          "new_api": null,
          "old_text": "mOrder.pushChildren(block);\n",
          "new_text": null,
          "old_line_content": "      domOrder.pushChildren(block);",
          "new_line_content": "          returnsAllocation = true;",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": "intInliningDetailsCallerBefore",
          "new_api": null,
          "old_text": "intInliningDetailsCallerBefore(PassName, Caller, Callee);\n",
          "new_text": null,
          "old_line_content": "      printInliningDetailsCallerBefore(PassName, Caller, Callee);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": "LInliner::inlineFullApply(AI, SILInliner::InlineKind::PerformanceInline,\n                                FuncBuilder, deleter);",
          "new_api": null,
          "old_text": "LInliner::inlineFullApply(AI, SILInliner::InlineKind::PerformanceInline,\n                                FuncBuilder, deleter);\n",
          "new_text": null,
          "old_line_content": "    SILInliner::inlineFullApply(AI, SILInliner::InlineKind::PerformanceInline,",
          "new_line_content": "    // Note that this must happen before inlining as the apply instruction",
          "content_same": false
        },
        {
          "line": 1048,
          "old_api": "intInliningDetailsCallerAfter",
          "new_api": null,
          "old_text": "intInliningDetailsCallerAfter(PassName, Caller, Callee);\n",
          "new_text": null,
          "old_line_content": "      printInliningDetailsCallerAfter(PassName, Caller, Callee);",
          "new_line_content": "    if (SILPrintInliningCallee) {",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": "cleanupDeadInstructions",
          "new_api": null,
          "old_text": "leter.cleanupDeadInstructions();\n",
          "new_text": null,
          "old_line_content": "  deleter.cleanupDeadInstructions();",
          "new_line_content": "    if (SILPrintInliningCallerBefore) {",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": "getFunction",
          "new_api": null,
          "old_text": ".getFunction());",
          "new_text": null,
          "old_line_content": "    LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": "getName",
          "new_api": null,
          "old_text": "llee->getName() <",
          "new_text": null,
          "old_line_content": "                            << Callee->getName() << '\\n');",
          "new_line_content": "  if (AllAccessesBeneficialToInline) {",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": "vm::dbgs() <",
          "new_api": null,
          "old_text": "vm::dbgs() <",
          "new_text": null,
          "old_line_content": "               llvm::dbgs() << \"    decision {\" << CalleeCost << \" into thunk} \"",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": "rgeBasicBlocks",
          "new_api": null,
          "old_text": "rgeBasicBlocks(Caller);\n",
          "new_text": null,
          "old_line_content": "  mergeBasicBlocks(Caller);",
          "new_line_content": "    // unconditionally inline the function.",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": "ackNesting::fixNesting(Caller);",
          "new_api": null,
          "old_text": "ackNesting::fixNesting(Caller);\n",
          "new_text": null,
          "old_line_content": "    StackNesting::fixNesting(Caller);",
          "new_line_content": "    // will assert, so we are safe making this assumption.",
          "content_same": false
        },
        {
          "line": 1065,
          "old_api": "verify",
          "new_api": null,
          "old_text": "ller->verify();\n",
          "new_text": null,
          "old_line_content": "    Caller->verify();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": "getInstruction",
          "new_api": null,
          "old_text": ".getInstruction()->getParent();\n",
          "new_text": null,
          "old_line_content": "  auto *bb = AI.getInstruction()->getParent();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": "find",
          "new_api": null,
          "old_text": "ToWeightMap.find(bb);\n",
          "new_text": null,
          "old_line_content": "  auto bbIt = BBToWeightMap.find(bb);",
          "new_line_content": "  // We reduce the benefit if the caller is too large. For this we use a",
          "content_same": false
        },
        {
          "line": 559,
          "old_api": "end",
          "new_api": null,
          "old_text": "ToWeightMap.end()) ",
          "new_text": null,
          "old_line_content": "  if (bbIt != BBToWeightMap.end()) {",
          "new_line_content": "  // cubic function on the number of caller blocks. This starts to prevent",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": "ofileBasedDecision",
          "new_api": null,
          "old_text": "ofileBasedDecision(AI, Benefit, Callee, CalleeCost, NumCallerBlocks,\n                             bbIt)) ",
          "new_text": null,
          "old_line_content": "    if (profileBasedDecision(AI, Benefit, Callee, CalleeCost, NumCallerBlocks,",
          "new_line_content": "  // inlining at about 800 - 1000 caller blocks.",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": "getInstruction",
          "new_api": null,
          "old_text": "tRemark::Emitter::emitOrDebug(DEBUG_TYPE, &ORE, [&]() {\n        using namespace OptRemark;\n        return RemarkPassed(\"Inline\", *AI.getInstruction())\n               << \"Profitable due to provided profile\";\n      });\n",
          "new_text": null,
          "old_line_content": "      OptRemark::Emitter::emitOrDebug(DEBUG_TYPE, &ORE, [&]() {",
          "new_line_content": "    Benefit -= ",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": "getInstruction",
          "new_api": null,
          "old_text": ".getInstruction())\n",
          "new_text": null,
          "old_line_content": "        return RemarkPassed(\"Inline\", *AI.getInstruction())",
          "new_line_content": "                          NumCallerBlocks / BlockLimitDenominator;",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": "getNext",
          "new_api": null,
          "old_text": "mOrder.getNext()) ",
          "new_text": null,
          "old_line_content": "  while (SILBasicBlock *block = domOrder.getNext()) {",
          "new_line_content": "  // find into it, do so now. This makes it easier to catch verification bugs in",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": "n_cast<ApplyInst>(&I);",
          "new_api": null,
          "old_text": "n_cast<ApplyInst>(&I);\n",
          "new_text": null,
          "old_line_content": "      auto *AI = dyn_cast<ApplyInst>(&I);",
          "new_line_content": "  if (EnableVerifyAfterInlining) {",
          "content_same": false
        },
        {
          "line": 1083,
          "old_api": "tEligibleFunction",
          "new_api": null,
          "old_text": "tEligibleFunction(AI, WhatToInline);\n",
          "new_text": null,
          "old_line_content": "      auto *Callee = getEligibleFunction(AI, WhatToInline);",
          "new_line_content": "  return true;",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": "cideInColdBlock",
          "new_api": null,
          "old_text": "cideInColdBlock(AI, Callee)) ",
          "new_text": null,
          "old_line_content": "      if (Callee && decideInColdBlock(AI, Callee)) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "pliesToInline.push_back(AI);\n",
          "new_text": null,
          "old_line_content": "        AppliesToInline.push_back(AI);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": "pushChildren",
          "new_api": null,
          "old_text": "mOrder.pushChildren(block);\n",
          "new_text": null,
          "old_line_content": "    domOrder.pushChildren(block);",
          "new_line_content": "void SILPerformanceInliner::visitColdBlocks(",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": "getInstruction",
          "new_api": null,
          "old_text": "tRemark::Emitter::emitOrDebug(DEBUG_TYPE, &ORE, [&]() {\n      using namespace OptRemark;\n      return RemarkMissed(\"Inline\", *AI.getInstruction())\n             << \"Not profitable to inline function \" << NV(\"Callee\", Callee)\n             << \" (cost = \" << NV(\"Cost\", CalleeCost)\n             << \", benefit = \" << NV(\"Benefit\", Benefit) << \")\";\n    });\n",
          "new_text": null,
          "old_line_content": "    OptRemark::Emitter::emitOrDebug(DEBUG_TYPE, &ORE, [&]() {",
          "new_line_content": "      using namespace OptRemark;",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": "getInstruction",
          "new_api": null,
          "old_text": ".getInstruction())\n",
          "new_text": null,
          "old_line_content": "      return RemarkMissed(\"Inline\", *AI.getInstruction())",
          "new_line_content": "             << \"Not profitable due to provided profile\";",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": "(\"Callee\", Callee)",
          "new_api": null,
          "old_text": "(\"Callee\", Callee)\n ",
          "new_text": null,
          "old_line_content": "             << \"Not profitable to inline function \" << NV(\"Callee\", Callee)",
          "new_line_content": "    });",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": "(\"Cost\", CalleeCost)",
          "new_api": null,
          "old_text": "(\"Cost\", CalleeCost)\n ",
          "new_text": null,
          "old_line_content": "             << \" (cost = \" << NV(\"Cost\", CalleeCost)",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": "(\"Benefit\", Benefit) <",
          "new_api": null,
          "old_text": "(\"Benefit\", Benefit) <",
          "new_text": null,
          "old_line_content": "             << \", benefit = \" << NV(\"Benefit\", Benefit) << \")\";",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": "size",
          "new_api": null,
          "old_text": "llee->size();\n",
          "new_text": null,
          "old_line_content": "  NumCallerBlocks += Callee->size();",
          "new_line_content": "      Benefit += 10;",
          "content_same": false
        },
        {
          "line": 1107,
          "old_api": "append",
          "new_api": null,
          "old_text": "ssName.append(\" Performance Inliner\");\n",
          "new_text": null,
          "old_line_content": "    PassName.append(\" Performance Inliner\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": "getFunction",
          "new_api": null,
          "old_text": ".getFunction());",
          "new_text": null,
          "old_line_content": "  LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 597,
          "old_api": "vm::dbgs() <",
          "new_api": null,
          "old_text": "vm::dbgs() <",
          "new_text": null,
          "old_line_content": "             llvm::dbgs() << \"    decision {c=\" << CalleeCost",
          "new_line_content": "  // This is the final inlining decision.",
          "content_same": false
        },
        {
          "line": 1111,
          "old_api": "->getAnalysis<DominanceAnalysis>();",
          "new_api": null,
          "old_text": "->getAnalysis<DominanceAnalysis>();\n",
          "new_text": null,
          "old_line_content": "    DominanceAnalysis *DA = PM->getAnalysis<DominanceAnalysis>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1112,
          "old_api": "->getAnalysis<SILLoopAnalysis>();",
          "new_api": null,
          "old_text": "->getAnalysis<SILLoopAnalysis>();\n",
          "new_text": null,
          "old_line_content": "    SILLoopAnalysis *LA = PM->getAnalysis<SILLoopAnalysis>();",
          "new_line_content": "namespace {",
          "content_same": false
        },
        {
          "line": 1113,
          "old_api": "->getAnalysis<SideEffectAnalysis>();",
          "new_api": null,
          "old_text": "->getAnalysis<SideEffectAnalysis>();\n",
          "new_text": null,
          "old_line_content": "    SideEffectAnalysis *SEA = PM->getAnalysis<SideEffectAnalysis>();",
          "new_line_content": "class SILPerformanceInlinerPass : public SILFunctionTransform {",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": "tFunction",
          "new_api": null,
          "old_text": "tFunction());",
          "new_text": null,
          "old_line_content": "    OptRemark::Emitter ORE(DEBUG_TYPE, *getFunction());",
          "new_line_content": "  /// Specifies which functions not to inline, based on @_semantics and",
          "content_same": false
        },
        {
          "line": 1116,
          "old_api": "tOptions",
          "new_api": null,
          "old_text": "tOptions().I",
          "new_text": null,
          "old_line_content": "    if (getOptions().InlineThreshold == 0) {",
          "new_line_content": "  InlineSelection WhatToInline;",
          "content_same": false
        },
        {
          "line": 606,
          "old_api": "getInstruction",
          "new_api": null,
          "old_text": ".getInstruction())\n",
          "new_text": null,
          "old_line_content": "    return RemarkPassed(\"Inlined\", *AI.getInstruction())",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 607,
          "old_api": "(\"Callee\", Callee) <",
          "new_api": null,
          "old_text": "(\"Callee\", Callee) <",
          "new_text": null,
          "old_line_content": "           << NV(\"Callee\", Callee) << \" inlined into \"",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": "getFunction",
          "new_api": null,
          "old_text": ".getFunction())\n",
          "new_text": null,
          "old_line_content": "           << NV(\"Caller\", AI.getFunction())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": "getEffectiveOptimizationMode",
          "new_api": null,
          "old_text": "tFunction()->getEffectiveOptimizationMode();\n",
          "new_text": null,
          "old_line_content": "    auto OptMode = getFunction()->getEffectiveOptimizationMode();",
          "new_line_content": "  SILPerformanceInlinerPass(InlineSelection WhatToInline, StringRef LevelName):",
          "content_same": false
        },
        {
          "line": 610,
          "old_api": "(\"Benefit\", Benefit) <",
          "new_api": null,
          "old_text": "(\"Benefit\", Benefit) <",
          "new_text": null,
          "old_line_content": "           << \", benefit = \" << NV(\"Benefit\", Benefit) << \")\";",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": "tFunction",
          "new_api": null,
          "old_text": "tFunction()))",
          "new_text": null,
          "old_line_content": "    if (Inliner.inlineCallsIntoFunction(getFunction())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": "startPassPipeline",
          "new_api": null,
          "old_text": "startPassPipeline();\n",
          "new_text": null,
          "old_line_content": "      restartPassPipeline();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 626,
          "old_api": "isTransparent",
          "new_api": null,
          "old_text": "llee->isTransparent())\n",
          "new_text": null,
          "old_line_content": "  if (Callee->isTransparent())",
          "new_line_content": "  });",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": "getInlineStrategy",
          "new_api": null,
          "old_text": "llee->getInlineStrategy() =",
          "new_text": null,
          "old_line_content": "  if (Callee->getInlineStrategy() == AlwaysInline)",
          "new_line_content": "  return true;",
          "content_same": false
        },
        {
          "line": 629,
          "old_api": "getOptions",
          "new_api": null,
          "old_text": "llee->getModule().getOptions().I",
          "new_text": null,
          "old_line_content": "    if (!Callee->getModule().getOptions().IgnoreAlwaysInline)",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": "getSwiftModule",
          "new_api": null,
          "old_text": "llee->getModule().getSwiftModule();\n",
          "new_text": null,
          "old_line_content": "  ModuleDecl *SwiftModule = Callee->getModule().getSwiftModule();",
          "new_line_content": "/// Checks if a given generic apply should be inlined unconditionally, i.e.",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": "hasSemanticsAttrThatStartsWith",
          "new_api": null,
          "old_text": "llee->hasSemanticsAttrThatStartsWith(\"array.\") &",
          "new_text": null,
          "old_line_content": "  if (Callee->hasSemanticsAttrThatStartsWith(\"array.\") &&",
          "new_line_content": "/// without any complex analysis using e.g. a cost model.",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": "isOnoneSupportModule",
          "new_api": null,
          "old_text": "iftModule->isOnoneSupportModule()))",
          "new_text": null,
          "old_line_content": "      (SwiftModule->isStdlibModule() || SwiftModule->isOnoneSupportModule()))",
          "new_line_content": "/// It returns true if a function should be inlined.",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": "getFunction",
          "new_api": null,
          "old_text": ".getFunction()->isThunk())\n",
          "new_text": null,
          "old_line_content": "  if (AI.getFunction()->isThunk())",
          "new_line_content": "static Optional<bool> shouldInlineGeneric(FullApplySite AI) {",
          "content_same": false
        },
        {
          "line": 660,
          "old_api": "InlineAlwaysCallSite",
          "new_api": null,
          "old_text": "InlineAlwaysCallSite(Callee))\n",
          "new_text": null,
          "old_line_content": "  if (isInlineAlwaysCallSite(Callee))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": "getLoweredFunctionType",
          "new_api": null,
          "old_text": "llee->getLoweredFunctionType()->getCoroutineKind() !",
          "new_text": null,
          "old_line_content": "  if (Callee->getLoweredFunctionType()->getCoroutineKind() !=",
          "new_line_content": "  // Do not inline into thunks.",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": "turnsClosure",
          "new_api": null,
          "old_text": "turnsClosure(Callee))\n",
          "new_text": null,
          "old_line_content": "  if (Callee->isThunk() && returnsClosure(Callee))",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": "hasSubstitutions",
          "new_api": null,
          "old_text": ".hasSubstitutions()) ",
          "new_text": null,
          "old_line_content": "  if (AI.hasSubstitutions()) {",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 700,
          "old_api": "ouldInlineGeneric",
          "new_api": null,
          "old_text": "ouldInlineGeneric(AI);\n",
          "new_text": null,
          "old_line_content": "    auto ShouldInlineGeneric = shouldInlineGeneric(AI);",
          "new_line_content": "  // All other generic functions should not be inlined if this kind of inlining",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": "hasValue",
          "new_api": null,
          "old_text": "ouldInlineGeneric.hasValue())\n",
          "new_text": null,
          "old_line_content": "    if (ShouldInlineGeneric.hasValue())",
          "new_line_content": "  // is disabled.",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": "getValue",
          "new_api": null,
          "old_text": "ouldInlineGeneric.getValue();\n",
          "new_text": null,
          "old_line_content": "      return ShouldInlineGeneric.getValue();",
          "new_line_content": "  if (!EnableSILInliningOfGenerics)",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": "getReferencedFunctionOrNull",
          "new_api": null,
          "old_text": ".getReferencedFunctionOrNull();\n",
          "new_text": null,
          "old_line_content": "  SILFunction *Callee = AI.getReferencedFunctionOrNull();",
          "new_line_content": "  // It is not clear yet if this function should be decided or not.",
          "content_same": false
        },
        {
          "line": 707,
          "old_api": "InlineAlwaysCallSite",
          "new_api": null,
          "old_text": "InlineAlwaysCallSite(Callee)) ",
          "new_text": null,
          "old_line_content": "  if (isInlineAlwaysCallSite(Callee)) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": "getFunction",
          "new_api": null,
          "old_text": ".getFunction());",
          "new_text": null,
          "old_line_content": "    LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": "vm::dbgs() <",
          "new_api": null,
          "old_text": "vm::dbgs() <",
          "new_text": null,
          "old_line_content": "               llvm::dbgs() << \"    always-inline decision \"",
          "new_line_content": "bool SILPerformanceInliner::decideInWarmBlock(",
          "content_same": false
        },
        {
          "line": 710,
          "old_api": "getName",
          "new_api": null,
          "old_text": "llee->getName() <",
          "new_text": null,
          "old_line_content": "                            << Callee->getName() << '\\n');",
          "new_line_content": "    FullApplySite AI, Weight CallerWeight, ConstantTracker &callerTracker,",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": "ProfitableToInline",
          "new_api": null,
          "old_text": "ProfitableToInline(AI, CallerWeight, callerTracker, NumCallerBlocks,\n                              BBToWeightMap);\n",
          "new_text": null,
          "old_line_content": "  return isProfitableToInline(AI, CallerWeight, callerTracker, NumCallerBlocks,",
          "new_line_content": "    // Only inline generics if definitively clear that it should be done.",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": "hasSubstitutions",
          "new_api": null,
          "old_text": ".hasSubstitutions()) ",
          "new_text": null,
          "old_line_content": "  if (AI.hasSubstitutions()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": "InlineAlwaysCallSite",
          "new_api": null,
          "old_text": "InlineAlwaysCallSite(Callee)) ",
          "new_text": null,
          "old_line_content": "  if (isInlineAlwaysCallSite(Callee)) {",
          "new_line_content": "                              BBToWeightMap);",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": "getFunction",
          "new_api": null,
          "old_text": ".getFunction());",
          "new_text": null,
          "old_line_content": "    LLVM_DEBUG(dumpCaller(AI.getFunction());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 732,
          "old_api": "vm::dbgs() <",
          "new_api": null,
          "old_text": "vm::dbgs() <",
          "new_text": null,
          "old_line_content": "               llvm::dbgs() << \"    always-inline decision \"",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": "getName",
          "new_api": null,
          "old_text": "llee->getName() <",
          "new_text": null,
          "old_line_content": "                            << Callee->getName() << '\\n');",
          "new_line_content": "/// Return true if inlining this call site into a cold block is profitable.",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": "structionInlineCost",
          "new_api": null,
          "old_text": "structionInlineCost(I));",
          "new_text": null,
          "old_line_content": "      CalleeCost += int(instructionInlineCost(I));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": "getReferencedFunctionOrNull",
          "new_api": null,
          "old_text": "S.getReferencedFunctionOrNull();\n",
          "new_text": null,
          "old_line_content": "  SILFunction *Callee = FAS.getReferencedFunctionOrNull();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": "hasSemanticsAttr",
          "new_api": null,
          "old_text": "llee->hasSemanticsAttr(semantics::ARRAY_UNINITIALIZED)) ",
          "new_text": null,
          "old_line_content": "  if (Callee && Callee->hasSemanticsAttr(semantics::ARRAY_UNINITIALIZED)) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": "getArgument",
          "new_api": null,
          "old_text": "S.getArgument(0);\n",
          "new_text": null,
          "old_line_content": "    SILValue BufferArg = FAS.getArgument(0);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 766,
          "old_api": "ripCasts",
          "new_api": null,
          "old_text": "ripCasts(BufferArg));",
          "new_text": null,
          "old_line_content": "    SILValue Base = stripValueProjections(stripCasts(BufferArg));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": "llApplySite::isa(Base))",
          "new_api": null,
          "old_text": "llApplySite::isa(Base))\n",
          "new_text": null,
          "old_line_content": "    if (auto BaseApply = FullApplySite::isa(Base))",
          "new_line_content": "/// Record additional weight increases.",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": "getSuccessors",
          "new_api": null,
          "old_text": "st->getSuccessors()) ",
          "new_text": null,
          "old_line_content": "  for (auto &succ : inst->getSuccessors()) {",
          "new_line_content": "                        llvm::DenseMap<FullApplySite, int> &WeightCorrections) {",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": "getSuccessors",
          "new_api": null,
          "old_text": "rmInst->getSuccessors()) ",
          "new_text": null,
          "old_line_content": "  for (auto &succ : termInst->getSuccessors()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": "getBB",
          "new_api": null,
          "old_text": "cc.getBB();\n",
          "new_text": null,
          "old_line_content": "    auto *currBB = succ.getBB();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": "end",
          "new_api": null,
          "old_text": "ToWeightMap.end() &",
          "new_text": null,
          "old_line_content": "    assert(BBToWeightMap.find(currBB) != BBToWeightMap.end() &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": "getEntryCount",
          "new_api": null,
          "old_text": "ller->getEntryCount();\n",
          "new_text": null,
          "old_line_content": "  auto entryCount = Caller->getEntryCount();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": "getValue",
          "new_api": null,
          "old_text": "tryCount.getValue();\n",
          "new_text": null,
          "old_line_content": "  BBToWeightMap[Caller->getEntryBlock()] = entryCount.getValue();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": "size",
          "new_api": null,
          "old_text": "ller->size());",
          "new_text": null,
          "old_line_content": "  DominanceOrder domOrder(&Caller->front(), DT, Caller->size());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": "getNext",
          "new_api": null,
          "old_text": "mOrder.getNext()) ",
          "new_text": null,
          "old_line_content": "  while (SILBasicBlock *block = domOrder.getNext()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": "find",
          "new_api": null,
          "old_text": "ToWeightMap.find(block);\n",
          "new_text": null,
          "old_line_content": "    auto bbIt = BBToWeightMap.find(block);",
          "new_line_content": "static void",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": "end",
          "new_api": null,
          "old_text": "ToWeightMap.end() &",
          "new_text": null,
          "old_line_content": "    assert(bbIt != BBToWeightMap.end() && \"Expected to find block in map\");",
          "new_line_content": "calculateBBWeights(SILFunction *Caller, DominanceInfo *DT,",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": "getSecond",
          "new_api": null,
          "old_text": "It->getSecond();\n",
          "new_text": null,
          "old_line_content": "    auto bbCount = bbIt->getSecond();",
          "new_line_content": "                   llvm::DenseMap<SILBasicBlock *, uint64_t> &BBToWeightMap) {",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": "ntainsWeight",
          "new_api": null,
          "old_text": "ntainsWeight(termInst)) ",
          "new_text": null,
          "old_line_content": "    if (containsWeight(termInst)) {",
          "new_line_content": "  if (!entryCount) {",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": "getSuccessors",
          "new_api": null,
          "old_text": "rmInst->getSuccessors()) ",
          "new_text": null,
          "old_line_content": "      for (auto &succ : termInst->getSuccessors()) {",
          "new_line_content": "  // Add all blocks to BBToWeightMap without count 0",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": "getBB",
          "new_api": null,
          "old_text": "cc.getBB();\n",
          "new_text": null,
          "old_line_content": "        auto *currBB = succ.getBB();",
          "new_line_content": "  for (auto &block : *Caller) {",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": "end",
          "new_api": null,
          "old_text": "ToWeightMap.end() &",
          "new_text": null,
          "old_line_content": "        assert(BBToWeightMap.find(currBB) != BBToWeightMap.end() &&",
          "new_line_content": "    BBToWeightMap[&block] = 0;",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": "getBB",
          "new_api": null,
          "old_text": "cc.getBB();\n",
          "new_text": null,
          "old_line_content": "            auto *currBB = succ.getBB();",
          "new_line_content": "               \"Expected to find block in map\");",
          "content_same": false
        },
        {
          "line": 841,
          "old_api": "size",
          "new_api": null,
          "old_text": "rmInst->getSuccessors().size();\n",
          "new_text": null,
          "old_line_content": "        auto numOfSucc = termInst->getSuccessors().size();",
          "new_line_content": "        BBToWeightMap[currBB] += currCountVal;",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": "sert",
          "new_api": null,
          "old_text": "sert(numOfSucc > 0 && \"Expected successors > 0\");\n",
          "new_text": null,
          "old_line_content": "        assert(numOfSucc > 0 && \"Expected successors > 0\");",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 844,
          "old_api": "dToBBCounts",
          "new_api": null,
          "old_text": "dToBBCounts(BBToWeightMap, numToAdd, termInst);\n",
          "new_text": null,
          "old_line_content": "        addToBBCounts(BBToWeightMap, numToAdd, termInst);",
          "new_line_content": "        // inaccurate profile - fill in the gaps for BBs without a count:",
          "content_same": false
        },
        {
          "line": 854,
          "old_api": "dToBBCounts",
          "new_api": null,
          "old_text": "dToBBCounts(BBToWeightMap, numToAdd, termInst);\n",
          "new_text": null,
          "old_line_content": "      addToBBCounts(BBToWeightMap, numToAdd, termInst);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": "get",
          "new_api": null,
          "old_text": "->get(Caller);\n",
          "new_text": null,
          "old_line_content": "  DominanceInfo *DT = DA->get(Caller);",
          "new_line_content": "      // Fill counters speculatively",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": "tSPA",
          "new_api": null,
          "old_text": "tSPA(Caller, LI);\n",
          "new_text": null,
          "old_line_content": "  ShortestPathAnalysis *SPA = getSPA(Caller, LI);",
          "new_line_content": "      auto numToAdd = bbCount / numOfSucc;",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": "dWeightCorrection",
          "new_api": null,
          "old_text": "dWeightCorrection(FAS, WeightCorrections);\n",
          "new_text": null,
          "old_line_content": "    addWeightCorrection(FAS, WeightCorrections);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": "tEligibleFunction",
          "new_api": null,
          "old_text": "tEligibleFunction(FAS, WhatToInline)) ",
          "new_text": null,
          "old_line_content": "    if (SILFunction *Callee = getEligibleFunction(FAS, WhatToInline)) {",
          "new_line_content": "    SILFunction *Caller, SmallVectorImpl<FullApplySite> &Applies) {",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": "tSPA",
          "new_api": null,
          "old_text": "tSPA(Callee, CalleeLI);\n",
          "new_text": null,
          "old_line_content": "      ShortestPathAnalysis *CalleeSPA = getSPA(Callee, CalleeLI);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": "isValid",
          "new_api": null,
          "old_text": "lleeSPA->isValid()) ",
          "new_text": null,
          "old_line_content": "      if (!CalleeSPA->isValid()) {",
          "new_line_content": "  llvm::DenseMap<FullApplySite, int> WeightCorrections;",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": "analyze",
          "new_api": null,
          "old_text": "lleeSPA->analyze(CBI, [](FullApplySite FAS) {\n          // We don't compute SPA for another call-level. Functions called from\n          // the callee are assumed to have DefaultApplyLength.\n          return DefaultApplyLength;\n        });\n",
          "new_text": null,
          "old_line_content": "        CalleeSPA->analyze(CBI, [](FullApplySite FAS) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": "front",
          "new_api": null,
          "old_text": "llee->front(), ",
          "new_text": null,
          "old_line_content": "      int CalleeLength = CalleeSPA->getScopeLength(&Callee->front(), 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": "dump",
          "new_api": null,
          "old_text": "A->dump();\n",
          "new_text": null,
          "old_line_content": "    SPA->dump();",
          "new_line_content": "          return DefaultApplyLength;",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": "size",
          "new_api": null,
          "old_text": "ller->size());",
          "new_text": null,
          "old_line_content": "  DominanceOrder domOrder(&Caller->front(), DT, Caller->size());",
          "new_line_content": "      if (CalleeLength >= ShortestPathAnalysis::InitialDist)",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": "size",
          "new_api": null,
          "old_text": "ller->size();\n",
          "new_text": null,
          "old_line_content": "  int NumCallerBlocks = (int)Caller->size();",
          "new_line_content": "        return DefaultApplyLength;",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": "lculateBBWeights",
          "new_api": null,
          "old_text": "lculateBBWeights(Caller, DT, BBToWeightMap);\n",
          "new_text": null,
          "old_line_content": "  calculateBBWeights(Caller, DT, BBToWeightMap);",
          "new_line_content": "    // Some unknown function.",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": "getNext",
          "new_api": null,
          "old_text": "mOrder.getNext()) ",
          "new_text": null,
          "old_line_content": "  while (SILBasicBlock *block = domOrder.getNext()) {",
          "new_line_content": "  if (PrintShortestPathInfo) {",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": "end",
          "new_api": null,
          "old_text": "ock->end(); ",
          "new_text": null,
          "old_line_content": "    for (auto I = block->begin(), E = block->end(); I != E; ++I) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 918,
          "old_api": "trackInst",
          "new_api": null,
          "old_text": "nstTracker.trackInst(&*I);\n",
          "new_text": null,
          "old_line_content": "      constTracker.trackInst(&*I);",
          "new_line_content": "  ConstantTracker constTracker(Caller);",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": "getSubstitutionMap",
          "new_api": null,
          "old_text": ".getSubstitutionMap();\n",
          "new_text": null,
          "old_line_content": "  SubstitutionMap CalleeSubstMap = AI.getSubstitutionMap();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 412,
          "old_api": "updateBenefit",
          "new_api": null,
          "old_text": "llerWeight.updateBenefit(Benefit, BaseBenefit);\n",
          "new_text": null,
          "old_line_content": "  CallerWeight.updateBenefit(Benefit, BaseBenefit);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": "tEligibleFunction",
          "new_api": null,
          "old_text": "tEligibleFunction(AI, WhatToInline);\n",
          "new_text": null,
          "old_line_content": "      auto *Callee = getEligibleFunction(AI, WhatToInline);",
          "new_line_content": "  // Go through all instructions and find candidates for inlining.",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": "getNext",
          "new_api": null,
          "old_text": "mOrder.getNext()) ",
          "new_text": null,
          "old_line_content": "  while (SILBasicBlock *block = domOrder.getNext()) {",
          "new_line_content": "  // benefits.",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": "size",
          "new_api": null,
          "old_text": "llee->size();\n",
          "new_text": null,
          "old_line_content": "          NumCallerBlocks += Callee->size();",
          "new_line_content": "    Weight BlockWeight;",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "plies.push_back(AI);\n",
          "new_text": null,
          "old_line_content": "          Applies.push_back(AI);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": "trackInst",
          "new_api": null,
          "old_text": "nstTracker.trackInst(&I);\n",
          "new_text": null,
          "old_line_content": "      constTracker.trackInst(&I);",
          "new_line_content": "    for (SILInstruction &I : *block) {",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": "structionInlineCost",
          "new_api": null,
          "old_text": "structionInlineCost(I);\n",
          "new_text": null,
          "old_line_content": "      CalleeCost += (int)instructionInlineCost(I);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": "llApplySite::isa(&I))",
          "new_api": null,
          "old_text": "llApplySite::isa(&I)) ",
          "new_text": null,
          "old_line_content": "      if (FullApplySite FAI = FullApplySite::isa(&I)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "I.getCallee());",
          "new_text": null,
          "old_line_content": "        SILInstruction *def = constTracker.getDefInCaller(FAI.getCallee());",
          "new_line_content": "        // threshold, because inlining will (probably) eliminate the closure.",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "I.getCallee());",
          "new_text": null,
          "old_line_content": "          def = dyn_cast_or_null<SingleValueInstruction>(FAI.getCallee());",
          "new_line_content": "        if (!def)",
          "content_same": false
        },
        {
          "line": 948,
          "old_api": "lookup",
          "new_api": null,
          "old_text": "ightCorrections.lookup(AI));",
          "new_text": null,
          "old_line_content": "        Weight W(BlockWeight, WeightCorrections.lookup(AI));",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 950,
          "old_api": "cideInWarmBlock",
          "new_api": null,
          "old_text": "cideInWarmBlock(AI, W, constTracker, NumCallerBlocks,\n                              BBToWeightMap))\n",
          "new_text": null,
          "old_line_content": "        if (decideInWarmBlock(AI, W, constTracker, NumCallerBlocks,",
          "new_line_content": "        // Next make sure that we do not have more blocks than our overall",
          "content_same": false
        },
        {
          "line": 439,
          "old_api": "getSubstitutionMap",
          "new_api": null,
          "old_text": "I.getSubstitutionMap();\n",
          "new_text": null,
          "old_line_content": "        auto Subs = FAI.getSubstitutionMap();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "itialCandidates.push_back(AI);\n",
          "new_text": null,
          "old_line_content": "          InitialCandidates.push_back(AI);",
          "new_line_content": "        // will ensure that any further non inline always functions are skipped,",
          "content_same": false
        },
        {
          "line": 442,
          "old_api": "hasAnySubstitutableParams",
          "new_api": null,
          "old_text": "bs.hasAnySubstitutableParams())\n",
          "new_text": null,
          "old_line_content": "        if (!EnableSILInliningOfGenerics || !Subs.hasAnySubstitutableParams())",
          "new_line_content": "        // Bail if it is not a generic call or inlining of generics is forbidden.",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": "pushChildrenIf",
          "new_api": null,
          "old_text": "mOrder.pushChildrenIf(block, [&] (SILBasicBlock *child) {\n      if (CBI.isSlowPath(block, child)) {\n        // Handle cold blocks separately.\n        visitColdBlocks(InitialCandidates, child, DT);\n        return false;\n      }\n      return true;\n    });\n",
          "new_text": null,
          "old_line_content": "    domOrder.pushChildrenIf(block, [&] (SILBasicBlock *child) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 445,
          "old_api": "a<ClassMethodInst>(def) &",
          "new_api": null,
          "old_text": "a<ClassMethodInst>(def) &",
          "new_text": null,
          "old_line_content": "        if (!isa<FunctionRefInst>(def) && !isa<ClassMethodInst>(def) &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": "isSlowPath",
          "new_api": null,
          "old_text": "I.isSlowPath(block, child)) ",
          "new_text": null,
          "old_line_content": "      if (CBI.isSlowPath(block, child)) {",
          "new_line_content": "        // Otherwise, calculate our block weights and determine if we want to",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": "subst",
          "new_api": null,
          "old_text": "bs.subst(CalleeSubstMap);\n",
          "new_text": null,
          "old_line_content": "        auto SubMap = Subs.subst(CalleeSubstMap);",
          "new_line_content": "        // inlining.",
          "content_same": false
        },
        {
          "line": 969,
          "old_api": "getReferencedFunctionOrNull",
          "new_api": null,
          "old_text": ".getReferencedFunctionOrNull();\n",
          "new_text": null,
          "old_line_content": "    SILFunction *Callee = AI.getReferencedFunctionOrNull();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": "a<WitnessMethodInst>(def) |",
          "new_api": null,
          "old_text": "a<WitnessMethodInst>(def) |",
          "new_text": null,
          "old_line_content": "        if (isa<ClassMethodInst>(def) || isa<WitnessMethodInst>(def) ||",
          "new_line_content": "        // Check if the call can be devirtualized.",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": "sert",
          "new_api": null,
          "old_text": "sert(Callee && \"apply_inst does not have a direct callee anymore\");\n",
          "new_text": null,
          "old_line_content": "    assert(Callee && \"apply_inst does not have a direct callee anymore\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 461,
          "old_api": "nDevirtualizeApply",
          "new_api": null,
          "old_text": "nDevirtualizeApply(FAI, nullptr)) ",
          "new_text": null,
          "old_line_content": "          if (canDevirtualizeApply(FAI, nullptr)) {",
          "new_line_content": "          // TODO: Take AI.getSubstitutions() into account.",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": "getInstruction",
          "new_api": null,
          "old_text": "I.getInstruction()->dumpInContext());",
          "new_text": null,
          "old_line_content": "                       FAI.getInstruction()->dumpInContext());",
          "new_line_content": "                                       \"after inlining for the call:\\n\";",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": "getReferencedFunctionOrNull",
          "new_api": null,
          "old_text": ".getReferencedFunctionOrNull();\n",
          "new_text": null,
          "old_line_content": "    SILFunction *Callee = AI.getReferencedFunctionOrNull();",
          "new_line_content": "      return true;",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "sert",
          "new_api": null,
          "old_text": "sert(Callee && \"apply_inst does not have a direct callee anymore\");\n",
          "new_text": null,
          "old_line_content": "    assert(Callee && \"apply_inst does not have a direct callee anymore\");",
          "new_line_content": "    });",
          "content_same": false
        },
        {
          "line": 470,
          "old_api": "a<FunctionRefInst>(def))",
          "new_api": null,
          "old_text": "a<FunctionRefInst>(def)) ",
          "new_text": null,
          "old_line_content": "        if (isa<FunctionRefInst>(def)) {",
          "new_line_content": "        // Check if a generic specialization would be possible.",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "plies.push_back(AI);\n",
          "new_text": null,
          "old_line_content": "      Applies.push_back(AI);",
          "new_line_content": "  llvm::DenseMap<SILFunction *, unsigned> CalleeCount;",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": "vm::dbgs() <",
          "new_api": null,
          "old_text": "vm::dbgs() <",
          "new_text": null,
          "old_line_content": "          LLVM_DEBUG(llvm::dbgs() << \"Generic specialization will be possible \"",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": "getInstruction",
          "new_api": null,
          "old_text": "I.getInstruction()->dumpInContext());",
          "new_text": null,
          "old_line_content": "                     FAI.getInstruction()->dumpInContext());",
          "new_line_content": "                                     \"after inlining for the call:\\n\";",
          "content_same": false
        },
        {
          "line": 479,
          "old_api": "n_cast<LoadInst>(&I))",
          "new_api": null,
          "old_text": "n_cast<LoadInst>(&I)) ",
          "new_text": null,
          "old_line_content": "      } else if (auto *LI = dyn_cast<LoadInst>(&I)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": "shouldOptimize",
          "new_api": null,
          "old_text": "ller->shouldOptimize())\n",
          "new_text": null,
          "old_line_content": "  if (!Caller->shouldOptimize())",
          "new_line_content": "  for (auto AI : InitialCandidates) {",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": "getOperand",
          "new_api": null,
          "old_text": "->getOperand()))",
          "new_text": null,
          "old_line_content": "        if (constTracker.isStackAddrInCaller(LI->getOperand()))",
          "new_line_content": "        // might be optimized away if inlined.",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": "llectAppliesToInline",
          "new_api": null,
          "old_text": "llectAppliesToInline(Caller, AppliesToInline);\n",
          "new_text": null,
          "old_line_content": "  collectAppliesToInline(Caller, AppliesToInline);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": "getDest",
          "new_api": null,
          "old_text": "->getDest()))",
          "new_text": null,
          "old_line_content": "        if (constTracker.isStackAddrInCaller(SI->getDest()))",
          "new_line_content": "        // might be optimized away if inlined.",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": "empty",
          "new_api": null,
          "old_text": "pliesToInline.empty())\n",
          "new_text": null,
          "old_line_content": "  if (AppliesToInline.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": "updateBenefit",
          "new_api": null,
          "old_text": "ockW.updateBenefit(Benefit, RefCountBenefit);\n",
          "new_text": null,
          "old_line_content": "            BlockW.updateBenefit(Benefit, RefCountBenefit);",
          "new_line_content": "              SILArgumentConvention::Direct_Guaranteed) {",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": "n_cast<BuiltinInst>(&I))",
          "new_api": null,
          "old_text": "n_cast<BuiltinInst>(&I)) ",
          "new_text": null,
          "old_line_content": "      } else if (auto *BI = dyn_cast<BuiltinInst>(&I)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1009,
          "old_api": "vm::reverse(AppliesToInline))",
          "new_api": null,
          "old_text": "vm::reverse(AppliesToInline)) ",
          "new_text": null,
          "old_line_content": "  for (auto AI : llvm::reverse(AppliesToInline)) {",
          "new_line_content": "  // First step: collect all the functions we want to inline.  We",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": "getReferencedFunctionOrNull",
          "new_api": null,
          "old_text": ".getReferencedFunctionOrNull();\n",
          "new_text": null,
          "old_line_content": "    SILFunction *Callee = AI.getReferencedFunctionOrNull();",
          "new_line_content": "  // don't change anything yet so that the dominator information",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": "sert",
          "new_api": null,
          "old_text": "sert(Callee && \"apply_inst does not have a direct callee anymore\");\n",
          "new_text": null,
          "old_line_content": "    assert(Callee && \"apply_inst does not have a direct callee anymore\");",
          "new_line_content": "  // remains valid.",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": "getSource",
          "new_api": null,
          "old_text": "I->getSource());",
          "new_text": null,
          "old_line_content": "          auto storage = AccessStorage::compute(BAI->getSource());",
          "new_line_content": "          // access enforcement optimizations",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": "hasOwnership",
          "new_api": null,
          "old_text": "ller->hasOwnership()) ",
          "new_text": null,
          "old_line_content": "    if (!Callee->hasOwnership() && Caller->hasOwnership()) {",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 63,
      "total_additions": 166,
      "total_deletions": 160,
      "total_api_changes": 389
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 15,
        "api_related_lines": 389,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          593,
          521,
          525,
          397
        ]
      }
    },
    "api_calls_before": 384,
    "api_calls_after": 391,
    "diff_info": {
      "added_lines": 15,
      "removed_lines": 0,
      "total_diff_lines": 41
    }
  }
}