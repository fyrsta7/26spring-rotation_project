{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/d69b6a059494dafc3ce917fa4f34959f2cf05589",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/d69b6a059494dafc3ce917fa4f34959f2cf05589/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/d69b6a059494dafc3ce917fa4f34959f2cf05589/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/d69b6a059494dafc3ce917fa4f34959f2cf05589/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 496,
          "old_api": "push_back",
          "new_api": "isOperator",
          "old_text": "favoredChoices.push_back({choice, score})",
          "new_text": "decl->isOperator()",
          "old_line_content": "            favoredChoices.push_back({choice, score});",
          "new_line_content": "            if (decl->isOperator() &&",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": "std::max(bestScore, score)",
          "new_api": "isArithmeticOperator",
          "old_text": "std::max(bestScore, score)",
          "new_text": "decl->getBaseIdentifier().isArithmeticOperator()",
          "old_line_content": "            bestScore = std::max(bestScore, score);",
          "new_line_content": "                decl->getBaseIdentifier().isArithmeticOperator() &&",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": "getCurrentIndent",
          "new_api": "getResult",
          "old_text": "cs.solverState->getCurrentIndent()",
          "new_text": "overloadType->getResult()",
          "old_line_content": "      llvm::errs().indent(cs.solverState->getCurrentIndent())",
          "new_line_content": "              auto resultTy = overloadType->getResult();",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": "getNestedConstraints",
          "new_api": "getParams",
          "old_text": "disjunction->getNestedConstraints()[0]->getFirstType()->getString(\n                 PO)",
          "new_text": "overloadType->getParams()",
          "old_line_content": "          << disjunction->getNestedConstraints()[0]->getFirstType()->getString(",
          "new_line_content": "                  llvm::all_of(overloadType->getParams(),",
          "content_same": false
        },
        {
          "line": 525,
          "old_api": "isDebugMode",
          "new_api": "getNestedConstraints",
          "old_text": "cs.isDebugMode()",
          "new_text": "disjunction->getNestedConstraints()[0]->getFirstType()->getString(\n                 PO)",
          "old_line_content": "  if (cs.isDebugMode() && bestOverallScore > 0) {",
          "new_line_content": "          << disjunction->getNestedConstraints()[0]->getFirstType()->getString(",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": "push_back",
          "new_api": "getLogger",
          "old_text": "favorings[entry.first].push_back(choice)",
          "new_text": "getLogger(/*extraIndent=*/6)",
          "old_line_content": "      favorings[entry.first].push_back(choice);",
          "new_line_content": "        auto &log = getLogger(/*extraIndent=*/6);",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": "getConstraintGraph",
          "new_api": "empty",
          "old_text": "cs.getConstraintGraph().gatherConstraints(\n        typeVar, ConstraintGraph::GatheringKind::EquivalenceClass,\n        [](Constraint *constraint) {\n          return constraint->getKind() == ConstraintKind::Conversion;\n        })",
          "new_text": "choices.empty()",
          "old_line_content": "    auto constraints = cs.getConstraintGraph().gatherConstraints(",
          "new_line_content": "    assert(!choices.empty());",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": "size",
          "new_api": "collectDisjunctions",
          "old_text": "favorings[second].size()",
          "new_text": "collectDisjunctions(disjunctions)",
          "old_line_content": "        unsigned secondFavored = favorings[second].size();",
          "new_line_content": "  collectDisjunctions(disjunctions);",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": "end",
          "new_api": "begin",
          "old_text": "disjunctions.end()",
          "new_text": "std::min_element(\n      disjunctions.begin(), disjunctions.end(),\n      [&](Constraint *first, Constraint *second) -> bool {\n        unsigned firstActive = first->countActiveNestedConstraints();\n        unsigned secondActive = second->countActiveNestedConstraints();\n        unsigned firstFavored = favorings[first].size();\n        unsigned secondFavored = favorings[second].size();\n\n        if (firstFavored == secondFavored) {\n          if (firstActive != secondActive)\n            return firstActive < secondActive;\n        }\n\n        firstFavored = firstFavored ? firstFavored : firstActive;\n        secondFavored = secondFavored ? secondFavored : secondActive;\n        return firstFavored < secondFavored;\n      })",
          "old_line_content": "  if (bestDisjunction != disjunctions.end())",
          "new_line_content": "  auto bestDisjunction = std::min_element(",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": "std::make_pair(*bestDisjunction, favorings[*bestDisjunction])",
          "new_api": "end",
          "old_text": "std::make_pair(*bestDisjunction, favorings[*bestDisjunction])",
          "new_text": "disjunctions.end()",
          "old_line_content": "    return std::make_pair(*bestDisjunction, favorings[*bestDisjunction]);",
          "new_line_content": "      disjunctions.begin(), disjunctions.end(),",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 640,
          "old_api": null,
          "new_api": "getConstraintGraph",
          "old_text": null,
          "new_text": "cs.getConstraintGraph().gatherConstraints(\n        typeVar, ConstraintGraph::GatheringKind::EquivalenceClass,\n        [](Constraint *constraint) {\n          return constraint->getKind() == ConstraintKind::Conversion;\n        })",
          "old_line_content": "",
          "new_line_content": "    auto constraints = cs.getConstraintGraph().gatherConstraints(",
          "content_same": false
        },
        {
          "line": 514,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "favoredChoices.push_back({choice, score})",
          "old_line_content": "      continue;",
          "new_line_content": "            favoredChoices.push_back({choice, score});",
          "content_same": false
        },
        {
          "line": 515,
          "old_api": null,
          "new_api": "std::max(bestScore, score)",
          "old_text": null,
          "new_text": "std::max(bestScore, score)",
          "old_line_content": "",
          "new_line_content": "            bestScore = std::max(bestScore, score);",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": null,
          "new_api": "getKind",
          "old_text": null,
          "new_text": "constraint->getKind()",
          "old_line_content": "  SmallVector<Constraint *, 4> disjunctions;",
          "new_line_content": "          return constraint->getKind() == ConstraintKind::Conversion;",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": null,
          "new_api": "isDebugMode",
          "old_text": null,
          "new_text": "cs.isDebugMode()",
          "old_line_content": "    for (const auto &choice : favoredChoices) {",
          "new_line_content": "    if (cs.isDebugMode()) {",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": null,
          "new_api": "getSecondType",
          "old_text": null,
          "new_text": "constraint->getSecondType()",
          "old_line_content": "    return std::nullopt;",
          "new_line_content": "      if (typeVar == getAsTypeVar(constraint->getSecondType()))",
          "content_same": false
        },
        {
          "line": 523,
          "old_api": null,
          "new_api": "getCurrentIndent",
          "old_text": null,
          "new_text": "cs.solverState->getCurrentIndent()",
          "old_line_content": "  }",
          "new_line_content": "      llvm::errs().indent(cs.solverState->getCurrentIndent())",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": null,
          "new_api": "std::max(bestOverallScore, bestScore)",
          "old_text": null,
          "new_text": "std::max(bestOverallScore, bestScore)",
          "old_line_content": "    {",
          "new_line_content": "    bestOverallScore = std::max(bestOverallScore, bestScore);",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "disjunctions.empty()",
          "old_line_content": "",
          "new_line_content": "  if (disjunctions.empty())",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "favoredChoicesPerDisjunction[disjunction].push_back(choice.first)",
          "old_line_content": "          disjunctions,",
          "new_line_content": "        favoredChoicesPerDisjunction[disjunction].push_back(choice.first);",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": null,
          "new_api": "selectBestBindingDisjunction",
          "old_text": null,
          "new_text": "selectBestBindingDisjunction(*this, disjunctions)",
          "old_line_content": "            return firstActive < secondActive;",
          "new_line_content": "  if (auto *disjunction = selectBestBindingDisjunction(*this, disjunctions))",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": null,
          "new_api": "llvm::TinyPtrVector<Constraint *>()",
          "old_text": null,
          "new_text": "llvm::TinyPtrVector<Constraint *>()",
          "old_line_content": "        }",
          "new_line_content": "    return std::make_pair(disjunction, llvm::TinyPtrVector<Constraint *>());",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": null,
          "new_api": "isDebugMode",
          "old_text": null,
          "new_text": "cs.isDebugMode()",
          "old_line_content": "                       ->getString(PO);",
          "new_line_content": "  if (cs.isDebugMode() && bestOverallScore > 0) {",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": null,
          "new_api": "determineBestChoicesInContext",
          "old_text": null,
          "new_text": "determineBestChoicesInContext(*this, disjunctions, favorings)",
          "old_line_content": "        secondFavored = secondFavored ? secondFavored : secondActive;",
          "new_line_content": "  determineBestChoicesInContext(*this, disjunctions, favorings);",
          "content_same": false
        },
        {
          "line": 548,
          "old_api": null,
          "new_api": "getCurrentIndent",
          "old_text": null,
          "new_text": "cs.solverState->getCurrentIndent()",
          "old_line_content": "    }",
          "new_line_content": "      return llvm::errs().indent(cs.solverState->getCurrentIndent() +",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": null,
          "new_api": "countActiveNestedConstraints",
          "old_text": null,
          "new_text": "first->countActiveNestedConstraints()",
          "old_line_content": "  return std::nullopt;",
          "new_line_content": "        unsigned firstActive = first->countActiveNestedConstraints();",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": null,
          "new_api": "countActiveNestedConstraints",
          "old_text": null,
          "new_text": "second->countActiveNestedConstraints()",
          "old_line_content": "}",
          "new_line_content": "        unsigned secondActive = second->countActiveNestedConstraints();",
          "content_same": false
        },
        {
          "line": 680,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "favorings[first].size()",
          "old_line_content": "",
          "new_line_content": "        unsigned firstFavored = favorings[first].size();",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": null,
          "new_api": "getLogger",
          "old_text": null,
          "new_text": "getLogger()",
          "old_line_content": "    for (const auto &entry : disjunctionScores) {",
          "new_line_content": "      auto &log = getLogger();",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "favorings[second].size()",
          "old_line_content": "",
          "new_line_content": "        unsigned secondFavored = favorings[second].size();",
          "content_same": false
        },
        {
          "line": 559,
          "old_api": null,
          "new_api": "getNestedConstraints",
          "old_text": null,
          "new_text": "disjunction->getNestedConstraints()[0]\n                       ->getFirstType()\n                       ->getString(PO)",
          "old_line_content": "",
          "new_line_content": "            log << disjunction->getNestedConstraints()[0]",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "disjunctions.end()",
          "old_line_content": "",
          "new_line_content": "  if (bestDisjunction != disjunctions.end())",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": null,
          "new_api": "std::make_pair(*bestDisjunction, favorings[*bestDisjunction])",
          "old_text": null,
          "new_text": "std::make_pair(*bestDisjunction, favorings[*bestDisjunction])",
          "old_line_content": "",
          "new_line_content": "    return std::make_pair(*bestDisjunction, favorings[*bestDisjunction]);",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": null,
          "new_api": "getLogger",
          "old_text": null,
          "new_text": "getLogger(/*extraIndent=*/4)",
          "old_line_content": "  }",
          "new_line_content": "      getLogger(/*extraIndent=*/4)",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": null,
          "new_api": "getNestedConstraints",
          "old_text": null,
          "new_text": "entry.first->getNestedConstraints()[0]->getFirstType()->getString(\n                 PO)",
          "old_line_content": "  for (auto &entry : disjunctionScores) {",
          "new_line_content": "          << entry.first->getNestedConstraints()[0]->getFirstType()->getString(",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": null,
          "new_api": "getASTContext",
          "old_text": null,
          "new_text": "cs.getASTContext()",
          "old_line_content": "",
          "new_line_content": "        choice->print(log, &cs.getASTContext().SourceMgr);",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": null,
          "new_api": "getLogger",
          "old_text": null,
          "new_text": "getLogger(/*extraIdent=*/4)",
          "old_line_content": "// Prefer disjunctions where the bound type variable is also the",
          "new_line_content": "      getLogger(/*extraIdent=*/4) << \"]\\n\";",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": null,
          "new_api": "getLogger",
          "old_text": null,
          "new_text": "getLogger()",
          "old_line_content": "// constraint system into multiple ones.",
          "new_line_content": "    getLogger() << \")\\n\";",
          "content_same": false
        },
        {
          "line": 597,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "favorings[entry.first].push_back(choice)",
          "old_line_content": "  auto getAsTypeVar = [&cs](Type type) {",
          "new_line_content": "      favorings[entry.first].push_back(choice);",
          "content_same": false
        },
        {
          "line": 612,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "disjunctions.empty()",
          "old_line_content": "    // have the same left-hand side.",
          "new_line_content": "  if (disjunctions.empty())",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": null,
          "new_api": "simplifyType",
          "old_text": null,
          "new_text": "cs.simplifyType(type)->getRValueType()->getAs<TypeVariableType>()",
          "old_line_content": "    if (!typeVar)",
          "new_line_content": "    return cs.simplifyType(type)->getRValueType()->getAs<TypeVariableType>();",
          "content_same": false
        },
        {
          "line": 621,
          "old_api": null,
          "new_api": "getNestedConstraints",
          "old_text": null,
          "new_text": "disjunction->getNestedConstraints()",
          "old_line_content": "",
          "new_line_content": "    auto choices = disjunction->getNestedConstraints();",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "choices.front()",
          "old_line_content": "        [](Constraint *constraint) {",
          "new_line_content": "    auto *choice = choices.front();",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": null,
          "new_api": "getNumParams",
          "old_text": null,
          "new_text": "overloadType->getNumParams()",
          "old_line_content": "          }",
          "new_line_content": "                overloadType->getNumParams() == 2) {",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": null,
          "new_api": "getFirstType",
          "old_text": null,
          "new_text": "choice->getFirstType()",
          "old_line_content": "",
          "new_line_content": "    auto *typeVar = getAsTypeVar(choice->getFirstType());",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": null,
          "new_api": "hasTypeParameter",
          "old_text": null,
          "new_text": "resultTy->hasTypeParameter()",
          "old_line_content": "          << \"<<< Disjunction \"",
          "new_line_content": "              if (!resultTy->hasTypeParameter() &&",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": null,
          "new_api": "getPlainType",
          "old_text": null,
          "new_text": "param.getPlainType()->isEqual(resultTy)",
          "old_line_content": "          << \" with score \" << bestScore << \"\\n\";",
          "new_line_content": "                                 return param.getPlainType()->isEqual(resultTy);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 516,
          "old_api": "std::max(bestOverallScore, bestScore)",
          "new_api": null,
          "old_text": "std::max(bestOverallScore, bestScore)",
          "new_text": null,
          "old_line_content": "    bestOverallScore = std::max(bestOverallScore, bestScore);",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": "collectDisjunctions",
          "new_api": null,
          "old_text": "collectDisjunctions(disjunctions)",
          "new_text": null,
          "old_line_content": "  collectDisjunctions(disjunctions);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": "empty",
          "new_api": null,
          "old_text": "disjunctions.empty()",
          "new_text": null,
          "old_line_content": "  if (disjunctions.empty())",
          "new_line_content": "    for (auto *constraint : constraints) {",
          "content_same": false
        },
        {
          "line": 521,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "favoredChoicesPerDisjunction[disjunction].push_back(choice.first)",
          "new_text": null,
          "old_line_content": "        favoredChoicesPerDisjunction[disjunction].push_back(choice.first);",
          "new_line_content": "      PO.PrintTypesForDebugging = true;",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": "selectBestBindingDisjunction",
          "new_api": null,
          "old_text": "selectBestBindingDisjunction(*this, disjunctions)",
          "new_text": null,
          "old_line_content": "  if (auto *disjunction = selectBestBindingDisjunction(*this, disjunctions))",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": "llvm::TinyPtrVector<Constraint *>()",
          "new_api": null,
          "old_text": "llvm::TinyPtrVector<Constraint *>()",
          "new_text": null,
          "old_line_content": "    return std::make_pair(disjunction, llvm::TinyPtrVector<Constraint *>());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": "determineBestChoicesInContext",
          "new_api": null,
          "old_text": "determineBestChoicesInContext(*this, disjunctions, favorings)",
          "new_text": null,
          "old_line_content": "  determineBestChoicesInContext(*this, disjunctions, favorings);",
          "new_line_content": "  // those. These ensure that we attempt to bind types earlier than",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": "begin",
          "new_api": null,
          "old_text": "std::min_element(\n      disjunctions.begin(), disjunctions.end(),\n      [&](Constraint *first, Constraint *second) -> bool {\n        unsigned firstActive = first->countActiveNestedConstraints();\n        unsigned secondActive = second->countActiveNestedConstraints();\n        unsigned firstFavored = favorings[first].size();\n        unsigned secondFavored = favorings[second].size();\n\n        if (firstFavored == secondFavored) {\n          if (firstActive != secondActive)\n            return firstActive < secondActive;\n        }\n\n        firstFavored = firstFavored ? firstFavored : firstActive;\n        secondFavored = secondFavored ? secondFavored : secondActive;\n        return firstFavored < secondFavored;\n      })",
          "new_text": null,
          "old_line_content": "  auto bestDisjunction = std::min_element(",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 530,
          "old_api": "getCurrentIndent",
          "new_api": null,
          "old_text": "cs.solverState->getCurrentIndent()",
          "new_text": null,
          "old_line_content": "      return llvm::errs().indent(cs.solverState->getCurrentIndent() +",
          "new_line_content": "    // No matching overload choices to favor.",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": "end",
          "new_api": null,
          "old_text": "disjunctions.end()",
          "new_text": null,
          "old_line_content": "      disjunctions.begin(), disjunctions.end(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 660,
          "old_api": "countActiveNestedConstraints",
          "new_api": null,
          "old_text": "first->countActiveNestedConstraints()",
          "new_text": null,
          "old_line_content": "        unsigned firstActive = first->countActiveNestedConstraints();",
          "new_line_content": "ConstraintSystem::selectDisjunction() {",
          "content_same": false
        },
        {
          "line": 661,
          "old_api": "countActiveNestedConstraints",
          "new_api": null,
          "old_text": "second->countActiveNestedConstraints()",
          "new_text": null,
          "old_line_content": "        unsigned secondActive = second->countActiveNestedConstraints();",
          "new_line_content": "  SmallVector<Constraint *, 4> disjunctions;",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": "size",
          "new_api": null,
          "old_text": "favorings[first].size()",
          "new_text": null,
          "old_line_content": "        unsigned firstFavored = favorings[first].size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 535,
          "old_api": "getLogger",
          "new_api": null,
          "old_text": "getLogger()",
          "new_text": null,
          "old_line_content": "      auto &log = getLogger();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": "getNestedConstraints",
          "new_api": null,
          "old_text": "interleave(\n          disjunctions,\n          [&](const auto *disjunction) {\n            log << disjunction->getNestedConstraints()[0]\n                       ->getFirstType()\n                       ->getString(PO);\n          },\n          [&]() { log << \", \"; })",
          "new_text": null,
          "old_line_content": "      interleave(",
          "new_line_content": "      if (choice.second == bestScore)",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": "getNestedConstraints",
          "new_api": null,
          "old_text": "disjunction->getNestedConstraints()[0]\n                       ->getFirstType()\n                       ->getString(PO)",
          "new_text": null,
          "old_line_content": "            log << disjunction->getNestedConstraints()[0]",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": "getLogger",
          "new_api": null,
          "old_text": "getLogger(/*extraIndent=*/4)",
          "new_text": null,
          "old_line_content": "    getLogger(/*extraIndent=*/4)",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": "getLogger",
          "new_api": null,
          "old_text": "getLogger(/*extraIndent=*/4)",
          "new_text": null,
          "old_line_content": "      getLogger(/*extraIndent=*/4)",
          "new_line_content": "      log << \"(Optimizing disjunctions: [\";",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": "getLogger",
          "new_api": null,
          "old_text": "getLogger(/*extraIndent=*/6)",
          "new_text": null,
          "old_line_content": "        auto &log = getLogger(/*extraIndent=*/6);",
          "new_line_content": "                       ->getString(PO);",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": "getASTContext",
          "new_api": null,
          "old_text": "cs.getASTContext()",
          "new_text": null,
          "old_line_content": "        choice->print(log, &cs.getASTContext().SourceMgr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": "getLogger",
          "new_api": null,
          "old_text": "getLogger()",
          "new_text": null,
          "old_line_content": "    getLogger() << \")\\n\";",
          "new_line_content": "    for (const auto &entry : disjunctionScores) {",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": "empty",
          "new_api": null,
          "old_text": "disjunctions.empty()",
          "new_text": null,
          "old_line_content": "  if (disjunctions.empty())",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": "simplifyType",
          "new_api": null,
          "old_text": "cs.simplifyType(type)->getRValueType()->getAs<TypeVariableType>()",
          "new_text": null,
          "old_line_content": "    return cs.simplifyType(type)->getRValueType()->getAs<TypeVariableType>();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": "getNestedConstraints",
          "new_api": null,
          "old_text": "disjunction->getNestedConstraints()",
          "new_text": null,
          "old_line_content": "    auto choices = disjunction->getNestedConstraints();",
          "new_line_content": "//",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": "empty",
          "new_api": null,
          "old_text": "choices.empty()",
          "new_text": null,
          "old_line_content": "    assert(!choices.empty());",
          "new_line_content": "// Prefer disjunctions where the bound type variable is also the",
          "content_same": false
        },
        {
          "line": 606,
          "old_api": "front",
          "new_api": null,
          "old_text": "choices.front()",
          "new_text": null,
          "old_line_content": "    auto *choice = choices.front();",
          "new_line_content": "// type that we're converting to can make it possible to split the",
          "content_same": false
        },
        {
          "line": 607,
          "old_api": "getKind",
          "new_api": null,
          "old_text": "choice->getKind()",
          "new_text": null,
          "old_line_content": "    if (choice->getKind() != ConstraintKind::Bind)",
          "new_line_content": "// constraint system into multiple ones.",
          "content_same": false
        },
        {
          "line": 615,
          "old_api": "getFirstType",
          "new_api": null,
          "old_text": "choice->getFirstType()",
          "new_text": null,
          "old_line_content": "    auto *typeVar = getAsTypeVar(choice->getFirstType());",
          "new_line_content": "  auto getAsTypeVar = [&cs](Type type) {",
          "content_same": false
        },
        {
          "line": 629,
          "old_api": "getSecondType",
          "new_api": null,
          "old_text": "constraint->getSecondType()",
          "new_text": null,
          "old_line_content": "      if (typeVar == getAsTypeVar(constraint->getSecondType()))",
          "new_line_content": "    // because all of choices (of bind overload set) should",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": "isDebugMode",
          "new_api": null,
          "old_text": "cs.isDebugMode()",
          "new_text": null,
          "old_line_content": "    if (cs.isDebugMode()) {",
          "new_line_content": "              //",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 10,
      "total_additions": 37,
      "total_deletions": 30,
      "total_api_changes": 77
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 18,
        "api_related_lines": 77,
        "non_api_lines": 10,
        "non_api_line_numbers": [
          512,
          513,
          499,
          500,
          502,
          503,
          504,
          508,
          510,
          511
        ]
      }
    },
    "api_calls_before": 212,
    "api_calls_after": 222,
    "diff_info": {
      "added_lines": 18,
      "removed_lines": 0,
      "total_diff_lines": 30
    }
  }
}