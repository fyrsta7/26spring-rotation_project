{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/1dc3e17f52edcd7b5cec47e29a7427f4d0d562cf",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/1dc3e17f52edcd7b5cec47e29a7427f4d0d562cf/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/1dc3e17f52edcd7b5cec47e29a7427f4d0d562cf/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/1dc3e17f52edcd7b5cec47e29a7427f4d0d562cf/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 627,
          "old_api": "advanceIfValidStartOfIdentifier",
          "new_api": "formToken",
          "old_text": "advanceIfValidStartOfIdentifier(CurPtr, BufferEnd)",
          "new_text": "formToken(Kind, TokStart)",
          "old_line_content": "  bool didStart = advanceIfValidStartOfIdentifier(CurPtr, BufferEnd);",
          "new_line_content": "  return formToken(Kind, TokStart);",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": "formToken",
          "new_api": "clang::isIdentifierBody(*tmpPtr)",
          "old_text": "formToken(tok::r_square_lit, TokStart)",
          "new_text": "clang::isIdentifierBody(*tmpPtr)",
          "old_line_content": "     return formToken(tok::r_square_lit, TokStart);",
          "new_line_content": "    } while (clang::isIdentifierBody(*tmpPtr));",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": "clang::isIdentifierBody(*tmpPtr)",
          "new_api": "Default",
          "old_text": "clang::isIdentifierBody(*tmpPtr)",
          "new_text": "  .Default(tok::pound)",
          "old_line_content": "    } while (clang::isIdentifierBody(*tmpPtr));",
          "new_line_content": "  .Default(tok::pound);",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": "isLeftBound",
          "new_api": "diagnose",
          "old_text": "isLeftBound(TokStart, ContentStart)",
          "new_text": "diagnose(TokStart, diag::lex_unary_equal)",
          "old_line_content": "  bool leftBound = isLeftBound(TokStart, ContentStart);",
          "new_line_content": "        auto d = diagnose(TokStart, diag::lex_unary_equal);",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": "formToken",
          "new_api": "fixItRemoveChars",
          "old_text": "formToken(tok::period, TokStart)",
          "new_text": "diagnose(TokStart, diag::extra_whitespace_period)\n          .fixItRemoveChars(getSourceLoc(CurPtr),\n                            getSourceLoc(AfterHorzWhitespace))",
          "old_line_content": "        return formToken(tok::period, TokStart);",
          "new_line_content": "        diagnose(TokStart, diag::extra_whitespace_period)",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": "isRightBound",
          "new_api": "formToken",
          "old_text": "isRightBound(AfterHorzWhitespace, leftBound, CodeCompletionPtr)",
          "new_text": "formToken(tok::period, TokStart)",
          "old_line_content": "      if (isRightBound(AfterHorzWhitespace, leftBound, CodeCompletionPtr) &&",
          "new_line_content": "        return formToken(tok::period, TokStart);",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": "fixItRemoveChars",
          "new_api": "formToken",
          "old_text": "diagnose(TokStart, diag::extra_whitespace_period)\n          .fixItRemoveChars(getSourceLoc(CurPtr),\n                            getSourceLoc(AfterHorzWhitespace))",
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "        diagnose(TokStart, diag::extra_whitespace_period)",
          "new_line_content": "      return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": "formToken",
          "new_api": "diagnose",
          "old_text": "formToken(tok::question_postfix, TokStart)",
          "new_text": "diagnose(TokStart, diag::lex_unexpected_block_comment_end)",
          "old_line_content": "        return formToken(tok::question_postfix, TokStart);",
          "new_line_content": "      diagnose(TokStart, diag::lex_unexpected_block_comment_end);",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": "formToken",
          "new_api": "find",
          "old_text": "formToken(tok::arrow, TokStart)",
          "new_text": "StringRef(TokStart, CurPtr-TokStart).find(\"*/\")",
          "old_line_content": "      return formToken(tok::arrow, TokStart);",
          "new_line_content": "    auto Pos = StringRef(TokStart, CurPtr-TokStart).find(\"*/\");",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": "find",
          "new_api": "formToken",
          "old_text": "StringRef(TokStart, CurPtr-TokStart).find(\"*/\")",
          "new_text": "formToken(leftBound ? tok::oper_binary_unspaced :\n                                 tok::oper_binary_spaced, TokStart)",
          "old_line_content": "    auto Pos = StringRef(TokStart, CurPtr-TokStart).find(\"*/\");",
          "new_line_content": "    return formToken(leftBound ? tok::oper_binary_unspaced :",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": "getSourceLoc",
          "new_api": "diagnose",
          "old_text": "getSourceLoc(CurPtr)",
          "new_text": "diagnose(tokStart, diag::expected_dollar_numeric)",
          "old_line_content": "        .fixItReplaceChars(getSourceLoc(tokStart), getSourceLoc(CurPtr), \"`$`\");",
          "new_line_content": "      diagnose(tokStart, diag::expected_dollar_numeric);",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": "formToken",
          "new_api": "assert",
          "old_text": "formToken(tok::dollarident, tokStart)",
          "new_text": "assert(*CurPtr == 'x' && \"not a hex literal\")",
          "old_line_content": "    return formToken(tok::dollarident, tokStart);",
          "new_line_content": "  assert(*CurPtr == 'x' && \"not a hex literal\");",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": "assert",
          "new_api": "StringRef",
          "old_text": "assert(*TokStart == '0' && \"not a hex literal\")",
          "new_text": "StringRef(loc, 1)",
          "old_line_content": "  assert(*TokStart == '0' && \"not a hex literal\");",
          "new_line_content": "    diagnose(loc, diag::lex_invalid_digit_in_int_literal, StringRef(loc, 1),",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": "StringRef",
          "new_api": "expected_hex_digit",
          "old_text": "StringRef(loc, 1)",
          "new_text": "expected_hex_digit(CurPtr)",
          "old_line_content": "    diagnose(loc, diag::lex_invalid_digit_in_int_literal, StringRef(loc, 1),",
          "new_line_content": "    return expected_hex_digit(CurPtr);",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "expected_digit",
          "new_api": "isHexDigit",
          "old_text": "expected_digit()",
          "new_text": "isHexDigit(*CurPtr)",
          "old_line_content": "    return expected_digit();",
          "new_line_content": "  while (isHexDigit(*CurPtr) || *CurPtr == '_')",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": "isHexDigit",
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": "isHexDigit(*CurPtr)",
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "  if (!isHexDigit(*CurPtr))",
          "new_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": "isHexDigit",
          "new_api": "formToken",
          "old_text": "isHexDigit(*CurPtr)",
          "new_text": "formToken(tok::integer_literal, TokStart)",
          "old_line_content": "  while (isHexDigit(*CurPtr) || *CurPtr == '_')",
          "new_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 974,
          "old_api": "formToken",
          "new_api": "assert",
          "old_text": "formToken(tok::integer_literal, TokStart)",
          "new_text": "assert(*CurPtr == 'p' || *CurPtr == 'P' && \"not at a hex float exponent?!\")",
          "old_line_content": "        return formToken(tok::integer_literal, TokStart);",
          "new_line_content": "  assert(*CurPtr == 'p' || *CurPtr == 'P' && \"not at a hex float exponent?!\");",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": "formToken",
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": "formToken(tok::integer_literal, TokStart)",
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "new_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": "StringRef",
          "new_api": "isDigit",
          "old_text": "StringRef(tmp, 1)",
          "new_text": "isDigit(*CurPtr)",
          "old_line_content": "      diagnose(tmp, diag::lex_invalid_digit_in_fp_exponent, StringRef(tmp, 1),",
          "new_line_content": "  while (isDigit(*CurPtr) || *CurPtr == '_')",
          "content_same": false
        },
        {
          "line": 1009,
          "old_api": "expected_digit",
          "new_api": "StringRef",
          "old_text": "expected_digit()",
          "new_text": "StringRef(tmp, 1)",
          "old_line_content": "    return expected_digit();",
          "new_line_content": "    diagnose(tmp, diag::lex_invalid_digit_in_fp_exponent, StringRef(tmp, 1),",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": "isDigit",
          "new_api": "StringRef",
          "old_text": "isDigit(*TokStart)",
          "new_text": "StringRef(loc, 1)",
          "old_line_content": "  assert((isDigit(*TokStart) || *TokStart == '.') && \"Unexpected start\");",
          "new_line_content": "    diagnose(loc, diag::lex_invalid_digit_in_int_literal, StringRef(loc, 1),",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": "isDigit",
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": "isDigit(*CurPtr)",
          "old_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "new_line_content": "  while (isDigit(*CurPtr) || *CurPtr == '_')",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": "isDigit",
          "new_api": "formToken",
          "old_text": "isDigit(*CurPtr)",
          "new_text": "formToken(tok::integer_literal, TokStart)",
          "old_line_content": "  while (isDigit(*CurPtr) || *CurPtr == '_')",
          "new_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 1094,
          "old_api": "is",
          "new_api": "expected_int_digit",
          "old_text": "NextToken.is(tok::period)",
          "new_text": "expected_int_digit(tmp, ExpectedDigitKind::Decimal)",
          "old_line_content": "    if (!isDigit(CurPtr[1]) || NextToken.is(tok::period))",
          "new_line_content": "        return expected_int_digit(tmp, ExpectedDigitKind::Decimal);",
          "content_same": false
        },
        {
          "line": 1129,
          "old_api": "StringRef",
          "new_api": "isDigit",
          "old_text": "StringRef(tmp, 1)",
          "new_text": "isDigit(*CurPtr)",
          "old_line_content": "        diagnose(tmp, diag::lex_invalid_digit_in_fp_exponent, StringRef(tmp, 1),",
          "new_line_content": "    while (isDigit(*CurPtr) || *CurPtr == '_')",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": "expected_digit",
          "new_api": "StringRef",
          "old_text": "expected_digit()",
          "new_text": "StringRef(tmp, 1)",
          "old_line_content": "      return expected_digit();",
          "new_line_content": "      diagnose(tmp, diag::lex_invalid_digit_in_fp_exponent, StringRef(tmp, 1),",
          "content_same": false
        },
        {
          "line": 1268,
          "old_api": "maybeConsumeNewlineEscape",
          "new_api": "isAlphanumeric",
          "old_text": "maybeConsumeNewlineEscape(CurPtr, 0)",
          "new_text": "isAlphanumeric(*CurPtr)",
          "old_line_content": "    if (MultilineString && maybeConsumeNewlineEscape(CurPtr, 0))",
          "new_line_content": "    if (isAlphanumeric(*CurPtr)) ++CurPtr;",
          "content_same": false
        },
        {
          "line": 1296,
          "old_api": "lexUnicodeEscape",
          "new_api": "EncodeToUTF8",
          "old_text": "lexUnicodeEscape(CurPtr, EmitDiagnostics ? this : nullptr)",
          "new_text": "EncodeToUTF8(CharValue, TempString)",
          "old_line_content": "    CharValue = lexUnicodeEscape(CurPtr, EmitDiagnostics ? this : nullptr);",
          "new_line_content": "  if (CharValue >= 0x80 && EncodeToUTF8(CharValue, TempString)) {",
          "content_same": false
        },
        {
          "line": 1371,
          "old_api": "inStringLiteral",
          "new_api": "back",
          "old_text": "inStringLiteral()",
          "new_text": "AllowNewline.back()",
          "old_line_content": "      if (!inStringLiteral()) {",
          "new_line_content": "      assert(AllowNewline.back() && \"other cases must be handled above\");",
          "content_same": false
        },
        {
          "line": 1374,
          "old_api": "push_back",
          "new_api": "pop_back",
          "old_text": "AllowNewline.push_back(isMultilineQuote)",
          "new_text": "OpenDelimiters.pop_back()",
          "old_line_content": "        AllowNewline.push_back(isMultilineQuote);",
          "new_line_content": "        OpenDelimiters.pop_back();",
          "content_same": false
        },
        {
          "line": 1382,
          "old_api": "pop_back",
          "new_api": "inStringLiteral",
          "old_text": "OpenDelimiters.pop_back()",
          "new_text": "inStringLiteral()",
          "old_line_content": "        OpenDelimiters.pop_back();",
          "new_line_content": "      if (inStringLiteral()) {",
          "content_same": false
        },
        {
          "line": 1390,
          "old_api": "inStringLiteral",
          "new_api": "back",
          "old_text": "inStringLiteral()",
          "new_text": "AllowNewline.back()",
          "old_line_content": "      if (inStringLiteral()) {",
          "new_line_content": "          if (AllowNewline.back())",
          "content_same": false
        },
        {
          "line": 1413,
          "old_api": "Lexer::getSourceLoc(CurPtr-1)",
          "new_api": "inStringLiteral",
          "old_text": "Lexer::getSourceLoc(CurPtr-1)",
          "new_text": "inStringLiteral()",
          "old_line_content": "          Diags->diagnose(Lexer::getSourceLoc(CurPtr-1),",
          "new_line_content": "      if (!inStringLiteral()) {",
          "content_same": false
        },
        {
          "line": 1421,
          "old_api": "inStringLiteral",
          "new_api": "back",
          "old_text": "inStringLiteral()",
          "new_text": "OpenDelimiters.back()",
          "old_line_content": "      if (!inStringLiteral()) {",
          "new_line_content": "      } else if (OpenDelimiters.back() == '(') {",
          "content_same": false
        },
        {
          "line": 1504,
          "old_api": "std::make_tuple(string, startLoc)",
          "new_api": "Lexer::getSourceLoc(start + 1)",
          "old_text": "std::make_tuple(string, startLoc)",
          "new_text": "Lexer::getSourceLoc(start + 1)",
          "old_line_content": "      return std::make_tuple(string, startLoc);",
          "new_line_content": "    auto loc = Lexer::getSourceLoc(start + 1);",
          "content_same": false
        },
        {
          "line": 1533,
          "old_api": "size",
          "new_api": "bytes_begin",
          "old_text": "ExpectedIndent.size()",
          "new_text": "Bytes.bytes_begin()",
          "old_line_content": "  if (MistakeOffset >= ExpectedIndent.size()) {",
          "new_line_content": "    return Lexer::getSourceLoc((const char *)Bytes.bytes_begin() + offset);",
          "content_same": false
        },
        {
          "line": 1557,
          "old_api": "classify",
          "new_api": "size",
          "old_text": "classify(Bytes[LineStarts[0] + MistakeOffset])",
          "new_text": "LineStarts.size()",
          "old_line_content": "                  classify(Bytes[LineStarts[0] + MistakeOffset]));",
          "new_line_content": "                             LineStarts.size() != 1);",
          "content_same": false
        },
        {
          "line": 1559,
          "old_api": "getAdvancedLoc",
          "new_api": "size",
          "old_text": "IndentLoc.getAdvancedLoc(MistakeOffset)",
          "new_text": "ActualIndent.size()",
          "old_line_content": "  Diags->diagnose(IndentLoc.getAdvancedLoc(MistakeOffset), ",
          "new_line_content": "  assert(MistakeOffset <= ActualIndent.size());",
          "content_same": false
        },
        {
          "line": 1561,
          "old_api": "classify",
          "new_api": "substr",
          "old_text": "classify(ExpectedIndent[MistakeOffset])",
          "new_text": "ActualIndent.substr(0, MistakeOffset)",
          "old_line_content": "                  classify(ExpectedIndent[MistakeOffset]));",
          "new_line_content": "         ActualIndent.substr(0, MistakeOffset));",
          "content_same": false
        },
        {
          "line": 1590,
          "old_api": "std::numeric_limits<size_t>::max()",
          "new_api": "find",
          "old_text": "std::numeric_limits<size_t>::max()",
          "new_text": "Bytes.find('\\n', pos + 1)",
          "old_line_content": "  size_t lastMistakeOffset = std::numeric_limits<size_t>::max();",
          "new_line_content": "  for (size_t pos = Bytes.find('\\n'); pos != StringRef::npos; pos = Bytes.find('\\n', pos + 1)) {",
          "content_same": false
        },
        {
          "line": 1600,
          "old_api": "substr",
          "new_api": "commonPrefixLength",
          "old_text": "Bytes.substr(nextpos)",
          "new_text": "commonPrefixLength(Indent, restOfBytes)",
          "old_line_content": "    auto restOfBytes = Bytes.substr(nextpos);",
          "new_line_content": "    auto errorOffset = commonPrefixLength(Indent, restOfBytes);",
          "content_same": false
        },
        {
          "line": 1628,
          "old_api": "substr",
          "new_api": "diagnoseInvalidMultilineIndents",
          "old_text": "commonIndentation.substr(0, prefixLength)",
          "new_text": "diagnoseInvalidMultilineIndents(Diags, Indent, IndentStartLoc, Bytes, \n                                  linesWithLastMistakeOffset, lastMistakeOffset, \n                                  commonIndentation)",
          "old_line_content": "      commonIndentation = commonIndentation.substr(0, prefixLength);",
          "new_line_content": "  diagnoseInvalidMultilineIndents(Diags, Indent, IndentStartLoc, Bytes, ",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": "Lexer::getSourceLoc(CurPtr)",
          "new_api": "skipToEndOfInterpolatedExpression",
          "old_text": "Lexer::getSourceLoc(CurPtr)",
          "new_text": "skipToEndOfInterpolatedExpression(CurPtr, BufferEnd,\n                                            Diags, MultilineString)",
          "old_line_content": "        .fixItInsert(Lexer::getSourceLoc(CurPtr), \"\\n\");",
          "new_line_content": "          skipToEndOfInterpolatedExpression(CurPtr, BufferEnd,",
          "content_same": false
        },
        {
          "line": 1686,
          "old_api": "lexCharacter",
          "new_api": "formToken",
          "old_text": "lexCharacter(CurPtr, *TokStart, true, MultilineString)",
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "    unsigned CharValue = lexCharacter(CurPtr, *TokStart, true, MultilineString);",
          "new_line_content": "        return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 1694,
          "old_api": "formToken",
          "new_api": "size",
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": "orig.size()",
          "old_line_content": "        return formToken(tok::unknown, TokStart);",
          "new_line_content": "        std::string str = orig.slice(1, orig.size() - 1).str();",
          "content_same": false
        },
        {
          "line": 1715,
          "old_api": "at",
          "new_api": "StringRef",
          "old_text": "str.at(pos)",
          "new_text": "StringRef(str)",
          "old_line_content": "          } else if (str.at(pos) == '\"') {",
          "new_line_content": "        replacement += StringRef(str);",
          "content_same": false
        },
        {
          "line": 1726,
          "old_api": "getSourceLoc",
          "new_api": "formToken",
          "old_text": "getSourceLoc(CurPtr)",
          "new_text": "formToken(tok::string_literal, TokStart, MultilineString)",
          "old_line_content": "          .fixItReplaceChars(getSourceLoc(TokStart), getSourceLoc(CurPtr),",
          "new_line_content": "          formToken(tok::string_literal, TokStart, MultilineString);",
          "content_same": false
        },
        {
          "line": 1826,
          "old_api": "formToken",
          "new_api": "size",
          "old_text": "formToken(tok::backtick, Quote)",
          "new_text": "terminator.size()",
          "old_line_content": "  formToken(tok::backtick, Quote);",
          "new_line_content": "  size_t termLen = terminator.size();",
          "content_same": false
        },
        {
          "line": 1839,
          "old_api": "find",
          "new_api": "substr",
          "old_text": "restOfBuffer.find(terminator)",
          "new_text": "restOfBuffer.substr(endPos + termLen)",
          "old_line_content": "  size_t endPos = restOfBuffer.find(terminator);",
          "new_line_content": "    restOfBuffer = restOfBuffer.substr(endPos + termLen);",
          "content_same": false
        },
        {
          "line": 1901,
          "old_api": "fixItReplaceChars",
          "new_api": "getSourceLoc",
          "old_text": "diagnose(CurPtr - 1, diag::lex_invalid_utf8)\n        .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \" \")",
          "new_text": "getSourceLoc(Tmp)",
          "old_line_content": "    diagnose(CurPtr - 1, diag::lex_invalid_utf8)",
          "new_line_content": "          .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \"\\\"\");",
          "content_same": false
        },
        {
          "line": 1935,
          "old_api": "fixItReplaceChars",
          "new_api": "EncodeToUTF8",
          "old_text": "diagnose(CurPtr - 1, diag::lex_invalid_character)\n      .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \" \")",
          "new_text": "EncodeToUTF8(Codepoint, ConfusedChar)",
          "old_line_content": "  diagnose(CurPtr - 1, diag::lex_invalid_character)",
          "new_line_content": "    EncodeToUTF8(Codepoint, ConfusedChar);",
          "content_same": false
        },
        {
          "line": 1940,
          "old_api": "confusable::tryConvertConfusableCharacterToASCII(Codepoint)",
          "new_api": "getSourceLoc",
          "old_text": "confusable::tryConvertConfusableCharacterToASCII(Codepoint)",
          "new_text": "getSourceLoc(Tmp)",
          "old_line_content": "           confusable::tryConvertConfusableCharacterToASCII(Codepoint))) {",
          "new_line_content": "        .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp),",
          "content_same": false
        },
        {
          "line": 2011,
          "old_api": "begin",
          "new_api": "push_back",
          "old_text": "Bytes.begin()",
          "new_text": "TempString.push_back('\\n')",
          "old_line_content": "        (IsFirstSegment && BytesPtr - 1 == Bytes.begin());",
          "new_line_content": "        TempString.push_back('\\n');",
          "content_same": false
        },
        {
          "line": 2038,
          "old_api": "push_back",
          "new_api": "maybeConsumeNewlineEscape",
          "old_text": "TempString.push_back('\\n')",
          "new_text": "maybeConsumeNewlineEscape(BytesPtr, -1)",
          "old_line_content": "    case 'n': TempString.push_back('\\n'); continue;",
          "new_line_content": "      if (maybeConsumeNewlineEscape(BytesPtr, -1)) {",
          "content_same": false
        },
        {
          "line": 2046,
          "old_api": "maybeConsumeNewlineEscape",
          "new_api": "llvm_unreachable",
          "old_text": "maybeConsumeNewlineEscape(BytesPtr, -1)",
          "new_text": "llvm_unreachable(\"string contained interpolated segments\")",
          "old_line_content": "      if (maybeConsumeNewlineEscape(BytesPtr, -1)) {",
          "new_line_content": "      llvm_unreachable(\"string contained interpolated segments\");",
          "content_same": false
        },
        {
          "line": 2070,
          "old_api": "EncodeToUTF8",
          "new_api": "clear",
          "old_text": "EncodeToUTF8(CharValue, TempString)",
          "new_text": "TempString.clear()",
          "old_line_content": "      EncodeToUTF8(CharValue, TempString);",
          "new_line_content": "    TempString.clear();",
          "content_same": false
        },
        {
          "line": 2090,
          "old_api": "getStringLiteralContent",
          "new_api": "getMultilineTrailingIndent",
          "old_text": "getStringLiteralContent(Str)",
          "new_text": "getMultilineTrailingIndent(Str, /*Diags=*/nullptr)",
          "old_line_content": "  StringRef Bytes = getStringLiteralContent(Str);",
          "new_line_content": "      std::get<0>(getMultilineTrailingIndent(Str, /*Diags=*/nullptr)).size();",
          "content_same": false
        },
        {
          "line": 2098,
          "old_api": "getMultilineTrailingIndent",
          "new_api": "end",
          "old_text": "getMultilineTrailingIndent(Str, /*Diags=*/nullptr)",
          "new_text": "Bytes.end()",
          "old_line_content": "      std::get<0>(getMultilineTrailingIndent(Str, /*Diags=*/nullptr)).size();",
          "new_line_content": "  while (BytesPtr != Bytes.end()) {",
          "content_same": false
        },
        {
          "line": 2117,
          "old_api": "push_back",
          "new_api": "getText",
          "old_text": "Segments.push_back(\n        StringSegment::getLiteral(getSourceLoc(SegmentStartPtr),\n                                  BytesPtr-SegmentStartPtr-2,\n                                  IsFirstSegment, false, IndentToStrip))",
          "new_text": "Str.getText().end()",
          "old_line_content": "    Segments.push_back(",
          "new_line_content": "                                                        Str.getText().end(),",
          "content_same": false
        },
        {
          "line": 2124,
          "old_api": "getText",
          "new_api": "push_back",
          "old_text": "skipToEndOfInterpolatedExpression(BytesPtr,\n                                                        Str.getText().end(),\n                                                        Diags, MultilineString)",
          "new_text": "Segments.push_back(\n        StringSegment::getExpr(getSourceLoc(BytesPtr-1), End-BytesPtr+1))",
          "old_line_content": "    const char *End = skipToEndOfInterpolatedExpression(BytesPtr,",
          "new_line_content": "    Segments.push_back(",
          "content_same": false
        },
        {
          "line": 2125,
          "old_api": "getText",
          "new_api": "getSourceLoc",
          "old_text": "Str.getText().end()",
          "new_text": "getSourceLoc(BytesPtr-1)",
          "old_line_content": "                                                        Str.getText().end(),",
          "new_line_content": "        StringSegment::getExpr(getSourceLoc(BytesPtr-1), End-BytesPtr+1));",
          "content_same": false
        },
        {
          "line": 2155,
          "old_api": "clear",
          "new_api": "TriviaPiece::garbageText({CurPtr, BOMLen})",
          "old_text": "LeadingTrivia.clear()",
          "new_text": "TriviaPiece::garbageText({CurPtr, BOMLen})",
          "old_line_content": "  LeadingTrivia.clear();",
          "new_line_content": "      LeadingTrivia.push_back(TriviaPiece::garbageText({CurPtr, BOMLen}));",
          "content_same": false
        },
        {
          "line": 2175,
          "old_api": "lexTrivia",
          "new_api": "advanceIfValidStartOfIdentifier",
          "old_text": "lexTrivia(LeadingTrivia, /* IsForTrailingTrivia */ false)",
          "new_text": "advanceIfValidStartOfIdentifier(Tmp, BufferEnd)",
          "old_line_content": "  lexTrivia(LeadingTrivia, /* IsForTrailingTrivia */ false);",
          "new_line_content": "    if (advanceIfValidStartOfIdentifier(Tmp, BufferEnd))",
          "content_same": false
        },
        {
          "line": 2186,
          "old_api": "advanceIfValidStartOfOperator",
          "new_api": "formToken",
          "old_text": "advanceIfValidStartOfOperator(Tmp, BufferEnd)",
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "    if (advanceIfValidStartOfOperator(Tmp, BufferEnd))",
          "new_line_content": "    return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 2255,
          "old_api": "formToken",
          "new_api": "skipSlashSlashComment",
          "old_text": "formToken(tok::backslash, TokStart)",
          "new_text": "skipSlashSlashComment(/*EatNewline=*/true)",
          "old_line_content": "    return formToken(tok::backslash, TokStart);",
          "new_line_content": "      skipSlashSlashComment(/*EatNewline=*/true);",
          "content_same": false
        },
        {
          "line": 2274,
          "old_api": "formToken",
          "new_api": "clang::isIdentifierBody(CurPtr[0])",
          "old_text": "formToken(tok::comment, TokStart)",
          "new_text": "clang::isIdentifierBody(CurPtr[0])",
          "old_line_content": "      return formToken(tok::comment, TokStart);",
          "new_line_content": "      } while (clang::isIdentifierBody(CurPtr[0]));",
          "content_same": false
        },
        {
          "line": 2276,
          "old_api": "lexOperatorIdentifier",
          "new_api": "formToken",
          "old_text": "lexOperatorIdentifier()",
          "new_text": "formToken(tok::sil_local_name, TokStart)",
          "old_line_content": "    return lexOperatorIdentifier();",
          "new_line_content": "      return formToken(tok::sil_local_name, TokStart);",
          "content_same": false
        },
        {
          "line": 2282,
          "old_api": "clang::isIdentifierBody(CurPtr[0])",
          "new_api": "formToken",
          "old_text": "clang::isIdentifierBody(CurPtr[0])",
          "new_text": "formToken(tok::sil_exclamation, TokStart)",
          "old_line_content": "      } while (clang::isIdentifierBody(CurPtr[0]));",
          "new_line_content": "      return formToken(tok::sil_exclamation, TokStart);",
          "content_same": false
        },
        {
          "line": 2290,
          "old_api": "formToken",
          "new_api": "lexOperatorIdentifier",
          "old_text": "formToken(tok::sil_exclamation, TokStart)",
          "new_text": "lexOperatorIdentifier()",
          "old_line_content": "      return formToken(tok::sil_exclamation, TokStart);",
          "new_line_content": "    return lexOperatorIdentifier();",
          "content_same": false
        },
        {
          "line": 2296,
          "old_api": "isLeftBound",
          "new_api": "lexOperatorIdentifier",
          "old_text": "isLeftBound(TokStart, ContentStart)",
          "new_text": "lexOperatorIdentifier()",
          "old_line_content": "    if (isLeftBound(TokStart, ContentStart))",
          "new_line_content": "    return lexOperatorIdentifier();",
          "content_same": false
        },
        {
          "line": 2302,
          "old_api": "tryLexEditorPlaceholder",
          "new_api": "lexOperatorIdentifier",
          "old_text": "tryLexEditorPlaceholder()",
          "new_text": "lexOperatorIdentifier()",
          "old_line_content": "      return tryLexEditorPlaceholder();",
          "new_line_content": "    return lexOperatorIdentifier();",
          "content_same": false
        },
        {
          "line": 2324,
          "old_api": "lexDollarIdent",
          "new_api": "lexStringLiteral",
          "old_text": "lexDollarIdent()",
          "new_text": "lexStringLiteral()",
          "old_line_content": "    return lexDollarIdent();",
          "new_line_content": "    return lexStringLiteral();",
          "content_same": false
        },
        {
          "line": 2371,
          "old_api": "setAtStartOfLine",
          "new_api": "TriviaPiece::carriageReturnLineFeeds(1)",
          "old_text": "NextToken.setAtStartOfLine(true)",
          "new_text": "TriviaPiece::carriageReturnLineFeeds(1)",
          "old_line_content": "    NextToken.setAtStartOfLine(true);",
          "new_line_content": "      Pieces.appendOrSquash(TriviaPiece::carriageReturnLineFeeds(1));",
          "content_same": false
        },
        {
          "line": 2398,
          "old_api": "isKeepingComments",
          "new_api": "skipSlashSlashComment",
          "old_text": "isKeepingComments()",
          "new_text": "skipSlashSlashComment(/*EatNewline=*/false)",
          "old_line_content": "    if (IsForTrailingTrivia || isKeepingComments()) {",
          "new_line_content": "      skipSlashSlashComment(/*EatNewline=*/false);",
          "content_same": false
        },
        {
          "line": 2408,
          "old_api": "push_back",
          "new_api": "skipSlashStarComment",
          "old_text": "Pieces.push_back(isDocComment\n                           ? TriviaPiece::docLineComment({TriviaStart, Length})\n                           : TriviaPiece::lineComment({TriviaStart, Length}))",
          "new_text": "skipSlashStarComment()",
          "old_line_content": "      Pieces.push_back(isDocComment",
          "new_line_content": "      skipSlashStarComment();",
          "content_same": false
        },
        {
          "line": 2410,
          "old_api": "TriviaPiece::lineComment({TriviaStart, Length})",
          "new_api": "push_back",
          "old_text": "TriviaPiece::lineComment({TriviaStart, Length})",
          "new_text": "Pieces.push_back(isDocComment\n                           ? TriviaPiece::docBlockComment({TriviaStart, Length})\n                           : TriviaPiece::blockComment({TriviaStart, Length}))",
          "old_line_content": "                           : TriviaPiece::lineComment({TriviaStart, Length}));",
          "new_line_content": "      Pieces.push_back(isDocComment",
          "content_same": false
        },
        {
          "line": 2420,
          "old_api": "TriviaPiece::blockComment({TriviaStart, Length})",
          "new_api": "getHashbangBufferID",
          "old_text": "TriviaPiece::blockComment({TriviaStart, Length})",
          "new_text": "SourceMgr.getHashbangBufferID()",
          "old_line_content": "                           : TriviaPiece::blockComment({TriviaStart, Length}));",
          "new_line_content": "      if (BufferID != SourceMgr.getHashbangBufferID())",
          "content_same": false
        },
        {
          "line": 2430,
          "old_api": "skipHashbang",
          "new_api": "tryLexConflictMarker",
          "old_text": "skipHashbang(/*EatNewline=*/false)",
          "new_text": "tryLexConflictMarker(/*EatNewline=*/false)",
          "old_line_content": "      skipHashbang(/*EatNewline=*/false);",
          "new_line_content": "    if (tryLexConflictMarker(/*EatNewline=*/false)) {",
          "content_same": false
        },
        {
          "line": 2438,
          "old_api": "tryLexConflictMarker",
          "new_api": "getNulCharacterKind",
          "old_text": "tryLexConflictMarker(/*EatNewline=*/false)",
          "new_text": "getNulCharacterKind(CurPtr - 1)",
          "old_line_content": "    if (tryLexConflictMarker(/*EatNewline=*/false)) {",
          "new_line_content": "    switch (getNulCharacterKind(CurPtr - 1)) {",
          "content_same": false
        },
        {
          "line": 2496,
          "old_api": "TriviaPiece::garbageText({TriviaStart, Length})",
          "new_api": "getLength",
          "old_text": "TriviaPiece::garbageText({TriviaStart, Length})",
          "new_text": "getTokenAtLocation(SM, Loc).getLength()",
          "old_line_content": "    Pieces.push_back(TriviaPiece::garbageText({TriviaStart, Length}));",
          "new_line_content": "  return Loc.getAdvancedLocOrInvalid(getTokenAtLocation(SM, Loc).getLength());",
          "content_same": false
        },
        {
          "line": 2547,
          "old_api": "getLocForStartOfTokenInBuf",
          "new_api": "isNot",
          "old_text": "getLocForStartOfTokenInBuf(SM, BufferID, Offset,\n                                              /*BufferStart=*/SegOffs,\n                                              /*BufferEnd=*/SegEnd)",
          "new_text": "Tok.isNot(tok::eof)",
          "old_line_content": "            return getLocForStartOfTokenInBuf(SM, BufferID, Offset,",
          "new_line_content": "  } while (Tok.isNot(tok::eof));",
          "content_same": false
        },
        {
          "line": 2578,
          "old_api": "hasValue",
          "new_api": "getRangeForBuffer",
          "old_text": "BufferIdOp.hasValue()",
          "new_text": "SM.getRangeForBuffer(BufferID)",
          "old_line_content": "  if (!BufferIdOp.hasValue())",
          "new_line_content": "  CharSourceRange entireRange = SM.getRangeForBuffer(BufferID);",
          "content_same": false
        },
        {
          "line": 2579,
          "old_api": "SourceLoc",
          "new_api": "extractText",
          "old_text": "SourceLoc()",
          "new_text": "SM.extractText(entireRange)",
          "old_line_content": "    return SourceLoc();",
          "new_line_content": "  StringRef Buffer = SM.extractText(entireRange);",
          "content_same": false
        },
        {
          "line": 2581,
          "old_api": "getValue",
          "new_api": "data",
          "old_text": "BufferIdOp.getValue()",
          "new_text": "Buffer.data()",
          "old_line_content": "    SM.getLocOffsetInBuffer(Loc, BufferIdOp.getValue()));",
          "new_line_content": "  const char *BufStart = Buffer.data();",
          "content_same": false
        },
        {
          "line": 2589,
          "old_api": "data",
          "new_api": "getLocForOffset",
          "old_text": "Buffer.data()",
          "new_text": "SM.getLocForOffset(BufferID, Offset)",
          "old_line_content": "  const char *BufStart = Buffer.data();",
          "new_line_content": "    return SM.getLocForOffset(BufferID, Offset);",
          "content_same": false
        },
        {
          "line": 2597,
          "old_api": "getLocForOffset",
          "new_api": "size",
          "old_text": "SM.getLocForOffset(BufferID, Offset)",
          "new_text": "Buffer.size()",
          "old_line_content": "    return SM.getLocForOffset(BufferID, Offset);",
          "new_line_content": "                                    /*BufferEnd=*/Buffer.size());",
          "content_same": false
        },
        {
          "line": 2610,
          "old_api": "isInvalid",
          "new_api": "getRangeForBuffer",
          "old_text": "Loc.isInvalid()",
          "new_text": "SM.getRangeForBuffer(BufferID)",
          "old_line_content": "  if (Loc.isInvalid())",
          "new_line_content": "  CharSourceRange entireRange = SM.getRangeForBuffer(BufferID);",
          "content_same": false
        },
        {
          "line": 2614,
          "old_api": "findBufferContainingLoc",
          "new_api": "getLocOffsetInBuffer",
          "old_text": "SM.findBufferContainingLoc(Loc)",
          "new_text": "SM.getLocOffsetInBuffer(Loc, BufferID)",
          "old_line_content": "  int BufferID = SM.findBufferContainingLoc(Loc);",
          "new_line_content": "  unsigned Offset = SM.getLocOffsetInBuffer(Loc, BufferID);",
          "content_same": false
        },
        {
          "line": 2616,
          "old_api": "SourceLoc",
          "new_api": "findStartOfLine",
          "old_text": "SourceLoc()",
          "new_text": "findStartOfLine(BufStart, BufStart + Offset)",
          "old_line_content": "    return SourceLoc();",
          "new_line_content": "  const char *StartOfLine = findStartOfLine(BufStart, BufStart + Offset);",
          "content_same": false
        },
        {
          "line": 2622,
          "old_api": "getLocOffsetInBuffer",
          "new_api": "isInvalid",
          "old_text": "SM.getLocOffsetInBuffer(Loc, BufferID)",
          "new_text": "Loc.isInvalid()",
          "old_line_content": "  unsigned Offset = SM.getLocOffsetInBuffer(Loc, BufferID);",
          "new_line_content": "  if (Loc.isInvalid())",
          "content_same": false
        },
        {
          "line": 2655,
          "old_api": "isInvalid",
          "new_api": "getRangeForBuffer",
          "old_text": "Loc.isInvalid()",
          "new_text": "SM.getRangeForBuffer(BufferID)",
          "old_line_content": "  if (Loc.isInvalid())",
          "new_line_content": "  CharSourceRange entireRange = SM.getRangeForBuffer(BufferID);",
          "content_same": false
        },
        {
          "line": 2659,
          "old_api": "findBufferContainingLoc",
          "new_api": "getLocOffsetInBuffer",
          "old_text": "SM.findBufferContainingLoc(Loc)",
          "new_text": "SM.getLocOffsetInBuffer(Loc, BufferID)",
          "old_line_content": "  int BufferID = SM.findBufferContainingLoc(Loc);",
          "new_line_content": "  unsigned Offset = SM.getLocOffsetInBuffer(Loc, BufferID);",
          "content_same": false
        },
        {
          "line": 2663,
          "old_api": "getRangeForBuffer",
          "new_api": "isHorizontalWhitespace",
          "old_text": "SM.getRangeForBuffer(BufferID)",
          "new_text": "isHorizontalWhitespace(*EndOfIndentation)",
          "old_line_content": "  CharSourceRange entireRange = SM.getRangeForBuffer(BufferID);",
          "new_line_content": "  while (*EndOfIndentation && isHorizontalWhitespace(*EndOfIndentation))",
          "content_same": false
        },
        {
          "line": 2666,
          "old_api": "data",
          "new_api": "StringRef",
          "old_text": "Buffer.data()",
          "new_text": "StringRef(StartOfLine, EndOfIndentation - StartOfLine)",
          "old_line_content": "  const char *BufStart = Buffer.data();",
          "new_line_content": "  return StringRef(StartOfLine, EndOfIndentation - StartOfLine);",
          "content_same": false
        },
        {
          "line": 2674,
          "old_api": "StringRef",
          "new_api": "token_lower_bound",
          "old_text": "StringRef(StartOfLine, EndOfIndentation - StartOfLine)",
          "new_text": "token_lower_bound(AllTokens, EndLoc)",
          "old_line_content": "  return StringRef(StartOfLine, EndOfIndentation - StartOfLine);",
          "new_line_content": "  auto EndIt = token_lower_bound(AllTokens, EndLoc);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2053,
          "old_api": null,
          "new_api": "lexUnicodeEscape",
          "old_text": null,
          "new_text": "lexUnicodeEscape(BytesPtr, /*no diagnostics*/nullptr)",
          "old_line_content": "    case '(':",
          "new_line_content": "      CharValue = lexUnicodeEscape(BytesPtr, /*no diagnostics*/nullptr);",
          "content_same": false
        },
        {
          "line": 2060,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "TempString.push_back(CharValue)",
          "old_line_content": "",
          "new_line_content": "      TempString.push_back(CharValue);",
          "content_same": false
        },
        {
          "line": 2062,
          "old_api": null,
          "new_api": "EncodeToUTF8",
          "old_text": null,
          "new_text": "EncodeToUTF8(CharValue, TempString)",
          "old_line_content": "      // Ignore invalid escapes.",
          "new_line_content": "      EncodeToUTF8(CharValue, TempString);",
          "content_same": false
        },
        {
          "line": 2069,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "Bytes.size()",
          "old_line_content": "    else",
          "new_line_content": "  if (TempString.size() == Bytes.size()) {",
          "content_same": false
        },
        {
          "line": 2073,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "TempString.size()",
          "old_line_content": "  // If we didn't escape or reprocess anything, then we don't need to use the",
          "new_line_content": "  return StringRef(TempString.begin(), TempString.size());",
          "content_same": false
        },
        {
          "line": 2080,
          "old_api": null,
          "new_api": "is",
          "old_text": null,
          "new_text": "Str.is(tok::string_literal)",
          "old_line_content": "  }",
          "new_line_content": "  assert(Str.is(tok::string_literal));",
          "content_same": false
        },
        {
          "line": 2082,
          "old_api": null,
          "new_api": "getStringLiteralContent",
          "old_text": null,
          "new_text": "getStringLiteralContent(Str)",
          "old_line_content": "}",
          "new_line_content": "  StringRef Bytes = getStringLiteralContent(Str);",
          "content_same": false
        },
        {
          "line": 2086,
          "old_api": null,
          "new_api": "IsMultilineString",
          "old_text": null,
          "new_text": "Str.IsMultilineString()",
          "old_line_content": "              SmallVectorImpl<StringSegment> &Segments,",
          "new_line_content": "  bool MultilineString = Str.IsMultilineString(), IsFirstSegment = true;",
          "content_same": false
        },
        {
          "line": 2095,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "Bytes.begin()",
          "old_line_content": "  unsigned IndentToStrip = 0;",
          "new_line_content": "  const char *SegmentStartPtr = Bytes.begin();",
          "content_same": false
        },
        {
          "line": 2109,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "Segments.push_back(\n        StringSegment::getLiteral(getSourceLoc(SegmentStartPtr),\n                                  BytesPtr-SegmentStartPtr-2,\n                                  IsFirstSegment, false, IndentToStrip))",
          "old_line_content": "      continue;",
          "new_line_content": "    Segments.push_back(",
          "content_same": false
        },
        {
          "line": 2110,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(SegmentStartPtr)",
          "old_line_content": "",
          "new_line_content": "        StringSegment::getLiteral(getSourceLoc(SegmentStartPtr),",
          "content_same": false
        },
        {
          "line": 2116,
          "old_api": null,
          "new_api": "getText",
          "old_text": null,
          "new_text": "skipToEndOfInterpolatedExpression(BytesPtr,\n                                                        Str.getText().end(),\n                                                        Diags, MultilineString)",
          "old_line_content": "    // Push the current segment.",
          "new_line_content": "    const char *End = skipToEndOfInterpolatedExpression(BytesPtr,",
          "content_same": false
        },
        {
          "line": 2119,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(*End == ')' && \"invalid string literal interpolations should\"\n           \" not be returned as string literals\")",
          "old_line_content": "                                  BytesPtr-SegmentStartPtr-2,",
          "new_line_content": "    assert(*End == ')' && \"invalid string literal interpolations should\"",
          "content_same": false
        },
        {
          "line": 2134,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "Bytes.end()",
          "old_line_content": "",
          "new_line_content": "                                Bytes.end()-SegmentStartPtr,",
          "content_same": false
        },
        {
          "line": 2144,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(CurPtr >= BufferStart &&\n         CurPtr <= BufferEnd && \"Current pointer out of range!\")",
          "old_line_content": "}",
          "new_line_content": "  assert(CurPtr >= BufferStart &&",
          "content_same": false
        },
        {
          "line": 2147,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "LeadingTrivia.clear()",
          "old_line_content": "//===----------------------------------------------------------------------===//",
          "new_line_content": "  LeadingTrivia.clear();",
          "content_same": false
        },
        {
          "line": 2148,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "TrailingTrivia.clear()",
          "old_line_content": "// Main Lexer Loop",
          "new_line_content": "  TrailingTrivia.clear();",
          "content_same": false
        },
        {
          "line": 2153,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(BOMLen == 3 && \"UTF-8 BOM is 3 bytes\")",
          "old_line_content": "         CurPtr <= BufferEnd && \"Current pointer out of range!\");",
          "new_line_content": "      assert(BOMLen == 3 && \"UTF-8 BOM is 3 bytes\");",
          "content_same": false
        },
        {
          "line": 2158,
          "old_api": null,
          "new_api": "setAtStartOfLine",
          "old_text": null,
          "new_text": "NextToken.setAtStartOfLine(true)",
          "old_line_content": "  if (CurPtr == BufferStart) {",
          "new_line_content": "    NextToken.setAtStartOfLine(true);",
          "content_same": false
        },
        {
          "line": 2160,
          "old_api": null,
          "new_api": "setAtStartOfLine",
          "old_text": null,
          "new_text": "NextToken.setAtStartOfLine(false)",
          "old_line_content": "      size_t BOMLen = ContentStart - BufferStart;",
          "new_line_content": "    NextToken.setAtStartOfLine(false);",
          "content_same": false
        },
        {
          "line": 2167,
          "old_api": null,
          "new_api": "lexTrivia",
          "old_text": null,
          "new_text": "lexTrivia(LeadingTrivia, /* IsForTrailingTrivia */ false)",
          "old_line_content": "  } else {",
          "new_line_content": "  lexTrivia(LeadingTrivia, /* IsForTrailingTrivia */ false);",
          "content_same": false
        },
        {
          "line": 2176,
          "old_api": null,
          "new_api": "lexIdentifier",
          "old_text": null,
          "new_text": "lexIdentifier()",
          "old_line_content": "",
          "new_line_content": "      return lexIdentifier();",
          "content_same": false
        },
        {
          "line": 2178,
          "old_api": null,
          "new_api": "advanceIfValidStartOfOperator",
          "old_text": null,
          "new_text": "advanceIfValidStartOfOperator(Tmp, BufferEnd)",
          "old_line_content": "  const char *TokStart = CurPtr;",
          "new_line_content": "    if (advanceIfValidStartOfOperator(Tmp, BufferEnd))",
          "content_same": false
        },
        {
          "line": 2179,
          "old_api": null,
          "new_api": "lexOperatorIdentifier",
          "old_text": null,
          "new_text": "lexOperatorIdentifier()",
          "old_line_content": "  ",
          "new_line_content": "      return lexOperatorIdentifier();",
          "content_same": false
        },
        {
          "line": 2181,
          "old_api": null,
          "new_api": "lexUnknown",
          "old_text": null,
          "new_text": "lexUnknown(/*EmitDiagnosticsIfToken=*/true)",
          "old_line_content": "  default: {",
          "new_line_content": "    bool ShouldTokenize = lexUnknown(/*EmitDiagnosticsIfToken=*/true);",
          "content_same": false
        },
        {
          "line": 2182,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(\n        ShouldTokenize &&\n        \"Invalid UTF-8 sequence should be eaten by lexTrivia as LeadingTrivia\")",
          "old_line_content": "    char const *Tmp = CurPtr-1;",
          "new_line_content": "    assert(",
          "content_same": false
        },
        {
          "line": 2191,
          "old_api": null,
          "new_api": "llvm_unreachable",
          "old_text": null,
          "new_text": "llvm_unreachable(\"Newlines should be eaten by lexTrivia as LeadingTrivia\")",
          "old_line_content": "        ShouldTokenize &&",
          "new_line_content": "    llvm_unreachable(\"Newlines should be eaten by lexTrivia as LeadingTrivia\");",
          "content_same": false
        },
        {
          "line": 2197,
          "old_api": null,
          "new_api": "llvm_unreachable",
          "old_text": null,
          "new_text": "llvm_unreachable(\n        \"Whitespaces should be eaten by lexTrivia as LeadingTrivia\")",
          "old_line_content": "  case '\\n':",
          "new_line_content": "    llvm_unreachable(",
          "content_same": false
        },
        {
          "line": 2202,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CurPtr-1, diag::lex_utf16_bom_marker)",
          "old_line_content": "  case '\\t':",
          "new_line_content": "    diagnose(CurPtr-1, diag::lex_utf16_bom_marker);",
          "content_same": false
        },
        {
          "line": 2204,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "  case '\\v':",
          "new_line_content": "    return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 2207,
          "old_api": null,
          "new_api": "getNulCharacterKind",
          "old_text": null,
          "new_text": "getNulCharacterKind(CurPtr - 1)",
          "old_line_content": "",
          "new_line_content": "    switch (getNulCharacterKind(CurPtr - 1)) {",
          "content_same": false
        },
        {
          "line": 2209,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::code_complete, TokStart)",
          "old_line_content": "  case -2:",
          "new_line_content": "      return formToken(tok::code_complete, TokStart);",
          "content_same": false
        },
        {
          "line": 2216,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::eof, TokStart)",
          "old_line_content": "    case NulCharacterKind::CodeCompletion:",
          "new_line_content": "      return formToken(tok::eof, TokStart);",
          "content_same": false
        },
        {
          "line": 2219,
          "old_api": null,
          "new_api": "llvm_unreachable",
          "old_text": null,
          "new_text": "llvm_unreachable(\n          \"Embedded nul should be eaten by lexTrivia as LeadingTrivia\")",
          "old_line_content": "    case NulCharacterKind::BufferEnd:",
          "new_line_content": "      llvm_unreachable(",
          "content_same": false
        },
        {
          "line": 2223,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::at_sign, TokStart)",
          "old_line_content": "      // Return EOF.",
          "new_line_content": "  case '@': return formToken(tok::at_sign, TokStart);",
          "content_same": false
        },
        {
          "line": 2233,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::l_square_lit, TokStart)",
          "old_line_content": "  case '[': {",
          "new_line_content": "       return formToken(tok::l_square_lit, TokStart);",
          "content_same": false
        },
        {
          "line": 2235,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::l_square, TokStart)",
          "old_line_content": "     // Remove in the future.",
          "new_line_content": "     return formToken(tok::l_square, TokStart);",
          "content_same": false
        },
        {
          "line": 2237,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::l_paren, TokStart)",
          "old_line_content": "       // NOTE: Do NOT include the '#' in the token, unlike in earlier",
          "new_line_content": "  case '(': return formToken(tok::l_paren, TokStart);",
          "content_same": false
        },
        {
          "line": 2238,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::r_brace, TokStart)",
          "old_line_content": "       // versions of Swift that supported the old object literal syntax",
          "new_line_content": "  case '}': return formToken(tok::r_brace, TokStart);",
          "content_same": false
        },
        {
          "line": 2239,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::r_square, TokStart)",
          "old_line_content": "       // directly.  The '#' will be lexed as part of the object literal",
          "new_line_content": "  case ']': return formToken(tok::r_square, TokStart);",
          "content_same": false
        },
        {
          "line": 2244,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::semi, TokStart)",
          "old_line_content": "  }",
          "new_line_content": "  case ';': return formToken(tok::semi, TokStart);",
          "content_same": false
        },
        {
          "line": 2250,
          "old_api": null,
          "new_api": "lexHash",
          "old_text": null,
          "new_text": "lexHash()",
          "old_line_content": "",
          "new_line_content": "    return lexHash();",
          "content_same": false
        },
        {
          "line": 2257,
          "old_api": null,
          "new_api": "isKeepingComments",
          "old_text": null,
          "new_text": "isKeepingComments()",
          "old_line_content": "  case '#':",
          "new_line_content": "      assert(isKeepingComments() &&",
          "content_same": false
        },
        {
          "line": 2259,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::comment, TokStart)",
          "old_line_content": "",
          "new_line_content": "      return formToken(tok::comment, TokStart);",
          "content_same": false
        },
        {
          "line": 2262,
          "old_api": null,
          "new_api": "skipSlashStarComment",
          "old_text": null,
          "new_text": "skipSlashStarComment()",
          "old_line_content": "    if (CurPtr[0] == '/') {  // \"//\"",
          "new_line_content": "      skipSlashStarComment();",
          "content_same": false
        },
        {
          "line": 2264,
          "old_api": null,
          "new_api": "isKeepingComments",
          "old_text": null,
          "new_text": "isKeepingComments()",
          "old_line_content": "      SeenComment = true;",
          "new_line_content": "      assert(isKeepingComments() &&",
          "content_same": false
        },
        {
          "line": 2266,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::comment, TokStart)",
          "old_line_content": "             \"Non token comment should be eaten by lexTrivia as LeadingTrivia\");",
          "new_line_content": "      return formToken(tok::comment, TokStart);",
          "content_same": false
        },
        {
          "line": 2268,
          "old_api": null,
          "new_api": "lexOperatorIdentifier",
          "old_text": null,
          "new_text": "lexOperatorIdentifier()",
          "old_line_content": "    }",
          "new_line_content": "    return lexOperatorIdentifier();",
          "content_same": false
        },
        {
          "line": 2271,
          "old_api": null,
          "new_api": "clang::isIdentifierBody(CurPtr[0])",
          "old_text": null,
          "new_text": "clang::isIdentifierBody(CurPtr[0])",
          "old_line_content": "      SeenComment = true;",
          "new_line_content": "    if (InSILBody && clang::isIdentifierBody(CurPtr[0])) {",
          "content_same": false
        },
        {
          "line": 2278,
          "old_api": null,
          "new_api": "lexOperatorIdentifier",
          "old_text": null,
          "new_text": "lexOperatorIdentifier()",
          "old_line_content": "    // Lex %[0-9a-zA-Z_]+ as a local SIL value",
          "new_line_content": "    return lexOperatorIdentifier();",
          "content_same": false
        },
        {
          "line": 2283,
          "old_api": null,
          "new_api": "isLeftBound",
          "old_text": null,
          "new_text": "isLeftBound(TokStart, ContentStart)",
          "old_line_content": "      ",
          "new_line_content": "    if (isLeftBound(TokStart, ContentStart))",
          "content_same": false
        },
        {
          "line": 2285,
          "old_api": null,
          "new_api": "lexOperatorIdentifier",
          "old_text": null,
          "new_text": "lexOperatorIdentifier()",
          "old_line_content": "    }",
          "new_line_content": "    return lexOperatorIdentifier();",
          "content_same": false
        },
        {
          "line": 2288,
          "old_api": null,
          "new_api": "isLeftBound",
          "old_text": null,
          "new_text": "isLeftBound(TokStart, ContentStart)",
          "old_line_content": "  case '!':",
          "new_line_content": "    if (isLeftBound(TokStart, ContentStart))",
          "content_same": false
        },
        {
          "line": 2289,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::question_postfix, TokStart)",
          "old_line_content": "    if (InSILBody)",
          "new_line_content": "      return formToken(tok::question_postfix, TokStart);",
          "content_same": false
        },
        {
          "line": 2294,
          "old_api": null,
          "new_api": "tryLexEditorPlaceholder",
          "old_text": null,
          "new_text": "tryLexEditorPlaceholder()",
          "old_line_content": "  ",
          "new_line_content": "      return tryLexEditorPlaceholder();",
          "content_same": false
        },
        {
          "line": 2313,
          "old_api": null,
          "new_api": "lexIdentifier",
          "old_text": null,
          "new_text": "lexIdentifier()",
          "old_line_content": "  case 'H': case 'I': case 'J': case 'K': case 'L': case 'M': case 'N':",
          "new_line_content": "    return lexIdentifier();",
          "content_same": false
        },
        {
          "line": 2316,
          "old_api": null,
          "new_api": "lexDollarIdent",
          "old_text": null,
          "new_text": "lexDollarIdent()",
          "old_line_content": "  case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g':",
          "new_line_content": "    return lexDollarIdent();",
          "content_same": false
        },
        {
          "line": 2320,
          "old_api": null,
          "new_api": "lexNumber",
          "old_text": null,
          "new_text": "lexNumber()",
          "old_line_content": "  case '_':",
          "new_line_content": "    return lexNumber();",
          "content_same": false
        },
        {
          "line": 2327,
          "old_api": null,
          "new_api": "lexEscapedIdentifier",
          "old_text": null,
          "new_text": "lexEscapedIdentifier()",
          "old_line_content": "  case '5': case '6': case '7': case '8': case '9':",
          "new_line_content": "    return lexEscapedIdentifier();",
          "content_same": false
        },
        {
          "line": 2333,
          "old_api": null,
          "new_api": "isValid",
          "old_text": null,
          "new_text": "Loc.isValid()",
          "old_line_content": "      ",
          "new_line_content": "  if (!Loc.isValid())",
          "content_same": false
        },
        {
          "line": 2334,
          "old_api": null,
          "new_api": "Token",
          "old_text": null,
          "new_text": "Token()",
          "old_line_content": "  case '`':",
          "new_line_content": "    return Token();",
          "content_same": false
        },
        {
          "line": 2337,
          "old_api": null,
          "new_api": "findBufferContainingLoc",
          "old_text": null,
          "new_text": "SM.findBufferContainingLoc(Loc)",
          "old_line_content": "}",
          "new_line_content": "  int BufferID = SM.findBufferContainingLoc(Loc);",
          "content_same": false
        },
        {
          "line": 2339,
          "old_api": null,
          "new_api": "Token",
          "old_text": null,
          "new_text": "Token()",
          "old_line_content": "Token Lexer::getTokenAtLocation(const SourceManager &SM, SourceLoc Loc) {",
          "new_line_content": "    return Token();",
          "content_same": false
        },
        {
          "line": 2351,
          "old_api": null,
          "new_api": "State",
          "old_text": null,
          "new_text": "State(Loc)",
          "old_line_content": "  LangOptions FakeLangOpts;",
          "new_line_content": "  L.restoreState(State(Loc));",
          "content_same": false
        },
        {
          "line": 2352,
          "old_api": null,
          "new_api": "peekNextToken",
          "old_text": null,
          "new_text": "L.peekNextToken()",
          "old_line_content": "",
          "new_line_content": "  return L.peekNextToken();",
          "content_same": false
        },
        {
          "line": 2363,
          "old_api": null,
          "new_api": "setAtStartOfLine",
          "old_text": null,
          "new_text": "NextToken.setAtStartOfLine(true)",
          "old_line_content": "void Lexer::lexTrivia(syntax::Trivia &Pieces, bool IsForTrailingTrivia) {",
          "new_line_content": "    NextToken.setAtStartOfLine(true);",
          "content_same": false
        },
        {
          "line": 2364,
          "old_api": null,
          "new_api": "TriviaPiece::newlines(1)",
          "old_text": null,
          "new_text": "TriviaPiece::newlines(1)",
          "old_line_content": "Restart:",
          "new_line_content": "    Pieces.appendOrSquash(TriviaPiece::newlines(1));",
          "content_same": false
        },
        {
          "line": 2369,
          "old_api": null,
          "new_api": "setAtStartOfLine",
          "old_text": null,
          "new_text": "NextToken.setAtStartOfLine(true)",
          "old_line_content": "    if (IsForTrailingTrivia)",
          "new_line_content": "    NextToken.setAtStartOfLine(true);",
          "content_same": false
        },
        {
          "line": 2374,
          "old_api": null,
          "new_api": "TriviaPiece::carriageReturns(1)",
          "old_text": null,
          "new_text": "TriviaPiece::carriageReturns(1)",
          "old_line_content": "  case '\\r':",
          "new_line_content": "      Pieces.appendOrSquash(TriviaPiece::carriageReturns(1));",
          "content_same": false
        },
        {
          "line": 2378,
          "old_api": null,
          "new_api": "TriviaPiece::spaces(1)",
          "old_text": null,
          "new_text": "TriviaPiece::spaces(1)",
          "old_line_content": "    if (CurPtr[0] == '\\n') {",
          "new_line_content": "    Pieces.appendOrSquash(TriviaPiece::spaces(1));",
          "content_same": false
        },
        {
          "line": 2381,
          "old_api": null,
          "new_api": "TriviaPiece::tabs(1)",
          "old_text": null,
          "new_text": "TriviaPiece::tabs(1)",
          "old_line_content": "    } else {",
          "new_line_content": "    Pieces.appendOrSquash(TriviaPiece::tabs(1));",
          "content_same": false
        },
        {
          "line": 2384,
          "old_api": null,
          "new_api": "TriviaPiece::verticalTabs(1)",
          "old_text": null,
          "new_text": "TriviaPiece::verticalTabs(1)",
          "old_line_content": "    goto Restart;",
          "new_line_content": "    Pieces.appendOrSquash(TriviaPiece::verticalTabs(1));",
          "content_same": false
        },
        {
          "line": 2387,
          "old_api": null,
          "new_api": "TriviaPiece::formfeeds(1)",
          "old_text": null,
          "new_text": "TriviaPiece::formfeeds(1)",
          "old_line_content": "    goto Restart;",
          "new_line_content": "    Pieces.appendOrSquash(TriviaPiece::formfeeds(1));",
          "content_same": false
        },
        {
          "line": 2390,
          "old_api": null,
          "new_api": "isKeepingComments",
          "old_text": null,
          "new_text": "isKeepingComments()",
          "old_line_content": "    goto Restart;",
          "new_line_content": "    if (IsForTrailingTrivia || isKeepingComments()) {",
          "content_same": false
        },
        {
          "line": 2400,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "Pieces.push_back(isDocComment\n                           ? TriviaPiece::docLineComment({TriviaStart, Length})\n                           : TriviaPiece::lineComment({TriviaStart, Length}))",
          "old_line_content": "      // Don't try to lex comments here if we are lexing comments as Tokens.",
          "new_line_content": "      Pieces.push_back(isDocComment",
          "content_same": false
        },
        {
          "line": 2401,
          "old_api": null,
          "new_api": "TriviaPiece::docLineComment({TriviaStart, Length})",
          "old_text": null,
          "new_text": "TriviaPiece::docLineComment({TriviaStart, Length})",
          "old_line_content": "      break;",
          "new_line_content": "                           ? TriviaPiece::docLineComment({TriviaStart, Length})",
          "content_same": false
        },
        {
          "line": 2402,
          "old_api": null,
          "new_api": "TriviaPiece::lineComment({TriviaStart, Length})",
          "old_text": null,
          "new_text": "TriviaPiece::lineComment({TriviaStart, Length})",
          "old_line_content": "    } else if (*CurPtr == '/') {",
          "new_line_content": "                           : TriviaPiece::lineComment({TriviaStart, Length}));",
          "content_same": false
        },
        {
          "line": 2411,
          "old_api": null,
          "new_api": "TriviaPiece::docBlockComment({TriviaStart, Length})",
          "old_text": null,
          "new_text": "TriviaPiece::docBlockComment({TriviaStart, Length})",
          "old_line_content": "      goto Restart;",
          "new_line_content": "                           ? TriviaPiece::docBlockComment({TriviaStart, Length})",
          "content_same": false
        },
        {
          "line": 2412,
          "old_api": null,
          "new_api": "TriviaPiece::blockComment({TriviaStart, Length})",
          "old_text": null,
          "new_text": "TriviaPiece::blockComment({TriviaStart, Length})",
          "old_line_content": "    } else if (*CurPtr == '*') {",
          "new_line_content": "                           : TriviaPiece::blockComment({TriviaStart, Length}));",
          "content_same": false
        },
        {
          "line": 2421,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(TriviaStart, diag::lex_hashbang_not_allowed)",
          "old_line_content": "      goto Restart;",
          "new_line_content": "        diagnose(TriviaStart, diag::lex_hashbang_not_allowed);",
          "content_same": false
        },
        {
          "line": 2422,
          "old_api": null,
          "new_api": "skipHashbang",
          "old_text": null,
          "new_text": "skipHashbang(/*EatNewline=*/false)",
          "old_line_content": "    }",
          "new_line_content": "      skipHashbang(/*EatNewline=*/false);",
          "content_same": false
        },
        {
          "line": 2424,
          "old_api": null,
          "new_api": "TriviaPiece::garbageText({TriviaStart, Length})",
          "old_text": null,
          "new_text": "TriviaPiece::garbageText({TriviaStart, Length})",
          "old_line_content": "  case '#':",
          "new_line_content": "      Pieces.push_back(TriviaPiece::garbageText({TriviaStart, Length}));",
          "content_same": false
        },
        {
          "line": 2433,
          "old_api": null,
          "new_api": "TriviaPiece::garbageText({TriviaStart, Length})",
          "old_text": null,
          "new_text": "TriviaPiece::garbageText({TriviaStart, Length})",
          "old_line_content": "      goto Restart;",
          "new_line_content": "      Pieces.push_back(TriviaPiece::garbageText({TriviaStart, Length}));",
          "content_same": false
        },
        {
          "line": 2440,
          "old_api": null,
          "new_api": "diagnoseEmbeddedNul",
          "old_text": null,
          "new_text": "diagnoseEmbeddedNul(Diags, CurPtr - 1)",
          "old_line_content": "      size_t Length = CurPtr - TriviaStart;",
          "new_line_content": "      diagnoseEmbeddedNul(Diags, CurPtr - 1);",
          "content_same": false
        },
        {
          "line": 2442,
          "old_api": null,
          "new_api": "TriviaPiece::garbageText({TriviaStart, Length})",
          "old_text": null,
          "new_text": "TriviaPiece::garbageText({TriviaStart, Length})",
          "old_line_content": "      goto Restart;",
          "new_line_content": "      Pieces.push_back(TriviaPiece::garbageText({TriviaStart, Length}));",
          "content_same": false
        },
        {
          "line": 2474,
          "old_api": null,
          "new_api": "advanceIfValidStartOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidStartOfIdentifier(Tmp, BufferEnd)",
          "old_line_content": "  case '_':",
          "new_line_content": "    if (advanceIfValidStartOfIdentifier(Tmp, BufferEnd)) {",
          "content_same": false
        },
        {
          "line": 2477,
          "old_api": null,
          "new_api": "advanceIfValidStartOfOperator",
          "old_text": null,
          "new_text": "advanceIfValidStartOfOperator(Tmp, BufferEnd)",
          "old_line_content": "  case '-': case '+': case '*':",
          "new_line_content": "    if (advanceIfValidStartOfOperator(Tmp, BufferEnd)) {",
          "content_same": false
        },
        {
          "line": 2481,
          "old_api": null,
          "new_api": "lexUnknown",
          "old_text": null,
          "new_text": "lexUnknown(/*EmitDiagnosticsIfToken=*/false)",
          "old_line_content": "    const char *Tmp = CurPtr - 1;",
          "new_line_content": "    bool ShouldTokenize = lexUnknown(/*EmitDiagnosticsIfToken=*/false);",
          "content_same": false
        },
        {
          "line": 2488,
          "old_api": null,
          "new_api": "TriviaPiece::garbageText({TriviaStart, Length})",
          "old_text": null,
          "new_text": "TriviaPiece::garbageText({TriviaStart, Length})",
          "old_line_content": "",
          "new_line_content": "    Pieces.push_back(TriviaPiece::garbageText({TriviaStart, Length}));",
          "content_same": false
        },
        {
          "line": 2516,
          "old_api": null,
          "new_api": "lex",
          "old_text": null,
          "new_text": "L.lex(Tok)",
          "old_line_content": "",
          "new_line_content": "    L.lex(Tok);",
          "content_same": false
        },
        {
          "line": 2518,
          "old_api": null,
          "new_api": "getLoc",
          "old_text": null,
          "new_text": "Tok.getLoc()",
          "old_line_content": "          CommentRetentionMode::None, TriviaRetentionMode::WithoutTrivia,",
          "new_line_content": "    unsigned TokOffs = SM.getLocOffsetInBuffer(Tok.getLoc(), BufferID);",
          "content_same": false
        },
        {
          "line": 2525,
          "old_api": null,
          "new_api": "getLength",
          "old_text": null,
          "new_text": "Tok.getLength()",
          "old_line_content": "",
          "new_line_content": "    if (Offset < TokOffs+Tok.getLength()) {",
          "content_same": false
        },
        {
          "line": 2528,
          "old_api": null,
          "new_api": "is",
          "old_text": null,
          "new_text": "Tok.is(tok::string_literal)",
          "old_line_content": "      // We ended up skipping over the source location entirely, which means",
          "new_line_content": "      if (Tok.is(tok::string_literal)) {",
          "content_same": false
        },
        {
          "line": 2530,
          "old_api": null,
          "new_api": "Lexer::getStringLiteralSegments(Tok, Segments, /*Diags=*/nullptr)",
          "old_text": null,
          "new_text": "Lexer::getStringLiteralSegments(Tok, Segments, /*Diags=*/nullptr)",
          "old_line_content": "      break;",
          "new_line_content": "        Lexer::getStringLiteralSegments(Tok, Segments, /*Diags=*/nullptr);",
          "content_same": false
        },
        {
          "line": 2532,
          "old_api": null,
          "new_api": "getLocOffsetInBuffer",
          "old_text": null,
          "new_text": "SM.getLocOffsetInBuffer(Seg.Loc, BufferID)",
          "old_line_content": "",
          "new_line_content": "          unsigned SegOffs = SM.getLocOffsetInBuffer(Seg.Loc, BufferID);",
          "content_same": false
        },
        {
          "line": 2539,
          "old_api": null,
          "new_api": "getLocForStartOfTokenInBuf",
          "old_text": null,
          "new_text": "getLocForStartOfTokenInBuf(SM, BufferID, Offset,\n                                              /*BufferStart=*/SegOffs,\n                                              /*BufferEnd=*/SegEnd)",
          "old_line_content": "        for (auto &Seg : Segments) {",
          "new_line_content": "            return getLocForStartOfTokenInBuf(SM, BufferID, Offset,",
          "content_same": false
        },
        {
          "line": 2545,
          "old_api": null,
          "new_api": "getLoc",
          "old_text": null,
          "new_text": "Tok.getLoc()",
          "old_line_content": "          // If the offset is inside an interpolated expr segment, re-lex.",
          "new_line_content": "      return Tok.getLoc();",
          "content_same": false
        },
        {
          "line": 2550,
          "old_api": null,
          "new_api": "getLocForOffset",
          "old_text": null,
          "new_text": "SM.getLocForOffset(BufferID, Offset)",
          "old_line_content": "        }",
          "new_line_content": "  return SM.getLocForOffset(BufferID, Offset);",
          "content_same": false
        },
        {
          "line": 2568,
          "old_api": null,
          "new_api": "SM.\n    getBufferIdentifierForLoc(Loc)",
          "old_text": null,
          "new_text": "SM.\n    getBufferIdentifierForLoc(Loc)",
          "old_line_content": "",
          "new_line_content": "  Optional<unsigned> BufferIdOp = SM.getIDForBufferIdentifier(SM.",
          "content_same": false
        },
        {
          "line": 2570,
          "old_api": null,
          "new_api": "hasValue",
          "old_text": null,
          "new_text": "BufferIdOp.hasValue()",
          "old_line_content": "  }",
          "new_line_content": "  if (!BufferIdOp.hasValue())",
          "content_same": false
        },
        {
          "line": 2571,
          "old_api": null,
          "new_api": "SourceLoc",
          "old_text": null,
          "new_text": "SourceLoc()",
          "old_line_content": "",
          "new_line_content": "    return SourceLoc();",
          "content_same": false
        },
        {
          "line": 2572,
          "old_api": null,
          "new_api": "getValue",
          "old_text": null,
          "new_text": "BufferIdOp.getValue()",
          "old_line_content": "  return current;",
          "new_line_content": "  return getLocForStartOfToken(SM, BufferIdOp.getValue(),",
          "content_same": false
        },
        {
          "line": 2573,
          "old_api": null,
          "new_api": "getValue",
          "old_text": null,
          "new_text": "BufferIdOp.getValue()",
          "old_line_content": "}",
          "new_line_content": "    SM.getLocOffsetInBuffer(Loc, BufferIdOp.getValue()));",
          "content_same": false
        },
        {
          "line": 2582,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "Buffer.size()",
          "old_line_content": "}",
          "new_line_content": "  if (Offset > Buffer.size())",
          "content_same": false
        },
        {
          "line": 2583,
          "old_api": null,
          "new_api": "SourceLoc",
          "old_text": null,
          "new_text": "SourceLoc()",
          "old_line_content": "",
          "new_line_content": "    return SourceLoc();",
          "content_same": false
        },
        {
          "line": 2593,
          "old_api": null,
          "new_api": "findStartOfLine",
          "old_text": null,
          "new_text": "findStartOfLine(BufStart, StrData)",
          "old_line_content": "  const char *StrData = BufStart+Offset;",
          "new_line_content": "  const char *LexStart = findStartOfLine(BufStart, StrData);",
          "content_same": false
        },
        {
          "line": 2595,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "getLocForStartOfTokenInBuf(SM, BufferID, Offset,\n                                    /*BufferStart=*/LexStart-BufStart,\n                                    /*BufferEnd=*/Buffer.size())",
          "old_line_content": "  if (StrData[0] == '\\n' || StrData[0] == '\\r' ||",
          "new_line_content": "  return getLocForStartOfTokenInBuf(SM, BufferID, Offset,",
          "content_same": false
        },
        {
          "line": 2602,
          "old_api": null,
          "new_api": "isInvalid",
          "old_text": null,
          "new_text": "Loc.isInvalid()",
          "old_line_content": "",
          "new_line_content": "  if (Loc.isInvalid())",
          "content_same": false
        },
        {
          "line": 2606,
          "old_api": null,
          "new_api": "findBufferContainingLoc",
          "old_text": null,
          "new_text": "SM.findBufferContainingLoc(Loc)",
          "old_line_content": "}",
          "new_line_content": "  int BufferID = SM.findBufferContainingLoc(Loc);",
          "content_same": false
        },
        {
          "line": 2608,
          "old_api": null,
          "new_api": "SourceLoc",
          "old_text": null,
          "new_text": "SourceLoc()",
          "old_line_content": "SourceLoc Lexer::getLocForStartOfLine(SourceManager &SM, SourceLoc Loc) {",
          "new_line_content": "    return SourceLoc();",
          "content_same": false
        },
        {
          "line": 2611,
          "old_api": null,
          "new_api": "extractText",
          "old_text": null,
          "new_text": "SM.extractText(entireRange)",
          "old_line_content": "    return Loc;",
          "new_line_content": "  StringRef Buffer = SM.extractText(entireRange);",
          "content_same": false
        },
        {
          "line": 2613,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "Buffer.data()",
          "old_line_content": "  // Figure out which buffer contains this location.",
          "new_line_content": "  const char *BufStart = Buffer.data();",
          "content_same": false
        },
        {
          "line": 2617,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(StartOfLine)",
          "old_line_content": "",
          "new_line_content": "  return getSourceLoc(StartOfLine);",
          "content_same": false
        },
        {
          "line": 2626,
          "old_api": null,
          "new_api": "findBufferContainingLoc",
          "old_text": null,
          "new_text": "SM.findBufferContainingLoc(Loc)",
          "old_line_content": "}",
          "new_line_content": "  int BufferID = SM.findBufferContainingLoc(Loc);",
          "content_same": false
        },
        {
          "line": 2628,
          "old_api": null,
          "new_api": "SourceLoc",
          "old_text": null,
          "new_text": "SourceLoc()",
          "old_line_content": "SourceLoc Lexer::getLocForEndOfLine(SourceManager &SM, SourceLoc Loc) {",
          "new_line_content": "    return SourceLoc();",
          "content_same": false
        },
        {
          "line": 2640,
          "old_api": null,
          "new_api": "State",
          "old_text": null,
          "new_text": "State(Loc)",
          "old_line_content": "  LangOptions FakeLangOpts;",
          "new_line_content": "  L.restoreState(State(Loc));",
          "content_same": false
        },
        {
          "line": 2641,
          "old_api": null,
          "new_api": "skipToEndOfLine",
          "old_text": null,
          "new_text": "L.skipToEndOfLine(/*EatNewline=*/true)",
          "old_line_content": "",
          "new_line_content": "  L.skipToEndOfLine(/*EatNewline=*/true);",
          "content_same": false
        },
        {
          "line": 2642,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(L.CurPtr)",
          "old_line_content": "  // Here we return comments as tokens because either the caller skipped",
          "new_line_content": "  return getSourceLoc(L.CurPtr);",
          "content_same": false
        },
        {
          "line": 2647,
          "old_api": null,
          "new_api": "isInvalid",
          "old_text": null,
          "new_text": "Loc.isInvalid()",
          "old_line_content": "          CommentRetentionMode::ReturnAsTokens);",
          "new_line_content": "  if (Loc.isInvalid())",
          "content_same": false
        },
        {
          "line": 2651,
          "old_api": null,
          "new_api": "findBufferContainingLoc",
          "old_text": null,
          "new_text": "SM.findBufferContainingLoc(Loc)",
          "old_line_content": "}",
          "new_line_content": "  int BufferID = SM.findBufferContainingLoc(Loc);",
          "content_same": false
        },
        {
          "line": 2656,
          "old_api": null,
          "new_api": "extractText",
          "old_text": null,
          "new_text": "SM.extractText(entireRange)",
          "old_line_content": "    return \"\";",
          "new_line_content": "  StringRef Buffer = SM.extractText(entireRange);",
          "content_same": false
        },
        {
          "line": 2658,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "Buffer.data()",
          "old_line_content": "  // Figure out which buffer contains this location.",
          "new_line_content": "  const char *BufStart = Buffer.data();",
          "content_same": false
        },
        {
          "line": 2661,
          "old_api": null,
          "new_api": "findStartOfLine",
          "old_text": null,
          "new_text": "findStartOfLine(BufStart, BufStart + Offset)",
          "old_line_content": "    return \"\";",
          "new_line_content": "  const char *StartOfLine = findStartOfLine(BufStart, BufStart + Offset);",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": null,
          "new_api": "advanceIfValidStartOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidStartOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "  }",
          "new_line_content": "  bool didStart = advanceIfValidStartOfIdentifier(CurPtr, BufferEnd);",
          "content_same": false
        },
        {
          "line": 620,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(didStart && \"Unexpected start\")",
          "old_line_content": "  return Kind;",
          "new_line_content": "  assert(didStart && \"Unexpected start\");",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "void Lexer::lexIdentifier() {",
          "new_line_content": "  while (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd));",
          "content_same": false
        },
        {
          "line": 2672,
          "old_api": null,
          "new_api": "isValid",
          "old_text": null,
          "new_text": "EndLoc.isValid()",
          "old_line_content": "    ++EndOfIndentation;",
          "new_line_content": "  assert(StartLoc.isValid() && EndLoc.isValid());",
          "content_same": false
        },
        {
          "line": 626,
          "old_api": null,
          "new_api": "StringRef",
          "old_text": null,
          "new_text": "StringRef(TokStart, CurPtr-TokStart)",
          "old_line_content": "  CurPtr = TokStart;",
          "new_line_content": "  tok Kind = kindOfIdentifier(StringRef(TokStart, CurPtr-TokStart), InSILMode);",
          "content_same": false
        },
        {
          "line": 2673,
          "old_api": null,
          "new_api": "token_lower_bound",
          "old_text": null,
          "new_text": "token_lower_bound(AllTokens, StartLoc)",
          "old_line_content": "",
          "new_line_content": "  auto StartIt = token_lower_bound(AllTokens, StartLoc);",
          "content_same": false
        },
        {
          "line": 2675,
          "old_api": null,
          "new_api": "getLoc",
          "old_text": null,
          "new_text": "EndIt->getLoc()",
          "old_line_content": "}",
          "new_line_content": "  assert(StartIt->getLoc() == StartLoc && EndIt->getLoc() == EndLoc);",
          "content_same": false
        },
        {
          "line": 2676,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "AllTokens.begin()",
          "old_line_content": "",
          "new_line_content": "  return AllTokens.slice(StartIt - AllTokens.begin(), EndIt - StartIt + 1);",
          "content_same": false
        },
        {
          "line": 637,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::r_square_lit, TokStart)",
          "old_line_content": "",
          "new_line_content": "     return formToken(tok::r_square_lit, TokStart);",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": null,
          "new_api": "clang::isIdentifierHead(*tmpPtr)",
          "old_text": null,
          "new_text": "clang::isIdentifierHead(*tmpPtr)",
          "old_line_content": "  // NOTE: legacy punctuator.  Remove in the future.",
          "new_line_content": "  if (clang::isIdentifierHead(*tmpPtr)) {",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": null,
          "new_api": "StringRef",
          "old_text": null,
          "new_text": "StringRef(CurPtr, tmpPtr-CurPtr)",
          "old_line_content": "  const char *tmpPtr = CurPtr;",
          "new_line_content": "  tok Kind = llvm::StringSwitch<tok>(StringRef(CurPtr, tmpPtr-CurPtr))",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::pound, TokStart)",
          "old_line_content": "  .Case(#id, tok::pound_##id)",
          "new_line_content": "    return formToken(tok::pound, TokStart);",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(Kind, TokStart)",
          "old_line_content": "  // If we didn't find a match, then just return tok::pound.  This is highly",
          "new_line_content": "  return formToken(Kind, TokStart);",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": null,
          "new_api": "advanceIfValidStartOfOperator",
          "old_text": null,
          "new_text": "advanceIfValidStartOfOperator(CurPtr, BufferEnd)",
          "old_line_content": "  }",
          "new_line_content": "  bool didStart = advanceIfValidStartOfOperator(CurPtr, BufferEnd);",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(didStart && \"unexpected operator start\")",
          "old_line_content": "  return false;",
          "new_line_content": "  assert(didStart && \"unexpected operator start\");",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": null,
          "new_api": "StringRef",
          "old_text": null,
          "new_text": "StringRef(CurPtr, BufferEnd-CurPtr)",
          "old_line_content": "      // When parsing SIL body, '!' and '?' are special token and can't be",
          "new_line_content": "    if (Identifier::isEditorPlaceholder(StringRef(CurPtr, BufferEnd-CurPtr)) &&",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": null,
          "new_api": "rangeContainsPlaceholderEnd",
          "old_text": null,
          "new_text": "rangeContainsPlaceholderEnd(CurPtr + 2, BufferEnd)",
          "old_line_content": "      // in the middle of an operator.",
          "new_line_content": "        rangeContainsPlaceholderEnd(CurPtr + 2, BufferEnd)) {",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfOperator",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfOperator(CurPtr, BufferEnd)",
          "old_line_content": "    // '.' cannot appear in the middle of an operator unless the operator",
          "new_line_content": "  } while (advanceIfValidContinuationOfOperator(CurPtr, BufferEnd));",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": null,
          "new_api": "isLeftBound",
          "old_text": null,
          "new_text": "isLeftBound(TokStart, ContentStart)",
          "old_line_content": "        break;",
          "new_line_content": "  bool leftBound = isLeftBound(TokStart, ContentStart);",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": null,
          "new_api": "isRightBound",
          "old_text": null,
          "new_text": "isRightBound(CurPtr, leftBound, CodeCompletionPtr)",
          "old_line_content": "      }",
          "new_line_content": "  bool rightBound = isRightBound(CurPtr, leftBound, CodeCompletionPtr);",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(TokStart)",
          "old_line_content": "",
          "new_line_content": "          d.fixItInsert(getSourceLoc(TokStart), \" \");",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(TokStart+1)",
          "old_line_content": "  if (CurPtr-TokStart == 1) {",
          "new_line_content": "          d.fixItInsert(getSourceLoc(TokStart+1), \" \");",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::equal, TokStart)",
          "old_line_content": "      if (leftBound != rightBound) {",
          "new_line_content": "      return formToken(tok::equal, TokStart);",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::amp_prefix, TokStart)",
          "old_line_content": "        else",
          "new_line_content": "      return formToken(tok::amp_prefix, TokStart);",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::period, TokStart)",
          "old_line_content": "      // always emit 'tok::equal' to avoid trickle down parse errors",
          "new_line_content": "        return formToken(tok::period, TokStart);",
          "content_same": false
        },
        {
          "line": 800,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::period_prefix, TokStart)",
          "old_line_content": "    case '&':",
          "new_line_content": "        return formToken(tok::period_prefix, TokStart);",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(TokStart, diag::expected_member_name)",
          "old_line_content": "      const char *AfterHorzWhitespace = CurPtr;",
          "new_line_content": "        diagnose(TokStart, diag::expected_member_name);",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::period, TokStart)",
          "old_line_content": "      while (*AfterHorzWhitespace == ' ' || *AfterHorzWhitespace == '\\t')",
          "new_line_content": "        return formToken(tok::period, TokStart);",
          "content_same": false
        },
        {
          "line": 818,
          "old_api": null,
          "new_api": "isRightBound",
          "old_text": null,
          "new_text": "isRightBound(AfterHorzWhitespace, leftBound, CodeCompletionPtr)",
          "old_line_content": "      // First, when we are code completing \"x. <ESC>\", then make sure to return",
          "new_line_content": "      if (isRightBound(AfterHorzWhitespace, leftBound, CodeCompletionPtr) &&",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(CurPtr)",
          "old_line_content": "      }",
          "new_line_content": "          .fixItRemoveChars(getSourceLoc(CurPtr),",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(AfterHorzWhitespace)",
          "old_line_content": "",
          "new_line_content": "                            getSourceLoc(AfterHorzWhitespace));",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(TokStart, diag::expected_member_name)",
          "old_line_content": "          *AfterHorzWhitespace != '/') {",
          "new_line_content": "      diagnose(TokStart, diag::expected_member_name);",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::question_postfix, TokStart)",
          "old_line_content": "      }",
          "new_line_content": "        return formToken(tok::question_postfix, TokStart);",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::question_infix, TokStart)",
          "old_line_content": "",
          "new_line_content": "      return formToken(tok::question_infix, TokStart);",
          "content_same": false
        },
        {
          "line": 841,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::arrow, TokStart)",
          "old_line_content": "    case '?':",
          "new_line_content": "      return formToken(tok::arrow, TokStart);",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(*tokStart == '$')",
          "old_line_content": "                                 tok::oper_binary_spaced, TokStart);",
          "new_line_content": "  assert(*tokStart == '$');",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": null,
          "new_api": "getKind",
          "old_text": null,
          "new_text": "NextToken.getKind()",
          "old_line_content": "",
          "new_line_content": "  if (InSILBody && NextToken.getKind() != tok::at_sign)",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::sil_dollar, tokStart)",
          "old_line_content": "/// lexDollarIdent - Match $[0-9a-zA-Z_$]+",
          "new_line_content": "    return formToken(tok::sil_dollar, tokStart);",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": null,
          "new_api": "isDigit",
          "old_text": null,
          "new_text": "isDigit(*CurPtr)",
          "old_line_content": "",
          "new_line_content": "    if (isDigit(*CurPtr)) {",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": null,
          "new_api": "clang::isIdentifierHead(*CurPtr, /*dollar*/true)",
          "old_text": null,
          "new_text": "clang::isIdentifierHead(*CurPtr, /*dollar*/true)",
          "old_line_content": "  // name. SIL global identifiers may start with a '$', e.g. @$S1m3fooyyF.",
          "new_line_content": "    } else if (clang::isIdentifierHead(*CurPtr, /*dollar*/true)) {",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": null,
          "new_api": "isSwiftVersion3",
          "old_text": null,
          "new_text": "LangOpts.isSwiftVersion3()",
          "old_line_content": "    } else {",
          "new_line_content": "    if (!LangOpts.isSwiftVersion3()) {",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": null,
          "new_api": "fixItReplaceChars",
          "old_text": null,
          "new_text": "diagnose(tokStart, diag::standalone_dollar_identifier)\n        .fixItReplaceChars(getSourceLoc(tokStart), getSourceLoc(CurPtr), \"`$`\")",
          "old_line_content": "    }",
          "new_line_content": "      diagnose(tokStart, diag::standalone_dollar_identifier)",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(CurPtr)",
          "old_line_content": "  }",
          "new_line_content": "        .fixItReplaceChars(getSourceLoc(tokStart), getSourceLoc(CurPtr), \"`$`\");",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::identifier, tokStart)",
          "old_line_content": "  if (CurPtr == tokStart + 1) {",
          "new_line_content": "    return formToken(tok::identifier, tokStart);",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::identifier, tokStart)",
          "old_line_content": "  // We reserve $nonNumeric for persistent bindings in the debugger.",
          "new_line_content": "    return formToken(tok::identifier, tokStart);",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::dollarident, tokStart)",
          "old_line_content": "    if (!LangOpts.EnableDollarIdentifiers && !InSILBody)",
          "new_line_content": "    return formToken(tok::dollarident, tokStart);",
          "content_same": false
        },
        {
          "line": 916,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(*TokStart == '0' && \"not a hex literal\")",
          "old_line_content": "}",
          "new_line_content": "  assert(*TokStart == '0' && \"not a hex literal\");",
          "content_same": false
        },
        {
          "line": 919,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "",
          "new_line_content": "    while (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd));",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "void Lexer::lexHexNumber() {",
          "new_line_content": "    return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": null,
          "new_api": "expected_digit",
          "old_text": null,
          "new_text": "expected_digit()",
          "old_line_content": "  auto expected_digit = [&]() {",
          "new_line_content": "    return expected_digit();",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": null,
          "new_api": "isHexDigit",
          "old_text": null,
          "new_text": "isHexDigit(*CurPtr)",
          "old_line_content": "  auto expected_hex_digit = [&](const char *loc) {",
          "new_line_content": "  if (!isHexDigit(*CurPtr))",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": null,
          "new_api": "isHexDigit",
          "old_text": null,
          "new_text": "isHexDigit(*CurPtr)",
          "old_line_content": "",
          "new_line_content": "    if (!isHexDigit(*CurPtr)) {",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::integer_literal, TokStart)",
          "old_line_content": "  if (*CurPtr == '.') {",
          "new_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": null,
          "new_api": "isHexDigit",
          "old_text": null,
          "new_text": "isHexDigit(*CurPtr)",
          "old_line_content": "    ",
          "new_line_content": "    while (isHexDigit(*CurPtr) || *CurPtr == '_')",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": null,
          "new_api": "isDigit",
          "old_text": null,
          "new_text": "isDigit(PtrOnDot[1])",
          "old_line_content": "      --CurPtr;",
          "new_line_content": "      if (!isDigit(PtrOnDot[1])) {",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::integer_literal, TokStart)",
          "old_line_content": "    ",
          "new_line_content": "        return formToken(tok::integer_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 968,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CurPtr, diag::lex_expected_binary_exponent_in_hex_float_literal)",
          "old_line_content": "      ++CurPtr;",
          "new_line_content": "      diagnose(CurPtr, diag::lex_expected_binary_exponent_in_hex_float_literal);",
          "content_same": false
        },
        {
          "line": 969,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "",
          "new_line_content": "      return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": null,
          "new_api": "isDigit",
          "old_text": null,
          "new_text": "isDigit(*CurPtr)",
          "old_line_content": "  ++CurPtr;",
          "new_line_content": "  if (!isDigit(*CurPtr)) {",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": null,
          "new_api": "isDigit",
          "old_text": null,
          "new_text": "isDigit(PtrOnDot[1])",
          "old_line_content": "  ",
          "new_line_content": "    if (PtrOnDot && !isDigit(PtrOnDot[1]) && !signedExponent) {",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::integer_literal, TokStart)",
          "old_line_content": "    ++CurPtr;  // Eat the sign.",
          "new_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": null,
          "new_api": "StringRef",
          "old_text": null,
          "new_text": "StringRef(tmp, 1)",
          "old_line_content": "    }",
          "new_line_content": "      diagnose(tmp, diag::lex_invalid_digit_in_fp_exponent, StringRef(tmp, 1),",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CurPtr, diag::lex_expected_digit_in_fp_exponent)",
          "old_line_content": "    // There are 3 cases to diagnose if the exponent starts with a non-digit:",
          "new_line_content": "      diagnose(CurPtr, diag::lex_expected_digit_in_fp_exponent);",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": null,
          "new_api": "expected_digit",
          "old_text": null,
          "new_text": "expected_digit()",
          "old_line_content": "    // non-identifier (empty exponent)",
          "new_line_content": "    return expected_digit();",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "",
          "new_line_content": "  if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)) {",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": null,
          "new_api": "expected_digit",
          "old_text": null,
          "new_text": "expected_digit()",
          "old_line_content": "  ",
          "new_line_content": "    return expected_digit();",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::floating_literal, TokStart)",
          "old_line_content": "",
          "new_line_content": "  return formToken(tok::floating_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 1029,
          "old_api": null,
          "new_api": "isDigit",
          "old_text": null,
          "new_text": "isDigit(*TokStart)",
          "old_line_content": "///   integer_literal  ::= 0b[01][01_]*",
          "new_line_content": "  assert((isDigit(*TokStart) || *TokStart == '.') && \"Unexpected start\");",
          "content_same": false
        },
        {
          "line": 1032,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "///   floating_literal ::= [0-9][0-9_]*[eE][+-]?[0-9][0-9_]*",
          "new_line_content": "    while (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd));",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "///   floating_literal ::= 0x[0-9A-Fa-f][0-9A-Fa-f_]*",
          "new_line_content": "    return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": null,
          "new_api": "expected_digit",
          "old_text": null,
          "new_text": "expected_digit()",
          "old_line_content": "  auto expected_digit = [&]() {",
          "new_line_content": "    return expected_digit();",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": null,
          "new_api": "lexHexNumber",
          "old_text": null,
          "new_text": "lexHexNumber()",
          "old_line_content": "",
          "new_line_content": "    return lexHexNumber();",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": null,
          "new_api": "expected_int_digit",
          "old_text": null,
          "new_text": "expected_int_digit(CurPtr, ExpectedDigitKind::Octal)",
          "old_line_content": "",
          "new_line_content": "      return expected_int_digit(CurPtr, ExpectedDigitKind::Octal);",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "    ++CurPtr;",
          "new_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "content_same": false
        },
        {
          "line": 1056,
          "old_api": null,
          "new_api": "expected_int_digit",
          "old_text": null,
          "new_text": "expected_int_digit(tmp, ExpectedDigitKind::Octal)",
          "old_line_content": "    if (*CurPtr < '0' || *CurPtr > '7')",
          "new_line_content": "      return expected_int_digit(tmp, ExpectedDigitKind::Octal);",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::integer_literal, TokStart)",
          "old_line_content": "",
          "new_line_content": "    return formToken(tok::integer_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 1065,
          "old_api": null,
          "new_api": "expected_int_digit",
          "old_text": null,
          "new_text": "expected_int_digit(CurPtr, ExpectedDigitKind::Binary)",
          "old_line_content": "",
          "new_line_content": "      return expected_int_digit(CurPtr, ExpectedDigitKind::Binary);",
          "content_same": false
        },
        {
          "line": 1071,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "    ++CurPtr;",
          "new_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "content_same": false
        },
        {
          "line": 1072,
          "old_api": null,
          "new_api": "expected_int_digit",
          "old_text": null,
          "new_text": "expected_int_digit(tmp, ExpectedDigitKind::Binary)",
          "old_line_content": "    if (*CurPtr != '0' && *CurPtr != '1')",
          "new_line_content": "      return expected_int_digit(tmp, ExpectedDigitKind::Binary);",
          "content_same": false
        },
        {
          "line": 1074,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::integer_literal, TokStart)",
          "old_line_content": "",
          "new_line_content": "    return formToken(tok::integer_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": null,
          "new_api": "is",
          "old_text": null,
          "new_text": "NextToken.is(tok::period)",
          "old_line_content": "  // floating point value.",
          "new_line_content": "    if (!isDigit(CurPtr[1]) || NextToken.is(tok::period))",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "    // Therefore: x.0.1 is sub-tuple access, not x.float_literal",
          "new_line_content": "      if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "content_same": false
        },
        {
          "line": 1096,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::integer_literal, TokStart)",
          "old_line_content": "  } else {",
          "new_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": null,
          "new_api": "isDigit",
          "old_text": null,
          "new_text": "isDigit(*CurPtr)",
          "old_line_content": "    }",
          "new_line_content": "    while (isDigit(*CurPtr) || *CurPtr == '_')",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": null,
          "new_api": "isDigit",
          "old_text": null,
          "new_text": "isDigit(*CurPtr)",
          "old_line_content": "  }",
          "new_line_content": "    if (!isDigit(*CurPtr)) {",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "    if (*CurPtr == '+' || *CurPtr == '-')",
          "new_line_content": "      if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "content_same": false
        },
        {
          "line": 1121,
          "old_api": null,
          "new_api": "StringRef",
          "old_text": null,
          "new_text": "StringRef(tmp, 1)",
          "old_line_content": "      ++CurPtr;  // Eat the sign.",
          "new_line_content": "        diagnose(tmp, diag::lex_invalid_digit_in_fp_exponent, StringRef(tmp, 1),",
          "content_same": false
        },
        {
          "line": 1124,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CurPtr, diag::lex_expected_digit_in_fp_exponent)",
          "old_line_content": "      // There are 3 cases to diagnose if the exponent starts with a non-digit:",
          "new_line_content": "        diagnose(CurPtr, diag::lex_expected_digit_in_fp_exponent);",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": null,
          "new_api": "expected_digit",
          "old_text": null,
          "new_text": "expected_digit()",
          "old_line_content": "      // non-identifier (empty exponent)",
          "new_line_content": "      return expected_digit();",
          "content_same": false
        },
        {
          "line": 1133,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "",
          "new_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)) {",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": null,
          "new_api": "expected_digit",
          "old_text": null,
          "new_text": "expected_digit()",
          "old_line_content": "",
          "new_line_content": "      return expected_digit();",
          "content_same": false
        },
        {
          "line": 1140,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::floating_literal, TokStart)",
          "old_line_content": "    auto tmp = CurPtr;",
          "new_line_content": "  return formToken(tok::floating_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 1146,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(CurPtr[0] == '{' && \"Invalid unicode escape\")",
          "old_line_content": "  }",
          "new_line_content": "  assert(CurPtr[0] == '{' && \"Invalid unicode escape\");",
          "content_same": false
        },
        {
          "line": 1152,
          "old_api": null,
          "new_api": "isHexDigit",
          "old_text": null,
          "new_text": "isHexDigit(CurPtr[0])",
          "old_line_content": "///   hex                      ::= [0-9a-fA-F]",
          "new_line_content": "  for (; isHexDigit(CurPtr[0]); ++NumDigits)",
          "content_same": false
        },
        {
          "line": 1157,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "Diags->diagnose(CurPtr, diag::lex_invalid_u_escape_rbrace)",
          "old_line_content": "  const char *DigitStart = CurPtr;",
          "new_line_content": "      Diags->diagnose(CurPtr, diag::lex_invalid_u_escape_rbrace);",
          "content_same": false
        },
        {
          "line": 1164,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "Diags->diagnose(CurPtr, diag::lex_invalid_u_escape)",
          "old_line_content": "    if (Diags)",
          "new_line_content": "      Diags->diagnose(CurPtr, diag::lex_invalid_u_escape);",
          "content_same": false
        },
        {
          "line": 1169,
          "old_api": null,
          "new_api": "getAsInteger",
          "old_text": null,
          "new_text": "StringRef(DigitStart, NumDigits).getAsInteger(16, CharValue)",
          "old_line_content": "",
          "new_line_content": "  StringRef(DigitStart, NumDigits).getAsInteger(16, CharValue);",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": null,
          "new_api": "isPrintable",
          "old_text": null,
          "new_text": "isPrintable(CurPtr[-1])",
          "old_line_content": "unsigned Lexer::lexCharacter(const char *&CurPtr, char StopQuote,",
          "new_line_content": "      if (isPrintable(CurPtr[-1]) == 0)",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CharStart, diag::lex_unprintable_ascii_character)",
          "old_line_content": "",
          "new_line_content": "            diagnose(CharStart, diag::lex_unprintable_ascii_character);",
          "content_same": false
        },
        {
          "line": 1218,
          "old_api": null,
          "new_api": "validateUTF8CharacterAndAdvance",
          "old_text": null,
          "new_text": "validateUTF8CharacterAndAdvance(CurPtr, BufferEnd)",
          "old_line_content": "    if ((signed char)(CurPtr[-1]) >= 0) {",
          "new_line_content": "    unsigned CharValue = validateUTF8CharacterAndAdvance(CurPtr, BufferEnd);",
          "content_same": false
        },
        {
          "line": 1221,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CharStart, diag::lex_invalid_utf8)",
          "old_line_content": "          if (EmitDiagnostics)",
          "new_line_content": "      diagnose(CharStart, diag::lex_invalid_utf8);",
          "content_same": false
        },
        {
          "line": 1237,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CurPtr-1, diag::lex_nul_character)",
          "old_line_content": "      return ~0U;",
          "new_line_content": "        diagnose(CurPtr-1, diag::lex_nul_character);",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CurPtr-1, diag::lex_unterminated_string)",
          "old_line_content": "    if (CurPtr-1 != BufferEnd) {",
          "new_line_content": "      diagnose(CurPtr-1, diag::lex_unterminated_string);",
          "content_same": false
        },
        {
          "line": 1250,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CurPtr-1, diag::lex_unterminated_string)",
          "old_line_content": "    if (EmitDiagnostics)",
          "new_line_content": "      diagnose(CurPtr-1, diag::lex_unterminated_string);",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": null,
          "new_api": "maybeConsumeNewlineEscape",
          "old_text": null,
          "new_text": "maybeConsumeNewlineEscape(CurPtr, 0)",
          "old_line_content": "  case '\\\\':  // Escapes.",
          "new_line_content": "    if (MultilineString && maybeConsumeNewlineEscape(CurPtr, 0))",
          "content_same": false
        },
        {
          "line": 1265,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CurPtr, diag::lex_invalid_escape)",
          "old_line_content": "  // Escape processing.  We already ate the \"\\\".",
          "new_line_content": "      diagnose(CurPtr, diag::lex_invalid_escape);",
          "content_same": false
        },
        {
          "line": 1284,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CurPtr-1, diag::lex_unicode_escape_braces)",
          "old_line_content": "  case '\"': ++CurPtr; return '\"';",
          "new_line_content": "        diagnose(CurPtr-1, diag::lex_unicode_escape_braces);",
          "content_same": false
        },
        {
          "line": 1288,
          "old_api": null,
          "new_api": "lexUnicodeEscape",
          "old_text": null,
          "new_text": "lexUnicodeEscape(CurPtr, EmitDiagnostics ? this : nullptr)",
          "old_line_content": "  case 'u': {  //  \\u HEX HEX HEX HEX",
          "new_line_content": "    CharValue = lexUnicodeEscape(CurPtr, EmitDiagnostics ? this : nullptr);",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CharStart, diag::lex_invalid_unicode_scalar)",
          "old_line_content": "    break;",
          "new_line_content": "      diagnose(CharStart, diag::lex_invalid_unicode_scalar);",
          "content_same": false
        },
        {
          "line": 1321,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "AllowNewline.push_back(MultilineString)",
          "old_line_content": "/// This function performs brace and quote matching, keeping a stack of",
          "new_line_content": "  AllowNewline.push_back(MultilineString);",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "OpenDelimiters.empty()",
          "old_line_content": "                                                     const char *EndPtr,",
          "new_line_content": "    return !OpenDelimiters.empty() &&",
          "content_same": false
        },
        {
          "line": 1325,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "OpenDelimiters.back()",
          "old_line_content": "                                                     DiagnosticEngine *Diags,",
          "new_line_content": "           (OpenDelimiters.back() == '\"' || OpenDelimiters.back() == '\\'');",
          "content_same": false
        },
        {
          "line": 1341,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "AllowNewline.back()",
          "old_line_content": "    // On success scanning the expression body, the real lexer will be used to",
          "new_line_content": "      if (AllowNewline.back())",
          "content_same": false
        },
        {
          "line": 1348,
          "old_api": null,
          "new_api": "inStringLiteral",
          "old_text": null,
          "new_text": "inStringLiteral()",
          "old_line_content": "    case '\\r':",
          "new_line_content": "      if (!AllowNewline.back() && inStringLiteral()) {",
          "content_same": false
        },
        {
          "line": 1351,
          "old_api": null,
          "new_api": "pop_back",
          "old_text": null,
          "new_text": "OpenDelimiters.pop_back()",
          "old_line_content": "      // Will be diagnosed as an unterminated string literal.",
          "new_line_content": "          OpenDelimiters.pop_back();",
          "content_same": false
        },
        {
          "line": 1352,
          "old_api": null,
          "new_api": "pop_back",
          "old_text": null,
          "new_text": "AllowNewline.pop_back()",
          "old_line_content": "      return CurPtr-1;",
          "new_line_content": "          AllowNewline.pop_back();",
          "content_same": false
        },
        {
          "line": 1363,
          "old_api": null,
          "new_api": "inStringLiteral",
          "old_text": null,
          "new_text": "inStringLiteral()",
          "old_line_content": "        continue;",
          "new_line_content": "      if (!inStringLiteral()) {",
          "content_same": false
        },
        {
          "line": 1365,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "OpenDelimiters.push_back(CurPtr[-1])",
          "old_line_content": "",
          "new_line_content": "        OpenDelimiters.push_back(CurPtr[-1]);",
          "content_same": false
        },
        {
          "line": 1366,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "AllowNewline.push_back(isMultilineQuote)",
          "old_line_content": "      bool isMultilineQuote = (",
          "new_line_content": "        AllowNewline.push_back(isMultilineQuote);",
          "content_same": false
        },
        {
          "line": 1375,
          "old_api": null,
          "new_api": "pop_back",
          "old_text": null,
          "new_text": "AllowNewline.pop_back()",
          "old_line_content": "        continue;",
          "new_line_content": "        AllowNewline.pop_back();",
          "content_same": false
        },
        {
          "line": 1387,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "OpenDelimiters.push_back('(')",
          "old_line_content": "      continue;",
          "new_line_content": "          OpenDelimiters.push_back('(');",
          "content_same": false
        },
        {
          "line": 1405,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(CurPtr-1)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(CurPtr-1)",
          "old_line_content": "          continue;",
          "new_line_content": "          Diags->diagnose(Lexer::getSourceLoc(CurPtr-1),",
          "content_same": false
        },
        {
          "line": 1414,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "OpenDelimiters.push_back('(')",
          "old_line_content": "                          diag::lex_unterminated_string);",
          "new_line_content": "        OpenDelimiters.push_back('(');",
          "content_same": false
        },
        {
          "line": 1418,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "OpenDelimiters.empty()",
          "old_line_content": "        ",
          "new_line_content": "      if (OpenDelimiters.empty()) {",
          "content_same": false
        },
        {
          "line": 1423,
          "old_api": null,
          "new_api": "pop_back",
          "old_text": null,
          "new_text": "OpenDelimiters.pop_back()",
          "old_line_content": "      }",
          "new_line_content": "        OpenDelimiters.pop_back();",
          "content_same": false
        },
        {
          "line": 1427,
          "old_api": null,
          "new_api": "inStringLiteral",
          "old_text": null,
          "new_text": "inStringLiteral()",
          "old_line_content": "        // No outstanding open delimiters; we're done.",
          "new_line_content": "        assert(inStringLiteral());",
          "content_same": false
        },
        {
          "line": 1440,
          "old_api": null,
          "new_api": "getText",
          "old_text": null,
          "new_text": "Str.getText()",
          "old_line_content": "      continue;",
          "new_line_content": "  StringRef Bytes = Str.getText();",
          "content_same": false
        },
        {
          "line": 1442,
          "old_api": null,
          "new_api": "IsMultilineString",
          "old_text": null,
          "new_text": "Str.IsMultilineString()",
          "old_line_content": "  }",
          "new_line_content": "  if (Str.IsMultilineString())",
          "content_same": false
        },
        {
          "line": 1443,
          "old_api": null,
          "new_api": "drop_front",
          "old_text": null,
          "new_text": "Bytes.drop_front(3).drop_back(3)",
          "old_line_content": "}",
          "new_line_content": "    Bytes = Bytes.drop_front(3).drop_back(3);",
          "content_same": false
        },
        {
          "line": 1445,
          "old_api": null,
          "new_api": "drop_front",
          "old_text": null,
          "new_text": "Bytes.drop_front().drop_back()",
          "old_line_content": "/// getStringLiteralContent:",
          "new_line_content": "    Bytes = Bytes.drop_front().drop_back();",
          "content_same": false
        },
        {
          "line": 1452,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "longer.size()",
          "old_line_content": "  else",
          "new_line_content": "  while (offset < shorter.size() && offset < longer.size() && shorter[offset] == longer[offset]) {",
          "content_same": false
        },
        {
          "line": 1463,
          "old_api": null,
          "new_api": "getStringLiteralContent",
          "old_text": null,
          "new_text": "getStringLiteralContent(Str)",
          "old_line_content": "  ",
          "new_line_content": "  StringRef Bytes = getStringLiteralContent(Str);",
          "content_same": false
        },
        {
          "line": 1464,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "Bytes.end()",
          "old_line_content": "  return offset;",
          "new_line_content": "  const char *begin = Bytes.begin(), *end = Bytes.end(), *start = end;",
          "content_same": false
        },
        {
          "line": 1476,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(start)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(start)",
          "old_line_content": "  while (!sawNonWhitespace && start > begin) {",
          "new_line_content": "      auto startLoc = Lexer::getSourceLoc(start);",
          "content_same": false
        },
        {
          "line": 1477,
          "old_api": null,
          "new_api": "StringRef",
          "old_text": null,
          "new_text": "StringRef(start, end - start)",
          "old_line_content": "    switch (*--start) {",
          "new_line_content": "      auto string = StringRef(start, end - start);",
          "content_same": false
        },
        {
          "line": 1487,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(Ptr)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(Ptr)",
          "old_line_content": "      // Disallow escaped newline in the last line.",
          "new_line_content": "          auto escapeLoc = Lexer::getSourceLoc(Ptr);",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": null,
          "new_api": "fixItRemoveChars",
          "old_text": null,
          "new_text": "Diags->diagnose(escapeLoc, diag::lex_escaped_newline_at_lastline)\n              .fixItRemoveChars(escapeLoc, Lexer::getSourceLoc(LineEnd))",
          "old_line_content": "        if (*Ptr == '\\r') --Ptr;",
          "new_line_content": "            Diags->diagnose(escapeLoc, diag::lex_escaped_newline_at_lastline)",
          "content_same": false
        },
        {
          "line": 1492,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(LineEnd)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(LineEnd)",
          "old_line_content": "        auto *LineEnd = Ptr + 1;",
          "new_line_content": "              .fixItRemoveChars(escapeLoc, Lexer::getSourceLoc(LineEnd));",
          "content_same": false
        },
        {
          "line": 1496,
          "old_api": null,
          "new_api": "std::make_tuple(string, startLoc)",
          "old_text": null,
          "new_text": "std::make_tuple(string, startLoc)",
          "old_line_content": "          bool invalid = true;",
          "new_line_content": "      return std::make_tuple(string, startLoc);",
          "content_same": false
        },
        {
          "line": 1505,
          "old_api": null,
          "new_api": "fixItInsert",
          "old_text": null,
          "new_text": "Diags->diagnose(loc, diag::lex_illegal_multiline_string_end)\n    // FIXME: Should try to suggest indentation.\n      .fixItInsert(loc, \"\\n\")",
          "old_line_content": "    }",
          "new_line_content": "    Diags->diagnose(loc, diag::lex_illegal_multiline_string_end)",
          "content_same": false
        },
        {
          "line": 1510,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(end - 1)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(end - 1)",
          "old_line_content": "  ",
          "new_line_content": "  return std::make_tuple(\"\", Lexer::getSourceLoc(end - 1));",
          "content_same": false
        },
        {
          "line": 1525,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "ExpectedIndent.size()",
          "old_line_content": "static void diagnoseInvalidMultilineIndents(",
          "new_line_content": "  if (MistakeOffset >= ExpectedIndent.size()) {",
          "content_same": false
        },
        {
          "line": 1530,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "LineStarts.empty()",
          "old_line_content": "                                            SmallVector<size_t, 4> LineStarts,",
          "new_line_content": "  assert(!LineStarts.empty());",
          "content_same": false
        },
        {
          "line": 1546,
          "old_api": null,
          "new_api": "getLoc",
          "old_text": null,
          "new_text": "getLoc(LineStarts[0] + MistakeOffset)",
          "old_line_content": "      return 0;",
          "new_line_content": "  Diags->diagnose(getLoc(LineStarts[0] + MistakeOffset),",
          "content_same": false
        },
        {
          "line": 1548,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "LineStarts.size()",
          "old_line_content": "      return 1;",
          "new_line_content": "                  LineStarts.size() != 1, LineStarts.size(),",
          "content_same": false
        },
        {
          "line": 1549,
          "old_api": null,
          "new_api": "classify",
          "old_text": null,
          "new_text": "classify(Bytes[LineStarts[0] + MistakeOffset])",
          "old_line_content": "    default:",
          "new_line_content": "                  classify(Bytes[LineStarts[0] + MistakeOffset]));",
          "content_same": false
        },
        {
          "line": 1551,
          "old_api": null,
          "new_api": "getAdvancedLoc",
          "old_text": null,
          "new_text": "IndentLoc.getAdvancedLoc(MistakeOffset)",
          "old_line_content": "    }",
          "new_line_content": "  Diags->diagnose(IndentLoc.getAdvancedLoc(MistakeOffset), ",
          "content_same": false
        },
        {
          "line": 1553,
          "old_api": null,
          "new_api": "classify",
          "old_text": null,
          "new_text": "classify(ExpectedIndent[MistakeOffset])",
          "old_line_content": "  ",
          "new_line_content": "                  classify(ExpectedIndent[MistakeOffset]));",
          "content_same": false
        },
        {
          "line": 1555,
          "old_api": null,
          "new_api": "getLoc",
          "old_text": null,
          "new_text": "getLoc(LineStarts[0] + MistakeOffset)",
          "old_line_content": "                  diag::lex_multiline_string_indent_inconsistent,",
          "new_line_content": "  auto fix = Diags->diagnose(getLoc(LineStarts[0] + MistakeOffset),",
          "content_same": false
        },
        {
          "line": 1560,
          "old_api": null,
          "new_api": "substr",
          "old_text": null,
          "new_text": "ExpectedIndent.substr(0, MistakeOffset)",
          "old_line_content": "                  diag::lex_multiline_string_indent_should_match_here, ",
          "new_line_content": "  assert(ExpectedIndent.substr(0, MistakeOffset) == ",
          "content_same": false
        },
        {
          "line": 1564,
          "old_api": null,
          "new_api": "getLoc",
          "old_text": null,
          "new_text": "getLoc(line + MistakeOffset)",
          "old_line_content": "                             diag::lex_multiline_string_indent_change_line,",
          "new_line_content": "    fix.fixItReplaceChars(getLoc(line + MistakeOffset), ",
          "content_same": false
        },
        {
          "line": 1566,
          "old_api": null,
          "new_api": "substr",
          "old_text": null,
          "new_text": "ExpectedIndent.substr(MistakeOffset)",
          "old_line_content": "  ",
          "new_line_content": "                          ExpectedIndent.substr(MistakeOffset));",
          "content_same": false
        },
        {
          "line": 1576,
          "old_api": null,
          "new_api": "getMultilineTrailingIndent",
          "old_text": null,
          "new_text": "getMultilineTrailingIndent(Str, Diags)",
          "old_line_content": "}",
          "new_line_content": "  std::tie(Indent, IndentStartLoc) = getMultilineTrailingIndent(Str, Diags);",
          "content_same": false
        },
        {
          "line": 1577,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "Indent.empty()",
          "old_line_content": "",
          "new_line_content": "  if (Indent.empty())",
          "content_same": false
        },
        {
          "line": 1582,
          "old_api": null,
          "new_api": "std::numeric_limits<size_t>::max()",
          "old_text": null,
          "new_text": "std::numeric_limits<size_t>::max()",
          "old_line_content": "  StringRef Indent;",
          "new_line_content": "  size_t lastMistakeOffset = std::numeric_limits<size_t>::max();",
          "content_same": false
        },
        {
          "line": 1589,
          "old_api": null,
          "new_api": "getStringLiteralContent",
          "old_text": null,
          "new_text": "getStringLiteralContent(Str)",
          "old_line_content": "  // error, or Indent.size() if every character matched.",
          "new_line_content": "  StringRef Bytes = getStringLiteralContent(Str);",
          "content_same": false
        },
        {
          "line": 1592,
          "old_api": null,
          "new_api": "substr",
          "old_text": null,
          "new_text": "Bytes.substr(nextpos)",
          "old_line_content": "  // lastMatchLength.",
          "new_line_content": "    auto restOfBytes = Bytes.substr(nextpos);",
          "content_same": false
        },
        {
          "line": 1605,
          "old_api": null,
          "new_api": "diagnoseInvalidMultilineIndents",
          "old_text": null,
          "new_text": "diagnoseInvalidMultilineIndents(Diags, Indent, IndentStartLoc, Bytes, \n                                      linesWithLastMistakeOffset, lastMistakeOffset, \n                                      commonIndentation)",
          "old_line_content": "    }",
          "new_line_content": "      diagnoseInvalidMultilineIndents(Diags, Indent, IndentStartLoc, Bytes, ",
          "content_same": false
        },
        {
          "line": 1614,
          "old_api": null,
          "new_api": "find_first_not_of",
          "old_text": null,
          "new_text": "restOfBytes.find_first_not_of(\" \\t\")",
          "old_line_content": "                                      linesWithLastMistakeOffset, lastMistakeOffset, ",
          "new_line_content": "      auto prefixLength = restOfBytes.find_first_not_of(\" \\t\");",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": null,
          "new_api": "substr",
          "old_text": null,
          "new_text": "restOfBytes.substr(0, prefixLength)",
          "old_line_content": "                                      commonIndentation);",
          "new_line_content": "      commonIndentation = restOfBytes.substr(0, prefixLength);",
          "content_same": false
        },
        {
          "line": 1619,
          "old_api": null,
          "new_api": "commonPrefixLength",
          "old_text": null,
          "new_text": "commonPrefixLength(commonIndentation, restOfBytes)",
          "old_line_content": "      linesWithLastMistakeOffset = {};",
          "new_line_content": "      auto prefixLength = commonPrefixLength(commonIndentation, restOfBytes);",
          "content_same": false
        },
        {
          "line": 1620,
          "old_api": null,
          "new_api": "substr",
          "old_text": null,
          "new_text": "commonIndentation.substr(0, prefixLength)",
          "old_line_content": "      ",
          "new_line_content": "      commonIndentation = commonIndentation.substr(0, prefixLength);",
          "content_same": false
        },
        {
          "line": 1624,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "linesWithLastMistakeOffset.push_back(nextpos)",
          "old_line_content": "    }",
          "new_line_content": "    linesWithLastMistakeOffset.push_back(nextpos);",
          "content_same": false
        },
        {
          "line": 1638,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert((*TokStart == '\"' || *TokStart == '\\'') && \"Unexpected start\")",
          "old_line_content": "                                  commonIndentation);",
          "new_line_content": "  assert((*TokStart == '\"' || *TokStart == '\\'') && \"Unexpected start\");",
          "content_same": false
        },
        {
          "line": 1649,
          "old_api": null,
          "new_api": "fixItInsert",
          "old_text": null,
          "new_text": "diagnose(CurPtr, diag::lex_illegal_multiline_string_start)\n        .fixItInsert(Lexer::getSourceLoc(CurPtr), \"\\n\")",
          "old_line_content": "",
          "new_line_content": "      diagnose(CurPtr, diag::lex_illegal_multiline_string_start)",
          "content_same": false
        },
        {
          "line": 1650,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(CurPtr)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(CurPtr)",
          "old_line_content": "  bool wasErroneous = false, MultilineString = false;",
          "new_line_content": "        .fixItInsert(Lexer::getSourceLoc(CurPtr), \"\\n\");",
          "content_same": false
        },
        {
          "line": 1674,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(TokStart, diag::lex_unterminated_string)",
          "old_line_content": "        wasErroneous = true;",
          "new_line_content": "      diagnose(TokStart, diag::lex_unterminated_string);",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "      }",
          "new_line_content": "      return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 1678,
          "old_api": null,
          "new_api": "lexCharacter",
          "old_text": null,
          "new_text": "lexCharacter(CurPtr, *TokStart, true, MultilineString)",
          "old_line_content": "",
          "new_line_content": "    unsigned CharValue = lexCharacter(CurPtr, *TokStart, true, MultilineString);",
          "content_same": false
        },
        {
          "line": 1697,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "str.length()",
          "old_line_content": "        // Complain about single-quote string and suggest replacement with",
          "new_line_content": "        while (pos != str.length()) {",
          "content_same": false
        },
        {
          "line": 1698,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "str.at(pos)",
          "old_line_content": "        // double-quoted equivalent.",
          "new_line_content": "          if (str.at(pos) == '\\\\') {",
          "content_same": false
        },
        {
          "line": 1699,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "str.at(pos + 1)",
          "old_line_content": "        StringRef orig(TokStart, CurPtr - TokStart);",
          "new_line_content": "            if (str.at(pos + 1) == '\\'') {",
          "content_same": false
        },
        {
          "line": 1701,
          "old_api": null,
          "new_api": "replace",
          "old_text": null,
          "new_text": "str.replace(pos, 2, \"'\")",
          "old_line_content": "        replacement += '\"';",
          "new_line_content": "                str.replace(pos, 2, \"'\");",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": null,
          "new_api": "replace",
          "old_text": null,
          "new_text": "str.replace(pos, 1, \"\\\\\\\"\")",
          "old_line_content": "                // Un-escape escaped single quotes.",
          "new_line_content": "            str.replace(pos, 1, \"\\\\\\\"\");",
          "content_same": false
        },
        {
          "line": 1717,
          "old_api": null,
          "new_api": "fixItReplaceChars",
          "old_text": null,
          "new_text": "diagnose(TokStart, diag::lex_single_quote_string)\n          .fixItReplaceChars(getSourceLoc(TokStart), getSourceLoc(CurPtr),\n                             replacement)",
          "old_line_content": "            // Advance past the newly added [\"\\\"\"].",
          "new_line_content": "        diagnose(TokStart, diag::lex_single_quote_string)",
          "content_same": false
        },
        {
          "line": 1718,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(CurPtr)",
          "old_line_content": "            pos += 2;",
          "new_line_content": "          .fixItReplaceChars(getSourceLoc(TokStart), getSourceLoc(CurPtr),",
          "content_same": false
        },
        {
          "line": 1728,
          "old_api": null,
          "new_api": "validateMultilineIndents",
          "old_text": null,
          "new_text": "validateMultilineIndents(NextToken, Diags)",
          "old_line_content": "      }",
          "new_line_content": "            validateMultilineIndents(NextToken, Diags);",
          "content_same": false
        },
        {
          "line": 1735,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::string_literal, TokStart, MultilineString)",
          "old_line_content": "          if (Diags)",
          "new_line_content": "      return formToken(tok::string_literal, TokStart, MultilineString);",
          "content_same": false
        },
        {
          "line": 1760,
          "old_api": null,
          "new_api": "lexCharacter",
          "old_text": null,
          "new_text": "lexCharacter(Body, '\\0', /*EmitDiagnostics=*/false)",
          "old_line_content": "      return nullptr;",
          "new_line_content": "    unsigned CharValue = lexCharacter(Body, '\\0', /*EmitDiagnostics=*/false);",
          "content_same": false
        },
        {
          "line": 1773,
          "old_api": null,
          "new_api": "fixItReplaceChars",
          "old_text": null,
          "new_text": "diagnose(CharStart, diag::lex_invalid_curly_quote)\n            .fixItReplaceChars(getSourceLoc(CharStart), getSourceLoc(Body),\n                               \"\\\"\")",
          "old_line_content": "    // to continue.",
          "new_line_content": "        diagnose(CharStart, diag::lex_invalid_curly_quote)",
          "content_same": false
        },
        {
          "line": 1774,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(Body)",
          "old_line_content": "    if (CharValue == '\"')",
          "new_line_content": "            .fixItReplaceChars(getSourceLoc(CharStart), getSourceLoc(Body),",
          "content_same": false
        },
        {
          "line": 1790,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(CurPtr[-1] == '`' && \"Unexpected start of escaped identifier\")",
          "old_line_content": "}",
          "new_line_content": "  assert(CurPtr[-1] == '`' && \"Unexpected start of escaped identifier\");",
          "content_same": false
        },
        {
          "line": 1797,
          "old_api": null,
          "new_api": "advanceIfValidStartOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidStartOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "void Lexer::lexEscapedIdentifier() {",
          "new_line_content": "  if (advanceIfValidStartOfIdentifier(CurPtr, BufferEnd)) {",
          "content_same": false
        },
        {
          "line": 1799,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "  ",
          "new_line_content": "    while (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd));",
          "content_same": false
        },
        {
          "line": 1804,
          "old_api": null,
          "new_api": "formEscapedIdentifierToken",
          "old_text": null,
          "new_text": "formEscapedIdentifierToken(Quote)",
          "old_line_content": "  const char *IdentifierStart = CurPtr;",
          "new_line_content": "      formEscapedIdentifierToken(Quote);",
          "content_same": false
        },
        {
          "line": 1818,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::backtick, Quote)",
          "old_line_content": "  if (Quote[1] == '$' && Quote[2] == '`') {",
          "new_line_content": "  formToken(tok::backtick, Quote);",
          "content_same": false
        },
        {
          "line": 1830,
          "old_api": null,
          "new_api": "substr",
          "old_text": null,
          "new_text": "StringRef(CurPtr, BufferEnd - CurPtr).substr(termLen)",
          "old_line_content": "static const char *findConflictEnd(const char *CurPtr, const char *BufferEnd,",
          "new_line_content": "  auto restOfBuffer = StringRef(CurPtr, BufferEnd - CurPtr).substr(termLen);",
          "content_same": false
        },
        {
          "line": 1831,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "restOfBuffer.find(terminator)",
          "old_line_content": "                                   ConflictMarkerKind CMK) {",
          "new_line_content": "  size_t endPos = restOfBuffer.find(terminator);",
          "content_same": false
        },
        {
          "line": 1837,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "restOfBuffer.data()",
          "old_line_content": "  // of the conflict marker.",
          "new_line_content": "      return restOfBuffer.data() + endPos;",
          "content_same": false
        },
        {
          "line": 1840,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "restOfBuffer.find(terminator)",
          "old_line_content": "  while (endPos != StringRef::npos) {",
          "new_line_content": "    endPos = restOfBuffer.find(terminator);",
          "content_same": false
        },
        {
          "line": 1854,
          "old_api": null,
          "new_api": "startswith",
          "old_text": null,
          "new_text": "restOfBuffer.startswith(\">>>> \")",
          "old_line_content": "  const char *Ptr = CurPtr - 1;",
          "new_line_content": "  if (!restOfBuffer.startswith(\"<<<<<<< \") && !restOfBuffer.startswith(\">>>> \"))",
          "content_same": false
        },
        {
          "line": 1859,
          "old_api": null,
          "new_api": "findConflictEnd",
          "old_text": null,
          "new_text": "findConflictEnd(Ptr, BufferEnd, Kind)",
          "old_line_content": "  ",
          "new_line_content": "  if (const char *End = findConflictEnd(Ptr, BufferEnd, Kind)) {",
          "content_same": false
        },
        {
          "line": 1861,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CurPtr, diag::lex_conflict_marker_in_file)",
          "old_line_content": "  StringRef restOfBuffer(Ptr, BufferEnd - Ptr);",
          "new_line_content": "    diagnose(CurPtr, diag::lex_conflict_marker_in_file);",
          "content_same": false
        },
        {
          "line": 1866,
          "old_api": null,
          "new_api": "skipToEndOfLine",
          "old_text": null,
          "new_text": "skipToEndOfLine(EatNewline)",
          "old_line_content": "                                        : ConflictMarkerKind::Perforce;",
          "new_line_content": "      skipToEndOfLine(EatNewline);",
          "content_same": false
        },
        {
          "line": 1878,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(Tmp, BufferEnd)",
          "old_line_content": "  ",
          "new_line_content": "  if (advanceIfValidContinuationOfIdentifier(Tmp, BufferEnd)) {",
          "content_same": false
        },
        {
          "line": 1882,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CurPtr - 1, diag::lex_invalid_identifier_start_character)",
          "old_line_content": "",
          "new_line_content": "      diagnose(CurPtr - 1, diag::lex_invalid_identifier_start_character);",
          "content_same": false
        },
        {
          "line": 1884,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(Tmp, BufferEnd)",
          "old_line_content": "  const char *Tmp = CurPtr - 1;",
          "new_line_content": "    while (advanceIfValidContinuationOfIdentifier(Tmp, BufferEnd))",
          "content_same": false
        },
        {
          "line": 1891,
          "old_api": null,
          "new_api": "validateUTF8CharacterAndAdvance",
          "old_text": null,
          "new_text": "validateUTF8CharacterAndAdvance(Tmp, BufferEnd)",
          "old_line_content": "    }",
          "new_line_content": "  uint32_t Codepoint = validateUTF8CharacterAndAdvance(Tmp, BufferEnd);",
          "content_same": false
        },
        {
          "line": 1893,
          "old_api": null,
          "new_api": "fixItReplaceChars",
          "old_text": null,
          "new_text": "diagnose(CurPtr - 1, diag::lex_invalid_utf8)\n        .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \" \")",
          "old_line_content": "      ;",
          "new_line_content": "    diagnose(CurPtr - 1, diag::lex_invalid_utf8)",
          "content_same": false
        },
        {
          "line": 1894,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(Tmp)",
          "old_line_content": "    CurPtr = Tmp;",
          "new_line_content": "        .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \" \");",
          "content_same": false
        },
        {
          "line": 1900,
          "old_api": null,
          "new_api": "fixItReplaceChars",
          "old_text": null,
          "new_text": "diagnose(CurPtr - 1, diag::lex_invalid_curly_quote)\n          .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \"\\\"\")",
          "old_line_content": "  if (Codepoint == ~0U) {",
          "new_line_content": "      diagnose(CurPtr - 1, diag::lex_invalid_curly_quote)",
          "content_same": false
        },
        {
          "line": 1910,
          "old_api": null,
          "new_api": "findEndOfCurlyQuoteStringLiteral",
          "old_text": null,
          "new_text": "findEndOfCurlyQuoteStringLiteral(Tmp, EmitDiagnosticsIfToken)",
          "old_line_content": "    }",
          "new_line_content": "            findEndOfCurlyQuoteStringLiteral(Tmp, EmitDiagnosticsIfToken))",
          "content_same": false
        },
        {
          "line": 1919,
          "old_api": null,
          "new_api": "fixItReplaceChars",
          "old_text": null,
          "new_text": "diagnose(CurPtr - 1, diag::lex_invalid_curly_quote)\n          .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(EndPtr),\n                             \"\\\"\")",
          "old_line_content": "      Tmp = Tmp2;",
          "new_line_content": "      diagnose(CurPtr - 1, diag::lex_invalid_curly_quote)",
          "content_same": false
        },
        {
          "line": 1920,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(EndPtr)",
          "old_line_content": "",
          "new_line_content": "          .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(EndPtr),",
          "content_same": false
        },
        {
          "line": 1932,
          "old_api": null,
          "new_api": "confusable::tryConvertConfusableCharacterToASCII(Codepoint)",
          "old_text": null,
          "new_text": "confusable::tryConvertConfusableCharacterToASCII(Codepoint)",
          "old_line_content": "    return true;",
          "new_line_content": "           confusable::tryConvertConfusableCharacterToASCII(Codepoint))) {",
          "content_same": false
        },
        {
          "line": 1938,
          "old_api": null,
          "new_api": "fixItReplaceChars",
          "old_text": null,
          "new_text": "diagnose(CurPtr - 1, diag::lex_confusable_character, ConfusedChar,\n             ExpectedChar)\n        .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp),\n                           ExpectedChar)",
          "old_line_content": "  char ExpectedCodepoint;",
          "new_line_content": "    diagnose(CurPtr - 1, diag::lex_confusable_character, ConfusedChar,",
          "content_same": false
        },
        {
          "line": 1949,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(Ptr != nullptr && *Ptr == 0)",
          "old_line_content": "                           ExpectedChar);",
          "new_line_content": "  assert(Ptr != nullptr && *Ptr == 0);",
          "content_same": false
        },
        {
          "line": 1960,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(CurPtr[-1] == '<' && CurPtr[0] == '#')",
          "old_line_content": "  }",
          "new_line_content": "  assert(CurPtr[-1] == '<' && CurPtr[0] == '#');",
          "content_same": false
        },
        {
          "line": 1971,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(TokStart, diag::lex_editor_placeholder_in_playground)",
          "old_line_content": "    if (*Ptr == '\\n')",
          "new_line_content": "        diagnose(TokStart, diag::lex_editor_placeholder_in_playground);",
          "content_same": false
        },
        {
          "line": 1973,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(TokStart, diag::lex_editor_placeholder)",
          "old_line_content": "    if (Ptr[0] == '<' && Ptr[1] == '#')",
          "new_line_content": "        diagnose(TokStart, diag::lex_editor_placeholder);",
          "content_same": false
        },
        {
          "line": 1976,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::identifier, TokStart)",
          "old_line_content": "      // Found it. Flag it as error (or warning, if in playground mode) for the",
          "new_line_content": "      formToken(tok::identifier, TokStart);",
          "content_same": false
        },
        {
          "line": 1982,
          "old_api": null,
          "new_api": "lexOperatorIdentifier",
          "old_text": null,
          "new_text": "lexOperatorIdentifier()",
          "old_line_content": "      }",
          "new_line_content": "  lexOperatorIdentifier();",
          "content_same": false
        },
        {
          "line": 1991,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "TempString.clear()",
          "old_line_content": "}",
          "new_line_content": "  TempString.clear();",
          "content_same": false
        },
        {
          "line": 1995,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "Bytes.begin()",
          "old_line_content": "                                         bool IsFirstSegment,",
          "new_line_content": "  const char *BytesPtr = Bytes.begin();",
          "content_same": false
        },
        {
          "line": 1997,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "Bytes.end()",
          "old_line_content": "                                         unsigned IndentToStrip) {",
          "new_line_content": "  while (BytesPtr < Bytes.end()) {",
          "content_same": false
        },
        {
          "line": 2008,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "Bytes.end()",
          "old_line_content": "    // Multiline string line ending normalization and indent stripping.",
          "new_line_content": "      if (IsLastSegment && BytesPtr == Bytes.end())",
          "content_same": false
        },
        {
          "line": 2017,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "TempString.push_back(CurChar)",
          "old_line_content": "        stripNewline = true;",
          "new_line_content": "      TempString.push_back(CurChar);",
          "content_same": false
        },
        {
          "line": 2029,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "TempString.push_back('\\0')",
          "old_line_content": "    // Invalid escapes are accepted by the lexer but diagnosed as an error.  We",
          "new_line_content": "    case '0': TempString.push_back('\\0'); continue;",
          "content_same": false
        },
        {
          "line": 2030,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "TempString.push_back('\\n')",
          "old_line_content": "    // just ignore them here.",
          "new_line_content": "    case 'n': TempString.push_back('\\n'); continue;",
          "content_same": false
        },
        {
          "line": 2031,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "TempString.push_back('\\r')",
          "old_line_content": "    unsigned CharValue = 0; // Unicode character value for \\x, \\u, \\U.",
          "new_line_content": "    case 'r': TempString.push_back('\\r'); continue;",
          "content_same": false
        },
        {
          "line": 2032,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "TempString.push_back('\\t')",
          "old_line_content": "    switch (*BytesPtr++) {",
          "new_line_content": "    case 't': TempString.push_back('\\t'); continue;",
          "content_same": false
        },
        {
          "line": 2033,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "TempString.push_back('\"')",
          "old_line_content": "    default:",
          "new_line_content": "    case '\"': TempString.push_back('\"'); continue;",
          "content_same": false
        },
        {
          "line": 2034,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "TempString.push_back('\\'')",
          "old_line_content": "      continue;   // Invalid escape, ignore it.",
          "new_line_content": "    case '\\'': TempString.push_back('\\''); continue;",
          "content_same": false
        },
        {
          "line": 2035,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "TempString.push_back('\\\\')",
          "old_line_content": "          ",
          "new_line_content": "    case '\\\\': TempString.push_back('\\\\'); continue;",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2054,
          "old_api": "llvm_unreachable",
          "new_api": null,
          "old_text": "llvm_unreachable(\"string contained interpolated segments\")",
          "new_text": null,
          "old_line_content": "      llvm_unreachable(\"string contained interpolated segments\");",
          "new_line_content": "      // Ignore invalid escapes.",
          "content_same": false
        },
        {
          "line": 2061,
          "old_api": "lexUnicodeEscape",
          "new_api": null,
          "old_text": "lexUnicodeEscape(BytesPtr, /*no diagnostics*/nullptr)",
          "new_text": null,
          "old_line_content": "      CharValue = lexUnicodeEscape(BytesPtr, /*no diagnostics*/nullptr);",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 2068,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "TempString.push_back(CharValue)",
          "new_text": null,
          "old_line_content": "      TempString.push_back(CharValue);",
          "new_line_content": "  // forms (in a valid string).",
          "content_same": false
        },
        {
          "line": 2077,
          "old_api": "size",
          "new_api": null,
          "old_text": "Bytes.size()",
          "new_text": null,
          "old_line_content": "  if (TempString.size() == Bytes.size()) {",
          "new_line_content": "              const Token &Str,",
          "content_same": false
        },
        {
          "line": 2078,
          "old_api": "clear",
          "new_api": null,
          "old_text": "TempString.clear()",
          "new_text": null,
          "old_line_content": "    TempString.clear();",
          "new_line_content": "              SmallVectorImpl<StringSegment> &Segments,",
          "content_same": false
        },
        {
          "line": 2081,
          "old_api": "size",
          "new_api": null,
          "old_text": "TempString.size()",
          "new_text": null,
          "old_line_content": "  return StringRef(TempString.begin(), TempString.size());",
          "new_line_content": "  // Get the bytes behind the string literal, dropping any double quotes.",
          "content_same": false
        },
        {
          "line": 2088,
          "old_api": "is",
          "new_api": null,
          "old_text": "Str.is(tok::string_literal)",
          "new_text": null,
          "old_line_content": "  assert(Str.is(tok::string_literal));",
          "new_line_content": "  if (MultilineString)",
          "content_same": false
        },
        {
          "line": 2094,
          "old_api": "IsMultilineString",
          "new_api": null,
          "old_text": "Str.IsMultilineString()",
          "new_text": null,
          "old_line_content": "  bool MultilineString = Str.IsMultilineString(), IsFirstSegment = true;",
          "new_line_content": "  // range check subscripting on the StringRef.",
          "content_same": false
        },
        {
          "line": 2103,
          "old_api": "begin",
          "new_api": null,
          "old_text": "Bytes.begin()",
          "new_text": null,
          "old_line_content": "  const char *SegmentStartPtr = Bytes.begin();",
          "new_line_content": "    if (*BytesPtr++ != '(')",
          "content_same": false
        },
        {
          "line": 2106,
          "old_api": "end",
          "new_api": null,
          "old_text": "Bytes.end()",
          "new_text": null,
          "old_line_content": "  while (BytesPtr != Bytes.end()) {",
          "new_line_content": "    // String interpolation.",
          "content_same": false
        },
        {
          "line": 2118,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(SegmentStartPtr)",
          "new_text": null,
          "old_line_content": "        StringSegment::getLiteral(getSourceLoc(SegmentStartPtr),",
          "new_line_content": "                                                        Diags, MultilineString);",
          "content_same": false
        },
        {
          "line": 2127,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(*End == ')' && \"invalid string literal interpolations should\"\n           \" not be returned as string literals\")",
          "new_text": null,
          "old_line_content": "    assert(*End == ')' && \"invalid string literal interpolations should\"",
          "new_line_content": "    // Reset the beginning of the segment to the string that remains to be",
          "content_same": false
        },
        {
          "line": 2140,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "Segments.push_back(\n      StringSegment::getLiteral(getSourceLoc(SegmentStartPtr),\n                                Bytes.end()-SegmentStartPtr,\n                                IsFirstSegment, true, IndentToStrip))",
          "new_text": null,
          "old_line_content": "  Segments.push_back(",
          "new_line_content": "// Main Lexer Loop",
          "content_same": false
        },
        {
          "line": 2141,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(SegmentStartPtr)",
          "new_text": null,
          "old_line_content": "      StringSegment::getLiteral(getSourceLoc(SegmentStartPtr),",
          "new_line_content": "//===----------------------------------------------------------------------===//",
          "content_same": false
        },
        {
          "line": 2142,
          "old_api": "end",
          "new_api": null,
          "old_text": "Bytes.end()",
          "new_text": null,
          "old_line_content": "                                Bytes.end()-SegmentStartPtr,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2152,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(CurPtr >= BufferStart &&\n         CurPtr <= BufferEnd && \"Current pointer out of range!\")",
          "new_text": null,
          "old_line_content": "  assert(CurPtr >= BufferStart &&",
          "new_line_content": "      size_t BOMLen = ContentStart - BufferStart;",
          "content_same": false
        },
        {
          "line": 2156,
          "old_api": "clear",
          "new_api": null,
          "old_text": "TrailingTrivia.clear()",
          "new_text": null,
          "old_line_content": "  TrailingTrivia.clear();",
          "new_line_content": "      CurPtr += BOMLen;",
          "content_same": false
        },
        {
          "line": 2161,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(BOMLen == 3 && \"UTF-8 BOM is 3 bytes\")",
          "new_text": null,
          "old_line_content": "      assert(BOMLen == 3 && \"UTF-8 BOM is 3 bytes\");",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2163,
          "old_api": "TriviaPiece::garbageText({CurPtr, BOMLen})",
          "new_api": null,
          "old_text": "TriviaPiece::garbageText({CurPtr, BOMLen})",
          "new_text": null,
          "old_line_content": "      LeadingTrivia.push_back(TriviaPiece::garbageText({CurPtr, BOMLen}));",
          "new_line_content": "  // Remember where we started so that we can find the comment range.",
          "content_same": false
        },
        {
          "line": 2166,
          "old_api": "setAtStartOfLine",
          "new_api": null,
          "old_text": "NextToken.setAtStartOfLine(true)",
          "new_text": null,
          "old_line_content": "    NextToken.setAtStartOfLine(true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2168,
          "old_api": "setAtStartOfLine",
          "new_api": null,
          "old_text": "NextToken.setAtStartOfLine(false)",
          "new_text": null,
          "old_line_content": "    NextToken.setAtStartOfLine(false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2183,
          "old_api": "advanceIfValidStartOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidStartOfIdentifier(Tmp, BufferEnd)",
          "new_text": null,
          "old_line_content": "    if (advanceIfValidStartOfIdentifier(Tmp, BufferEnd))",
          "new_line_content": "        ShouldTokenize &&",
          "content_same": false
        },
        {
          "line": 2184,
          "old_api": "lexIdentifier",
          "new_api": null,
          "old_text": "lexIdentifier()",
          "new_text": null,
          "old_line_content": "      return lexIdentifier();",
          "new_line_content": "        \"Invalid UTF-8 sequence should be eaten by lexTrivia as LeadingTrivia\");",
          "content_same": false
        },
        {
          "line": 2187,
          "old_api": "lexOperatorIdentifier",
          "new_api": null,
          "old_text": "lexOperatorIdentifier()",
          "new_text": null,
          "old_line_content": "      return lexOperatorIdentifier();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2189,
          "old_api": "lexUnknown",
          "new_api": null,
          "old_text": "lexUnknown(/*EmitDiagnosticsIfToken=*/true)",
          "new_text": null,
          "old_line_content": "    bool ShouldTokenize = lexUnknown(/*EmitDiagnosticsIfToken=*/true);",
          "new_line_content": "  case '\\n':",
          "content_same": false
        },
        {
          "line": 2190,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(\n        ShouldTokenize &&\n        \"Invalid UTF-8 sequence should be eaten by lexTrivia as LeadingTrivia\")",
          "new_text": null,
          "old_line_content": "    assert(",
          "new_line_content": "  case '\\r':",
          "content_same": false
        },
        {
          "line": 2194,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::unknown, TokStart);",
          "new_line_content": "  case '\\t':",
          "content_same": false
        },
        {
          "line": 2199,
          "old_api": "llvm_unreachable",
          "new_api": null,
          "old_text": "llvm_unreachable(\"Newlines should be eaten by lexTrivia as LeadingTrivia\")",
          "new_text": null,
          "old_line_content": "    llvm_unreachable(\"Newlines should be eaten by lexTrivia as LeadingTrivia\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2205,
          "old_api": "llvm_unreachable",
          "new_api": null,
          "old_text": "llvm_unreachable(\n        \"Whitespaces should be eaten by lexTrivia as LeadingTrivia\")",
          "new_text": null,
          "old_line_content": "    llvm_unreachable(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2210,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CurPtr-1, diag::lex_utf16_bom_marker)",
          "new_text": null,
          "old_line_content": "    diagnose(CurPtr-1, diag::lex_utf16_bom_marker);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2212,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::unknown, TokStart);",
          "new_line_content": "      // This is the real end of the buffer.",
          "content_same": false
        },
        {
          "line": 2215,
          "old_api": "getNulCharacterKind",
          "new_api": null,
          "old_text": "getNulCharacterKind(CurPtr - 1)",
          "new_text": null,
          "old_line_content": "    switch (getNulCharacterKind(CurPtr - 1)) {",
          "new_line_content": "      // Return EOF.",
          "content_same": false
        },
        {
          "line": 2217,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::code_complete, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::code_complete, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2227,
          "old_api": "llvm_unreachable",
          "new_api": null,
          "old_text": "llvm_unreachable(\n          \"Embedded nul should be eaten by lexTrivia as LeadingTrivia\")",
          "new_text": null,
          "old_line_content": "      llvm_unreachable(",
          "new_line_content": "     // Remove in the future.",
          "content_same": false
        },
        {
          "line": 2231,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::at_sign, TokStart)",
          "new_text": null,
          "old_line_content": "  case '@': return formToken(tok::at_sign, TokStart);",
          "new_line_content": "       // directly.  The '#' will be lexed as part of the object literal",
          "content_same": false
        },
        {
          "line": 2232,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::l_brace, TokStart)",
          "new_text": null,
          "old_line_content": "  case '{': return formToken(tok::l_brace, TokStart);",
          "new_line_content": "       // keyword token itself.",
          "content_same": false
        },
        {
          "line": 2246,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::r_brace, TokStart)",
          "new_text": null,
          "old_line_content": "  case '}': return formToken(tok::r_brace, TokStart);",
          "new_line_content": "  case '\\\\':",
          "content_same": false
        },
        {
          "line": 2249,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::r_paren, TokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::r_paren, TokStart);",
          "new_line_content": "  case '#':",
          "content_same": false
        },
        {
          "line": 2251,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::comma, TokStart)",
          "new_text": null,
          "old_line_content": "  case ',': return formToken(tok::comma, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2252,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::semi, TokStart)",
          "new_text": null,
          "old_line_content": "  case ';': return formToken(tok::semi, TokStart);",
          "new_line_content": "      // Operator characters.",
          "content_same": false
        },
        {
          "line": 2253,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::colon, TokStart)",
          "new_text": null,
          "old_line_content": "  case ':': return formToken(tok::colon, TokStart);",
          "new_line_content": "  case '/':",
          "content_same": false
        },
        {
          "line": 2258,
          "old_api": "lexHash",
          "new_api": null,
          "old_text": "lexHash()",
          "new_text": null,
          "old_line_content": "    return lexHash();",
          "new_line_content": "             \"Non token comment should be eaten by lexTrivia as LeadingTrivia\");",
          "content_same": false
        },
        {
          "line": 2263,
          "old_api": "skipSlashSlashComment",
          "new_api": null,
          "old_text": "skipSlashSlashComment(/*EatNewline=*/true)",
          "new_text": null,
          "old_line_content": "      skipSlashSlashComment(/*EatNewline=*/true);",
          "new_line_content": "      SeenComment = true;",
          "content_same": false
        },
        {
          "line": 2265,
          "old_api": "isKeepingComments",
          "new_api": null,
          "old_text": "isKeepingComments()",
          "new_text": null,
          "old_line_content": "      assert(isKeepingComments() &&",
          "new_line_content": "             \"Non token comment should be eaten by lexTrivia as LeadingTrivia\");",
          "content_same": false
        },
        {
          "line": 2267,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::comment, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::comment, TokStart);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2270,
          "old_api": "skipSlashStarComment",
          "new_api": null,
          "old_text": "skipSlashStarComment()",
          "new_text": null,
          "old_line_content": "      skipSlashStarComment();",
          "new_line_content": "    // Lex %[0-9a-zA-Z_]+ as a local SIL value",
          "content_same": false
        },
        {
          "line": 2272,
          "old_api": "isKeepingComments",
          "new_api": null,
          "old_text": "isKeepingComments()",
          "new_text": null,
          "old_line_content": "      assert(isKeepingComments() &&",
          "new_line_content": "      do {",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": "clang::isIdentifierBody(CurPtr[0])",
          "new_api": null,
          "old_text": "clang::isIdentifierBody(CurPtr[0])",
          "new_text": null,
          "old_line_content": "    if (InSILBody && clang::isIdentifierBody(CurPtr[0])) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2286,
          "old_api": "lexOperatorIdentifier",
          "new_api": null,
          "old_text": "lexOperatorIdentifier()",
          "new_text": null,
          "old_line_content": "    return lexOperatorIdentifier();",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": "isLeftBound",
          "new_api": null,
          "old_text": "isLeftBound(TokStart, ContentStart)",
          "new_text": null,
          "old_line_content": "    if (isLeftBound(TokStart, ContentStart))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2292,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::exclaim_postfix, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::exclaim_postfix, TokStart);",
          "new_line_content": "  case '<':",
          "content_same": false
        },
        {
          "line": 2293,
          "old_api": "lexOperatorIdentifier",
          "new_api": null,
          "old_text": "lexOperatorIdentifier()",
          "new_text": null,
          "old_line_content": "    return lexOperatorIdentifier();",
          "new_line_content": "    if (CurPtr[0] == '#')",
          "content_same": false
        },
        {
          "line": 2297,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::question_postfix, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::question_postfix, TokStart);",
          "new_line_content": "  case '>':",
          "content_same": false
        },
        {
          "line": 2304,
          "old_api": "lexOperatorIdentifier",
          "new_api": null,
          "old_text": "lexOperatorIdentifier()",
          "new_text": null,
          "old_line_content": "    return lexOperatorIdentifier();",
          "new_line_content": "  case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G':",
          "content_same": false
        },
        {
          "line": 2306,
          "old_api": "lexOperatorIdentifier",
          "new_api": null,
          "old_text": "lexOperatorIdentifier()",
          "new_text": null,
          "old_line_content": "    return lexOperatorIdentifier();",
          "new_line_content": "  case 'O': case 'P': case 'Q': case 'R': case 'S': case 'T': case 'U':",
          "content_same": false
        },
        {
          "line": 2310,
          "old_api": "lexOperatorIdentifier",
          "new_api": null,
          "old_text": "lexOperatorIdentifier()",
          "new_text": null,
          "old_line_content": "    return lexOperatorIdentifier();",
          "new_line_content": "  case 'o': case 'p': case 'q': case 'r': case 's': case 't': case 'u':",
          "content_same": false
        },
        {
          "line": 2321,
          "old_api": "lexIdentifier",
          "new_api": null,
          "old_text": "lexIdentifier()",
          "new_text": null,
          "old_line_content": "    return lexIdentifier();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2328,
          "old_api": "lexNumber",
          "new_api": null,
          "old_text": "lexNumber()",
          "new_text": null,
          "old_line_content": "    return lexNumber();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2332,
          "old_api": "lexStringLiteral",
          "new_api": null,
          "old_text": "lexStringLiteral()",
          "new_text": null,
          "old_line_content": "    return lexStringLiteral();",
          "new_line_content": "  // Don't try to do anything with an invalid location.",
          "content_same": false
        },
        {
          "line": 2335,
          "old_api": "lexEscapedIdentifier",
          "new_api": null,
          "old_text": "lexEscapedIdentifier()",
          "new_text": null,
          "old_line_content": "    return lexEscapedIdentifier();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2341,
          "old_api": "isValid",
          "new_api": null,
          "old_text": "Loc.isValid()",
          "new_text": null,
          "old_line_content": "  if (!Loc.isValid())",
          "new_line_content": "  // Use fake language options; language options only affect validity",
          "content_same": false
        },
        {
          "line": 2342,
          "old_api": "Token",
          "new_api": null,
          "old_text": "Token()",
          "new_text": null,
          "old_line_content": "    return Token();",
          "new_line_content": "  // and the exact token produced.",
          "content_same": false
        },
        {
          "line": 2345,
          "old_api": "findBufferContainingLoc",
          "new_api": null,
          "old_text": "SM.findBufferContainingLoc(Loc)",
          "new_text": null,
          "old_line_content": "  int BufferID = SM.findBufferContainingLoc(Loc);",
          "new_line_content": "  // Here we return comments as tokens because either the caller skipped",
          "content_same": false
        },
        {
          "line": 2347,
          "old_api": "Token",
          "new_api": null,
          "old_text": "Token()",
          "new_text": null,
          "old_line_content": "    return Token();",
          "new_line_content": "  // (making this option irrelevant), or the caller lexed comments and",
          "content_same": false
        },
        {
          "line": 2359,
          "old_api": "State",
          "new_api": null,
          "old_text": "State(Loc)",
          "new_text": null,
          "old_line_content": "  L.restoreState(State(Loc));",
          "new_line_content": "  switch ((signed char)*CurPtr++) {",
          "content_same": false
        },
        {
          "line": 2360,
          "old_api": "peekNextToken",
          "new_api": null,
          "old_text": "L.peekNextToken()",
          "new_text": null,
          "old_line_content": "  return L.peekNextToken();",
          "new_line_content": "  case '\\n':",
          "content_same": false
        },
        {
          "line": 2372,
          "old_api": "TriviaPiece::newlines(1)",
          "new_api": null,
          "old_text": "TriviaPiece::newlines(1)",
          "new_text": null,
          "old_line_content": "    Pieces.appendOrSquash(TriviaPiece::newlines(1));",
          "new_line_content": "      ++CurPtr;",
          "content_same": false
        },
        {
          "line": 2377,
          "old_api": "setAtStartOfLine",
          "new_api": null,
          "old_text": "NextToken.setAtStartOfLine(true)",
          "new_text": null,
          "old_line_content": "    NextToken.setAtStartOfLine(true);",
          "new_line_content": "  case ' ':",
          "content_same": false
        },
        {
          "line": 2379,
          "old_api": "TriviaPiece::carriageReturnLineFeeds(1)",
          "new_api": null,
          "old_text": "TriviaPiece::carriageReturnLineFeeds(1)",
          "new_text": null,
          "old_line_content": "      Pieces.appendOrSquash(TriviaPiece::carriageReturnLineFeeds(1));",
          "new_line_content": "    goto Restart;",
          "content_same": false
        },
        {
          "line": 2382,
          "old_api": "TriviaPiece::carriageReturns(1)",
          "new_api": null,
          "old_text": "TriviaPiece::carriageReturns(1)",
          "new_text": null,
          "old_line_content": "      Pieces.appendOrSquash(TriviaPiece::carriageReturns(1));",
          "new_line_content": "    goto Restart;",
          "content_same": false
        },
        {
          "line": 2386,
          "old_api": "TriviaPiece::spaces(1)",
          "new_api": null,
          "old_text": "TriviaPiece::spaces(1)",
          "new_text": null,
          "old_line_content": "    Pieces.appendOrSquash(TriviaPiece::spaces(1));",
          "new_line_content": "  case '\\f':",
          "content_same": false
        },
        {
          "line": 2389,
          "old_api": "TriviaPiece::tabs(1)",
          "new_api": null,
          "old_text": "TriviaPiece::tabs(1)",
          "new_text": null,
          "old_line_content": "    Pieces.appendOrSquash(TriviaPiece::tabs(1));",
          "new_line_content": "  case '/':",
          "content_same": false
        },
        {
          "line": 2392,
          "old_api": "TriviaPiece::verticalTabs(1)",
          "new_api": null,
          "old_text": "TriviaPiece::verticalTabs(1)",
          "new_text": null,
          "old_line_content": "    Pieces.appendOrSquash(TriviaPiece::verticalTabs(1));",
          "new_line_content": "      // Don't try to lex comments here if we are lexing comments as Tokens.",
          "content_same": false
        },
        {
          "line": 2395,
          "old_api": "TriviaPiece::formfeeds(1)",
          "new_api": null,
          "old_text": "TriviaPiece::formfeeds(1)",
          "new_text": null,
          "old_line_content": "    Pieces.appendOrSquash(TriviaPiece::formfeeds(1));",
          "new_line_content": "      // '// ...' comment.",
          "content_same": false
        },
        {
          "line": 2406,
          "old_api": "skipSlashSlashComment",
          "new_api": null,
          "old_text": "skipSlashSlashComment(/*EatNewline=*/false)",
          "new_text": null,
          "old_line_content": "      skipSlashSlashComment(/*EatNewline=*/false);",
          "new_line_content": "      SeenComment = true;",
          "content_same": false
        },
        {
          "line": 2409,
          "old_api": "TriviaPiece::docLineComment({TriviaStart, Length})",
          "new_api": null,
          "old_text": "TriviaPiece::docLineComment({TriviaStart, Length})",
          "new_text": null,
          "old_line_content": "                           ? TriviaPiece::docLineComment({TriviaStart, Length})",
          "new_line_content": "      size_t Length = CurPtr - TriviaStart;",
          "content_same": false
        },
        {
          "line": 2416,
          "old_api": "skipSlashStarComment",
          "new_api": null,
          "old_text": "skipSlashStarComment()",
          "new_text": null,
          "old_line_content": "      skipSlashStarComment();",
          "new_line_content": "  case '#':",
          "content_same": false
        },
        {
          "line": 2418,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "Pieces.push_back(isDocComment\n                           ? TriviaPiece::docBlockComment({TriviaStart, Length})\n                           : TriviaPiece::blockComment({TriviaStart, Length}))",
          "new_text": null,
          "old_line_content": "      Pieces.push_back(isDocComment",
          "new_line_content": "      // Hashbang '#!/path/to/swift'.",
          "content_same": false
        },
        {
          "line": 2419,
          "old_api": "TriviaPiece::docBlockComment({TriviaStart, Length})",
          "new_api": null,
          "old_text": "TriviaPiece::docBlockComment({TriviaStart, Length})",
          "new_text": null,
          "old_line_content": "                           ? TriviaPiece::docBlockComment({TriviaStart, Length})",
          "new_line_content": "      --CurPtr;",
          "content_same": false
        },
        {
          "line": 2428,
          "old_api": "getHashbangBufferID",
          "new_api": null,
          "old_text": "SourceMgr.getHashbangBufferID()",
          "new_text": null,
          "old_line_content": "      if (BufferID != SourceMgr.getHashbangBufferID())",
          "new_line_content": "  case '<':",
          "content_same": false
        },
        {
          "line": 2429,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(TriviaStart, diag::lex_hashbang_not_allowed)",
          "new_text": null,
          "old_line_content": "        diagnose(TriviaStart, diag::lex_hashbang_not_allowed);",
          "new_line_content": "  case '>':",
          "content_same": false
        },
        {
          "line": 2432,
          "old_api": "TriviaPiece::garbageText({TriviaStart, Length})",
          "new_api": null,
          "old_text": "TriviaPiece::garbageText({TriviaStart, Length})",
          "new_text": null,
          "old_line_content": "      Pieces.push_back(TriviaPiece::garbageText({TriviaStart, Length}));",
          "new_line_content": "      size_t Length = CurPtr - TriviaStart;",
          "content_same": false
        },
        {
          "line": 2441,
          "old_api": "TriviaPiece::garbageText({TriviaStart, Length})",
          "new_api": null,
          "old_text": "TriviaPiece::garbageText({TriviaStart, Length})",
          "new_text": null,
          "old_line_content": "      Pieces.push_back(TriviaPiece::garbageText({TriviaStart, Length}));",
          "new_line_content": "      size_t Length = CurPtr - TriviaStart;",
          "content_same": false
        },
        {
          "line": 2446,
          "old_api": "getNulCharacterKind",
          "new_api": null,
          "old_text": "getNulCharacterKind(CurPtr - 1)",
          "new_text": null,
          "old_line_content": "    switch (getNulCharacterKind(CurPtr - 1)) {",
          "new_line_content": "    case NulCharacterKind::BufferEnd:",
          "content_same": false
        },
        {
          "line": 2448,
          "old_api": "diagnoseEmbeddedNul",
          "new_api": null,
          "old_text": "diagnoseEmbeddedNul(Diags, CurPtr - 1)",
          "new_text": null,
          "old_line_content": "      diagnoseEmbeddedNul(Diags, CurPtr - 1);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2450,
          "old_api": "TriviaPiece::garbageText({TriviaStart, Length})",
          "new_api": null,
          "old_text": "TriviaPiece::garbageText({TriviaStart, Length})",
          "new_text": null,
          "old_line_content": "      Pieces.push_back(TriviaPiece::garbageText({TriviaStart, Length}));",
          "new_line_content": "  // Start character of tokens.",
          "content_same": false
        },
        {
          "line": 2482,
          "old_api": "advanceIfValidStartOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidStartOfIdentifier(Tmp, BufferEnd)",
          "new_text": null,
          "old_line_content": "    if (advanceIfValidStartOfIdentifier(Tmp, BufferEnd)) {",
          "new_line_content": "    if (ShouldTokenize) {",
          "content_same": false
        },
        {
          "line": 2485,
          "old_api": "advanceIfValidStartOfOperator",
          "new_api": null,
          "old_text": "advanceIfValidStartOfOperator(Tmp, BufferEnd)",
          "new_text": null,
          "old_line_content": "    if (advanceIfValidStartOfOperator(Tmp, BufferEnd)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2489,
          "old_api": "lexUnknown",
          "new_api": null,
          "old_text": "lexUnknown(/*EmitDiagnosticsIfToken=*/false)",
          "new_text": null,
          "old_line_content": "    bool ShouldTokenize = lexUnknown(/*EmitDiagnosticsIfToken=*/false);",
          "new_line_content": "    goto Restart;",
          "content_same": false
        },
        {
          "line": 2504,
          "old_api": "getLength",
          "new_api": null,
          "old_text": "getTokenAtLocation(SM, Loc).getLength()",
          "new_text": null,
          "old_line_content": "  return Loc.getAdvancedLocOrInvalid(getTokenAtLocation(SM, Loc).getLength());",
          "new_line_content": "                                            unsigned BufferEnd) {",
          "content_same": false
        },
        {
          "line": 2524,
          "old_api": "lex",
          "new_api": null,
          "old_text": "L.lex(Tok)",
          "new_text": null,
          "old_line_content": "    L.lex(Tok);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2526,
          "old_api": "getLoc",
          "new_api": null,
          "old_text": "Tok.getLoc()",
          "new_text": null,
          "old_line_content": "    unsigned TokOffs = SM.getLocOffsetInBuffer(Tok.getLoc(), BufferID);",
          "new_line_content": "      // Current token encompasses our source location.",
          "content_same": false
        },
        {
          "line": 2533,
          "old_api": "getLength",
          "new_api": null,
          "old_text": "Tok.getLength()",
          "new_text": null,
          "old_line_content": "    if (Offset < TokOffs+Tok.getLength()) {",
          "new_line_content": "          unsigned SegEnd = SegOffs+Seg.Length;",
          "content_same": false
        },
        {
          "line": 2536,
          "old_api": "is",
          "new_api": null,
          "old_text": "Tok.is(tok::string_literal)",
          "new_text": null,
          "old_line_content": "      if (Tok.is(tok::string_literal)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2538,
          "old_api": "Lexer::getStringLiteralSegments(Tok, Segments, /*Diags=*/nullptr)",
          "new_api": null,
          "old_text": "Lexer::getStringLiteralSegments(Tok, Segments, /*Diags=*/nullptr)",
          "new_text": null,
          "old_line_content": "        Lexer::getStringLiteralSegments(Tok, Segments, /*Diags=*/nullptr);",
          "new_line_content": "          if (Seg.Kind == Lexer::StringSegment::Expr && Offset < SegEnd)",
          "content_same": false
        },
        {
          "line": 2540,
          "old_api": "getLocOffsetInBuffer",
          "new_api": null,
          "old_text": "SM.getLocOffsetInBuffer(Seg.Loc, BufferID)",
          "new_text": null,
          "old_line_content": "          unsigned SegOffs = SM.getLocOffsetInBuffer(Seg.Loc, BufferID);",
          "new_line_content": "                                              /*BufferStart=*/SegOffs,",
          "content_same": false
        },
        {
          "line": 2553,
          "old_api": "getLoc",
          "new_api": null,
          "old_text": "Tok.getLoc()",
          "new_text": null,
          "old_line_content": "      return Tok.getLoc();",
          "new_line_content": "// Find the start of the given line.",
          "content_same": false
        },
        {
          "line": 2555,
          "old_api": "isNot",
          "new_api": null,
          "old_text": "Tok.isNot(tok::eof)",
          "new_text": null,
          "old_line_content": "  } while (Tok.isNot(tok::eof));",
          "new_line_content": "  while (current != bufStart) {",
          "content_same": false
        },
        {
          "line": 2558,
          "old_api": "getLocForOffset",
          "new_api": null,
          "old_text": "SM.getLocForOffset(BufferID, Offset)",
          "new_text": null,
          "old_line_content": "  return SM.getLocForOffset(BufferID, Offset);",
          "new_line_content": "      break;",
          "content_same": false
        },
        {
          "line": 2576,
          "old_api": "SM.\n    getBufferIdentifierForLoc(Loc)",
          "new_api": null,
          "old_text": "SM.\n    getBufferIdentifierForLoc(Loc)",
          "new_text": null,
          "old_line_content": "  Optional<unsigned> BufferIdOp = SM.getIDForBufferIdentifier(SM.",
          "new_line_content": "SourceLoc Lexer::getLocForStartOfToken(SourceManager &SM, unsigned BufferID,",
          "content_same": false
        },
        {
          "line": 2580,
          "old_api": "getValue",
          "new_api": null,
          "old_text": "BufferIdOp.getValue()",
          "new_text": null,
          "old_line_content": "  return getLocForStartOfToken(SM, BufferIdOp.getValue(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2586,
          "old_api": "getRangeForBuffer",
          "new_api": null,
          "old_text": "SM.getRangeForBuffer(BufferID)",
          "new_text": null,
          "old_line_content": "  CharSourceRange entireRange = SM.getRangeForBuffer(BufferID);",
          "new_line_content": "  // If it points to whitespace return the SourceLoc for it.",
          "content_same": false
        },
        {
          "line": 2587,
          "old_api": "extractText",
          "new_api": null,
          "old_text": "SM.extractText(entireRange)",
          "new_text": null,
          "old_line_content": "  StringRef Buffer = SM.extractText(entireRange);",
          "new_line_content": "  if (StrData[0] == '\\n' || StrData[0] == '\\r' ||",
          "content_same": false
        },
        {
          "line": 2590,
          "old_api": "size",
          "new_api": null,
          "old_text": "Buffer.size()",
          "new_text": null,
          "old_line_content": "  if (Offset > Buffer.size())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2591,
          "old_api": "SourceLoc",
          "new_api": null,
          "old_text": "SourceLoc()",
          "new_text": null,
          "old_line_content": "    return SourceLoc();",
          "new_line_content": "  // Back up from the current location until we hit the beginning of a line",
          "content_same": false
        },
        {
          "line": 2601,
          "old_api": "findStartOfLine",
          "new_api": null,
          "old_text": "findStartOfLine(BufStart, StrData)",
          "new_text": null,
          "old_line_content": "  const char *LexStart = findStartOfLine(BufStart, StrData);",
          "new_line_content": "  // Don't try to do anything with an invalid location.",
          "content_same": false
        },
        {
          "line": 2603,
          "old_api": "size",
          "new_api": null,
          "old_text": "getLocForStartOfTokenInBuf(SM, BufferID, Offset,\n                                    /*BufferStart=*/LexStart-BufStart,\n                                    /*BufferEnd=*/Buffer.size())",
          "new_text": null,
          "old_line_content": "  return getLocForStartOfTokenInBuf(SM, BufferID, Offset,",
          "new_line_content": "    return Loc;",
          "content_same": false
        },
        {
          "line": 2605,
          "old_api": "size",
          "new_api": null,
          "old_text": "Buffer.size()",
          "new_text": null,
          "old_line_content": "                                    /*BufferEnd=*/Buffer.size());",
          "new_line_content": "  // Figure out which buffer contains this location.",
          "content_same": false
        },
        {
          "line": 2618,
          "old_api": "getRangeForBuffer",
          "new_api": null,
          "old_text": "SM.getRangeForBuffer(BufferID)",
          "new_text": null,
          "old_line_content": "  CharSourceRange entireRange = SM.getRangeForBuffer(BufferID);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2619,
          "old_api": "extractText",
          "new_api": null,
          "old_text": "SM.extractText(entireRange)",
          "new_text": null,
          "old_line_content": "  StringRef Buffer = SM.extractText(entireRange);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2621,
          "old_api": "data",
          "new_api": null,
          "old_text": "Buffer.data()",
          "new_text": null,
          "old_line_content": "  const char *BufStart = Buffer.data();",
          "new_line_content": "  // Don't try to do anything with an invalid location.",
          "content_same": false
        },
        {
          "line": 2624,
          "old_api": "findStartOfLine",
          "new_api": null,
          "old_text": "findStartOfLine(BufStart, BufStart + Offset)",
          "new_text": null,
          "old_line_content": "  const char *StartOfLine = findStartOfLine(BufStart, BufStart + Offset);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2625,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(StartOfLine)",
          "new_text": null,
          "old_line_content": "  return getSourceLoc(StartOfLine);",
          "new_line_content": "  // Figure out which buffer contains this location.",
          "content_same": false
        },
        {
          "line": 2630,
          "old_api": "isInvalid",
          "new_api": null,
          "old_text": "Loc.isInvalid()",
          "new_text": null,
          "old_line_content": "  if (Loc.isInvalid())",
          "new_line_content": "  // Use fake language options; language options only affect validity",
          "content_same": false
        },
        {
          "line": 2634,
          "old_api": "findBufferContainingLoc",
          "new_api": null,
          "old_text": "SM.findBufferContainingLoc(Loc)",
          "new_text": null,
          "old_line_content": "  int BufferID = SM.findBufferContainingLoc(Loc);",
          "new_line_content": "  // Here we return comments as tokens because either the caller skipped",
          "content_same": false
        },
        {
          "line": 2636,
          "old_api": "SourceLoc",
          "new_api": null,
          "old_text": "SourceLoc()",
          "new_text": null,
          "old_line_content": "    return SourceLoc();",
          "new_line_content": "  // (making this option irrelevant), or the caller lexed comments and",
          "content_same": false
        },
        {
          "line": 2648,
          "old_api": "State",
          "new_api": null,
          "old_text": "State(Loc)",
          "new_text": null,
          "old_line_content": "  L.restoreState(State(Loc));",
          "new_line_content": "    return \"\";",
          "content_same": false
        },
        {
          "line": 2649,
          "old_api": "skipToEndOfLine",
          "new_api": null,
          "old_text": "L.skipToEndOfLine(/*EatNewline=*/true)",
          "new_text": null,
          "old_line_content": "  L.skipToEndOfLine(/*EatNewline=*/true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2650,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(L.CurPtr)",
          "new_text": null,
          "old_line_content": "  return getSourceLoc(L.CurPtr);",
          "new_line_content": "  // Figure out which buffer contains this location.",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": "llvm::StringSwitch<tok>(Str)",
          "new_api": null,
          "old_text": "llvm::StringSwitch<tok>(Str)",
          "new_text": null,
          "old_line_content": "  tok Kind = llvm::StringSwitch<tok>(Str)",
          "new_line_content": "#define SIL_KEYWORD(kw)",
          "content_same": false
        },
        {
          "line": 607,
          "old_api": "Default",
          "new_api": null,
          "old_text": "    .Default(tok::identifier)",
          "new_text": null,
          "old_line_content": "    .Default(tok::identifier);",
          "new_line_content": "  // SIL keywords are only active in SIL mode.",
          "content_same": false
        },
        {
          "line": 2664,
          "old_api": "extractText",
          "new_api": null,
          "old_text": "SM.extractText(entireRange)",
          "new_text": null,
          "old_line_content": "  StringRef Buffer = SM.extractText(entireRange);",
          "new_line_content": "    ++EndOfIndentation;",
          "content_same": false
        },
        {
          "line": 2667,
          "old_api": "getLocOffsetInBuffer",
          "new_api": null,
          "old_text": "SM.getLocOffsetInBuffer(Loc, BufferID)",
          "new_text": null,
          "old_line_content": "  unsigned Offset = SM.getLocOffsetInBuffer(Loc, BufferID);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2669,
          "old_api": "findStartOfLine",
          "new_api": null,
          "old_text": "findStartOfLine(BufStart, BufStart + Offset)",
          "new_text": null,
          "old_line_content": "  const char *StartOfLine = findStartOfLine(BufStart, BufStart + Offset);",
          "new_line_content": "ArrayRef<Token> swift::",
          "content_same": false
        },
        {
          "line": 2671,
          "old_api": "isHorizontalWhitespace",
          "new_api": null,
          "old_text": "isHorizontalWhitespace(*EndOfIndentation)",
          "new_text": null,
          "old_line_content": "  while (*EndOfIndentation && isHorizontalWhitespace(*EndOfIndentation))",
          "new_line_content": "                  SourceLoc EndLoc) {",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(didStart && \"Unexpected start\")",
          "new_text": null,
          "old_line_content": "  assert(didStart && \"Unexpected start\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 632,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "  while (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd));",
          "new_line_content": "  const char *TokStart = CurPtr-1;",
          "content_same": false
        },
        {
          "line": 2680,
          "old_api": "isValid",
          "new_api": null,
          "old_text": "EndLoc.isValid()",
          "new_text": null,
          "old_line_content": "  assert(StartLoc.isValid() && EndLoc.isValid());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(TokStart, CurPtr-TokStart)",
          "new_text": null,
          "old_line_content": "  tok Kind = kindOfIdentifier(StringRef(TokStart, CurPtr-TokStart), InSILMode);",
          "new_line_content": "  // NOTE: legacy punctuator.  Remove in the future.",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(Kind, TokStart)",
          "new_text": null,
          "old_line_content": "  return formToken(Kind, TokStart);",
          "new_line_content": "  if (*CurPtr == ']') { // #]",
          "content_same": false
        },
        {
          "line": 2681,
          "old_api": "token_lower_bound",
          "new_api": null,
          "old_text": "token_lower_bound(AllTokens, StartLoc)",
          "new_text": null,
          "old_line_content": "  auto StartIt = token_lower_bound(AllTokens, StartLoc);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2682,
          "old_api": "token_lower_bound",
          "new_api": null,
          "old_text": "token_lower_bound(AllTokens, EndLoc)",
          "new_text": null,
          "old_line_content": "  auto EndIt = token_lower_bound(AllTokens, EndLoc);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2683,
          "old_api": "getLoc",
          "new_api": null,
          "old_text": "EndIt->getLoc()",
          "new_text": null,
          "old_line_content": "  assert(StartIt->getLoc() == StartLoc && EndIt->getLoc() == EndLoc);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2684,
          "old_api": "begin",
          "new_api": null,
          "old_text": "AllTokens.begin()",
          "new_text": null,
          "old_line_content": "  return AllTokens.slice(StartIt - AllTokens.begin(), EndIt - StartIt + 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": "clang::isIdentifierHead(*tmpPtr)",
          "new_api": null,
          "old_text": "clang::isIdentifierHead(*tmpPtr)",
          "new_text": null,
          "old_line_content": "  if (clang::isIdentifierHead(*tmpPtr)) {",
          "new_line_content": "#define POUND_KEYWORD(id) \\",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(CurPtr, tmpPtr-CurPtr)",
          "new_text": null,
          "old_line_content": "  tok Kind = llvm::StringSwitch<tok>(StringRef(CurPtr, tmpPtr-CurPtr))",
          "new_line_content": "  // SIL parsing.",
          "content_same": false
        },
        {
          "line": 661,
          "old_api": "Default",
          "new_api": null,
          "old_text": "  .Default(tok::pound)",
          "new_text": null,
          "old_line_content": "  .Default(tok::pound);",
          "new_line_content": "  // If we found something specific, return it.",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::pound, TokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::pound, TokStart);",
          "new_line_content": "/// Is the operator beginning at the given character \"left-bound\"?",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(Kind, TokStart)",
          "new_text": null,
          "old_line_content": "  return formToken(Kind, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": "advanceIfValidStartOfOperator",
          "new_api": null,
          "old_text": "advanceIfValidStartOfOperator(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "  bool didStart = advanceIfValidStartOfOperator(CurPtr, BufferEnd);",
          "new_line_content": "      // in the middle of an operator.",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(didStart && \"unexpected operator start\")",
          "new_text": null,
          "old_line_content": "  assert(didStart && \"unexpected operator start\");",
          "new_line_content": "      break;",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(CurPtr, BufferEnd-CurPtr)",
          "new_text": null,
          "old_line_content": "    if (Identifier::isEditorPlaceholder(StringRef(CurPtr, BufferEnd-CurPtr)) &&",
          "new_line_content": "    // it starts a comment.",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": "rangeContainsPlaceholderEnd",
          "new_api": null,
          "old_text": "rangeContainsPlaceholderEnd(CurPtr + 2, BufferEnd)",
          "new_text": null,
          "old_line_content": "        rangeContainsPlaceholderEnd(CurPtr + 2, BufferEnd)) {",
          "new_line_content": "    for (auto Ptr = TokStart+1; Ptr != CurPtr-1; ++Ptr) {",
          "content_same": false
        },
        {
          "line": 768,
          "old_api": "advanceIfValidContinuationOfOperator",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfOperator(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "  } while (advanceIfValidContinuationOfOperator(CurPtr, BufferEnd));",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": "isRightBound",
          "new_api": null,
          "old_text": "isRightBound(CurPtr, leftBound, CodeCompletionPtr)",
          "new_text": null,
          "old_line_content": "  bool rightBound = isRightBound(CurPtr, leftBound, CodeCompletionPtr);",
          "new_line_content": "        if (leftBound)",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(TokStart, diag::lex_unary_equal)",
          "new_text": null,
          "old_line_content": "        auto d = diagnose(TokStart, diag::lex_unary_equal);",
          "new_line_content": "    case '&':",
          "content_same": false
        },
        {
          "line": 794,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(TokStart)",
          "new_text": null,
          "old_line_content": "          d.fixItInsert(getSourceLoc(TokStart), \" \");",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(TokStart+1)",
          "new_text": null,
          "old_line_content": "          d.fixItInsert(getSourceLoc(TokStart+1), \" \");",
          "new_line_content": "    case '.': {",
          "content_same": false
        },
        {
          "line": 799,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::equal, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::equal, TokStart);",
          "new_line_content": "      if (rightBound)",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::amp_prefix, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::amp_prefix, TokStart);",
          "new_line_content": "      ",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::period, TokStart)",
          "new_text": null,
          "old_line_content": "        return formToken(tok::period, TokStart);",
          "new_line_content": "      const char *AfterHorzWhitespace = CurPtr;",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::period_prefix, TokStart)",
          "new_text": null,
          "old_line_content": "        return formToken(tok::period_prefix, TokStart);",
          "new_line_content": "        ++AfterHorzWhitespace;",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(TokStart, diag::expected_member_name)",
          "new_text": null,
          "old_line_content": "        diagnose(TokStart, diag::expected_member_name);",
          "new_line_content": "          *AfterHorzWhitespace != '/') {",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(CurPtr)",
          "new_text": null,
          "old_line_content": "          .fixItRemoveChars(getSourceLoc(CurPtr),",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(AfterHorzWhitespace)",
          "new_text": null,
          "old_line_content": "                            getSourceLoc(AfterHorzWhitespace));",
          "new_line_content": "    case '?':",
          "content_same": false
        },
        {
          "line": 834,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::period, TokStart)",
          "new_text": null,
          "old_line_content": "        return formToken(tok::period, TokStart);",
          "new_line_content": "      if (leftBound)",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(TokStart, diag::expected_member_name)",
          "new_text": null,
          "old_line_content": "      diagnose(TokStart, diag::expected_member_name);",
          "new_line_content": "  } else if (CurPtr-TokStart == 2) {",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::unknown, TokStart);",
          "new_line_content": "    switch ((TokStart[0] << 8) | TokStart[1]) {",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(TokStart+Pos, diag::lex_unexpected_block_comment_end)",
          "new_text": null,
          "old_line_content": "      diagnose(TokStart+Pos, diag::lex_unexpected_block_comment_end);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(leftBound ? tok::oper_binary_unspaced :\n                                 tok::oper_binary_spaced, TokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(leftBound ? tok::oper_binary_unspaced :",
          "new_line_content": "  const char *tokStart = CurPtr-1;",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(leftBound ? tok::oper_postfix : tok::oper_prefix, TokStart)",
          "new_text": null,
          "old_line_content": "  return formToken(leftBound ? tok::oper_postfix : tok::oper_prefix, TokStart);",
          "new_line_content": "  // In a SIL function body, '$' is a token by itself, except it's a SIL global",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(*tokStart == '$')",
          "new_text": null,
          "old_line_content": "  assert(*tokStart == '$');",
          "new_line_content": "  for (;; ++CurPtr) {",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": "getKind",
          "new_api": null,
          "old_text": "NextToken.getKind()",
          "new_text": null,
          "old_line_content": "  if (InSILBody && NextToken.getKind() != tok::at_sign)",
          "new_line_content": "      isAllDigits = false;",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::sil_dollar, tokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::sil_dollar, tokStart);",
          "new_line_content": "      // continue",
          "content_same": false
        },
        {
          "line": 883,
          "old_api": "isDigit",
          "new_api": null,
          "old_text": "isDigit(*CurPtr)",
          "new_text": null,
          "old_line_content": "    if (isDigit(*CurPtr)) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": "clang::isIdentifierHead(*CurPtr, /*dollar*/true)",
          "new_api": null,
          "old_text": "clang::isIdentifierHead(*CurPtr, /*dollar*/true)",
          "new_text": null,
          "old_line_content": "    } else if (clang::isIdentifierHead(*CurPtr, /*dollar*/true)) {",
          "new_line_content": "  if (CurPtr == tokStart + 1) {",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": "isSwiftVersion3",
          "new_api": null,
          "old_text": "LangOpts.isSwiftVersion3()",
          "new_text": null,
          "old_line_content": "    if (!LangOpts.isSwiftVersion3()) {",
          "new_line_content": "  // We reserve $nonNumeric for persistent bindings in the debugger.",
          "content_same": false
        },
        {
          "line": 898,
          "old_api": "fixItReplaceChars",
          "new_api": null,
          "old_text": "diagnose(tokStart, diag::standalone_dollar_identifier)\n        .fixItReplaceChars(getSourceLoc(tokStart), getSourceLoc(CurPtr), \"`$`\")",
          "new_text": null,
          "old_line_content": "      diagnose(tokStart, diag::standalone_dollar_identifier)",
          "new_line_content": "    if (!LangOpts.EnableDollarIdentifiers && !InSILBody)",
          "content_same": false
        },
        {
          "line": 901,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::identifier, tokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::identifier, tokStart);",
          "new_line_content": "    // Even if we diagnose, we go ahead and form an identifier token,",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(tokStart, diag::expected_dollar_numeric)",
          "new_text": null,
          "old_line_content": "      diagnose(tokStart, diag::expected_dollar_numeric);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::identifier, tokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::identifier, tokStart);",
          "new_line_content": "void Lexer::lexHexNumber() {",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(*CurPtr == 'x' && \"not a hex literal\")",
          "new_text": null,
          "old_line_content": "  assert(*CurPtr == 'x' && \"not a hex literal\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "    while (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd));",
          "new_line_content": "  };",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::unknown, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "new_line_content": "  // (\\.[0-9A-Fa-f][0-9A-Fa-f_]*)?",
          "content_same": false
        },
        {
          "line": 948,
          "old_api": "expected_hex_digit",
          "new_api": null,
          "old_text": "expected_hex_digit(tmp)",
          "new_text": null,
          "old_line_content": "      return expected_hex_digit(tmp);",
          "new_line_content": "  if (*CurPtr == '.') {",
          "content_same": false
        },
        {
          "line": 950,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::integer_literal, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "new_line_content": "    ++CurPtr;",
          "content_same": false
        },
        {
          "line": 962,
          "old_api": "isHexDigit",
          "new_api": null,
          "old_text": "isHexDigit(*CurPtr)",
          "new_text": null,
          "old_line_content": "    if (!isHexDigit(*CurPtr)) {",
          "new_line_content": "    if (*CurPtr != 'p' && *CurPtr != 'P') {",
          "content_same": false
        },
        {
          "line": 964,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::integer_literal, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "new_line_content": "        // e.g: 0xff.description",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": "isHexDigit",
          "new_api": null,
          "old_text": "isHexDigit(*CurPtr)",
          "new_text": null,
          "old_line_content": "    while (isHexDigit(*CurPtr) || *CurPtr == '_')",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": "isDigit",
          "new_api": null,
          "old_text": "isDigit(PtrOnDot[1])",
          "new_text": null,
          "old_line_content": "      if (!isDigit(PtrOnDot[1])) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 976,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CurPtr, diag::lex_expected_binary_exponent_in_hex_float_literal)",
          "new_text": null,
          "old_line_content": "      diagnose(CurPtr, diag::lex_expected_binary_exponent_in_hex_float_literal);",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::unknown, TokStart);",
          "new_line_content": "  bool signedExponent = false;",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(*CurPtr == 'p' || *CurPtr == 'P' && \"not at a hex float exponent?!\")",
          "new_text": null,
          "old_line_content": "  assert(*CurPtr == 'p' || *CurPtr == 'P' && \"not at a hex float exponent?!\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": "isDigit",
          "new_api": null,
          "old_text": "isDigit(*CurPtr)",
          "new_text": null,
          "old_line_content": "  if (!isDigit(*CurPtr)) {",
          "new_line_content": "    // There are 3 cases to diagnose if the exponent starts with a non-digit:",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": "isDigit",
          "new_api": null,
          "old_text": "isDigit(PtrOnDot[1])",
          "new_text": null,
          "old_line_content": "    if (PtrOnDot && !isDigit(PtrOnDot[1]) && !signedExponent) {",
          "new_line_content": "    // identifier (invalid character), underscore (invalid first character),",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CurPtr, diag::lex_expected_digit_in_fp_exponent)",
          "new_text": null,
          "old_line_content": "      diagnose(CurPtr, diag::lex_expected_digit_in_fp_exponent);",
          "new_line_content": "  auto tmp = CurPtr;",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": "isDigit",
          "new_api": null,
          "old_text": "isDigit(*CurPtr)",
          "new_text": null,
          "old_line_content": "  while (isDigit(*CurPtr) || *CurPtr == '_')",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "  if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1017,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(tmp, 1)",
          "new_text": null,
          "old_line_content": "    diagnose(tmp, diag::lex_invalid_digit_in_fp_exponent, StringRef(tmp, 1),",
          "new_line_content": "/// lexNumber:",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": "expected_digit",
          "new_api": null,
          "old_text": "expected_digit()",
          "new_text": null,
          "old_line_content": "    return expected_digit();",
          "new_line_content": "///   integer_literal  ::= 0x[0-9a-fA-F][0-9a-fA-F_]*",
          "content_same": false
        },
        {
          "line": 1022,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::floating_literal, TokStart)",
          "new_text": null,
          "old_line_content": "  return formToken(tok::floating_literal, TokStart);",
          "new_line_content": "///   floating_literal ::= [0-9][0-9]_*\\.[0-9][0-9_]*",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "    while (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd));",
          "new_line_content": "  };",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::unknown, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1045,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(loc, 1)",
          "new_text": null,
          "old_line_content": "    diagnose(loc, diag::lex_invalid_digit_in_int_literal, StringRef(loc, 1),",
          "new_line_content": "  if (*TokStart == '0' && *CurPtr == 'o') {",
          "content_same": false
        },
        {
          "line": 1047,
          "old_api": "expected_digit",
          "new_api": null,
          "old_text": "expected_digit()",
          "new_text": null,
          "old_line_content": "    return expected_digit();",
          "new_line_content": "    ++CurPtr;",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": "lexHexNumber",
          "new_api": null,
          "old_text": "lexHexNumber()",
          "new_text": null,
          "old_line_content": "    return lexHexNumber();",
          "new_line_content": "    while ((*CurPtr >= '0' && *CurPtr <= '7') || *CurPtr == '_')",
          "content_same": false
        },
        {
          "line": 1057,
          "old_api": "expected_int_digit",
          "new_api": null,
          "old_text": "expected_int_digit(CurPtr, ExpectedDigitKind::Octal)",
          "new_text": null,
          "old_line_content": "      return expected_int_digit(CurPtr, ExpectedDigitKind::Octal);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "new_line_content": "    ++CurPtr;",
          "content_same": false
        },
        {
          "line": 1064,
          "old_api": "expected_int_digit",
          "new_api": null,
          "old_text": "expected_int_digit(tmp, ExpectedDigitKind::Octal)",
          "new_text": null,
          "old_line_content": "      return expected_int_digit(tmp, ExpectedDigitKind::Octal);",
          "new_line_content": "    if (*CurPtr != '0' && *CurPtr != '1')",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::integer_literal, TokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::integer_literal, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1073,
          "old_api": "expected_int_digit",
          "new_api": null,
          "old_text": "expected_int_digit(CurPtr, ExpectedDigitKind::Binary)",
          "new_text": null,
          "old_line_content": "      return expected_int_digit(CurPtr, ExpectedDigitKind::Binary);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": "expected_int_digit",
          "new_api": null,
          "old_text": "expected_int_digit(tmp, ExpectedDigitKind::Binary)",
          "new_text": null,
          "old_line_content": "      return expected_int_digit(tmp, ExpectedDigitKind::Binary);",
          "new_line_content": "    ++CurPtr;",
          "content_same": false
        },
        {
          "line": 1082,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::integer_literal, TokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::integer_literal, TokStart);",
          "new_line_content": "  // Lex things like 4.x as '4' followed by a tok::period.",
          "content_same": false
        },
        {
          "line": 1095,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::integer_literal, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "      if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "new_line_content": "  if (*CurPtr == '.') {",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": "expected_int_digit",
          "new_api": null,
          "old_text": "expected_int_digit(tmp, ExpectedDigitKind::Decimal)",
          "new_text": null,
          "old_line_content": "        return expected_int_digit(tmp, ExpectedDigitKind::Decimal);",
          "new_line_content": "    ++CurPtr;",
          "content_same": false
        },
        {
          "line": 1104,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::integer_literal, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "new_line_content": "    // Lex any digits after the decimal point.",
          "content_same": false
        },
        {
          "line": 1113,
          "old_api": "isDigit",
          "new_api": null,
          "old_text": "isDigit(*CurPtr)",
          "new_text": null,
          "old_line_content": "    while (isDigit(*CurPtr) || *CurPtr == '_')",
          "new_line_content": "      ++CurPtr;  // Eat the sign.",
          "content_same": false
        },
        {
          "line": 1123,
          "old_api": "isDigit",
          "new_api": null,
          "old_text": "isDigit(*CurPtr)",
          "new_text": null,
          "old_line_content": "    if (!isDigit(*CurPtr)) {",
          "new_line_content": "      else",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "      if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CurPtr, diag::lex_expected_digit_in_fp_exponent)",
          "new_text": null,
          "old_line_content": "        diagnose(CurPtr, diag::lex_expected_digit_in_fp_exponent);",
          "new_line_content": "    auto tmp = CurPtr;",
          "content_same": false
        },
        {
          "line": 1137,
          "old_api": "isDigit",
          "new_api": null,
          "old_text": "isDigit(*CurPtr)",
          "new_text": null,
          "old_line_content": "    while (isDigit(*CurPtr) || *CurPtr == '_')",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1142,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(tmp, 1)",
          "new_text": null,
          "old_line_content": "      diagnose(tmp, diag::lex_invalid_digit_in_fp_exponent, StringRef(tmp, 1),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1144,
          "old_api": "expected_digit",
          "new_api": null,
          "old_text": "expected_digit()",
          "new_text": null,
          "old_line_content": "      return expected_digit();",
          "new_line_content": "///   hex                      ::= [0-9a-fA-F]",
          "content_same": false
        },
        {
          "line": 1148,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::floating_literal, TokStart)",
          "new_text": null,
          "old_line_content": "  return formToken(tok::floating_literal, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(CurPtr[0] == '{' && \"Invalid unicode escape\")",
          "new_text": null,
          "old_line_content": "  assert(CurPtr[0] == '{' && \"Invalid unicode escape\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": "isHexDigit",
          "new_api": null,
          "old_text": "isHexDigit(CurPtr[0])",
          "new_text": null,
          "old_line_content": "  for (; isHexDigit(CurPtr[0]); ++NumDigits)",
          "new_line_content": "  ++CurPtr;",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "Diags->diagnose(CurPtr, diag::lex_invalid_u_escape_rbrace)",
          "new_text": null,
          "old_line_content": "      Diags->diagnose(CurPtr, diag::lex_invalid_u_escape_rbrace);",
          "new_line_content": "    return ~1U;",
          "content_same": false
        },
        {
          "line": 1172,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "Diags->diagnose(CurPtr, diag::lex_invalid_u_escape)",
          "new_text": null,
          "old_line_content": "      Diags->diagnose(CurPtr, diag::lex_invalid_u_escape);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1177,
          "old_api": "getAsInteger",
          "new_api": null,
          "old_text": "StringRef(DigitStart, NumDigits).getAsInteger(16, CharValue)",
          "new_text": null,
          "old_line_content": "  StringRef(DigitStart, NumDigits).getAsInteger(16, CharValue);",
          "new_line_content": "  while (true) {",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": "isPrintable",
          "new_api": null,
          "old_text": "isPrintable(CurPtr[-1])",
          "new_text": null,
          "old_line_content": "      if (isPrintable(CurPtr[-1]) == 0)",
          "new_line_content": "    if (CharValue != ~0U) return CharValue;",
          "content_same": false
        },
        {
          "line": 1222,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CharStart, diag::lex_unprintable_ascii_character)",
          "new_text": null,
          "old_line_content": "            diagnose(CharStart, diag::lex_unprintable_ascii_character);",
          "new_line_content": "    return ~1U;",
          "content_same": false
        },
        {
          "line": 1226,
          "old_api": "validateUTF8CharacterAndAdvance",
          "new_api": null,
          "old_text": "validateUTF8CharacterAndAdvance(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "    unsigned CharValue = validateUTF8CharacterAndAdvance(CurPtr, BufferEnd);",
          "new_line_content": "    // If we found a closing quote character, we're done.",
          "content_same": false
        },
        {
          "line": 1229,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CharStart, diag::lex_invalid_utf8)",
          "new_text": null,
          "old_line_content": "      diagnose(CharStart, diag::lex_invalid_utf8);",
          "new_line_content": "      return ~0U;",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CurPtr-1, diag::lex_nul_character)",
          "new_text": null,
          "old_line_content": "        diagnose(CurPtr-1, diag::lex_nul_character);",
          "new_line_content": "  case '\\n':  // String literals cannot have \\n or \\r in them.",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CurPtr-1, diag::lex_unterminated_string)",
          "new_text": null,
          "old_line_content": "      diagnose(CurPtr-1, diag::lex_unterminated_string);",
          "new_line_content": "    return ~1U;",
          "content_same": false
        },
        {
          "line": 1258,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CurPtr-1, diag::lex_unterminated_string)",
          "new_text": null,
          "old_line_content": "      diagnose(CurPtr-1, diag::lex_unterminated_string);",
          "new_line_content": "  switch (*CurPtr) {",
          "content_same": false
        },
        {
          "line": 1273,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CurPtr, diag::lex_invalid_escape)",
          "new_text": null,
          "old_line_content": "      diagnose(CurPtr, diag::lex_invalid_escape);",
          "new_line_content": "  case 'n': ++CurPtr; return '\\n';",
          "content_same": false
        },
        {
          "line": 1276,
          "old_api": "isAlphanumeric",
          "new_api": null,
          "old_text": "isAlphanumeric(*CurPtr)",
          "new_text": null,
          "old_line_content": "    if (isAlphanumeric(*CurPtr)) ++CurPtr;",
          "new_line_content": "  case '\"': ++CurPtr; return '\"';",
          "content_same": false
        },
        {
          "line": 1292,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CurPtr-1, diag::lex_unicode_escape_braces)",
          "new_text": null,
          "old_line_content": "        diagnose(CurPtr-1, diag::lex_unicode_escape_braces);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1304,
          "old_api": "EncodeToUTF8",
          "new_api": null,
          "old_text": "EncodeToUTF8(CharValue, TempString)",
          "new_text": null,
          "old_line_content": "  if (CharValue >= 0x80 && EncodeToUTF8(CharValue, TempString)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1306,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CharStart, diag::lex_invalid_unicode_scalar)",
          "new_text": null,
          "old_line_content": "      diagnose(CharStart, diag::lex_invalid_unicode_scalar);",
          "new_line_content": "/// sequence in a string literal (the start of an interpolated expression),",
          "content_same": false
        },
        {
          "line": 1329,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "AllowNewline.push_back(MultilineString)",
          "new_text": null,
          "old_line_content": "  AllowNewline.push_back(MultilineString);",
          "new_line_content": "    // string literals but not much else.  The implications of this include not",
          "content_same": false
        },
        {
          "line": 1332,
          "old_api": "empty",
          "new_api": null,
          "old_text": "OpenDelimiters.empty()",
          "new_text": null,
          "old_line_content": "    return !OpenDelimiters.empty() &&",
          "new_line_content": "    //",
          "content_same": false
        },
        {
          "line": 1333,
          "old_api": "back",
          "new_api": null,
          "old_text": "OpenDelimiters.back()",
          "new_text": null,
          "old_line_content": "           (OpenDelimiters.back() == '\"' || OpenDelimiters.back() == '\\'');",
          "new_line_content": "    // On success scanning the expression body, the real lexer will be used to",
          "content_same": false
        },
        {
          "line": 1356,
          "old_api": "inStringLiteral",
          "new_api": null,
          "old_text": "inStringLiteral()",
          "new_text": null,
          "old_line_content": "      if (!AllowNewline.back() && inStringLiteral()) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1357,
          "old_api": "back",
          "new_api": null,
          "old_text": "OpenDelimiters.back()",
          "new_text": null,
          "old_line_content": "        if (OpenDelimiters.back() == CurPtr[-1]) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1359,
          "old_api": "pop_back",
          "new_api": null,
          "old_text": "OpenDelimiters.pop_back()",
          "new_text": null,
          "old_line_content": "          OpenDelimiters.pop_back();",
          "new_line_content": "          *CurPtr == '\"' && *(CurPtr + 1) == '\"' && *(CurPtr - 1) == '\"');",
          "content_same": false
        },
        {
          "line": 1360,
          "old_api": "pop_back",
          "new_api": null,
          "old_text": "AllowNewline.pop_back()",
          "new_text": null,
          "old_line_content": "          AllowNewline.pop_back();",
          "new_line_content": "      if (isMultilineQuote)",
          "content_same": false
        },
        {
          "line": 1373,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "OpenDelimiters.push_back(CurPtr[-1])",
          "new_text": null,
          "old_line_content": "        OpenDelimiters.push_back(CurPtr[-1]);",
          "new_line_content": "        // Close multiline string literal.",
          "content_same": false
        },
        {
          "line": 1379,
          "old_api": "back",
          "new_api": null,
          "old_text": "AllowNewline.back()",
          "new_text": null,
          "old_line_content": "      assert(AllowNewline.back() && \"other cases must be handled above\");",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 1383,
          "old_api": "pop_back",
          "new_api": null,
          "old_text": "AllowNewline.pop_back()",
          "new_text": null,
          "old_line_content": "        AllowNewline.pop_back();",
          "new_line_content": "        char escapedChar = *CurPtr++;",
          "content_same": false
        },
        {
          "line": 1395,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "OpenDelimiters.push_back('(')",
          "new_text": null,
          "old_line_content": "          OpenDelimiters.push_back('(');",
          "new_line_content": "          return CurPtr-1;",
          "content_same": false
        },
        {
          "line": 1398,
          "old_api": "back",
          "new_api": null,
          "old_text": "AllowNewline.back()",
          "new_text": null,
          "old_line_content": "          if (AllowNewline.back())",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1422,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "OpenDelimiters.push_back('(')",
          "new_text": null,
          "old_line_content": "        OpenDelimiters.push_back('(');",
          "new_line_content": "        // Pop the matching bracket and keep going.",
          "content_same": false
        },
        {
          "line": 1426,
          "old_api": "empty",
          "new_api": null,
          "old_text": "OpenDelimiters.empty()",
          "new_text": null,
          "old_line_content": "      if (OpenDelimiters.empty()) {",
          "new_line_content": "        // It's a right parenthesis in a string literal.",
          "content_same": false
        },
        {
          "line": 1429,
          "old_api": "back",
          "new_api": null,
          "old_text": "OpenDelimiters.back()",
          "new_text": null,
          "old_line_content": "      } else if (OpenDelimiters.back() == '(') {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1431,
          "old_api": "pop_back",
          "new_api": null,
          "old_text": "OpenDelimiters.pop_back()",
          "new_text": null,
          "old_line_content": "        OpenDelimiters.pop_back();",
          "new_line_content": "      // Normal token character.",
          "content_same": false
        },
        {
          "line": 1435,
          "old_api": "inStringLiteral",
          "new_api": null,
          "old_text": "inStringLiteral()",
          "new_text": null,
          "old_line_content": "        assert(inStringLiteral());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1448,
          "old_api": "getText",
          "new_api": null,
          "old_text": "Str.getText()",
          "new_text": null,
          "old_line_content": "  StringRef Bytes = Str.getText();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1450,
          "old_api": "IsMultilineString",
          "new_api": null,
          "old_text": "Str.IsMultilineString()",
          "new_text": null,
          "old_line_content": "  if (Str.IsMultilineString())",
          "new_line_content": "static size_t commonPrefixLength(StringRef shorter, StringRef longer) {",
          "content_same": false
        },
        {
          "line": 1451,
          "old_api": "drop_front",
          "new_api": null,
          "old_text": "Bytes.drop_front(3).drop_back(3)",
          "new_text": null,
          "old_line_content": "    Bytes = Bytes.drop_front(3).drop_back(3);",
          "new_line_content": "  size_t offset = 0;",
          "content_same": false
        },
        {
          "line": 1453,
          "old_api": "drop_front",
          "new_api": null,
          "old_text": "Bytes.drop_front().drop_back()",
          "new_text": null,
          "old_line_content": "    Bytes = Bytes.drop_front().drop_back();",
          "new_line_content": "    ++offset;",
          "content_same": false
        },
        {
          "line": 1460,
          "old_api": "size",
          "new_api": null,
          "old_text": "longer.size()",
          "new_text": null,
          "old_line_content": "  while (offset < shorter.size() && offset < longer.size() && shorter[offset] == longer[offset]) {",
          "new_line_content": "/// Determine trailing indent to be used for multiline literal indent stripping.",
          "content_same": false
        },
        {
          "line": 1471,
          "old_api": "getStringLiteralContent",
          "new_api": null,
          "old_text": "getStringLiteralContent(Str)",
          "new_text": null,
          "old_line_content": "  StringRef Bytes = getStringLiteralContent(Str);",
          "new_line_content": "    case '\\t':",
          "content_same": false
        },
        {
          "line": 1472,
          "old_api": "end",
          "new_api": null,
          "old_text": "Bytes.end()",
          "new_text": null,
          "old_line_content": "  const char *begin = Bytes.begin(), *end = Bytes.end(), *start = end;",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 1484,
          "old_api": "Lexer::getSourceLoc(start)",
          "new_api": null,
          "old_text": "Lexer::getSourceLoc(start)",
          "new_text": null,
          "old_line_content": "      auto startLoc = Lexer::getSourceLoc(start);",
          "new_line_content": "        auto *LineEnd = Ptr + 1;",
          "content_same": false
        },
        {
          "line": 1485,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(start, end - start)",
          "new_text": null,
          "old_line_content": "      auto string = StringRef(start, end - start);",
          "new_line_content": "        while (Ptr > begin && (*Ptr == ' ' || *Ptr == '\\t')) --Ptr;",
          "content_same": false
        },
        {
          "line": 1495,
          "old_api": "Lexer::getSourceLoc(Ptr)",
          "new_api": null,
          "old_text": "Lexer::getSourceLoc(Ptr)",
          "new_text": null,
          "old_line_content": "          auto escapeLoc = Lexer::getSourceLoc(Ptr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1499,
          "old_api": "fixItRemoveChars",
          "new_api": null,
          "old_text": "Diags->diagnose(escapeLoc, diag::lex_escaped_newline_at_lastline)\n              .fixItRemoveChars(escapeLoc, Lexer::getSourceLoc(LineEnd))",
          "new_text": null,
          "old_line_content": "            Diags->diagnose(escapeLoc, diag::lex_escaped_newline_at_lastline)",
          "new_line_content": "      sawNonWhitespace = true;",
          "content_same": false
        },
        {
          "line": 1500,
          "old_api": "Lexer::getSourceLoc(LineEnd)",
          "new_api": null,
          "old_text": "Lexer::getSourceLoc(LineEnd)",
          "new_text": null,
          "old_line_content": "              .fixItRemoveChars(escapeLoc, Lexer::getSourceLoc(LineEnd));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1512,
          "old_api": "Lexer::getSourceLoc(start + 1)",
          "new_api": null,
          "old_text": "Lexer::getSourceLoc(start + 1)",
          "new_text": null,
          "old_line_content": "    auto loc = Lexer::getSourceLoc(start + 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1513,
          "old_api": "fixItInsert",
          "new_api": null,
          "old_text": "Diags->diagnose(loc, diag::lex_illegal_multiline_string_end)\n    // FIXME: Should try to suggest indentation.\n      .fixItInsert(loc, \"\\n\")",
          "new_text": null,
          "old_line_content": "    Diags->diagnose(loc, diag::lex_illegal_multiline_string_end)",
          "new_line_content": "/// diagnoseInvalidMultilineIndents:",
          "content_same": false
        },
        {
          "line": 1518,
          "old_api": "Lexer::getSourceLoc(end - 1)",
          "new_api": null,
          "old_text": "Lexer::getSourceLoc(end - 1)",
          "new_text": null,
          "old_line_content": "  return std::make_tuple(\"\", Lexer::getSourceLoc(end - 1));",
          "new_line_content": "                                            DiagnosticEngine *Diags, ",
          "content_same": false
        },
        {
          "line": 1538,
          "old_api": "empty",
          "new_api": null,
          "old_text": "LineStarts.empty()",
          "new_text": null,
          "old_line_content": "  assert(!LineStarts.empty());",
          "new_line_content": "      return 0;",
          "content_same": false
        },
        {
          "line": 1541,
          "old_api": "bytes_begin",
          "new_api": null,
          "old_text": "Bytes.bytes_begin()",
          "new_text": null,
          "old_line_content": "    return Lexer::getSourceLoc((const char *)Bytes.bytes_begin() + offset);",
          "new_line_content": "    default:",
          "content_same": false
        },
        {
          "line": 1554,
          "old_api": "getLoc",
          "new_api": null,
          "old_text": "getLoc(LineStarts[0] + MistakeOffset)",
          "new_text": null,
          "old_line_content": "  Diags->diagnose(getLoc(LineStarts[0] + MistakeOffset),",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 1556,
          "old_api": "size",
          "new_api": null,
          "old_text": "LineStarts.size()",
          "new_text": null,
          "old_line_content": "                  LineStarts.size() != 1, LineStarts.size(),",
          "new_line_content": "                             diag::lex_multiline_string_indent_change_line,",
          "content_same": false
        },
        {
          "line": 1563,
          "old_api": "getLoc",
          "new_api": null,
          "old_text": "getLoc(LineStarts[0] + MistakeOffset)",
          "new_text": null,
          "old_line_content": "  auto fix = Diags->diagnose(getLoc(LineStarts[0] + MistakeOffset),",
          "new_line_content": "  for (auto line : LineStarts) {",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": "size",
          "new_api": null,
          "old_text": "ActualIndent.size()",
          "new_text": null,
          "old_line_content": "  assert(MistakeOffset <= ActualIndent.size());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1568,
          "old_api": "substr",
          "new_api": null,
          "old_text": "ExpectedIndent.substr(0, MistakeOffset)",
          "new_text": null,
          "old_line_content": "  assert(ExpectedIndent.substr(0, MistakeOffset) == ",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1569,
          "old_api": "substr",
          "new_api": null,
          "old_text": "ActualIndent.substr(0, MistakeOffset)",
          "new_text": null,
          "old_line_content": "         ActualIndent.substr(0, MistakeOffset));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1572,
          "old_api": "getLoc",
          "new_api": null,
          "old_text": "getLoc(line + MistakeOffset)",
          "new_text": null,
          "old_line_content": "    fix.fixItReplaceChars(getLoc(line + MistakeOffset), ",
          "new_line_content": "static void validateMultilineIndents(const Token &Str,",
          "content_same": false
        },
        {
          "line": 1573,
          "old_api": "size",
          "new_api": null,
          "old_text": "ActualIndent.size()",
          "new_text": null,
          "old_line_content": "                          getLoc(line + ActualIndent.size()),",
          "new_line_content": "                                     DiagnosticEngine *Diags) {",
          "content_same": false
        },
        {
          "line": 1574,
          "old_api": "substr",
          "new_api": null,
          "old_text": "ExpectedIndent.substr(MistakeOffset)",
          "new_text": null,
          "old_line_content": "                          ExpectedIndent.substr(MistakeOffset));",
          "new_line_content": "  StringRef Indent;",
          "content_same": false
        },
        {
          "line": 1584,
          "old_api": "getMultilineTrailingIndent",
          "new_api": null,
          "old_text": "getMultilineTrailingIndent(Str, Diags)",
          "new_text": null,
          "old_line_content": "  std::tie(Indent, IndentStartLoc) = getMultilineTrailingIndent(Str, Diags);",
          "new_line_content": "  // lastMatchLength.",
          "content_same": false
        },
        {
          "line": 1585,
          "old_api": "empty",
          "new_api": null,
          "old_text": "Indent.empty()",
          "new_text": null,
          "old_line_content": "  if (Indent.empty())",
          "new_line_content": "  SmallVector<size_t, 4> linesWithLastMistakeOffset = {};",
          "content_same": false
        },
        {
          "line": 1597,
          "old_api": "getStringLiteralContent",
          "new_api": null,
          "old_text": "getStringLiteralContent(Str)",
          "new_text": null,
          "old_line_content": "  StringRef Bytes = getStringLiteralContent(Str);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1598,
          "old_api": "find",
          "new_api": null,
          "old_text": "Bytes.find('\\n', pos + 1)",
          "new_text": null,
          "old_line_content": "  for (size_t pos = Bytes.find('\\n'); pos != StringRef::npos; pos = Bytes.find('\\n', pos + 1)) {",
          "new_line_content": "    ",
          "content_same": false
        },
        {
          "line": 1608,
          "old_api": "commonPrefixLength",
          "new_api": null,
          "old_text": "commonPrefixLength(Indent, restOfBytes)",
          "new_text": null,
          "old_line_content": "    auto errorOffset = commonPrefixLength(Indent, restOfBytes);",
          "new_line_content": "      ",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": "diagnoseInvalidMultilineIndents",
          "new_api": null,
          "old_text": "diagnoseInvalidMultilineIndents(Diags, Indent, IndentStartLoc, Bytes, \n                                      linesWithLastMistakeOffset, lastMistakeOffset, \n                                      commonIndentation)",
          "new_text": null,
          "old_line_content": "      diagnoseInvalidMultilineIndents(Diags, Indent, IndentStartLoc, Bytes, ",
          "new_line_content": "      // To begin with, all whitespace is part of the common indentation.",
          "content_same": false
        },
        {
          "line": 1622,
          "old_api": "find_first_not_of",
          "new_api": null,
          "old_text": "restOfBytes.find_first_not_of(\" \\t\")",
          "new_text": null,
          "old_line_content": "      auto prefixLength = restOfBytes.find_first_not_of(\" \\t\");",
          "new_line_content": "    ",
          "content_same": false
        },
        {
          "line": 1623,
          "old_api": "substr",
          "new_api": null,
          "old_text": "restOfBytes.substr(0, prefixLength)",
          "new_text": null,
          "old_line_content": "      commonIndentation = restOfBytes.substr(0, prefixLength);",
          "new_line_content": "    // Either way, add this line to the run.",
          "content_same": false
        },
        {
          "line": 1627,
          "old_api": "commonPrefixLength",
          "new_api": null,
          "old_text": "commonPrefixLength(commonIndentation, restOfBytes)",
          "new_text": null,
          "old_line_content": "      auto prefixLength = commonPrefixLength(commonIndentation, restOfBytes);",
          "new_line_content": "  // Handle the last run.",
          "content_same": false
        },
        {
          "line": 1632,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "linesWithLastMistakeOffset.push_back(nextpos)",
          "new_text": null,
          "old_line_content": "    linesWithLastMistakeOffset.push_back(nextpos);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1636,
          "old_api": "diagnoseInvalidMultilineIndents",
          "new_api": null,
          "old_text": "diagnoseInvalidMultilineIndents(Diags, Indent, IndentStartLoc, Bytes, \n                                  linesWithLastMistakeOffset, lastMistakeOffset, \n                                  commonIndentation)",
          "new_text": null,
          "old_line_content": "  diagnoseInvalidMultilineIndents(Diags, Indent, IndentStartLoc, Bytes, ",
          "new_line_content": "void Lexer::lexStringLiteral() {",
          "content_same": false
        },
        {
          "line": 1646,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert((*TokStart == '\"' || *TokStart == '\\'') && \"Unexpected start\")",
          "new_text": null,
          "old_line_content": "  assert((*TokStart == '\"' || *TokStart == '\\'') && \"Unexpected start\");",
          "new_line_content": "    MultilineString = true;",
          "content_same": false
        },
        {
          "line": 1657,
          "old_api": "fixItInsert",
          "new_api": null,
          "old_text": "diagnose(CurPtr, diag::lex_illegal_multiline_string_start)\n        .fixItInsert(Lexer::getSourceLoc(CurPtr), \"\\n\")",
          "new_text": null,
          "old_line_content": "      diagnose(CurPtr, diag::lex_illegal_multiline_string_start)",
          "new_line_content": "      const char *EndPtr =",
          "content_same": false
        },
        {
          "line": 1666,
          "old_api": "skipToEndOfInterpolatedExpression",
          "new_api": null,
          "old_text": "skipToEndOfInterpolatedExpression(CurPtr, BufferEnd,\n                                            Diags, MultilineString)",
          "new_text": null,
          "old_line_content": "          skipToEndOfInterpolatedExpression(CurPtr, BufferEnd,",
          "new_line_content": "        wasErroneous = true;",
          "content_same": false
        },
        {
          "line": 1682,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(TokStart, diag::lex_unterminated_string)",
          "new_text": null,
          "old_line_content": "      diagnose(TokStart, diag::lex_unterminated_string);",
          "new_line_content": "    // or an already-diagnosed error, just munch it.",
          "content_same": false
        },
        {
          "line": 1683,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::unknown, TokStart);",
          "new_line_content": "    if (CharValue == ~0U) {",
          "content_same": false
        },
        {
          "line": 1702,
          "old_api": "size",
          "new_api": null,
          "old_text": "orig.size()",
          "new_text": null,
          "old_line_content": "        std::string str = orig.slice(1, orig.size() - 1).str();",
          "new_line_content": "                ++pos;",
          "content_same": false
        },
        {
          "line": 1705,
          "old_api": "length",
          "new_api": null,
          "old_text": "str.length()",
          "new_text": null,
          "old_line_content": "        while (pos != str.length()) {",
          "new_line_content": "                pos += 2;",
          "content_same": false
        },
        {
          "line": 1706,
          "old_api": "at",
          "new_api": null,
          "old_text": "str.at(pos)",
          "new_text": null,
          "old_line_content": "          if (str.at(pos) == '\\\\') {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": "replace",
          "new_api": null,
          "old_text": "str.replace(pos, 2, \"'\")",
          "new_text": null,
          "old_line_content": "                str.replace(pos, 2, \"'\");",
          "new_line_content": "            // Advance past the newly added [\"\\\"\"].",
          "content_same": false
        },
        {
          "line": 1716,
          "old_api": "replace",
          "new_api": null,
          "old_text": "str.replace(pos, 1, \"\\\\\\\"\")",
          "new_text": null,
          "old_line_content": "            str.replace(pos, 1, \"\\\\\\\"\");",
          "new_line_content": "        replacement += '\"';",
          "content_same": false
        },
        {
          "line": 1723,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(str)",
          "new_text": null,
          "old_line_content": "        replacement += StringRef(str);",
          "new_line_content": "      if (MultilineString) {",
          "content_same": false
        },
        {
          "line": 1725,
          "old_api": "fixItReplaceChars",
          "new_api": null,
          "old_text": "diagnose(TokStart, diag::lex_single_quote_string)\n          .fixItReplaceChars(getSourceLoc(TokStart), getSourceLoc(CurPtr),\n                             replacement)",
          "new_text": null,
          "old_line_content": "        diagnose(TokStart, diag::lex_single_quote_string)",
          "new_line_content": "          CurPtr += 2;",
          "content_same": false
        },
        {
          "line": 1734,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::string_literal, TokStart, MultilineString)",
          "new_text": null,
          "old_line_content": "          formToken(tok::string_literal, TokStart, MultilineString);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1736,
          "old_api": "validateMultilineIndents",
          "new_api": null,
          "old_text": "validateMultilineIndents(NextToken, Diags)",
          "new_text": null,
          "old_line_content": "            validateMultilineIndents(NextToken, Diags);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::string_literal, TokStart, MultilineString)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::string_literal, TokStart, MultilineString);",
          "new_line_content": "/// string literal, diagnose the problem and return a pointer to the end of the",
          "content_same": false
        },
        {
          "line": 1768,
          "old_api": "lexCharacter",
          "new_api": null,
          "old_text": "lexCharacter(Body, '\\0', /*EmitDiagnostics=*/false)",
          "new_text": null,
          "old_line_content": "    unsigned CharValue = lexCharacter(Body, '\\0', /*EmitDiagnostics=*/false);",
          "new_line_content": "    ",
          "content_same": false
        },
        {
          "line": 1781,
          "old_api": "fixItReplaceChars",
          "new_api": null,
          "old_text": "diagnose(CharStart, diag::lex_invalid_curly_quote)\n            .fixItReplaceChars(getSourceLoc(CharStart), getSourceLoc(Body),\n                               \"\\\"\")",
          "new_text": null,
          "old_line_content": "        diagnose(CharStart, diag::lex_invalid_curly_quote)",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1782,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(Body)",
          "new_text": null,
          "old_line_content": "            .fixItReplaceChars(getSourceLoc(CharStart), getSourceLoc(Body),",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1798,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(CurPtr[-1] == '`' && \"Unexpected start of escaped identifier\")",
          "new_text": null,
          "old_line_content": "  assert(CurPtr[-1] == '`' && \"Unexpected start of escaped identifier\");",
          "new_line_content": "    // Keep continuing the identifier.",
          "content_same": false
        },
        {
          "line": 1805,
          "old_api": "advanceIfValidStartOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidStartOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "  if (advanceIfValidStartOfIdentifier(CurPtr, BufferEnd)) {",
          "new_line_content": "      return;",
          "content_same": false
        },
        {
          "line": 1807,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "    while (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1820,
          "old_api": "formEscapedIdentifierToken",
          "new_api": null,
          "old_text": "formEscapedIdentifierToken(Quote)",
          "new_text": null,
          "old_line_content": "    formEscapedIdentifierToken(Quote);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1834,
          "old_api": "size",
          "new_api": null,
          "old_text": "terminator.size()",
          "new_text": null,
          "old_line_content": "  size_t termLen = terminator.size();",
          "new_line_content": "    if (endPos != 0 &&",
          "content_same": false
        },
        {
          "line": 1838,
          "old_api": "substr",
          "new_api": null,
          "old_text": "StringRef(CurPtr, BufferEnd - CurPtr).substr(termLen)",
          "new_text": null,
          "old_line_content": "  auto restOfBuffer = StringRef(CurPtr, BufferEnd - CurPtr).substr(termLen);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1845,
          "old_api": "data",
          "new_api": null,
          "old_text": "restOfBuffer.data()",
          "new_text": null,
          "old_line_content": "      return restOfBuffer.data() + endPos;",
          "new_line_content": "bool Lexer::tryLexConflictMarker(bool EatNewline) {",
          "content_same": false
        },
        {
          "line": 1847,
          "old_api": "substr",
          "new_api": null,
          "old_text": "restOfBuffer.substr(endPos + termLen)",
          "new_text": null,
          "old_line_content": "    restOfBuffer = restOfBuffer.substr(endPos + termLen);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1848,
          "old_api": "find",
          "new_api": null,
          "old_text": "restOfBuffer.find(terminator)",
          "new_text": null,
          "old_line_content": "    endPos = restOfBuffer.find(terminator);",
          "new_line_content": "  // Only a conflict marker if it starts at the beginning of a line.",
          "content_same": false
        },
        {
          "line": 1862,
          "old_api": "startswith",
          "new_api": null,
          "old_text": "restOfBuffer.startswith(\">>>> \")",
          "new_text": null,
          "old_line_content": "  if (!restOfBuffer.startswith(\"<<<<<<< \") && !restOfBuffer.startswith(\">>>> \"))",
          "new_line_content": "    CurPtr = End;",
          "content_same": false
        },
        {
          "line": 1867,
          "old_api": "findConflictEnd",
          "new_api": null,
          "old_text": "findConflictEnd(Ptr, BufferEnd, Kind)",
          "new_text": null,
          "old_line_content": "  if (const char *End = findConflictEnd(Ptr, BufferEnd, Kind)) {",
          "new_line_content": "    ",
          "content_same": false
        },
        {
          "line": 1869,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CurPtr, diag::lex_conflict_marker_in_file)",
          "new_text": null,
          "old_line_content": "    diagnose(CurPtr, diag::lex_conflict_marker_in_file);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1874,
          "old_api": "skipToEndOfLine",
          "new_api": null,
          "old_text": "skipToEndOfLine(EatNewline)",
          "new_text": null,
          "old_line_content": "      skipToEndOfLine(EatNewline);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1886,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(Tmp, BufferEnd)",
          "new_text": null,
          "old_line_content": "  if (advanceIfValidContinuationOfIdentifier(Tmp, BufferEnd)) {",
          "new_line_content": "    CurPtr = Tmp;",
          "content_same": false
        },
        {
          "line": 1890,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CurPtr - 1, diag::lex_invalid_identifier_start_character)",
          "new_text": null,
          "old_line_content": "      diagnose(CurPtr - 1, diag::lex_invalid_identifier_start_character);",
          "new_line_content": "  // This character isn't allowed in Swift source.",
          "content_same": false
        },
        {
          "line": 1892,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(Tmp, BufferEnd)",
          "new_text": null,
          "old_line_content": "    while (advanceIfValidContinuationOfIdentifier(Tmp, BufferEnd))",
          "new_line_content": "  if (Codepoint == ~0U) {",
          "content_same": false
        },
        {
          "line": 1899,
          "old_api": "validateUTF8CharacterAndAdvance",
          "new_api": null,
          "old_text": "validateUTF8CharacterAndAdvance(Tmp, BufferEnd)",
          "new_text": null,
          "old_line_content": "  uint32_t Codepoint = validateUTF8CharacterAndAdvance(Tmp, BufferEnd);",
          "new_line_content": "    if (EmitDiagnosticsIfToken) {",
          "content_same": false
        },
        {
          "line": 1902,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(Tmp)",
          "new_text": null,
          "old_line_content": "        .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \" \");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1908,
          "old_api": "fixItReplaceChars",
          "new_api": null,
          "old_text": "diagnose(CurPtr - 1, diag::lex_invalid_curly_quote)\n          .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \"\\\"\")",
          "new_text": null,
          "old_line_content": "      diagnose(CurPtr - 1, diag::lex_invalid_curly_quote)",
          "new_line_content": "    // to improve recovery.",
          "content_same": false
        },
        {
          "line": 1909,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(Tmp)",
          "new_text": null,
          "old_line_content": "          .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \"\\\"\");",
          "new_line_content": "    if (auto Tmp2 =",
          "content_same": false
        },
        {
          "line": 1918,
          "old_api": "findEndOfCurlyQuoteStringLiteral",
          "new_api": null,
          "old_text": "findEndOfCurlyQuoteStringLiteral(Tmp, EmitDiagnosticsIfToken)",
          "new_text": null,
          "old_line_content": "            findEndOfCurlyQuoteStringLiteral(Tmp, EmitDiagnosticsIfToken))",
          "new_line_content": "    if (EmitDiagnosticsIfToken) {",
          "content_same": false
        },
        {
          "line": 1936,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(Tmp)",
          "new_text": null,
          "old_line_content": "      .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \" \");",
          "new_line_content": "    llvm::SmallString<1> ExpectedChar;",
          "content_same": false
        },
        {
          "line": 1943,
          "old_api": "EncodeToUTF8",
          "new_api": null,
          "old_text": "EncodeToUTF8(Codepoint, ConfusedChar)",
          "new_text": null,
          "old_line_content": "    EncodeToUTF8(Codepoint, ConfusedChar);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1946,
          "old_api": "fixItReplaceChars",
          "new_api": null,
          "old_text": "diagnose(CurPtr - 1, diag::lex_confusable_character, ConfusedChar,\n             ExpectedChar)\n        .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp),\n                           ExpectedChar)",
          "new_text": null,
          "old_line_content": "    diagnose(CurPtr - 1, diag::lex_confusable_character, ConfusedChar,",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1948,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(Tmp)",
          "new_text": null,
          "old_line_content": "        .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp),",
          "new_line_content": "Lexer::NulCharacterKind Lexer::getNulCharacterKind(const char *Ptr) const {",
          "content_same": false
        },
        {
          "line": 1957,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(Ptr != nullptr && *Ptr == 0)",
          "new_text": null,
          "old_line_content": "  assert(Ptr != nullptr && *Ptr == 0);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1968,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(CurPtr[-1] == '<' && CurPtr[0] == '#')",
          "new_text": null,
          "old_line_content": "  assert(CurPtr[-1] == '<' && CurPtr[0] == '#');",
          "new_line_content": "      // Found it. Flag it as error (or warning, if in playground mode) for the",
          "content_same": false
        },
        {
          "line": 1979,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(TokStart, diag::lex_editor_placeholder_in_playground)",
          "new_text": null,
          "old_line_content": "        diagnose(TokStart, diag::lex_editor_placeholder_in_playground);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1981,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(TokStart, diag::lex_editor_placeholder)",
          "new_text": null,
          "old_line_content": "        diagnose(TokStart, diag::lex_editor_placeholder);",
          "new_line_content": "  // Not a well-formed placeholder.",
          "content_same": false
        },
        {
          "line": 1984,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::identifier, TokStart)",
          "new_text": null,
          "old_line_content": "      formToken(tok::identifier, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1990,
          "old_api": "lexOperatorIdentifier",
          "new_api": null,
          "old_text": "lexOperatorIdentifier()",
          "new_text": null,
          "old_line_content": "  lexOperatorIdentifier();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1999,
          "old_api": "clear",
          "new_api": null,
          "old_text": "TempString.clear()",
          "new_text": null,
          "old_line_content": "  TempString.clear();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2005,
          "old_api": "end",
          "new_api": null,
          "old_text": "Bytes.end()",
          "new_text": null,
          "old_line_content": "  while (BytesPtr < Bytes.end()) {",
          "new_line_content": "        ++BytesPtr;",
          "content_same": false
        },
        {
          "line": 2016,
          "old_api": "end",
          "new_api": null,
          "old_text": "Bytes.end()",
          "new_text": null,
          "old_line_content": "      if (IsLastSegment && BytesPtr == Bytes.end())",
          "new_line_content": "    if (CurChar != '\\\\') {",
          "content_same": false
        },
        {
          "line": 2019,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "TempString.push_back('\\n')",
          "new_text": null,
          "old_line_content": "        TempString.push_back('\\n');",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2025,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "TempString.push_back(CurChar)",
          "new_text": null,
          "old_line_content": "      TempString.push_back(CurChar);",
          "new_line_content": "    default:",
          "content_same": false
        },
        {
          "line": 2037,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "TempString.push_back('\\0')",
          "new_text": null,
          "old_line_content": "    case '0': TempString.push_back('\\0'); continue;",
          "new_line_content": "    case ' ': case '\\t': case '\\n': case '\\r':",
          "content_same": false
        },
        {
          "line": 2039,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "TempString.push_back('\\r')",
          "new_text": null,
          "old_line_content": "    case 'r': TempString.push_back('\\r'); continue;",
          "new_line_content": "        IsEscapedNewline = true;",
          "content_same": false
        },
        {
          "line": 2040,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "TempString.push_back('\\t')",
          "new_text": null,
          "old_line_content": "    case 't': TempString.push_back('\\t'); continue;",
          "new_line_content": "        --BytesPtr;",
          "content_same": false
        },
        {
          "line": 2041,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "TempString.push_back('\"')",
          "new_text": null,
          "old_line_content": "    case '\"': TempString.push_back('\"'); continue;",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2042,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "TempString.push_back('\\'')",
          "new_text": null,
          "old_line_content": "    case '\\'': TempString.push_back('\\''); continue;",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 2043,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "TempString.push_back('\\\\')",
          "new_text": null,
          "old_line_content": "    case '\\\\': TempString.push_back('\\\\'); continue;",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 96,
      "total_additions": 347,
      "total_deletions": 349,
      "total_api_changes": 792
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 15,
        "api_related_lines": 792,
        "non_api_lines": 12,
        "non_api_line_numbers": [
          608,
          609,
          610,
          611,
          612,
          614,
          615,
          616,
          617,
          618,
          604,
          605
        ]
      }
    },
    "api_calls_before": 678,
    "api_calls_after": 676,
    "diff_info": {
      "added_lines": 5,
      "removed_lines": 13,
      "total_diff_lines": 35
    }
  }
}