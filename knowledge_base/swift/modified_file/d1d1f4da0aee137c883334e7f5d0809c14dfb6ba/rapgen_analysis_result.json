{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/d1d1f4da0aee137c883334e7f5d0809c14dfb6ba",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/d1d1f4da0aee137c883334e7f5d0809c14dfb6ba/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/d1d1f4da0aee137c883334e7f5d0809c14dfb6ba/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/d1d1f4da0aee137c883334e7f5d0809c14dfb6ba/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 58,
          "old_api": "contains",
          "new_api": "end",
          "old_text": "CurrentInliningSet.contains(F)",
          "new_text": "FullyInlinedSet.end()",
          "old_line_content": "  if (CurrentInliningSet.contains(F)) {",
          "new_line_content": "  if (FullyInlinedSet.find(F) != FullyInlinedSet.end())",
          "content_same": false
        },
        {
          "line": 62,
          "old_api": "assert",
          "new_api": "contains",
          "old_text": "assert(L && \"Must have location for forced inline apply\")",
          "new_text": "CurrentInliningSet.contains(F)",
          "old_line_content": "    assert(L && \"Must have location for forced inline apply\");",
          "new_line_content": "  if (CurrentInliningSet.contains(F)) {",
          "content_same": false
        },
        {
          "line": 85,
          "old_api": "getResultNumber",
          "new_api": "getCallee",
          "old_text": "Callee.getResultNumber()",
          "new_text": "InnerAI->getCallee()",
          "old_line_content": "        assert(Callee.getResultNumber() == 0);",
          "new_line_content": "        SILValue Callee = InnerAI->getCallee();",
          "content_same": false
        },
        {
          "line": 86,
          "old_api": "getFunction",
          "new_api": "getDef",
          "old_text": "FRI->getFunction()",
          "new_text": "Callee.getDef()",
          "old_line_content": "        SILFunction *CalledFunc = FRI->getFunction();",
          "new_line_content": "        FunctionRefInst *FRI = dyn_cast<FunctionRefInst>(Callee.getDef());",
          "content_same": false
        },
        {
          "line": 103,
          "old_api": "getStartSourceLoc",
          "new_api": "getLoc",
          "old_text": "L.getStartSourceLoc()",
          "new_text": "AI->getLoc()",
          "old_line_content": "            diagnose(F->getModule().getASTContext(), L.getStartSourceLoc(),",
          "new_line_content": "            SILLocation L = AI->getLoc();",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 128,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "FullyInlinedSet.insert(F)",
          "old_line_content": "}",
          "new_line_content": "  FullyInlinedSet.insert(F);",
          "content_same": false
        },
        {
          "line": 65,
          "old_api": null,
          "new_api": "getLoc",
          "old_text": null,
          "new_text": "AI->getLoc()",
          "old_line_content": "    return false;",
          "new_line_content": "    SILLocation L = AI->getLoc();",
          "content_same": false
        },
        {
          "line": 64,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(AI && \"Cannot have circular inline without apply\")",
          "old_line_content": "             diag::circular_force_inline);",
          "new_line_content": "    assert(AI && \"Cannot have circular inline without apply\");",
          "content_same": false
        },
        {
          "line": 66,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(L && \"Must have location for forced inline apply\")",
          "old_line_content": "  }",
          "new_line_content": "    assert(L && \"Must have location for forced inline apply\");",
          "content_same": false
        },
        {
          "line": 67,
          "old_api": null,
          "new_api": "getStartSourceLoc",
          "old_text": null,
          "new_text": "L.getStartSourceLoc()",
          "old_line_content": "",
          "new_line_content": "    diagnose(F->getModule().getASTContext(), L.getStartSourceLoc(),",
          "content_same": false
        },
        {
          "line": 121,
          "old_api": null,
          "new_api": "inlineFunction",
          "old_text": null,
          "new_text": "Inliner.inlineFunction(InnerAI)",
          "old_line_content": "    }",
          "new_line_content": "      Inliner.inlineFunction(InnerAI);",
          "content_same": false
        },
        {
          "line": 104,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(L && \"Must have location for forced inline apply\")",
          "old_line_content": "                     diag::note_while_inlining);",
          "new_line_content": "            assert(L && \"Must have location for forced inline apply\");",
          "content_same": false
        },
        {
          "line": 105,
          "old_api": null,
          "new_api": "getStartSourceLoc",
          "old_text": null,
          "new_text": "L.getStartSourceLoc()",
          "old_line_content": "          }",
          "new_line_content": "            diagnose(F->getModule().getASTContext(), L.getStartSourceLoc(),",
          "content_same": false
        },
        {
          "line": 74,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "SetFactory.add(CurrentInliningSet, F)",
          "old_line_content": "    for (auto &I : BB) {",
          "new_line_content": "  CurrentInliningSet = SetFactory.add(CurrentInliningSet, F);",
          "content_same": false
        },
        {
          "line": 140,
          "old_api": null,
          "new_api": "getEmptySet",
          "old_text": null,
          "new_text": "runOnFunctionRecursively(&F, nullptr, FullyInlinedSet, SetFactory,\n                              SetFactory.getEmptySet())",
          "old_line_content": "}",
          "new_line_content": "    runOnFunctionRecursively(&F, nullptr, FullyInlinedSet, SetFactory,",
          "content_same": false
        },
        {
          "line": 141,
          "old_api": null,
          "new_api": "getEmptySet",
          "old_text": null,
          "new_text": "SetFactory.getEmptySet()",
          "old_line_content": "",
          "new_line_content": "                              SetFactory.getEmptySet());",
          "content_same": false
        },
        {
          "line": 111,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "ApplySites.push_back(InnerAI)",
          "old_line_content": "    }",
          "new_line_content": "        ApplySites.push_back(InnerAI);",
          "content_same": false
        },
        {
          "line": 80,
          "old_api": null,
          "new_api": "isForceInline",
          "old_text": null,
          "new_text": "InnerAI->isForceInline()",
          "old_line_content": "        // bodies available.",
          "new_line_content": "      if ((InnerAI = dyn_cast<ApplyInst>(&I)) && InnerAI->isForceInline()) {",
          "content_same": false
        },
        {
          "line": 118,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "ApplySites.empty()",
          "old_line_content": "    for (auto *InnerAI : ApplySites) {",
          "new_line_content": "  if (!ApplySites.empty()) {",
          "content_same": false
        },
        {
          "line": 89,
          "old_api": null,
          "new_api": "getResultNumber",
          "old_text": null,
          "new_text": "Callee.getResultNumber()",
          "old_line_content": "",
          "new_line_content": "        assert(Callee.getResultNumber() == 0);",
          "content_same": false
        },
        {
          "line": 90,
          "old_api": null,
          "new_api": "getFunction",
          "old_text": null,
          "new_text": "FRI->getFunction()",
          "old_line_content": "        // If we haven't fully processed this function yet, then recursively",
          "new_line_content": "        SILFunction *CalledFunc = FRI->getFunction();",
          "content_same": false
        },
        {
          "line": 91,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "CalledFunc->empty()",
          "old_line_content": "        // process it first before trying to inline it.",
          "new_line_content": "        if (!CalledFunc || CalledFunc->empty())",
          "content_same": false
        },
        {
          "line": 95,
          "old_api": null,
          "new_api": "runOnFunctionRecursively",
          "old_text": null,
          "new_text": "runOnFunctionRecursively(CalledFunc, InnerAI, FullyInlinedSet,\n                                      SetFactory, CurrentInliningSet)",
          "old_line_content": "          // If we failed due to circular inlining, then emit some notes to",
          "new_line_content": "        if (!runOnFunctionRecursively(CalledFunc, InnerAI, FullyInlinedSet,",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 101,
          "old_api": "getLoc",
          "new_api": null,
          "old_text": "AI->getLoc()",
          "new_text": null,
          "old_line_content": "            SILLocation L = AI->getLoc();",
          "new_line_content": "          // propogating the failure.",
          "content_same": false
        },
        {
          "line": 70,
          "old_api": "add",
          "new_api": null,
          "old_text": "SetFactory.add(CurrentInliningSet, F)",
          "new_text": null,
          "old_line_content": "  CurrentInliningSet = SetFactory.add(CurrentInliningSet, F);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 102,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(L && \"Must have location for forced inline apply\")",
          "new_text": null,
          "old_line_content": "            assert(L && \"Must have location for forced inline apply\");",
          "new_line_content": "          if (AI) {",
          "content_same": false
        },
        {
          "line": 138,
          "old_api": "getEmptySet",
          "new_api": null,
          "old_text": "runOnFunctionRecursively(&F, nullptr, FullyInlinedSet, SetFactory,\n                              SetFactory.getEmptySet())",
          "new_text": null,
          "old_line_content": "    runOnFunctionRecursively(&F, nullptr, FullyInlinedSet, SetFactory,",
          "new_line_content": "  ImmutableFunctionSet::Factory SetFactory;",
          "content_same": false
        },
        {
          "line": 139,
          "old_api": "getEmptySet",
          "new_api": null,
          "old_text": "SetFactory.getEmptySet()",
          "new_text": null,
          "old_line_content": "                              SetFactory.getEmptySet());",
          "new_line_content": "  for (auto &F : *M)",
          "content_same": false
        },
        {
          "line": 76,
          "old_api": "isForceInline",
          "new_api": null,
          "old_text": "InnerAI->isForceInline()",
          "new_text": null,
          "old_line_content": "      if ((InnerAI = dyn_cast<ApplyInst>(&I)) && InnerAI->isForceInline()) {",
          "new_line_content": "  SmallVector<ApplyInst*, 4> ApplySites;",
          "content_same": false
        },
        {
          "line": 109,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "ApplySites.push_back(InnerAI)",
          "new_text": null,
          "old_line_content": "        ApplySites.push_back(InnerAI);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 92,
          "old_api": "end",
          "new_api": null,
          "old_text": "FullyInlinedSet.end()",
          "new_text": null,
          "old_line_content": "        if (FullyInlinedSet.find(CalledFunc) == FullyInlinedSet.end() &&",
          "new_line_content": "          continue;",
          "content_same": false
        },
        {
          "line": 81,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "InnerAI->getCallee()",
          "new_text": null,
          "old_line_content": "        SILValue Callee = InnerAI->getCallee();",
          "new_line_content": "        // Figure out of this is something we have the body for",
          "content_same": false
        },
        {
          "line": 82,
          "old_api": "getDef",
          "new_api": null,
          "old_text": "Callee.getDef()",
          "new_text": null,
          "old_line_content": "        FunctionRefInst *FRI = dyn_cast<FunctionRefInst>(Callee.getDef());",
          "new_line_content": "        // FIXME: once fragile SIL is serialized in modules, these can be",
          "content_same": false
        },
        {
          "line": 93,
          "old_api": "runOnFunctionRecursively",
          "new_api": null,
          "old_text": "runOnFunctionRecursively(CalledFunc, InnerAI, FullyInlinedSet,\n                                      SetFactory, CurrentInliningSet)",
          "new_text": null,
          "old_line_content": "            !runOnFunctionRecursively(CalledFunc, InnerAI, FullyInlinedSet,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 116,
          "old_api": "empty",
          "new_api": null,
          "old_text": "ApplySites.empty()",
          "new_text": null,
          "old_line_content": "  if (!ApplySites.empty()) {",
          "new_line_content": "  // Do the inlining separately from the inspection loop to avoid iterator",
          "content_same": false
        },
        {
          "line": 119,
          "old_api": "inlineFunction",
          "new_api": null,
          "old_text": "Inliner.inlineFunction(InnerAI)",
          "new_text": null,
          "old_line_content": "      Inliner.inlineFunction(InnerAI);",
          "new_line_content": "    SILInliner Inliner(*F);",
          "content_same": false
        },
        {
          "line": 87,
          "old_api": "empty",
          "new_api": null,
          "old_text": "CalledFunc->empty()",
          "new_text": null,
          "old_line_content": "        if (!CalledFunc || CalledFunc->empty())",
          "new_line_content": "        if (!FRI)",
          "content_same": false
        },
        {
          "line": 60,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(AI && \"Cannot have circular inline without apply\")",
          "new_text": null,
          "old_line_content": "    assert(AI && \"Cannot have circular inline without apply\");",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 61,
          "old_api": "getLoc",
          "new_api": null,
          "old_text": "AI->getLoc()",
          "new_text": null,
          "old_line_content": "    SILLocation L = AI->getLoc();",
          "new_line_content": "  // Prevent attempt to circularly inline.",
          "content_same": false
        },
        {
          "line": 126,
          "old_api": "insert",
          "new_api": null,
          "old_text": "FullyInlinedSet.insert(F)",
          "new_text": null,
          "old_line_content": "  FullyInlinedSet.insert(F);",
          "new_line_content": "  // Keep track of full inlined functions so we don't waste time recursively",
          "content_same": false
        },
        {
          "line": 63,
          "old_api": "getStartSourceLoc",
          "new_api": null,
          "old_text": "L.getStartSourceLoc()",
          "new_text": null,
          "old_line_content": "    diagnose(F->getModule().getASTContext(), L.getStartSourceLoc(),",
          "new_line_content": "    // This cannot happen on a top-level call, so AI should be non-null.",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 5,
      "total_additions": 18,
      "total_deletions": 18,
      "total_api_changes": 41
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 10,
        "api_related_lines": 41,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          57,
          59,
          94
        ]
      }
    },
    "api_calls_before": 36,
    "api_calls_after": 36,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 4,
      "total_diff_lines": 29
    }
  }
}