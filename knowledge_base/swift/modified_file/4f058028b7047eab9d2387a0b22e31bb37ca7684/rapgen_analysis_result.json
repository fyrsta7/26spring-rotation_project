{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/4f058028b7047eab9d2387a0b22e31bb37ca7684",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/4f058028b7047eab9d2387a0b22e31bb37ca7684/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/4f058028b7047eab9d2387a0b22e31bb37ca7684/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/swift/modified_file/4f058028b7047eab9d2387a0b22e31bb37ca7684/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 290,
          "old_api": "isComment",
          "new_api": "end",
          "old_text": "Piece.isComment()",
          "new_text": "LeadingTrivia.end()",
          "old_line_content": "      return Piece.isComment();",
          "new_line_content": "    for (auto End = LeadingTrivia.end(); Iter != End; Iter++) {",
          "content_same": false
        },
        {
          "line": 313,
          "old_api": "assert",
          "new_api": "TriviaPiece::backtick()",
          "old_text": "assert(CurPtr[-1] == '`' && \"escaped identifier ends with backtick\")",
          "new_text": "TriviaPiece::backtick()",
          "old_line_content": "  assert(CurPtr[-1] == '`' && \"escaped identifier ends with backtick\");",
          "new_line_content": "  LeadingTrivia.push_back(TriviaPiece::backtick());",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": "TriviaPiece::backtick()",
          "new_api": "formToken",
          "old_text": "TriviaPiece::backtick()",
          "new_text": "formToken(tok::identifier, TokStart)",
          "old_line_content": "  TrailingTrivia.push_back(TriviaPiece::backtick());",
          "new_line_content": "  formToken(tok::identifier, TokStart);",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": "is",
          "new_api": "setEscapedIdentifier",
          "old_text": "NextToken.is(tok::eof)",
          "new_text": "NextToken.setEscapedIdentifier(true)",
          "old_line_content": "  if (NextToken.is(tok::eof))",
          "new_line_content": "  NextToken.setEscapedIdentifier(true);",
          "content_same": false
        },
        {
          "line": 333,
          "old_api": "is",
          "new_api": "setStringLiteral",
          "old_text": "NextToken.is(tok::eof)",
          "new_text": "NextToken.setStringLiteral(IsMultilineString, CustomDelimiterLen)",
          "old_line_content": "  if (NextToken.is(tok::eof))",
          "new_line_content": "  NextToken.setStringLiteral(IsMultilineString, CustomDelimiterLen);",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": "Lexer::getSourceLoc(Ptr)",
          "new_api": "fixItRemoveChars",
          "old_text": "Lexer::getSourceLoc(Ptr)",
          "new_text": "Diags->diagnose(NulLoc, diag::lex_nul_character)\n      .fixItRemoveChars(NulLoc, NulEndLoc)",
          "old_line_content": "  SourceLoc NulLoc = Lexer::getSourceLoc(Ptr);",
          "new_line_content": "  Diags->diagnose(NulLoc, diag::lex_nul_character)",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": "assert",
          "new_api": "skipToEndOfLine",
          "old_text": "assert(CurPtr == ContentStart && CurPtr[0] == '#' && CurPtr[1] == '!' &&\n         \"Not a hashbang\")",
          "new_text": "skipToEndOfLine(EatNewline)",
          "old_line_content": "  assert(CurPtr == ContentStart && CurPtr[0] == '#' && CurPtr[1] == '!' &&",
          "new_line_content": "  skipToEndOfLine(EatNewline);",
          "content_same": false
        },
        {
          "line": 522,
          "old_api": "skipToEndOfSlashStarComment",
          "new_api": "setAtStartOfLine",
          "old_text": "skipToEndOfSlashStarComment(CurPtr, BufferEnd, CodeCompletionPtr, Diags)",
          "new_text": "NextToken.setAtStartOfLine(true)",
          "old_line_content": "      skipToEndOfSlashStarComment(CurPtr, BufferEnd, CodeCompletionPtr, Diags);",
          "new_line_content": "    NextToken.setAtStartOfLine(true);",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": "isValidIdentifierContinuationCodePoint",
          "new_api": "isDigit",
          "old_text": "isValidIdentifierContinuationCodePoint(c)",
          "new_text": "isDigit(c)",
          "old_line_content": "  if (!isValidIdentifierContinuationCodePoint(c))",
          "new_line_content": "  if (c < 0x80 && (isDigit(c) || c == '$'))",
          "content_same": false
        },
        {
          "line": 632,
          "old_api": "empty",
          "new_api": "advanceIfValidStartOfIdentifier",
          "old_text": "string.empty()",
          "new_text": "advanceIfValidStartOfIdentifier(p, end)",
          "old_line_content": "  if (string.empty()) return false;",
          "new_line_content": "  if (!advanceIfValidStartOfIdentifier(p, end))",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": "advanceIfValidStartOfIdentifier",
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": "advanceIfValidStartOfIdentifier(p, end)",
          "new_text": "advanceIfValidContinuationOfIdentifier(p, end)",
          "old_line_content": "  if (!advanceIfValidStartOfIdentifier(p, end))",
          "new_line_content": "  while (p < end && advanceIfValidContinuationOfIdentifier(p, end));",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": "empty",
          "new_api": "advanceIfValidStartOfOperator",
          "old_text": "string.empty()",
          "new_text": "advanceIfValidStartOfOperator(p, end)",
          "old_line_content": "  if (string.empty()) return false;",
          "new_line_content": "  if (!advanceIfValidStartOfOperator(p, end))",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": "advanceIfValidStartOfOperator",
          "new_api": "advanceIfValidContinuationOfOperator",
          "old_text": "advanceIfValidStartOfOperator(p, end)",
          "new_text": "advanceIfValidContinuationOfOperator(p, end)",
          "old_line_content": "  if (!advanceIfValidStartOfOperator(p, end))",
          "new_line_content": "  while (p < end && advanceIfValidContinuationOfOperator(p, end));",
          "content_same": false
        },
        {
          "line": 674,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": "StringRef",
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": "StringRef(TokStart, CurPtr-TokStart)",
          "old_line_content": "  while (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd));",
          "new_line_content": "  tok Kind = kindOfIdentifier(StringRef(TokStart, CurPtr-TokStart), InSILMode);",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": "diagnose",
          "new_api": "getSourceLoc",
          "old_text": "diagnose(TokStart, diag::lex_unary_equal)",
          "new_text": "getSourceLoc(TokStart)",
          "old_line_content": "        auto d = diagnose(TokStart, diag::lex_unary_equal);",
          "new_line_content": "          d.fixItInsert(getSourceLoc(TokStart), \" \");",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": "fixItRemoveChars",
          "new_api": "getSourceLoc",
          "old_text": "diagnose(TokStart, diag::extra_whitespace_period)\n          .fixItRemoveChars(getSourceLoc(CurPtr),\n                            getSourceLoc(AfterHorzWhitespace))",
          "new_text": "getSourceLoc(AfterHorzWhitespace)",
          "old_line_content": "        diagnose(TokStart, diag::extra_whitespace_period)",
          "new_line_content": "                            getSourceLoc(AfterHorzWhitespace));",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": "getSourceLoc",
          "new_api": "formToken",
          "old_text": "getSourceLoc(CurPtr)",
          "new_text": "formToken(tok::period, TokStart)",
          "old_line_content": "          .fixItRemoveChars(getSourceLoc(CurPtr),",
          "new_line_content": "        return formToken(tok::period, TokStart);",
          "content_same": false
        },
        {
          "line": 897,
          "old_api": "formToken",
          "new_api": "diagnose",
          "old_text": "formToken(tok::arrow, TokStart)",
          "new_text": "diagnose(TokStart, diag::lex_unexpected_block_comment_end)",
          "old_line_content": "      return formToken(tok::arrow, TokStart);",
          "new_line_content": "      diagnose(TokStart, diag::lex_unexpected_block_comment_end);",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": "find",
          "new_api": "diagnose",
          "old_text": "StringRef(TokStart, CurPtr-TokStart).find(\"*/\")",
          "new_text": "diagnose(TokStart+Pos, diag::lex_unexpected_block_comment_end)",
          "old_line_content": "    auto Pos = StringRef(TokStart, CurPtr-TokStart).find(\"*/\");",
          "new_line_content": "      diagnose(TokStart+Pos, diag::lex_unexpected_block_comment_end);",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": "isDigit",
          "new_api": "clang::isIdentifierHead(*CurPtr, /*dollar*/true)",
          "old_text": "isDigit(*CurPtr)",
          "new_text": "clang::isIdentifierHead(*CurPtr, /*dollar*/true)",
          "old_line_content": "    if (isDigit(*CurPtr)) {",
          "new_line_content": "    } else if (clang::isIdentifierHead(*CurPtr, /*dollar*/true)) {",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": "fixItReplaceChars",
          "new_api": "formToken",
          "old_text": "diagnose(tokStart, diag::standalone_dollar_identifier)\n      .fixItReplaceChars(getSourceLoc(tokStart), getSourceLoc(CurPtr), \"`$`\")",
          "new_text": "formToken(tok::identifier, tokStart)",
          "old_line_content": "    diagnose(tokStart, diag::standalone_dollar_identifier)",
          "new_line_content": "    return formToken(tok::identifier, tokStart);",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "StringRef",
          "new_api": "expected_digit",
          "old_text": "StringRef(loc, 1)",
          "new_text": "expected_digit()",
          "old_line_content": "    diagnose(loc, diag::lex_invalid_digit_in_int_literal, StringRef(loc, 1),",
          "new_line_content": "    return expected_digit();",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": "expected_hex_digit",
          "new_api": "isHexDigit",
          "old_text": "expected_hex_digit(CurPtr)",
          "new_text": "isHexDigit(*CurPtr)",
          "old_line_content": "    return expected_hex_digit(CurPtr);",
          "new_line_content": "  while (isHexDigit(*CurPtr) || *CurPtr == '_')",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": "expected_hex_digit",
          "new_api": "formToken",
          "old_text": "expected_hex_digit(tmp)",
          "new_text": "formToken(tok::integer_literal, TokStart)",
          "old_line_content": "      return expected_hex_digit(tmp);",
          "new_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": "isHexDigit",
          "new_api": "formToken",
          "old_text": "isHexDigit(*CurPtr)",
          "new_text": "formToken(tok::integer_literal, TokStart)",
          "old_line_content": "    if (!isHexDigit(*CurPtr)) {",
          "new_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": "formToken",
          "new_api": "diagnose",
          "old_text": "formToken(tok::integer_literal, TokStart)",
          "new_text": "diagnose(CurPtr, diag::lex_expected_binary_exponent_in_hex_float_literal)",
          "old_line_content": "        return formToken(tok::integer_literal, TokStart);",
          "new_line_content": "      diagnose(CurPtr, diag::lex_expected_binary_exponent_in_hex_float_literal);",
          "content_same": false
        },
        {
          "line": 1053,
          "old_api": "diagnose",
          "new_api": "expected_digit",
          "old_text": "diagnose(CurPtr, diag::lex_expected_digit_in_fp_exponent)",
          "new_text": "expected_digit()",
          "old_line_content": "      diagnose(CurPtr, diag::lex_expected_digit_in_fp_exponent);",
          "new_line_content": "    return expected_digit();",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": "StringRef",
          "new_api": "expected_digit",
          "old_text": "StringRef(tmp, 1)",
          "new_text": "expected_digit()",
          "old_line_content": "    diagnose(tmp, diag::lex_invalid_digit_in_fp_exponent, StringRef(tmp, 1),",
          "new_line_content": "    return expected_digit();",
          "content_same": false
        },
        {
          "line": 1091,
          "old_api": "StringRef",
          "new_api": "expected_digit",
          "old_text": "StringRef(loc, 1)",
          "new_text": "expected_digit()",
          "old_line_content": "    diagnose(loc, diag::lex_invalid_digit_in_int_literal, StringRef(loc, 1),",
          "new_line_content": "    return expected_digit();",
          "content_same": false
        },
        {
          "line": 1110,
          "old_api": "expected_int_digit",
          "new_api": "formToken",
          "old_text": "expected_int_digit(tmp, ExpectedDigitKind::Octal)",
          "new_text": "formToken(tok::integer_literal, TokStart)",
          "old_line_content": "      return expected_int_digit(tmp, ExpectedDigitKind::Octal);",
          "new_line_content": "    return formToken(tok::integer_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": "expected_int_digit",
          "new_api": "formToken",
          "old_text": "expected_int_digit(tmp, ExpectedDigitKind::Binary)",
          "new_text": "formToken(tok::integer_literal, TokStart)",
          "old_line_content": "      return expected_int_digit(tmp, ExpectedDigitKind::Binary);",
          "new_line_content": "    return formToken(tok::integer_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 1148,
          "old_api": "expected_int_digit",
          "new_api": "formToken",
          "old_text": "expected_int_digit(tmp, ExpectedDigitKind::Decimal)",
          "new_text": "formToken(tok::integer_literal, TokStart)",
          "old_line_content": "        return expected_int_digit(tmp, ExpectedDigitKind::Decimal);",
          "new_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 1178,
          "old_api": "diagnose",
          "new_api": "expected_digit",
          "old_text": "diagnose(CurPtr, diag::lex_expected_digit_in_fp_exponent)",
          "new_text": "expected_digit()",
          "old_line_content": "        diagnose(CurPtr, diag::lex_expected_digit_in_fp_exponent);",
          "new_line_content": "      return expected_digit();",
          "content_same": false
        },
        {
          "line": 1188,
          "old_api": "StringRef",
          "new_api": "expected_digit",
          "old_text": "StringRef(tmp, 1)",
          "new_text": "expected_digit()",
          "old_line_content": "      diagnose(tmp, diag::lex_invalid_digit_in_fp_exponent, StringRef(tmp, 1),",
          "new_line_content": "      return expected_digit();",
          "content_same": false
        },
        {
          "line": 1311,
          "old_api": "Lexer::getSourceLoc(BytesPtr)",
          "new_api": "Lexer::getSourceLoc(TmpPtr)",
          "old_text": "Lexer::getSourceLoc(BytesPtr)",
          "new_text": "Lexer::getSourceLoc(TmpPtr)",
          "old_line_content": "    Diags->diagnose(Lexer::getSourceLoc(BytesPtr), message)",
          "new_line_content": "                          Lexer::getSourceLoc(TmpPtr));",
          "content_same": false
        },
        {
          "line": 1372,
          "old_api": "assert",
          "new_api": "diagnose",
          "old_text": "assert(CurPtr - 1 != BufferEnd && \"Caller must handle EOF\")",
          "new_text": "diagnose(CurPtr-1, diag::lex_nul_character)",
          "old_line_content": "    assert(CurPtr - 1 != BufferEnd && \"Caller must handle EOF\");",
          "new_line_content": "      diagnose(CurPtr-1, diag::lex_nul_character);",
          "content_same": false
        },
        {
          "line": 1427,
          "old_api": "EncodeToUTF8",
          "new_api": "diagnose",
          "old_text": "EncodeToUTF8(CharValue, TempString)",
          "new_text": "diagnose(CharStart, diag::lex_invalid_unicode_scalar)",
          "old_line_content": "  if (CharValue >= 0x80 && EncodeToUTF8(CharValue, TempString)) {",
          "new_line_content": "      diagnose(CharStart, diag::lex_invalid_unicode_scalar);",
          "content_same": false
        },
        {
          "line": 1485,
          "old_api": "advanceIfCustomDelimiter",
          "new_api": "assert",
          "old_text": "advanceIfCustomDelimiter(CurPtr, nullptr)",
          "new_text": "assert(CurPtr[-1] == '\"' &&\n             \"advanceIfCustomDelimiter() must stop at after the quote\")",
          "old_line_content": "          !(CustomDelimiterLen = advanceIfCustomDelimiter(CurPtr, nullptr)))",
          "new_line_content": "      assert(CurPtr[-1] == '\"' &&",
          "content_same": false
        },
        {
          "line": 1493,
          "old_api": "inStringLiteral",
          "new_api": "push_back",
          "old_text": "inStringLiteral()",
          "new_text": "OpenDelimiters.push_back(CurPtr[-1])",
          "old_line_content": "      if (!inStringLiteral()) {",
          "new_line_content": "        OpenDelimiters.push_back(CurPtr[-1]);",
          "content_same": false
        },
        {
          "line": 1552,
          "old_api": "back",
          "new_api": "pop_back",
          "old_text": "OpenDelimiters.back()",
          "new_text": "OpenDelimiters.pop_back()",
          "old_line_content": "      } else if (OpenDelimiters.back() == '(') {",
          "new_line_content": "        OpenDelimiters.pop_back();",
          "content_same": false
        },
        {
          "line": 1594,
          "old_api": "getText",
          "new_api": "getCustomDelimiterLen",
          "old_text": "Str.getText()",
          "new_text": "Str.getCustomDelimiterLen()",
          "old_line_content": "  StringRef Bytes = Str.getText();",
          "new_line_content": "  if (unsigned CustomDelimiterLen = Str.getCustomDelimiterLen())",
          "content_same": false
        },
        {
          "line": 1597,
          "old_api": "drop_front",
          "new_api": "isMultilineString",
          "old_text": "Bytes.drop_front(CustomDelimiterLen).drop_back(CustomDelimiterLen)",
          "new_text": "Str.isMultilineString()",
          "old_line_content": "    Bytes = Bytes.drop_front(CustomDelimiterLen).drop_back(CustomDelimiterLen);",
          "new_line_content": "  if (Str.isMultilineString())",
          "content_same": false
        },
        {
          "line": 1701,
          "old_api": "getLoc",
          "new_api": "size",
          "old_text": "getLoc(LineStarts[0] + MistakeOffset)",
          "new_text": "LineStarts.size()",
          "old_line_content": "  Diags->diagnose(getLoc(LineStarts[0] + MistakeOffset),",
          "new_line_content": "                  LineStarts.size() != 1, LineStarts.size(),",
          "content_same": false
        },
        {
          "line": 1704,
          "old_api": "classify",
          "new_api": "getAdvancedLoc",
          "old_text": "classify(Bytes[LineStarts[0] + MistakeOffset])",
          "new_text": "IndentLoc.getAdvancedLoc(MistakeOffset)",
          "old_line_content": "                  classify(Bytes[LineStarts[0] + MistakeOffset]));",
          "new_line_content": "  Diags->diagnose(IndentLoc.getAdvancedLoc(MistakeOffset), ",
          "content_same": false
        },
        {
          "line": 1706,
          "old_api": "getAdvancedLoc",
          "new_api": "classify",
          "old_text": "IndentLoc.getAdvancedLoc(MistakeOffset)",
          "new_text": "classify(ExpectedIndent[MistakeOffset])",
          "old_line_content": "  Diags->diagnose(IndentLoc.getAdvancedLoc(MistakeOffset), ",
          "new_line_content": "                  classify(ExpectedIndent[MistakeOffset]));",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": "classify",
          "new_api": "getLoc",
          "old_text": "classify(ExpectedIndent[MistakeOffset])",
          "new_text": "getLoc(LineStarts[0] + MistakeOffset)",
          "old_line_content": "                  classify(ExpectedIndent[MistakeOffset]));",
          "new_line_content": "  auto fix = Diags->diagnose(getLoc(LineStarts[0] + MistakeOffset),",
          "content_same": false
        },
        {
          "line": 1710,
          "old_api": "getLoc",
          "new_api": "size",
          "old_text": "getLoc(LineStarts[0] + MistakeOffset)",
          "new_text": "LineStarts.size()",
          "old_line_content": "  auto fix = Diags->diagnose(getLoc(LineStarts[0] + MistakeOffset),",
          "new_line_content": "                             LineStarts.size() != 1);",
          "content_same": false
        },
        {
          "line": 1714,
          "old_api": "size",
          "new_api": "substr",
          "old_text": "ActualIndent.size()",
          "new_text": "ActualIndent.substr(0, MistakeOffset)",
          "old_line_content": "  assert(MistakeOffset <= ActualIndent.size());",
          "new_line_content": "         ActualIndent.substr(0, MistakeOffset));",
          "content_same": false
        },
        {
          "line": 1719,
          "old_api": "getLoc",
          "new_api": "substr",
          "old_text": "getLoc(line + MistakeOffset)",
          "new_text": "ExpectedIndent.substr(MistakeOffset)",
          "old_line_content": "    fix.fixItReplaceChars(getLoc(line + MistakeOffset), ",
          "new_line_content": "                          ExpectedIndent.substr(MistakeOffset));",
          "content_same": false
        },
        {
          "line": 1729,
          "old_api": "getStringLiteralContent",
          "new_api": "getCustomDelimiterLen",
          "old_text": "getStringLiteralContent(Str)",
          "new_text": "Str.getCustomDelimiterLen()",
          "old_line_content": "  StringRef Bytes = getStringLiteralContent(Str);",
          "new_line_content": "    getMultilineTrailingIndent(Bytes, Diags, Str.getCustomDelimiterLen());",
          "content_same": false
        },
        {
          "line": 1732,
          "old_api": "empty",
          "new_api": "data",
          "old_text": "Indent.empty()",
          "new_text": "Indent.data()",
          "old_line_content": "  if (Indent.empty())",
          "new_line_content": "  SourceLoc IndentStartLoc = Lexer::getSourceLoc(Indent.data());",
          "content_same": false
        },
        {
          "line": 1745,
          "old_api": "find",
          "new_api": "substr",
          "old_text": "Bytes.find('\\n', pos + 1)",
          "new_text": "Bytes.substr(nextpos)",
          "old_line_content": "  for (size_t pos = Bytes.find('\\n'); pos != StringRef::npos; pos = Bytes.find('\\n', pos + 1)) {",
          "new_line_content": "    auto restOfBytes = Bytes.substr(nextpos);",
          "content_same": false
        },
        {
          "line": 1811,
          "old_api": "end",
          "new_api": "assert",
          "old_text": "replacement.end()",
          "new_text": "assert(*Ptr == ')')",
          "old_line_content": "        Ptr = skipToEndOfInterpolatedExpression(Ptr + 1, replacement.end(),",
          "new_line_content": "        assert(*Ptr == ')');",
          "content_same": false
        },
        {
          "line": 1824,
          "old_api": "assert",
          "new_api": "push_back",
          "old_text": "assert(Ptr == TokEnd && Ptr[-1] == '\\'')",
          "new_text": "replacement.push_back('\"')",
          "old_line_content": "  assert(Ptr == TokEnd && Ptr[-1] == '\\'');",
          "new_line_content": "  replacement.push_back('\"');",
          "content_same": false
        },
        {
          "line": 1826,
          "old_api": "push_back",
          "new_api": "Lexer::getSourceLoc(TokStart)",
          "old_text": "replacement.push_back('\"')",
          "new_text": "Lexer::getSourceLoc(TokStart)",
          "old_line_content": "  replacement.push_back('\"');",
          "new_line_content": "  D->diagnose(Lexer::getSourceLoc(TokStart), diag::lex_single_quote_string)",
          "content_same": false
        },
        {
          "line": 1828,
          "old_api": "Lexer::getSourceLoc(TokStart)",
          "new_api": "Lexer::getSourceLoc(TokEnd)",
          "old_text": "Lexer::getSourceLoc(TokStart)",
          "new_text": "Lexer::getSourceLoc(TokEnd)",
          "old_line_content": "  D->diagnose(Lexer::getSourceLoc(TokStart), diag::lex_single_quote_string)",
          "new_line_content": "                         Lexer::getSourceLoc(TokEnd), replacement);",
          "content_same": false
        },
        {
          "line": 1843,
          "old_api": "assert",
          "new_api": "advanceIfMultilineDelimiter",
          "old_text": "assert((QuoteChar == '\"' || QuoteChar == '\\'') && \"Unexpected start\")",
          "new_text": "advanceIfMultilineDelimiter(CurPtr, Diags)",
          "old_line_content": "  assert((QuoteChar == '\"' || QuoteChar == '\\'') && \"Unexpected start\");",
          "new_line_content": "  bool IsMultilineString = advanceIfMultilineDelimiter(CurPtr, Diags);",
          "content_same": false
        },
        {
          "line": 1845,
          "old_api": "advanceIfMultilineDelimiter",
          "new_api": "fixItInsert",
          "old_text": "advanceIfMultilineDelimiter(CurPtr, Diags)",
          "new_text": "diagnose(CurPtr, diag::lex_illegal_multiline_string_start)\n        .fixItInsert(Lexer::getSourceLoc(CurPtr), \"\\n\")",
          "old_line_content": "  bool IsMultilineString = advanceIfMultilineDelimiter(CurPtr, Diags);",
          "new_line_content": "    diagnose(CurPtr, diag::lex_illegal_multiline_string_start)",
          "content_same": false
        },
        {
          "line": 1894,
          "old_api": "assert",
          "new_api": "diagnoseSingleQuoteStringLiteral",
          "old_text": "assert(!IsMultilineString && CustomDelimiterLen == 0 &&\n           \"Single quoted string cannot have custom delimitor, nor multiline\")",
          "new_text": "diagnoseSingleQuoteStringLiteral(TokStart, CurPtr, Diags)",
          "old_line_content": "    assert(!IsMultilineString && CustomDelimiterLen == 0 &&",
          "new_line_content": "    diagnoseSingleQuoteStringLiteral(TokStart, CurPtr, Diags);",
          "content_same": false
        },
        {
          "line": 1900,
          "old_api": "formToken",
          "new_api": "formStringLiteralToken",
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": "formStringLiteralToken(TokStart, IsMultilineString,\n                                CustomDelimiterLen)",
          "old_line_content": "    return formToken(tok::unknown, TokStart);",
          "new_line_content": "  return formStringLiteralToken(TokStart, IsMultilineString,",
          "content_same": false
        },
        {
          "line": 1963,
          "old_api": "advanceIfValidStartOfIdentifier",
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": "advanceIfValidStartOfIdentifier(CurPtr, BufferEnd)",
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "  if (advanceIfValidStartOfIdentifier(CurPtr, BufferEnd)) {",
          "new_line_content": "    while (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd));",
          "content_same": false
        },
        {
          "line": 2003,
          "old_api": "data",
          "new_api": "substr",
          "old_text": "restOfBuffer.data()",
          "new_text": "restOfBuffer.substr(endPos + termLen)",
          "old_line_content": "      return restOfBuffer.data() + endPos;",
          "new_line_content": "    restOfBuffer = restOfBuffer.substr(endPos + termLen);",
          "content_same": false
        },
        {
          "line": 2025,
          "old_api": "findConflictEnd",
          "new_api": "diagnose",
          "old_text": "findConflictEnd(Ptr, BufferEnd, Kind)",
          "new_text": "diagnose(CurPtr, diag::lex_conflict_marker_in_file)",
          "old_line_content": "  if (const char *End = findConflictEnd(Ptr, BufferEnd, Kind)) {",
          "new_line_content": "    diagnose(CurPtr, diag::lex_conflict_marker_in_file);",
          "content_same": false
        },
        {
          "line": 2048,
          "old_api": "diagnose",
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": "diagnose(CurPtr - 1, diag::lex_invalid_identifier_start_character)",
          "new_text": "advanceIfValidContinuationOfIdentifier(Tmp, BufferEnd)",
          "old_line_content": "      diagnose(CurPtr - 1, diag::lex_invalid_identifier_start_character);",
          "new_line_content": "    while (advanceIfValidContinuationOfIdentifier(Tmp, BufferEnd))",
          "content_same": false
        },
        {
          "line": 2057,
          "old_api": "validateUTF8CharacterAndAdvance",
          "new_api": "fixItReplaceChars",
          "old_text": "validateUTF8CharacterAndAdvance(Tmp, BufferEnd)",
          "new_text": "diagnose(CurPtr - 1, diag::lex_invalid_utf8)\n        .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \" \")",
          "old_line_content": "  uint32_t Codepoint = validateUTF8CharacterAndAdvance(Tmp, BufferEnd);",
          "new_line_content": "    diagnose(CurPtr - 1, diag::lex_invalid_utf8)",
          "content_same": false
        },
        {
          "line": 2068,
          "old_api": "assign",
          "new_api": "getSourceLoc",
          "old_text": "Spaces.assign((Tmp - CurPtr + 1) / 2, ' ')",
          "new_text": "getSourceLoc(Tmp)",
          "old_line_content": "      Spaces.assign((Tmp - CurPtr + 1) / 2, ' ');",
          "new_line_content": "          .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp),",
          "content_same": false
        },
        {
          "line": 2115,
          "old_api": "fixItReplaceChars",
          "new_api": "getSourceLoc",
          "old_text": "diagnose(CurPtr - 1, diag::lex_confusable_character, ConfusedChar,\n             ExpectedChar)\n        .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp),\n                           ExpectedChar)",
          "new_text": "getSourceLoc(Tmp)",
          "old_line_content": "    diagnose(CurPtr - 1, diag::lex_confusable_character, ConfusedChar,",
          "new_line_content": "        .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp),",
          "content_same": false
        },
        {
          "line": 2246,
          "old_api": "push_back",
          "new_api": "EncodeToUTF8",
          "old_text": "TempString.push_back(CharValue)",
          "new_text": "EncodeToUTF8(CharValue, TempString)",
          "old_line_content": "      TempString.push_back(CharValue);",
          "new_line_content": "      EncodeToUTF8(CharValue, TempString);",
          "content_same": false
        },
        {
          "line": 2266,
          "old_api": "is",
          "new_api": "getStringLiteralContent",
          "old_text": "Str.is(tok::string_literal)",
          "new_text": "getStringLiteralContent(Str)",
          "old_line_content": "  assert(Str.is(tok::string_literal));",
          "new_line_content": "  StringRef Bytes = getStringLiteralContent(Str);",
          "content_same": false
        },
        {
          "line": 2273,
          "old_api": "getCustomDelimiterLen",
          "new_api": "size",
          "old_text": "Str.getCustomDelimiterLen()",
          "new_text": "getMultilineTrailingIndent(Bytes).size()",
          "old_line_content": "  unsigned IndentToStrip = 0, CustomDelimiterLen = Str.getCustomDelimiterLen();",
          "new_line_content": "    IndentToStrip = getMultilineTrailingIndent(Bytes).size();",
          "content_same": false
        },
        {
          "line": 2284,
          "old_api": "begin",
          "new_api": "delimiterMatches",
          "old_text": "Bytes.begin()",
          "new_text": "delimiterMatches(CustomDelimiterLen, BytesPtr, Diags)",
          "old_line_content": "    BytesPtr = Bytes.begin() + pos + 1;",
          "new_line_content": "    if (!delimiterMatches(CustomDelimiterLen, BytesPtr, Diags) ||",
          "content_same": false
        },
        {
          "line": 2301,
          "old_api": "getText",
          "new_api": "assert",
          "old_text": "skipToEndOfInterpolatedExpression(\n        BytesPtr, Str.getText().end(), MultilineString)",
          "new_text": "assert(*End == ')' && \"invalid string literal interpolations should\"\n           \" not be returned as string literals\")",
          "old_line_content": "    const char *End = skipToEndOfInterpolatedExpression(",
          "new_line_content": "    assert(*End == ')' && \"invalid string literal interpolations should\"",
          "content_same": false
        },
        {
          "line": 2316,
          "old_api": "push_back",
          "new_api": "end",
          "old_text": "Segments.push_back(\n      StringSegment::getLiteral(getSourceLoc(SegmentStartPtr),\n                                Bytes.end()-SegmentStartPtr,\n                                IsFirstSegment, true, IndentToStrip,\n                                CustomDelimiterLen))",
          "new_text": "Bytes.end()",
          "old_line_content": "  Segments.push_back(",
          "new_line_content": "                                Bytes.end()-SegmentStartPtr,",
          "content_same": false
        },
        {
          "line": 2338,
          "old_api": "assert",
          "new_api": "StringRef",
          "old_text": "assert(BOMLen == 3 && \"UTF-8 BOM is 3 bytes\")",
          "new_text": "StringRef(CurPtr, BOMLen)",
          "old_line_content": "      assert(BOMLen == 3 && \"UTF-8 BOM is 3 bytes\");",
          "new_line_content": "      auto Text = OwnedString::makeRefCounted(StringRef(CurPtr, BOMLen));",
          "content_same": false
        },
        {
          "line": 2358,
          "old_api": "lexIdentifier",
          "new_api": "advanceIfValidStartOfOperator",
          "old_text": "lexIdentifier()",
          "new_text": "advanceIfValidStartOfOperator(Tmp, BufferEnd)",
          "old_line_content": "      return lexIdentifier();",
          "new_line_content": "    if (advanceIfValidStartOfOperator(Tmp, BufferEnd))",
          "content_same": false
        },
        {
          "line": 2361,
          "old_api": "lexOperatorIdentifier",
          "new_api": "lexUnknown",
          "old_text": "lexOperatorIdentifier()",
          "new_text": "lexUnknown(/*EmitDiagnosticsIfToken=*/true)",
          "old_line_content": "      return lexOperatorIdentifier();",
          "new_line_content": "    bool ShouldTokenize = lexUnknown(/*EmitDiagnosticsIfToken=*/true);",
          "content_same": false
        },
        {
          "line": 2384,
          "old_api": "diagnose",
          "new_api": "formToken",
          "old_text": "diagnose(CurPtr-1, diag::lex_utf16_bom_marker)",
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "    diagnose(CurPtr-1, diag::lex_utf16_bom_marker);",
          "new_line_content": "    return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 2389,
          "old_api": "getNulCharacterKind",
          "new_api": "formToken",
          "old_text": "getNulCharacterKind(CurPtr - 1)",
          "new_text": "formToken(tok::code_complete, TokStart)",
          "old_line_content": "    switch (getNulCharacterKind(CurPtr - 1)) {",
          "new_line_content": "      return formToken(tok::code_complete, TokStart);",
          "content_same": false
        },
        {
          "line": 2419,
          "old_api": "advanceIfCustomDelimiter",
          "new_api": "lexHash",
          "old_text": "advanceIfCustomDelimiter(CurPtr, Diags)",
          "new_text": "lexHash()",
          "old_line_content": "    if (unsigned CustomDelimiterLen = advanceIfCustomDelimiter(CurPtr, Diags))",
          "new_line_content": "    return lexHash();",
          "content_same": false
        },
        {
          "line": 2427,
          "old_api": "isKeepingComments",
          "new_api": "formToken",
          "old_text": "isKeepingComments()",
          "new_text": "formToken(tok::comment, TokStart)",
          "old_line_content": "      assert(isKeepingComments() &&",
          "new_line_content": "      return formToken(tok::comment, TokStart);",
          "content_same": false
        },
        {
          "line": 2433,
          "old_api": "isKeepingComments",
          "new_api": "formToken",
          "old_text": "isKeepingComments()",
          "new_text": "formToken(tok::comment, TokStart)",
          "old_line_content": "      assert(isKeepingComments() &&",
          "new_line_content": "      return formToken(tok::comment, TokStart);",
          "content_same": false
        },
        {
          "line": 2435,
          "old_api": "formToken",
          "new_api": "lexOperatorIdentifier",
          "old_text": "formToken(tok::comment, TokStart)",
          "new_text": "lexOperatorIdentifier()",
          "old_line_content": "      return formToken(tok::comment, TokStart);",
          "new_line_content": "    return lexOperatorIdentifier();",
          "content_same": false
        },
        {
          "line": 2443,
          "old_api": "clang::isIdentifierBody(CurPtr[0])",
          "new_api": "formToken",
          "old_text": "clang::isIdentifierBody(CurPtr[0])",
          "new_text": "formToken(tok::sil_local_name, TokStart)",
          "old_line_content": "      } while (clang::isIdentifierBody(CurPtr[0]));",
          "new_line_content": "      return formToken(tok::sil_local_name, TokStart);",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": "formToken",
          "new_api": "lexOperatorIdentifier",
          "old_text": "formToken(tok::sil_local_name, TokStart)",
          "new_text": "lexOperatorIdentifier()",
          "old_line_content": "      return formToken(tok::sil_local_name, TokStart);",
          "new_line_content": "    return lexOperatorIdentifier();",
          "content_same": false
        },
        {
          "line": 2452,
          "old_api": "isLeftBound",
          "new_api": "lexOperatorIdentifier",
          "old_text": "isLeftBound(TokStart, ContentStart)",
          "new_text": "lexOperatorIdentifier()",
          "old_line_content": "    if (isLeftBound(TokStart, ContentStart))",
          "new_line_content": "    return lexOperatorIdentifier();",
          "content_same": false
        },
        {
          "line": 2457,
          "old_api": "isLeftBound",
          "new_api": "lexOperatorIdentifier",
          "old_text": "isLeftBound(TokStart, ContentStart)",
          "new_text": "lexOperatorIdentifier()",
          "old_line_content": "    if (isLeftBound(TokStart, ContentStart))",
          "new_line_content": "    return lexOperatorIdentifier();",
          "content_same": false
        },
        {
          "line": 2463,
          "old_api": "tryLexEditorPlaceholder",
          "new_api": "lexOperatorIdentifier",
          "old_text": "tryLexEditorPlaceholder()",
          "new_text": "lexOperatorIdentifier()",
          "old_line_content": "      return tryLexEditorPlaceholder();",
          "new_line_content": "    return lexOperatorIdentifier();",
          "content_same": false
        },
        {
          "line": 2506,
          "old_api": "findBufferContainingLoc",
          "new_api": "Token",
          "old_text": "SM.findBufferContainingLoc(Loc)",
          "new_text": "Token()",
          "old_line_content": "  int BufferID = SM.findBufferContainingLoc(Loc);",
          "new_line_content": "    return Token();",
          "content_same": false
        },
        {
          "line": 2538,
          "old_api": "setAtStartOfLine",
          "new_api": "TriviaPiece::carriageReturnLineFeeds(1)",
          "old_text": "NextToken.setAtStartOfLine(true)",
          "new_text": "TriviaPiece::carriageReturnLineFeeds(1)",
          "old_line_content": "    NextToken.setAtStartOfLine(true);",
          "new_line_content": "      Pieces.appendOrSquash(TriviaPiece::carriageReturnLineFeeds(1));",
          "content_same": false
        },
        {
          "line": 2566,
          "old_api": "skipSlashSlashComment",
          "new_api": "StringRef",
          "old_text": "skipSlashSlashComment(/*EatNewline=*/false)",
          "new_text": "StringRef(TriviaStart, Length)",
          "old_line_content": "      skipSlashSlashComment(/*EatNewline=*/false);",
          "new_line_content": "      auto Text = OwnedString::makeRefCounted(StringRef(TriviaStart, Length));",
          "content_same": false
        },
        {
          "line": 2568,
          "old_api": "StringRef",
          "new_api": "TriviaPiece::lineComment(Text)",
          "old_text": "StringRef(TriviaStart, Length)",
          "new_text": "TriviaPiece::lineComment(Text)",
          "old_line_content": "      auto Text = OwnedString::makeRefCounted(StringRef(TriviaStart, Length));",
          "new_line_content": "                                    : TriviaPiece::lineComment(Text));",
          "content_same": false
        },
        {
          "line": 2575,
          "old_api": "skipSlashStarComment",
          "new_api": "StringRef",
          "old_text": "skipSlashStarComment()",
          "new_text": "StringRef(TriviaStart, Length)",
          "old_line_content": "      skipSlashStarComment();",
          "new_line_content": "      auto Text = OwnedString::makeRefCounted(StringRef(TriviaStart, Length));",
          "content_same": false
        },
        {
          "line": 2577,
          "old_api": "StringRef",
          "new_api": "TriviaPiece::blockComment(Text)",
          "old_text": "StringRef(TriviaStart, Length)",
          "new_text": "TriviaPiece::blockComment(Text)",
          "old_line_content": "      auto Text = OwnedString::makeRefCounted(StringRef(TriviaStart, Length));",
          "new_line_content": "                                    : TriviaPiece::blockComment(Text));",
          "content_same": false
        },
        {
          "line": 2589,
          "old_api": "skipHashbang",
          "new_api": "StringRef",
          "old_text": "skipHashbang(/*EatNewline=*/false)",
          "new_text": "StringRef(TriviaStart, Length)",
          "old_line_content": "      skipHashbang(/*EatNewline=*/false);",
          "new_line_content": "      auto Text = OwnedString::makeRefCounted(StringRef(TriviaStart, Length));",
          "content_same": false
        },
        {
          "line": 2607,
          "old_api": "getNulCharacterKind",
          "new_api": "diagnoseEmbeddedNul",
          "old_text": "getNulCharacterKind(CurPtr - 1)",
          "new_text": "diagnoseEmbeddedNul(Diags, CurPtr - 1)",
          "old_line_content": "    switch (getNulCharacterKind(CurPtr - 1)) {",
          "new_line_content": "      diagnoseEmbeddedNul(Diags, CurPtr - 1);",
          "content_same": false
        },
        {
          "line": 2609,
          "old_api": "diagnoseEmbeddedNul",
          "new_api": "StringRef",
          "old_text": "diagnoseEmbeddedNul(Diags, CurPtr - 1)",
          "new_text": "StringRef(TriviaStart, Length)",
          "old_line_content": "      diagnoseEmbeddedNul(Diags, CurPtr - 1);",
          "new_line_content": "      auto Text = OwnedString::makeRefCounted(StringRef(TriviaStart, Length));",
          "content_same": false
        },
        {
          "line": 2687,
          "old_api": "lex",
          "new_api": "getLoc",
          "old_text": "L.lex(Tok)",
          "new_text": "Tok.getLoc()",
          "old_line_content": "    L.lex(Tok);",
          "new_line_content": "    unsigned TokOffs = SM.getLocOffsetInBuffer(Tok.getLoc(), BufferID);",
          "content_same": false
        },
        {
          "line": 2699,
          "old_api": "is",
          "new_api": "Lexer::getStringLiteralSegments(Tok, Segments, /*Diags=*/nullptr)",
          "old_text": "Tok.is(tok::string_literal)",
          "new_text": "Lexer::getStringLiteralSegments(Tok, Segments, /*Diags=*/nullptr)",
          "old_line_content": "      if (Tok.is(tok::string_literal)) {",
          "new_line_content": "        Lexer::getStringLiteralSegments(Tok, Segments, /*Diags=*/nullptr);",
          "content_same": false
        },
        {
          "line": 2701,
          "old_api": "Lexer::getStringLiteralSegments(Tok, Segments, /*Diags=*/nullptr)",
          "new_api": "getLocOffsetInBuffer",
          "old_text": "Lexer::getStringLiteralSegments(Tok, Segments, /*Diags=*/nullptr)",
          "new_text": "SM.getLocOffsetInBuffer(Seg.Loc, BufferID)",
          "old_line_content": "        Lexer::getStringLiteralSegments(Tok, Segments, /*Diags=*/nullptr);",
          "new_line_content": "          unsigned SegOffs = SM.getLocOffsetInBuffer(Seg.Loc, BufferID);",
          "content_same": false
        },
        {
          "line": 2716,
          "old_api": "getLoc",
          "new_api": "isNot",
          "old_text": "Tok.getLoc()",
          "new_text": "Tok.isNot(tok::eof)",
          "old_line_content": "      return Tok.getLoc();",
          "new_line_content": "  } while (Tok.isNot(tok::eof));",
          "content_same": false
        },
        {
          "line": 2739,
          "old_api": "isValid",
          "new_api": "findBufferContainingLoc",
          "old_text": "Loc.isValid()",
          "new_text": "SM.findBufferContainingLoc(Loc)",
          "old_line_content": "  if (!Loc.isValid())",
          "new_line_content": "  unsigned BufferId = SM.findBufferContainingLoc(Loc);",
          "content_same": false
        },
        {
          "line": 2740,
          "old_api": "SourceLoc",
          "new_api": "getLocOffsetInBuffer",
          "old_text": "SourceLoc()",
          "new_text": "getLocForStartOfToken(SM, BufferId,\n                               SM.getLocOffsetInBuffer(Loc, BufferId))",
          "old_line_content": "    return SourceLoc();",
          "new_line_content": "  return getLocForStartOfToken(SM, BufferId,",
          "content_same": false
        },
        {
          "line": 2741,
          "old_api": "findBufferContainingLoc",
          "new_api": "getLocOffsetInBuffer",
          "old_text": "SM.findBufferContainingLoc(Loc)",
          "new_text": "SM.getLocOffsetInBuffer(Loc, BufferId)",
          "old_line_content": "  unsigned BufferId = SM.findBufferContainingLoc(Loc);",
          "new_line_content": "                               SM.getLocOffsetInBuffer(Loc, BufferId));",
          "content_same": false
        },
        {
          "line": 2749,
          "old_api": "extractText",
          "new_api": "data",
          "old_text": "SM.extractText(entireRange)",
          "new_text": "Buffer.data()",
          "old_line_content": "  StringRef Buffer = SM.extractText(entireRange);",
          "new_line_content": "  const char *BufStart = Buffer.data();",
          "content_same": false
        },
        {
          "line": 2751,
          "old_api": "data",
          "new_api": "SourceLoc",
          "old_text": "Buffer.data()",
          "new_text": "SourceLoc()",
          "old_line_content": "  const char *BufStart = Buffer.data();",
          "new_line_content": "    return SourceLoc();",
          "content_same": false
        },
        {
          "line": 2763,
          "old_api": "findStartOfLine",
          "new_api": "size",
          "old_text": "findStartOfLine(BufStart, StrData)",
          "new_text": "getLocForStartOfTokenInBuf(SM, BufferID, Offset,\n                                    /*BufferStart=*/LexStart-BufStart,\n                                    /*BufferEnd=*/Buffer.size())",
          "old_line_content": "  const char *LexStart = findStartOfLine(BufStart, StrData);",
          "new_line_content": "  return getLocForStartOfTokenInBuf(SM, BufferID, Offset,",
          "content_same": false
        },
        {
          "line": 2776,
          "old_api": "findBufferContainingLoc",
          "new_api": "SourceLoc",
          "old_text": "SM.findBufferContainingLoc(Loc)",
          "new_text": "SourceLoc()",
          "old_line_content": "  int BufferID = SM.findBufferContainingLoc(Loc);",
          "new_line_content": "    return SourceLoc();",
          "content_same": false
        },
        {
          "line": 2778,
          "old_api": "SourceLoc",
          "new_api": "getRangeForBuffer",
          "old_text": "SourceLoc()",
          "new_text": "SM.getRangeForBuffer(BufferID)",
          "old_line_content": "    return SourceLoc();",
          "new_line_content": "  CharSourceRange entireRange = SM.getRangeForBuffer(BufferID);",
          "content_same": false
        },
        {
          "line": 2781,
          "old_api": "extractText",
          "new_api": "data",
          "old_text": "SM.extractText(entireRange)",
          "new_text": "Buffer.data()",
          "old_line_content": "  StringRef Buffer = SM.extractText(entireRange);",
          "new_line_content": "  const char *BufStart = Buffer.data();",
          "content_same": false
        },
        {
          "line": 2784,
          "old_api": "getLocOffsetInBuffer",
          "new_api": "findStartOfLine",
          "old_text": "SM.getLocOffsetInBuffer(Loc, BufferID)",
          "new_text": "findStartOfLine(BufStart, BufStart + Offset)",
          "old_line_content": "  unsigned Offset = SM.getLocOffsetInBuffer(Loc, BufferID);",
          "new_line_content": "  const char *StartOfLine = findStartOfLine(BufStart, BufStart + Offset);",
          "content_same": false
        },
        {
          "line": 2796,
          "old_api": "findBufferContainingLoc",
          "new_api": "SourceLoc",
          "old_text": "SM.findBufferContainingLoc(Loc)",
          "new_text": "SourceLoc()",
          "old_line_content": "  int BufferID = SM.findBufferContainingLoc(Loc);",
          "new_line_content": "    return SourceLoc();",
          "content_same": false
        },
        {
          "line": 2810,
          "old_api": "State",
          "new_api": "getSourceLoc",
          "old_text": "State(Loc)",
          "new_text": "getSourceLoc(L.CurPtr)",
          "old_line_content": "  L.restoreState(State(Loc));",
          "new_line_content": "  return getSourceLoc(L.CurPtr);",
          "content_same": false
        },
        {
          "line": 2836,
          "old_api": "extractText",
          "new_api": "data",
          "old_text": "SM.extractText(entireRange)",
          "new_text": "Buffer.data()",
          "old_line_content": "  StringRef Buffer = SM.extractText(entireRange);",
          "new_line_content": "  const char *BufStart = Buffer.data();",
          "content_same": false
        },
        {
          "line": 2839,
          "old_api": "getLocOffsetInBuffer",
          "new_api": "findStartOfLine",
          "old_text": "SM.getLocOffsetInBuffer(Loc, BufferID)",
          "new_text": "findStartOfLine(BufStart, BufStart + Offset)",
          "old_line_content": "  unsigned Offset = SM.getLocOffsetInBuffer(Loc, BufferID);",
          "new_line_content": "  const char *StartOfLine = findStartOfLine(BufStart, BufStart + Offset);",
          "content_same": false
        },
        {
          "line": 2841,
          "old_api": "findStartOfLine",
          "new_api": "isHorizontalWhitespace",
          "old_text": "findStartOfLine(BufStart, BufStart + Offset)",
          "new_text": "isHorizontalWhitespace(*EndOfIndentation)",
          "old_line_content": "  const char *StartOfLine = findStartOfLine(BufStart, BufStart + Offset);",
          "new_line_content": "  while (*EndOfIndentation && isHorizontalWhitespace(*EndOfIndentation))",
          "content_same": false
        },
        {
          "line": 2852,
          "old_api": "isValid",
          "new_api": "token_lower_bound",
          "old_text": "EndLoc.isValid()",
          "new_text": "token_lower_bound(AllTokens, EndLoc)",
          "old_line_content": "  assert(StartLoc.isValid() && EndLoc.isValid());",
          "new_line_content": "  auto EndIt = token_lower_bound(AllTokens, EndLoc);",
          "content_same": false
        },
        {
          "line": 2853,
          "old_api": "token_lower_bound",
          "new_api": "getLoc",
          "old_text": "token_lower_bound(AllTokens, StartLoc)",
          "new_text": "EndIt->getLoc()",
          "old_line_content": "  auto StartIt = token_lower_bound(AllTokens, StartLoc);",
          "new_line_content": "  assert(StartIt->getLoc() == StartLoc && EndIt->getLoc() == EndLoc);",
          "content_same": false
        },
        {
          "line": 2854,
          "old_api": "token_lower_bound",
          "new_api": "begin",
          "old_text": "token_lower_bound(AllTokens, EndLoc)",
          "new_text": "AllTokens.begin()",
          "old_line_content": "  auto EndIt = token_lower_bound(AllTokens, EndLoc);",
          "new_line_content": "  return AllTokens.slice(StartIt - AllTokens.begin(), EndIt - StartIt + 1);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2055,
          "old_api": null,
          "new_api": "validateUTF8CharacterAndAdvance",
          "old_text": null,
          "new_text": "validateUTF8CharacterAndAdvance(Tmp, BufferEnd)",
          "old_line_content": "",
          "new_line_content": "  uint32_t Codepoint = validateUTF8CharacterAndAdvance(Tmp, BufferEnd);",
          "content_same": false
        },
        {
          "line": 2058,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(Tmp)",
          "old_line_content": "  if (Codepoint == ~0U) {",
          "new_line_content": "        .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \" \");",
          "content_same": false
        },
        {
          "line": 2066,
          "old_api": null,
          "new_api": "assign",
          "old_text": null,
          "new_text": "Spaces.assign((Tmp - CurPtr + 1) / 2, ' ')",
          "old_line_content": "        Tmp += 2;",
          "new_line_content": "      Spaces.assign((Tmp - CurPtr + 1) / 2, ' ');",
          "content_same": false
        },
        {
          "line": 2067,
          "old_api": null,
          "new_api": "fixItReplaceChars",
          "old_text": null,
          "new_text": "diagnose(CurPtr - 1, diag::lex_nonbreaking_space)\n          .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp),\n                             Spaces)",
          "old_line_content": "      SmallString<8> Spaces;",
          "new_line_content": "      diagnose(CurPtr - 1, diag::lex_nonbreaking_space)",
          "content_same": false
        },
        {
          "line": 2075,
          "old_api": null,
          "new_api": "fixItReplaceChars",
          "old_text": null,
          "new_text": "diagnose(CurPtr - 1, diag::lex_invalid_curly_quote)\n          .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \"\\\"\")",
          "old_line_content": "    // If this is an end curly quote, just diagnose it with a fixit hint.",
          "new_line_content": "      diagnose(CurPtr - 1, diag::lex_invalid_curly_quote)",
          "content_same": false
        },
        {
          "line": 2076,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(Tmp)",
          "old_line_content": "    if (EmitDiagnosticsIfToken) {",
          "new_line_content": "          .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \"\\\"\");",
          "content_same": false
        },
        {
          "line": 2085,
          "old_api": null,
          "new_api": "findEndOfCurlyQuoteStringLiteral",
          "old_text": null,
          "new_text": "findEndOfCurlyQuoteStringLiteral(Tmp, EmitDiagnosticsIfToken)",
          "old_line_content": "    // to improve recovery.",
          "new_line_content": "            findEndOfCurlyQuoteStringLiteral(Tmp, EmitDiagnosticsIfToken))",
          "content_same": false
        },
        {
          "line": 2094,
          "old_api": null,
          "new_api": "fixItReplaceChars",
          "old_text": null,
          "new_text": "diagnose(CurPtr - 1, diag::lex_invalid_curly_quote)\n          .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(EndPtr),\n                             \"\\\"\")",
          "old_line_content": "    // literal.",
          "new_line_content": "      diagnose(CurPtr - 1, diag::lex_invalid_curly_quote)",
          "content_same": false
        },
        {
          "line": 2095,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(EndPtr)",
          "old_line_content": "    if (EmitDiagnosticsIfToken) {",
          "new_line_content": "          .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(EndPtr),",
          "content_same": false
        },
        {
          "line": 2102,
          "old_api": null,
          "new_api": "fixItReplaceChars",
          "old_text": null,
          "new_text": "diagnose(CurPtr - 1, diag::lex_invalid_character)\n      .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \" \")",
          "old_line_content": "  }",
          "new_line_content": "  diagnose(CurPtr - 1, diag::lex_invalid_character)",
          "content_same": false
        },
        {
          "line": 2103,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(Tmp)",
          "old_line_content": "",
          "new_line_content": "      .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \" \");",
          "content_same": false
        },
        {
          "line": 2107,
          "old_api": null,
          "new_api": "confusable::tryConvertConfusableCharacterToASCII(Codepoint)",
          "old_text": null,
          "new_text": "confusable::tryConvertConfusableCharacterToASCII(Codepoint)",
          "old_line_content": "  char ExpectedCodepoint;",
          "new_line_content": "           confusable::tryConvertConfusableCharacterToASCII(Codepoint))) {",
          "content_same": false
        },
        {
          "line": 2110,
          "old_api": null,
          "new_api": "EncodeToUTF8",
          "old_text": null,
          "new_text": "EncodeToUTF8(Codepoint, ConfusedChar)",
          "old_line_content": "",
          "new_line_content": "    EncodeToUTF8(Codepoint, ConfusedChar);",
          "content_same": false
        },
        {
          "line": 2113,
          "old_api": null,
          "new_api": "fixItReplaceChars",
          "old_text": null,
          "new_text": "diagnose(CurPtr - 1, diag::lex_confusable_character, ConfusedChar,\n             ExpectedChar)\n        .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp),\n                           ExpectedChar)",
          "old_line_content": "    llvm::SmallString<1> ExpectedChar;",
          "new_line_content": "    diagnose(CurPtr - 1, diag::lex_confusable_character, ConfusedChar,",
          "content_same": false
        },
        {
          "line": 2124,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(Ptr != nullptr && *Ptr == 0)",
          "old_line_content": "",
          "new_line_content": "  assert(Ptr != nullptr && *Ptr == 0);",
          "content_same": false
        },
        {
          "line": 2135,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(CurPtr[-1] == '<' && CurPtr[0] == '#')",
          "old_line_content": "",
          "new_line_content": "  assert(CurPtr[-1] == '<' && CurPtr[0] == '#');",
          "content_same": false
        },
        {
          "line": 2146,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(TokStart, diag::lex_editor_placeholder_in_playground)",
          "old_line_content": "      // rest of the compiler pipeline and lex it as an identifier.",
          "new_line_content": "        diagnose(TokStart, diag::lex_editor_placeholder_in_playground);",
          "content_same": false
        },
        {
          "line": 2151,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::identifier, TokStart)",
          "old_line_content": "      }",
          "new_line_content": "      formToken(tok::identifier, TokStart);",
          "content_same": false
        },
        {
          "line": 2157,
          "old_api": null,
          "new_api": "lexOperatorIdentifier",
          "old_text": null,
          "new_text": "lexOperatorIdentifier()",
          "old_line_content": "",
          "new_line_content": "  lexOperatorIdentifier();",
          "content_same": false
        },
        {
          "line": 2167,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "TempString.clear()",
          "old_line_content": "                                             unsigned CustomDelimiterLen) {",
          "new_line_content": "  TempString.clear();",
          "content_same": false
        },
        {
          "line": 2172,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "Bytes.begin()",
          "old_line_content": "  // unterminated literal or a segment that doesn't come from source). Use",
          "new_line_content": "  const char *BytesPtr = Bytes.begin();",
          "content_same": false
        },
        {
          "line": 2177,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "getMultilineTrailingIndent(Bytes).size()",
          "old_line_content": "  // This should allow multiline strings to work as attribute messages.",
          "new_line_content": "    IndentToStrip = getMultilineTrailingIndent(Bytes).size();",
          "content_same": false
        },
        {
          "line": 2180,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "Bytes.end()",
          "old_line_content": "",
          "new_line_content": "  while (BytesPtr < Bytes.end()) {",
          "content_same": false
        },
        {
          "line": 2186,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "Bytes.begin()",
          "old_line_content": "    if (CurChar == '\\r' || CurChar == '\\n') {",
          "new_line_content": "        (IsFirstSegment && BytesPtr - 1 == Bytes.begin());",
          "content_same": false
        },
        {
          "line": 2191,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "Bytes.end()",
          "old_line_content": "      if (*BytesPtr != '\\r' && *BytesPtr != '\\n')",
          "new_line_content": "      if (IsLastSegment && BytesPtr == Bytes.end())",
          "content_same": false
        },
        {
          "line": 2194,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "TempString.push_back('\\n')",
          "old_line_content": "        stripNewline = true;",
          "new_line_content": "        TempString.push_back('\\n');",
          "content_same": false
        },
        {
          "line": 2200,
          "old_api": null,
          "new_api": "delimiterMatches",
          "old_text": null,
          "new_text": "delimiterMatches(CustomDelimiterLen, BytesPtr, nullptr)",
          "old_line_content": "",
          "new_line_content": "        !delimiterMatches(CustomDelimiterLen, BytesPtr, nullptr)) {",
          "content_same": false
        },
        {
          "line": 2201,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "TempString.push_back(CurChar)",
          "old_line_content": "    if (CurChar != '\\\\' ||",
          "new_line_content": "      TempString.push_back(CurChar);",
          "content_same": false
        },
        {
          "line": 2213,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "TempString.push_back('\\0')",
          "old_line_content": "          ",
          "new_line_content": "    case '0': TempString.push_back('\\0'); continue;",
          "content_same": false
        },
        {
          "line": 2214,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "TempString.push_back('\\n')",
          "old_line_content": "      // Simple single-character escapes.",
          "new_line_content": "    case 'n': TempString.push_back('\\n'); continue;",
          "content_same": false
        },
        {
          "line": 2222,
          "old_api": null,
          "new_api": "maybeConsumeNewlineEscape",
          "old_text": null,
          "new_text": "maybeConsumeNewlineEscape(BytesPtr, -1)",
          "old_line_content": "",
          "new_line_content": "      if (maybeConsumeNewlineEscape(BytesPtr, -1)) {",
          "content_same": false
        },
        {
          "line": 2230,
          "old_api": null,
          "new_api": "llvm_unreachable",
          "old_text": null,
          "new_text": "llvm_unreachable(\"string contained interpolated segments\")",
          "old_line_content": "    // String interpolation.",
          "new_line_content": "      llvm_unreachable(\"string contained interpolated segments\");",
          "content_same": false
        },
        {
          "line": 2237,
          "old_api": null,
          "new_api": "lexUnicodeEscape",
          "old_text": null,
          "new_text": "lexUnicodeEscape(BytesPtr, /*no diagnostics*/nullptr)",
          "old_line_content": "        continue;       // Ignore invalid escapes.",
          "new_line_content": "      CharValue = lexUnicodeEscape(BytesPtr, /*no diagnostics*/nullptr);",
          "content_same": false
        },
        {
          "line": 2244,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "TempString.push_back(CharValue)",
          "old_line_content": "    ",
          "new_line_content": "      TempString.push_back(CharValue);",
          "content_same": false
        },
        {
          "line": 2253,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "Bytes.size()",
          "old_line_content": "  // is safe because unescaped strings are always shorter than their escaped",
          "new_line_content": "  if (TempString.size() == Bytes.size()) {",
          "content_same": false
        },
        {
          "line": 2254,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "TempString.clear()",
          "old_line_content": "  // forms (in a valid string).",
          "new_line_content": "    TempString.clear();",
          "content_same": false
        },
        {
          "line": 2257,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "TempString.size()",
          "old_line_content": "    return Bytes;",
          "new_line_content": "  return StringRef(TempString.begin(), TempString.size());",
          "content_same": false
        },
        {
          "line": 2264,
          "old_api": null,
          "new_api": "is",
          "old_text": null,
          "new_text": "Str.is(tok::string_literal)",
          "old_line_content": "              SmallVectorImpl<StringSegment> &Segments,",
          "new_line_content": "  assert(Str.is(tok::string_literal));",
          "content_same": false
        },
        {
          "line": 2270,
          "old_api": null,
          "new_api": "isMultilineString",
          "old_text": null,
          "new_text": "Str.isMultilineString()",
          "old_line_content": "  // Are substitutions required either for indent stripping or line ending",
          "new_line_content": "  bool MultilineString = Str.isMultilineString(), IsFirstSegment = true;",
          "content_same": false
        },
        {
          "line": 2271,
          "old_api": null,
          "new_api": "getCustomDelimiterLen",
          "old_text": null,
          "new_text": "Str.getCustomDelimiterLen()",
          "old_line_content": "  // normalization?",
          "new_line_content": "  unsigned IndentToStrip = 0, CustomDelimiterLen = Str.getCustomDelimiterLen();",
          "content_same": false
        },
        {
          "line": 2278,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "Bytes.begin()",
          "old_line_content": "  // we know that there is a terminating \" character.  Use BytesPtr to avoid a",
          "new_line_content": "  const char *SegmentStartPtr = Bytes.begin();",
          "content_same": false
        },
        {
          "line": 2281,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "Bytes.begin()",
          "old_line_content": "  const char *BytesPtr = SegmentStartPtr;",
          "new_line_content": "  while ((pos = Bytes.find('\\\\', BytesPtr-Bytes.begin())) != StringRef::npos) {",
          "content_same": false
        },
        {
          "line": 2282,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "Bytes.begin()",
          "old_line_content": "  size_t pos;",
          "new_line_content": "    BytesPtr = Bytes.begin() + pos + 1;",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "Segments.push_back(\n        StringSegment::getLiteral(getSourceLoc(SegmentStartPtr),\n                                  BytesPtr-SegmentStartPtr-2-CustomDelimiterLen,\n                                  IsFirstSegment, false, IndentToStrip,\n                                  CustomDelimiterLen))",
          "old_line_content": "",
          "new_line_content": "    Segments.push_back(",
          "content_same": false
        },
        {
          "line": 2292,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(SegmentStartPtr)",
          "old_line_content": "    // Push the current segment.",
          "new_line_content": "        StringSegment::getLiteral(getSourceLoc(SegmentStartPtr),",
          "content_same": false
        },
        {
          "line": 2299,
          "old_api": null,
          "new_api": "getText",
          "old_text": null,
          "new_text": "skipToEndOfInterpolatedExpression(\n        BytesPtr, Str.getText().end(), MultilineString)",
          "old_line_content": "",
          "new_line_content": "    const char *End = skipToEndOfInterpolatedExpression(",
          "content_same": false
        },
        {
          "line": 2300,
          "old_api": null,
          "new_api": "getText",
          "old_text": null,
          "new_text": "Str.getText().end()",
          "old_line_content": "    // Find the closing ')'.",
          "new_line_content": "        BytesPtr, Str.getText().end(), MultilineString);",
          "content_same": false
        },
        {
          "line": 2306,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "Segments.push_back(\n        StringSegment::getExpr(getSourceLoc(BytesPtr-1), End-BytesPtr+1))",
          "old_line_content": "",
          "new_line_content": "    Segments.push_back(",
          "content_same": false
        },
        {
          "line": 2307,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(BytesPtr-1)",
          "old_line_content": "    // Add an expression segment.",
          "new_line_content": "        StringSegment::getExpr(getSourceLoc(BytesPtr-1), End-BytesPtr+1));",
          "content_same": false
        },
        {
          "line": 2314,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "Segments.push_back(\n      StringSegment::getLiteral(getSourceLoc(SegmentStartPtr),\n                                Bytes.end()-SegmentStartPtr,\n                                IsFirstSegment, true, IndentToStrip,\n                                CustomDelimiterLen))",
          "old_line_content": "  }",
          "new_line_content": "  Segments.push_back(",
          "content_same": false
        },
        {
          "line": 2315,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(SegmentStartPtr)",
          "old_line_content": "",
          "new_line_content": "      StringSegment::getLiteral(getSourceLoc(SegmentStartPtr),",
          "content_same": false
        },
        {
          "line": 270,
          "old_api": null,
          "new_api": "peekNextToken",
          "old_text": null,
          "new_text": "L.peekNextToken()",
          "old_line_content": "  Token Result;",
          "new_line_content": "  return L.peekNextToken();",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(CurPtr >= BufferStart &&\n         CurPtr <= BufferEnd && \"Current pointer out of range!\")",
          "old_line_content": "",
          "new_line_content": "  assert(CurPtr >= BufferStart &&",
          "content_same": false
        },
        {
          "line": 2327,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(CurPtr >= BufferStart &&\n         CurPtr <= BufferEnd && \"Current pointer out of range!\")",
          "old_line_content": "",
          "new_line_content": "  assert(CurPtr >= BufferStart &&",
          "content_same": false
        },
        {
          "line": 2330,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "LeadingTrivia.clear()",
          "old_line_content": "         CurPtr <= BufferEnd && \"Current pointer out of range!\");",
          "new_line_content": "  LeadingTrivia.clear();",
          "content_same": false
        },
        {
          "line": 2331,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "TrailingTrivia.clear()",
          "old_line_content": "",
          "new_line_content": "  TrailingTrivia.clear();",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": null,
          "new_api": "isComment",
          "old_text": null,
          "new_text": "llvm::find_if(LeadingTrivia, [](const TriviaPiece &Piece) {\n      return Piece.isComment();\n    })",
          "old_line_content": "    // 'CommentLength' here is the length from the *first* comment to the",
          "new_line_content": "    auto Iter = llvm::find_if(LeadingTrivia, [](const TriviaPiece &Piece) {",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": null,
          "new_api": "isComment",
          "old_text": null,
          "new_text": "Piece.isComment()",
          "old_line_content": "    // token text (or its backtick if exist).",
          "new_line_content": "      return Piece.isComment();",
          "content_same": false
        },
        {
          "line": 2336,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(BOMLen == 3 && \"UTF-8 BOM is 3 bytes\")",
          "old_line_content": "    if (BufferStart < ContentStart) {",
          "new_line_content": "      assert(BOMLen == 3 && \"UTF-8 BOM is 3 bytes\");",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": null,
          "new_api": "getKind",
          "old_text": null,
          "new_text": "Iter->getKind()",
          "old_line_content": "    });",
          "new_line_content": "      if (Iter->getKind() == TriviaKind::Backtick)",
          "content_same": false
        },
        {
          "line": 2339,
          "old_api": null,
          "new_api": "TriviaPiece::garbageText(Text)",
          "old_text": null,
          "new_text": "TriviaPiece::garbageText(Text)",
          "old_line_content": "      // Add UTF-8 BOM to LeadingTrivia.",
          "new_line_content": "      LeadingTrivia.push_back(TriviaPiece::garbageText(Text));",
          "content_same": false
        },
        {
          "line": 2342,
          "old_api": null,
          "new_api": "setAtStartOfLine",
          "old_text": null,
          "new_text": "NextToken.setAtStartOfLine(true)",
          "old_line_content": "      CurPtr += BOMLen;",
          "new_line_content": "    NextToken.setAtStartOfLine(true);",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": null,
          "new_api": "getTextLength",
          "old_text": null,
          "new_text": "Iter->getTextLength()",
          "old_line_content": "        // we cannot include length of backtick.",
          "new_line_content": "      CommentLength += Iter->getTextLength();",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": null,
          "new_api": "static_cast<size_t>(CurPtr - TokStart)",
          "old_text": null,
          "new_text": "static_cast<size_t>(CurPtr - TokStart)",
          "old_line_content": "  }",
          "new_line_content": "  StringRef TokenText { TokStart, static_cast<size_t>(CurPtr - TokStart) };",
          "content_same": false
        },
        {
          "line": 2347,
          "old_api": null,
          "new_api": "lexTrivia",
          "old_text": null,
          "new_text": "lexTrivia(LeadingTrivia, /* IsForTrailingTrivia */ false)",
          "old_line_content": "  }",
          "new_line_content": "  lexTrivia(LeadingTrivia, /* IsForTrailingTrivia */ false);",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": null,
          "new_api": "lexTrivia",
          "old_text": null,
          "new_text": "lexTrivia(TrailingTrivia, /* IsForTrailingTrivia */ true)",
          "old_line_content": "",
          "new_line_content": "    lexTrivia(TrailingTrivia, /* IsForTrailingTrivia */ true);",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": null,
          "new_api": "setToken",
          "old_text": null,
          "new_text": "NextToken.setToken(Kind, TokenText, CommentLength)",
          "old_line_content": "  }",
          "new_line_content": "  NextToken.setToken(Kind, TokenText, CommentLength);",
          "content_same": false
        },
        {
          "line": 2355,
          "old_api": null,
          "new_api": "advanceIfValidStartOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidStartOfIdentifier(Tmp, BufferEnd)",
          "old_line_content": "  default: {",
          "new_line_content": "    if (advanceIfValidStartOfIdentifier(Tmp, BufferEnd))",
          "content_same": false
        },
        {
          "line": 2356,
          "old_api": null,
          "new_api": "lexIdentifier",
          "old_text": null,
          "new_text": "lexIdentifier()",
          "old_line_content": "    char const *Tmp = CurPtr-1;",
          "new_line_content": "      return lexIdentifier();",
          "content_same": false
        },
        {
          "line": 309,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(CurPtr - TokStart >= 3 && \"escaped identifier must be longer than or equal 3 bytes\")",
          "old_line_content": "",
          "new_line_content": "  assert(CurPtr - TokStart >= 3 && \"escaped identifier must be longer than or equal 3 bytes\");",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(TokStart[0] == '`' && \"escaped identifier starts with backtick\")",
          "old_line_content": "void Lexer::formEscapedIdentifierToken(const char *TokStart) {",
          "new_line_content": "  assert(TokStart[0] == '`' && \"escaped identifier starts with backtick\");",
          "content_same": false
        },
        {
          "line": 2359,
          "old_api": null,
          "new_api": "lexOperatorIdentifier",
          "old_text": null,
          "new_text": "lexOperatorIdentifier()",
          "old_line_content": "    ",
          "new_line_content": "      return lexOperatorIdentifier();",
          "content_same": false
        },
        {
          "line": 314,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "TrailingTrivia.empty()",
          "old_line_content": "",
          "new_line_content": "  assert(TrailingTrivia.empty() && \"TrailingTrivia is empty here\");",
          "content_same": false
        },
        {
          "line": 2362,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(\n        ShouldTokenize &&\n        \"Invalid UTF-8 sequence should be eaten by lexTrivia as LeadingTrivia\")",
          "old_line_content": "",
          "new_line_content": "    assert(",
          "content_same": false
        },
        {
          "line": 2366,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "        \"Invalid UTF-8 sequence should be eaten by lexTrivia as LeadingTrivia\");",
          "new_line_content": "    return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 320,
          "old_api": null,
          "new_api": "is",
          "old_text": null,
          "new_text": "NextToken.is(tok::eof)",
          "old_line_content": "  // If this token is at ArtificialEOF, it's forced to be tok::eof. Don't mark",
          "new_line_content": "  if (NextToken.is(tok::eof))",
          "content_same": false
        },
        {
          "line": 2371,
          "old_api": null,
          "new_api": "llvm_unreachable",
          "old_text": null,
          "new_text": "llvm_unreachable(\"Newlines should be eaten by lexTrivia as LeadingTrivia\")",
          "old_line_content": "  case '\\n':",
          "new_line_content": "    llvm_unreachable(\"Newlines should be eaten by lexTrivia as LeadingTrivia\");",
          "content_same": false
        },
        {
          "line": 2377,
          "old_api": null,
          "new_api": "llvm_unreachable",
          "old_text": null,
          "new_text": "llvm_unreachable(\n        \"Whitespaces should be eaten by lexTrivia as LeadingTrivia\")",
          "old_line_content": "  case '\\f':",
          "new_line_content": "    llvm_unreachable(",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::string_literal, TokStart)",
          "old_line_content": "                                   bool IsMultilineString,",
          "new_line_content": "  formToken(tok::string_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": null,
          "new_api": "is",
          "old_text": null,
          "new_text": "NextToken.is(tok::eof)",
          "old_line_content": "                                   unsigned CustomDelimiterLen) {",
          "new_line_content": "  if (NextToken.is(tok::eof))",
          "content_same": false
        },
        {
          "line": 2382,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CurPtr-1, diag::lex_utf16_bom_marker)",
          "old_line_content": "  case -1:",
          "new_line_content": "    diagnose(CurPtr-1, diag::lex_utf16_bom_marker);",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": null,
          "new_api": "validateMultilineIndents",
          "old_text": null,
          "new_text": "validateMultilineIndents(NextToken, Diags)",
          "old_line_content": "",
          "new_line_content": "    validateMultilineIndents(NextToken, Diags);",
          "content_same": false
        },
        {
          "line": 2387,
          "old_api": null,
          "new_api": "getNulCharacterKind",
          "old_text": null,
          "new_text": "getNulCharacterKind(CurPtr - 1)",
          "old_line_content": "",
          "new_line_content": "    switch (getNulCharacterKind(CurPtr - 1)) {",
          "content_same": false
        },
        {
          "line": 340,
          "old_api": null,
          "new_api": "getBufferPtrForSourceLoc",
          "old_text": null,
          "new_text": "getBufferPtrForSourceLoc(Loc)",
          "old_line_content": "",
          "new_line_content": "  const char *Ptr = getBufferPtrForSourceLoc(Loc);",
          "content_same": false
        },
        {
          "line": 2396,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::eof, TokStart)",
          "old_line_content": "      --CurPtr;",
          "new_line_content": "      return formToken(tok::eof, TokStart);",
          "content_same": false
        },
        {
          "line": 2399,
          "old_api": null,
          "new_api": "llvm_unreachable",
          "old_text": null,
          "new_text": "llvm_unreachable(\n          \"Embedded nul should be eaten by lexTrivia as LeadingTrivia\")",
          "old_line_content": "",
          "new_line_content": "      llvm_unreachable(",
          "content_same": false
        },
        {
          "line": 2403,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::at_sign, TokStart)",
          "old_line_content": "    }",
          "new_line_content": "  case '@': return formToken(tok::at_sign, TokStart);",
          "content_same": false
        },
        {
          "line": 2404,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::l_brace, TokStart)",
          "old_line_content": "",
          "new_line_content": "  case '{': return formToken(tok::l_brace, TokStart);",
          "content_same": false
        },
        {
          "line": 363,
          "old_api": null,
          "new_api": "llvm::SMLoc::getFromPointer(Ptr)",
          "old_text": null,
          "new_text": "llvm::SMLoc::getFromPointer(Ptr)",
          "old_line_content": "    break;",
          "new_line_content": "  return State(SourceLoc(llvm::SMLoc::getFromPointer(Ptr)));",
          "content_same": false
        },
        {
          "line": 2412,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::semi, TokStart)",
          "old_line_content": "",
          "new_line_content": "  case ';': return formToken(tok::semi, TokStart);",
          "content_same": false
        },
        {
          "line": 2417,
          "old_api": null,
          "new_api": "advanceIfCustomDelimiter",
          "old_text": null,
          "new_text": "advanceIfCustomDelimiter(CurPtr, Diags)",
          "old_line_content": "",
          "new_line_content": "    if (unsigned CustomDelimiterLen = advanceIfCustomDelimiter(CurPtr, Diags))",
          "content_same": false
        },
        {
          "line": 2418,
          "old_api": null,
          "new_api": "lexStringLiteral",
          "old_text": null,
          "new_text": "lexStringLiteral(CustomDelimiterLen)",
          "old_line_content": "  case '#':",
          "new_line_content": "      return lexStringLiteral(CustomDelimiterLen);",
          "content_same": false
        },
        {
          "line": 371,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(Ptr && \"invalid source location\")",
          "old_line_content": "",
          "new_line_content": "  assert(Ptr && \"invalid source location\");",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(*Ptr == '\\0' && \"not an embedded null\")",
          "old_line_content": "static void diagnoseEmbeddedNul(DiagnosticEngine *Diags, const char *Ptr) {",
          "new_line_content": "  assert(*Ptr == '\\0' && \"not an embedded null\");",
          "content_same": false
        },
        {
          "line": 2424,
          "old_api": null,
          "new_api": "skipSlashSlashComment",
          "old_text": null,
          "new_text": "skipSlashSlashComment(/*EatNewline=*/true)",
          "old_line_content": "  case '/':",
          "new_line_content": "      skipSlashSlashComment(/*EatNewline=*/true);",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(Ptr)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(Ptr)",
          "old_line_content": "    return;",
          "new_line_content": "  SourceLoc NulLoc = Lexer::getSourceLoc(Ptr);",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(Ptr+1)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(Ptr+1)",
          "old_line_content": "",
          "new_line_content": "  SourceLoc NulEndLoc = Lexer::getSourceLoc(Ptr+1);",
          "content_same": false
        },
        {
          "line": 2425,
          "old_api": null,
          "new_api": "isKeepingComments",
          "old_text": null,
          "new_text": "isKeepingComments()",
          "old_line_content": "    if (CurPtr[0] == '/') {  // \"//\"",
          "new_line_content": "      assert(isKeepingComments() &&",
          "content_same": false
        },
        {
          "line": 2430,
          "old_api": null,
          "new_api": "skipSlashStarComment",
          "old_text": null,
          "new_text": "skipSlashStarComment()",
          "old_line_content": "    }",
          "new_line_content": "      skipSlashStarComment();",
          "content_same": false
        },
        {
          "line": 2431,
          "old_api": null,
          "new_api": "isKeepingComments",
          "old_text": null,
          "new_text": "isKeepingComments()",
          "old_line_content": "    if (CurPtr[0] == '*') { // \"/*\"",
          "new_line_content": "      assert(isKeepingComments() &&",
          "content_same": false
        },
        {
          "line": 2438,
          "old_api": null,
          "new_api": "clang::isIdentifierBody(CurPtr[0])",
          "old_text": null,
          "new_text": "clang::isIdentifierBody(CurPtr[0])",
          "old_line_content": "  case '%':",
          "new_line_content": "    if (InSILBody && clang::isIdentifierBody(CurPtr[0])) {",
          "content_same": false
        },
        {
          "line": 2441,
          "old_api": null,
          "new_api": "clang::isIdentifierBody(CurPtr[0])",
          "old_text": null,
          "new_text": "clang::isIdentifierBody(CurPtr[0])",
          "old_line_content": "      do {",
          "new_line_content": "      } while (clang::isIdentifierBody(CurPtr[0]));",
          "content_same": false
        },
        {
          "line": 399,
          "old_api": null,
          "new_api": "validateUTF8CharacterAndAdvance",
          "old_text": null,
          "new_text": "validateUTF8CharacterAndAdvance(CurPtr, BufferEnd)",
          "old_line_content": "        --CurPtr;",
          "new_line_content": "        if (validateUTF8CharacterAndAdvance(CurPtr, BufferEnd) == ~0U)",
          "content_same": false
        },
        {
          "line": 400,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(CharStart)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(CharStart)",
          "old_line_content": "        const char *CharStart = CurPtr;",
          "new_line_content": "          Diags->diagnose(Lexer::getSourceLoc(CharStart),",
          "content_same": false
        },
        {
          "line": 2449,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::sil_exclamation, TokStart)",
          "old_line_content": "  case '!':",
          "new_line_content": "      return formToken(tok::sil_exclamation, TokStart);",
          "content_same": false
        },
        {
          "line": 2450,
          "old_api": null,
          "new_api": "isLeftBound",
          "old_text": null,
          "new_text": "isLeftBound(TokStart, ContentStart)",
          "old_line_content": "    if (InSILBody)",
          "new_line_content": "    if (isLeftBound(TokStart, ContentStart))",
          "content_same": false
        },
        {
          "line": 2455,
          "old_api": null,
          "new_api": "isLeftBound",
          "old_text": null,
          "new_text": "isLeftBound(TokStart, ContentStart)",
          "old_line_content": "  ",
          "new_line_content": "    if (isLeftBound(TokStart, ContentStart))",
          "content_same": false
        },
        {
          "line": 2456,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::question_postfix, TokStart)",
          "old_line_content": "  case '?':",
          "new_line_content": "      return formToken(tok::question_postfix, TokStart);",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": null,
          "new_api": "diagnoseEmbeddedNul",
          "old_text": null,
          "new_text": "diagnoseEmbeddedNul(Diags, CurPtr - 1)",
          "old_line_content": "          // If this is a random nul character in the middle of a buffer, skip",
          "new_line_content": "          diagnoseEmbeddedNul(Diags, CurPtr - 1);",
          "content_same": false
        },
        {
          "line": 2461,
          "old_api": null,
          "new_api": "tryLexEditorPlaceholder",
          "old_text": null,
          "new_text": "tryLexEditorPlaceholder()",
          "old_line_content": "  case '<':",
          "new_line_content": "      return tryLexEditorPlaceholder();",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": null,
          "new_api": "advanceToEndOfLine",
          "old_text": null,
          "new_text": "advanceToEndOfLine(CurPtr, BufferEnd, CodeCompletionPtr, Diags)",
          "old_line_content": "",
          "new_line_content": "  bool isEOL = advanceToEndOfLine(CurPtr, BufferEnd, CodeCompletionPtr, Diags);",
          "content_same": false
        },
        {
          "line": 2469,
          "old_api": null,
          "new_api": "lexOperatorIdentifier",
          "old_text": null,
          "new_text": "lexOperatorIdentifier()",
          "old_line_content": "  case '=': case '-': case '+': case '*':",
          "new_line_content": "    return lexOperatorIdentifier();",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": null,
          "new_api": "setAtStartOfLine",
          "old_text": null,
          "new_text": "NextToken.setAtStartOfLine(true)",
          "old_line_content": "  if (EatNewline && isEOL) {",
          "new_line_content": "    NextToken.setAtStartOfLine(true);",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(CurPtr[-1] == '/' && CurPtr[0] == '/' && \"Not a // comment\")",
          "old_line_content": "",
          "new_line_content": "  assert(CurPtr[-1] == '/' && CurPtr[0] == '/' && \"Not a // comment\");",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": null,
          "new_api": "skipToEndOfLine",
          "old_text": null,
          "new_text": "skipToEndOfLine(EatNewline)",
          "old_line_content": "void Lexer::skipSlashSlashComment(bool EatNewline) {",
          "new_line_content": "  skipToEndOfLine(EatNewline);",
          "content_same": false
        },
        {
          "line": 2480,
          "old_api": null,
          "new_api": "lexIdentifier",
          "old_text": null,
          "new_text": "lexIdentifier()",
          "old_line_content": "  case 'v': case 'w': case 'x': case 'y': case 'z':",
          "new_line_content": "    return lexIdentifier();",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(CurPtr == ContentStart && CurPtr[0] == '#' && CurPtr[1] == '!' &&\n         \"Not a hashbang\")",
          "old_line_content": "",
          "new_line_content": "  assert(CurPtr == ContentStart && CurPtr[0] == '#' && CurPtr[1] == '!' &&",
          "content_same": false
        },
        {
          "line": 2483,
          "old_api": null,
          "new_api": "lexDollarIdent",
          "old_text": null,
          "new_text": "lexDollarIdent()",
          "old_line_content": "",
          "new_line_content": "    return lexDollarIdent();",
          "content_same": false
        },
        {
          "line": 2487,
          "old_api": null,
          "new_api": "lexNumber",
          "old_text": null,
          "new_text": "lexNumber()",
          "old_line_content": "  case '0': case '1': case '2': case '3': case '4':",
          "new_line_content": "    return lexNumber();",
          "content_same": false
        },
        {
          "line": 2491,
          "old_api": null,
          "new_api": "lexStringLiteral",
          "old_text": null,
          "new_text": "lexStringLiteral()",
          "old_line_content": "  case '\"':",
          "new_line_content": "    return lexStringLiteral();",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(CurPtr[-1] == '/' && CurPtr[0] == '*' && \"Not a /* comment\")",
          "old_line_content": "                                        DiagnosticEngine *Diags = nullptr) {",
          "new_line_content": "  assert(CurPtr[-1] == '/' && CurPtr[0] == '*' && \"Not a /* comment\");",
          "content_same": false
        },
        {
          "line": 2494,
          "old_api": null,
          "new_api": "lexEscapedIdentifier",
          "old_text": null,
          "new_text": "lexEscapedIdentifier()",
          "old_line_content": "      ",
          "new_line_content": "    return lexEscapedIdentifier();",
          "content_same": false
        },
        {
          "line": 2500,
          "old_api": null,
          "new_api": "isValid",
          "old_text": null,
          "new_text": "Loc.isValid()",
          "old_line_content": "Token Lexer::getTokenAtLocation(const SourceManager &SM, SourceLoc Loc) {",
          "new_line_content": "  if (!Loc.isValid())",
          "content_same": false
        },
        {
          "line": 2501,
          "old_api": null,
          "new_api": "Token",
          "old_text": null,
          "new_text": "Token()",
          "old_line_content": "  // Don't try to do anything with an invalid location.",
          "new_line_content": "    return Token();",
          "content_same": false
        },
        {
          "line": 2504,
          "old_api": null,
          "new_api": "findBufferContainingLoc",
          "old_text": null,
          "new_text": "SM.findBufferContainingLoc(Loc)",
          "old_line_content": "",
          "new_line_content": "  int BufferID = SM.findBufferContainingLoc(Loc);",
          "content_same": false
        },
        {
          "line": 2518,
          "old_api": null,
          "new_api": "State",
          "old_text": null,
          "new_text": "State(Loc)",
          "old_line_content": "  Lexer L(FakeLangOpts, SM, BufferID, nullptr, /*InSILMode=*/ false,",
          "new_line_content": "  L.restoreState(State(Loc));",
          "content_same": false
        },
        {
          "line": 2519,
          "old_api": null,
          "new_api": "peekNextToken",
          "old_text": null,
          "new_text": "L.peekNextToken()",
          "old_line_content": "          HashbangMode::Allowed, CommentRetentionMode::ReturnAsTokens);",
          "new_line_content": "  return L.peekNextToken();",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": null,
          "new_api": "validateUTF8CharacterAndAdvance",
          "old_text": null,
          "new_text": "validateUTF8CharacterAndAdvance(CurPtr, BufferEnd)",
          "old_line_content": "        --CurPtr;",
          "new_line_content": "        if (validateUTF8CharacterAndAdvance(CurPtr, BufferEnd) == ~0U)",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(CharStart)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(CharStart)",
          "old_line_content": "        const char *CharStart = CurPtr;",
          "new_line_content": "          Diags->diagnose(Lexer::getSourceLoc(CharStart),",
          "content_same": false
        },
        {
          "line": 2530,
          "old_api": null,
          "new_api": "setAtStartOfLine",
          "old_text": null,
          "new_text": "NextToken.setAtStartOfLine(true)",
          "old_line_content": "    if (IsForTrailingTrivia)",
          "new_line_content": "    NextToken.setAtStartOfLine(true);",
          "content_same": false
        },
        {
          "line": 2531,
          "old_api": null,
          "new_api": "TriviaPiece::newlines(1)",
          "old_text": null,
          "new_text": "TriviaPiece::newlines(1)",
          "old_line_content": "      break;",
          "new_line_content": "    Pieces.appendOrSquash(TriviaPiece::newlines(1));",
          "content_same": false
        },
        {
          "line": 2536,
          "old_api": null,
          "new_api": "setAtStartOfLine",
          "old_text": null,
          "new_text": "NextToken.setAtStartOfLine(true)",
          "old_line_content": "    if (IsForTrailingTrivia)",
          "new_line_content": "    NextToken.setAtStartOfLine(true);",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": null,
          "new_api": "diagnoseEmbeddedNul",
          "old_text": null,
          "new_text": "diagnoseEmbeddedNul(Diags, CurPtr - 1)",
          "old_line_content": "          // If this is a random nul character in the middle of a buffer, skip",
          "new_line_content": "          diagnoseEmbeddedNul(Diags, CurPtr - 1);",
          "content_same": false
        },
        {
          "line": 2541,
          "old_api": null,
          "new_api": "TriviaPiece::carriageReturns(1)",
          "old_text": null,
          "new_text": "TriviaPiece::carriageReturns(1)",
          "old_line_content": "      ++CurPtr;",
          "new_line_content": "      Pieces.appendOrSquash(TriviaPiece::carriageReturns(1));",
          "content_same": false
        },
        {
          "line": 2545,
          "old_api": null,
          "new_api": "TriviaPiece::spaces(1)",
          "old_text": null,
          "new_text": "TriviaPiece::spaces(1)",
          "old_line_content": "    goto Restart;",
          "new_line_content": "    Pieces.appendOrSquash(TriviaPiece::spaces(1));",
          "content_same": false
        },
        {
          "line": 2548,
          "old_api": null,
          "new_api": "TriviaPiece::tabs(1)",
          "old_text": null,
          "new_text": "TriviaPiece::tabs(1)",
          "old_line_content": "    goto Restart;",
          "new_line_content": "    Pieces.appendOrSquash(TriviaPiece::tabs(1));",
          "content_same": false
        },
        {
          "line": 2551,
          "old_api": null,
          "new_api": "TriviaPiece::verticalTabs(1)",
          "old_text": null,
          "new_text": "TriviaPiece::verticalTabs(1)",
          "old_line_content": "    goto Restart;",
          "new_line_content": "    Pieces.appendOrSquash(TriviaPiece::verticalTabs(1));",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": null,
          "new_api": "fixItInsert",
          "old_text": null,
          "new_text": "Diags\n            ->diagnose(Lexer::getSourceLoc(EOL),\n                       diag::lex_unterminated_block_comment)\n            .fixItInsert(Lexer::getSourceLoc(EOL), Terminator)",
          "old_line_content": "          Terminator += \"*/\";",
          "new_line_content": "        Diags",
          "content_same": false
        },
        {
          "line": 2554,
          "old_api": null,
          "new_api": "TriviaPiece::formfeeds(1)",
          "old_text": null,
          "new_text": "TriviaPiece::formfeeds(1)",
          "old_line_content": "    goto Restart;",
          "new_line_content": "    Pieces.appendOrSquash(TriviaPiece::formfeeds(1));",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(EOL)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(EOL)",
          "old_line_content": "        const char *EOL = (CurPtr[-1] == '\\n') ? (CurPtr - 1) : CurPtr;",
          "new_line_content": "            ->diagnose(Lexer::getSourceLoc(EOL),",
          "content_same": false
        },
        {
          "line": 2557,
          "old_api": null,
          "new_api": "isKeepingComments",
          "old_text": null,
          "new_text": "isKeepingComments()",
          "old_line_content": "    goto Restart;",
          "new_line_content": "    if (IsForTrailingTrivia || isKeepingComments()) {",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(StartPtr)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(StartPtr)",
          "old_line_content": "                       diag::lex_unterminated_block_comment)",
          "new_line_content": "        Diags->diagnose(Lexer::getSourceLoc(StartPtr), diag::lex_comment_start);",
          "content_same": false
        },
        {
          "line": 2564,
          "old_api": null,
          "new_api": "skipSlashSlashComment",
          "old_text": null,
          "new_text": "skipSlashSlashComment(/*EatNewline=*/false)",
          "old_line_content": "      // '// ...' comment.",
          "new_line_content": "      skipSlashSlashComment(/*EatNewline=*/false);",
          "content_same": false
        },
        {
          "line": 2567,
          "old_api": null,
          "new_api": "TriviaPiece::docLineComment(Text)",
          "old_text": null,
          "new_text": "TriviaPiece::docLineComment(Text)",
          "old_line_content": "      size_t Length = CurPtr - TriviaStart;",
          "new_line_content": "      Pieces.push_back(isDocComment ? TriviaPiece::docLineComment(Text)",
          "content_same": false
        },
        {
          "line": 520,
          "old_api": null,
          "new_api": "skipToEndOfSlashStarComment",
          "old_text": null,
          "new_text": "skipToEndOfSlashStarComment(CurPtr, BufferEnd, CodeCompletionPtr, Diags)",
          "old_line_content": "void Lexer::skipSlashStarComment() {",
          "new_line_content": "      skipToEndOfSlashStarComment(CurPtr, BufferEnd, CodeCompletionPtr, Diags);",
          "content_same": false
        },
        {
          "line": 2573,
          "old_api": null,
          "new_api": "skipSlashStarComment",
          "old_text": null,
          "new_text": "skipSlashStarComment()",
          "old_line_content": "      // '/* ... */' comment.",
          "new_line_content": "      skipSlashStarComment();",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": null,
          "new_api": "clang::isIdentifierBody(c, /*dollar*/true)",
          "old_text": null,
          "new_text": "clang::isIdentifierBody(c, /*dollar*/true)",
          "old_line_content": "static bool isValidIdentifierContinuationCodePoint(uint32_t c) {",
          "new_line_content": "    return clang::isIdentifierBody(c, /*dollar*/true);",
          "content_same": false
        },
        {
          "line": 2576,
          "old_api": null,
          "new_api": "TriviaPiece::docBlockComment(Text)",
          "old_text": null,
          "new_text": "TriviaPiece::docBlockComment(Text)",
          "old_line_content": "      size_t Length = CurPtr - TriviaStart;",
          "new_line_content": "      Pieces.push_back(isDocComment ? TriviaPiece::docBlockComment(Text)",
          "content_same": false
        },
        {
          "line": 2586,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(TriviaStart, diag::lex_hashbang_not_allowed)",
          "old_line_content": "      --CurPtr;",
          "new_line_content": "        diagnose(TriviaStart, diag::lex_hashbang_not_allowed);",
          "content_same": false
        },
        {
          "line": 2587,
          "old_api": null,
          "new_api": "skipHashbang",
          "old_text": null,
          "new_text": "skipHashbang(/*EatNewline=*/false)",
          "old_line_content": "      if (!IsHashbangAllowed)",
          "new_line_content": "      skipHashbang(/*EatNewline=*/false);",
          "content_same": false
        },
        {
          "line": 2590,
          "old_api": null,
          "new_api": "TriviaPiece::garbageText(Text)",
          "old_text": null,
          "new_text": "TriviaPiece::garbageText(Text)",
          "old_line_content": "      size_t Length = CurPtr - TriviaStart;",
          "new_line_content": "      Pieces.push_back(TriviaPiece::garbageText(Text));",
          "content_same": false
        },
        {
          "line": 2596,
          "old_api": null,
          "new_api": "tryLexConflictMarker",
          "old_text": null,
          "new_text": "tryLexConflictMarker(/*EatNewline=*/false)",
          "old_line_content": "  case '<':",
          "new_line_content": "    if (tryLexConflictMarker(/*EatNewline=*/false)) {",
          "content_same": false
        },
        {
          "line": 2599,
          "old_api": null,
          "new_api": "StringRef",
          "old_text": null,
          "new_text": "StringRef(TriviaStart, Length)",
          "old_line_content": "      // Conflict marker.",
          "new_line_content": "      auto Text = OwnedString::makeRefCounted(StringRef(TriviaStart, Length));",
          "content_same": false
        },
        {
          "line": 2600,
          "old_api": null,
          "new_api": "TriviaPiece::garbageText(Text)",
          "old_text": null,
          "new_text": "TriviaPiece::garbageText(Text)",
          "old_line_content": "      size_t Length = CurPtr - TriviaStart;",
          "new_line_content": "      Pieces.push_back(TriviaPiece::garbageText(Text));",
          "content_same": false
        },
        {
          "line": 2605,
          "old_api": null,
          "new_api": "getNulCharacterKind",
          "old_text": null,
          "new_text": "getNulCharacterKind(CurPtr - 1)",
          "old_line_content": "    break;",
          "new_line_content": "    switch (getNulCharacterKind(CurPtr - 1)) {",
          "content_same": false
        },
        {
          "line": 2610,
          "old_api": null,
          "new_api": "TriviaPiece::garbageText(Text)",
          "old_text": null,
          "new_text": "TriviaPiece::garbageText(Text)",
          "old_line_content": "      size_t Length = CurPtr - TriviaStart;",
          "new_line_content": "      Pieces.push_back(TriviaPiece::garbageText(Text));",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": null,
          "new_api": "isValidIdentifierContinuationCodePoint",
          "old_text": null,
          "new_text": "isValidIdentifierContinuationCodePoint(c)",
          "old_line_content": "}",
          "new_line_content": "  if (!isValidIdentifierContinuationCodePoint(c))",
          "content_same": false
        },
        {
          "line": 2642,
          "old_api": null,
          "new_api": "advanceIfValidStartOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidStartOfIdentifier(Tmp, BufferEnd)",
          "old_line_content": "  default:",
          "new_line_content": "    if (advanceIfValidStartOfIdentifier(Tmp, BufferEnd)) {",
          "content_same": false
        },
        {
          "line": 2645,
          "old_api": null,
          "new_api": "advanceIfValidStartOfOperator",
          "old_text": null,
          "new_text": "advanceIfValidStartOfOperator(Tmp, BufferEnd)",
          "old_line_content": "      break;",
          "new_line_content": "    if (advanceIfValidStartOfOperator(Tmp, BufferEnd)) {",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": null,
          "new_api": "validateUTF8CharacterAndAdvance",
          "old_text": null,
          "new_text": "validateUTF8CharacterAndAdvance(next, end)",
          "old_line_content": "                      bool (*predicate)(uint32_t)) {",
          "new_line_content": "  uint32_t c = validateUTF8CharacterAndAdvance(next, end);",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": null,
          "new_api": "predicate",
          "old_text": null,
          "new_text": "predicate(c)",
          "old_line_content": "  if (c == ~0U)",
          "new_line_content": "  if (predicate(c)) {",
          "content_same": false
        },
        {
          "line": 2649,
          "old_api": null,
          "new_api": "lexUnknown",
          "old_text": null,
          "new_text": "lexUnknown(/*EmitDiagnosticsIfToken=*/false)",
          "old_line_content": "    }",
          "new_line_content": "    bool ShouldTokenize = lexUnknown(/*EmitDiagnosticsIfToken=*/false);",
          "content_same": false
        },
        {
          "line": 2656,
          "old_api": null,
          "new_api": "StringRef",
          "old_text": null,
          "new_text": "StringRef(TriviaStart, Length)",
          "old_line_content": "",
          "new_line_content": "    auto Text = OwnedString::makeRefCounted(StringRef(TriviaStart, Length));",
          "content_same": false
        },
        {
          "line": 2657,
          "old_api": null,
          "new_api": "TriviaPiece::garbageText(Text)",
          "old_text": null,
          "new_text": "TriviaPiece::garbageText(Text)",
          "old_line_content": "    size_t Length = CurPtr - TriviaStart;",
          "new_line_content": "    Pieces.push_back(TriviaPiece::garbageText(Text));",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": null,
          "new_api": "advanceIf",
          "old_text": null,
          "new_text": "advanceIf(ptr, end, isValidIdentifierStartCodePoint)",
          "old_line_content": "static bool advanceIfValidStartOfIdentifier(char const *&ptr,",
          "new_line_content": "  return advanceIf(ptr, end, isValidIdentifierStartCodePoint);",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": null,
          "new_api": "advanceIf",
          "old_text": null,
          "new_text": "advanceIf(ptr, end, isValidIdentifierContinuationCodePoint)",
          "old_line_content": "static bool advanceIfValidContinuationOfIdentifier(char const *&ptr,",
          "new_line_content": "  return advanceIf(ptr, end, isValidIdentifierContinuationCodePoint);",
          "content_same": false
        },
        {
          "line": 2665,
          "old_api": null,
          "new_api": "getLength",
          "old_text": null,
          "new_text": "getTokenAtLocation(SM, Loc).getLength()",
          "old_line_content": "",
          "new_line_content": "  return Loc.getAdvancedLocOrInvalid(getTokenAtLocation(SM, Loc).getLength());",
          "content_same": false
        },
        {
          "line": 621,
          "old_api": null,
          "new_api": "advanceIf",
          "old_text": null,
          "new_text": "advanceIf(ptr, end, Identifier::isOperatorStartCodePoint)",
          "old_line_content": "static bool advanceIfValidStartOfOperator(char const *&ptr,",
          "new_line_content": "  return advanceIf(ptr, end, Identifier::isOperatorStartCodePoint);",
          "content_same": false
        },
        {
          "line": 626,
          "old_api": null,
          "new_api": "advanceIf",
          "old_text": null,
          "new_text": "advanceIf(ptr, end, Identifier::isOperatorContinuationCodePoint)",
          "old_line_content": "static bool advanceIfValidContinuationOfOperator(char const *&ptr,",
          "new_line_content": "  return advanceIf(ptr, end, Identifier::isOperatorContinuationCodePoint);",
          "content_same": false
        },
        {
          "line": 630,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "string.empty()",
          "old_line_content": "",
          "new_line_content": "  if (string.empty()) return false;",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "string.end()",
          "old_line_content": "bool Lexer::isIdentifier(StringRef string) {",
          "new_line_content": "  char const *p = string.data(), *end = string.end();",
          "content_same": false
        },
        {
          "line": 2685,
          "old_api": null,
          "new_api": "lex",
          "old_text": null,
          "new_text": "L.lex(Tok)",
          "old_line_content": "  Token Tok;",
          "new_line_content": "    L.lex(Tok);",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "string.empty()",
          "old_line_content": "/// without escaping characters.",
          "new_line_content": "  if (string.empty()) return false;",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "string.end()",
          "old_line_content": "bool Lexer::isOperator(StringRef string) {",
          "new_line_content": "  char const *p = string.data(), *end = string.end();",
          "content_same": false
        },
        {
          "line": 2694,
          "old_api": null,
          "new_api": "getLength",
          "old_text": null,
          "new_text": "Tok.getLength()",
          "old_line_content": "    }",
          "new_line_content": "    if (Offset < TokOffs+Tok.getLength()) {",
          "content_same": false
        },
        {
          "line": 2697,
          "old_api": null,
          "new_api": "is",
          "old_text": null,
          "new_text": "Tok.is(tok::string_literal)",
          "old_line_content": "      // Current token encompasses our source location.",
          "new_line_content": "      if (Tok.is(tok::string_literal)) {",
          "content_same": false
        },
        {
          "line": 2708,
          "old_api": null,
          "new_api": "getLocForStartOfTokenInBuf",
          "old_text": null,
          "new_text": "getLocForStartOfTokenInBuf(SM, BufferID, Offset,\n                                              /*BufferStart=*/SegOffs,\n                                              /*BufferEnd=*/SegEnd)",
          "old_line_content": "          // If the offset is inside an interpolated expr segment, re-lex.",
          "new_line_content": "            return getLocForStartOfTokenInBuf(SM, BufferID, Offset,",
          "content_same": false
        },
        {
          "line": 2714,
          "old_api": null,
          "new_api": "getLoc",
          "old_text": null,
          "new_text": "Tok.getLoc()",
          "old_line_content": "      }",
          "new_line_content": "      return Tok.getLoc();",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": null,
          "new_api": "advanceIfValidStartOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidStartOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "  const char *TokStart = CurPtr-1;",
          "new_line_content": "  bool didStart = advanceIfValidStartOfIdentifier(CurPtr, BufferEnd);",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(didStart && \"Unexpected start\")",
          "old_line_content": "  CurPtr = TokStart;",
          "new_line_content": "  assert(didStart && \"Unexpected start\");",
          "content_same": false
        },
        {
          "line": 2719,
          "old_api": null,
          "new_api": "getLocForOffset",
          "old_text": null,
          "new_text": "SM.getLocForOffset(BufferID, Offset)",
          "old_line_content": "",
          "new_line_content": "  return SM.getLocForOffset(BufferID, Offset);",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "",
          "new_line_content": "  while (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd));",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(Kind, TokStart)",
          "old_line_content": "",
          "new_line_content": "  return formToken(Kind, TokStart);",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": null,
          "new_api": "clang::isIdentifierHead(*tmpPtr)",
          "old_text": null,
          "new_text": "clang::isIdentifierHead(*tmpPtr)",
          "old_line_content": "  // Scan for [a-zA-Z]+ to see what we match.",
          "new_line_content": "  if (clang::isIdentifierHead(*tmpPtr)) {",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": null,
          "new_api": "clang::isIdentifierBody(*tmpPtr)",
          "old_text": null,
          "new_text": "clang::isIdentifierBody(*tmpPtr)",
          "old_line_content": "    do {",
          "new_line_content": "    } while (clang::isIdentifierBody(*tmpPtr));",
          "content_same": false
        },
        {
          "line": 2737,
          "old_api": null,
          "new_api": "isValid",
          "old_text": null,
          "new_text": "Loc.isValid()",
          "old_line_content": "",
          "new_line_content": "  if (!Loc.isValid())",
          "content_same": false
        },
        {
          "line": 2738,
          "old_api": null,
          "new_api": "SourceLoc",
          "old_text": null,
          "new_text": "SourceLoc()",
          "old_line_content": "SourceLoc Lexer::getLocForStartOfToken(SourceManager &SM, SourceLoc Loc) {",
          "new_line_content": "    return SourceLoc();",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": null,
          "new_api": "StringRef",
          "old_text": null,
          "new_text": "StringRef(CurPtr, tmpPtr-CurPtr)",
          "old_line_content": "",
          "new_line_content": "  tok Kind = llvm::StringSwitch<tok>(StringRef(CurPtr, tmpPtr-CurPtr))",
          "content_same": false
        },
        {
          "line": 695,
          "old_api": null,
          "new_api": "Default",
          "old_text": null,
          "new_text": "  .Default(tok::pound)",
          "old_line_content": "  .Case(#id, tok::pound_##id)",
          "new_line_content": "  .Default(tok::pound);",
          "content_same": false
        },
        {
          "line": 2746,
          "old_api": null,
          "new_api": "getRangeForBuffer",
          "old_text": null,
          "new_text": "SM.getRangeForBuffer(BufferID)",
          "old_line_content": "SourceLoc Lexer::getLocForStartOfToken(SourceManager &SM, unsigned BufferID,",
          "new_line_content": "  CharSourceRange entireRange = SM.getRangeForBuffer(BufferID);",
          "content_same": false
        },
        {
          "line": 2747,
          "old_api": null,
          "new_api": "extractText",
          "old_text": null,
          "new_text": "SM.extractText(entireRange)",
          "old_line_content": "                                       unsigned Offset) {",
          "new_line_content": "  StringRef Buffer = SM.extractText(entireRange);",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::pound, TokStart)",
          "old_line_content": "  // SIL parsing.",
          "new_line_content": "    return formToken(tok::pound, TokStart);",
          "content_same": false
        },
        {
          "line": 2750,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "Buffer.size()",
          "old_line_content": "",
          "new_line_content": "  if (Offset > Buffer.size())",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(Kind, TokStart)",
          "old_line_content": "  // If we found something specific, return it.",
          "new_line_content": "  return formToken(Kind, TokStart);",
          "content_same": false
        },
        {
          "line": 2757,
          "old_api": null,
          "new_api": "getLocForOffset",
          "old_text": null,
          "new_text": "SM.getLocForOffset(BufferID, Offset)",
          "old_line_content": "  if (StrData[0] == '\\n' || StrData[0] == '\\r' ||",
          "new_line_content": "    return SM.getLocForOffset(BufferID, Offset);",
          "content_same": false
        },
        {
          "line": 2761,
          "old_api": null,
          "new_api": "findStartOfLine",
          "old_text": null,
          "new_text": "findStartOfLine(BufStart, StrData)",
          "old_line_content": "  // Back up from the current location until we hit the beginning of a line",
          "new_line_content": "  const char *LexStart = findStartOfLine(BufStart, StrData);",
          "content_same": false
        },
        {
          "line": 2770,
          "old_api": null,
          "new_api": "isInvalid",
          "old_text": null,
          "new_text": "Loc.isInvalid()",
          "old_line_content": "SourceLoc Lexer::getLocForStartOfLine(SourceManager &SM, SourceLoc Loc) {",
          "new_line_content": "  if (Loc.isInvalid())",
          "content_same": false
        },
        {
          "line": 2774,
          "old_api": null,
          "new_api": "findBufferContainingLoc",
          "old_text": null,
          "new_text": "SM.findBufferContainingLoc(Loc)",
          "old_line_content": "",
          "new_line_content": "  int BufferID = SM.findBufferContainingLoc(Loc);",
          "content_same": false
        },
        {
          "line": 2779,
          "old_api": null,
          "new_api": "extractText",
          "old_text": null,
          "new_text": "SM.extractText(entireRange)",
          "old_line_content": "",
          "new_line_content": "  StringRef Buffer = SM.extractText(entireRange);",
          "content_same": false
        },
        {
          "line": 2782,
          "old_api": null,
          "new_api": "getLocOffsetInBuffer",
          "old_text": null,
          "new_text": "SM.getLocOffsetInBuffer(Loc, BufferID)",
          "old_line_content": "",
          "new_line_content": "  unsigned Offset = SM.getLocOffsetInBuffer(Loc, BufferID);",
          "content_same": false
        },
        {
          "line": 2785,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(StartOfLine)",
          "old_line_content": "",
          "new_line_content": "  return getSourceLoc(StartOfLine);",
          "content_same": false
        },
        {
          "line": 2790,
          "old_api": null,
          "new_api": "isInvalid",
          "old_text": null,
          "new_text": "Loc.isInvalid()",
          "old_line_content": "SourceLoc Lexer::getLocForEndOfLine(SourceManager &SM, SourceLoc Loc) {",
          "new_line_content": "  if (Loc.isInvalid())",
          "content_same": false
        },
        {
          "line": 2794,
          "old_api": null,
          "new_api": "findBufferContainingLoc",
          "old_text": null,
          "new_text": "SM.findBufferContainingLoc(Loc)",
          "old_line_content": "",
          "new_line_content": "  int BufferID = SM.findBufferContainingLoc(Loc);",
          "content_same": false
        },
        {
          "line": 2808,
          "old_api": null,
          "new_api": "State",
          "old_text": null,
          "new_text": "State(Loc)",
          "old_line_content": "  Lexer L(FakeLangOpts, SM, BufferID, nullptr, /*InSILMode=*/ false,",
          "new_line_content": "  L.restoreState(State(Loc));",
          "content_same": false
        },
        {
          "line": 2809,
          "old_api": null,
          "new_api": "skipToEndOfLine",
          "old_text": null,
          "new_text": "L.skipToEndOfLine(/*EatNewline=*/true)",
          "old_line_content": "          HashbangMode::Allowed, CommentRetentionMode::ReturnAsTokens);",
          "new_line_content": "  L.skipToEndOfLine(/*EatNewline=*/true);",
          "content_same": false
        },
        {
          "line": 2825,
          "old_api": null,
          "new_api": "isInvalid",
          "old_text": null,
          "new_text": "Loc.isInvalid()",
          "old_line_content": "",
          "new_line_content": "  if (Loc.isInvalid())",
          "content_same": false
        },
        {
          "line": 2829,
          "old_api": null,
          "new_api": "findBufferContainingLoc",
          "old_text": null,
          "new_text": "SM.findBufferContainingLoc(Loc)",
          "old_line_content": "",
          "new_line_content": "  int BufferID = SM.findBufferContainingLoc(Loc);",
          "content_same": false
        },
        {
          "line": 2833,
          "old_api": null,
          "new_api": "getRangeForBuffer",
          "old_text": null,
          "new_text": "SM.getRangeForBuffer(BufferID)",
          "old_line_content": "    return \"\";",
          "new_line_content": "  CharSourceRange entireRange = SM.getRangeForBuffer(BufferID);",
          "content_same": false
        },
        {
          "line": 2834,
          "old_api": null,
          "new_api": "extractText",
          "old_text": null,
          "new_text": "SM.extractText(entireRange)",
          "old_line_content": "",
          "new_line_content": "  StringRef Buffer = SM.extractText(entireRange);",
          "content_same": false
        },
        {
          "line": 2837,
          "old_api": null,
          "new_api": "getLocOffsetInBuffer",
          "old_text": null,
          "new_text": "SM.getLocOffsetInBuffer(Loc, BufferID)",
          "old_line_content": "",
          "new_line_content": "  unsigned Offset = SM.getLocOffsetInBuffer(Loc, BufferID);",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": null,
          "new_api": "advanceIfValidStartOfOperator",
          "old_text": null,
          "new_text": "advanceIfValidStartOfOperator(CurPtr, BufferEnd)",
          "old_line_content": "  const char *TokStart = CurPtr-1;",
          "new_line_content": "  bool didStart = advanceIfValidStartOfOperator(CurPtr, BufferEnd);",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(didStart && \"unexpected operator start\")",
          "old_line_content": "  CurPtr = TokStart;",
          "new_line_content": "  assert(didStart && \"unexpected operator start\");",
          "content_same": false
        },
        {
          "line": 2844,
          "old_api": null,
          "new_api": "StringRef",
          "old_text": null,
          "new_text": "StringRef(StartOfLine, EndOfIndentation - StartOfLine)",
          "old_line_content": "    ++EndOfIndentation;",
          "new_line_content": "  return StringRef(StartOfLine, EndOfIndentation - StartOfLine);",
          "content_same": false
        },
        {
          "line": 2850,
          "old_api": null,
          "new_api": "isValid",
          "old_text": null,
          "new_text": "EndLoc.isValid()",
          "old_line_content": "slice_token_array(ArrayRef<Token> AllTokens, SourceLoc StartLoc,",
          "new_line_content": "  assert(StartLoc.isValid() && EndLoc.isValid());",
          "content_same": false
        },
        {
          "line": 2851,
          "old_api": null,
          "new_api": "token_lower_bound",
          "old_text": null,
          "new_text": "token_lower_bound(AllTokens, StartLoc)",
          "old_line_content": "                  SourceLoc EndLoc) {",
          "new_line_content": "  auto StartIt = token_lower_bound(AllTokens, StartLoc);",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": null,
          "new_api": "StringRef",
          "old_text": null,
          "new_text": "StringRef(CurPtr, BufferEnd-CurPtr)",
          "old_line_content": "    if (*CurPtr == '.' && *TokStart != '.')",
          "new_line_content": "    if (Identifier::isEditorPlaceholder(StringRef(CurPtr, BufferEnd-CurPtr)) &&",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": null,
          "new_api": "rangeContainsPlaceholderEnd",
          "old_text": null,
          "new_text": "rangeContainsPlaceholderEnd(CurPtr + 2, BufferEnd)",
          "old_line_content": "      break;",
          "new_line_content": "        rangeContainsPlaceholderEnd(CurPtr + 2, BufferEnd)) {",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfOperator",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfOperator(CurPtr, BufferEnd)",
          "old_line_content": "      break;",
          "new_line_content": "  } while (advanceIfValidContinuationOfOperator(CurPtr, BufferEnd));",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": null,
          "new_api": "isLeftBound",
          "old_text": null,
          "new_text": "isLeftBound(TokStart, ContentStart)",
          "old_line_content": "  // It's binary if either both sides are bound or both sides are not bound.",
          "new_line_content": "  bool leftBound = isLeftBound(TokStart, ContentStart);",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": null,
          "new_api": "isRightBound",
          "old_text": null,
          "new_text": "isRightBound(CurPtr, leftBound, CodeCompletionPtr)",
          "old_line_content": "  // Otherwise, it's postfix if left-bound and prefix if right-bound.",
          "new_line_content": "  bool rightBound = isRightBound(CurPtr, leftBound, CodeCompletionPtr);",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(TokStart, diag::lex_unary_equal)",
          "old_line_content": "    case '=':",
          "new_line_content": "        auto d = diagnose(TokStart, diag::lex_unary_equal);",
          "content_same": false
        },
        {
          "line": 845,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::equal, TokStart)",
          "old_line_content": "      }",
          "new_line_content": "      return formToken(tok::equal, TokStart);",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::amp_prefix, TokStart)",
          "old_line_content": "      if (leftBound == rightBound || leftBound)",
          "new_line_content": "      return formToken(tok::amp_prefix, TokStart);",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::period, TokStart)",
          "old_line_content": "    case '.': {",
          "new_line_content": "        return formToken(tok::period, TokStart);",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(TokStart, diag::expected_member_name)",
          "old_line_content": "      if (*AfterHorzWhitespace == '\\0' &&",
          "new_line_content": "        diagnose(TokStart, diag::expected_member_name);",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::period, TokStart)",
          "old_line_content": "          AfterHorzWhitespace == CodeCompletionPtr) {",
          "new_line_content": "        return formToken(tok::period, TokStart);",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": null,
          "new_api": "isRightBound",
          "old_text": null,
          "new_text": "isRightBound(AfterHorzWhitespace, leftBound, CodeCompletionPtr)",
          "old_line_content": "      }",
          "new_line_content": "      if (isRightBound(AfterHorzWhitespace, leftBound, CodeCompletionPtr) &&",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": null,
          "new_api": "fixItRemoveChars",
          "old_text": null,
          "new_text": "diagnose(TokStart, diag::extra_whitespace_period)\n          .fixItRemoveChars(getSourceLoc(CurPtr),\n                            getSourceLoc(AfterHorzWhitespace))",
          "old_line_content": "          // expected-error lines.",
          "new_line_content": "        diagnose(TokStart, diag::extra_whitespace_period)",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(CurPtr)",
          "old_line_content": "          *AfterHorzWhitespace != '/') {",
          "new_line_content": "          .fixItRemoveChars(getSourceLoc(CurPtr),",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(TokStart, diag::expected_member_name)",
          "old_line_content": "",
          "new_line_content": "      diagnose(TokStart, diag::expected_member_name);",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "      // Otherwise, it is probably a missing member.",
          "new_line_content": "      return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::question_postfix, TokStart)",
          "old_line_content": "    case '?':",
          "new_line_content": "        return formToken(tok::question_postfix, TokStart);",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::question_infix, TokStart)",
          "old_line_content": "      if (leftBound)",
          "new_line_content": "      return formToken(tok::question_infix, TokStart);",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::arrow, TokStart)",
          "old_line_content": "    switch ((TokStart[0] << 8) | TokStart[1]) {",
          "new_line_content": "      return formToken(tok::arrow, TokStart);",
          "content_same": false
        },
        {
          "line": 898,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "    case ('*' << 8) | '/': // */",
          "new_line_content": "      return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 903,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "StringRef(TokStart, CurPtr-TokStart).find(\"*/\")",
          "old_line_content": "    // Verify there is no \"*/\" in the middle of the identifier token, we reject",
          "new_line_content": "    auto Pos = StringRef(TokStart, CurPtr-TokStart).find(\"*/\");",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "    if (Pos != StringRef::npos) {",
          "new_line_content": "      return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(leftBound ? tok::oper_binary_unspaced :\n                                 tok::oper_binary_spaced, TokStart)",
          "old_line_content": "",
          "new_line_content": "    return formToken(leftBound ? tok::oper_binary_unspaced :",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(leftBound ? tok::oper_postfix : tok::oper_prefix, TokStart)",
          "old_line_content": "                                 tok::oper_binary_spaced, TokStart);",
          "new_line_content": "  return formToken(leftBound ? tok::oper_postfix : tok::oper_prefix, TokStart);",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(*tokStart == '$')",
          "old_line_content": "void Lexer::lexDollarIdent() {",
          "new_line_content": "  assert(*tokStart == '$');",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": null,
          "new_api": "getKind",
          "old_text": null,
          "new_text": "NextToken.getKind()",
          "old_line_content": "  // In a SIL function body, '$' is a token by itself, except it's a SIL global",
          "new_line_content": "  if (InSILBody && NextToken.getKind() != tok::at_sign)",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::sil_dollar, tokStart)",
          "old_line_content": "  // name. SIL global identifiers may start with a '$', e.g. @$S1m3fooyyF.",
          "new_line_content": "    return formToken(tok::sil_dollar, tokStart);",
          "content_same": false
        },
        {
          "line": 929,
          "old_api": null,
          "new_api": "isDigit",
          "old_text": null,
          "new_text": "isDigit(*CurPtr)",
          "old_line_content": "  bool isAllDigits = true;",
          "new_line_content": "    if (isDigit(*CurPtr)) {",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": null,
          "new_api": "fixItReplaceChars",
          "old_text": null,
          "new_text": "diagnose(tokStart, diag::standalone_dollar_identifier)\n      .fixItReplaceChars(getSourceLoc(tokStart), getSourceLoc(CurPtr), \"`$`\")",
          "old_line_content": "  if (CurPtr == tokStart + 1) {",
          "new_line_content": "    diagnose(tokStart, diag::standalone_dollar_identifier)",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(CurPtr)",
          "old_line_content": "    // It is an error to see a standalone '$'. Offer to replace '$' with '`$`'.",
          "new_line_content": "      .fixItReplaceChars(getSourceLoc(tokStart), getSourceLoc(CurPtr), \"`$`\");",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(tokStart, diag::expected_dollar_numeric)",
          "old_line_content": "  if (!isAllDigits) {",
          "new_line_content": "      diagnose(tokStart, diag::expected_dollar_numeric);",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::identifier, tokStart)",
          "old_line_content": "    // in part to ensure that the basic behavior of the lexer is",
          "new_line_content": "    return formToken(tok::identifier, tokStart);",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::identifier, tokStart)",
          "old_line_content": "  } else {",
          "new_line_content": "      return formToken(tok::identifier, tokStart);",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::dollarident, tokStart)",
          "old_line_content": "    if (LangOpts.EnableDollarIdentifiers && !LangOpts.Playground)",
          "new_line_content": "    return formToken(tok::dollarident, tokStart);",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(*CurPtr == 'x' && \"not a hex literal\")",
          "old_line_content": "void Lexer::lexHexNumber() {",
          "new_line_content": "  assert(*CurPtr == 'x' && \"not a hex literal\");",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "",
          "new_line_content": "    while (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd));",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "  auto expected_digit = [&]() {",
          "new_line_content": "    return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 976,
          "old_api": null,
          "new_api": "StringRef",
          "old_text": null,
          "new_text": "StringRef(loc, 1)",
          "old_line_content": "",
          "new_line_content": "    diagnose(loc, diag::lex_invalid_digit_in_int_literal, StringRef(loc, 1),",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": null,
          "new_api": "isHexDigit",
          "old_text": null,
          "new_text": "isHexDigit(*CurPtr)",
          "old_line_content": "  // 0x[0-9a-fA-F][0-9a-fA-F_]*",
          "new_line_content": "  if (!isHexDigit(*CurPtr))",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": null,
          "new_api": "expected_hex_digit",
          "old_text": null,
          "new_text": "expected_hex_digit(CurPtr)",
          "old_line_content": "  ++CurPtr;",
          "new_line_content": "    return expected_hex_digit(CurPtr);",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "  if (*CurPtr != '.' && *CurPtr != 'p' && *CurPtr != 'P') {",
          "new_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": null,
          "new_api": "expected_hex_digit",
          "old_text": null,
          "new_text": "expected_hex_digit(tmp)",
          "old_line_content": "    auto tmp = CurPtr;",
          "new_line_content": "      return expected_hex_digit(tmp);",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": null,
          "new_api": "isHexDigit",
          "old_text": null,
          "new_text": "isHexDigit(*CurPtr)",
          "old_line_content": "    // If the character after the '.' is not a digit, assume we have an int",
          "new_line_content": "    if (!isHexDigit(*CurPtr)) {",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": null,
          "new_api": "isHexDigit",
          "old_text": null,
          "new_text": "isHexDigit(*CurPtr)",
          "old_line_content": "    }",
          "new_line_content": "    while (isHexDigit(*CurPtr) || *CurPtr == '_')",
          "content_same": false
        },
        {
          "line": 1015,
          "old_api": null,
          "new_api": "isDigit",
          "old_text": null,
          "new_text": "isDigit(PtrOnDot[1])",
          "old_line_content": "",
          "new_line_content": "      if (!isDigit(PtrOnDot[1])) {",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::integer_literal, TokStart)",
          "old_line_content": "        // e.g: 0xff.description",
          "new_line_content": "        return formToken(tok::integer_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 1021,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "      }",
          "new_line_content": "      return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(*CurPtr == 'p' || *CurPtr == 'P' && \"not at a hex float exponent?!\")",
          "old_line_content": "  ",
          "new_line_content": "  assert(*CurPtr == 'p' || *CurPtr == 'P' && \"not at a hex float exponent?!\");",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": null,
          "new_api": "isDigit",
          "old_text": null,
          "new_text": "isDigit(*CurPtr)",
          "old_line_content": "  }",
          "new_line_content": "  if (!isDigit(*CurPtr)) {",
          "content_same": false
        },
        {
          "line": 1036,
          "old_api": null,
          "new_api": "isDigit",
          "old_text": null,
          "new_text": "isDigit(PtrOnDot[1])",
          "old_line_content": "",
          "new_line_content": "    if (PtrOnDot && !isDigit(PtrOnDot[1]) && !signedExponent) {",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::integer_literal, TokStart)",
          "old_line_content": "      // e.g: 0xff.fpValue, 0xff.fp",
          "new_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 1047,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "    // non-identifier (empty exponent)",
          "new_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "content_same": false
        },
        {
          "line": 1048,
          "old_api": null,
          "new_api": "StringRef",
          "old_text": null,
          "new_text": "StringRef(tmp, 1)",
          "old_line_content": "    auto tmp = CurPtr;",
          "new_line_content": "      diagnose(tmp, diag::lex_invalid_digit_in_fp_exponent, StringRef(tmp, 1),",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CurPtr, diag::lex_expected_digit_in_fp_exponent)",
          "old_line_content": "               *tmp == '_');",
          "new_line_content": "      diagnose(CurPtr, diag::lex_expected_digit_in_fp_exponent);",
          "content_same": false
        },
        {
          "line": 1056,
          "old_api": null,
          "new_api": "isDigit",
          "old_text": null,
          "new_text": "isDigit(*CurPtr)",
          "old_line_content": "  }",
          "new_line_content": "  while (isDigit(*CurPtr) || *CurPtr == '_')",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "",
          "new_line_content": "  if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)) {",
          "content_same": false
        },
        {
          "line": 1061,
          "old_api": null,
          "new_api": "StringRef",
          "old_text": null,
          "new_text": "StringRef(tmp, 1)",
          "old_line_content": "  auto tmp = CurPtr;",
          "new_line_content": "    diagnose(tmp, diag::lex_invalid_digit_in_fp_exponent, StringRef(tmp, 1),",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::floating_literal, TokStart)",
          "old_line_content": "  }",
          "new_line_content": "  return formToken(tok::floating_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": null,
          "new_api": "isDigit",
          "old_text": null,
          "new_text": "isDigit(*TokStart)",
          "old_line_content": "void Lexer::lexNumber() {",
          "new_line_content": "  assert((isDigit(*TokStart) || *TokStart == '.') && \"Unexpected start\");",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "",
          "new_line_content": "    while (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd));",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "  auto expected_digit = [&]() {",
          "new_line_content": "    return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 1089,
          "old_api": null,
          "new_api": "StringRef",
          "old_text": null,
          "new_text": "StringRef(loc, 1)",
          "old_line_content": "",
          "new_line_content": "    diagnose(loc, diag::lex_invalid_digit_in_int_literal, StringRef(loc, 1),",
          "content_same": false
        },
        {
          "line": 1095,
          "old_api": null,
          "new_api": "lexHexNumber",
          "old_text": null,
          "new_text": "lexHexNumber()",
          "old_line_content": "",
          "new_line_content": "    return lexHexNumber();",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": null,
          "new_api": "expected_int_digit",
          "old_text": null,
          "new_text": "expected_int_digit(CurPtr, ExpectedDigitKind::Octal)",
          "old_line_content": "    ++CurPtr;",
          "new_line_content": "      return expected_int_digit(CurPtr, ExpectedDigitKind::Octal);",
          "content_same": false
        },
        {
          "line": 1107,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "",
          "new_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "content_same": false
        },
        {
          "line": 1108,
          "old_api": null,
          "new_api": "expected_int_digit",
          "old_text": null,
          "new_text": "expected_int_digit(tmp, ExpectedDigitKind::Octal)",
          "old_line_content": "    auto tmp = CurPtr;",
          "new_line_content": "      return expected_int_digit(tmp, ExpectedDigitKind::Octal);",
          "content_same": false
        },
        {
          "line": 1117,
          "old_api": null,
          "new_api": "expected_int_digit",
          "old_text": null,
          "new_text": "expected_int_digit(CurPtr, ExpectedDigitKind::Binary)",
          "old_line_content": "    ++CurPtr;",
          "new_line_content": "      return expected_int_digit(CurPtr, ExpectedDigitKind::Binary);",
          "content_same": false
        },
        {
          "line": 1123,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "",
          "new_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "content_same": false
        },
        {
          "line": 1124,
          "old_api": null,
          "new_api": "expected_int_digit",
          "old_text": null,
          "new_text": "expected_int_digit(tmp, ExpectedDigitKind::Binary)",
          "old_line_content": "    auto tmp = CurPtr;",
          "new_line_content": "      return expected_int_digit(tmp, ExpectedDigitKind::Binary);",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": null,
          "new_api": "isDigit",
          "old_text": null,
          "new_text": "isDigit(*CurPtr)",
          "old_line_content": "  // Handle a leading [0-9]+, lexing an integer or falling through if we have a",
          "new_line_content": "  while (isDigit(*CurPtr) || *CurPtr == '_')",
          "content_same": false
        },
        {
          "line": 1138,
          "old_api": null,
          "new_api": "is",
          "old_text": null,
          "new_text": "NextToken.is(tok::period)",
          "old_line_content": "    // NextToken is the soon to be previous token",
          "new_line_content": "    if (!isDigit(CurPtr[1]) || NextToken.is(tok::period))",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::integer_literal, TokStart)",
          "old_line_content": "    // Therefore: x.0.1 is sub-tuple access, not x.float_literal",
          "new_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "    if (*CurPtr != 'e' && *CurPtr != 'E') {",
          "new_line_content": "      if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "content_same": false
        },
        {
          "line": 1146,
          "old_api": null,
          "new_api": "expected_int_digit",
          "old_text": null,
          "new_text": "expected_int_digit(tmp, ExpectedDigitKind::Decimal)",
          "old_line_content": "      auto tmp = CurPtr;",
          "new_line_content": "        return expected_int_digit(tmp, ExpectedDigitKind::Decimal);",
          "content_same": false
        },
        {
          "line": 1157,
          "old_api": null,
          "new_api": "isDigit",
          "old_text": null,
          "new_text": "isDigit(*CurPtr)",
          "old_line_content": "   ",
          "new_line_content": "    while (isDigit(*CurPtr) || *CurPtr == '_')",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": null,
          "new_api": "isDigit",
          "old_text": null,
          "new_text": "isDigit(*CurPtr)",
          "old_line_content": "      ++CurPtr;  // Eat the sign.",
          "new_line_content": "    if (!isDigit(*CurPtr)) {",
          "content_same": false
        },
        {
          "line": 1172,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "      // non-identifier (empty exponent)",
          "new_line_content": "      if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": null,
          "new_api": "StringRef",
          "old_text": null,
          "new_text": "StringRef(tmp, 1)",
          "old_line_content": "      auto tmp = CurPtr;",
          "new_line_content": "        diagnose(tmp, diag::lex_invalid_digit_in_fp_exponent, StringRef(tmp, 1),",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CurPtr, diag::lex_expected_digit_in_fp_exponent)",
          "old_line_content": "                 *tmp == '_');",
          "new_line_content": "        diagnose(CurPtr, diag::lex_expected_digit_in_fp_exponent);",
          "content_same": false
        },
        {
          "line": 1181,
          "old_api": null,
          "new_api": "isDigit",
          "old_text": null,
          "new_text": "isDigit(*CurPtr)",
          "old_line_content": "    }",
          "new_line_content": "    while (isDigit(*CurPtr) || *CurPtr == '_')",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "",
          "new_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)) {",
          "content_same": false
        },
        {
          "line": 1186,
          "old_api": null,
          "new_api": "StringRef",
          "old_text": null,
          "new_text": "StringRef(tmp, 1)",
          "old_line_content": "    auto tmp = CurPtr;",
          "new_line_content": "      diagnose(tmp, diag::lex_invalid_digit_in_fp_exponent, StringRef(tmp, 1),",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::floating_literal, TokStart)",
          "old_line_content": "  }",
          "new_line_content": "  return formToken(tok::floating_literal, TokStart);",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(CurPtr[0] == '{' && \"Invalid unicode escape\")",
          "old_line_content": "///   hex                      ::= [0-9a-fA-F]",
          "new_line_content": "  assert(CurPtr[0] == '{' && \"Invalid unicode escape\");",
          "content_same": false
        },
        {
          "line": 1204,
          "old_api": null,
          "new_api": "isHexDigit",
          "old_text": null,
          "new_text": "isHexDigit(CurPtr[0])",
          "old_line_content": "",
          "new_line_content": "  for (; isHexDigit(CurPtr[0]); ++NumDigits)",
          "content_same": false
        },
        {
          "line": 1209,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "Diags->diagnose(CurPtr, diag::lex_invalid_u_escape_rbrace)",
          "old_line_content": "  if (CurPtr[0] != '}') {",
          "new_line_content": "      Diags->diagnose(CurPtr, diag::lex_invalid_u_escape_rbrace);",
          "content_same": false
        },
        {
          "line": 1216,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "Diags->diagnose(CurPtr, diag::lex_invalid_u_escape)",
          "old_line_content": "  if (NumDigits < 1 || NumDigits > 8) {",
          "new_line_content": "      Diags->diagnose(CurPtr, diag::lex_invalid_u_escape);",
          "content_same": false
        },
        {
          "line": 1221,
          "old_api": null,
          "new_api": "getAsInteger",
          "old_text": null,
          "new_text": "StringRef(DigitStart, NumDigits).getAsInteger(16, CharValue)",
          "old_line_content": "",
          "new_line_content": "  StringRef(DigitStart, NumDigits).getAsInteger(16, CharValue);",
          "content_same": false
        },
        {
          "line": 1262,
          "old_api": null,
          "new_api": "diagnoseZeroWidthMatchAndAdvance",
          "old_text": null,
          "new_text": "diagnoseZeroWidthMatchAndAdvance('\"', TmpPtr, Diags)",
          "old_line_content": "  const char *TmpPtr = CurPtr;",
          "new_line_content": "      diagnoseZeroWidthMatchAndAdvance('\"', TmpPtr, Diags) &&",
          "content_same": false
        },
        {
          "line": 1263,
          "old_api": null,
          "new_api": "diagnoseZeroWidthMatchAndAdvance",
          "old_text": null,
          "new_text": "diagnoseZeroWidthMatchAndAdvance('\"', TmpPtr, Diags)",
          "old_line_content": "  if (*(TmpPtr - 1) == '\"' &&",
          "new_line_content": "      diagnoseZeroWidthMatchAndAdvance('\"', TmpPtr, Diags)) {",
          "content_same": false
        },
        {
          "line": 1275,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(CurPtr[-1] == '#')",
          "old_line_content": "static unsigned advanceIfCustomDelimiter(const char *&CurPtr,",
          "new_line_content": "  assert(CurPtr[-1] == '#');",
          "content_same": false
        },
        {
          "line": 1279,
          "old_api": null,
          "new_api": "diagnoseZeroWidthMatchAndAdvance",
          "old_text": null,
          "new_text": "diagnoseZeroWidthMatchAndAdvance('#', TmpPtr, Diags)",
          "old_line_content": "  const char *TmpPtr = CurPtr;",
          "new_line_content": "  while (diagnoseZeroWidthMatchAndAdvance('#', TmpPtr, Diags))",
          "content_same": false
        },
        {
          "line": 1299,
          "old_api": null,
          "new_api": "diagnoseZeroWidthMatchAndAdvance",
          "old_text": null,
          "new_text": "diagnoseZeroWidthMatchAndAdvance('#', TmpPtr, Diags)",
          "old_line_content": "    return true;",
          "new_line_content": "  while (diagnoseZeroWidthMatchAndAdvance('#', TmpPtr, Diags)) {}",
          "content_same": false
        },
        {
          "line": 1309,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(BytesPtr)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(BytesPtr)",
          "old_line_content": "    Diag<> message = IsClosing ? diag::lex_invalid_closing_delimiter",
          "new_line_content": "    Diags->diagnose(Lexer::getSourceLoc(BytesPtr), message)",
          "content_same": false
        },
        {
          "line": 1310,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(BytesPtr)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(BytesPtr)",
          "old_line_content": "                               : diag::lex_invalid_escape_delimiter;",
          "new_line_content": "        .fixItRemoveChars(Lexer::getSourceLoc(BytesPtr),",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": null,
          "new_api": "isPrintable",
          "old_text": null,
          "new_text": "isPrintable(CurPtr[-1])",
          "old_line_content": "    // If this is a \"high\" UTF-8 character, validate it.",
          "new_line_content": "      if (isPrintable(CurPtr[-1]) == 0)",
          "content_same": false
        },
        {
          "line": 1337,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CharStart, diag::lex_unprintable_ascii_character)",
          "old_line_content": "        if (!(IsMultilineString && (CurPtr[-1] == '\\t')))",
          "new_line_content": "            diagnose(CharStart, diag::lex_unprintable_ascii_character);",
          "content_same": false
        },
        {
          "line": 1341,
          "old_api": null,
          "new_api": "validateUTF8CharacterAndAdvance",
          "old_text": null,
          "new_text": "validateUTF8CharacterAndAdvance(CurPtr, BufferEnd)",
          "old_line_content": "    }",
          "new_line_content": "    unsigned CharValue = validateUTF8CharacterAndAdvance(CurPtr, BufferEnd);",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CharStart, diag::lex_invalid_utf8)",
          "old_line_content": "    if (CharValue != ~0U) return CharValue;",
          "new_line_content": "      diagnose(CharStart, diag::lex_invalid_utf8);",
          "content_same": false
        },
        {
          "line": 1351,
          "old_api": null,
          "new_api": "LLVM_UNLIKELY",
          "old_text": null,
          "new_text": "LLVM_UNLIKELY(StopQuote != '\"')",
          "old_line_content": "    if (CurPtr[-1] == StopQuote) {",
          "new_line_content": "      if (LLVM_UNLIKELY(StopQuote != '\"'))",
          "content_same": false
        },
        {
          "line": 1358,
          "old_api": null,
          "new_api": "advanceIfMultilineDelimiter",
          "old_text": null,
          "new_text": "advanceIfMultilineDelimiter(TmpPtr, D)",
          "old_line_content": "      DiagnosticEngine *D = EmitDiagnostics ? Diags : nullptr;",
          "new_line_content": "      if (IsMultilineString && !advanceIfMultilineDelimiter(TmpPtr, D))",
          "content_same": false
        },
        {
          "line": 1361,
          "old_api": null,
          "new_api": "delimiterMatches",
          "old_text": null,
          "new_text": "delimiterMatches(CustomDelimiterLen, TmpPtr, D, /*IsClosing=*/true)",
          "old_line_content": "        return '\"';",
          "new_line_content": "          !delimiterMatches(CustomDelimiterLen, TmpPtr, D, /*IsClosing=*/true))",
          "content_same": false
        },
        {
          "line": 1370,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(CurPtr - 1 != BufferEnd && \"Caller must handle EOF\")",
          "old_line_content": "",
          "new_line_content": "    assert(CurPtr - 1 != BufferEnd && \"Caller must handle EOF\");",
          "content_same": false
        },
        {
          "line": 1376,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(IsMultilineString && \"Caller must handle newlines in non-multiline\")",
          "old_line_content": "  case '\\n':  // String literals cannot have \\n or \\r in them.",
          "new_line_content": "    assert(IsMultilineString && \"Caller must handle newlines in non-multiline\");",
          "content_same": false
        },
        {
          "line": 1379,
          "old_api": null,
          "new_api": "delimiterMatches",
          "old_text": null,
          "new_text": "delimiterMatches(CustomDelimiterLen, CurPtr,\n                          EmitDiagnostics ? Diags : nullptr)",
          "old_line_content": "    return CurPtr[-1];",
          "new_line_content": "    if (!delimiterMatches(CustomDelimiterLen, CurPtr,",
          "content_same": false
        },
        {
          "line": 1389,
          "old_api": null,
          "new_api": "maybeConsumeNewlineEscape",
          "old_text": null,
          "new_text": "maybeConsumeNewlineEscape(CurPtr, 0)",
          "old_line_content": "  switch (*CurPtr) {",
          "new_line_content": "    if (IsMultilineString && maybeConsumeNewlineEscape(CurPtr, 0))",
          "content_same": false
        },
        {
          "line": 1394,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CurPtr, diag::lex_invalid_escape)",
          "old_line_content": "  default:  // Invalid escape.",
          "new_line_content": "      diagnose(CurPtr, diag::lex_invalid_escape);",
          "content_same": false
        },
        {
          "line": 1397,
          "old_api": null,
          "new_api": "isAlphanumeric",
          "old_text": null,
          "new_text": "isAlphanumeric(*CurPtr)",
          "old_line_content": "    // If this looks like a plausible escape character, recover as though this",
          "new_line_content": "    if (isAlphanumeric(*CurPtr)) ++CurPtr;",
          "content_same": false
        },
        {
          "line": 1413,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CurPtr-1, diag::lex_unicode_escape_braces)",
          "old_line_content": "    if (*CurPtr != '{') {",
          "new_line_content": "        diagnose(CurPtr-1, diag::lex_unicode_escape_braces);",
          "content_same": false
        },
        {
          "line": 1417,
          "old_api": null,
          "new_api": "lexUnicodeEscape",
          "old_text": null,
          "new_text": "lexUnicodeEscape(CurPtr, EmitDiagnostics ? this : nullptr)",
          "old_line_content": "    }",
          "new_line_content": "    CharValue = lexUnicodeEscape(CurPtr, EmitDiagnostics ? this : nullptr);",
          "content_same": false
        },
        {
          "line": 1425,
          "old_api": null,
          "new_api": "EncodeToUTF8",
          "old_text": null,
          "new_text": "EncodeToUTF8(CharValue, TempString)",
          "old_line_content": "  // Check to see if the encoding is valid.",
          "new_line_content": "  if (CharValue >= 0x80 && EncodeToUTF8(CharValue, TempString)) {",
          "content_same": false
        },
        {
          "line": 1450,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "AllowNewline.push_back(IsMultilineString)",
          "old_line_content": "  SmallVector<bool, 4> AllowNewline;",
          "new_line_content": "  AllowNewline.push_back(IsMultilineString);",
          "content_same": false
        },
        {
          "line": 1453,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "OpenDelimiters.empty()",
          "old_line_content": "",
          "new_line_content": "    return !OpenDelimiters.empty() &&",
          "content_same": false
        },
        {
          "line": 1454,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "OpenDelimiters.back()",
          "old_line_content": "  auto inStringLiteral = [&]() {",
          "new_line_content": "           (OpenDelimiters.back() == '\"' || OpenDelimiters.back() == '\\'');",
          "content_same": false
        },
        {
          "line": 1471,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "AllowNewline.back()",
          "old_line_content": "    case '\\n':",
          "new_line_content": "      if (AllowNewline.back())",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": null,
          "new_api": "inStringLiteral",
          "old_text": null,
          "new_text": "inStringLiteral()",
          "old_line_content": "",
          "new_line_content": "      if (inStringLiteral() ||",
          "content_same": false
        },
        {
          "line": 1483,
          "old_api": null,
          "new_api": "advanceIfCustomDelimiter",
          "old_text": null,
          "new_text": "advanceIfCustomDelimiter(CurPtr, nullptr)",
          "old_line_content": "    case '#':",
          "new_line_content": "          !(CustomDelimiterLen = advanceIfCustomDelimiter(CurPtr, nullptr)))",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": null,
          "new_api": "inStringLiteral",
          "old_text": null,
          "new_text": "inStringLiteral()",
          "old_line_content": "    case '\"':",
          "new_line_content": "      if (!inStringLiteral()) {",
          "content_same": false
        },
        {
          "line": 1494,
          "old_api": null,
          "new_api": "advanceIfMultilineDelimiter",
          "old_text": null,
          "new_text": "advanceIfMultilineDelimiter(CurPtr, nullptr)",
          "old_line_content": "        // Open string literal.",
          "new_line_content": "        AllowNewline.push_back(advanceIfMultilineDelimiter(CurPtr, nullptr));",
          "content_same": false
        },
        {
          "line": 1502,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "OpenDelimiters.back()",
          "old_line_content": "",
          "new_line_content": "      if (OpenDelimiters.back() != CurPtr[-1])",
          "content_same": false
        },
        {
          "line": 1506,
          "old_api": null,
          "new_api": "advanceIfMultilineDelimiter",
          "old_text": null,
          "new_text": "advanceIfMultilineDelimiter(CurPtr, nullptr)",
          "old_line_content": "",
          "new_line_content": "      if (AllowNewline.back() && !advanceIfMultilineDelimiter(CurPtr, nullptr))",
          "content_same": false
        },
        {
          "line": 1510,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "CustomDelimiter.back()",
          "old_line_content": "",
          "new_line_content": "      if (!delimiterMatches(CustomDelimiter.back(), CurPtr, nullptr, true))",
          "content_same": false
        },
        {
          "line": 1514,
          "old_api": null,
          "new_api": "pop_back",
          "old_text": null,
          "new_text": "OpenDelimiters.pop_back()",
          "old_line_content": "",
          "new_line_content": "      OpenDelimiters.pop_back();",
          "content_same": false
        },
        {
          "line": 1515,
          "old_api": null,
          "new_api": "pop_back",
          "old_text": null,
          "new_text": "AllowNewline.pop_back()",
          "old_line_content": "      // Close string literal.",
          "new_line_content": "      AllowNewline.pop_back();",
          "content_same": false
        },
        {
          "line": 1522,
          "old_api": null,
          "new_api": "inStringLiteral",
          "old_text": null,
          "new_text": "inStringLiteral()",
          "old_line_content": "      // We ignore invalid escape sequence here. They should be diagnosed in",
          "new_line_content": "      if (inStringLiteral() &&",
          "content_same": false
        },
        {
          "line": 1523,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "CustomDelimiter.back()",
          "old_line_content": "      // the real lexer functions.",
          "new_line_content": "          delimiterMatches(CustomDelimiter.back(), CurPtr, nullptr)) {",
          "content_same": false
        },
        {
          "line": 1527,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "OpenDelimiters.push_back('(')",
          "old_line_content": "        case '(':",
          "new_line_content": "          OpenDelimiters.push_back('(');",
          "content_same": false
        },
        {
          "line": 1542,
          "old_api": null,
          "new_api": "inStringLiteral",
          "old_text": null,
          "new_text": "inStringLiteral()",
          "old_line_content": "    // Paren nesting deeper to support \"foo = \\((a+b)-(c*d)) bar\".",
          "new_line_content": "      if (!inStringLiteral()) {",
          "content_same": false
        },
        {
          "line": 1543,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "OpenDelimiters.push_back('(')",
          "old_line_content": "    case '(':",
          "new_line_content": "        OpenDelimiters.push_back('(');",
          "content_same": false
        },
        {
          "line": 1547,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "OpenDelimiters.empty()",
          "old_line_content": "      continue;",
          "new_line_content": "      if (OpenDelimiters.empty()) {",
          "content_same": false
        },
        {
          "line": 1550,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "OpenDelimiters.back()",
          "old_line_content": "        // No outstanding open delimiters; we're done.",
          "new_line_content": "      } else if (OpenDelimiters.back() == '(') {",
          "content_same": false
        },
        {
          "line": 1556,
          "old_api": null,
          "new_api": "inStringLiteral",
          "old_text": null,
          "new_text": "inStringLiteral()",
          "old_line_content": "      } else {",
          "new_line_content": "        assert(inStringLiteral());",
          "content_same": false
        },
        {
          "line": 1560,
          "old_api": null,
          "new_api": "inStringLiteral",
          "old_text": null,
          "new_text": "inStringLiteral()",
          "old_line_content": "      }",
          "new_line_content": "      if (inStringLiteral())",
          "content_same": false
        },
        {
          "line": 1565,
          "old_api": null,
          "new_api": "skipToEndOfSlashStarComment",
          "old_text": null,
          "new_text": "skipToEndOfSlashStarComment(CurPtr, EndPtr)",
          "old_line_content": "      if (*CurPtr == '*') {",
          "new_line_content": "        bool isMultilineComment = skipToEndOfSlashStarComment(CurPtr, EndPtr);",
          "content_same": false
        },
        {
          "line": 1566,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "AllowNewline.back()",
          "old_line_content": "        auto CommentStart = CurPtr - 1;",
          "new_line_content": "        if (isMultilineComment && !AllowNewline.back()) {",
          "content_same": false
        },
        {
          "line": 1572,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "AllowNewline.back()",
          "old_line_content": "        }",
          "new_line_content": "        if (!AllowNewline.back()) {",
          "content_same": false
        },
        {
          "line": 1578,
          "old_api": null,
          "new_api": "advanceToEndOfLine",
          "old_text": null,
          "new_text": "advanceToEndOfLine(CurPtr, EndPtr)",
          "old_line_content": "        }",
          "new_line_content": "        if (/*isEOL=*/advanceToEndOfLine(CurPtr, EndPtr))",
          "content_same": false
        },
        {
          "line": 1592,
          "old_api": null,
          "new_api": "getText",
          "old_text": null,
          "new_text": "Str.getText()",
          "old_line_content": "/// Extract content of string literal from inside quotes.",
          "new_line_content": "  StringRef Bytes = Str.getText();",
          "content_same": false
        },
        {
          "line": 1595,
          "old_api": null,
          "new_api": "drop_front",
          "old_text": null,
          "new_text": "Bytes.drop_front(CustomDelimiterLen).drop_back(CustomDelimiterLen)",
          "old_line_content": "",
          "new_line_content": "    Bytes = Bytes.drop_front(CustomDelimiterLen).drop_back(CustomDelimiterLen);",
          "content_same": false
        },
        {
          "line": 1598,
          "old_api": null,
          "new_api": "drop_front",
          "old_text": null,
          "new_text": "Bytes.drop_front(3).drop_back(3)",
          "old_line_content": "",
          "new_line_content": "    Bytes = Bytes.drop_front(3).drop_back(3);",
          "content_same": false
        },
        {
          "line": 1607,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "longer.size()",
          "old_line_content": "static size_t commonPrefixLength(StringRef shorter, StringRef longer) {",
          "new_line_content": "  while (offset < shorter.size() && offset < longer.size() && shorter[offset] == longer[offset]) {",
          "content_same": false
        },
        {
          "line": 1619,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "Bytes.end()",
          "old_line_content": "getMultilineTrailingIndent(StringRef Bytes, DiagnosticEngine *Diags = nullptr,",
          "new_line_content": "  const char *begin = Bytes.begin(), *end = Bytes.end(), *start = end;",
          "content_same": false
        },
        {
          "line": 1640,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(Ptr)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(Ptr)",
          "old_line_content": "        while (Ptr > begin && (*Ptr == ' ' || *Ptr == '\\t')) --Ptr;",
          "new_line_content": "          auto escapeLoc = Lexer::getSourceLoc(Ptr);",
          "content_same": false
        },
        {
          "line": 1644,
          "old_api": null,
          "new_api": "fixItRemoveChars",
          "old_text": null,
          "new_text": "Diags->diagnose(escapeLoc, diag::lex_escaped_newline_at_lastline)\n              .fixItRemoveChars(escapeLoc, Lexer::getSourceLoc(LineEnd))",
          "old_line_content": "          while (*--Ptr == '\\\\') invalid = !invalid;",
          "new_line_content": "            Diags->diagnose(escapeLoc, diag::lex_escaped_newline_at_lastline)",
          "content_same": false
        },
        {
          "line": 1645,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(LineEnd)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(LineEnd)",
          "old_line_content": "          if (invalid)",
          "new_line_content": "              .fixItRemoveChars(escapeLoc, Lexer::getSourceLoc(LineEnd));",
          "content_same": false
        },
        {
          "line": 1649,
          "old_api": null,
          "new_api": "StringRef",
          "old_text": null,
          "new_text": "StringRef(start, end - start)",
          "old_line_content": "      }",
          "new_line_content": "      return StringRef(start, end - start);",
          "content_same": false
        },
        {
          "line": 1657,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(start + 1)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(start + 1)",
          "old_line_content": "  ",
          "new_line_content": "    auto loc = Lexer::getSourceLoc(start + 1);",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": null,
          "new_api": "fixItInsert",
          "old_text": null,
          "new_text": "Diags->diagnose(loc, diag::lex_illegal_multiline_string_end)\n    // FIXME: Should try to suggest indentation.\n      .fixItInsert(loc, \"\\n\")",
          "old_line_content": "  if (sawNonWhitespace && Diags) {",
          "new_line_content": "    Diags->diagnose(loc, diag::lex_illegal_multiline_string_end)",
          "content_same": false
        },
        {
          "line": 1678,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "ExpectedIndent.size()",
          "old_line_content": "                                            size_t MistakeOffset,",
          "new_line_content": "  if (MistakeOffset >= ExpectedIndent.size()) {",
          "content_same": false
        },
        {
          "line": 1683,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "LineStarts.empty()",
          "old_line_content": "  }",
          "new_line_content": "  assert(!LineStarts.empty());",
          "content_same": false
        },
        {
          "line": 1686,
          "old_api": null,
          "new_api": "bytes_begin",
          "old_text": null,
          "new_text": "Bytes.bytes_begin()",
          "old_line_content": "",
          "new_line_content": "    return Lexer::getSourceLoc((const char *)Bytes.bytes_begin() + offset);",
          "content_same": false
        },
        {
          "line": 1699,
          "old_api": null,
          "new_api": "getLoc",
          "old_text": null,
          "new_text": "getLoc(LineStarts[0] + MistakeOffset)",
          "old_line_content": "  };",
          "new_line_content": "  Diags->diagnose(getLoc(LineStarts[0] + MistakeOffset),",
          "content_same": false
        },
        {
          "line": 1702,
          "old_api": null,
          "new_api": "classify",
          "old_text": null,
          "new_text": "classify(Bytes[LineStarts[0] + MistakeOffset])",
          "old_line_content": "                  diag::lex_multiline_string_indent_inconsistent,",
          "new_line_content": "                  classify(Bytes[LineStarts[0] + MistakeOffset]));",
          "content_same": false
        },
        {
          "line": 1713,
          "old_api": null,
          "new_api": "substr",
          "old_text": null,
          "new_text": "ExpectedIndent.substr(0, MistakeOffset)",
          "old_line_content": "  ",
          "new_line_content": "  assert(ExpectedIndent.substr(0, MistakeOffset) == ",
          "content_same": false
        },
        {
          "line": 1717,
          "old_api": null,
          "new_api": "getLoc",
          "old_text": null,
          "new_text": "getLoc(line + MistakeOffset)",
          "old_line_content": "  ",
          "new_line_content": "    fix.fixItReplaceChars(getLoc(line + MistakeOffset), ",
          "content_same": false
        },
        {
          "line": 1718,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "ActualIndent.size()",
          "old_line_content": "  for (auto line : LineStarts) {",
          "new_line_content": "                          getLoc(line + ActualIndent.size()),",
          "content_same": false
        },
        {
          "line": 1727,
          "old_api": null,
          "new_api": "getStringLiteralContent",
          "old_text": null,
          "new_text": "getStringLiteralContent(Str)",
          "old_line_content": "static void validateMultilineIndents(const Token &Str,",
          "new_line_content": "  StringRef Bytes = getStringLiteralContent(Str);",
          "content_same": false
        },
        {
          "line": 1730,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "Indent.empty()",
          "old_line_content": "  StringRef Indent =",
          "new_line_content": "  if (Indent.empty())",
          "content_same": false
        },
        {
          "line": 1736,
          "old_api": null,
          "new_api": "std::numeric_limits<size_t>::max()",
          "old_text": null,
          "new_text": "std::numeric_limits<size_t>::max()",
          "old_line_content": "  // The offset into the previous line where it experienced its first indentation ",
          "new_line_content": "  size_t lastMistakeOffset = std::numeric_limits<size_t>::max();",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "Bytes.find('\\n', pos + 1)",
          "old_line_content": "  StringRef commonIndentation = \"\";",
          "new_line_content": "  for (size_t pos = Bytes.find('\\n'); pos != StringRef::npos; pos = Bytes.find('\\n', pos + 1)) {",
          "content_same": false
        },
        {
          "line": 1753,
          "old_api": null,
          "new_api": "commonPrefixLength",
          "old_text": null,
          "new_text": "commonPrefixLength(Indent, restOfBytes)",
          "old_line_content": "    ",
          "new_line_content": "    auto errorOffset = commonPrefixLength(Indent, restOfBytes);",
          "content_same": false
        },
        {
          "line": 1758,
          "old_api": null,
          "new_api": "diagnoseInvalidMultilineIndents",
          "old_text": null,
          "new_text": "diagnoseInvalidMultilineIndents(Diags, Indent, IndentStartLoc, Bytes, \n                                      linesWithLastMistakeOffset, lastMistakeOffset, \n                                      commonIndentation)",
          "old_line_content": "    if (errorOffset != lastMistakeOffset) {",
          "new_line_content": "      diagnoseInvalidMultilineIndents(Diags, Indent, IndentStartLoc, Bytes, ",
          "content_same": false
        },
        {
          "line": 1767,
          "old_api": null,
          "new_api": "find_first_not_of",
          "old_text": null,
          "new_text": "restOfBytes.find_first_not_of(\" \\t\")",
          "old_line_content": "      ",
          "new_line_content": "      auto prefixLength = restOfBytes.find_first_not_of(\" \\t\");",
          "content_same": false
        },
        {
          "line": 1768,
          "old_api": null,
          "new_api": "substr",
          "old_text": null,
          "new_text": "restOfBytes.substr(0, prefixLength)",
          "old_line_content": "      // To begin with, all whitespace is part of the common indentation.",
          "new_line_content": "      commonIndentation = restOfBytes.substr(0, prefixLength);",
          "content_same": false
        },
        {
          "line": 1772,
          "old_api": null,
          "new_api": "commonPrefixLength",
          "old_text": null,
          "new_text": "commonPrefixLength(commonIndentation, restOfBytes)",
          "old_line_content": "    else {",
          "new_line_content": "      auto prefixLength = commonPrefixLength(commonIndentation, restOfBytes);",
          "content_same": false
        },
        {
          "line": 1773,
          "old_api": null,
          "new_api": "substr",
          "old_text": null,
          "new_text": "commonIndentation.substr(0, prefixLength)",
          "old_line_content": "      // We're continuing the run, so include this line in the common prefix.",
          "new_line_content": "      commonIndentation = commonIndentation.substr(0, prefixLength);",
          "content_same": false
        },
        {
          "line": 1777,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "linesWithLastMistakeOffset.push_back(nextpos)",
          "old_line_content": "    ",
          "new_line_content": "    linesWithLastMistakeOffset.push_back(nextpos);",
          "content_same": false
        },
        {
          "line": 1781,
          "old_api": null,
          "new_api": "diagnoseInvalidMultilineIndents",
          "old_text": null,
          "new_text": "diagnoseInvalidMultilineIndents(Diags, Indent, IndentStartLoc, Bytes, \n                                  linesWithLastMistakeOffset, lastMistakeOffset, \n                                  commonIndentation)",
          "old_line_content": "  ",
          "new_line_content": "  diagnoseInvalidMultilineIndents(Diags, Indent, IndentStartLoc, Bytes, ",
          "content_same": false
        },
        {
          "line": 1791,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(*TokStart == '\\'' && TokEnd[-1] == '\\'')",
          "old_line_content": "                                             const char *TokEnd,",
          "new_line_content": "  assert(*TokStart == '\\'' && TokEnd[-1] == '\\'');",
          "content_same": false
        },
        {
          "line": 1796,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "replacement.push_back('\"')",
          "old_line_content": "",
          "new_line_content": "  replacement.push_back('\"');",
          "content_same": false
        },
        {
          "line": 1803,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "replacement.append(OutputPtr, Ptr - 1)",
          "old_line_content": "    if (Ptr[-1] == '\\\\') {",
          "new_line_content": "        replacement.append(OutputPtr, Ptr - 1);",
          "content_same": false
        },
        {
          "line": 1806,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "replacement.push_back('\\'')",
          "old_line_content": "        OutputPtr = Ptr + 1;",
          "new_line_content": "        replacement.push_back('\\'');",
          "content_same": false
        },
        {
          "line": 1809,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "replacement.end()",
          "old_line_content": "      } else if (*Ptr == '(') {",
          "new_line_content": "        Ptr = skipToEndOfInterpolatedExpression(Ptr + 1, replacement.end(),",
          "content_same": false
        },
        {
          "line": 1816,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "replacement.append(OutputPtr, Ptr - 1)",
          "old_line_content": "      ++Ptr;",
          "new_line_content": "      replacement.append(OutputPtr, Ptr - 1);",
          "content_same": false
        },
        {
          "line": 1819,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "replacement.append(\"\\\\\\\"\")",
          "old_line_content": "      OutputPtr = Ptr;",
          "new_line_content": "      replacement.append(\"\\\\\\\"\");",
          "content_same": false
        },
        {
          "line": 1822,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(Ptr == TokEnd && Ptr[-1] == '\\'')",
          "old_line_content": "    }",
          "new_line_content": "  assert(Ptr == TokEnd && Ptr[-1] == '\\'');",
          "content_same": false
        },
        {
          "line": 1823,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "replacement.append(OutputPtr, Ptr - 1)",
          "old_line_content": "  }",
          "new_line_content": "  replacement.append(OutputPtr, Ptr - 1);",
          "content_same": false
        },
        {
          "line": 1827,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(TokStart)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(TokStart)",
          "old_line_content": "",
          "new_line_content": "      .fixItReplaceChars(Lexer::getSourceLoc(TokStart),",
          "content_same": false
        },
        {
          "line": 1841,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert((QuoteChar == '\"' || QuoteChar == '\\'') && \"Unexpected start\")",
          "old_line_content": "  // NOTE: We only allow single-quote string literals so we can emit useful",
          "new_line_content": "  assert((QuoteChar == '\"' || QuoteChar == '\\'') && \"Unexpected start\");",
          "content_same": false
        },
        {
          "line": 1846,
          "old_api": null,
          "new_api": "Lexer::getSourceLoc(CurPtr)",
          "old_text": null,
          "new_text": "Lexer::getSourceLoc(CurPtr)",
          "old_line_content": "  if (IsMultilineString && *CurPtr != '\\n' && *CurPtr != '\\r')",
          "new_line_content": "        .fixItInsert(Lexer::getSourceLoc(CurPtr), \"\\n\");",
          "content_same": false
        },
        {
          "line": 1853,
          "old_api": null,
          "new_api": "delimiterMatches",
          "old_text": null,
          "new_text": "delimiterMatches(CustomDelimiterLen, TmpPtr, nullptr)",
          "old_line_content": "    const char *TmpPtr = CurPtr + 1;",
          "new_line_content": "        delimiterMatches(CustomDelimiterLen, TmpPtr, nullptr) &&",
          "content_same": false
        },
        {
          "line": 1856,
          "old_api": null,
          "new_api": "skipToEndOfInterpolatedExpression",
          "old_text": null,
          "new_text": "skipToEndOfInterpolatedExpression(TmpPtr, BufferEnd,\n                                                 IsMultilineString)",
          "old_line_content": "        *TmpPtr++ == '(') {",
          "new_line_content": "      CurPtr = skipToEndOfInterpolatedExpression(TmpPtr, BufferEnd,",
          "content_same": false
        },
        {
          "line": 1865,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CurPtr, diag::lex_unterminated_string)",
          "old_line_content": "        // The only case we reach here is unterminated single line string in the",
          "new_line_content": "        diagnose(CurPtr, diag::lex_unterminated_string);",
          "content_same": false
        },
        {
          "line": 1869,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(TokStart, diag::lex_unterminated_string)",
          "old_line_content": "        continue;",
          "new_line_content": "        diagnose(TokStart, diag::lex_unterminated_string);",
          "content_same": false
        },
        {
          "line": 1870,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "      } else {",
          "new_line_content": "        return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 1877,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(TokStart, diag::lex_unterminated_string)",
          "old_line_content": "    if (((*CurPtr == '\\r' || *CurPtr == '\\n') && !IsMultilineString)",
          "new_line_content": "      diagnose(TokStart, diag::lex_unterminated_string);",
          "content_same": false
        },
        {
          "line": 1878,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "        || CurPtr == BufferEnd) {",
          "new_line_content": "      return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 1881,
          "old_api": null,
          "new_api": "lexCharacter",
          "old_text": null,
          "new_text": "lexCharacter(CurPtr, QuoteChar, true,\n                                      IsMultilineString, CustomDelimiterLen)",
          "old_line_content": "    }",
          "new_line_content": "    unsigned CharValue = lexCharacter(CurPtr, QuoteChar, true,",
          "content_same": false
        },
        {
          "line": 1892,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(!IsMultilineString && CustomDelimiterLen == 0 &&\n           \"Single quoted string cannot have custom delimitor, nor multiline\")",
          "old_line_content": "",
          "new_line_content": "    assert(!IsMultilineString && CustomDelimiterLen == 0 &&",
          "content_same": false
        },
        {
          "line": 1898,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::unknown, TokStart)",
          "old_line_content": "",
          "new_line_content": "    return formToken(tok::unknown, TokStart);",
          "content_same": false
        },
        {
          "line": 1924,
          "old_api": null,
          "new_api": "lexCharacter",
          "old_text": null,
          "new_text": "lexCharacter(Body, '\\0', /*EmitDiagnostics=*/false)",
          "old_line_content": "    // Get the next character.",
          "new_line_content": "    unsigned CharValue = lexCharacter(Body, '\\0', /*EmitDiagnostics=*/false);",
          "content_same": false
        },
        {
          "line": 1937,
          "old_api": null,
          "new_api": "fixItReplaceChars",
          "old_text": null,
          "new_text": "diagnose(CharStart, diag::lex_invalid_curly_quote)\n            .fixItReplaceChars(getSourceLoc(CharStart), getSourceLoc(Body),\n                               \"\\\"\")",
          "old_line_content": "    if (CharValue == 0x0000201D) {",
          "new_line_content": "        diagnose(CharStart, diag::lex_invalid_curly_quote)",
          "content_same": false
        },
        {
          "line": 1938,
          "old_api": null,
          "new_api": "getSourceLoc",
          "old_text": null,
          "new_text": "getSourceLoc(Body)",
          "old_line_content": "      if (EmitDiagnostics) {",
          "new_line_content": "            .fixItReplaceChars(getSourceLoc(CharStart), getSourceLoc(Body),",
          "content_same": false
        },
        {
          "line": 1954,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(CurPtr[-1] == '`' && \"Unexpected start of escaped identifier\")",
          "old_line_content": "/// If it doesn't match this production, the leading ` is a punctuator.",
          "new_line_content": "  assert(CurPtr[-1] == '`' && \"Unexpected start of escaped identifier\");",
          "content_same": false
        },
        {
          "line": 1961,
          "old_api": null,
          "new_api": "advanceIfValidStartOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidStartOfIdentifier(CurPtr, BufferEnd)",
          "old_line_content": "  // case this is an escaped identifier.",
          "new_line_content": "  if (advanceIfValidStartOfIdentifier(CurPtr, BufferEnd)) {",
          "content_same": false
        },
        {
          "line": 1968,
          "old_api": null,
          "new_api": "formEscapedIdentifierToken",
          "old_text": null,
          "new_text": "formEscapedIdentifierToken(Quote)",
          "old_line_content": "    if (*CurPtr == '`') {",
          "new_line_content": "      formEscapedIdentifierToken(Quote);",
          "content_same": false
        },
        {
          "line": 1976,
          "old_api": null,
          "new_api": "formEscapedIdentifierToken",
          "old_text": null,
          "new_text": "formEscapedIdentifierToken(Quote)",
          "old_line_content": "  if (Quote[1] == '$' && Quote[2] == '`') {",
          "new_line_content": "    formEscapedIdentifierToken(Quote);",
          "content_same": false
        },
        {
          "line": 1982,
          "old_api": null,
          "new_api": "formToken",
          "old_text": null,
          "new_text": "formToken(tok::backtick, Quote)",
          "old_line_content": "  // The backtick is punctuation.",
          "new_line_content": "  formToken(tok::backtick, Quote);",
          "content_same": false
        },
        {
          "line": 1990,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "terminator.size()",
          "old_line_content": "  StringRef terminator = CMK == ConflictMarkerKind::Perforce ? \"<<<<\\n\"",
          "new_line_content": "  size_t termLen = terminator.size();",
          "content_same": false
        },
        {
          "line": 1994,
          "old_api": null,
          "new_api": "substr",
          "old_text": null,
          "new_text": "StringRef(CurPtr, BufferEnd - CurPtr).substr(termLen)",
          "old_line_content": "  // Get a reference to the rest of the buffer minus the length of the start",
          "new_line_content": "  auto restOfBuffer = StringRef(CurPtr, BufferEnd - CurPtr).substr(termLen);",
          "content_same": false
        },
        {
          "line": 1995,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "restOfBuffer.find(terminator)",
          "old_line_content": "  // of the conflict marker.",
          "new_line_content": "  size_t endPos = restOfBuffer.find(terminator);",
          "content_same": false
        },
        {
          "line": 2001,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "restOfBuffer.data()",
          "old_line_content": "        (restOfBuffer[endPos - 1] == '\\r' || restOfBuffer[endPos - 1] == '\\n'))",
          "new_line_content": "      return restOfBuffer.data() + endPos;",
          "content_same": false
        },
        {
          "line": 2004,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "restOfBuffer.find(terminator)",
          "old_line_content": "    }",
          "new_line_content": "    endPos = restOfBuffer.find(terminator);",
          "content_same": false
        },
        {
          "line": 2018,
          "old_api": null,
          "new_api": "startswith",
          "old_text": null,
          "new_text": "restOfBuffer.startswith(\">>>> \")",
          "old_line_content": "  // Check to see if we have <<<<<<< or >>>>.",
          "new_line_content": "  if (!restOfBuffer.startswith(\"<<<<<<< \") && !restOfBuffer.startswith(\">>>> \"))",
          "content_same": false
        },
        {
          "line": 2023,
          "old_api": null,
          "new_api": "findConflictEnd",
          "old_text": null,
          "new_text": "findConflictEnd(Ptr, BufferEnd, Kind)",
          "old_line_content": "  ConflictMarkerKind Kind = *Ptr == '<' ? ConflictMarkerKind::Normal",
          "new_line_content": "  if (const char *End = findConflictEnd(Ptr, BufferEnd, Kind)) {",
          "content_same": false
        },
        {
          "line": 2030,
          "old_api": null,
          "new_api": "skipToEndOfLine",
          "old_text": null,
          "new_text": "skipToEndOfLine(EatNewline)",
          "old_line_content": "    // Skip ahead to the end of the marker.",
          "new_line_content": "      skipToEndOfLine(EatNewline);",
          "content_same": false
        },
        {
          "line": 2042,
          "old_api": null,
          "new_api": "advanceIfValidContinuationOfIdentifier",
          "old_text": null,
          "new_text": "advanceIfValidContinuationOfIdentifier(Tmp, BufferEnd)",
          "old_line_content": "  const char *Tmp = CurPtr - 1;",
          "new_line_content": "  if (advanceIfValidContinuationOfIdentifier(Tmp, BufferEnd)) {",
          "content_same": false
        },
        {
          "line": 2046,
          "old_api": null,
          "new_api": "diagnose",
          "old_text": null,
          "new_text": "diagnose(CurPtr - 1, diag::lex_invalid_identifier_start_character)",
          "old_line_content": "    // start, attempt to recover by eating more continuation characters.",
          "new_line_content": "      diagnose(CurPtr - 1, diag::lex_invalid_identifier_start_character);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2050,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(Tmp, BufferEnd)",
          "new_text": null,
          "old_line_content": "    while (advanceIfValidContinuationOfIdentifier(Tmp, BufferEnd))",
          "new_line_content": "    CurPtr = Tmp;",
          "content_same": false
        },
        {
          "line": 2059,
          "old_api": "fixItReplaceChars",
          "new_api": null,
          "old_text": "diagnose(CurPtr - 1, diag::lex_invalid_utf8)\n        .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \" \")",
          "new_text": null,
          "old_line_content": "    diagnose(CurPtr - 1, diag::lex_invalid_utf8)",
          "new_line_content": "    CurPtr = Tmp;",
          "content_same": false
        },
        {
          "line": 2060,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(Tmp)",
          "new_text": null,
          "old_line_content": "        .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \" \");",
          "new_line_content": "    return false; // Skip presumed whitespace.",
          "content_same": false
        },
        {
          "line": 2069,
          "old_api": "fixItReplaceChars",
          "new_api": null,
          "old_text": "diagnose(CurPtr - 1, diag::lex_nonbreaking_space)\n          .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp),\n                             Spaces)",
          "new_text": null,
          "old_line_content": "      diagnose(CurPtr - 1, diag::lex_nonbreaking_space)",
          "new_line_content": "                             Spaces);",
          "content_same": false
        },
        {
          "line": 2070,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(Tmp)",
          "new_text": null,
          "old_line_content": "          .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp),",
          "new_line_content": "      CurPtr = Tmp;",
          "content_same": false
        },
        {
          "line": 2077,
          "old_api": "fixItReplaceChars",
          "new_api": null,
          "old_text": "diagnose(CurPtr - 1, diag::lex_invalid_curly_quote)\n          .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \"\\\"\")",
          "new_text": null,
          "old_line_content": "      diagnose(CurPtr - 1, diag::lex_invalid_curly_quote)",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2078,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(Tmp)",
          "new_text": null,
          "old_line_content": "          .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \"\\\"\");",
          "new_line_content": "    CurPtr = Tmp;",
          "content_same": false
        },
        {
          "line": 2087,
          "old_api": "findEndOfCurlyQuoteStringLiteral",
          "new_api": null,
          "old_text": "findEndOfCurlyQuoteStringLiteral(Tmp, EmitDiagnosticsIfToken)",
          "new_text": null,
          "old_line_content": "            findEndOfCurlyQuoteStringLiteral(Tmp, EmitDiagnosticsIfToken))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2096,
          "old_api": "fixItReplaceChars",
          "new_api": null,
          "old_text": "diagnose(CurPtr - 1, diag::lex_invalid_curly_quote)\n          .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(EndPtr),\n                             \"\\\"\")",
          "new_text": null,
          "old_line_content": "      diagnose(CurPtr - 1, diag::lex_invalid_curly_quote)",
          "new_line_content": "                             \"\\\"\");",
          "content_same": false
        },
        {
          "line": 2097,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(EndPtr)",
          "new_text": null,
          "old_line_content": "          .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(EndPtr),",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2104,
          "old_api": "fixItReplaceChars",
          "new_api": null,
          "old_text": "diagnose(CurPtr - 1, diag::lex_invalid_character)\n      .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \" \")",
          "new_text": null,
          "old_line_content": "  diagnose(CurPtr - 1, diag::lex_invalid_character)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2105,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(Tmp)",
          "new_text": null,
          "old_line_content": "      .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp), \" \");",
          "new_line_content": "  char ExpectedCodepoint;",
          "content_same": false
        },
        {
          "line": 2109,
          "old_api": "confusable::tryConvertConfusableCharacterToASCII(Codepoint)",
          "new_api": null,
          "old_text": "confusable::tryConvertConfusableCharacterToASCII(Codepoint)",
          "new_text": null,
          "old_line_content": "           confusable::tryConvertConfusableCharacterToASCII(Codepoint))) {",
          "new_line_content": "    llvm::SmallString<4> ConfusedChar;",
          "content_same": false
        },
        {
          "line": 2112,
          "old_api": "EncodeToUTF8",
          "new_api": null,
          "old_text": "EncodeToUTF8(Codepoint, ConfusedChar)",
          "new_text": null,
          "old_line_content": "    EncodeToUTF8(Codepoint, ConfusedChar);",
          "new_line_content": "    ExpectedChar += ExpectedCodepoint;",
          "content_same": false
        },
        {
          "line": 2117,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(Tmp)",
          "new_text": null,
          "old_line_content": "        .fixItReplaceChars(getSourceLoc(CurPtr - 1), getSourceLoc(Tmp),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2126,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(Ptr != nullptr && *Ptr == 0)",
          "new_text": null,
          "old_line_content": "  assert(Ptr != nullptr && *Ptr == 0);",
          "new_line_content": "    return NulCharacterKind::CodeCompletion;",
          "content_same": false
        },
        {
          "line": 2137,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(CurPtr[-1] == '<' && CurPtr[0] == '#')",
          "new_text": null,
          "old_line_content": "  assert(CurPtr[-1] == '<' && CurPtr[0] == '#');",
          "new_line_content": "  for (const char *Ptr = CurPtr+1; Ptr < BufferEnd-1; ++Ptr) {",
          "content_same": false
        },
        {
          "line": 2150,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(TokStart, diag::lex_editor_placeholder)",
          "new_text": null,
          "old_line_content": "        diagnose(TokStart, diag::lex_editor_placeholder);",
          "new_line_content": "      CurPtr = Ptr+2;",
          "content_same": false
        },
        {
          "line": 2153,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::identifier, TokStart)",
          "new_text": null,
          "old_line_content": "      formToken(tok::identifier, TokStart);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2159,
          "old_api": "lexOperatorIdentifier",
          "new_api": null,
          "old_text": "lexOperatorIdentifier()",
          "new_text": null,
          "old_line_content": "  lexOperatorIdentifier();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2169,
          "old_api": "clear",
          "new_api": null,
          "old_text": "TempString.clear()",
          "new_text": null,
          "old_line_content": "  TempString.clear();",
          "new_line_content": "  // know that there is a terminating \" character (or null byte for an",
          "content_same": false
        },
        {
          "line": 2174,
          "old_api": "begin",
          "new_api": null,
          "old_text": "Bytes.begin()",
          "new_text": null,
          "old_line_content": "  const char *BytesPtr = Bytes.begin();",
          "new_line_content": "  // Special case when being called from EncodedDiagnosticMessage(...)",
          "content_same": false
        },
        {
          "line": 2179,
          "old_api": "size",
          "new_api": null,
          "old_text": "getMultilineTrailingIndent(Bytes).size()",
          "new_text": null,
          "old_line_content": "    IndentToStrip = getMultilineTrailingIndent(Bytes).size();",
          "new_line_content": "  bool IsEscapedNewline = false;",
          "content_same": false
        },
        {
          "line": 2182,
          "old_api": "end",
          "new_api": null,
          "old_text": "Bytes.end()",
          "new_text": null,
          "old_line_content": "  while (BytesPtr < Bytes.end()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2188,
          "old_api": "begin",
          "new_api": null,
          "old_text": "Bytes.begin()",
          "new_text": null,
          "old_line_content": "        (IsFirstSegment && BytesPtr - 1 == Bytes.begin());",
          "new_line_content": "        ++BytesPtr;",
          "content_same": false
        },
        {
          "line": 2193,
          "old_api": "end",
          "new_api": null,
          "old_text": "Bytes.end()",
          "new_text": null,
          "old_line_content": "      if (IsLastSegment && BytesPtr == Bytes.end())",
          "new_line_content": "      if (!stripNewline)",
          "content_same": false
        },
        {
          "line": 2196,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "TempString.push_back('\\n')",
          "new_text": null,
          "old_line_content": "        TempString.push_back('\\n');",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 2202,
          "old_api": "delimiterMatches",
          "new_api": null,
          "old_text": "delimiterMatches(CustomDelimiterLen, BytesPtr, nullptr)",
          "new_text": null,
          "old_line_content": "        !delimiterMatches(CustomDelimiterLen, BytesPtr, nullptr)) {",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 2203,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "TempString.push_back(CurChar)",
          "new_text": null,
          "old_line_content": "      TempString.push_back(CurChar);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2220,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "TempString.push_back('\\'')",
          "new_text": null,
          "old_line_content": "    case '\\'': TempString.push_back('\\''); continue;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2221,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "TempString.push_back('\\\\')",
          "new_text": null,
          "old_line_content": "    case '\\\\': TempString.push_back('\\\\'); continue;",
          "new_line_content": "    case ' ': case '\\t': case '\\n': case '\\r':",
          "content_same": false
        },
        {
          "line": 2224,
          "old_api": "maybeConsumeNewlineEscape",
          "new_api": null,
          "old_text": "maybeConsumeNewlineEscape(BytesPtr, -1)",
          "new_text": null,
          "old_line_content": "      if (maybeConsumeNewlineEscape(BytesPtr, -1)) {",
          "new_line_content": "        --BytesPtr;",
          "content_same": false
        },
        {
          "line": 2232,
          "old_api": "llvm_unreachable",
          "new_api": null,
          "old_text": "llvm_unreachable(\"string contained interpolated segments\")",
          "new_text": null,
          "old_line_content": "      llvm_unreachable(\"string contained interpolated segments\");",
          "new_line_content": "      // Unicode escapes of various lengths.",
          "content_same": false
        },
        {
          "line": 2239,
          "old_api": "lexUnicodeEscape",
          "new_api": null,
          "old_text": "lexUnicodeEscape(BytesPtr, /*no diagnostics*/nullptr)",
          "new_text": null,
          "old_line_content": "      CharValue = lexUnicodeEscape(BytesPtr, /*no diagnostics*/nullptr);",
          "new_line_content": "      if (CharValue == ~1U) continue;",
          "content_same": false
        },
        {
          "line": 2248,
          "old_api": "EncodeToUTF8",
          "new_api": null,
          "old_text": "EncodeToUTF8(CharValue, TempString)",
          "new_text": null,
          "old_line_content": "      EncodeToUTF8(CharValue, TempString);",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 2255,
          "old_api": "size",
          "new_api": null,
          "old_text": "Bytes.size()",
          "new_text": null,
          "old_line_content": "  if (TempString.size() == Bytes.size()) {",
          "new_line_content": "    return Bytes;",
          "content_same": false
        },
        {
          "line": 2256,
          "old_api": "clear",
          "new_api": null,
          "old_text": "TempString.clear()",
          "new_text": null,
          "old_line_content": "    TempString.clear();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2259,
          "old_api": "size",
          "new_api": null,
          "old_text": "TempString.size()",
          "new_text": null,
          "old_line_content": "  return StringRef(TempString.begin(), TempString.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2268,
          "old_api": "getStringLiteralContent",
          "new_api": null,
          "old_text": "getStringLiteralContent(Str)",
          "new_text": null,
          "old_line_content": "  StringRef Bytes = getStringLiteralContent(Str);",
          "new_line_content": "  // Are substitutions required either for indent stripping or line ending",
          "content_same": false
        },
        {
          "line": 2272,
          "old_api": "isMultilineString",
          "new_api": null,
          "old_text": "Str.isMultilineString()",
          "new_text": null,
          "old_line_content": "  bool MultilineString = Str.isMultilineString(), IsFirstSegment = true;",
          "new_line_content": "  if (MultilineString)",
          "content_same": false
        },
        {
          "line": 2275,
          "old_api": "size",
          "new_api": null,
          "old_text": "getMultilineTrailingIndent(Bytes).size()",
          "new_text": null,
          "old_line_content": "    IndentToStrip = getMultilineTrailingIndent(Bytes).size();",
          "new_line_content": "  // Note that it is always safe to read one over the end of \"Bytes\" because",
          "content_same": false
        },
        {
          "line": 2280,
          "old_api": "begin",
          "new_api": null,
          "old_text": "Bytes.begin()",
          "new_text": null,
          "old_line_content": "  const char *SegmentStartPtr = Bytes.begin();",
          "new_line_content": "  size_t pos;",
          "content_same": false
        },
        {
          "line": 2283,
          "old_api": "begin",
          "new_api": null,
          "old_text": "Bytes.begin()",
          "new_text": null,
          "old_line_content": "  while ((pos = Bytes.find('\\\\', BytesPtr-Bytes.begin())) != StringRef::npos) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2286,
          "old_api": "delimiterMatches",
          "new_api": null,
          "old_text": "delimiterMatches(CustomDelimiterLen, BytesPtr, Diags)",
          "new_text": null,
          "old_line_content": "    if (!delimiterMatches(CustomDelimiterLen, BytesPtr, Diags) ||",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 2293,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "Segments.push_back(\n        StringSegment::getLiteral(getSourceLoc(SegmentStartPtr),\n                                  BytesPtr-SegmentStartPtr-2-CustomDelimiterLen,\n                                  IsFirstSegment, false, IndentToStrip,\n                                  CustomDelimiterLen))",
          "new_text": null,
          "old_line_content": "    Segments.push_back(",
          "new_line_content": "                                  BytesPtr-SegmentStartPtr-2-CustomDelimiterLen,",
          "content_same": false
        },
        {
          "line": 2294,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(SegmentStartPtr)",
          "new_text": null,
          "old_line_content": "        StringSegment::getLiteral(getSourceLoc(SegmentStartPtr),",
          "new_line_content": "                                  IsFirstSegment, false, IndentToStrip,",
          "content_same": false
        },
        {
          "line": 2302,
          "old_api": "getText",
          "new_api": null,
          "old_text": "Str.getText().end()",
          "new_text": null,
          "old_line_content": "        BytesPtr, Str.getText().end(), MultilineString);",
          "new_line_content": "           \" not be returned as string literals\");",
          "content_same": false
        },
        {
          "line": 2303,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(*End == ')' && \"invalid string literal interpolations should\"\n           \" not be returned as string literals\")",
          "new_text": null,
          "old_line_content": "    assert(*End == ')' && \"invalid string literal interpolations should\"",
          "new_line_content": "    ++End;",
          "content_same": false
        },
        {
          "line": 2308,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "Segments.push_back(\n        StringSegment::getExpr(getSourceLoc(BytesPtr-1), End-BytesPtr+1))",
          "new_text": null,
          "old_line_content": "    Segments.push_back(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2309,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(BytesPtr-1)",
          "new_text": null,
          "old_line_content": "        StringSegment::getExpr(getSourceLoc(BytesPtr-1), End-BytesPtr+1));",
          "new_line_content": "    // Reset the beginning of the segment to the string that remains to be",
          "content_same": false
        },
        {
          "line": 2317,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(SegmentStartPtr)",
          "new_text": null,
          "old_line_content": "      StringSegment::getLiteral(getSourceLoc(SegmentStartPtr),",
          "new_line_content": "                                IsFirstSegment, true, IndentToStrip,",
          "content_same": false
        },
        {
          "line": 2318,
          "old_api": "end",
          "new_api": null,
          "old_text": "Bytes.end()",
          "new_text": null,
          "old_line_content": "                                Bytes.end()-SegmentStartPtr,",
          "new_line_content": "                                CustomDelimiterLen));",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": "lex",
          "new_api": null,
          "old_text": "L.lex(Result)",
          "new_text": null,
          "old_line_content": "  L.lex(Result);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(CurPtr >= BufferStart &&\n         CurPtr <= BufferEnd && \"Current pointer out of range!\")",
          "new_text": null,
          "old_line_content": "  assert(CurPtr >= BufferStart &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2329,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(CurPtr >= BufferStart &&\n         CurPtr <= BufferEnd && \"Current pointer out of range!\")",
          "new_text": null,
          "old_line_content": "  assert(CurPtr >= BufferStart &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2332,
          "old_api": "clear",
          "new_api": null,
          "old_text": "LeadingTrivia.clear()",
          "new_text": null,
          "old_line_content": "  LeadingTrivia.clear();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2333,
          "old_api": "clear",
          "new_api": null,
          "old_text": "TrailingTrivia.clear()",
          "new_text": null,
          "old_line_content": "  TrailingTrivia.clear();",
          "new_line_content": "  if (CurPtr == BufferStart) {",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": "isComment",
          "new_api": null,
          "old_text": "llvm::find_if(LeadingTrivia, [](const TriviaPiece &Piece) {\n      return Piece.isComment();\n    })",
          "new_text": null,
          "old_line_content": "    auto Iter = llvm::find_if(LeadingTrivia, [](const TriviaPiece &Piece) {",
          "new_line_content": "    });",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": "end",
          "new_api": null,
          "old_text": "LeadingTrivia.end()",
          "new_text": null,
          "old_line_content": "    for (auto End = LeadingTrivia.end(); Iter != End; Iter++) {",
          "new_line_content": "        // Since Token::getCommentRange() doesn't take backtick into account,",
          "content_same": false
        },
        {
          "line": 293,
          "old_api": "getKind",
          "new_api": null,
          "old_text": "Iter->getKind()",
          "new_text": null,
          "old_line_content": "      if (Iter->getKind() == TriviaKind::Backtick)",
          "new_line_content": "        // we cannot include length of backtick.",
          "content_same": false
        },
        {
          "line": 2340,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(CurPtr, BOMLen)",
          "new_text": null,
          "old_line_content": "      auto Text = OwnedString::makeRefCounted(StringRef(CurPtr, BOMLen));",
          "new_line_content": "      CurPtr += BOMLen;",
          "content_same": false
        },
        {
          "line": 2341,
          "old_api": "TriviaPiece::garbageText(Text)",
          "new_api": null,
          "old_text": "TriviaPiece::garbageText(Text)",
          "new_text": null,
          "old_line_content": "      LeadingTrivia.push_back(TriviaPiece::garbageText(Text));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 297,
          "old_api": "getTextLength",
          "new_api": null,
          "old_text": "Iter->getTextLength()",
          "new_text": null,
          "old_line_content": "      CommentLength += Iter->getTextLength();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2346,
          "old_api": "setAtStartOfLine",
          "new_api": null,
          "old_text": "NextToken.setAtStartOfLine(false)",
          "new_text": null,
          "old_line_content": "    NextToken.setAtStartOfLine(false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": "static_cast<size_t>(CurPtr - TokStart)",
          "new_api": null,
          "old_text": "static_cast<size_t>(CurPtr - TokStart)",
          "new_text": null,
          "old_line_content": "  StringRef TokenText { TokStart, static_cast<size_t>(CurPtr - TokStart) };",
          "new_line_content": "  if (TriviaRetention == TriviaRetentionMode::WithTrivia) {",
          "content_same": false
        },
        {
          "line": 2349,
          "old_api": "lexTrivia",
          "new_api": null,
          "old_text": "lexTrivia(LeadingTrivia, /* IsForTrailingTrivia */ false)",
          "new_text": null,
          "old_line_content": "  lexTrivia(LeadingTrivia, /* IsForTrailingTrivia */ false);",
          "new_line_content": "  // Remember the start of the token so we can form the text range.",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": "lexTrivia",
          "new_api": null,
          "old_text": "lexTrivia(TrailingTrivia, /* IsForTrailingTrivia */ true)",
          "new_text": null,
          "old_line_content": "    lexTrivia(TrailingTrivia, /* IsForTrailingTrivia */ true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": "setToken",
          "new_api": null,
          "old_text": "NextToken.setToken(Kind, TokenText, CommentLength)",
          "new_text": null,
          "old_line_content": "  NextToken.setToken(Kind, TokenText, CommentLength);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2357,
          "old_api": "advanceIfValidStartOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidStartOfIdentifier(Tmp, BufferEnd)",
          "new_text": null,
          "old_line_content": "    if (advanceIfValidStartOfIdentifier(Tmp, BufferEnd))",
          "new_line_content": "    ",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(TokStart[0] == '`' && \"escaped identifier starts with backtick\")",
          "new_text": null,
          "old_line_content": "  assert(TokStart[0] == '`' && \"escaped identifier starts with backtick\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2360,
          "old_api": "advanceIfValidStartOfOperator",
          "new_api": null,
          "old_text": "advanceIfValidStartOfOperator(Tmp, BufferEnd)",
          "new_text": null,
          "old_line_content": "    if (advanceIfValidStartOfOperator(Tmp, BufferEnd))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2363,
          "old_api": "lexUnknown",
          "new_api": null,
          "old_text": "lexUnknown(/*EmitDiagnosticsIfToken=*/true)",
          "new_text": null,
          "old_line_content": "    bool ShouldTokenize = lexUnknown(/*EmitDiagnosticsIfToken=*/true);",
          "new_line_content": "        ShouldTokenize &&",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": "empty",
          "new_api": null,
          "old_text": "TrailingTrivia.empty()",
          "new_text": null,
          "old_line_content": "  assert(TrailingTrivia.empty() && \"TrailingTrivia is empty here\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2364,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(\n        ShouldTokenize &&\n        \"Invalid UTF-8 sequence should be eaten by lexTrivia as LeadingTrivia\")",
          "new_text": null,
          "old_line_content": "    assert(",
          "new_line_content": "        \"Invalid UTF-8 sequence should be eaten by lexTrivia as LeadingTrivia\");",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::identifier, TokStart)",
          "new_text": null,
          "old_line_content": "  formToken(tok::identifier, TokStart);",
          "new_line_content": "  // this as escaped-identifier in this case.",
          "content_same": false
        },
        {
          "line": 2368,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::unknown, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": "setEscapedIdentifier",
          "new_api": null,
          "old_text": "NextToken.setEscapedIdentifier(true)",
          "new_text": null,
          "old_line_content": "  NextToken.setEscapedIdentifier(true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2373,
          "old_api": "llvm_unreachable",
          "new_api": null,
          "old_text": "llvm_unreachable(\"Newlines should be eaten by lexTrivia as LeadingTrivia\")",
          "new_text": null,
          "old_line_content": "    llvm_unreachable(\"Newlines should be eaten by lexTrivia as LeadingTrivia\");",
          "new_line_content": "  case ' ':",
          "content_same": false
        },
        {
          "line": 2379,
          "old_api": "llvm_unreachable",
          "new_api": null,
          "old_text": "llvm_unreachable(\n        \"Whitespaces should be eaten by lexTrivia as LeadingTrivia\")",
          "new_text": null,
          "old_line_content": "    llvm_unreachable(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 332,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::string_literal, TokStart)",
          "new_text": null,
          "old_line_content": "  formToken(tok::string_literal, TokStart);",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 335,
          "old_api": "setStringLiteral",
          "new_api": null,
          "old_text": "NextToken.setStringLiteral(IsMultilineString, CustomDelimiterLen)",
          "new_text": null,
          "old_line_content": "  NextToken.setStringLiteral(IsMultilineString, CustomDelimiterLen);",
          "new_line_content": "  if (IsMultilineString && Diags)",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": "validateMultilineIndents",
          "new_api": null,
          "old_text": "validateMultilineIndents(NextToken, Diags)",
          "new_text": null,
          "old_line_content": "    validateMultilineIndents(NextToken, Diags);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2386,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::unknown, TokStart);",
          "new_line_content": "  case 0:",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": "getBufferPtrForSourceLoc",
          "new_api": null,
          "old_text": "getBufferPtrForSourceLoc(Loc)",
          "new_text": null,
          "old_line_content": "  const char *Ptr = getBufferPtrForSourceLoc(Loc);",
          "new_line_content": "  // correctly lex the token if it is at the beginning of the line.",
          "content_same": false
        },
        {
          "line": 2391,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::code_complete, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::code_complete, TokStart);",
          "new_line_content": "    case NulCharacterKind::BufferEnd:",
          "content_same": false
        },
        {
          "line": 2398,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::eof, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::eof, TokStart);",
          "new_line_content": "    case NulCharacterKind::Embedded:",
          "content_same": false
        },
        {
          "line": 2401,
          "old_api": "llvm_unreachable",
          "new_api": null,
          "old_text": "llvm_unreachable(\n          \"Embedded nul should be eaten by lexTrivia as LeadingTrivia\")",
          "new_text": null,
          "old_line_content": "      llvm_unreachable(",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2410,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::r_square, TokStart)",
          "new_text": null,
          "old_line_content": "  case ']': return formToken(tok::r_square, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": "llvm::SMLoc::getFromPointer(Ptr)",
          "new_api": null,
          "old_text": "llvm::SMLoc::getFromPointer(Ptr)",
          "new_text": null,
          "old_line_content": "  return State(SourceLoc(llvm::SMLoc::getFromPointer(Ptr)));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2415,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::colon, TokStart)",
          "new_text": null,
          "old_line_content": "  case ':': return formToken(tok::colon, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2416,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::backslash, TokStart)",
          "new_text": null,
          "old_line_content": "  case '\\\\': return formToken(tok::backslash, TokStart);",
          "new_line_content": "  case '#':",
          "content_same": false
        },
        {
          "line": 2420,
          "old_api": "lexStringLiteral",
          "new_api": null,
          "old_text": "lexStringLiteral(CustomDelimiterLen)",
          "new_text": null,
          "old_line_content": "      return lexStringLiteral(CustomDelimiterLen);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 373,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(Ptr && \"invalid source location\")",
          "new_text": null,
          "old_line_content": "  assert(Ptr && \"invalid source location\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(*Ptr == '\\0' && \"not an embedded null\")",
          "new_text": null,
          "old_line_content": "  assert(*Ptr == '\\0' && \"not an embedded null\");",
          "new_line_content": "  if (!Diags)",
          "content_same": false
        },
        {
          "line": 2421,
          "old_api": "lexHash",
          "new_api": null,
          "old_text": "lexHash()",
          "new_text": null,
          "old_line_content": "    return lexHash();",
          "new_line_content": "      // Operator characters.",
          "content_same": false
        },
        {
          "line": 2426,
          "old_api": "skipSlashSlashComment",
          "new_api": null,
          "old_text": "skipSlashSlashComment(/*EatNewline=*/true)",
          "new_text": null,
          "old_line_content": "      skipSlashSlashComment(/*EatNewline=*/true);",
          "new_line_content": "             \"Non token comment should be eaten by lexTrivia as LeadingTrivia\");",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": "Lexer::getSourceLoc(Ptr+1)",
          "new_api": null,
          "old_text": "Lexer::getSourceLoc(Ptr+1)",
          "new_text": null,
          "old_line_content": "  SourceLoc NulEndLoc = Lexer::getSourceLoc(Ptr+1);",
          "new_line_content": "      .fixItRemoveChars(NulLoc, NulEndLoc);",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": "fixItRemoveChars",
          "new_api": null,
          "old_text": "Diags->diagnose(NulLoc, diag::lex_nul_character)\n      .fixItRemoveChars(NulLoc, NulEndLoc)",
          "new_text": null,
          "old_line_content": "  Diags->diagnose(NulLoc, diag::lex_nul_character)",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2429,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::comment, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::comment, TokStart);",
          "new_line_content": "    if (CurPtr[0] == '*') { // \"/*\"",
          "content_same": false
        },
        {
          "line": 2432,
          "old_api": "skipSlashStarComment",
          "new_api": null,
          "old_text": "skipSlashStarComment()",
          "new_text": null,
          "old_line_content": "      skipSlashStarComment();",
          "new_line_content": "             \"Non token comment should be eaten by lexTrivia as LeadingTrivia\");",
          "content_same": false
        },
        {
          "line": 2437,
          "old_api": "lexOperatorIdentifier",
          "new_api": null,
          "old_text": "lexOperatorIdentifier()",
          "new_text": null,
          "old_line_content": "    return lexOperatorIdentifier();",
          "new_line_content": "    // Lex %[0-9a-zA-Z_]+ as a local SIL value",
          "content_same": false
        },
        {
          "line": 2440,
          "old_api": "clang::isIdentifierBody(CurPtr[0])",
          "new_api": null,
          "old_text": "clang::isIdentifierBody(CurPtr[0])",
          "new_text": null,
          "old_line_content": "    if (InSILBody && clang::isIdentifierBody(CurPtr[0])) {",
          "new_line_content": "        ++CurPtr;",
          "content_same": false
        },
        {
          "line": 2447,
          "old_api": "lexOperatorIdentifier",
          "new_api": null,
          "old_text": "lexOperatorIdentifier()",
          "new_text": null,
          "old_line_content": "    return lexOperatorIdentifier();",
          "new_line_content": "  case '!':",
          "content_same": false
        },
        {
          "line": 401,
          "old_api": "validateUTF8CharacterAndAdvance",
          "new_api": null,
          "old_text": "validateUTF8CharacterAndAdvance(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "        if (validateUTF8CharacterAndAdvance(CurPtr, BufferEnd) == ~0U)",
          "new_line_content": "                          diag::lex_invalid_utf8);",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": "Lexer::getSourceLoc(CharStart)",
          "new_api": null,
          "old_text": "Lexer::getSourceLoc(CharStart)",
          "new_text": null,
          "old_line_content": "          Diags->diagnose(Lexer::getSourceLoc(CharStart),",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2453,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::exclaim_postfix, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::exclaim_postfix, TokStart);",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 2454,
          "old_api": "lexOperatorIdentifier",
          "new_api": null,
          "old_text": "lexOperatorIdentifier()",
          "new_text": null,
          "old_line_content": "    return lexOperatorIdentifier();",
          "new_line_content": "  case '?':",
          "content_same": false
        },
        {
          "line": 2458,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::question_postfix, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::question_postfix, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 411,
          "old_api": "diagnoseEmbeddedNul",
          "new_api": null,
          "old_text": "diagnoseEmbeddedNul(Diags, CurPtr - 1)",
          "new_text": null,
          "old_line_content": "          diagnoseEmbeddedNul(Diags, CurPtr - 1);",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 2459,
          "old_api": "lexOperatorIdentifier",
          "new_api": null,
          "old_text": "lexOperatorIdentifier()",
          "new_text": null,
          "old_line_content": "    return lexOperatorIdentifier();",
          "new_line_content": "  case '<':",
          "content_same": false
        },
        {
          "line": 2467,
          "old_api": "lexOperatorIdentifier",
          "new_api": null,
          "old_text": "lexOperatorIdentifier()",
          "new_text": null,
          "old_line_content": "    return lexOperatorIdentifier();",
          "new_line_content": "  case '=': case '-': case '+': case '*':",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": "advanceToEndOfLine",
          "new_api": null,
          "old_text": "advanceToEndOfLine(CurPtr, BufferEnd, CodeCompletionPtr, Diags)",
          "new_text": null,
          "old_line_content": "  bool isEOL = advanceToEndOfLine(CurPtr, BufferEnd, CodeCompletionPtr, Diags);",
          "new_line_content": "    ++CurPtr;",
          "content_same": false
        },
        {
          "line": 2471,
          "old_api": "lexOperatorIdentifier",
          "new_api": null,
          "old_text": "lexOperatorIdentifier()",
          "new_text": null,
          "old_line_content": "    return lexOperatorIdentifier();",
          "new_line_content": "  case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G':",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": "setAtStartOfLine",
          "new_api": null,
          "old_text": "NextToken.setAtStartOfLine(true)",
          "new_text": null,
          "old_line_content": "    NextToken.setAtStartOfLine(true);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 431,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(CurPtr[-1] == '/' && CurPtr[0] == '/' && \"Not a // comment\")",
          "new_text": null,
          "old_line_content": "  assert(CurPtr[-1] == '/' && CurPtr[0] == '/' && \"Not a // comment\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 432,
          "old_api": "skipToEndOfLine",
          "new_api": null,
          "old_text": "skipToEndOfLine(EatNewline)",
          "new_text": null,
          "old_line_content": "  skipToEndOfLine(EatNewline);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2482,
          "old_api": "lexIdentifier",
          "new_api": null,
          "old_text": "lexIdentifier()",
          "new_text": null,
          "old_line_content": "    return lexIdentifier();",
          "new_line_content": "  case '$':",
          "content_same": false
        },
        {
          "line": 2485,
          "old_api": "lexDollarIdent",
          "new_api": null,
          "old_text": "lexDollarIdent()",
          "new_text": null,
          "old_line_content": "    return lexDollarIdent();",
          "new_line_content": "  case '0': case '1': case '2': case '3': case '4':",
          "content_same": false
        },
        {
          "line": 438,
          "old_api": "skipToEndOfLine",
          "new_api": null,
          "old_text": "skipToEndOfLine(EatNewline)",
          "new_text": null,
          "old_line_content": "  skipToEndOfLine(EatNewline);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2489,
          "old_api": "lexNumber",
          "new_api": null,
          "old_text": "lexNumber()",
          "new_text": null,
          "old_line_content": "    return lexNumber();",
          "new_line_content": "  case '\"':",
          "content_same": false
        },
        {
          "line": 2493,
          "old_api": "lexStringLiteral",
          "new_api": null,
          "old_text": "lexStringLiteral()",
          "new_text": null,
          "old_line_content": "    return lexStringLiteral();",
          "new_line_content": "  case '`':",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(CurPtr[-1] == '/' && CurPtr[0] == '*' && \"Not a /* comment\")",
          "new_text": null,
          "old_line_content": "  assert(CurPtr[-1] == '/' && CurPtr[0] == '*' && \"Not a /* comment\");",
          "new_line_content": "  // the beginning and end of the comment.",
          "content_same": false
        },
        {
          "line": 2496,
          "old_api": "lexEscapedIdentifier",
          "new_api": null,
          "old_text": "lexEscapedIdentifier()",
          "new_text": null,
          "old_line_content": "    return lexEscapedIdentifier();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2502,
          "old_api": "isValid",
          "new_api": null,
          "old_text": "Loc.isValid()",
          "new_text": null,
          "old_line_content": "  if (!Loc.isValid())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2503,
          "old_api": "Token",
          "new_api": null,
          "old_text": "Token()",
          "new_text": null,
          "old_line_content": "    return Token();",
          "new_line_content": "  // Figure out which buffer contains this location.",
          "content_same": false
        },
        {
          "line": 2508,
          "old_api": "Token",
          "new_api": null,
          "old_text": "Token()",
          "new_text": null,
          "old_line_content": "    return Token();",
          "new_line_content": "  // Use fake language options; language options only affect validity",
          "content_same": false
        },
        {
          "line": 2520,
          "old_api": "State",
          "new_api": null,
          "old_text": "State(Loc)",
          "new_text": null,
          "old_line_content": "  L.restoreState(State(Loc));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2521,
          "old_api": "peekNextToken",
          "new_api": null,
          "old_text": "L.peekNextToken()",
          "new_text": null,
          "old_line_content": "  return L.peekNextToken();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": "validateUTF8CharacterAndAdvance",
          "new_api": null,
          "old_text": "validateUTF8CharacterAndAdvance(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "        if (validateUTF8CharacterAndAdvance(CurPtr, BufferEnd) == ~0U)",
          "new_line_content": "                          diag::lex_invalid_utf8);",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": "Lexer::getSourceLoc(CharStart)",
          "new_api": null,
          "old_text": "Lexer::getSourceLoc(CharStart)",
          "new_text": null,
          "old_line_content": "          Diags->diagnose(Lexer::getSourceLoc(CharStart),",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2532,
          "old_api": "setAtStartOfLine",
          "new_api": null,
          "old_text": "NextToken.setAtStartOfLine(true)",
          "new_text": null,
          "old_line_content": "    NextToken.setAtStartOfLine(true);",
          "new_line_content": "    goto Restart;",
          "content_same": false
        },
        {
          "line": 2533,
          "old_api": "TriviaPiece::newlines(1)",
          "new_api": null,
          "old_text": "TriviaPiece::newlines(1)",
          "new_text": null,
          "old_line_content": "    Pieces.appendOrSquash(TriviaPiece::newlines(1));",
          "new_line_content": "  case '\\r':",
          "content_same": false
        },
        {
          "line": 2540,
          "old_api": "TriviaPiece::carriageReturnLineFeeds(1)",
          "new_api": null,
          "old_text": "TriviaPiece::carriageReturnLineFeeds(1)",
          "new_text": null,
          "old_line_content": "      Pieces.appendOrSquash(TriviaPiece::carriageReturnLineFeeds(1));",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": "diagnoseEmbeddedNul",
          "new_api": null,
          "old_text": "diagnoseEmbeddedNul(Diags, CurPtr - 1)",
          "new_text": null,
          "old_line_content": "          diagnoseEmbeddedNul(Diags, CurPtr - 1);",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 2543,
          "old_api": "TriviaPiece::carriageReturns(1)",
          "new_api": null,
          "old_text": "TriviaPiece::carriageReturns(1)",
          "new_text": null,
          "old_line_content": "      Pieces.appendOrSquash(TriviaPiece::carriageReturns(1));",
          "new_line_content": "    goto Restart;",
          "content_same": false
        },
        {
          "line": 2547,
          "old_api": "TriviaPiece::spaces(1)",
          "new_api": null,
          "old_text": "TriviaPiece::spaces(1)",
          "new_text": null,
          "old_line_content": "    Pieces.appendOrSquash(TriviaPiece::spaces(1));",
          "new_line_content": "  case '\\t':",
          "content_same": false
        },
        {
          "line": 2550,
          "old_api": "TriviaPiece::tabs(1)",
          "new_api": null,
          "old_text": "TriviaPiece::tabs(1)",
          "new_text": null,
          "old_line_content": "    Pieces.appendOrSquash(TriviaPiece::tabs(1));",
          "new_line_content": "  case '\\v':",
          "content_same": false
        },
        {
          "line": 2553,
          "old_api": "TriviaPiece::verticalTabs(1)",
          "new_api": null,
          "old_text": "TriviaPiece::verticalTabs(1)",
          "new_text": null,
          "old_line_content": "    Pieces.appendOrSquash(TriviaPiece::verticalTabs(1));",
          "new_line_content": "  case '\\f':",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": "fixItInsert",
          "new_api": null,
          "old_text": "Diags\n            ->diagnose(Lexer::getSourceLoc(EOL),\n                       diag::lex_unterminated_block_comment)\n            .fixItInsert(Lexer::getSourceLoc(EOL), Terminator)",
          "new_text": null,
          "old_line_content": "        Diags",
          "new_line_content": "                       diag::lex_unterminated_block_comment)",
          "content_same": false
        },
        {
          "line": 2556,
          "old_api": "TriviaPiece::formfeeds(1)",
          "new_api": null,
          "old_text": "TriviaPiece::formfeeds(1)",
          "new_text": null,
          "old_line_content": "    Pieces.appendOrSquash(TriviaPiece::formfeeds(1));",
          "new_line_content": "  case '/':",
          "content_same": false
        },
        {
          "line": 510,
          "old_api": "Lexer::getSourceLoc(EOL)",
          "new_api": null,
          "old_text": "Lexer::getSourceLoc(EOL)",
          "new_text": null,
          "old_line_content": "            .fixItInsert(Lexer::getSourceLoc(EOL), Terminator);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2559,
          "old_api": "isKeepingComments",
          "new_api": null,
          "old_text": "isKeepingComments()",
          "new_text": null,
          "old_line_content": "    if (IsForTrailingTrivia || isKeepingComments()) {",
          "new_line_content": "      // Don't try to lex comments here if we are lexing comments as Tokens.",
          "content_same": false
        },
        {
          "line": 511,
          "old_api": "Lexer::getSourceLoc(StartPtr)",
          "new_api": null,
          "old_text": "Lexer::getSourceLoc(StartPtr)",
          "new_text": null,
          "old_line_content": "        Diags->diagnose(Lexer::getSourceLoc(StartPtr), diag::lex_comment_start);",
          "new_line_content": "      return isMultiline;",
          "content_same": false
        },
        {
          "line": 2569,
          "old_api": "TriviaPiece::docLineComment(Text)",
          "new_api": null,
          "old_text": "TriviaPiece::docLineComment(Text)",
          "new_text": null,
          "old_line_content": "      Pieces.push_back(isDocComment ? TriviaPiece::docLineComment(Text)",
          "new_line_content": "      goto Restart;",
          "content_same": false
        },
        {
          "line": 2570,
          "old_api": "TriviaPiece::lineComment(Text)",
          "new_api": null,
          "old_text": "TriviaPiece::lineComment(Text)",
          "new_text": null,
          "old_line_content": "                                    : TriviaPiece::lineComment(Text));",
          "new_line_content": "    } else if (*CurPtr == '*') {",
          "content_same": false
        },
        {
          "line": 524,
          "old_api": "setAtStartOfLine",
          "new_api": null,
          "old_text": "NextToken.setAtStartOfLine(true)",
          "new_text": null,
          "old_line_content": "    NextToken.setAtStartOfLine(true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": "clang::isIdentifierBody(c, /*dollar*/true)",
          "new_api": null,
          "old_text": "clang::isIdentifierBody(c, /*dollar*/true)",
          "new_text": null,
          "old_line_content": "    return clang::isIdentifierBody(c, /*dollar*/true);",
          "new_line_content": "  // N1518: Recommendations for extended identifier characters for C and C++",
          "content_same": false
        },
        {
          "line": 2578,
          "old_api": "TriviaPiece::docBlockComment(Text)",
          "new_api": null,
          "old_text": "TriviaPiece::docBlockComment(Text)",
          "new_text": null,
          "old_line_content": "      Pieces.push_back(isDocComment ? TriviaPiece::docBlockComment(Text)",
          "new_line_content": "      goto Restart;",
          "content_same": false
        },
        {
          "line": 2579,
          "old_api": "TriviaPiece::blockComment(Text)",
          "new_api": null,
          "old_text": "TriviaPiece::blockComment(Text)",
          "new_text": null,
          "old_line_content": "                                    : TriviaPiece::blockComment(Text));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2588,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(TriviaStart, diag::lex_hashbang_not_allowed)",
          "new_text": null,
          "old_line_content": "        diagnose(TriviaStart, diag::lex_hashbang_not_allowed);",
          "new_line_content": "      size_t Length = CurPtr - TriviaStart;",
          "content_same": false
        },
        {
          "line": 2591,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(TriviaStart, Length)",
          "new_text": null,
          "old_line_content": "      auto Text = OwnedString::makeRefCounted(StringRef(TriviaStart, Length));",
          "new_line_content": "      goto Restart;",
          "content_same": false
        },
        {
          "line": 2592,
          "old_api": "TriviaPiece::garbageText(Text)",
          "new_api": null,
          "old_text": "TriviaPiece::garbageText(Text)",
          "new_text": null,
          "old_line_content": "      Pieces.push_back(TriviaPiece::garbageText(Text));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2598,
          "old_api": "tryLexConflictMarker",
          "new_api": null,
          "old_text": "tryLexConflictMarker(/*EatNewline=*/false)",
          "new_text": null,
          "old_line_content": "    if (tryLexConflictMarker(/*EatNewline=*/false)) {",
          "new_line_content": "      size_t Length = CurPtr - TriviaStart;",
          "content_same": false
        },
        {
          "line": 2601,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(TriviaStart, Length)",
          "new_text": null,
          "old_line_content": "      auto Text = OwnedString::makeRefCounted(StringRef(TriviaStart, Length));",
          "new_line_content": "      goto Restart;",
          "content_same": false
        },
        {
          "line": 2602,
          "old_api": "TriviaPiece::garbageText(Text)",
          "new_api": null,
          "old_text": "TriviaPiece::garbageText(Text)",
          "new_text": null,
          "old_line_content": "      Pieces.push_back(TriviaPiece::garbageText(Text));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2611,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(TriviaStart, Length)",
          "new_text": null,
          "old_line_content": "      auto Text = OwnedString::makeRefCounted(StringRef(TriviaStart, Length));",
          "new_line_content": "      goto Restart;",
          "content_same": false
        },
        {
          "line": 2612,
          "old_api": "TriviaPiece::garbageText(Text)",
          "new_api": null,
          "old_text": "TriviaPiece::garbageText(Text)",
          "new_text": null,
          "old_line_content": "      Pieces.push_back(TriviaPiece::garbageText(Text));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": "isDigit",
          "new_api": null,
          "old_text": "isDigit(c)",
          "new_text": null,
          "old_line_content": "  if (c < 0x80 && (isDigit(c) || c == '$'))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2644,
          "old_api": "advanceIfValidStartOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidStartOfIdentifier(Tmp, BufferEnd)",
          "new_text": null,
          "old_line_content": "    if (advanceIfValidStartOfIdentifier(Tmp, BufferEnd)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2647,
          "old_api": "advanceIfValidStartOfOperator",
          "new_api": null,
          "old_text": "advanceIfValidStartOfOperator(Tmp, BufferEnd)",
          "new_text": null,
          "old_line_content": "    if (advanceIfValidStartOfOperator(Tmp, BufferEnd)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 600,
          "old_api": "validateUTF8CharacterAndAdvance",
          "new_api": null,
          "old_text": "validateUTF8CharacterAndAdvance(next, end)",
          "new_text": null,
          "old_line_content": "  uint32_t c = validateUTF8CharacterAndAdvance(next, end);",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": "predicate",
          "new_api": null,
          "old_text": "predicate(c)",
          "new_text": null,
          "old_line_content": "  if (predicate(c)) {",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 2651,
          "old_api": "lexUnknown",
          "new_api": null,
          "old_text": "lexUnknown(/*EmitDiagnosticsIfToken=*/false)",
          "new_text": null,
          "old_line_content": "    bool ShouldTokenize = lexUnknown(/*EmitDiagnosticsIfToken=*/false);",
          "new_line_content": "      CurPtr = Tmp;",
          "content_same": false
        },
        {
          "line": 2658,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(TriviaStart, Length)",
          "new_text": null,
          "old_line_content": "    auto Text = OwnedString::makeRefCounted(StringRef(TriviaStart, Length));",
          "new_line_content": "    goto Restart;",
          "content_same": false
        },
        {
          "line": 2659,
          "old_api": "TriviaPiece::garbageText(Text)",
          "new_api": null,
          "old_text": "TriviaPiece::garbageText(Text)",
          "new_text": null,
          "old_line_content": "    Pieces.push_back(TriviaPiece::garbageText(Text));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": "advanceIf",
          "new_api": null,
          "old_text": "advanceIf(ptr, end, isValidIdentifierStartCodePoint)",
          "new_text": null,
          "old_line_content": "  return advanceIf(ptr, end, isValidIdentifierStartCodePoint);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": "advanceIf",
          "new_api": null,
          "old_text": "advanceIf(ptr, end, isValidIdentifierContinuationCodePoint)",
          "new_text": null,
          "old_line_content": "  return advanceIf(ptr, end, isValidIdentifierContinuationCodePoint);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2667,
          "old_api": "getLength",
          "new_api": null,
          "old_text": "getTokenAtLocation(SM, Loc).getLength()",
          "new_text": null,
          "old_line_content": "  return Loc.getAdvancedLocOrInvalid(getTokenAtLocation(SM, Loc).getLength());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 623,
          "old_api": "advanceIf",
          "new_api": null,
          "old_text": "advanceIf(ptr, end, Identifier::isOperatorStartCodePoint)",
          "new_text": null,
          "old_line_content": "  return advanceIf(ptr, end, Identifier::isOperatorStartCodePoint);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": "advanceIf",
          "new_api": null,
          "old_text": "advanceIf(ptr, end, Identifier::isOperatorContinuationCodePoint)",
          "new_text": null,
          "old_line_content": "  return advanceIf(ptr, end, Identifier::isOperatorContinuationCodePoint);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": "end",
          "new_api": null,
          "old_text": "string.end()",
          "new_text": null,
          "old_line_content": "  char const *p = string.data(), *end = string.end();",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(p, end)",
          "new_text": null,
          "old_line_content": "  while (p < end && advanceIfValidContinuationOfIdentifier(p, end));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2689,
          "old_api": "getLoc",
          "new_api": null,
          "old_text": "Tok.getLoc()",
          "new_text": null,
          "old_line_content": "    unsigned TokOffs = SM.getLocOffsetInBuffer(Tok.getLoc(), BufferID);",
          "new_line_content": "      // We ended up skipping over the source location entirely, which means",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": "end",
          "new_api": null,
          "old_text": "string.end()",
          "new_text": null,
          "old_line_content": "  char const *p = string.data(), *end = string.end();",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": "advanceIfValidContinuationOfOperator",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfOperator(p, end)",
          "new_text": null,
          "old_line_content": "  while (p < end && advanceIfValidContinuationOfOperator(p, end));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2696,
          "old_api": "getLength",
          "new_api": null,
          "old_text": "Tok.getLength()",
          "new_text": null,
          "old_line_content": "    if (Offset < TokOffs+Tok.getLength()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2703,
          "old_api": "getLocOffsetInBuffer",
          "new_api": null,
          "old_text": "SM.getLocOffsetInBuffer(Seg.Loc, BufferID)",
          "new_text": null,
          "old_line_content": "          unsigned SegOffs = SM.getLocOffsetInBuffer(Seg.Loc, BufferID);",
          "new_line_content": "          if (SegOffs > Offset)",
          "content_same": false
        },
        {
          "line": 2710,
          "old_api": "getLocForStartOfTokenInBuf",
          "new_api": null,
          "old_text": "getLocForStartOfTokenInBuf(SM, BufferID, Offset,\n                                              /*BufferStart=*/SegOffs,\n                                              /*BufferEnd=*/SegEnd)",
          "new_text": null,
          "old_line_content": "            return getLocForStartOfTokenInBuf(SM, BufferID, Offset,",
          "new_line_content": "                                              /*BufferEnd=*/SegEnd);",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": "advanceIfValidStartOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidStartOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "  bool didStart = advanceIfValidStartOfIdentifier(CurPtr, BufferEnd);",
          "new_line_content": "  (void) didStart;",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(didStart && \"Unexpected start\")",
          "new_text": null,
          "old_line_content": "  assert(didStart && \"Unexpected start\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2718,
          "old_api": "isNot",
          "new_api": null,
          "old_text": "Tok.isNot(tok::eof)",
          "new_text": null,
          "old_line_content": "  } while (Tok.isNot(tok::eof));",
          "new_line_content": "  // We've passed our source location; just return the original source location.",
          "content_same": false
        },
        {
          "line": 2721,
          "old_api": "getLocForOffset",
          "new_api": null,
          "old_text": "SM.getLocForOffset(BufferID, Offset)",
          "new_text": null,
          "old_line_content": "  return SM.getLocForOffset(BufferID, Offset);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(TokStart, CurPtr-TokStart)",
          "new_text": null,
          "old_line_content": "  tok Kind = kindOfIdentifier(StringRef(TokStart, CurPtr-TokStart), InSILMode);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(Kind, TokStart)",
          "new_text": null,
          "old_line_content": "  return formToken(Kind, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": "clang::isIdentifierHead(*tmpPtr)",
          "new_api": null,
          "old_text": "clang::isIdentifierHead(*tmpPtr)",
          "new_text": null,
          "old_line_content": "  if (clang::isIdentifierHead(*tmpPtr)) {",
          "new_line_content": "      ++tmpPtr;",
          "content_same": false
        },
        {
          "line": 689,
          "old_api": "clang::isIdentifierBody(*tmpPtr)",
          "new_api": null,
          "old_text": "clang::isIdentifierBody(*tmpPtr)",
          "new_text": null,
          "old_line_content": "    } while (clang::isIdentifierBody(*tmpPtr));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(CurPtr, tmpPtr-CurPtr)",
          "new_text": null,
          "old_line_content": "  tok Kind = llvm::StringSwitch<tok>(StringRef(CurPtr, tmpPtr-CurPtr))",
          "new_line_content": "  .Case(#id, tok::pound_##id)",
          "content_same": false
        },
        {
          "line": 2742,
          "old_api": "getLocOffsetInBuffer",
          "new_api": null,
          "old_text": "getLocForStartOfToken(SM, BufferId,\n                               SM.getLocOffsetInBuffer(Loc, BufferId))",
          "new_text": null,
          "old_line_content": "  return getLocForStartOfToken(SM, BufferId,",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2743,
          "old_api": "getLocOffsetInBuffer",
          "new_api": null,
          "old_text": "SM.getLocOffsetInBuffer(Loc, BufferId)",
          "new_text": null,
          "old_line_content": "                               SM.getLocOffsetInBuffer(Loc, BufferId));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 697,
          "old_api": "Default",
          "new_api": null,
          "old_text": "  .Default(tok::pound)",
          "new_text": null,
          "old_line_content": "  .Default(tok::pound);",
          "new_line_content": "  // If we didn't find a match, then just return tok::pound.  This is highly",
          "content_same": false
        },
        {
          "line": 2748,
          "old_api": "getRangeForBuffer",
          "new_api": null,
          "old_text": "SM.getRangeForBuffer(BufferID)",
          "new_text": null,
          "old_line_content": "  CharSourceRange entireRange = SM.getRangeForBuffer(BufferID);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 703,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::pound, TokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::pound, TokStart);",
          "new_line_content": "  // If we found something specific, return it.",
          "content_same": false
        },
        {
          "line": 2752,
          "old_api": "size",
          "new_api": null,
          "old_text": "Buffer.size()",
          "new_text": null,
          "old_line_content": "  if (Offset > Buffer.size())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2753,
          "old_api": "SourceLoc",
          "new_api": null,
          "old_text": "SourceLoc()",
          "new_text": null,
          "old_line_content": "    return SourceLoc();",
          "new_line_content": "  const char *StrData = BufStart+Offset;",
          "content_same": false
        },
        {
          "line": 707,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(Kind, TokStart)",
          "new_text": null,
          "old_line_content": "  return formToken(Kind, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2759,
          "old_api": "getLocForOffset",
          "new_api": null,
          "old_text": "SM.getLocForOffset(BufferID, Offset)",
          "new_text": null,
          "old_line_content": "    return SM.getLocForOffset(BufferID, Offset);",
          "new_line_content": "  // Back up from the current location until we hit the beginning of a line",
          "content_same": false
        },
        {
          "line": 2767,
          "old_api": "size",
          "new_api": null,
          "old_text": "Buffer.size()",
          "new_text": null,
          "old_line_content": "                                    /*BufferEnd=*/Buffer.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2772,
          "old_api": "isInvalid",
          "new_api": null,
          "old_text": "Loc.isInvalid()",
          "new_text": null,
          "old_line_content": "  if (Loc.isInvalid())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2780,
          "old_api": "getRangeForBuffer",
          "new_api": null,
          "old_text": "SM.getRangeForBuffer(BufferID)",
          "new_text": null,
          "old_line_content": "  CharSourceRange entireRange = SM.getRangeForBuffer(BufferID);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2783,
          "old_api": "data",
          "new_api": null,
          "old_text": "Buffer.data()",
          "new_text": null,
          "old_line_content": "  const char *BufStart = Buffer.data();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2786,
          "old_api": "findStartOfLine",
          "new_api": null,
          "old_text": "findStartOfLine(BufStart, BufStart + Offset)",
          "new_text": null,
          "old_line_content": "  const char *StartOfLine = findStartOfLine(BufStart, BufStart + Offset);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2787,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(StartOfLine)",
          "new_text": null,
          "old_line_content": "  return getSourceLoc(StartOfLine);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2792,
          "old_api": "isInvalid",
          "new_api": null,
          "old_text": "Loc.isInvalid()",
          "new_text": null,
          "old_line_content": "  if (Loc.isInvalid())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2798,
          "old_api": "SourceLoc",
          "new_api": null,
          "old_text": "SourceLoc()",
          "new_text": null,
          "old_line_content": "    return SourceLoc();",
          "new_line_content": "  // Use fake language options; language options only affect validity",
          "content_same": false
        },
        {
          "line": 2811,
          "old_api": "skipToEndOfLine",
          "new_api": null,
          "old_text": "L.skipToEndOfLine(/*EatNewline=*/true)",
          "new_text": null,
          "old_line_content": "  L.skipToEndOfLine(/*EatNewline=*/true);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2812,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(L.CurPtr)",
          "new_text": null,
          "old_line_content": "  return getSourceLoc(L.CurPtr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2827,
          "old_api": "isInvalid",
          "new_api": null,
          "old_text": "Loc.isInvalid()",
          "new_text": null,
          "old_line_content": "  if (Loc.isInvalid())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2831,
          "old_api": "findBufferContainingLoc",
          "new_api": null,
          "old_text": "SM.findBufferContainingLoc(Loc)",
          "new_text": null,
          "old_line_content": "  int BufferID = SM.findBufferContainingLoc(Loc);",
          "new_line_content": "    return \"\";",
          "content_same": false
        },
        {
          "line": 2835,
          "old_api": "getRangeForBuffer",
          "new_api": null,
          "old_text": "SM.getRangeForBuffer(BufferID)",
          "new_text": null,
          "old_line_content": "  CharSourceRange entireRange = SM.getRangeForBuffer(BufferID);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2838,
          "old_api": "data",
          "new_api": null,
          "old_text": "Buffer.data()",
          "new_text": null,
          "old_line_content": "  const char *BufStart = Buffer.data();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2843,
          "old_api": "isHorizontalWhitespace",
          "new_api": null,
          "old_text": "isHorizontalWhitespace(*EndOfIndentation)",
          "new_text": null,
          "old_line_content": "  while (*EndOfIndentation && isHorizontalWhitespace(*EndOfIndentation))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": "advanceIfValidStartOfOperator",
          "new_api": null,
          "old_text": "advanceIfValidStartOfOperator(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "  bool didStart = advanceIfValidStartOfOperator(CurPtr, BufferEnd);",
          "new_line_content": "  (void) didStart;",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(didStart && \"unexpected operator start\")",
          "new_text": null,
          "old_line_content": "  assert(didStart && \"unexpected operator start\");",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 2846,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(StartOfLine, EndOfIndentation - StartOfLine)",
          "new_text": null,
          "old_line_content": "  return StringRef(StartOfLine, EndOfIndentation - StartOfLine);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2855,
          "old_api": "getLoc",
          "new_api": null,
          "old_text": "EndIt->getLoc()",
          "new_text": null,
          "old_line_content": "  assert(StartIt->getLoc() == StartLoc && EndIt->getLoc() == EndLoc);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2856,
          "old_api": "begin",
          "new_api": null,
          "old_text": "AllTokens.begin()",
          "new_text": null,
          "old_line_content": "  return AllTokens.slice(StartIt - AllTokens.begin(), EndIt - StartIt + 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(CurPtr, BufferEnd-CurPtr)",
          "new_text": null,
          "old_line_content": "    if (Identifier::isEditorPlaceholder(StringRef(CurPtr, BufferEnd-CurPtr)) &&",
          "new_line_content": "      break;",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": "rangeContainsPlaceholderEnd",
          "new_api": null,
          "old_text": "rangeContainsPlaceholderEnd(CurPtr + 2, BufferEnd)",
          "new_text": null,
          "old_line_content": "        rangeContainsPlaceholderEnd(CurPtr + 2, BufferEnd)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": "advanceIfValidContinuationOfOperator",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfOperator(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "  } while (advanceIfValidContinuationOfOperator(CurPtr, BufferEnd));",
          "new_line_content": "  if (CurPtr-TokStart > 2) {",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": "isLeftBound",
          "new_api": null,
          "old_text": "isLeftBound(TokStart, ContentStart)",
          "new_text": null,
          "old_line_content": "  bool leftBound = isLeftBound(TokStart, ContentStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": "isRightBound",
          "new_api": null,
          "old_text": "isRightBound(CurPtr, leftBound, CodeCompletionPtr)",
          "new_text": null,
          "old_line_content": "  bool rightBound = isRightBound(CurPtr, leftBound, CodeCompletionPtr);",
          "new_line_content": "  // Match various reserved words.",
          "content_same": false
        },
        {
          "line": 844,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(TokStart+1)",
          "new_text": null,
          "old_line_content": "          d.fixItInsert(getSourceLoc(TokStart+1), \" \");",
          "new_line_content": "      // always emit 'tok::equal' to avoid trickle down parse errors",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::equal, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::equal, TokStart);",
          "new_line_content": "      if (leftBound == rightBound || leftBound)",
          "content_same": false
        },
        {
          "line": 851,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::amp_prefix, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::amp_prefix, TokStart);",
          "new_line_content": "      if (leftBound == rightBound)",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::period_prefix, TokStart)",
          "new_text": null,
          "old_line_content": "        return formToken(tok::period_prefix, TokStart);",
          "new_line_content": "      // If left bound but not right bound, handle some likely situations.",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(TokStart, diag::expected_member_name)",
          "new_text": null,
          "old_line_content": "        diagnose(TokStart, diag::expected_member_name);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::period, TokStart)",
          "new_text": null,
          "old_line_content": "        return formToken(tok::period, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": "isRightBound",
          "new_api": null,
          "old_text": "isRightBound(AfterHorzWhitespace, leftBound, CodeCompletionPtr)",
          "new_text": null,
          "old_line_content": "      if (isRightBound(AfterHorzWhitespace, leftBound, CodeCompletionPtr) &&",
          "new_line_content": "          // either // or /* and most likely occurs just in our testsuite for",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(AfterHorzWhitespace)",
          "new_text": null,
          "old_line_content": "                            getSourceLoc(AfterHorzWhitespace));",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::period, TokStart)",
          "new_text": null,
          "old_line_content": "        return formToken(tok::period, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(TokStart, diag::expected_member_name)",
          "new_text": null,
          "old_line_content": "      diagnose(TokStart, diag::expected_member_name);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::unknown, TokStart);",
          "new_line_content": "    case '?':",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::question_postfix, TokStart)",
          "new_text": null,
          "old_line_content": "        return formToken(tok::question_postfix, TokStart);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::question_infix, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::question_infix, TokStart);",
          "new_line_content": "  } else if (CurPtr-TokStart == 2) {",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(TokStart, diag::lex_unexpected_block_comment_end)",
          "new_text": null,
          "old_line_content": "      diagnose(TokStart, diag::lex_unexpected_block_comment_end);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 900,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::unknown, TokStart);",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(TokStart+Pos, diag::lex_unexpected_block_comment_end)",
          "new_text": null,
          "old_line_content": "      diagnose(TokStart+Pos, diag::lex_unexpected_block_comment_end);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::unknown, TokStart);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(leftBound ? tok::oper_binary_unspaced :\n                                 tok::oper_binary_spaced, TokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(leftBound ? tok::oper_binary_unspaced :",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 916,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(leftBound ? tok::oper_postfix : tok::oper_prefix, TokStart)",
          "new_text": null,
          "old_line_content": "  return formToken(leftBound ? tok::oper_postfix : tok::oper_prefix, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(*tokStart == '$')",
          "new_text": null,
          "old_line_content": "  assert(*tokStart == '$');",
          "new_line_content": "  // In a SIL function body, '$' is a token by itself, except it's a SIL global",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": "getKind",
          "new_api": null,
          "old_text": "NextToken.getKind()",
          "new_text": null,
          "old_line_content": "  if (InSILBody && NextToken.getKind() != tok::at_sign)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::sil_dollar, tokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::sil_dollar, tokStart);",
          "new_line_content": "  bool isAllDigits = true;",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": "clang::isIdentifierHead(*CurPtr, /*dollar*/true)",
          "new_api": null,
          "old_text": "clang::isIdentifierHead(*CurPtr, /*dollar*/true)",
          "new_text": null,
          "old_line_content": "    } else if (clang::isIdentifierHead(*CurPtr, /*dollar*/true)) {",
          "new_line_content": "      // continue",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(CurPtr)",
          "new_text": null,
          "old_line_content": "      .fixItReplaceChars(getSourceLoc(tokStart), getSourceLoc(CurPtr), \"`$`\");",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::identifier, tokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::identifier, tokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(tokStart, diag::expected_dollar_numeric)",
          "new_text": null,
          "old_line_content": "      diagnose(tokStart, diag::expected_dollar_numeric);",
          "new_line_content": "    // Even if we diagnose, we go ahead and form an identifier token,",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::identifier, tokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::identifier, tokStart);",
          "new_line_content": "    if (LangOpts.EnableDollarIdentifiers && !LangOpts.Playground)",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::identifier, tokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::identifier, tokStart);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::dollarident, tokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::dollarident, tokStart);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(*TokStart == '0' && \"not a hex literal\")",
          "new_text": null,
          "old_line_content": "  assert(*TokStart == '0' && \"not a hex literal\");",
          "new_line_content": "  auto expected_digit = [&]() {",
          "content_same": false
        },
        {
          "line": 973,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "    while (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd));",
          "new_line_content": "  };",
          "content_same": false
        },
        {
          "line": 974,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::unknown, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": "expected_digit",
          "new_api": null,
          "old_text": "expected_digit()",
          "new_text": null,
          "old_line_content": "    return expected_digit();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": "isHexDigit",
          "new_api": null,
          "old_text": "isHexDigit(*CurPtr)",
          "new_text": null,
          "old_line_content": "  if (!isHexDigit(*CurPtr))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": "isHexDigit",
          "new_api": null,
          "old_text": "isHexDigit(*CurPtr)",
          "new_text": null,
          "old_line_content": "  while (isHexDigit(*CurPtr) || *CurPtr == '_')",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::integer_literal, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::integer_literal, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "new_line_content": "    ",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": "isHexDigit",
          "new_api": null,
          "old_text": "isHexDigit(*CurPtr)",
          "new_text": null,
          "old_line_content": "    while (isHexDigit(*CurPtr) || *CurPtr == '_')",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1017,
          "old_api": "isDigit",
          "new_api": null,
          "old_text": "isDigit(PtrOnDot[1])",
          "new_text": null,
          "old_line_content": "      if (!isDigit(PtrOnDot[1])) {",
          "new_line_content": "        CurPtr = PtrOnDot;",
          "content_same": false
        },
        {
          "line": 1022,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CurPtr, diag::lex_expected_binary_exponent_in_hex_float_literal)",
          "new_text": null,
          "old_line_content": "      diagnose(CurPtr, diag::lex_expected_binary_exponent_in_hex_float_literal);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::unknown, TokStart);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(*CurPtr == 'p' || *CurPtr == 'P' && \"not at a hex float exponent?!\")",
          "new_text": null,
          "old_line_content": "  assert(*CurPtr == 'p' || *CurPtr == 'P' && \"not at a hex float exponent?!\");",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": "isDigit",
          "new_api": null,
          "old_text": "isDigit(*CurPtr)",
          "new_text": null,
          "old_line_content": "  if (!isDigit(*CurPtr)) {",
          "new_line_content": "      // e.g: 0xff.fpValue, 0xff.fp",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": "isDigit",
          "new_api": null,
          "old_text": "isDigit(PtrOnDot[1])",
          "new_text": null,
          "old_line_content": "    if (PtrOnDot && !isDigit(PtrOnDot[1]) && !signedExponent) {",
          "new_line_content": "      CurPtr = PtrOnDot;",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::integer_literal, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "new_line_content": "    // Note: 0xff.fp+otherExpr can be valid expression. But we don't accept it.",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "new_line_content": "               *tmp == '_');",
          "content_same": false
        },
        {
          "line": 1050,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(tmp, 1)",
          "new_text": null,
          "old_line_content": "      diagnose(tmp, diag::lex_invalid_digit_in_fp_exponent, StringRef(tmp, 1),",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": "expected_digit",
          "new_api": null,
          "old_text": "expected_digit()",
          "new_text": null,
          "old_line_content": "    return expected_digit();",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": "isDigit",
          "new_api": null,
          "old_text": "isDigit(*CurPtr)",
          "new_text": null,
          "old_line_content": "  while (isDigit(*CurPtr) || *CurPtr == '_')",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "  if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)) {",
          "new_line_content": "             false);",
          "content_same": false
        },
        {
          "line": 1065,
          "old_api": "expected_digit",
          "new_api": null,
          "old_text": "expected_digit()",
          "new_text": null,
          "old_line_content": "    return expected_digit();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1068,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::floating_literal, TokStart)",
          "new_text": null,
          "old_line_content": "  return formToken(tok::floating_literal, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1083,
          "old_api": "isDigit",
          "new_api": null,
          "old_text": "isDigit(*TokStart)",
          "new_text": null,
          "old_line_content": "  assert((isDigit(*TokStart) || *TokStart == '.') && \"Unexpected start\");",
          "new_line_content": "  auto expected_digit = [&]() {",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "    while (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd));",
          "new_line_content": "  };",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::unknown, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": "expected_digit",
          "new_api": null,
          "old_text": "expected_digit()",
          "new_text": null,
          "old_line_content": "    return expected_digit();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": "lexHexNumber",
          "new_api": null,
          "old_text": "lexHexNumber()",
          "new_text": null,
          "old_line_content": "    return lexHexNumber();",
          "new_line_content": "  if (*TokStart == '0' && *CurPtr == 'o') {",
          "content_same": false
        },
        {
          "line": 1103,
          "old_api": "expected_int_digit",
          "new_api": null,
          "old_text": "expected_int_digit(CurPtr, ExpectedDigitKind::Octal)",
          "new_text": null,
          "old_line_content": "      return expected_int_digit(CurPtr, ExpectedDigitKind::Octal);",
          "new_line_content": "    while ((*CurPtr >= '0' && *CurPtr <= '7') || *CurPtr == '_')",
          "content_same": false
        },
        {
          "line": 1109,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1112,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::integer_literal, TokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::integer_literal, TokStart);",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 1119,
          "old_api": "expected_int_digit",
          "new_api": null,
          "old_text": "expected_int_digit(CurPtr, ExpectedDigitKind::Binary)",
          "new_text": null,
          "old_line_content": "      return expected_int_digit(CurPtr, ExpectedDigitKind::Binary);",
          "new_line_content": "    while (*CurPtr == '0' || *CurPtr == '1' || *CurPtr == '_')",
          "content_same": false
        },
        {
          "line": 1125,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::integer_literal, TokStart)",
          "new_text": null,
          "old_line_content": "    return formToken(tok::integer_literal, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1133,
          "old_api": "isDigit",
          "new_api": null,
          "old_text": "isDigit(*CurPtr)",
          "new_text": null,
          "old_line_content": "  while (isDigit(*CurPtr) || *CurPtr == '_')",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1140,
          "old_api": "is",
          "new_api": null,
          "old_text": "NextToken.is(tok::period)",
          "new_text": null,
          "old_line_content": "    if (!isDigit(CurPtr[1]) || NextToken.is(tok::period))",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::integer_literal, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "new_line_content": "    // Floating literals must have '.', 'e', or 'E' after digits.  If it is",
          "content_same": false
        },
        {
          "line": 1147,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "      if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::integer_literal, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::integer_literal, TokStart);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": "isDigit",
          "new_api": null,
          "old_text": "isDigit(*CurPtr)",
          "new_text": null,
          "old_line_content": "    while (isDigit(*CurPtr) || *CurPtr == '_')",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1169,
          "old_api": "isDigit",
          "new_api": null,
          "old_text": "isDigit(*CurPtr)",
          "new_text": null,
          "old_line_content": "    if (!isDigit(*CurPtr)) {",
          "new_line_content": "      // identifier (invalid character), underscore (invalid first character),",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "      if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd))",
          "new_line_content": "                 *tmp == '_');",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(tmp, 1)",
          "new_text": null,
          "old_line_content": "        diagnose(tmp, diag::lex_invalid_digit_in_fp_exponent, StringRef(tmp, 1),",
          "new_line_content": "      else",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": "expected_digit",
          "new_api": null,
          "old_text": "expected_digit()",
          "new_text": null,
          "old_line_content": "      return expected_digit();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1183,
          "old_api": "isDigit",
          "new_api": null,
          "old_text": "isDigit(*CurPtr)",
          "new_text": null,
          "old_line_content": "    while (isDigit(*CurPtr) || *CurPtr == '_')",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1187,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "    if (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)) {",
          "new_line_content": "               false);",
          "content_same": false
        },
        {
          "line": 1190,
          "old_api": "expected_digit",
          "new_api": null,
          "old_text": "expected_digit()",
          "new_text": null,
          "old_line_content": "      return expected_digit();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1194,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::floating_literal, TokStart)",
          "new_text": null,
          "old_line_content": "  return formToken(tok::floating_literal, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1200,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(CurPtr[0] == '{' && \"Invalid unicode escape\")",
          "new_text": null,
          "old_line_content": "  assert(CurPtr[0] == '{' && \"Invalid unicode escape\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1206,
          "old_api": "isHexDigit",
          "new_api": null,
          "old_text": "isHexDigit(CurPtr[0])",
          "new_text": null,
          "old_line_content": "  for (; isHexDigit(CurPtr[0]); ++NumDigits)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "Diags->diagnose(CurPtr, diag::lex_invalid_u_escape_rbrace)",
          "new_text": null,
          "old_line_content": "      Diags->diagnose(CurPtr, diag::lex_invalid_u_escape_rbrace);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1218,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "Diags->diagnose(CurPtr, diag::lex_invalid_u_escape)",
          "new_text": null,
          "old_line_content": "      Diags->diagnose(CurPtr, diag::lex_invalid_u_escape);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1223,
          "old_api": "getAsInteger",
          "new_api": null,
          "old_text": "StringRef(DigitStart, NumDigits).getAsInteger(16, CharValue)",
          "new_text": null,
          "old_line_content": "  StringRef(DigitStart, NumDigits).getAsInteger(16, CharValue);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1264,
          "old_api": "diagnoseZeroWidthMatchAndAdvance",
          "new_api": null,
          "old_text": "diagnoseZeroWidthMatchAndAdvance('\"', TmpPtr, Diags)",
          "new_text": null,
          "old_line_content": "      diagnoseZeroWidthMatchAndAdvance('\"', TmpPtr, Diags) &&",
          "new_line_content": "    CurPtr = TmpPtr;",
          "content_same": false
        },
        {
          "line": 1265,
          "old_api": "diagnoseZeroWidthMatchAndAdvance",
          "new_api": null,
          "old_text": "diagnoseZeroWidthMatchAndAdvance('\"', TmpPtr, Diags)",
          "new_text": null,
          "old_line_content": "      diagnoseZeroWidthMatchAndAdvance('\"', TmpPtr, Diags)) {",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 1277,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(CurPtr[-1] == '#')",
          "new_text": null,
          "old_line_content": "  assert(CurPtr[-1] == '#');",
          "new_line_content": "  const char *TmpPtr = CurPtr;",
          "content_same": false
        },
        {
          "line": 1283,
          "old_api": "diagnoseZeroWidthMatchAndAdvance",
          "new_api": null,
          "old_text": "diagnoseZeroWidthMatchAndAdvance('\"', TmpPtr, Diags)",
          "new_text": null,
          "old_line_content": "  if (diagnoseZeroWidthMatchAndAdvance('\"', TmpPtr, Diags)) {",
          "new_line_content": "    return CustomDelimiterLen;",
          "content_same": false
        },
        {
          "line": 1301,
          "old_api": "diagnoseZeroWidthMatchAndAdvance",
          "new_api": null,
          "old_text": "diagnoseZeroWidthMatchAndAdvance('#', TmpPtr, Diags)",
          "new_text": null,
          "old_line_content": "  while (diagnoseZeroWidthMatchAndAdvance('#', TmpPtr, Diags)) {}",
          "new_line_content": "  if (TmpPtr - BytesPtr < CustomDelimiterLen)",
          "content_same": false
        },
        {
          "line": 1312,
          "old_api": "Lexer::getSourceLoc(BytesPtr)",
          "new_api": null,
          "old_text": "Lexer::getSourceLoc(BytesPtr)",
          "new_text": null,
          "old_line_content": "        .fixItRemoveChars(Lexer::getSourceLoc(BytesPtr),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1313,
          "old_api": "Lexer::getSourceLoc(TmpPtr)",
          "new_api": null,
          "old_text": "Lexer::getSourceLoc(TmpPtr)",
          "new_text": null,
          "old_line_content": "                          Lexer::getSourceLoc(TmpPtr));",
          "new_line_content": "  return true;",
          "content_same": false
        },
        {
          "line": 1336,
          "old_api": "isPrintable",
          "new_api": null,
          "old_text": "isPrintable(CurPtr[-1])",
          "new_text": null,
          "old_line_content": "      if (isPrintable(CurPtr[-1]) == 0)",
          "new_line_content": "          if (EmitDiagnostics)",
          "content_same": false
        },
        {
          "line": 1339,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CharStart, diag::lex_unprintable_ascii_character)",
          "new_text": null,
          "old_line_content": "            diagnose(CharStart, diag::lex_unprintable_ascii_character);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1343,
          "old_api": "validateUTF8CharacterAndAdvance",
          "new_api": null,
          "old_text": "validateUTF8CharacterAndAdvance(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "    unsigned CharValue = validateUTF8CharacterAndAdvance(CurPtr, BufferEnd);",
          "new_line_content": "    if (EmitDiagnostics)",
          "content_same": false
        },
        {
          "line": 1346,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CharStart, diag::lex_invalid_utf8)",
          "new_text": null,
          "old_line_content": "      diagnose(CharStart, diag::lex_invalid_utf8);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1353,
          "old_api": "LLVM_UNLIKELY",
          "new_api": null,
          "old_text": "LLVM_UNLIKELY(StopQuote != '\"')",
          "new_text": null,
          "old_line_content": "      if (LLVM_UNLIKELY(StopQuote != '\"'))",
          "new_line_content": "      if (!IsMultilineString && !CustomDelimiterLen)",
          "content_same": false
        },
        {
          "line": 1360,
          "old_api": "advanceIfMultilineDelimiter",
          "new_api": null,
          "old_text": "advanceIfMultilineDelimiter(TmpPtr, D)",
          "new_text": null,
          "old_line_content": "      if (IsMultilineString && !advanceIfMultilineDelimiter(TmpPtr, D))",
          "new_line_content": "      if (CustomDelimiterLen &&",
          "content_same": false
        },
        {
          "line": 1363,
          "old_api": "delimiterMatches",
          "new_api": null,
          "old_text": "delimiterMatches(CustomDelimiterLen, TmpPtr, D, /*IsClosing=*/true)",
          "new_text": null,
          "old_line_content": "          !delimiterMatches(CustomDelimiterLen, TmpPtr, D, /*IsClosing=*/true))",
          "new_line_content": "      CurPtr = TmpPtr;",
          "content_same": false
        },
        {
          "line": 1374,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CurPtr-1, diag::lex_nul_character)",
          "new_text": null,
          "old_line_content": "      diagnose(CurPtr-1, diag::lex_nul_character);",
          "new_line_content": "  case '\\n':  // String literals cannot have \\n or \\r in them.",
          "content_same": false
        },
        {
          "line": 1378,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(IsMultilineString && \"Caller must handle newlines in non-multiline\")",
          "new_text": null,
          "old_line_content": "    assert(IsMultilineString && \"Caller must handle newlines in non-multiline\");",
          "new_line_content": "  case '\\\\':  // Escapes.",
          "content_same": false
        },
        {
          "line": 1381,
          "old_api": "delimiterMatches",
          "new_api": null,
          "old_text": "delimiterMatches(CustomDelimiterLen, CurPtr,\n                          EmitDiagnostics ? Diags : nullptr)",
          "new_text": null,
          "old_line_content": "    if (!delimiterMatches(CustomDelimiterLen, CurPtr,",
          "new_line_content": "      return '\\\\';",
          "content_same": false
        },
        {
          "line": 1391,
          "old_api": "maybeConsumeNewlineEscape",
          "new_api": null,
          "old_text": "maybeConsumeNewlineEscape(CurPtr, 0)",
          "new_text": null,
          "old_line_content": "    if (IsMultilineString && maybeConsumeNewlineEscape(CurPtr, 0))",
          "new_line_content": "    LLVM_FALLTHROUGH;",
          "content_same": false
        },
        {
          "line": 1396,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CurPtr, diag::lex_invalid_escape)",
          "new_text": null,
          "old_line_content": "      diagnose(CurPtr, diag::lex_invalid_escape);",
          "new_line_content": "    // is an invalid escape.",
          "content_same": false
        },
        {
          "line": 1399,
          "old_api": "isAlphanumeric",
          "new_api": null,
          "old_text": "isAlphanumeric(*CurPtr)",
          "new_text": null,
          "old_line_content": "    if (isAlphanumeric(*CurPtr)) ++CurPtr;",
          "new_line_content": "      ",
          "content_same": false
        },
        {
          "line": 1415,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CurPtr-1, diag::lex_unicode_escape_braces)",
          "new_text": null,
          "old_line_content": "        diagnose(CurPtr-1, diag::lex_unicode_escape_braces);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1419,
          "old_api": "lexUnicodeEscape",
          "new_api": null,
          "old_text": "lexUnicodeEscape(CurPtr, EmitDiagnostics ? this : nullptr)",
          "new_text": null,
          "old_line_content": "    CharValue = lexUnicodeEscape(CurPtr, EmitDiagnostics ? this : nullptr);",
          "new_line_content": "    break;",
          "content_same": false
        },
        {
          "line": 1429,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CharStart, diag::lex_invalid_unicode_scalar)",
          "new_text": null,
          "old_line_content": "      diagnose(CharStart, diag::lex_invalid_unicode_scalar);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1452,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "AllowNewline.push_back(IsMultilineString)",
          "new_text": null,
          "old_line_content": "  AllowNewline.push_back(IsMultilineString);",
          "new_line_content": "  auto inStringLiteral = [&]() {",
          "content_same": false
        },
        {
          "line": 1455,
          "old_api": "empty",
          "new_api": null,
          "old_text": "OpenDelimiters.empty()",
          "new_text": null,
          "old_line_content": "    return !OpenDelimiters.empty() &&",
          "new_line_content": "  };",
          "content_same": false
        },
        {
          "line": 1456,
          "old_api": "back",
          "new_api": null,
          "old_text": "OpenDelimiters.back()",
          "new_text": null,
          "old_line_content": "           (OpenDelimiters.back() == '\"' || OpenDelimiters.back() == '\\'');",
          "new_line_content": "  while (true) {",
          "content_same": false
        },
        {
          "line": 1473,
          "old_api": "back",
          "new_api": null,
          "old_text": "AllowNewline.back()",
          "new_text": null,
          "old_line_content": "      if (AllowNewline.back())",
          "new_line_content": "      // Will be diagnosed as an unterminated string literal.",
          "content_same": false
        },
        {
          "line": 1484,
          "old_api": "inStringLiteral",
          "new_api": null,
          "old_text": "inStringLiteral()",
          "new_text": null,
          "old_line_content": "      if (inStringLiteral() ||",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 1487,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(CurPtr[-1] == '\"' &&\n             \"advanceIfCustomDelimiter() must stop at after the quote\")",
          "new_text": null,
          "old_line_content": "      assert(CurPtr[-1] == '\"' &&",
          "new_line_content": "      LLVM_FALLTHROUGH;",
          "content_same": false
        },
        {
          "line": 1496,
          "old_api": "advanceIfMultilineDelimiter",
          "new_api": null,
          "old_text": "advanceIfMultilineDelimiter(CurPtr, nullptr)",
          "new_text": null,
          "old_line_content": "        AllowNewline.push_back(advanceIfMultilineDelimiter(CurPtr, nullptr));",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 1497,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "CustomDelimiter.push_back(CustomDelimiterLen)",
          "new_text": null,
          "old_line_content": "        CustomDelimiter.push_back(CustomDelimiterLen);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1504,
          "old_api": "back",
          "new_api": null,
          "old_text": "OpenDelimiters.back()",
          "new_text": null,
          "old_line_content": "      if (OpenDelimiters.back() != CurPtr[-1])",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1508,
          "old_api": "advanceIfMultilineDelimiter",
          "new_api": null,
          "old_text": "advanceIfMultilineDelimiter(CurPtr, nullptr)",
          "new_text": null,
          "old_line_content": "      if (AllowNewline.back() && !advanceIfMultilineDelimiter(CurPtr, nullptr))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1512,
          "old_api": "back",
          "new_api": null,
          "old_text": "CustomDelimiter.back()",
          "new_text": null,
          "old_line_content": "      if (!delimiterMatches(CustomDelimiter.back(), CurPtr, nullptr, true))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1517,
          "old_api": "pop_back",
          "new_api": null,
          "old_text": "AllowNewline.pop_back()",
          "new_text": null,
          "old_line_content": "      AllowNewline.pop_back();",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 1518,
          "old_api": "pop_back",
          "new_api": null,
          "old_text": "CustomDelimiter.pop_back()",
          "new_text": null,
          "old_line_content": "      CustomDelimiter.pop_back();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1524,
          "old_api": "inStringLiteral",
          "new_api": null,
          "old_text": "inStringLiteral()",
          "new_text": null,
          "old_line_content": "      if (inStringLiteral() &&",
          "new_line_content": "        switch (*CurPtr++) {",
          "content_same": false
        },
        {
          "line": 1525,
          "old_api": "back",
          "new_api": null,
          "old_text": "CustomDelimiter.back()",
          "new_text": null,
          "old_line_content": "          delimiterMatches(CustomDelimiter.back(), CurPtr, nullptr)) {",
          "new_line_content": "        case '(':",
          "content_same": false
        },
        {
          "line": 1529,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "OpenDelimiters.push_back('(')",
          "new_text": null,
          "old_line_content": "          OpenDelimiters.push_back('(');",
          "new_line_content": "        case '\\n': case '\\r': case 0:",
          "content_same": false
        },
        {
          "line": 1544,
          "old_api": "inStringLiteral",
          "new_api": null,
          "old_text": "inStringLiteral()",
          "new_text": null,
          "old_line_content": "      if (!inStringLiteral()) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1545,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "OpenDelimiters.push_back('(')",
          "new_text": null,
          "old_line_content": "        OpenDelimiters.push_back('(');",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 1549,
          "old_api": "empty",
          "new_api": null,
          "old_text": "OpenDelimiters.empty()",
          "new_text": null,
          "old_line_content": "      if (OpenDelimiters.empty()) {",
          "new_line_content": "        return CurPtr-1;",
          "content_same": false
        },
        {
          "line": 1554,
          "old_api": "pop_back",
          "new_api": null,
          "old_text": "OpenDelimiters.pop_back()",
          "new_text": null,
          "old_line_content": "        OpenDelimiters.pop_back();",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 1558,
          "old_api": "inStringLiteral",
          "new_api": null,
          "old_text": "inStringLiteral()",
          "new_text": null,
          "old_line_content": "        assert(inStringLiteral());",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1562,
          "old_api": "inStringLiteral",
          "new_api": null,
          "old_text": "inStringLiteral()",
          "new_text": null,
          "old_line_content": "      if (inStringLiteral())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": "skipToEndOfSlashStarComment",
          "new_api": null,
          "old_text": "skipToEndOfSlashStarComment(CurPtr, EndPtr)",
          "new_text": null,
          "old_line_content": "        bool isMultilineComment = skipToEndOfSlashStarComment(CurPtr, EndPtr);",
          "new_line_content": "          // Multiline comment is prohibited in string literal.",
          "content_same": false
        },
        {
          "line": 1568,
          "old_api": "back",
          "new_api": null,
          "old_text": "AllowNewline.back()",
          "new_text": null,
          "old_line_content": "        if (isMultilineComment && !AllowNewline.back()) {",
          "new_line_content": "          // Return the start of the comment.",
          "content_same": false
        },
        {
          "line": 1574,
          "old_api": "back",
          "new_api": null,
          "old_text": "AllowNewline.back()",
          "new_text": null,
          "old_line_content": "        if (!AllowNewline.back()) {",
          "new_line_content": "          // Return the start of the comment.",
          "content_same": false
        },
        {
          "line": 1580,
          "old_api": "advanceToEndOfLine",
          "new_api": null,
          "old_text": "advanceToEndOfLine(CurPtr, EndPtr)",
          "new_text": null,
          "old_line_content": "        if (/*isEOL=*/advanceToEndOfLine(CurPtr, EndPtr))",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1596,
          "old_api": "getCustomDelimiterLen",
          "new_api": null,
          "old_text": "Str.getCustomDelimiterLen()",
          "new_text": null,
          "old_line_content": "  if (unsigned CustomDelimiterLen = Str.getCustomDelimiterLen())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": "isMultilineString",
          "new_api": null,
          "old_text": "Str.isMultilineString()",
          "new_text": null,
          "old_line_content": "  if (Str.isMultilineString())",
          "new_line_content": "  else",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": "drop_front",
          "new_api": null,
          "old_text": "Bytes.drop_front().drop_back()",
          "new_text": null,
          "old_line_content": "    Bytes = Bytes.drop_front().drop_back();",
          "new_line_content": "  return Bytes;",
          "content_same": false
        },
        {
          "line": 1609,
          "old_api": "size",
          "new_api": null,
          "old_text": "longer.size()",
          "new_text": null,
          "old_line_content": "  while (offset < shorter.size() && offset < longer.size() && shorter[offset] == longer[offset]) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1621,
          "old_api": "end",
          "new_api": null,
          "old_text": "Bytes.end()",
          "new_text": null,
          "old_line_content": "  const char *begin = Bytes.begin(), *end = Bytes.end(), *start = end;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1642,
          "old_api": "Lexer::getSourceLoc(Ptr)",
          "new_api": null,
          "old_text": "Lexer::getSourceLoc(Ptr)",
          "new_text": null,
          "old_line_content": "          auto escapeLoc = Lexer::getSourceLoc(Ptr);",
          "new_line_content": "          while (*--Ptr == '\\\\') invalid = !invalid;",
          "content_same": false
        },
        {
          "line": 1646,
          "old_api": "fixItRemoveChars",
          "new_api": null,
          "old_text": "Diags->diagnose(escapeLoc, diag::lex_escaped_newline_at_lastline)\n              .fixItRemoveChars(escapeLoc, Lexer::getSourceLoc(LineEnd))",
          "new_text": null,
          "old_line_content": "            Diags->diagnose(escapeLoc, diag::lex_escaped_newline_at_lastline)",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1647,
          "old_api": "Lexer::getSourceLoc(LineEnd)",
          "new_api": null,
          "old_text": "Lexer::getSourceLoc(LineEnd)",
          "new_text": null,
          "old_line_content": "              .fixItRemoveChars(escapeLoc, Lexer::getSourceLoc(LineEnd));",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1651,
          "old_api": "StringRef",
          "new_api": null,
          "old_text": "StringRef(start, end - start)",
          "new_text": null,
          "old_line_content": "      return StringRef(start, end - start);",
          "new_line_content": "    default:",
          "content_same": false
        },
        {
          "line": 1659,
          "old_api": "Lexer::getSourceLoc(start + 1)",
          "new_api": null,
          "old_text": "Lexer::getSourceLoc(start + 1)",
          "new_text": null,
          "old_line_content": "    auto loc = Lexer::getSourceLoc(start + 1);",
          "new_line_content": "    // FIXME: Should try to suggest indentation.",
          "content_same": false
        },
        {
          "line": 1660,
          "old_api": "fixItInsert",
          "new_api": null,
          "old_text": "Diags->diagnose(loc, diag::lex_illegal_multiline_string_end)\n    // FIXME: Should try to suggest indentation.\n      .fixItInsert(loc, \"\\n\")",
          "new_text": null,
          "old_line_content": "    Diags->diagnose(loc, diag::lex_illegal_multiline_string_end)",
          "new_line_content": "      .fixItInsert(loc, \"\\n\");",
          "content_same": false
        },
        {
          "line": 1680,
          "old_api": "size",
          "new_api": null,
          "old_text": "ExpectedIndent.size()",
          "new_text": null,
          "old_line_content": "  if (MistakeOffset >= ExpectedIndent.size()) {",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 1685,
          "old_api": "empty",
          "new_api": null,
          "old_text": "LineStarts.empty()",
          "new_text": null,
          "old_line_content": "  assert(!LineStarts.empty());",
          "new_line_content": "  auto getLoc = [&](size_t offset) -> SourceLoc {",
          "content_same": false
        },
        {
          "line": 1688,
          "old_api": "bytes_begin",
          "new_api": null,
          "old_text": "Bytes.bytes_begin()",
          "new_text": null,
          "old_line_content": "    return Lexer::getSourceLoc((const char *)Bytes.bytes_begin() + offset);",
          "new_line_content": "  auto classify = [&](unsigned char ch) -> unsigned {",
          "content_same": false
        },
        {
          "line": 1703,
          "old_api": "size",
          "new_api": null,
          "old_text": "LineStarts.size()",
          "new_text": null,
          "old_line_content": "                  LineStarts.size() != 1, LineStarts.size(),",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 1715,
          "old_api": "substr",
          "new_api": null,
          "old_text": "ExpectedIndent.substr(0, MistakeOffset)",
          "new_text": null,
          "old_line_content": "  assert(ExpectedIndent.substr(0, MistakeOffset) == ",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 1716,
          "old_api": "substr",
          "new_api": null,
          "old_text": "ActualIndent.substr(0, MistakeOffset)",
          "new_text": null,
          "old_line_content": "         ActualIndent.substr(0, MistakeOffset));",
          "new_line_content": "  for (auto line : LineStarts) {",
          "content_same": false
        },
        {
          "line": 1720,
          "old_api": "size",
          "new_api": null,
          "old_text": "ActualIndent.size()",
          "new_text": null,
          "old_line_content": "                          getLoc(line + ActualIndent.size()),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": "substr",
          "new_api": null,
          "old_text": "ExpectedIndent.substr(MistakeOffset)",
          "new_text": null,
          "old_line_content": "                          ExpectedIndent.substr(MistakeOffset));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1731,
          "old_api": "getCustomDelimiterLen",
          "new_api": null,
          "old_text": "Str.getCustomDelimiterLen()",
          "new_text": null,
          "old_line_content": "    getMultilineTrailingIndent(Bytes, Diags, Str.getCustomDelimiterLen());",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 1734,
          "old_api": "data",
          "new_api": null,
          "old_text": "Indent.data()",
          "new_text": null,
          "old_line_content": "  SourceLoc IndentStartLoc = Lexer::getSourceLoc(Indent.data());",
          "new_line_content": "  // The offset into the previous line where it experienced its first indentation ",
          "content_same": false
        },
        {
          "line": 1738,
          "old_api": "std::numeric_limits<size_t>::max()",
          "new_api": null,
          "old_text": "std::numeric_limits<size_t>::max()",
          "new_text": null,
          "old_line_content": "  size_t lastMistakeOffset = std::numeric_limits<size_t>::max();",
          "new_line_content": "  // lastMatchLength.",
          "content_same": false
        },
        {
          "line": 1747,
          "old_api": "substr",
          "new_api": null,
          "old_text": "Bytes.substr(nextpos)",
          "new_text": null,
          "old_line_content": "    auto restOfBytes = Bytes.substr(nextpos);",
          "new_line_content": "    // Ignore blank lines.",
          "content_same": false
        },
        {
          "line": 1755,
          "old_api": "commonPrefixLength",
          "new_api": null,
          "old_text": "commonPrefixLength(Indent, restOfBytes)",
          "new_text": null,
          "old_line_content": "    auto errorOffset = commonPrefixLength(Indent, restOfBytes);",
          "new_line_content": "    // Are we starting a new run?",
          "content_same": false
        },
        {
          "line": 1760,
          "old_api": "diagnoseInvalidMultilineIndents",
          "new_api": null,
          "old_text": "diagnoseInvalidMultilineIndents(Diags, Indent, IndentStartLoc, Bytes, \n                                      linesWithLastMistakeOffset, lastMistakeOffset, \n                                      commonIndentation)",
          "new_text": null,
          "old_line_content": "      diagnoseInvalidMultilineIndents(Diags, Indent, IndentStartLoc, Bytes, ",
          "new_line_content": "                                      commonIndentation);",
          "content_same": false
        },
        {
          "line": 1769,
          "old_api": "find_first_not_of",
          "new_api": null,
          "old_text": "restOfBytes.find_first_not_of(\" \\t\")",
          "new_text": null,
          "old_line_content": "      auto prefixLength = restOfBytes.find_first_not_of(\" \\t\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1770,
          "old_api": "substr",
          "new_api": null,
          "old_text": "restOfBytes.substr(0, prefixLength)",
          "new_text": null,
          "old_line_content": "      commonIndentation = restOfBytes.substr(0, prefixLength);",
          "new_line_content": "    else {",
          "content_same": false
        },
        {
          "line": 1774,
          "old_api": "commonPrefixLength",
          "new_api": null,
          "old_text": "commonPrefixLength(commonIndentation, restOfBytes)",
          "new_text": null,
          "old_line_content": "      auto prefixLength = commonPrefixLength(commonIndentation, restOfBytes);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1775,
          "old_api": "substr",
          "new_api": null,
          "old_text": "commonIndentation.substr(0, prefixLength)",
          "new_text": null,
          "old_line_content": "      commonIndentation = commonIndentation.substr(0, prefixLength);",
          "new_line_content": "    ",
          "content_same": false
        },
        {
          "line": 1779,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "linesWithLastMistakeOffset.push_back(nextpos)",
          "new_text": null,
          "old_line_content": "    linesWithLastMistakeOffset.push_back(nextpos);",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 1783,
          "old_api": "diagnoseInvalidMultilineIndents",
          "new_api": null,
          "old_text": "diagnoseInvalidMultilineIndents(Diags, Indent, IndentStartLoc, Bytes, \n                                  linesWithLastMistakeOffset, lastMistakeOffset, \n                                  commonIndentation)",
          "new_text": null,
          "old_line_content": "  diagnoseInvalidMultilineIndents(Diags, Indent, IndentStartLoc, Bytes, ",
          "new_line_content": "                                  commonIndentation);",
          "content_same": false
        },
        {
          "line": 1793,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(*TokStart == '\\'' && TokEnd[-1] == '\\'')",
          "new_text": null,
          "old_line_content": "  assert(*TokStart == '\\'' && TokEnd[-1] == '\\'');",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 1798,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "replacement.push_back('\"')",
          "new_text": null,
          "old_line_content": "  replacement.push_back('\"');",
          "new_line_content": "  const char *OutputPtr = Ptr;",
          "content_same": false
        },
        {
          "line": 1805,
          "old_api": "append",
          "new_api": null,
          "old_text": "replacement.append(OutputPtr, Ptr - 1)",
          "new_text": null,
          "old_line_content": "        replacement.append(OutputPtr, Ptr - 1);",
          "new_line_content": "        // Un-escape single quotes.",
          "content_same": false
        },
        {
          "line": 1808,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "replacement.push_back('\\'')",
          "new_text": null,
          "old_line_content": "        replacement.push_back('\\'');",
          "new_line_content": "        // Preserve the contents of interpolation.",
          "content_same": false
        },
        {
          "line": 1813,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(*Ptr == ')')",
          "new_text": null,
          "old_line_content": "        assert(*Ptr == ')');",
          "new_line_content": "      // Skip over escaped characters.",
          "content_same": false
        },
        {
          "line": 1818,
          "old_api": "append",
          "new_api": null,
          "old_text": "replacement.append(OutputPtr, Ptr - 1)",
          "new_text": null,
          "old_line_content": "      replacement.append(OutputPtr, Ptr - 1);",
          "new_line_content": "      // Escape double quotes.",
          "content_same": false
        },
        {
          "line": 1821,
          "old_api": "append",
          "new_api": null,
          "old_text": "replacement.append(\"\\\\\\\"\")",
          "new_text": null,
          "old_line_content": "      replacement.append(\"\\\\\\\"\");",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1825,
          "old_api": "append",
          "new_api": null,
          "old_text": "replacement.append(OutputPtr, Ptr - 1)",
          "new_text": null,
          "old_line_content": "  replacement.append(OutputPtr, Ptr - 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1829,
          "old_api": "Lexer::getSourceLoc(TokStart)",
          "new_api": null,
          "old_text": "Lexer::getSourceLoc(TokStart)",
          "new_text": null,
          "old_line_content": "      .fixItReplaceChars(Lexer::getSourceLoc(TokStart),",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1830,
          "old_api": "Lexer::getSourceLoc(TokEnd)",
          "new_api": null,
          "old_text": "Lexer::getSourceLoc(TokEnd)",
          "new_text": null,
          "old_line_content": "                         Lexer::getSourceLoc(TokEnd), replacement);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1847,
          "old_api": "fixItInsert",
          "new_api": null,
          "old_text": "diagnose(CurPtr, diag::lex_illegal_multiline_string_start)\n        .fixItInsert(Lexer::getSourceLoc(CurPtr), \"\\n\")",
          "new_text": null,
          "old_line_content": "    diagnose(CurPtr, diag::lex_illegal_multiline_string_start)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1848,
          "old_api": "Lexer::getSourceLoc(CurPtr)",
          "new_api": null,
          "old_text": "Lexer::getSourceLoc(CurPtr)",
          "new_text": null,
          "old_line_content": "        .fixItInsert(Lexer::getSourceLoc(CurPtr), \"\\n\");",
          "new_line_content": "  bool wasErroneous = false;",
          "content_same": false
        },
        {
          "line": 1855,
          "old_api": "delimiterMatches",
          "new_api": null,
          "old_text": "delimiterMatches(CustomDelimiterLen, TmpPtr, nullptr)",
          "new_text": null,
          "old_line_content": "        delimiterMatches(CustomDelimiterLen, TmpPtr, nullptr) &&",
          "new_line_content": "      // Consume tokens until we hit the corresponding ')'.",
          "content_same": false
        },
        {
          "line": 1858,
          "old_api": "skipToEndOfInterpolatedExpression",
          "new_api": null,
          "old_text": "skipToEndOfInterpolatedExpression(TmpPtr, BufferEnd,\n                                                 IsMultilineString)",
          "new_text": null,
          "old_line_content": "      CurPtr = skipToEndOfInterpolatedExpression(TmpPtr, BufferEnd,",
          "new_line_content": "      if (*CurPtr == ')') {",
          "content_same": false
        },
        {
          "line": 1867,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CurPtr, diag::lex_unterminated_string)",
          "new_text": null,
          "old_line_content": "        diagnose(CurPtr, diag::lex_unterminated_string);",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 1871,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(TokStart, diag::lex_unterminated_string)",
          "new_text": null,
          "old_line_content": "        diagnose(TokStart, diag::lex_unterminated_string);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1872,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": null,
          "old_line_content": "        return formToken(tok::unknown, TokStart);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1879,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(TokStart, diag::lex_unterminated_string)",
          "new_text": null,
          "old_line_content": "      diagnose(TokStart, diag::lex_unterminated_string);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::unknown, TokStart)",
          "new_text": null,
          "old_line_content": "      return formToken(tok::unknown, TokStart);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1883,
          "old_api": "lexCharacter",
          "new_api": null,
          "old_text": "lexCharacter(CurPtr, QuoteChar, true,\n                                      IsMultilineString, CustomDelimiterLen)",
          "new_text": null,
          "old_line_content": "    unsigned CharValue = lexCharacter(CurPtr, QuoteChar, true,",
          "new_line_content": "    // This is the end of string, we are done.",
          "content_same": false
        },
        {
          "line": 1896,
          "old_api": "diagnoseSingleQuoteStringLiteral",
          "new_api": null,
          "old_text": "diagnoseSingleQuoteStringLiteral(TokStart, CurPtr, Diags)",
          "new_text": null,
          "old_line_content": "    diagnoseSingleQuoteStringLiteral(TokStart, CurPtr, Diags);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1902,
          "old_api": "formStringLiteralToken",
          "new_api": null,
          "old_text": "formStringLiteralToken(TokStart, IsMultilineString,\n                                CustomDelimiterLen)",
          "new_text": null,
          "old_line_content": "  return formStringLiteralToken(TokStart, IsMultilineString,",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1926,
          "old_api": "lexCharacter",
          "new_api": null,
          "old_text": "lexCharacter(Body, '\\0', /*EmitDiagnostics=*/false)",
          "new_text": null,
          "old_line_content": "    unsigned CharValue = lexCharacter(Body, '\\0', /*EmitDiagnostics=*/false);",
          "new_line_content": "    if (CharValue == ~1U) return nullptr;",
          "content_same": false
        },
        {
          "line": 1939,
          "old_api": "fixItReplaceChars",
          "new_api": null,
          "old_text": "diagnose(CharStart, diag::lex_invalid_curly_quote)\n            .fixItReplaceChars(getSourceLoc(CharStart), getSourceLoc(Body),\n                               \"\\\"\")",
          "new_text": null,
          "old_line_content": "        diagnose(CharStart, diag::lex_invalid_curly_quote)",
          "new_line_content": "                               \"\\\"\");",
          "content_same": false
        },
        {
          "line": 1940,
          "old_api": "getSourceLoc",
          "new_api": null,
          "old_text": "getSourceLoc(Body)",
          "new_text": null,
          "old_line_content": "            .fixItReplaceChars(getSourceLoc(CharStart), getSourceLoc(Body),",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1956,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(CurPtr[-1] == '`' && \"Unexpected start of escaped identifier\")",
          "new_text": null,
          "old_line_content": "  assert(CurPtr[-1] == '`' && \"Unexpected start of escaped identifier\");",
          "new_line_content": "  const char *Quote = CurPtr-1;",
          "content_same": false
        },
        {
          "line": 1965,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd)",
          "new_text": null,
          "old_line_content": "    while (advanceIfValidContinuationOfIdentifier(CurPtr, BufferEnd));",
          "new_line_content": "    // If we have the terminating \"`\", it's an escaped identifier.",
          "content_same": false
        },
        {
          "line": 1970,
          "old_api": "formEscapedIdentifierToken",
          "new_api": null,
          "old_text": "formEscapedIdentifierToken(Quote)",
          "new_text": null,
          "old_line_content": "      formEscapedIdentifierToken(Quote);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1978,
          "old_api": "formEscapedIdentifierToken",
          "new_api": null,
          "old_text": "formEscapedIdentifierToken(Quote)",
          "new_text": null,
          "old_line_content": "    formEscapedIdentifierToken(Quote);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1984,
          "old_api": "formToken",
          "new_api": null,
          "old_text": "formToken(tok::backtick, Quote)",
          "new_text": null,
          "old_line_content": "  formToken(tok::backtick, Quote);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1992,
          "old_api": "size",
          "new_api": null,
          "old_text": "terminator.size()",
          "new_text": null,
          "old_line_content": "  size_t termLen = terminator.size();",
          "new_line_content": "  // Get a reference to the rest of the buffer minus the length of the start",
          "content_same": false
        },
        {
          "line": 1996,
          "old_api": "substr",
          "new_api": null,
          "old_text": "StringRef(CurPtr, BufferEnd - CurPtr).substr(termLen)",
          "new_text": null,
          "old_line_content": "  auto restOfBuffer = StringRef(CurPtr, BufferEnd - CurPtr).substr(termLen);",
          "new_line_content": "  while (endPos != StringRef::npos) {",
          "content_same": false
        },
        {
          "line": 1997,
          "old_api": "find",
          "new_api": null,
          "old_text": "restOfBuffer.find(terminator)",
          "new_text": null,
          "old_line_content": "  size_t endPos = restOfBuffer.find(terminator);",
          "new_line_content": "    // Must occur at start of line.",
          "content_same": false
        },
        {
          "line": 2005,
          "old_api": "substr",
          "new_api": null,
          "old_text": "restOfBuffer.substr(endPos + termLen)",
          "new_text": null,
          "old_line_content": "    restOfBuffer = restOfBuffer.substr(endPos + termLen);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2006,
          "old_api": "find",
          "new_api": null,
          "old_text": "restOfBuffer.find(terminator)",
          "new_text": null,
          "old_line_content": "    endPos = restOfBuffer.find(terminator);",
          "new_line_content": "  return nullptr;",
          "content_same": false
        },
        {
          "line": 2020,
          "old_api": "startswith",
          "new_api": null,
          "old_text": "restOfBuffer.startswith(\">>>> \")",
          "new_text": null,
          "old_line_content": "  if (!restOfBuffer.startswith(\"<<<<<<< \") && !restOfBuffer.startswith(\">>>> \"))",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 2027,
          "old_api": "diagnose",
          "new_api": null,
          "old_text": "diagnose(CurPtr, diag::lex_conflict_marker_in_file)",
          "new_text": null,
          "old_line_content": "    diagnose(CurPtr, diag::lex_conflict_marker_in_file);",
          "new_line_content": "    ",
          "content_same": false
        },
        {
          "line": 2032,
          "old_api": "skipToEndOfLine",
          "new_api": null,
          "old_text": "skipToEndOfLine(EatNewline)",
          "new_text": null,
          "old_line_content": "      skipToEndOfLine(EatNewline);",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 2044,
          "old_api": "advanceIfValidContinuationOfIdentifier",
          "new_api": null,
          "old_text": "advanceIfValidContinuationOfIdentifier(Tmp, BufferEnd)",
          "new_text": null,
          "old_line_content": "  if (advanceIfValidContinuationOfIdentifier(Tmp, BufferEnd)) {",
          "new_line_content": "    // start, attempt to recover by eating more continuation characters.",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 118,
      "total_additions": 423,
      "total_deletions": 423,
      "total_api_changes": 964
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 3,
        "api_related_lines": 964,
        "non_api_lines": 1,
        "non_api_line_numbers": [
          272
        ]
      }
    },
    "api_calls_before": 741,
    "api_calls_after": 741,
    "diff_info": {
      "added_lines": 1,
      "removed_lines": 3,
      "total_diff_lines": 16
    }
  }
}