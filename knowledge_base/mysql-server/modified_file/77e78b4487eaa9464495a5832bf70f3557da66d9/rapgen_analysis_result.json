{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/mysql-server/modified_file/77e78b4487eaa9464495a5832bf70f3557da66d9",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/mysql-server/modified_file/77e78b4487eaa9464495a5832bf70f3557da66d9/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/mysql-server/modified_file/77e78b4487eaa9464495a5832bf70f3557da66d9/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/mysql-server/modified_file/77e78b4487eaa9464495a5832bf70f3557da66d9/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 331,
          "old_api": "min",
          "new_api": "primary_key_is_clustered",
          "old_text": "min(tmp_fanout, tab->worst_seeks)",
          "new_text": "table->file->primary_key_is_clustered()",
          "old_line_content": "            cur_read_cost= prefix_rowcount * min(tmp_fanout, tab->worst_seeks);",
          "new_line_content": "                   table->file->primary_key_is_clustered())",
          "content_same": false
        },
        {
          "line": 337,
          "old_api": "actual_key_parts",
          "new_api": "min",
          "old_text": "actual_key_parts(keyinfo)",
          "new_text": "min(tmp_fanout, tab->worst_seeks)",
          "old_line_content": "                                         actual_key_parts(keyinfo))))",
          "new_line_content": "            cur_read_cost= prefix_rowcount * min(tmp_fanout, tab->worst_seeks);",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": "index_only_read_time",
          "new_api": "set_if_smaller",
          "old_text": "table->file->index_only_read_time(key, tmp_fanout)",
          "new_text": "set_if_smaller(tmp_fanout,\n                       (double) thd->variables.max_seeks_for_key)",
          "old_line_content": "            table->file->index_only_read_time(key, tmp_fanout);",
          "new_line_content": "        set_if_smaller(tmp_fanout,",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": "find_best_ref",
          "new_api": "DBUG_ENTER",
          "old_text": "find_best_ref(tab, remaining_tables, idx, prefix_rowcount,\n                            &found_condition, &ref_depend_map, &used_key_parts)",
          "new_text": "DBUG_ENTER(\"Optimize_table_order::best_access_path\")",
          "old_line_content": "    best_ref= find_best_ref(tab, remaining_tables, idx, prefix_rowcount,",
          "new_line_content": "  DBUG_ENTER(\"Optimize_table_order::best_access_path\");",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": "add_alnum",
          "new_api": "ha_table_flags",
          "old_text": "trace_access_scan.add_alnum(\"access_type\", \"scan\").\n      add(\"chosen\", false).\n      add_alnum(\"cause\", \"force_index\")",
          "new_text": "table->file->ha_table_flags()",
          "old_line_content": "    trace_access_scan.add_alnum(\"access_type\", \"scan\").",
          "new_line_content": "  else if ((table->file->ha_table_flags() & HA_TABLE_SCAN_ON_INDEX) &&    //(3)",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": "calculate_scan_cost",
          "new_api": "add_alnum",
          "old_text": "calculate_scan_cost(tab,\n                                               idx,\n                                               best_ref,\n                                               prefix_rowcount,\n                                               found_condition,\n                                               disable_jbuf,\n                                               &scan_fanout,\n                                               &trace_access_scan)",
          "new_text": "trace_access_scan.add_alnum(\"access_type\", \"scan\").\n      add(\"chosen\", false).\n      add_alnum(\"cause\", \"force_index\")",
          "old_line_content": "    double scan_read_cost= calculate_scan_cost(tab,",
          "new_line_content": "    trace_access_scan.add_alnum(\"access_type\", \"scan\").",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": "find_item_equal",
          "new_api": "type",
          "old_text": "item_field->find_item_equal(nest ? nest->cond_equal :\n                                              tab->join->cond_equal)",
          "new_text": "outer->type()",
          "old_line_content": "      item_equal= item_field->find_item_equal(nest ? nest->cond_equal :",
          "new_line_content": "    if (outer->type() == Item::FIELD_ITEM)",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": "get_const",
          "new_api": "outer_join_nest",
          "old_text": "item_equal->get_const()",
          "new_text": "item_field->field->table->pos_in_table_list->outer_join_nest()",
          "old_line_content": "      if (item_equal->get_const() ||                           // (1)",
          "new_line_content": "        item_field->field->table->pos_in_table_list->outer_join_nest();",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": "used_tables",
          "new_api": "find_item_equal",
          "old_text": "item_equal->used_tables()",
          "new_text": "item_field->find_item_equal(nest ? nest->cond_equal :\n                                              tab->join->cond_equal)",
          "old_line_content": "          (item_equal->used_tables() & ~not_available_tables)) // (2)",
          "new_line_content": "      item_equal= item_field->find_item_equal(nest ? nest->cond_equal :",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": "is_set",
          "new_api": "add",
          "old_text": "tab->table->covering_keys.is_set(key)",
          "new_text": "trace_ref.add(\"cost\", start_key->read_cost)",
          "old_line_content": "    else if (tab->table->covering_keys.is_set(key))",
          "new_line_content": "      trace_ref.add(\"cost\", start_key->read_cost);",
          "content_same": false
        },
        {
          "line": 1223,
          "old_api": "add",
          "new_api": "index_only_read_time",
          "old_text": "trace_cov_scan.add(\"cost\", cost)",
          "new_text": "tab->table->file->index_only_read_time(key, rowcount)",
          "old_line_content": "      trace_cov_scan.add(\"cost\", cost);",
          "new_line_content": "      double cost= tab->table->file->index_only_read_time(key, rowcount);",
          "content_same": false
        },
        {
          "line": 1255,
          "old_api": "rows2double",
          "new_api": "end",
          "old_text": "rows2double(tab->quick->records)",
          "new_text": "trace_all_idx.end()",
          "old_line_content": "      pos->fanout= rows2double(tab->quick->records);",
          "new_line_content": "  trace_all_idx.end();",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": "reset_nj_counters",
          "new_api": "DBUG_ENTER",
          "old_text": "reset_nj_counters(join->join_list)",
          "new_text": "DBUG_ENTER(\"Optimize_table_order::choose_table_order\")",
          "old_line_content": "  reset_nj_counters(join->join_list);",
          "new_line_content": "  DBUG_ENTER(\"Optimize_table_order::choose_table_order\");",
          "content_same": false
        },
        {
          "line": 1310,
          "old_api": "Join_tab_compare_embedded_first",
          "new_api": "reset_nj_counters",
          "old_text": "Join_tab_compare_embedded_first(emb_sjm_nest)",
          "new_text": "reset_nj_counters(join->join_list)",
          "old_line_content": "               Join_tab_compare_embedded_first(emb_sjm_nest));",
          "new_line_content": "  reset_nj_counters(join->join_list);",
          "content_same": false
        },
        {
          "line": 1340,
          "old_api": "optimize_straight_join",
          "new_api": "merge_sort",
          "old_text": "optimize_straight_join(join_tables)",
          "new_text": "merge_sort(join->best_ref + join->const_tables,\n                 join->best_ref + join->tables,\n                 Join_tab_compare_default())",
          "old_line_content": "    optimize_straight_join(join_tables);",
          "new_line_content": "      merge_sort(join->best_ref + join->const_tables,",
          "content_same": false
        },
        {
          "line": 1352,
          "old_api": "fix_semijoin_strategies",
          "new_api": "optimize_straight_join",
          "old_text": "fix_semijoin_strategies()",
          "new_text": "optimize_straight_join(join_tables)",
          "old_line_content": "  if (fix_semijoin_strategies())",
          "new_line_content": "    optimize_straight_join(join_tables);",
          "content_same": false
        },
        {
          "line": 1355,
          "old_api": "DBUG_RETURN",
          "new_api": "greedy_search",
          "old_text": "DBUG_RETURN(false)",
          "new_text": "greedy_search(join_tables)",
          "old_line_content": "  DBUG_RETURN(false);",
          "new_line_content": "    if (greedy_search(join_tables))",
          "content_same": false
        },
        {
          "line": 1461,
          "old_api": "best_access_path",
          "new_api": "is_started",
          "old_text": "best_access_path(s, join_tables, idx, false, record_count, position)",
          "new_text": "trace->is_started()",
          "old_line_content": "    best_access_path(s, join_tables, idx, false, record_count, position);",
          "new_line_content": "    if (unlikely(trace->is_started()))",
          "content_same": false
        },
        {
          "line": 1480,
          "old_api": "memcpy",
          "new_api": "no_semijoin",
          "old_text": "memcpy(join->best_positions, join->positions, sizeof(POSITION)*idx)",
          "new_text": "position->no_semijoin()",
          "old_line_content": "  memcpy(join->best_positions, join->positions, sizeof(POSITION)*idx);",
          "new_line_content": "    position->no_semijoin(); // advance_sj_state() is not needed",
          "content_same": false
        },
        {
          "line": 1665,
          "old_api": "best_extension_by_limited_search",
          "new_api": "DBUG_ENTER",
          "old_text": "best_extension_by_limited_search(remaining_tables, idx,\n                                         record_count, read_time,\n                                         search_depth)",
          "new_text": "DBUG_ENTER(\"Optimize_table_order::greedy_search\")",
          "old_line_content": "    if (best_extension_by_limited_search(remaining_tables, idx,",
          "new_line_content": "  DBUG_ENTER(\"Optimize_table_order::greedy_search\");",
          "content_same": false
        },
        {
          "line": 1668,
          "old_api": "DBUG_RETURN",
          "new_api": "my_count_bits",
          "old_text": "DBUG_RETURN(true)",
          "new_text": "my_count_bits(remaining_tables)",
          "old_line_content": "      DBUG_RETURN(true);",
          "new_line_content": "  const uint n_tables= my_count_bits(remaining_tables);",
          "content_same": false
        },
        {
          "line": 1990,
          "old_api": "print_plan",
          "new_api": "DBUG_EXECUTE_IF",
          "old_text": "print_plan(join, idx, record_count, read_time, read_time,\n                                \"part_plan\")",
          "new_text": "DBUG_EXECUTE_IF(\"bug13820776_2\", thd->killed= THD::KILL_QUERY;)",
          "old_line_content": "  DBUG_EXECUTE(\"opt\", print_plan(join, idx, record_count, read_time, read_time,",
          "new_line_content": "  DBUG_EXECUTE_IF(\"bug13820776_2\", thd->killed= THD::KILL_QUERY;);",
          "content_same": false
        },
        {
          "line": 2009,
          "old_api": "memcpy",
          "new_api": "is_empty",
          "old_text": "memcpy(saved_refs, join->best_ref + idx, \n         sizeof(JOIN_TAB*) * (join->tables - idx))",
          "new_text": "join->select_lex->sj_nests.is_empty()",
          "old_line_content": "  memcpy(saved_refs, join->best_ref + idx, ",
          "new_line_content": "  const bool has_sj= !(join->select_lex->sj_nests.is_empty() || emb_sjm_nest);",
          "content_same": false
        },
        {
          "line": 2039,
          "old_api": "DBUG_ASSERT",
          "new_api": "check_interleaving_with_nj",
          "old_text": "DBUG_ASSERT(emb_sjm_nest == NULL || emb_sjm_nest == s->emb_sj_nest)",
          "new_text": "check_interleaving_with_nj(s)",
          "old_line_content": "      DBUG_ASSERT(emb_sjm_nest == NULL || emb_sjm_nest == s->emb_sj_nest);",
          "new_line_content": "        (!idx || !check_interleaving_with_nj(s)))",
          "content_same": false
        },
        {
          "line": 2051,
          "old_api": "add",
          "new_api": "DBUG_ASSERT",
          "old_text": "trace_one_table.add(\"cost_for_plan\", current_read_time).\n        add(\"rows_for_plan\", current_record_count)",
          "new_text": "DBUG_ASSERT(emb_sjm_nest == NULL || emb_sjm_nest == s->emb_sj_nest)",
          "old_line_content": "      trace_one_table.add(\"cost_for_plan\", current_read_time).",
          "new_line_content": "      DBUG_ASSERT(emb_sjm_nest == NULL || emb_sjm_nest == s->emb_sj_nest);",
          "content_same": false
        },
        {
          "line": 2181,
          "old_api": "DBUG_RETURN",
          "new_api": "backout_nj_state",
          "old_text": "DBUG_RETURN(true)",
          "new_text": "backout_nj_state(remaining_tables, s)",
          "old_line_content": "          DBUG_RETURN(true);",
          "new_line_content": "            backout_nj_state(remaining_tables, s);",
          "content_same": false
        },
        {
          "line": 2203,
          "old_api": "DBUG_RETURN",
          "new_api": "DBUG_ASSERT",
          "old_text": "DBUG_RETURN(false)",
          "new_text": "DBUG_ASSERT((remaining_tables_after != 0) ||\n                    ((cur_embedding_map == 0) &&\n                     (join->positions[idx].dups_producing_tables == 0)))",
          "old_line_content": "  DBUG_RETURN(false);",
          "new_line_content": "        DBUG_ASSERT((remaining_tables_after != 0) ||",
          "content_same": false
        },
        {
          "line": 2381,
          "old_api": "best_access_path",
          "new_api": "check_interleaving_with_nj",
          "old_text": "best_access_path(s, remaining_tables, idx, false, record_count,\n                       position)",
          "new_text": "check_interleaving_with_nj(s)",
          "old_line_content": "      best_access_path(s, remaining_tables, idx, false, record_count,",
          "new_line_content": "        (!idx || !check_interleaving_with_nj(s)))  // 4)",
          "content_same": false
        },
        {
          "line": 2473,
          "old_api": "backout_nj_state",
          "new_api": "consider_plan",
          "old_text": "backout_nj_state(remaining_tables, s)",
          "new_text": "consider_plan(idx, current_record_count, current_read_time,\n                        &trace_one_table)",
          "old_line_content": "      backout_nj_state(remaining_tables, s);",
          "new_line_content": "          consider_plan(idx, current_record_count, current_read_time,",
          "content_same": false
        },
        {
          "line": 2489,
          "old_api": "DBUG_RETURN",
          "new_api": "memcpy",
          "old_text": "DBUG_RETURN(~(table_map)0)",
          "new_text": "memcpy(join->best_ref + idx, saved_refs, sizeof(JOIN_TAB*) * (join->tables-idx))",
          "old_line_content": "    DBUG_RETURN(~(table_map)0);",
          "new_line_content": "  memcpy(join->best_ref + idx, saved_refs, sizeof(JOIN_TAB*) * (join->tables-idx));",
          "content_same": false
        },
        {
          "line": 2686,
          "old_api": "memcpy",
          "new_api": "add_alnum",
          "old_text": "memcpy(join->best_positions + first, // stale semijoin strategy here too\n             sjm_nest->nested_join->sjm.positions,\n             sizeof(POSITION) * table_count)",
          "new_text": "trace_final_strategy.add_alnum(\"final_semijoin_strategy\",\n                                     \"MaterializeLookup\")",
          "old_line_content": "      memcpy(join->best_positions + first, // stale semijoin strategy here too",
          "new_line_content": "      trace_final_strategy.add_alnum(\"final_semijoin_strategy\",",
          "content_same": false
        },
        {
          "line": 2709,
          "old_api": "add_alnum",
          "new_api": "semijoin_mat_scan_access_paths",
          "old_text": "trace_final_strategy.add_alnum(\"final_semijoin_strategy\", \"FirstMatch\")",
          "new_text": "semijoin_mat_scan_access_paths(last_inner, tableno,\n                                     remaining_tables, sjm_nest, true,\n                                     &rowcount, &cost)",
          "old_line_content": "      trace_final_strategy.add_alnum(\"final_semijoin_strategy\", \"FirstMatch\");",
          "new_line_content": "      semijoin_mat_scan_access_paths(last_inner, tableno,",
          "content_same": false
        },
        {
          "line": 3022,
          "old_api": "set_prefix_costs",
          "new_api": "best_access_path",
          "old_text": "dst_pos->set_prefix_costs(cost + dst_pos->read_cost +\n                                    rows * ROW_EVALUATE_COST,\n                                    rows)",
          "new_text": "best_access_path(tab, remaining_tables, i, \n                       i < no_jbuf_before,\n                       rowcount * inner_fanout * outer_fanout,\n                       dst_pos)",
          "old_line_content": "          dst_pos->set_prefix_costs(cost + dst_pos->read_cost +",
          "new_line_content": "      best_access_path(tab, remaining_tables, i, ",
          "content_same": false
        },
        {
          "line": 3028,
          "old_api": "DBUG_ASSERT",
          "new_api": "semijoin_loosescan_fill_driving_table_position",
          "old_text": "DBUG_ASSERT(!final)",
          "new_text": "semijoin_loosescan_fill_driving_table_position(tab,\n                                                           remaining_tables,\n                                                           i, dst_pos)",
          "old_line_content": "          DBUG_ASSERT(!final);",
          "new_line_content": "        if (semijoin_loosescan_fill_driving_table_position(tab,",
          "content_same": false
        },
        {
          "line": 3114,
          "old_api": "total_cost",
          "new_api": "my_count_bits",
          "old_text": "positions[first_inner - 1].prefix_cost.total_cost()",
          "new_text": "my_count_bits(sjm_nest->sj_inner_tables)",
          "old_line_content": "    cost=     positions[first_inner - 1].prefix_cost.total_cost();",
          "new_line_content": "  const uint inner_count= my_count_bits(sjm_nest->sj_inner_tables);",
          "content_same": false
        },
        {
          "line": 3413,
          "old_api": "LINT_INIT",
          "new_api": "DBUG_ENTER",
          "old_text": "LINT_INIT(pos->sjm_scan_last_inner)",
          "new_text": "DBUG_ENTER(\"Optimize_table_order::advance_sj_state\")",
          "old_line_content": "    LINT_INIT(pos->sjm_scan_last_inner);",
          "new_line_content": "  DBUG_ENTER(\"Optimize_table_order::advance_sj_state\");",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 513,
          "old_api": null,
          "new_api": "index_only_read_time",
          "old_text": null,
          "new_text": "table->file->index_only_read_time(key, tmp_fanout)",
          "old_line_content": "      {",
          "new_line_content": "            table->file->index_only_read_time(key, tmp_fanout);",
          "content_same": false
        },
        {
          "line": 3073,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(true)",
          "old_line_content": "  @param sjm_nest          Pointer to semi-join nest for inner tables",
          "new_line_content": "  DBUG_RETURN(true);",
          "content_same": false
        },
        {
          "line": 1539,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(!(remaining_tables & tab->table->map))",
          "old_line_content": "  /* ",
          "new_line_content": "  DBUG_ASSERT(!(remaining_tables & tab->table->map));",
          "content_same": false
        },
        {
          "line": 516,
          "old_api": null,
          "new_api": "primary_key_is_clustered",
          "old_text": null,
          "new_text": "table->file->primary_key_is_clustered()",
          "old_line_content": "        continue;",
          "new_line_content": "                 table->file->primary_key_is_clustered())",
          "content_same": false
        },
        {
          "line": 2053,
          "old_api": null,
          "new_api": "best_access_path",
          "old_text": null,
          "new_text": "best_access_path(s, remaining_tables, idx, false, record_count, \n                       position)",
          "old_line_content": "",
          "new_line_content": "      best_access_path(s, remaining_tables, idx, false, record_count, ",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": null,
          "new_api": "is_set",
          "old_text": null,
          "new_text": "table->covering_keys.is_set(key)",
          "old_line_content": "        else",
          "new_line_content": "        if (table->covering_keys.is_set(key))",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": null,
          "new_api": "read_time",
          "old_text": null,
          "new_text": "table->file->read_time(key, 1, (ha_rows)tmp_fanout)",
          "old_line_content": "    else",
          "new_line_content": "            table->file->read_time(key, 1, (ha_rows)tmp_fanout);",
          "content_same": false
        },
        {
          "line": 522,
          "old_api": null,
          "new_api": "min",
          "old_text": null,
          "new_text": "min(tmp_fanout, tab->worst_seeks)",
          "old_line_content": "",
          "new_line_content": "          cur_read_cost= prefix_rowcount * min(tmp_fanout, tab->worst_seeks);",
          "content_same": false
        },
        {
          "line": 2061,
          "old_api": null,
          "new_api": "set_prefix_costs",
          "old_text": null,
          "new_text": "position->set_prefix_costs(current_read_time, current_record_count)",
          "old_line_content": "          Besides, never call advance_sj_state() when calculating the plan",
          "new_line_content": "      position->set_prefix_costs(current_read_time, current_record_count);",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_access_idx.add(\"usable\", false).add(\"chosen\", false)",
          "old_line_content": "",
          "new_line_content": "        trace_access_idx.add(\"usable\", false).add(\"chosen\", false);",
          "content_same": false
        },
        {
          "line": 2063,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_one_table.add(\"cost_for_plan\", current_read_time).\n        add(\"rows_for_plan\", current_record_count)",
          "old_line_content": "        */",
          "new_line_content": "      trace_one_table.add(\"cost_for_plan\", current_read_time).",
          "content_same": false
        },
        {
          "line": 1555,
          "old_api": null,
          "new_api": "my_count_bits",
          "old_text": null,
          "new_text": "my_count_bits(emb_sj_nest->sj_inner_tables)",
          "old_line_content": "      !emb_sj_nest->nested_join->sjm.lookup_allowed)",
          "new_line_content": "  const uint n_tables= my_count_bits(emb_sj_nest->sj_inner_tables);",
          "content_same": false
        },
        {
          "line": 3607,
          "old_api": null,
          "new_api": "uses_materialization",
          "old_text": null,
          "new_text": "new_join_tab->table->pos_in_table_list->uses_materialization()",
          "old_line_content": "        Ok we have all LooseScan sj-nest's inner tables and outer correlated",
          "new_line_content": "        !new_join_tab->table->pos_in_table_list->uses_materialization()) // (8)",
          "content_same": false
        },
        {
          "line": 536,
          "old_api": null,
          "new_api": "prev_record_reads",
          "old_text": null,
          "new_text": "prev_record_reads(join, idx, table_deps)",
          "old_line_content": "    {",
          "new_line_content": "      cur_read_cost= prev_record_reads(join, idx, table_deps);",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(remaining_tables & table->map)",
          "old_line_content": "  Opt_trace_array trace_all_idx(trace, \"indexes\");",
          "new_line_content": "  DBUG_ASSERT(remaining_tables & table->map);",
          "content_same": false
        },
        {
          "line": 2076,
          "old_api": null,
          "new_api": "advance_sj_state",
          "old_text": null,
          "new_text": "advance_sj_state(remaining_tables, s, idx,\n                         &current_record_count, &current_read_time)",
          "old_line_content": "                                       current_read_time,",
          "new_line_content": "        advance_sj_state(remaining_tables, s, idx,",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": null,
          "new_api": "get_bound_sj_equalities",
          "old_text": null,
          "new_text": "get_bound_sj_equalities(tab, excluded_tables | remaining_tables)",
          "old_line_content": "    For each index, we calculate how many key segments of this index",
          "new_line_content": "    get_bound_sj_equalities(tab, excluded_tables | remaining_tables);",
          "content_same": false
        },
        {
          "line": 2080,
          "old_api": null,
          "new_api": "no_semijoin",
          "old_text": null,
          "new_text": "position->no_semijoin()",
          "old_line_content": "        continue;",
          "new_line_content": "        position->no_semijoin();",
          "content_same": false
        },
        {
          "line": 3105,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"Optimize_table_order::semijoin_mat_scan_access_paths\")",
          "old_line_content": "  const uint first_inner= last_inner_tab + 1 - inner_count;",
          "new_line_content": "  DBUG_ENTER(\"Optimize_table_order::semijoin_mat_scan_access_paths\");",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_access_idx.add(\"rows\", cur_fanout).add(\"cost\", cur_ref_cost)",
          "old_line_content": "  return best_ref;",
          "new_line_content": "    trace_access_idx.add(\"rows\", cur_fanout).add(\"cost\", cur_ref_cost);",
          "content_same": false
        },
        {
          "line": 2085,
          "old_api": null,
          "new_api": "print_plan",
          "old_text": null,
          "new_text": "print_plan(join, idx+1,\n                                       current_record_count,\n                                       read_time,\n                                       current_read_time,\n                                       \"prune_by_cost\")",
          "old_line_content": "        the optimal QEPs, thus it results in a non-exhaustive search.",
          "new_line_content": "        DBUG_EXECUTE(\"opt\", print_plan(join, idx+1,",
          "content_same": false
        },
        {
          "line": 2090,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_one_table.add(\"pruned_by_cost\", true)",
          "old_line_content": "            best_read_time > current_read_time ||",
          "new_line_content": "        trace_one_table.add(\"pruned_by_cost\", true);",
          "content_same": false
        },
        {
          "line": 555,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_access_idx.add(\"chosen\", best_ref == start_key)",
          "old_line_content": "  (ROW_EVALUATE_COST) for the rows (estimate) that will be filtered",
          "new_line_content": "    trace_access_idx.add(\"chosen\", best_ref == start_key);",
          "content_same": false
        },
        {
          "line": 2091,
          "old_api": null,
          "new_api": "backout_nj_state",
          "old_text": null,
          "new_text": "backout_nj_state(remaining_tables, s)",
          "old_line_content": "            (idx == join->const_tables &&  // 's' is the first table in the QEP",
          "new_line_content": "        backout_nj_state(remaining_tables, s);",
          "content_same": false
        },
        {
          "line": 3626,
          "old_api": null,
          "new_api": "add_alnum",
          "old_text": null,
          "new_text": "trace_one_strategy.add_alnum(\"strategy\", \"LooseScan\")",
          "old_line_content": "      {",
          "new_line_content": "      trace_one_strategy.add_alnum(\"strategy\", \"LooseScan\");",
          "content_same": false
        },
        {
          "line": 3634,
          "old_api": null,
          "new_api": "semijoin_firstmatch_loosescan_access_paths",
          "old_text": null,
          "new_text": "semijoin_firstmatch_loosescan_access_paths(\n                                      pos->first_loosescan_table, idx,\n                                      remaining_tables, true, false,\n                                      &rowcount, &cost)",
          "old_line_content": "        sj_strategy= SJ_OPT_LOOSE_SCAN;",
          "new_line_content": "      if (semijoin_firstmatch_loosescan_access_paths(",
          "content_same": false
        },
        {
          "line": 1075,
          "old_api": null,
          "new_api": "add_utf8",
          "old_text": null,
          "new_text": "trace_idx.add_utf8(\"index\", table->key_info[key].name)",
          "old_line_content": "    uint max_keypart= 0;",
          "new_line_content": "    trace_idx.add_utf8(\"index\", table->key_info[key].name);",
          "content_same": false
        },
        {
          "line": 3126,
          "old_api": null,
          "new_api": "total_cost",
          "old_text": null,
          "new_text": "positions[first_inner - 1].prefix_cost.total_cost()",
          "old_line_content": "    from a full join, on which the access paths of outer tables are currently",
          "new_line_content": "    cost=     positions[first_inner - 1].prefix_cost.total_cost();",
          "content_same": false
        },
        {
          "line": 3130,
          "old_api": null,
          "new_api": "total_cost",
          "old_text": null,
          "new_text": "sjm_nest->nested_join->sjm.materialization_cost.total_cost()",
          "old_line_content": "  double outer_fanout= 1.0;",
          "new_line_content": "  cost+= sjm_nest->nested_join->sjm.materialization_cost.total_cost() +",
          "content_same": false
        },
        {
          "line": 3131,
          "old_api": null,
          "new_api": "total_cost",
          "old_text": null,
          "new_text": "sjm_nest->nested_join->sjm.scan_cost.total_cost()",
          "old_line_content": "",
          "new_line_content": "         rowcount * sjm_nest->nested_join->sjm.scan_cost.total_cost();",
          "content_same": false
        },
        {
          "line": 3649,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_one_strategy.add(\"cost\", *current_cost).\n          add(\"rows\", *current_rowcount)",
          "old_line_content": "  pos->dups_producing_tables &= ~handled_by_fm_or_ls;",
          "new_line_content": "        trace_one_strategy.add(\"cost\", *current_cost).",
          "content_same": false
        },
        {
          "line": 2118,
          "old_api": null,
          "new_api": "print_plan",
          "old_text": null,
          "new_text": "print_plan(join, idx+1,\n                                         current_record_count,\n                                         read_time,\n                                         current_read_time,\n                                         \"pruned_by_heuristic\")",
          "old_line_content": "        (remaining_tables & ~real_table_bit);",
          "new_line_content": "          DBUG_EXECUTE(\"opt\", print_plan(join, idx+1,",
          "content_same": false
        },
        {
          "line": 3654,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_one_strategy.add(\"chosen\", sj_strategy == SJ_OPT_LOOSE_SCAN)",
          "old_line_content": "                                          new_join_tab, idx);",
          "new_line_content": "      trace_one_strategy.add(\"chosen\", sj_strategy == SJ_OPT_LOOSE_SCAN);",
          "content_same": false
        },
        {
          "line": 2123,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_one_table.add(\"pruned_by_heuristic\", true)",
          "old_line_content": "          If possible, use heuristic to avoid a full expansion of partial QEP.",
          "new_line_content": "          trace_one_table.add(\"pruned_by_heuristic\", true);",
          "content_same": false
        },
        {
          "line": 2124,
          "old_api": null,
          "new_api": "backout_nj_state",
          "old_text": null,
          "new_text": "backout_nj_state(remaining_tables, s)",
          "old_line_content": "          Evaluate a simplified EQ_REF extension of QEP if:",
          "new_line_content": "          backout_nj_state(remaining_tables, s);",
          "content_same": false
        },
        {
          "line": 2637,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"Optimize_table_order::fix_semijoin_strategies\")",
          "old_line_content": "",
          "new_line_content": "  DBUG_ENTER(\"Optimize_table_order::fix_semijoin_strategies\");",
          "content_same": false
        },
        {
          "line": 3148,
          "old_api": null,
          "new_api": "add_utf8_table",
          "old_text": null,
          "new_text": "trace_one_table.add_utf8_table(tab->table)",
          "old_line_content": "  *newcost=  cost;",
          "new_line_content": "    trace_one_table.add_utf8_table(tab->table);",
          "content_same": false
        },
        {
          "line": 2639,
          "old_api": null,
          "new_api": "is_empty",
          "old_text": null,
          "new_text": "join->select_lex->sj_nests.is_empty()",
          "old_line_content": "        pos->sj_strategy == SJ_OPT_NONE)",
          "new_line_content": "  if (join->select_lex->sj_nests.is_empty())",
          "content_same": false
        },
        {
          "line": 2640,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(false)",
          "old_line_content": "    {",
          "new_line_content": "    DBUG_RETURN(false);",
          "content_same": false
        },
        {
          "line": 3151,
          "old_api": null,
          "new_api": "best_access_path",
          "old_text": null,
          "new_text": "best_access_path(tab, remaining_tables, i, false,\n                     rowcount * inner_fanout * outer_fanout, dst_pos)",
          "old_line_content": "}",
          "new_line_content": "    best_access_path(tab, remaining_tables, i, false,",
          "content_same": false
        },
        {
          "line": 3665,
          "old_api": null,
          "new_api": "semijoin_order_allows_materialization",
          "old_text": null,
          "new_text": "semijoin_order_allows_materialization(join, remaining_tables,\n                                          new_join_tab, idx)",
          "old_line_content": "      records, so at point (1) we'll get the fanout from sj-inner tables (ie",
          "new_line_content": "    semijoin_order_allows_materialization(join, remaining_tables,",
          "content_same": false
        },
        {
          "line": 1112,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(max_keypart <= keypart)",
          "old_line_content": "      nest.",
          "new_line_content": "        DBUG_ASSERT(max_keypart <= keypart); // see sort_keyuse()",
          "content_same": false
        },
        {
          "line": 2658,
          "old_api": null,
          "new_api": "LINT_INIT",
          "old_text": null,
          "new_text": "LINT_INIT(first)",
          "old_line_content": "        materialization. The target QEP rules (it has seen more tables), but",
          "new_line_content": "    LINT_INIT(first);",
          "content_same": false
        },
        {
          "line": 2662,
          "old_api": null,
          "new_api": "my_count_bits",
          "old_text": null,
          "new_text": "my_count_bits(sjm_nest->sj_inner_tables)",
          "old_line_content": "        fixed for the first table of that range right after the memcpy(), and",
          "new_line_content": "      const uint table_count= my_count_bits(sjm_nest->sj_inner_tables);",
          "content_same": false
        },
        {
          "line": 3692,
          "old_api": null,
          "new_api": "add_alnum",
          "old_text": null,
          "new_text": "Opt_trace_object(trace).add_alnum(\"strategy\", \"MaterializeScan\").\n      add_alnum(\"choice\", \"deferred\")",
          "old_line_content": "      add(\"duplicate_tables_left\", pos->dups_producing_tables != 0);",
          "new_line_content": "    Opt_trace_object(trace).add_alnum(\"strategy\", \"MaterializeScan\").",
          "content_same": false
        },
        {
          "line": 2157,
          "old_api": null,
          "new_api": "eq_ref_extension_by_limited_search",
          "old_text": null,
          "new_text": "eq_ref_extension_by_limited_search(\n                                             remaining_tables_after,\n                                             idx + 1,\n                                             current_record_count,\n                                             current_read_time,\n                                             current_search_depth - 1)",
          "old_line_content": "              goto done;",
          "new_line_content": "              eq_ref_extension_by_limited_search(",
          "content_same": false
        },
        {
          "line": 3186,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"Optimize_table_order::semijoin_mat_lookup_access_paths\")",
          "old_line_content": "  {",
          "new_line_content": "  DBUG_ENTER(\"Optimize_table_order::semijoin_mat_lookup_access_paths\");",
          "content_same": false
        },
        {
          "line": 3699,
          "old_api": null,
          "new_api": "semijoin_mat_lookup_access_paths",
          "old_text": null,
          "new_text": "semijoin_mat_lookup_access_paths(idx, emb_sj_nest, &rowcount, &cost)",
          "old_line_content": "        after the QEP has been chosen.",
          "new_line_content": "    semijoin_mat_lookup_access_paths(idx, emb_sj_nest, &rowcount, &cost);",
          "content_same": false
        },
        {
          "line": 2164,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(true)",
          "old_line_content": "                                           current_record_count,",
          "new_line_content": "              DBUG_RETURN(true);      // Failed",
          "content_same": false
        },
        {
          "line": 3188,
          "old_api": null,
          "new_api": "my_count_bits",
          "old_text": null,
          "new_text": "my_count_bits(sjm_nest->sj_inner_tables)",
          "old_line_content": "    rowcount= join->positions[first_inner - 1].prefix_record_count;",
          "new_line_content": "  const uint inner_count= my_count_bits(sjm_nest->sj_inner_tables);",
          "content_same": false
        },
        {
          "line": 2166,
          "old_api": null,
          "new_api": "backout_nj_state",
          "old_text": null,
          "new_text": "backout_nj_state(remaining_tables, s)",
          "old_line_content": "                                           current_read_time,",
          "new_line_content": "            backout_nj_state(remaining_tables, s);",
          "content_same": false
        },
        {
          "line": 2679,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(pos - table_count + 1, sjm_nest->nested_join->sjm.positions, \n             sizeof(POSITION) * table_count)",
          "old_line_content": "      const uint last_inner= pos->sjm_scan_last_inner;",
          "new_line_content": "      memcpy(pos - table_count + 1, sjm_nest->nested_join->sjm.positions, ",
          "content_same": false
        },
        {
          "line": 3702,
          "old_api": null,
          "new_api": "add_alnum",
          "old_text": null,
          "new_text": "trace_one_strategy.add_alnum(\"strategy\", \"MaterializeLookup\").\n      add(\"cost\", cost).add(\"rows\", rowcount).\n      add(\"duplicate_tables_left\", pos->dups_producing_tables != 0)",
          "old_line_content": "      *current_cost=     cost;",
          "new_line_content": "    trace_one_strategy.add_alnum(\"strategy\", \"MaterializeLookup\").",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": null,
          "new_api": "add_alnum",
          "old_text": null,
          "new_text": "trace_access_scan->add_alnum(\"access_type\", \"range\")",
          "old_line_content": "       (tab->found_records - rows_after_filtering) * ROW_EVALUATE_COST);",
          "new_line_content": "    trace_access_scan->add_alnum(\"access_type\", \"range\");",
          "content_same": false
        },
        {
          "line": 3199,
          "old_api": null,
          "new_api": "total_cost",
          "old_text": null,
          "new_text": "join->positions[first_inner - 1].prefix_cost.total_cost()",
          "old_line_content": "",
          "new_line_content": "    cost=     join->positions[first_inner - 1].prefix_cost.total_cost();",
          "content_same": false
        },
        {
          "line": 2175,
          "old_api": null,
          "new_api": "print_plan",
          "old_text": null,
          "new_text": "print_plan(join, idx+1,\n                                           current_record_count,\n                                           read_time,\n                                           current_read_time,\n                                           \"pruned_by_eq_ref_heuristic\")",
          "old_line_content": "        Opt_trace_array trace_rest(trace, \"rest_of_plan\");",
          "new_line_content": "            DBUG_EXECUTE(\"opt\", print_plan(join, idx+1,",
          "content_same": false
        },
        {
          "line": 3203,
          "old_api": null,
          "new_api": "total_cost",
          "old_text": null,
          "new_text": "sjm_nest->nested_join->sjm.materialization_cost.total_cost()",
          "old_line_content": "  and calculate rowcount and cost based on these.",
          "new_line_content": "  cost+= sjm_nest->nested_join->sjm.materialization_cost.total_cost() +",
          "content_same": false
        },
        {
          "line": 2180,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_one_table.add(\"pruned_by_eq_ref_heuristic\", true)",
          "old_line_content": "                                             current_search_depth - 1))",
          "new_line_content": "            trace_one_table.add(\"pruned_by_eq_ref_heuristic\", true);",
          "content_same": false
        },
        {
          "line": 3204,
          "old_api": null,
          "new_api": "total_cost",
          "old_text": null,
          "new_text": "sjm_nest->nested_join->sjm.lookup_cost.total_cost()",
          "old_line_content": "",
          "new_line_content": "         rowcount * sjm_nest->nested_join->sjm.lookup_cost.total_cost();",
          "content_same": false
        },
        {
          "line": 2694,
          "old_api": null,
          "new_api": "my_count_bits",
          "old_text": null,
          "new_text": "my_count_bits(sjm_nest->sj_inner_tables)",
          "old_line_content": "                                     \"MaterializeScan\");",
          "new_line_content": "      const uint table_count= my_count_bits(sjm_nest->sj_inner_tables);",
          "content_same": false
        },
        {
          "line": 3718,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_one_strategy.add(\"chosen\", sj_strategy == SJ_OPT_MATERIALIZE_LOOKUP)",
          "old_line_content": "    pos->sjm_scan_need_tables= 0;",
          "new_line_content": "    trace_one_strategy.add(\"chosen\", sj_strategy == SJ_OPT_MATERIALIZE_LOOKUP);",
          "content_same": false
        },
        {
          "line": 2696,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT((join->best_positions + first)->table->emb_sj_nest ==\n                  sjm_nest)",
          "old_line_content": "      double rowcount, cost;",
          "new_line_content": "      DBUG_ASSERT((join->best_positions + first)->table->emb_sj_nest ==",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": null,
          "new_api": "add_alnum",
          "old_text": null,
          "new_text": "trace_access_scan->add_alnum(\"access_type\", \"scan\")",
          "old_line_content": "        - read the whole table record ",
          "new_line_content": "    trace_access_scan->add_alnum(\"access_type\", \"scan\");",
          "content_same": false
        },
        {
          "line": 2698,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(join->best_positions + first, // stale semijoin strategy here too\n             sjm_nest->nested_join->sjm.positions,\n             sizeof(POSITION) * table_count)",
          "old_line_content": "                                     remaining_tables, sjm_nest, true,",
          "new_line_content": "      memcpy(join->best_positions + first, // stale semijoin strategy here too",
          "content_same": false
        },
        {
          "line": 2188,
          "old_api": null,
          "new_api": "best_extension_by_limited_search",
          "old_text": null,
          "new_text": "best_extension_by_limited_search(remaining_tables_after,\n                                             idx + 1,\n                                             current_record_count,\n                                             current_read_time,\n                                             current_search_depth - 1)",
          "old_line_content": "          If plan is complete, there should be no \"open\" outer join nest, and",
          "new_line_content": "        if (best_extension_by_limited_search(remaining_tables_after,",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": null,
          "new_api": "LOWER_BITS",
          "old_text": null,
          "new_text": "LOWER_BITS(ulonglong,\n                   tab->emb_sj_nest->nested_join->sj_inner_exprs.elements)",
          "old_line_content": "         ~(bound_keyparts | handled_keyparts)) != 0)                    // (2)",
          "new_line_content": "        LOWER_BITS(ulonglong,",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": null,
          "new_api": "read_time",
          "old_text": null,
          "new_text": "table->file->read_time(tab->ref.key, 1, tab->records)",
          "old_line_content": "        satisfy the WHERE condition, but this is added in",
          "new_line_content": "      table->file->read_time(tab->ref.key, 1, tab->records) : // index scan",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": null,
          "new_api": "scan_time",
          "old_text": null,
          "new_text": "table->file->scan_time()",
          "old_line_content": "        greedy_search().",
          "new_line_content": "      table->file->scan_time();                               // table scan",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_idx.add(\"index_handles_needed_semijoin_equalities\", false)",
          "old_line_content": "      continue;",
          "new_line_content": "      trace_idx.add(\"index_handles_needed_semijoin_equalities\", false);",
          "content_same": false
        },
        {
          "line": 2193,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(true)",
          "old_line_content": "                     (join->positions[idx].dups_producing_tables == 0)));",
          "new_line_content": "          DBUG_RETURN(true);",
          "content_same": false
        },
        {
          "line": 1680,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(true)",
          "old_line_content": "      */",
          "new_line_content": "      DBUG_RETURN(true);",
          "content_same": false
        },
        {
          "line": 2705,
          "old_api": null,
          "new_api": "add_alnum",
          "old_text": null,
          "new_text": "trace_final_strategy.add_alnum(\"final_semijoin_strategy\",\n                                     \"MaterializeScan\")",
          "old_line_content": "      join->best_positions[first].sj_strategy= SJ_OPT_FIRST_MATCH;",
          "new_line_content": "      trace_final_strategy.add_alnum(\"final_semijoin_strategy\",",
          "content_same": false
        },
        {
          "line": 1677,
          "old_api": null,
          "new_api": "best_extension_by_limited_search",
          "old_text": null,
          "new_text": "best_extension_by_limited_search(remaining_tables, idx,\n                                         record_count, read_time,\n                                         search_depth)",
          "old_line_content": "      /*",
          "new_line_content": "    if (best_extension_by_limited_search(remaining_tables, idx,",
          "content_same": false
        },
        {
          "line": 1685,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(join->best_read < DBL_MAX)",
          "old_line_content": "",
          "new_line_content": "    DBUG_ASSERT(join->best_read < DBL_MAX); ",
          "content_same": false
        },
        {
          "line": 2197,
          "old_api": null,
          "new_api": "consider_plan",
          "old_text": null,
          "new_text": "consider_plan(idx, current_record_count, current_read_time,\n                      &trace_one_table)",
          "old_line_content": "  }",
          "new_line_content": "        consider_plan(idx, current_record_count, current_read_time,",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_idx.add(\"some_index_part_used\", false)",
          "old_line_content": "    if (tab->quick && tab->quick->index == key &&",
          "new_line_content": "      trace_idx.add(\"some_index_part_used\", false);",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": null,
          "new_api": "LOWER_BITS",
          "old_text": null,
          "new_text": "LOWER_BITS(key_part_map, max_keypart + 1)",
          "old_line_content": "      quick_uses_applicable_index= true;",
          "new_line_content": "    if ((LOWER_BITS(key_part_map, max_keypart + 1) &                    // (2)",
          "content_same": false
        },
        {
          "line": 1179,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_idx.add(\"index_can_remove_duplicates\", false)",
          "old_line_content": "",
          "new_line_content": "      trace_idx.add(\"index_can_remove_duplicates\", false);",
          "content_same": false
        },
        {
          "line": 1693,
          "old_api": null,
          "new_api": "print_plan",
          "old_text": null,
          "new_text": "print_plan(join, n_tables, record_count, read_time,\n                                     read_time, \"optimal\")",
          "old_line_content": "    */",
          "new_line_content": "      DBUG_EXECUTE(\"opt\", print_plan(join, n_tables, record_count, read_time,",
          "content_same": false
        },
        {
          "line": 3741,
          "old_api": null,
          "new_api": "add_alnum",
          "old_text": null,
          "new_text": "trace_one_strategy.add_alnum(\"strategy\", \"MaterializeScan\")",
          "old_line_content": "      In the second case, we pick this strategy unconditionally because",
          "new_line_content": "    trace_one_strategy.add_alnum(\"strategy\", \"MaterializeScan\");",
          "content_same": false
        },
        {
          "line": 1695,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(false)",
          "old_line_content": "",
          "new_line_content": "      DBUG_RETURN(false);",
          "content_same": false
        },
        {
          "line": 2207,
          "old_api": null,
          "new_api": "backout_nj_state",
          "old_text": null,
          "new_text": "backout_nj_state(remaining_tables, s)",
          "old_line_content": "/**",
          "new_line_content": "      backout_nj_state(remaining_tables, s);",
          "content_same": false
        },
        {
          "line": 2721,
          "old_api": null,
          "new_api": "add_alnum",
          "old_text": null,
          "new_text": "trace_final_strategy.add_alnum(\"final_semijoin_strategy\", \"FirstMatch\")",
          "old_line_content": "      Opt_trace_object trace_final_strategy(trace);",
          "new_line_content": "      trace_final_strategy.add_alnum(\"final_semijoin_strategy\", \"FirstMatch\");",
          "content_same": false
        },
        {
          "line": 1186,
          "old_api": null,
          "new_api": "get_type",
          "old_text": null,
          "new_text": "tab->quick->get_type()",
          "old_line_content": "        // @TODO use rec-per-key-based fanout calculations",
          "new_line_content": "        tab->quick->get_type() == QUICK_SELECT_I::QS_TYPE_RANGE)",
          "content_same": false
        },
        {
          "line": 3743,
          "old_api": null,
          "new_api": "semijoin_mat_scan_access_paths",
          "old_text": null,
          "new_text": "semijoin_mat_scan_access_paths(pos->sjm_scan_last_inner, idx,\n                                   remaining_tables, sjm_nest, false,\n                                   &rowcount, &cost)",
          "old_line_content": "      duplicate removal is not an apples-to-apples comparison.",
          "new_line_content": "    semijoin_mat_scan_access_paths(pos->sjm_scan_last_inner, idx,",
          "content_same": false
        },
        {
          "line": 3746,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_one_strategy.add(\"cost\", cost).\n      add(\"rows\", rowcount).\n      add(\"duplicate_tables_left\", pos->dups_producing_tables != 0)",
          "old_line_content": "    {",
          "new_line_content": "    trace_one_strategy.add(\"cost\", cost).",
          "content_same": false
        },
        {
          "line": 2213,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(join->best_ref + idx, saved_refs,\n         sizeof(JOIN_TAB*) * (join->tables-idx))",
          "old_line_content": "  1::1 relation between the rows being joined. Assuming we",
          "new_line_content": "  memcpy(join->best_ref + idx, saved_refs,",
          "content_same": false
        },
        {
          "line": 2725,
          "old_api": null,
          "new_api": "semijoin_firstmatch_loosescan_access_paths",
          "old_text": null,
          "new_text": "semijoin_firstmatch_loosescan_access_paths(first, tableno,\n                                        remaining_tables, false, true,\n                                        &rowcount, &cost)",
          "old_line_content": "      double rowcount, cost;",
          "new_line_content": "      (void)semijoin_firstmatch_loosescan_access_paths(first, tableno,",
          "content_same": false
        },
        {
          "line": 2215,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(false)",
          "old_line_content": "  sequence, without other join types inbetween. Then all of ",
          "new_line_content": "  DBUG_RETURN(false);",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": null,
          "new_api": "cache_record_length",
          "old_text": null,
          "new_text": "cache_record_length(join,idx)",
          "old_line_content": "  *fanout= rows_after_filtering;",
          "new_line_content": "        1.0 + ((double) cache_record_length(join,idx) *",
          "content_same": false
        },
        {
          "line": 3244,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"Optimize_table_order::semijoin_dupsweedout_access_paths\")",
          "old_line_content": "  else",
          "new_line_content": "  DBUG_ENTER(\"Optimize_table_order::semijoin_dupsweedout_access_paths\");",
          "content_same": false
        },
        {
          "line": 2734,
          "old_api": null,
          "new_api": "add_alnum",
          "old_text": null,
          "new_text": "trace_final_strategy.add_alnum(\"final_semijoin_strategy\", \"LooseScan\")",
          "old_line_content": "    }",
          "new_line_content": "      trace_final_strategy.add_alnum(\"final_semijoin_strategy\", \"LooseScan\");",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_access_scan->add(\"using_join_cache\", true)",
          "old_line_content": "  plan and add this path to the plan.",
          "new_line_content": "      trace_access_scan->add(\"using_join_cache\", true);",
          "content_same": false
        },
        {
          "line": 689,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_access_scan->add(\"buffers_needed\", (ulong)buffer_count)",
          "old_line_content": "",
          "new_line_content": "      trace_access_scan->add(\"buffers_needed\", (ulong)buffer_count);",
          "content_same": false
        },
        {
          "line": 2738,
          "old_api": null,
          "new_api": "semijoin_firstmatch_loosescan_access_paths",
          "old_text": null,
          "new_text": "semijoin_firstmatch_loosescan_access_paths(first, tableno,\n                                        remaining_tables, true, true,\n                                        &rowcount, &cost)",
          "old_line_content": "        Duplicate Weedout starting at pos->first_dupsweedout_table, ending at",
          "new_line_content": "      (void)semijoin_firstmatch_loosescan_access_paths(first, tableno,",
          "content_same": false
        },
        {
          "line": 1204,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_ref.add(\"chosen\", true)",
          "old_line_content": "      */",
          "new_line_content": "        trace_ref.add(\"chosen\", true);",
          "content_same": false
        },
        {
          "line": 3764,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_one_strategy.add(\"chosen\", sj_strategy == SJ_OPT_MATERIALIZE_SCAN)",
          "old_line_content": "        pos->first_dupsweedout_table= idx;",
          "new_line_content": "    trace_one_strategy.add(\"chosen\", sj_strategy == SJ_OPT_MATERIALIZE_SCAN);",
          "content_same": false
        },
        {
          "line": 1207,
          "old_api": null,
          "new_api": "is_set",
          "old_text": null,
          "new_text": "tab->table->covering_keys.is_set(key)",
          "old_line_content": "      // Calculate the cost of complete loose index scan.",
          "new_line_content": "    else if (tab->table->covering_keys.is_set(key))",
          "content_same": false
        },
        {
          "line": 2745,
          "old_api": null,
          "new_api": "my_count_bits",
          "old_text": null,
          "new_text": "my_count_bits(first_pos->table->emb_sj_nest->sj_inner_tables)",
          "old_line_content": "      Opt_trace_object trace_final_strategy(trace);",
          "new_line_content": "        my_count_bits(first_pos->table->emb_sj_nest->sj_inner_tables);",
          "content_same": false
        },
        {
          "line": 3258,
          "old_api": null,
          "new_api": "total_cost",
          "old_text": null,
          "new_text": "join->positions[first_tab - 1].prefix_cost.total_cost()",
          "old_line_content": "       // dependencies between these tables, the fanout for the outer",
          "new_line_content": "    cost=     join->positions[first_tab - 1].prefix_cost.total_cost();",
          "content_same": false
        },
        {
          "line": 1723,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(!is_interleave_error)",
          "old_line_content": "    */",
          "new_line_content": "    DBUG_ASSERT(!is_interleave_error);",
          "content_same": false
        },
        {
          "line": 1730,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT((pos != NULL))",
          "old_line_content": "    read_time+=    join->positions[idx].read_cost",
          "new_line_content": "    DBUG_ASSERT((pos != NULL)); // should always find 'best_table'",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": null,
          "new_api": "rows2double",
          "old_text": null,
          "new_text": "rows2double(tab->table->file->stats.records)",
          "old_line_content": "      if (rpc != 0)",
          "new_line_content": "      double rowcount= rows2double(tab->table->file->stats.records);",
          "content_same": false
        },
        {
          "line": 2758,
          "old_api": null,
          "new_api": "add_alnum",
          "old_text": null,
          "new_text": "trace_final_strategy.add_alnum(\"final_semijoin_strategy\",\n                                     \"DuplicateWeedout\")",
          "old_line_content": "      handled_tables|= join->best_positions[i].table->table->map;",
          "new_line_content": "      trace_final_strategy.add_alnum(\"final_semijoin_strategy\",",
          "content_same": false
        },
        {
          "line": 1736,
          "old_api": null,
          "new_api": "memmove",
          "old_text": null,
          "new_text": "memmove(join->best_ref + idx + 1, join->best_ref + idx,\n            sizeof(JOIN_TAB*) * (best_idx - idx))",
          "old_line_content": "",
          "new_line_content": "    memmove(join->best_ref + idx + 1, join->best_ref + idx,",
          "content_same": false
        },
        {
          "line": 3786,
          "old_api": null,
          "new_api": "add_alnum",
          "old_text": null,
          "new_text": "trace_one_strategy.add_alnum(\"strategy\", \"DuplicatesWeedout\")",
          "old_line_content": "        We need to calculate the cost in case #2 also because we need to make",
          "new_line_content": "      trace_one_strategy.add_alnum(\"strategy\", \"DuplicatesWeedout\");",
          "content_same": false
        },
        {
          "line": 1235,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_cov_scan.add(\"cost\", cost)",
          "old_line_content": "    else",
          "new_line_content": "      trace_cov_scan.add(\"cost\", cost);",
          "content_same": false
        },
        {
          "line": 1749,
          "old_api": null,
          "new_api": "print_plan",
          "old_text": null,
          "new_text": "print_plan(join, idx, record_count, read_time, \n                                   read_time, \"extended\")",
          "old_line_content": "                               partial join order",
          "new_line_content": "    DBUG_EXECUTE(\"opt\", print_plan(join, idx, record_count, read_time, ",
          "content_same": false
        },
        {
          "line": 2776,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(remaining_tables == (join->all_table_map&~join->const_table_map))",
          "old_line_content": "    with backout_nj_state().",
          "new_line_content": "  DBUG_ASSERT(remaining_tables == (join->all_table_map&~join->const_table_map));",
          "content_same": false
        },
        {
          "line": 2778,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(FALSE)",
          "old_line_content": "    The function assumes that both current partial join order and its",
          "new_line_content": "  DBUG_RETURN(FALSE);",
          "content_same": false
        },
        {
          "line": 3802,
          "old_api": null,
          "new_api": "semijoin_dupsweedout_access_paths",
          "old_text": null,
          "new_text": "semijoin_dupsweedout_access_paths(pos->first_dupsweedout_table, idx,\n                                        remaining_tables, &rowcount, &cost)",
          "old_line_content": "        add(\"rows\", rowcount).",
          "new_line_content": "      semijoin_dupsweedout_access_paths(pos->first_dupsweedout_table, idx,",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_cov_scan.add(\"chosen\", true)",
          "old_line_content": "",
          "new_line_content": "        trace_cov_scan.add(\"chosen\", true);",
          "content_same": false
        },
        {
          "line": 3812,
          "old_api": null,
          "new_api": "trace_one_strategy.\n        add(\"cost\", cost).\n        add(\"rows\", rowcount).\n        add(\"duplicate_tables_left\", pos->dups_producing_tables != 0)",
          "old_text": null,
          "new_text": "trace_one_strategy.\n        add(\"cost\", cost).\n        add(\"rows\", rowcount).\n        add(\"duplicate_tables_left\", pos->dups_producing_tables != 0)",
          "old_line_content": "        */",
          "new_line_content": "      trace_one_strategy.",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": null,
          "new_api": "optimizer_switch_flag",
          "old_text": null,
          "new_text": "thd->optimizer_switch_flag(OPTIMIZER_SWITCH_BNL)",
          "old_line_content": "",
          "new_line_content": "    !thd->optimizer_switch_flag(OPTIMIZER_SWITCH_BNL);               // 2",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_range.add(\"cost\", tab->quick->read_time)",
          "old_line_content": "  }",
          "new_line_content": "    trace_range.add(\"cost\", tab->quick->read_time);",
          "content_same": false
        },
        {
          "line": 1267,
          "old_api": null,
          "new_api": "rows2double",
          "old_text": null,
          "new_text": "rows2double(tab->quick->records)",
          "old_line_content": "/**",
          "new_line_content": "      pos->fanout= rows2double(tab->quick->records);",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": null,
          "new_api": "find_best_ref",
          "old_text": null,
          "new_text": "find_best_ref(tab, remaining_tables, idx, prefix_rowcount,\n                            &found_condition, &ref_depend_map, &used_key_parts)",
          "old_line_content": "    Don't test table scan if it can't be better.",
          "new_line_content": "    best_ref= find_best_ref(tab, remaining_tables, idx, prefix_rowcount,",
          "content_same": false
        },
        {
          "line": 3827,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_one_strategy.add(\"chosen\", sj_strategy == SJ_OPT_DUPS_WEEDOUT)",
          "old_line_content": "",
          "new_line_content": "      trace_one_strategy.add(\"chosen\", sj_strategy == SJ_OPT_DUPS_WEEDOUT);",
          "content_same": false
        },
        {
          "line": 1270,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_range.add(\"chosen\", true)",
          "old_line_content": "  The function checks user-configurable parameters that control the search",
          "new_line_content": "      trace_range.add(\"chosen\", true);",
          "content_same": false
        },
        {
          "line": 3847,
          "old_api": null,
          "new_api": "set_prefix_costs",
          "old_text": null,
          "new_text": "pos->set_prefix_costs(*current_cost, *current_rowcount)",
          "old_line_content": "  function for the first table in join order (for which ",
          "new_line_content": "    pos->set_prefix_costs(*current_cost, *current_rowcount);",
          "content_same": false
        },
        {
          "line": 1303,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(join->best_positions, join->positions,\n\t   sizeof(POSITION) * join->const_tables)",
          "old_line_content": "  if (emb_sjm_nest)",
          "new_line_content": "    memcpy(join->best_positions, join->positions,",
          "content_same": false
        },
        {
          "line": 1307,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(false)",
          "old_line_content": "    */",
          "new_line_content": "    DBUG_RETURN(false);",
          "content_same": false
        },
        {
          "line": 1312,
          "old_api": null,
          "new_api": "test",
          "old_text": null,
          "new_text": "test(join->select_options & SELECT_STRAIGHT_JOIN)",
          "old_line_content": "  }",
          "new_line_content": "  const bool straight_join= test(join->select_options & SELECT_STRAIGHT_JOIN);",
          "content_same": false
        },
        {
          "line": 1827,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_obj->add(\"sort_cost\", record_count).\n      add(\"new_cost_for_plan\", read_time)",
          "old_line_content": "    /*",
          "new_line_content": "    trace_obj->add(\"sort_cost\", record_count).",
          "content_same": false
        },
        {
          "line": 2339,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"Optimize_table_order::eq_ref_extension_by_limited_search\")",
          "old_line_content": "  */",
          "new_line_content": "  DBUG_ENTER(\"Optimize_table_order::eq_ref_extension_by_limited_search\");",
          "content_same": false
        },
        {
          "line": 2342,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "  JOIN_TAB *s;",
          "new_line_content": "    DBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": null,
          "new_api": "merge_sort",
          "old_text": null,
          "new_text": "merge_sort(join->best_ref + join->const_tables,\n               join->best_ref + join->tables,\n               Join_tab_compare_embedded_first(emb_sjm_nest))",
          "old_line_content": "        Apply heuristic: pre-sort all access plans with respect to the number of",
          "new_line_content": "    merge_sort(join->best_ref + join->const_tables,",
          "content_same": false
        },
        {
          "line": 1833,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_obj->add(\"chosen\", chosen)",
          "old_line_content": "    join->best_read= read_time - 0.001;",
          "new_line_content": "  trace_obj->add(\"chosen\", chosen);",
          "content_same": false
        },
        {
          "line": 1322,
          "old_api": null,
          "new_api": "Join_tab_compare_embedded_first",
          "old_text": null,
          "new_text": "Join_tab_compare_embedded_first(emb_sjm_nest)",
          "old_line_content": "    */",
          "new_line_content": "               Join_tab_compare_embedded_first(emb_sjm_nest));",
          "content_same": false
        },
        {
          "line": 2344,
          "old_api": null,
          "new_api": "is_empty",
          "old_text": null,
          "new_text": "join->select_lex->sj_nests.is_empty()",
          "old_line_content": "  // Save 'best_ref[]' as we has to restore before return.",
          "new_line_content": "  const bool has_sj= !(join->select_lex->sj_nests.is_empty() || emb_sjm_nest);",
          "content_same": false
        },
        {
          "line": 1836,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy((uchar*) join->best_positions, (uchar*) join->positions,\n            sizeof(POSITION) * (idx + 1))",
          "old_line_content": "  }",
          "new_line_content": "    memcpy((uchar*) join->best_positions, (uchar*) join->positions,",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": null,
          "new_api": "add_alnum",
          "old_text": null,
          "new_text": "trace_access_scan.add_alnum(\"access_type\", tab->quick ? \"range\" : \"scan\").\n      add(\"cost\", tab->read_time + tab->found_records * ROW_EVALUATE_COST).\n      add(\"rows\", tab->found_records).\n      add(\"chosen\", false).\n      add_alnum(\"cause\", \"cost\")",
          "old_line_content": "      add_alnum(\"cause\", \"heuristic_index_cheaper\");",
          "new_line_content": "    trace_access_scan.add_alnum(\"access_type\", tab->quick ? \"range\" : \"scan\").",
          "content_same": false
        },
        {
          "line": 2357,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(saved_refs, join->best_ref + idx,\n         sizeof(JOIN_TAB*) * (join->tables-idx))",
          "old_line_content": "    swap_variables(JOIN_TAB*, join->best_ref[idx], *pos);",
          "new_line_content": "  memcpy(saved_refs, join->best_ref + idx,",
          "content_same": false
        },
        {
          "line": 1336,
          "old_api": null,
          "new_api": "merge_sort",
          "old_text": null,
          "new_text": "merge_sort(join->best_ref + join->const_tables,\n                 join->best_ref + join->tables,\n                 Join_tab_compare_straight())",
          "old_line_content": "  Opt_trace_array",
          "new_line_content": "      merge_sort(join->best_ref + join->const_tables,",
          "content_same": false
        },
        {
          "line": 1849,
          "old_api": null,
          "new_api": "print_plan",
          "old_text": null,
          "new_text": "print_plan(join, idx+1,\n                                 record_count,\n                                 read_time,\n                                 read_time,\n                                 \"full_plan\")",
          "old_line_content": "    The procedure searches for the optimal ordering of the query tables in set",
          "new_line_content": "  DBUG_EXECUTE(\"opt\", print_plan(join, idx+1,",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": null,
          "new_api": "add_alnum",
          "old_text": null,
          "new_text": "trace_access_scan.add_alnum(\"access_type\", \"range\").\n      add(\"chosen\", false).\n      add_alnum(\"cause\", \"heuristic_index_cheaper\")",
          "old_line_content": "      add_alnum(\"cause\", \"covering_index_better_than_full_scan\");",
          "new_line_content": "    trace_access_scan.add_alnum(\"access_type\", \"range\").",
          "content_same": false
        },
        {
          "line": 1338,
          "old_api": null,
          "new_api": "Join_tab_compare_straight",
          "old_text": null,
          "new_text": "Join_tab_compare_straight()",
          "old_line_content": "               Opt_trace_context::GREEDY_SEARCH);",
          "new_line_content": "                 Join_tab_compare_straight());",
          "content_same": false
        },
        {
          "line": 1342,
          "old_api": null,
          "new_api": "Join_tab_compare_default",
          "old_text": null,
          "new_text": "Join_tab_compare_default()",
          "old_line_content": "  {",
          "new_line_content": "                 Join_tab_compare_default());",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": null,
          "new_api": "is_clear_all",
          "old_text": null,
          "new_text": "table->covering_keys.is_clear_all()",
          "old_line_content": "      add(\"chosen\", false).",
          "new_line_content": "      !table->covering_keys.is_clear_all() && best_ref &&                 //(3)",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": null,
          "new_api": "get_type",
          "old_text": null,
          "new_text": "tab->quick->get_type()",
          "old_line_content": "  }",
          "new_line_content": "       (tab->quick->get_type() == QUICK_SELECT_I::QS_TYPE_ROR_INTERSECT &&//(3)",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": null,
          "new_api": "add_alnum",
          "old_text": null,
          "new_text": "trace_access_scan.add_alnum(\"access_type\", tab->quick ? \"range\" : \"scan\").\n      add(\"chosen\", false).\n      add_alnum(\"cause\", \"covering_index_better_than_full_scan\")",
          "old_line_content": "    /*",
          "new_line_content": "    trace_access_scan.add_alnum(\"access_type\", tab->quick ? \"range\" : \"scan\").",
          "content_same": false
        },
        {
          "line": 3909,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(remaining_tables & tab->table->map)",
          "old_line_content": "",
          "new_line_content": "  DBUG_ASSERT(remaining_tables & tab->table->map);",
          "content_same": false
        },
        {
          "line": 2891,
          "old_api": null,
          "new_api": "join_cond",
          "old_text": null,
          "new_text": "next_emb->join_cond()",
          "old_line_content": "    */",
          "new_line_content": "    if (!next_emb->join_cond())",
          "content_same": false
        },
        {
          "line": 3404,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(emb_sjm_nest == NULL)",
          "old_line_content": "",
          "new_line_content": "  DBUG_ASSERT(emb_sjm_nest == NULL);",
          "content_same": false
        },
        {
          "line": 3917,
          "old_api": null,
          "new_api": "join_cond",
          "old_text": null,
          "new_text": "last_emb->join_cond()",
          "old_line_content": "",
          "new_line_content": "    if (!last_emb->join_cond())",
          "content_same": false
        },
        {
          "line": 1356,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(true)",
          "old_line_content": "}",
          "new_line_content": "      DBUG_RETURN(true);",
          "content_same": false
        },
        {
          "line": 3407,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(remaining_tables & new_join_tab->table->map)",
          "old_line_content": "  {",
          "new_line_content": "  DBUG_ASSERT(remaining_tables & new_join_tab->table->map);",
          "content_same": false
        },
        {
          "line": 334,
          "old_api": null,
          "new_api": "read_time",
          "old_text": null,
          "new_text": "table->file->read_time(key, 1, (ha_rows)tmp_fanout)",
          "old_line_content": "      else if ((found_part & 1) &&",
          "new_line_content": "              table->file->read_time(key, 1, (ha_rows)tmp_fanout);",
          "content_same": false
        },
        {
          "line": 2384,
          "old_api": null,
          "new_api": "is_started",
          "old_text": null,
          "new_text": "trace->is_started()",
          "old_line_content": "      /*",
          "new_line_content": "      if (unlikely(trace->is_started()))",
          "content_same": false
        },
        {
          "line": 3922,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(nest->nj_counter > 0)",
          "old_line_content": "",
          "new_line_content": "    DBUG_ASSERT(nest->nj_counter > 0);",
          "content_same": false
        },
        {
          "line": 1361,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(false)",
          "old_line_content": "  exhaustiveness for the greedy search procedure.",
          "new_line_content": "    DBUG_RETURN(false);",
          "content_same": false
        },
        {
          "line": 2386,
          "old_api": null,
          "new_api": "trace_plan_prefix",
          "old_text": null,
          "new_text": "trace_plan_prefix(join, idx, excluded_tables)",
          "old_line_content": "        in the ref_extension has the same #rows and cost.",
          "new_line_content": "        trace_plan_prefix(join, idx, excluded_tables);",
          "content_same": false
        },
        {
          "line": 1364,
          "old_api": null,
          "new_api": "fix_semijoin_strategies",
          "old_text": null,
          "new_text": "fix_semijoin_strategies()",
          "old_line_content": "  big enough to result in a near-optimal QEP, that doesn't take too long to",
          "new_line_content": "  if (fix_semijoin_strategies())",
          "content_same": false
        },
        {
          "line": 341,
          "old_api": null,
          "new_api": "index_flags",
          "old_text": null,
          "new_text": "table->file->index_flags(key, 0, 0)",
          "old_line_content": "          than a not unique key.",
          "new_line_content": "               (!(table->file->index_flags(key, 0, 0) & HA_ONLY_WHOLE_INDEX) ||",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": null,
          "new_api": "LOWER_BITS",
          "old_text": null,
          "new_text": "LOWER_BITS(key_part_map,\n                                         actual_key_parts(keyinfo))",
          "old_line_content": "          Set cur_fanout to (previous record count) * (records / combination)",
          "new_line_content": "                found_part == LOWER_BITS(key_part_map,",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": null,
          "new_api": "actual_key_parts",
          "old_text": null,
          "new_text": "actual_key_parts(keyinfo)",
          "old_line_content": "        */",
          "new_line_content": "                                         actual_key_parts(keyinfo))))",
          "content_same": false
        },
        {
          "line": 854,
          "old_api": null,
          "new_api": "calculate_scan_cost",
          "old_text": null,
          "new_text": "calculate_scan_cost(tab,\n                                               idx,\n                                               best_ref,\n                                               prefix_rowcount,\n                                               found_condition,\n                                               disable_jbuf,\n                                               &scan_fanout,\n                                               &trace_access_scan)",
          "old_line_content": "      This cost plus scan_cost gives us total cost of",
          "new_line_content": "    double scan_read_cost= calculate_scan_cost(tab,",
          "content_same": false
        },
        {
          "line": 1365,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(true)",
          "old_line_content": "  find. If the number of tables in the query exceeds some constant, then",
          "new_line_content": "    DBUG_RETURN(true);",
          "content_same": false
        },
        {
          "line": 1367,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(false)",
          "old_line_content": "",
          "new_line_content": "  DBUG_RETURN(false);",
          "content_same": false
        },
        {
          "line": 2387,
          "old_api": null,
          "new_api": "add_utf8_table",
          "old_text": null,
          "new_text": "trace_one_table.add_utf8_table(s->table)",
          "old_line_content": "        -> The total cost of the QEP is independent of the order",
          "new_line_content": "        trace_one_table.add_utf8_table(s->table);",
          "content_same": false
        },
        {
          "line": 2391,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(emb_sjm_nest == NULL || emb_sjm_nest == s->emb_sj_nest)",
          "old_line_content": "      */",
          "new_line_content": "      DBUG_ASSERT(emb_sjm_nest == NULL || emb_sjm_nest == s->emb_sj_nest);",
          "content_same": false
        },
        {
          "line": 2393,
          "old_api": null,
          "new_api": "best_access_path",
          "old_text": null,
          "new_text": "best_access_path(s, remaining_tables, idx, false, record_count,\n                       position)",
          "old_line_content": "        position->key  &&",
          "new_line_content": "      best_access_path(s, remaining_tables, idx, false, record_count,",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": null,
          "new_api": "max_part_bit",
          "old_text": null,
          "new_text": "max_part_bit(found_part)",
          "old_line_content": "          with \"t.keypart_i IS NULL\")]  (**)",
          "new_line_content": "        cur_used_keyparts= max_part_bit(found_part);",
          "content_same": false
        },
        {
          "line": 3425,
          "old_api": null,
          "new_api": "LINT_INIT",
          "old_text": null,
          "new_text": "LINT_INIT(pos->sjm_scan_last_inner)",
          "old_line_content": "    pos->first_loosescan_table=",
          "new_line_content": "    LINT_INIT(pos->sjm_scan_last_inner);",
          "content_same": false
        },
        {
          "line": 2408,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_one_table.add(\"added_to_eq_ref_extension\",\n                          added_to_eq_ref_extension)",
          "old_line_content": "",
          "new_line_content": "      trace_one_table.add(\"added_to_eq_ref_extension\",",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_access_scan.add(\"cost\", scan_total_cost)",
          "old_line_content": "      best_ref=       NULL;",
          "new_line_content": "    trace_access_scan.add(\"cost\", scan_total_cost);",
          "content_same": false
        },
        {
          "line": 3954,
          "old_api": null,
          "new_api": "enum_query_type",
          "old_text": null,
          "new_text": "enum_query_type(QT_TO_SYSTEM_CHARSET |\n                                             QT_SHOW_SELECT_NUMBER |\n                                             QT_NO_DEFAULT_DB |\n                                             QT_DERIVED_TABLE_ONLY_ALIAS)",
          "old_line_content": "  @} (end of group Query_Planner)",
          "new_line_content": "        tl->print(thd, &str, enum_query_type(QT_TO_SYSTEM_CHARSET |",
          "content_same": false
        },
        {
          "line": 2419,
          "old_api": null,
          "new_api": "set_prefix_costs",
          "old_text": null,
          "new_text": "position->set_prefix_costs(current_read_time, current_record_count)",
          "old_line_content": "          */",
          "new_line_content": "        position->set_prefix_costs(current_read_time, current_record_count);",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": null,
          "new_api": "rows2double",
          "old_text": null,
          "new_text": "rows2double(scan_fanout)",
          "old_line_content": "    If this table is an inner table of an outer join, adjust row count to 1,",
          "new_line_content": "      fanout=         rows2double(scan_fanout);",
          "content_same": false
        },
        {
          "line": 2421,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_one_table.add(\"cost_for_plan\", current_read_time).\n          add(\"rows_for_plan\", current_record_count)",
          "old_line_content": "                           &current_record_count, &current_read_time);",
          "new_line_content": "        trace_one_table.add(\"cost_for_plan\", current_read_time).",
          "content_same": false
        },
        {
          "line": 3958,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "str.length()",
          "old_line_content": "",
          "new_line_content": "        plan_prefix.add_utf8(str.ptr(), str.length());",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_access_scan.add(\"chosen\", best_ref == NULL)",
          "old_line_content": "  if (fanout == 0.0 && (join->outer_join & table->map))",
          "new_line_content": "    trace_access_scan.add(\"chosen\", best_ref == NULL);",
          "content_same": false
        },
        {
          "line": 2432,
          "old_api": null,
          "new_api": "advance_sj_state",
          "old_text": null,
          "new_text": "advance_sj_state(remaining_tables, s, idx,\n                           &current_record_count, &current_read_time)",
          "old_line_content": "                                         current_read_time,",
          "new_line_content": "          advance_sj_state(remaining_tables, s, idx,",
          "content_same": false
        },
        {
          "line": 2436,
          "old_api": null,
          "new_api": "no_semijoin",
          "old_text": null,
          "new_text": "position->no_semijoin()",
          "old_line_content": "          continue;",
          "new_line_content": "          position->no_semijoin();",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": null,
          "new_api": "is_set",
          "old_text": null,
          "new_text": "table->quick_keys.is_set(key)",
          "old_line_content": "        else",
          "new_line_content": "        if (table->quick_keys.is_set(key) && !table_deps &&          //(C1)",
          "content_same": false
        },
        {
          "line": 2441,
          "old_api": null,
          "new_api": "print_plan",
          "old_text": null,
          "new_text": "print_plan(join, idx+1,\n                                         current_record_count,\n                                         read_time,\n                                         current_read_time,\n                                         \"prune_by_cost\")",
          "old_line_content": "          (remaining_tables & ~real_table_bit);",
          "new_line_content": "          DBUG_EXECUTE(\"opt\", print_plan(join, idx+1,",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": null,
          "new_api": "test",
          "old_text": null,
          "new_text": "test(ref_or_null_part)",
          "old_line_content": "          // Check if we have statistic about the distribution",
          "new_line_content": "            table->quick_n_ranges[key] == 1+test(ref_or_null_part))  //(C3)",
          "content_same": false
        },
        {
          "line": 2446,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_one_table.add(\"pruned_by_cost\", true)",
          "old_line_content": "                                         read_time,",
          "new_line_content": "          trace_one_table.add(\"pruned_by_cost\", true);",
          "content_same": false
        },
        {
          "line": 2447,
          "old_api": null,
          "new_api": "backout_nj_state",
          "old_text": null,
          "new_text": "backout_nj_state(remaining_tables, s)",
          "old_line_content": "                                         current_read_time,",
          "new_line_content": "          backout_nj_state(remaining_tables, s);",
          "content_same": false
        },
        {
          "line": 2958,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\n           \"Optimize_table_order::semijoin_firstmatch_loosescan_access_paths\")",
          "old_line_content": "  if (first_tab == join->const_tables)",
          "new_line_content": "  DBUG_ENTER(",
          "content_same": false
        },
        {
          "line": 3474,
          "old_api": null,
          "new_api": "optimizer_switch_flag",
          "old_text": null,
          "new_text": "thd->optimizer_switch_flag(OPTIMIZER_SWITCH_FIRSTMATCH)",
          "old_line_content": "          are in the join prefix",
          "new_line_content": "      thd->optimizer_switch_flag(OPTIMIZER_SWITCH_FIRSTMATCH))",
          "content_same": false
        },
        {
          "line": 919,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_access_scan.add(\"use_tmp_table\", true)",
          "old_line_content": "   called sj-equality. If ieK or oeK depends only on tables available before",
          "new_line_content": "    trace_access_scan.add(\"use_tmp_table\", true);",
          "content_same": false
        },
        {
          "line": 2456,
          "old_api": null,
          "new_api": "print_plan",
          "old_text": null,
          "new_text": "print_plan(join, idx + 1,\n                                         current_record_count,\n                                         read_time,\n                                         current_read_time,\n                                         \"EQ_REF_extension\")",
          "old_line_content": "                                               current_read_time,",
          "new_line_content": "          DBUG_EXECUTE(\"opt\", print_plan(join, idx + 1,",
          "content_same": false
        },
        {
          "line": 2465,
          "old_api": null,
          "new_api": "eq_ref_extension_by_limited_search",
          "old_text": null,
          "new_text": "eq_ref_extension_by_limited_search(remaining_tables_after,\n                                               idx + 1,\n                                               current_record_count,\n                                               current_read_time,\n                                               current_search_depth - 1)",
          "old_line_content": "                       (join->positions[idx].dups_producing_tables == 0)));",
          "new_line_content": "            eq_ref_extension_by_limited_search(remaining_tables_after,",
          "content_same": false
        },
        {
          "line": 2977,
          "old_api": null,
          "new_api": "total_cost",
          "old_text": null,
          "new_text": "positions[first_tab - 1].prefix_cost.total_cost()",
          "old_line_content": "  if (loosescan)",
          "new_line_content": "    cost=     positions[first_tab - 1].prefix_cost.total_cost();",
          "content_same": false
        },
        {
          "line": 3496,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(sj_inner_tables ==\n                  (remaining_tables_incl & sj_inner_tables))",
          "old_line_content": "          Trying to add an sj-inner table whose sj-nest has an outer correlated ",
          "new_line_content": "      DBUG_ASSERT(sj_inner_tables ==",
          "content_same": false
        },
        {
          "line": 2475,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT((remaining_tables_after != 0) ||\n                      ((cur_embedding_map == 0) &&\n                       (join->positions[idx].dups_producing_tables == 0)))",
          "old_line_content": "  } // for (JOIN_TAB **pos= ...)",
          "new_line_content": "          DBUG_ASSERT((remaining_tables_after != 0) ||",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": null,
          "new_api": "is_set",
          "old_text": null,
          "new_text": "table->quick_keys.is_set(key)",
          "old_line_content": "          }",
          "new_line_content": "            if (!table_deps && table->quick_keys.is_set(key) &&     // (1)",
          "content_same": false
        },
        {
          "line": 1454,
          "old_api": null,
          "new_api": "is_empty",
          "old_text": null,
          "new_text": "join->select_lex->sj_nests.is_empty()",
          "old_line_content": "    /*",
          "new_line_content": "  DBUG_ASSERT(join->select_lex->sj_nests.is_empty());",
          "content_same": false
        },
        {
          "line": 2479,
          "old_api": null,
          "new_api": "backout_nj_state",
          "old_text": null,
          "new_text": "backout_nj_state(remaining_tables, s)",
          "old_line_content": "    'eq_ref' heuristc didn't find a table to be appended to",
          "new_line_content": "        backout_nj_state(remaining_tables, s);",
          "content_same": false
        },
        {
          "line": 2480,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(join->best_ref + idx, saved_refs,\n               sizeof(JOIN_TAB*) * (join->tables - idx))",
          "old_line_content": "    the query plan. We need to use the greedy search",
          "new_line_content": "        memcpy(join->best_ref + idx, saved_refs,",
          "content_same": false
        },
        {
          "line": 2482,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(eq_ref_ext)",
          "old_line_content": "  */",
          "new_line_content": "        DBUG_RETURN(eq_ref_ext);",
          "content_same": false
        },
        {
          "line": 2485,
          "old_api": null,
          "new_api": "backout_nj_state",
          "old_text": null,
          "new_text": "backout_nj_state(remaining_tables, s)",
          "old_line_content": "                                       idx,",
          "new_line_content": "      backout_nj_state(remaining_tables, s);",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": null,
          "new_api": "used_tables",
          "old_text": null,
          "new_text": "outer->used_tables()",
          "old_line_content": "      corresponding outer expression t2.b+0 refers to 't2' which is not yet",
          "new_line_content": "    if (!((not_available_tables) & outer->used_tables()))",
          "content_same": false
        },
        {
          "line": 1463,
          "old_api": null,
          "new_api": "trace_plan_prefix",
          "old_text": null,
          "new_text": "trace_plan_prefix(join, idx, excluded_tables)",
          "old_line_content": "    /* compute the cost of the new plan extended with 's' */",
          "new_line_content": "      trace_plan_prefix(join, idx, excluded_tables);",
          "content_same": false
        },
        {
          "line": 1464,
          "old_api": null,
          "new_api": "add_utf8_table",
          "old_text": null,
          "new_text": "trace_table.add_utf8_table(s->table)",
          "old_line_content": "    record_count*= position->fanout;",
          "new_line_content": "      trace_table.add_utf8_table(s->table);",
          "content_same": false
        },
        {
          "line": 1471,
          "old_api": null,
          "new_api": "check_interleaving_with_nj",
          "old_text": null,
          "new_text": "check_interleaving_with_nj(s)",
          "old_line_content": "      add(\"rows_for_plan\", record_count);",
          "new_line_content": "    DBUG_ASSERT(!check_interleaving_with_nj(s));",
          "content_same": false
        },
        {
          "line": 3520,
          "old_api": null,
          "new_api": "semijoin_firstmatch_loosescan_access_paths",
          "old_text": null,
          "new_text": "semijoin_firstmatch_loosescan_access_paths(\n                                        pos->first_firstmatch_table, idx,\n                                        remaining_tables, false, false,\n                                        &rowcount, &cost)",
          "old_line_content": "        */",
          "new_line_content": "        (void)semijoin_firstmatch_loosescan_access_paths(",
          "content_same": false
        },
        {
          "line": 2495,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(!eq_ref_ext)",
          "old_line_content": "/*",
          "new_line_content": "  DBUG_ASSERT(!eq_ref_ext);",
          "content_same": false
        },
        {
          "line": 1473,
          "old_api": null,
          "new_api": "best_access_path",
          "old_text": null,
          "new_text": "best_access_path(s, join_tables, idx, false, record_count, position)",
          "old_line_content": "    ++idx;",
          "new_line_content": "    best_access_path(s, join_tables, idx, false, record_count, position);",
          "content_same": false
        },
        {
          "line": 2496,
          "old_api": null,
          "new_api": "best_extension_by_limited_search",
          "old_text": null,
          "new_text": "best_extension_by_limited_search(remaining_tables,\n                                       idx,\n                                       record_count,\n                                       read_time,\n                                       current_search_depth)",
          "old_line_content": "  Get the number of different row combinations for subset of partial join",
          "new_line_content": "  if (best_extension_by_limited_search(remaining_tables,",
          "content_same": false
        },
        {
          "line": 3519,
          "old_api": null,
          "new_api": "add_alnum",
          "old_text": null,
          "new_text": "trace_one_strategy.add_alnum(\"strategy\", \"FirstMatch\")",
          "old_line_content": "          picked the best QEP.",
          "new_line_content": "        trace_one_strategy.add_alnum(\"strategy\", \"FirstMatch\");",
          "content_same": false
        },
        {
          "line": 1988,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"Optimize_table_order::best_extension_by_limited_search\")",
          "old_line_content": "  double best_read_time=    DBL_MAX;",
          "new_line_content": "  DBUG_ENTER(\"Optimize_table_order::best_extension_by_limited_search\");",
          "content_same": false
        },
        {
          "line": 2501,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(~(table_map)0)",
          "old_line_content": "      idx        Number of tables in the partial join order (i.e. the",
          "new_line_content": "    DBUG_RETURN(~(table_map)0);",
          "content_same": false
        },
        {
          "line": 1479,
          "old_api": null,
          "new_api": "set_prefix_costs",
          "old_text": null,
          "new_text": "position->set_prefix_costs(read_time, record_count)",
          "old_line_content": "",
          "new_line_content": "    position->set_prefix_costs(read_time, record_count);",
          "content_same": false
        },
        {
          "line": 1992,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(true)",
          "old_line_content": "  /*",
          "new_line_content": "    DBUG_RETURN(true);",
          "content_same": false
        },
        {
          "line": 2503,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(eq_ref_ext)",
          "old_line_content": "      found_ref  Bitmap of tables for which we need to find # of distinct",
          "new_line_content": "  DBUG_RETURN(eq_ref_ext);",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_table.add(\"cost_for_plan\", read_time).\n      add(\"rows_for_plan\", record_count)",
          "old_line_content": "  /**",
          "new_line_content": "    trace_table.add(\"cost_for_plan\", read_time).",
          "content_same": false
        },
        {
          "line": 3019,
          "old_api": null,
          "new_api": "add_utf8_table",
          "old_text": null,
          "new_text": "trace_one_table.add_utf8_table(tab->table)",
          "old_line_content": "        {",
          "new_line_content": "      trace_one_table.add_utf8_table(tab->table);",
          "content_same": false
        },
        {
          "line": 3536,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_one_strategy.add(\"cost\", *current_cost).\n          add(\"rows\", *current_rowcount)",
          "old_line_content": "    LooseScan requires that all dependent outer tables are not in the join",
          "new_line_content": "        trace_one_strategy.add(\"cost\", *current_cost).",
          "content_same": false
        },
        {
          "line": 2002,
          "old_api": null,
          "new_api": "print_plan",
          "old_text": null,
          "new_text": "print_plan(join, idx, record_count, read_time, read_time,\n                                \"part_plan\")",
          "old_line_content": "    will not be considered in further EQ_REF extensions based",
          "new_line_content": "  DBUG_EXECUTE(\"opt\", print_plan(join, idx, record_count, read_time, read_time,",
          "content_same": false
        },
        {
          "line": 1492,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(join->best_positions, join->positions, sizeof(POSITION)*idx)",
          "old_line_content": "",
          "new_line_content": "  memcpy(join->best_positions, join->positions, sizeof(POSITION)*idx);",
          "content_same": false
        },
        {
          "line": 3540,
          "old_api": null,
          "new_api": "add",
          "old_text": null,
          "new_text": "trace_one_strategy.add(\"chosen\", true)",
          "old_line_content": "    2. The remaining tables from the same semi-join nest as the above table.",
          "new_line_content": "        trace_one_strategy.add(\"chosen\", true);",
          "content_same": false
        },
        {
          "line": 470,
          "old_api": null,
          "new_api": "set_if_bigger",
          "old_text": null,
          "new_text": "set_if_bigger(tmp_fanout, 1.0)",
          "old_line_content": "          {",
          "new_line_content": "              set_if_bigger(tmp_fanout, 1.0);",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "inner->type()",
          "old_line_content": "    }",
          "new_line_content": "    else if (inner->type() == Item::FIELD_ITEM)",
          "content_same": false
        },
        {
          "line": 3034,
          "old_api": null,
          "new_api": "set_prefix_costs",
          "old_text": null,
          "new_text": "dst_pos->set_prefix_costs(cost + dst_pos->read_cost +\n                                    rows * ROW_EVALUATE_COST,\n                                    rows)",
          "old_line_content": "    else ",
          "new_line_content": "          dst_pos->set_prefix_costs(cost + dst_pos->read_cost +",
          "content_same": false
        },
        {
          "line": 990,
          "old_api": null,
          "new_api": "static_cast<Item_field *>(item)",
          "old_text": null,
          "new_text": "static_cast<Item_field *>(item)",
          "old_line_content": "        If the multiple equality {[optional_constant,] col1, col2...} contains",
          "new_line_content": "    Item_field *const item_field= static_cast<Item_field *>(item);",
          "content_same": false
        },
        {
          "line": 3040,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(!final)",
          "old_line_content": "     */",
          "new_line_content": "          DBUG_ASSERT(!final);",
          "content_same": false
        },
        {
          "line": 3041,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(false)",
          "old_line_content": "    if (pos->read_cost == DBL_MAX)",
          "new_line_content": "          DBUG_RETURN(false);",
          "content_same": false
        },
        {
          "line": 2021,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(saved_refs, join->best_ref + idx, \n         sizeof(JOIN_TAB*) * (join->tables - idx))",
          "old_line_content": "    */",
          "new_line_content": "  memcpy(saved_refs, join->best_ref + idx, ",
          "content_same": false
        },
        {
          "line": 3557,
          "old_api": null,
          "new_api": "optimizer_switch_flag",
          "old_text": null,
          "new_text": "thd->optimizer_switch_flag(OPTIMIZER_SWITCH_LOOSE_SCAN)",
          "old_line_content": "        // Stage 2: Accept remaining tables from the semi-join nest:",
          "new_line_content": "  if (thd->optimizer_switch_flag(OPTIMIZER_SWITCH_LOOSE_SCAN))",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": null,
          "new_api": "is_set",
          "old_text": null,
          "new_text": "table->quick_keys.is_set(key)",
          "old_line_content": "              cur_fanout > (double) table->quick_rows[key])",
          "new_line_content": "          if (table->quick_keys.is_set(key) &&",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": null,
          "new_api": "get_const",
          "old_text": null,
          "new_text": "item_equal->get_const()",
          "old_line_content": "",
          "new_line_content": "      if (item_equal->get_const() ||                           // (1)",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": null,
          "new_api": "used_tables",
          "old_text": null,
          "new_text": "item_equal->used_tables()",
          "old_line_content": "  This function was created by copying the code from best_access_path, and",
          "new_line_content": "          (item_equal->used_tables() & ~not_available_tables)) // (2)",
          "content_same": false
        },
        {
          "line": 3055,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(loosescan && !final)",
          "old_line_content": "           rowcount * inner_fanout * outer_fanout * ROW_EVALUATE_COST;",
          "new_line_content": "      DBUG_ASSERT(loosescan && !final);",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": null,
          "new_api": "test",
          "old_text": null,
          "new_text": "test(ref_or_null_part &\n                                                     const_part)",
          "old_line_content": "        }",
          "new_line_content": "              table->quick_n_ranges[key] == 1 + test(ref_or_null_part &",
          "content_same": false
        },
        {
          "line": 3056,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(false)",
          "old_line_content": "  }",
          "new_line_content": "      DBUG_RETURN(false);",
          "content_same": false
        },
        {
          "line": 3576,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(emb_sj_nest != first_emb_sj_nest)",
          "old_line_content": "      new_join_tab->emb_sj_nest (which we've just entered, see #3), and",
          "new_line_content": "        DBUG_ASSERT(emb_sj_nest != first_emb_sj_nest);",
          "content_same": false
        },
        {
          "line": 2043,
          "old_api": null,
          "new_api": "is_started",
          "old_text": null,
          "new_text": "trace->is_started()",
          "old_line_content": "",
          "new_line_content": "      if (unlikely(trace->is_started()))",
          "content_same": false
        },
        {
          "line": 2045,
          "old_api": null,
          "new_api": "trace_plan_prefix",
          "old_text": null,
          "new_text": "trace_plan_prefix(join, idx, excluded_tables)",
          "old_line_content": "      current_record_count= record_count * position->fanout;",
          "new_line_content": "        trace_plan_prefix(join, idx, excluded_tables);",
          "content_same": false
        },
        {
          "line": 2046,
          "old_api": null,
          "new_api": "add_utf8_table",
          "old_text": null,
          "new_text": "trace_one_table.add_utf8_table(s->table)",
          "old_line_content": "      current_read_time=    read_time",
          "new_line_content": "        trace_one_table.add_utf8_table(s->table);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2049,
          "old_api": "set_prefix_costs",
          "new_api": null,
          "old_text": "position->set_prefix_costs(current_read_time, current_record_count)",
          "new_text": null,
          "old_line_content": "      position->set_prefix_costs(current_read_time, current_record_count);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 515,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_access_idx.add(\"usable\", false).add(\"chosen\", false)",
          "new_text": null,
          "old_line_content": "        trace_access_idx.add(\"usable\", false).add(\"chosen\", false);",
          "new_line_content": "        else if (key == table->s->primary_key &&",
          "content_same": false
        },
        {
          "line": 1543,
          "old_api": "my_count_bits",
          "new_api": null,
          "old_text": "my_count_bits(emb_sj_nest->sj_inner_tables)",
          "new_text": null,
          "old_line_content": "  const uint n_tables= my_count_bits(emb_sj_nest->sj_inner_tables);",
          "new_line_content": "    2. All the tables from the subquery are in the prefix",
          "content_same": false
        },
        {
          "line": 3595,
          "old_api": "uses_materialization",
          "new_api": null,
          "old_text": "new_join_tab->table->pos_in_table_list->uses_materialization()",
          "new_text": null,
          "old_line_content": "        !new_join_tab->table->pos_in_table_list->uses_materialization()) // (8)",
          "new_line_content": "      8. Not a derived table/view. (a temporary restriction)",
          "content_same": false
        },
        {
          "line": 524,
          "old_api": "prev_record_reads",
          "new_api": null,
          "old_text": "prev_record_reads(join, idx, table_deps)",
          "new_text": null,
          "old_line_content": "      cur_read_cost= prev_record_reads(join, idx, table_deps);",
          "new_line_content": "      else",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(remaining_tables & table->map)",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(remaining_tables & table->map);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2064,
          "old_api": "advance_sj_state",
          "new_api": null,
          "old_text": "advance_sj_state(remaining_tables, s, idx,\n                         &current_record_count, &current_read_time)",
          "new_text": null,
          "old_line_content": "        advance_sj_state(remaining_tables, s, idx,",
          "new_line_content": "        add(\"rows_for_plan\", current_record_count);",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": "get_bound_sj_equalities",
          "new_api": null,
          "old_text": "get_bound_sj_equalities(tab, excluded_tables | remaining_tables)",
          "new_text": null,
          "old_line_content": "    get_bound_sj_equalities(tab, excluded_tables | remaining_tables);",
          "new_line_content": "                                               table_map remaining_tables,",
          "content_same": false
        },
        {
          "line": 2068,
          "old_api": "no_semijoin",
          "new_api": null,
          "old_text": "position->no_semijoin()",
          "new_text": null,
          "old_line_content": "        position->no_semijoin();",
          "new_line_content": "        /*",
          "content_same": false
        },
        {
          "line": 3093,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"Optimize_table_order::semijoin_mat_scan_access_paths\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"Optimize_table_order::semijoin_mat_scan_access_paths\");",
          "new_line_content": "    Calculate best access paths for the outer tables of the MaterializeScan",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_access_idx.add(\"rows\", cur_fanout).add(\"cost\", cur_ref_cost)",
          "new_text": null,
          "old_line_content": "    trace_access_idx.add(\"rows\", cur_fanout).add(\"cost\", cur_ref_cost);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2073,
          "old_api": "print_plan",
          "new_api": null,
          "old_text": "print_plan(join, idx+1,\n                                       current_record_count,\n                                       read_time,\n                                       current_read_time,\n                                       \"prune_by_cost\")",
          "new_text": null,
          "old_line_content": "        DBUG_EXECUTE(\"opt\", print_plan(join, idx+1,",
          "new_line_content": "          Besides, never call advance_sj_state() when calculating the plan",
          "content_same": false
        },
        {
          "line": 3614,
          "old_api": "add_alnum",
          "new_api": null,
          "old_text": "trace_one_strategy.add_alnum(\"strategy\", \"LooseScan\")",
          "new_text": null,
          "old_line_content": "      trace_one_strategy.add_alnum(\"strategy\", \"LooseScan\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3102,
          "old_api": "my_count_bits",
          "new_api": null,
          "old_text": "my_count_bits(sjm_nest->sj_inner_tables)",
          "new_text": null,
          "old_line_content": "  const uint inner_count= my_count_bits(sjm_nest->sj_inner_tables);",
          "new_line_content": "                table_map remaining_tables, TABLE_LIST *sjm_nest, bool final,",
          "content_same": false
        },
        {
          "line": 2079,
          "old_api": "backout_nj_state",
          "new_api": null,
          "old_text": "backout_nj_state(remaining_tables, s)",
          "new_text": null,
          "old_line_content": "        backout_nj_state(remaining_tables, s);",
          "new_line_content": "      else",
          "content_same": false
        },
        {
          "line": 2078,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_one_table.add(\"pruned_by_cost\", true)",
          "new_text": null,
          "old_line_content": "        trace_one_table.add(\"pruned_by_cost\", true);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_access_idx.add(\"chosen\", best_ref == start_key)",
          "new_text": null,
          "old_line_content": "    trace_access_idx.add(\"chosen\", best_ref == start_key);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3622,
          "old_api": "semijoin_firstmatch_loosescan_access_paths",
          "new_api": null,
          "old_text": "semijoin_firstmatch_loosescan_access_paths(\n                                      pos->first_loosescan_table, idx,\n                                      remaining_tables, true, false,\n                                      &rowcount, &cost)",
          "new_text": null,
          "old_line_content": "      if (semijoin_firstmatch_loosescan_access_paths(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": "add_utf8",
          "new_api": null,
          "old_text": "trace_idx.add_utf8(\"index\", table->key_info[key].name)",
          "new_text": null,
          "old_line_content": "    trace_idx.add_utf8(\"index\", table->key_info[key].name);",
          "new_line_content": "  Opt_trace_array trace_all_idx(trace, \"indexes\");",
          "content_same": false
        },
        {
          "line": 3118,
          "old_api": "total_cost",
          "new_api": null,
          "old_text": "sjm_nest->nested_join->sjm.materialization_cost.total_cost()",
          "new_text": null,
          "old_line_content": "  cost+= sjm_nest->nested_join->sjm.materialization_cost.total_cost() +",
          "new_line_content": "  if (first_inner == join->const_tables)",
          "content_same": false
        },
        {
          "line": 3119,
          "old_api": "total_cost",
          "new_api": null,
          "old_text": "sjm_nest->nested_join->sjm.scan_cost.total_cost()",
          "new_text": null,
          "old_line_content": "         rowcount * sjm_nest->nested_join->sjm.scan_cost.total_cost();",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 3637,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_one_strategy.add(\"cost\", *current_cost).\n          add(\"rows\", *current_rowcount)",
          "new_text": null,
          "old_line_content": "        trace_one_strategy.add(\"cost\", *current_cost).",
          "new_line_content": "                                      &rowcount, &cost))",
          "content_same": false
        },
        {
          "line": 2106,
          "old_api": "print_plan",
          "new_api": null,
          "old_text": "print_plan(join, idx+1,\n                                         current_record_count,\n                                         read_time,\n                                         current_read_time,\n                                         \"pruned_by_heuristic\")",
          "new_text": null,
          "old_line_content": "          DBUG_EXECUTE(\"opt\", print_plan(join, idx+1,",
          "new_line_content": "          if (best_record_count >= current_record_count &&",
          "content_same": false
        },
        {
          "line": 3642,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_one_strategy.add(\"chosen\", sj_strategy == SJ_OPT_LOOSE_SCAN)",
          "new_text": null,
          "old_line_content": "      trace_one_strategy.add(\"chosen\", sj_strategy == SJ_OPT_LOOSE_SCAN);",
          "new_line_content": "          Materialization, which need at least the same set of tables in ",
          "content_same": false
        },
        {
          "line": 2111,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_one_table.add(\"pruned_by_heuristic\", true)",
          "new_text": null,
          "old_line_content": "          trace_one_table.add(\"pruned_by_heuristic\", true);",
          "new_line_content": "          {",
          "content_same": false
        },
        {
          "line": 2112,
          "old_api": "backout_nj_state",
          "new_api": null,
          "old_text": "backout_nj_state(remaining_tables, s)",
          "new_text": null,
          "old_line_content": "          backout_nj_state(remaining_tables, s);",
          "new_line_content": "            best_record_count= current_record_count;",
          "content_same": false
        },
        {
          "line": 2625,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"Optimize_table_order::fix_semijoin_strategies\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"Optimize_table_order::fix_semijoin_strategies\");",
          "new_line_content": "                               functions, EXPLAIN, etc proceed from left to ",
          "content_same": false
        },
        {
          "line": 3136,
          "old_api": "add_utf8_table",
          "new_api": null,
          "old_text": "trace_one_table.add_utf8_table(tab->table)",
          "new_text": null,
          "old_line_content": "    trace_one_table.add_utf8_table(tab->table);",
          "new_line_content": "    Materialization removes duplicates from the materialized table, so",
          "content_same": false
        },
        {
          "line": 2627,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "join->select_lex->sj_nests.is_empty()",
          "new_text": null,
          "old_line_content": "  if (join->select_lex->sj_nests.is_empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2628,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(false)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(false);",
          "new_line_content": "    This function does the needed reversal, making it possible to read the",
          "content_same": false
        },
        {
          "line": 3139,
          "old_api": "best_access_path",
          "new_api": null,
          "old_text": "best_access_path(tab, remaining_tables, i, false,\n                     rowcount * inner_fanout * outer_fanout, dst_pos)",
          "new_text": null,
          "old_line_content": "    best_access_path(tab, remaining_tables, i, false,",
          "new_line_content": "    based. Rerun best_access_path to adjust for reduced rowcount.",
          "content_same": false
        },
        {
          "line": 3653,
          "old_api": "semijoin_order_allows_materialization",
          "new_api": null,
          "old_text": "semijoin_order_allows_materialization(join, remaining_tables,\n                                          new_join_tab, idx)",
          "new_text": null,
          "old_line_content": "    semijoin_order_allows_materialization(join, remaining_tables,",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1100,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(max_keypart <= keypart)",
          "new_text": null,
          "old_line_content": "        DBUG_ASSERT(max_keypart <= keypart); // see sort_keyuse()",
          "new_line_content": "          is for fulltext, or is over a prefix, then it is not a \"handled sj",
          "content_same": false
        },
        {
          "line": 2646,
          "old_api": "LINT_INIT",
          "new_api": null,
          "old_text": "LINT_INIT(first)",
          "new_text": null,
          "old_line_content": "    LINT_INIT(first);",
          "new_line_content": "       tableno--)",
          "content_same": false
        },
        {
          "line": 2650,
          "old_api": "my_count_bits",
          "new_api": null,
          "old_text": "my_count_bits(sjm_nest->sj_inner_tables)",
          "new_text": null,
          "old_line_content": "      const uint table_count= my_count_bits(sjm_nest->sj_inner_tables);",
          "new_line_content": "    if ((handled_tables & pos->table->table->map) ||",
          "content_same": false
        },
        {
          "line": 3680,
          "old_api": "add_alnum",
          "new_api": null,
          "old_text": "Opt_trace_object(trace).add_alnum(\"strategy\", \"MaterializeScan\").\n      add_alnum(\"choice\", \"deferred\")",
          "new_text": null,
          "old_line_content": "    Opt_trace_object(trace).add_alnum(\"strategy\", \"MaterializeScan\").",
          "new_line_content": "      The final join result will not contain any semi-join produced",
          "content_same": false
        },
        {
          "line": 2145,
          "old_api": "eq_ref_extension_by_limited_search",
          "new_api": null,
          "old_text": "eq_ref_extension_by_limited_search(\n                                             remaining_tables_after,\n                                             idx + 1,\n                                             current_record_count,\n                                             current_read_time,\n                                             current_search_depth - 1)",
          "new_text": null,
          "old_line_content": "              eq_ref_extension_by_limited_search(",
          "new_line_content": "          /*",
          "content_same": false
        },
        {
          "line": 3174,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"Optimize_table_order::semijoin_mat_lookup_access_paths\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"Optimize_table_order::semijoin_mat_lookup_access_paths\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3687,
          "old_api": "semijoin_mat_lookup_access_paths",
          "new_api": null,
          "old_text": "semijoin_mat_lookup_access_paths(idx, emb_sj_nest, &rowcount, &cost)",
          "new_text": null,
          "old_line_content": "    semijoin_mat_lookup_access_paths(idx, emb_sj_nest, &rowcount, &cost);",
          "new_line_content": "    */",
          "content_same": false
        },
        {
          "line": 2152,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(true)",
          "new_text": null,
          "old_line_content": "              DBUG_RETURN(true);      // Failed",
          "new_line_content": "          if (eq_ref_extended == (table_map)0)",
          "content_same": false
        },
        {
          "line": 3176,
          "old_api": "my_count_bits",
          "new_api": null,
          "old_text": "my_count_bits(sjm_nest->sj_inner_tables)",
          "new_text": null,
          "old_line_content": "  const uint inner_count= my_count_bits(sjm_nest->sj_inner_tables);",
          "new_line_content": "    All outer tables may use join buffering, so there is no need to recalculate",
          "content_same": false
        },
        {
          "line": 2154,
          "old_api": "backout_nj_state",
          "new_api": null,
          "old_text": "backout_nj_state(remaining_tables, s)",
          "new_text": null,
          "old_line_content": "            backout_nj_state(remaining_tables, s);",
          "new_line_content": "            /* Try an EQ_REF-joined expansion of the partial plan */",
          "content_same": false
        },
        {
          "line": 2667,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(pos - table_count + 1, sjm_nest->nested_join->sjm.positions, \n             sizeof(POSITION) * table_count)",
          "new_text": null,
          "old_line_content": "      memcpy(pos - table_count + 1, sjm_nest->nested_join->sjm.positions, ",
          "new_line_content": "        to-be-materialized inner tables.",
          "content_same": false
        },
        {
          "line": 3690,
          "old_api": "add_alnum",
          "new_api": null,
          "old_text": "trace_one_strategy.add_alnum(\"strategy\", \"MaterializeLookup\").\n      add(\"cost\", cost).add(\"rows\", rowcount).\n      add(\"duplicate_tables_left\", pos->dups_producing_tables != 0)",
          "new_text": null,
          "old_line_content": "    trace_one_strategy.add_alnum(\"strategy\", \"MaterializeLookup\").",
          "new_line_content": "      emb_sj_nest->nested_join->sj_depends_on;",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": "add_alnum",
          "new_api": null,
          "old_text": "trace_access_scan->add_alnum(\"access_type\", \"range\")",
          "new_text": null,
          "old_line_content": "    trace_access_scan->add_alnum(\"access_type\", \"range\");",
          "new_line_content": "    heuristics at once.",
          "content_same": false
        },
        {
          "line": 2674,
          "old_api": "add_alnum",
          "new_api": null,
          "old_text": "trace_final_strategy.add_alnum(\"final_semijoin_strategy\",\n                                     \"MaterializeLookup\")",
          "new_text": null,
          "old_line_content": "      trace_final_strategy.add_alnum(\"final_semijoin_strategy\",",
          "new_line_content": "        fixed for the first table of that range right after the memcpy(), and",
          "content_same": false
        },
        {
          "line": 2163,
          "old_api": "print_plan",
          "new_api": null,
          "old_text": "print_plan(join, idx+1,\n                                           current_record_count,\n                                           read_time,\n                                           current_read_time,\n                                           \"pruned_by_eq_ref_heuristic\")",
          "new_text": null,
          "old_line_content": "            DBUG_EXECUTE(\"opt\", print_plan(join, idx+1,",
          "new_line_content": "            if (eq_ref_extended == ~(table_map)0)",
          "content_same": false
        },
        {
          "line": 3187,
          "old_api": "total_cost",
          "new_api": null,
          "old_text": "join->positions[first_inner - 1].prefix_cost.total_cost()",
          "new_text": null,
          "old_line_content": "    cost=     join->positions[first_inner - 1].prefix_cost.total_cost();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"Optimize_table_order::greedy_search\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"Optimize_table_order::greedy_search\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3191,
          "old_api": "total_cost",
          "new_api": null,
          "old_text": "sjm_nest->nested_join->sjm.materialization_cost.total_cost()",
          "new_text": null,
          "old_line_content": "  cost+= sjm_nest->nested_join->sjm.materialization_cost.total_cost() +",
          "new_line_content": "  const uint first_inner= last_inner + 1 - inner_count;",
          "content_same": false
        },
        {
          "line": 2168,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_one_table.add(\"pruned_by_eq_ref_heuristic\", true)",
          "new_text": null,
          "old_line_content": "            trace_one_table.add(\"pruned_by_eq_ref_heuristic\", true);",
          "new_line_content": "            if (eq_ref_extended == remaining_tables)",
          "content_same": false
        },
        {
          "line": 3192,
          "old_api": "total_cost",
          "new_api": null,
          "old_text": "sjm_nest->nested_join->sjm.lookup_cost.total_cost()",
          "new_text": null,
          "old_line_content": "         rowcount * sjm_nest->nested_join->sjm.lookup_cost.total_cost();",
          "new_line_content": "  if (first_inner == join->const_tables)",
          "content_same": false
        },
        {
          "line": 1656,
          "old_api": "my_count_bits",
          "new_api": null,
          "old_text": "my_count_bits(remaining_tables)",
          "new_text": null,
          "old_line_content": "  const uint n_tables= my_count_bits(remaining_tables);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2169,
          "old_api": "backout_nj_state",
          "new_api": null,
          "old_text": "backout_nj_state(remaining_tables, s)",
          "new_text": null,
          "old_line_content": "            backout_nj_state(remaining_tables, s);",
          "new_line_content": "              goto done;",
          "content_same": false
        },
        {
          "line": 2682,
          "old_api": "my_count_bits",
          "new_api": null,
          "old_text": "my_count_bits(sjm_nest->sj_inner_tables)",
          "new_text": null,
          "old_line_content": "      const uint table_count= my_count_bits(sjm_nest->sj_inner_tables);",
          "new_line_content": "      join->best_positions[first].n_sj_tables= table_count;",
          "content_same": false
        },
        {
          "line": 2684,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT((join->best_positions + first)->table->emb_sj_nest ==\n                  sjm_nest)",
          "new_text": null,
          "old_line_content": "      DBUG_ASSERT((join->best_positions + first)->table->emb_sj_nest ==",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": "add_alnum",
          "new_api": null,
          "old_text": "trace_access_scan->add_alnum(\"access_type\", \"scan\")",
          "new_text": null,
          "old_line_content": "    trace_access_scan->add_alnum(\"access_type\", \"scan\");",
          "new_line_content": "      - skip rows which does not satisfy WHERE constraints",
          "content_same": false
        },
        {
          "line": 3706,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_one_strategy.add(\"chosen\", sj_strategy == SJ_OPT_MATERIALIZE_LOOKUP)",
          "new_text": null,
          "old_line_content": "    trace_one_strategy.add(\"chosen\", sj_strategy == SJ_OPT_MATERIALIZE_LOOKUP);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2176,
          "old_api": "best_extension_by_limited_search",
          "new_api": null,
          "old_text": "best_extension_by_limited_search(remaining_tables_after,\n                                             idx + 1,\n                                             current_record_count,\n                                             current_read_time,\n                                             current_search_depth - 1)",
          "new_text": null,
          "old_line_content": "        if (best_extension_by_limited_search(remaining_tables_after,",
          "new_line_content": "                                           current_record_count,",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": "LOWER_BITS",
          "new_api": null,
          "old_text": "LOWER_BITS(ulonglong,\n                   tab->emb_sj_nest->nested_join->sj_inner_exprs.elements)",
          "new_text": null,
          "old_line_content": "        LOWER_BITS(ulonglong,",
          "new_line_content": "      If the plan is t3-t1-t2, and we are looking at an index on t1.a:",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": "read_time",
          "new_api": null,
          "old_text": "table->file->read_time(tab->ref.key, 1, tab->records)",
          "new_text": null,
          "old_line_content": "      table->file->read_time(tab->ref.key, 1, tab->records) : // index scan",
          "new_line_content": "      account here for range/index_merge access. Find out why this is so.",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": "scan_time",
          "new_api": null,
          "old_text": "table->file->scan_time()",
          "new_text": null,
          "old_line_content": "      table->file->scan_time();                               // table scan",
          "new_line_content": "    */",
          "content_same": false
        },
        {
          "line": 1156,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_idx.add(\"index_handles_needed_semijoin_equalities\", false)",
          "new_text": null,
          "old_line_content": "      trace_idx.add(\"index_handles_needed_semijoin_equalities\", false);",
          "new_line_content": "      handled_keyparts==0, bound_keyparts==1 (t1.a=10).",
          "content_same": false
        },
        {
          "line": 2693,
          "old_api": "add_alnum",
          "new_api": null,
          "old_text": "trace_final_strategy.add_alnum(\"final_semijoin_strategy\",\n                                     \"MaterializeScan\")",
          "new_text": null,
          "old_line_content": "      trace_final_strategy.add_alnum(\"final_semijoin_strategy\",",
          "new_line_content": "        (join->best_positions + last_inner)->table->emb_sj_nest;",
          "content_same": false
        },
        {
          "line": 1161,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_idx.add(\"some_index_part_used\", false)",
          "new_text": null,
          "old_line_content": "      trace_idx.add(\"some_index_part_used\", false);",
          "new_line_content": "      rows of t1 returned by ref access. But this is a bit degenerate,",
          "content_same": false
        },
        {
          "line": 1673,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(join->best_read < DBL_MAX)",
          "new_text": null,
          "old_line_content": "    DBUG_ASSERT(join->best_read < DBL_MAX); ",
          "new_line_content": "  do {",
          "content_same": false
        },
        {
          "line": 2185,
          "old_api": "consider_plan",
          "new_api": null,
          "old_text": "consider_plan(idx, current_record_count, current_read_time,\n                      &trace_one_table)",
          "new_text": null,
          "old_line_content": "        consider_plan(idx, current_record_count, current_read_time,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1164,
          "old_api": "LOWER_BITS",
          "new_api": null,
          "old_text": "LOWER_BITS(key_part_map, max_keypart + 1)",
          "new_text": null,
          "old_line_content": "    if ((LOWER_BITS(key_part_map, max_keypart + 1) &                    // (2)",
          "new_line_content": "    if ((handled_sj_equalities | bound_sj_equalities) !=                // (1)",
          "content_same": false
        },
        {
          "line": 2697,
          "old_api": "semijoin_mat_scan_access_paths",
          "new_api": null,
          "old_text": "semijoin_mat_scan_access_paths(last_inner, tableno,\n                                     remaining_tables, sjm_nest, true,\n                                     &rowcount, &cost)",
          "new_text": null,
          "old_line_content": "      semijoin_mat_scan_access_paths(last_inner, tableno,",
          "new_line_content": "                  sjm_nest);",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_idx.add(\"index_can_remove_duplicates\", false)",
          "new_text": null,
          "old_line_content": "      trace_idx.add(\"index_can_remove_duplicates\", false);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2191,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT((remaining_tables_after != 0) ||\n                    ((cur_embedding_map == 0) &&\n                     (join->positions[idx].dups_producing_tables == 0)))",
          "new_text": null,
          "old_line_content": "        DBUG_ASSERT((remaining_tables_after != 0) ||",
          "new_line_content": "                                             current_read_time,",
          "content_same": false
        },
        {
          "line": 1681,
          "old_api": "print_plan",
          "new_api": null,
          "old_text": "print_plan(join, n_tables, record_count, read_time,\n                                     read_time, \"optimal\")",
          "new_text": null,
          "old_line_content": "      DBUG_EXECUTE(\"opt\", print_plan(join, n_tables, record_count, read_time,",
          "new_line_content": "    /*",
          "content_same": false
        },
        {
          "line": 3729,
          "old_api": "add_alnum",
          "new_api": null,
          "old_text": "trace_one_strategy.add_alnum(\"strategy\", \"MaterializeScan\")",
          "new_text": null,
          "old_line_content": "    trace_one_strategy.add_alnum(\"strategy\", \"MaterializeScan\");",
          "new_line_content": "      join->positions[pos->sjm_scan_last_inner].table->emb_sj_nest)",
          "content_same": false
        },
        {
          "line": 1683,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(false)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(false);",
          "new_line_content": "      some plan and updated 'best_positions' array accordingly.",
          "content_same": false
        },
        {
          "line": 2195,
          "old_api": "backout_nj_state",
          "new_api": null,
          "old_text": "backout_nj_state(remaining_tables, s)",
          "new_text": null,
          "old_line_content": "      backout_nj_state(remaining_tables, s);",
          "new_line_content": "      else  //if ((current_search_depth > 1) && ...",
          "content_same": false
        },
        {
          "line": 3731,
          "old_api": "semijoin_mat_scan_access_paths",
          "new_api": null,
          "old_text": "semijoin_mat_scan_access_paths(pos->sjm_scan_last_inner, idx,\n                                   remaining_tables, sjm_nest, false,\n                                   &rowcount, &cost)",
          "new_text": null,
          "old_line_content": "    semijoin_mat_scan_access_paths(pos->sjm_scan_last_inner, idx,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": "get_type",
          "new_api": null,
          "old_text": "tab->quick->get_type()",
          "new_text": null,
          "old_line_content": "        tab->quick->get_type() == QUICK_SELECT_I::QS_TYPE_RANGE)",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 3734,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_one_strategy.add(\"cost\", cost).\n      add(\"rows\", rowcount).\n      add(\"duplicate_tables_left\", pos->dups_producing_tables != 0)",
          "new_text": null,
          "old_line_content": "    trace_one_strategy.add(\"cost\", cost).",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 2201,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(join->best_ref + idx, saved_refs,\n         sizeof(JOIN_TAB*) * (join->tables-idx))",
          "new_text": null,
          "old_line_content": "  memcpy(join->best_ref + idx, saved_refs,",
          "new_line_content": "          all semi join nests should be handled by a strategy:",
          "content_same": false
        },
        {
          "line": 2713,
          "old_api": "semijoin_firstmatch_loosescan_access_paths",
          "new_api": null,
          "old_text": "semijoin_firstmatch_loosescan_access_paths(first, tableno,\n                                        remaining_tables, false, true,\n                                        &rowcount, &cost)",
          "new_text": null,
          "old_line_content": "      (void)semijoin_firstmatch_loosescan_access_paths(first, tableno,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": "cache_record_length",
          "new_api": null,
          "old_text": "cache_record_length(join,idx)",
          "new_text": null,
          "old_line_content": "        1.0 + ((double) cache_record_length(join,idx) *",
          "new_line_content": "      scan_and_filter_cost= prefix_rowcount *",
          "content_same": false
        },
        {
          "line": 1183,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_ref.add(\"cost\", start_key->read_cost)",
          "new_text": null,
          "old_line_content": "      trace_ref.add(\"cost\", start_key->read_cost);",
          "new_line_content": "    // Ok, can use the strategy",
          "content_same": false
        },
        {
          "line": 3232,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"Optimize_table_order::semijoin_dupsweedout_access_paths\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"Optimize_table_order::semijoin_dupsweedout_access_paths\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2722,
          "old_api": "add_alnum",
          "new_api": null,
          "old_text": "trace_final_strategy.add_alnum(\"final_semijoin_strategy\", \"LooseScan\")",
          "new_text": null,
          "old_line_content": "      trace_final_strategy.add_alnum(\"final_semijoin_strategy\", \"LooseScan\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_access_scan->add(\"using_join_cache\", true)",
          "new_text": null,
          "old_line_content": "      trace_access_scan->add(\"using_join_cache\", true);",
          "new_line_content": "        We read the table as many times as join buffer becomes full.",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_access_scan->add(\"buffers_needed\", (ulong)buffer_count)",
          "new_text": null,
          "old_line_content": "      trace_access_scan->add(\"buffers_needed\", (ulong)buffer_count);",
          "new_line_content": "        It would be more exact to round the result of the division with",
          "content_same": false
        },
        {
          "line": 2726,
          "old_api": "semijoin_firstmatch_loosescan_access_paths",
          "new_api": null,
          "old_text": "semijoin_firstmatch_loosescan_access_paths(first, tableno,\n                                        remaining_tables, true, true,\n                                        &rowcount, &cost)",
          "new_text": null,
          "old_line_content": "      (void)semijoin_firstmatch_loosescan_access_paths(first, tableno,",
          "new_line_content": "                                        remaining_tables, false, true,",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_ref.add(\"chosen\", true)",
          "new_text": null,
          "old_line_content": "        trace_ref.add(\"chosen\", true);",
          "new_line_content": "    if (bound_keyparts & 1)",
          "content_same": false
        },
        {
          "line": 3752,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_one_strategy.add(\"chosen\", sj_strategy == SJ_OPT_MATERIALIZE_SCAN)",
          "new_text": null,
          "old_line_content": "    trace_one_strategy.add(\"chosen\", sj_strategy == SJ_OPT_MATERIALIZE_SCAN);",
          "new_line_content": "       * we haven't picked any other semi-join strategy yet",
          "content_same": false
        },
        {
          "line": 2733,
          "old_api": "my_count_bits",
          "new_api": null,
          "old_text": "my_count_bits(first_pos->table->emb_sj_nest->sj_inner_tables)",
          "new_text": null,
          "old_line_content": "        my_count_bits(first_pos->table->emb_sj_nest->sj_inner_tables);",
          "new_line_content": "      Opt_trace_object trace_final_strategy(trace);",
          "content_same": false
        },
        {
          "line": 3246,
          "old_api": "total_cost",
          "new_api": null,
          "old_text": "join->positions[first_tab - 1].prefix_cost.total_cost()",
          "new_text": null,
          "old_line_content": "    cost=     join->positions[first_tab - 1].prefix_cost.total_cost();",
          "new_line_content": "  double cost, rowcount;",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(!is_interleave_error)",
          "new_text": null,
          "old_line_content": "    DBUG_ASSERT(!is_interleave_error);",
          "new_line_content": "      with a new table. We are doing this here because",
          "content_same": false
        },
        {
          "line": 1718,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT((pos != NULL))",
          "new_text": null,
          "old_line_content": "    DBUG_ASSERT((pos != NULL)); // should always find 'best_table'",
          "new_line_content": "      don't \"pop\" tables already present in the partial plan.",
          "content_same": false
        },
        {
          "line": 1208,
          "old_api": "rows2double",
          "new_api": null,
          "old_text": "rows2double(tab->table->file->stats.records)",
          "new_text": null,
          "old_line_content": "      double rowcount= rows2double(tab->table->file->stats.records);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2746,
          "old_api": "add_alnum",
          "new_api": null,
          "old_text": "trace_final_strategy.add_alnum(\"final_semijoin_strategy\",\n                                     \"DuplicateWeedout\")",
          "new_text": null,
          "old_line_content": "      trace_final_strategy.add_alnum(\"final_semijoin_strategy\",",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": "index_only_read_time",
          "new_api": null,
          "old_text": "tab->table->file->index_only_read_time(key, rowcount)",
          "new_text": null,
          "old_line_content": "      double cost= tab->table->file->index_only_read_time(key, rowcount);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1724,
          "old_api": "memmove",
          "new_api": null,
          "old_text": "memmove(join->best_ref + idx + 1, join->best_ref + idx,\n            sizeof(JOIN_TAB*) * (best_idx - idx))",
          "new_text": null,
          "old_line_content": "    memmove(join->best_ref + idx + 1, join->best_ref + idx,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3774,
          "old_api": "add_alnum",
          "new_api": null,
          "old_text": "trace_one_strategy.add_alnum(\"strategy\", \"DuplicatesWeedout\")",
          "new_text": null,
          "old_line_content": "      trace_one_strategy.add_alnum(\"strategy\", \"DuplicatesWeedout\");",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1737,
          "old_api": "print_plan",
          "new_api": null,
          "old_text": "print_plan(join, idx, record_count, read_time, \n                                   read_time, \"extended\")",
          "new_text": null,
          "old_line_content": "    DBUG_EXECUTE(\"opt\", print_plan(join, idx, record_count, read_time, ",
          "new_line_content": "            sizeof(JOIN_TAB*) * (best_idx - idx));",
          "content_same": false
        },
        {
          "line": 2764,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(remaining_tables == (join->all_table_map&~join->const_table_map))",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(remaining_tables == (join->all_table_map&~join->const_table_map));",
          "new_line_content": "      /*",
          "content_same": false
        },
        {
          "line": 2766,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(FALSE)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(FALSE);",
          "new_line_content": "        SJ_OPT_MATERIALIZE_LOOKUP case above.",
          "content_same": false
        },
        {
          "line": 3790,
          "old_api": "semijoin_dupsweedout_access_paths",
          "new_api": null,
          "old_text": "semijoin_dupsweedout_access_paths(pos->first_dupsweedout_table, idx,\n                                        remaining_tables, &rowcount, &cost)",
          "new_text": null,
          "old_line_content": "      semijoin_dupsweedout_access_paths(pos->first_dupsweedout_table, idx,",
          "new_line_content": "          - the join cost (this is needed as the accumulated cost may assume ",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_cov_scan.add(\"chosen\", true)",
          "new_text": null,
          "old_line_content": "        trace_cov_scan.add(\"chosen\", true);",
          "new_line_content": "      if (rpc != 0)",
          "content_same": false
        },
        {
          "line": 1236,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_idx.add(\"ref_possible\", false).\n        add(\"covering_scan_possible\", false)",
          "new_text": null,
          "old_line_content": "      trace_idx.add(\"ref_possible\", false).",
          "new_line_content": "      // @TODO: previous version also did /2",
          "content_same": false
        },
        {
          "line": 3800,
          "old_api": "trace_one_strategy.\n        add(\"cost\", cost).\n        add(\"rows\", rowcount).\n        add(\"duplicate_tables_left\", pos->dups_producing_tables != 0)",
          "new_api": null,
          "old_text": "trace_one_strategy.\n        add(\"cost\", cost).\n        add(\"rows\", rowcount).\n        add(\"duplicate_tables_left\", pos->dups_producing_tables != 0)",
          "new_text": null,
          "old_line_content": "      trace_one_strategy.",
          "new_line_content": "      */",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": "optimizer_switch_flag",
          "new_api": null,
          "old_text": "thd->optimizer_switch_flag(OPTIMIZER_SWITCH_BNL)",
          "new_text": null,
          "old_line_content": "    !thd->optimizer_switch_flag(OPTIMIZER_SWITCH_BNL);               // 2",
          "new_line_content": "  TABLE *const table= tab->table;",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": "end",
          "new_api": null,
          "old_text": "trace_all_idx.end()",
          "new_text": null,
          "old_line_content": "  trace_all_idx.end();",
          "new_line_content": "        pos->key= NULL;",
          "content_same": false
        },
        {
          "line": 732,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"Optimize_table_order::best_access_path\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"Optimize_table_order::best_access_path\");",
          "new_line_content": "  thd->status_var.last_query_partial_plans++;",
          "content_same": false
        },
        {
          "line": 3815,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_one_strategy.add(\"chosen\", sj_strategy == SJ_OPT_DUPS_WEEDOUT)",
          "new_text": null,
          "old_line_content": "      trace_one_strategy.add(\"chosen\", sj_strategy == SJ_OPT_DUPS_WEEDOUT);",
          "new_line_content": "        add(\"duplicate_tables_left\", pos->dups_producing_tables != 0);",
          "content_same": false
        },
        {
          "line": 1258,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_range.add(\"chosen\", true)",
          "new_text": null,
          "old_line_content": "      trace_range.add(\"chosen\", true);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 3835,
          "old_api": "set_prefix_costs",
          "new_api": null,
          "old_text": "pos->set_prefix_costs(*current_cost, *current_rowcount)",
          "new_text": null,
          "old_line_content": "    pos->set_prefix_costs(*current_cost, *current_rowcount);",
          "new_line_content": "    where we have two semi-join nests containing it1 and it2, respectively,",
          "content_same": false
        },
        {
          "line": 1286,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"Optimize_table_order::choose_table_order\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"Optimize_table_order::choose_table_order\");",
          "new_line_content": "  'join->best_read'.",
          "content_same": false
        },
        {
          "line": 1291,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(join->best_positions, join->positions,\n\t   sizeof(POSITION) * join->const_tables)",
          "new_text": null,
          "old_line_content": "    memcpy(join->best_positions, join->positions,",
          "new_line_content": "  nest to be materialized and a NULL pointer when producing a full query plan.",
          "content_same": false
        },
        {
          "line": 1295,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(false)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1300,
          "old_api": "test",
          "new_api": null,
          "old_text": "test(join->select_options & SELECT_STRAIGHT_JOIN)",
          "new_text": null,
          "old_line_content": "  const bool straight_join= test(join->select_options & SELECT_STRAIGHT_JOIN);",
          "new_line_content": "  /* Are there any tables to optimize? */",
          "content_same": false
        },
        {
          "line": 1815,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_obj->add(\"sort_cost\", record_count).\n      add(\"new_cost_for_plan\", read_time)",
          "new_text": null,
          "old_line_content": "    trace_obj->add(\"sort_cost\", record_count).",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2327,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"Optimize_table_order::eq_ref_extension_by_limited_search\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"Optimize_table_order::eq_ref_extension_by_limited_search\");",
          "new_line_content": "    'table_map'          Map of those tables appended to the EQ_REF-joined sequence",
          "content_same": false
        },
        {
          "line": 2330,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(0);",
          "new_line_content": "*/",
          "content_same": false
        },
        {
          "line": 1308,
          "old_api": "merge_sort",
          "new_api": null,
          "old_text": "merge_sort(join->best_ref + join->const_tables,\n               join->best_ref + join->tables,\n               Join_tab_compare_embedded_first(emb_sjm_nest))",
          "new_text": null,
          "old_line_content": "    merge_sort(join->best_ref + join->const_tables,",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1821,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_obj->add(\"chosen\", chosen)",
          "new_text": null,
          "old_line_content": "  trace_obj->add(\"chosen\", chosen);",
          "new_line_content": "  */",
          "content_same": false
        },
        {
          "line": 2332,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "join->select_lex->sj_nests.is_empty()",
          "new_text": null,
          "old_line_content": "  const bool has_sj= !(join->select_lex->sj_nests.is_empty() || emb_sjm_nest);",
          "new_line_content": "table_map Optimize_table_order::eq_ref_extension_by_limited_search(",
          "content_same": false
        },
        {
          "line": 1824,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy((uchar*) join->best_positions, (uchar*) join->positions,\n            sizeof(POSITION) * (idx + 1))",
          "new_text": null,
          "old_line_content": "    memcpy((uchar*) join->best_positions, (uchar*) join->positions,",
          "new_line_content": "      join->positions[join->const_tables].table->table)",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": "add_alnum",
          "new_api": null,
          "old_text": "trace_access_scan.add_alnum(\"access_type\", tab->quick ? \"range\" : \"scan\").\n      add(\"cost\", tab->read_time + tab->found_records * ROW_EVALUATE_COST).\n      add(\"rows\", tab->found_records).\n      add(\"chosen\", false).\n      add_alnum(\"cause\", \"cost\")",
          "new_text": null,
          "old_line_content": "    trace_access_scan.add_alnum(\"access_type\", tab->quick ? \"range\" : \"scan\").",
          "new_line_content": "    (4) NOT (\"FORCE INDEX(...)\" is used for table and there is 'ref' access",
          "content_same": false
        },
        {
          "line": 2345,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(saved_refs, join->best_ref + idx,\n         sizeof(JOIN_TAB*) * (join->tables-idx))",
          "new_text": null,
          "old_line_content": "  memcpy(saved_refs, join->best_ref + idx,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": "merge_sort",
          "new_api": null,
          "old_text": "merge_sort(join->best_ref + join->const_tables,\n                 join->best_ref + join->tables,\n                 Join_tab_compare_straight())",
          "new_text": null,
          "old_line_content": "      merge_sort(join->best_ref + join->const_tables,",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1837,
          "old_api": "print_plan",
          "new_api": null,
          "old_text": "print_plan(join, idx+1,\n                                 record_count,\n                                 read_time,\n                                 read_time,\n                                 \"full_plan\")",
          "new_text": null,
          "old_line_content": "  DBUG_EXECUTE(\"opt\", print_plan(join, idx+1,",
          "new_line_content": "            sizeof(POSITION) * (idx + 1));",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": "add_alnum",
          "new_api": null,
          "old_text": "trace_access_scan.add_alnum(\"access_type\", \"range\").\n      add(\"chosen\", false).\n      add_alnum(\"cause\", \"heuristic_index_cheaper\")",
          "new_text": null,
          "old_line_content": "    trace_access_scan.add_alnum(\"access_type\", \"range\").",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 1326,
          "old_api": "Join_tab_compare_straight",
          "new_api": null,
          "old_text": "Join_tab_compare_straight()",
          "new_text": null,
          "old_line_content": "                 Join_tab_compare_straight());",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 1328,
          "old_api": "merge_sort",
          "new_api": null,
          "old_text": "merge_sort(join->best_ref + join->const_tables,\n                 join->best_ref + join->tables,\n                 Join_tab_compare_default())",
          "new_text": null,
          "old_line_content": "      merge_sort(join->best_ref + join->const_tables,",
          "new_line_content": "      if (SELECT_STRAIGHT_JOIN option is set)",
          "content_same": false
        },
        {
          "line": 818,
          "old_api": "ha_table_flags",
          "new_api": null,
          "old_text": "table->file->ha_table_flags()",
          "new_text": null,
          "old_line_content": "  else if ((table->file->ha_table_flags() & HA_TABLE_SCAN_ON_INDEX) &&    //(3)",
          "new_line_content": "      add(\"rows\", tab->found_records).",
          "content_same": false
        },
        {
          "line": 819,
          "old_api": "is_clear_all",
          "new_api": null,
          "old_text": "table->covering_keys.is_clear_all()",
          "new_text": null,
          "old_line_content": "      !table->covering_keys.is_clear_all() && best_ref &&                 //(3)",
          "new_line_content": "      add(\"chosen\", false).",
          "content_same": false
        },
        {
          "line": 1330,
          "old_api": "Join_tab_compare_default",
          "new_api": null,
          "old_text": "Join_tab_compare_default()",
          "new_text": null,
          "old_line_content": "                 Join_tab_compare_default());",
          "new_line_content": "        on, otherwise keep tables in the order they were specified in the query ",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": "get_type",
          "new_api": null,
          "old_text": "tab->quick->get_type()",
          "new_text": null,
          "old_line_content": "       (tab->quick->get_type() == QUICK_SELECT_I::QS_TYPE_ROR_INTERSECT &&//(3)",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": "add_alnum",
          "new_api": null,
          "old_text": "trace_access_scan.add_alnum(\"access_type\", tab->quick ? \"range\" : \"scan\").\n      add(\"chosen\", false).\n      add_alnum(\"cause\", \"covering_index_better_than_full_scan\")",
          "new_text": null,
          "old_line_content": "    trace_access_scan.add_alnum(\"access_type\", tab->quick ? \"range\" : \"scan\").",
          "new_line_content": "      (used_key_parts >= table->quick_key_parts[best_ref->key]))  // (2)",
          "content_same": false
        },
        {
          "line": 3897,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(remaining_tables & tab->table->map)",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(remaining_tables & tab->table->map);",
          "new_line_content": "  upwards to NJ1 and decrement its counter to 2. A subsequent removal of t4",
          "content_same": false
        },
        {
          "line": 2879,
          "old_api": "join_cond",
          "new_api": null,
          "old_text": "next_emb->join_cond()",
          "new_text": null,
          "old_line_content": "    if (!next_emb->join_cond())",
          "new_line_content": "      Cannot add it.",
          "content_same": false
        },
        {
          "line": 3392,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(emb_sjm_nest == NULL)",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(emb_sjm_nest == NULL);",
          "new_line_content": "  Opt_trace_context * const trace= &thd->opt_trace;",
          "content_same": false
        },
        {
          "line": 3905,
          "old_api": "join_cond",
          "new_api": null,
          "old_text": "last_emb->join_cond()",
          "new_text": null,
          "old_line_content": "    if (!last_emb->join_cond())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1343,
          "old_api": "greedy_search",
          "new_api": null,
          "old_text": "greedy_search(join_tables)",
          "new_text": null,
          "old_line_content": "    if (greedy_search(join_tables))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3395,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(remaining_tables & new_join_tab->table->map)",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(remaining_tables & new_join_tab->table->map);",
          "new_line_content": "  uint sj_strategy= SJ_OPT_NONE;  // Initially: No chosen strategy",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(true)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(true);",
          "new_line_content": "    join_tables= join->all_table_map & ~join->const_table_map;",
          "content_same": false
        },
        {
          "line": 2369,
          "old_api": "check_interleaving_with_nj",
          "new_api": null,
          "old_text": "check_interleaving_with_nj(s)",
          "new_text": null,
          "old_line_content": "        (!idx || !check_interleaving_with_nj(s)))  // 4)",
          "new_line_content": "    swap_variables(JOIN_TAB*, join->best_ref[idx], *pos);",
          "content_same": false
        },
        {
          "line": 3910,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(nest->nj_counter > 0)",
          "new_text": null,
          "old_line_content": "    DBUG_ASSERT(nest->nj_counter > 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2372,
          "old_api": "is_started",
          "new_api": null,
          "old_text": "trace->is_started()",
          "new_text": null,
          "old_line_content": "      if (unlikely(trace->is_started()))",
          "new_line_content": "      Consider table for 'eq_ref' heuristic if:",
          "content_same": false
        },
        {
          "line": 1349,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(false)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(false);",
          "new_line_content": "    trace_plan(&join->thd->opt_trace, \"considered_execution_plans\",",
          "content_same": false
        },
        {
          "line": 3401,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"Optimize_table_order::advance_sj_state\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"Optimize_table_order::advance_sj_state\");",
          "new_line_content": "    within a semi-join nest have emb_sj_nest != NULL, which triggers several",
          "content_same": false
        },
        {
          "line": 2374,
          "old_api": "trace_plan_prefix",
          "new_api": null,
          "old_text": "trace_plan_prefix(join, idx, excluded_tables)",
          "new_text": null,
          "old_line_content": "        trace_plan_prefix(join, idx, excluded_tables);",
          "new_line_content": "        2) and, Table remains to be handled.",
          "content_same": false
        },
        {
          "line": 2375,
          "old_api": "add_utf8_table",
          "new_api": null,
          "old_text": "trace_one_table.add_utf8_table(s->table)",
          "new_text": null,
          "old_line_content": "        trace_one_table.add_utf8_table(s->table);",
          "new_line_content": "        3) and, It is independent of those not yet in partial plan.",
          "content_same": false
        },
        {
          "line": 1353,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(true)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(true);",
          "new_line_content": "  else",
          "content_same": false
        },
        {
          "line": 2379,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(emb_sjm_nest == NULL || emb_sjm_nest == s->emb_sj_nest)",
          "new_text": null,
          "old_line_content": "      DBUG_ASSERT(emb_sjm_nest == NULL || emb_sjm_nest == s->emb_sj_nest);",
          "new_line_content": "        (remaining_tables & real_table_bit) &&     // 2)",
          "content_same": false
        },
        {
          "line": 335,
          "old_api": "index_flags",
          "new_api": null,
          "old_text": "table->file->index_flags(key, 0, 0)",
          "new_text": null,
          "old_line_content": "               (!(table->file->index_flags(key, 0, 0) & HA_ONLY_WHOLE_INDEX) ||",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": "LOWER_BITS",
          "new_api": null,
          "old_text": "LOWER_BITS(key_part_map,\n                                         actual_key_parts(keyinfo))",
          "new_text": null,
          "old_line_content": "                found_part == LOWER_BITS(key_part_map,",
          "new_line_content": "          else",
          "content_same": false
        },
        {
          "line": 345,
          "old_api": "max_part_bit",
          "new_api": null,
          "old_text": "max_part_bit(found_part)",
          "new_text": null,
          "old_line_content": "        cur_used_keyparts= max_part_bit(found_part);",
          "new_line_content": "        /*",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": "rows2double",
          "new_api": null,
          "old_text": "rows2double(scan_fanout)",
          "new_text": null,
          "old_line_content": "    trace_access_scan.add(\"rows\", rows2double(scan_fanout));",
          "new_line_content": "                                               &scan_fanout,",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_access_scan.add(\"cost\", scan_total_cost)",
          "new_text": null,
          "old_line_content": "    trace_access_scan.add(\"cost\", scan_total_cost);",
          "new_line_content": "                                               &trace_access_scan);",
          "content_same": false
        },
        {
          "line": 2396,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_one_table.add(\"added_to_eq_ref_extension\",\n                          added_to_eq_ref_extension)",
          "new_text": null,
          "old_line_content": "      trace_one_table.add(\"added_to_eq_ref_extension\",",
          "new_line_content": "      /*",
          "content_same": false
        },
        {
          "line": 3942,
          "old_api": "enum_query_type",
          "new_api": null,
          "old_text": "enum_query_type(QT_TO_SYSTEM_CHARSET |\n                                             QT_SHOW_SELECT_NUMBER |\n                                             QT_NO_DEFAULT_DB |\n                                             QT_DERIVED_TABLE_ONLY_ALIAS)",
          "new_text": null,
          "old_line_content": "        tl->print(thd, &str, enum_query_type(QT_TO_SYSTEM_CHARSET |",
          "new_line_content": "#ifdef OPTIMIZER_TRACE",
          "content_same": false
        },
        {
          "line": 2407,
          "old_api": "set_prefix_costs",
          "new_api": null,
          "old_text": "position->set_prefix_costs(current_read_time, current_record_count)",
          "new_text": null,
          "old_line_content": "        position->set_prefix_costs(current_read_time, current_record_count);",
          "new_line_content": "        position->fanout == (position-1)->fanout;",
          "content_same": false
        },
        {
          "line": 2409,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_one_table.add(\"cost_for_plan\", current_read_time).\n          add(\"rows_for_plan\", current_record_count)",
          "new_text": null,
          "old_line_content": "        trace_one_table.add(\"cost_for_plan\", current_read_time).",
          "new_line_content": "                          added_to_eq_ref_extension);",
          "content_same": false
        },
        {
          "line": 3946,
          "old_api": "length",
          "new_api": null,
          "old_text": "str.length()",
          "new_text": null,
          "old_line_content": "        plan_prefix.add_utf8(str.ptr(), str.length());",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_access_scan.add(\"chosen\", best_ref == NULL)",
          "new_text": null,
          "old_line_content": "    trace_access_scan.add(\"chosen\", best_ref == NULL);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2420,
          "old_api": "advance_sj_state",
          "new_api": null,
          "old_text": "advance_sj_state(remaining_tables, s, idx,\n                           &current_record_count, &current_read_time)",
          "new_text": null,
          "old_line_content": "          advance_sj_state(remaining_tables, s, idx,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2424,
          "old_api": "no_semijoin",
          "new_api": null,
          "old_text": "position->no_semijoin()",
          "new_text": null,
          "old_line_content": "          position->no_semijoin();",
          "new_line_content": "        if (has_sj)",
          "content_same": false
        },
        {
          "line": 2429,
          "old_api": "print_plan",
          "new_api": null,
          "old_text": "print_plan(join, idx+1,\n                                         current_record_count,\n                                         read_time,\n                                         current_read_time,\n                                         \"prune_by_cost\")",
          "new_text": null,
          "old_line_content": "          DBUG_EXECUTE(\"opt\", print_plan(join, idx+1,",
          "new_line_content": "            hence the if() above, which is also more efficient than the",
          "content_same": false
        },
        {
          "line": 2434,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_one_table.add(\"pruned_by_cost\", true)",
          "new_text": null,
          "old_line_content": "          trace_one_table.add(\"pruned_by_cost\", true);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 387,
          "old_api": "is_set",
          "new_api": null,
          "old_text": "table->quick_keys.is_set(key)",
          "new_text": null,
          "old_line_content": "        if (table->quick_keys.is_set(key) && !table_deps &&          //(C1)",
          "new_line_content": "          ref-or-null and looking for estimate for two intervals. This",
          "content_same": false
        },
        {
          "line": 2435,
          "old_api": "backout_nj_state",
          "new_api": null,
          "old_text": "backout_nj_state(remaining_tables, s)",
          "new_text": null,
          "old_line_content": "          backout_nj_state(remaining_tables, s);",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 389,
          "old_api": "test",
          "new_api": null,
          "old_text": "test(ref_or_null_part)",
          "new_text": null,
          "old_line_content": "            table->quick_n_ranges[key] == 1+test(ref_or_null_part))  //(C3)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2946,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\n           \"Optimize_table_order::semijoin_firstmatch_loosescan_access_paths\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(",
          "new_line_content": "    and non-dependent outer tables. The first and last table in the handled",
          "content_same": false
        },
        {
          "line": 3462,
          "old_api": "optimizer_switch_flag",
          "new_api": null,
          "old_text": "thd->optimizer_switch_flag(OPTIMIZER_SWITCH_FIRSTMATCH)",
          "new_text": null,
          "old_line_content": "      thd->optimizer_switch_flag(OPTIMIZER_SWITCH_FIRSTMATCH))",
          "new_line_content": "    - If tables from multiple semi-join nests are intertwined, they will",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_access_scan.add(\"use_tmp_table\", true)",
          "new_text": null,
          "old_line_content": "    trace_access_scan.add(\"use_tmp_table\", true);",
          "new_line_content": "  pos->read_cost=       best_read_cost;",
          "content_same": false
        },
        {
          "line": 2444,
          "old_api": "print_plan",
          "new_api": null,
          "old_text": "print_plan(join, idx + 1,\n                                         current_record_count,\n                                         read_time,\n                                         current_read_time,\n                                         \"EQ_REF_extension\")",
          "new_text": null,
          "old_line_content": "          DBUG_EXECUTE(\"opt\", print_plan(join, idx + 1,",
          "new_line_content": "                                         current_read_time,",
          "content_same": false
        },
        {
          "line": 2453,
          "old_api": "eq_ref_extension_by_limited_search",
          "new_api": null,
          "old_text": "eq_ref_extension_by_limited_search(remaining_tables_after,\n                                               idx + 1,\n                                               current_record_count,\n                                               current_read_time,\n                                               current_search_depth - 1)",
          "new_text": null,
          "old_line_content": "            eq_ref_extension_by_limited_search(remaining_tables_after,",
          "new_line_content": "          (remaining_tables & ~real_table_bit);",
          "content_same": false
        },
        {
          "line": 2965,
          "old_api": "total_cost",
          "new_api": null,
          "old_text": "positions[first_tab - 1].prefix_cost.total_cost()",
          "new_text": null,
          "old_line_content": "    cost=     positions[first_tab - 1].prefix_cost.total_cost();",
          "new_line_content": "  Opt_trace_object recalculate(trace, \"recalculate_access_paths_and_cost\");",
          "content_same": false
        },
        {
          "line": 3484,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(sj_inner_tables ==\n                  (remaining_tables_incl & sj_inner_tables))",
          "new_text": null,
          "old_line_content": "      DBUG_ASSERT(sj_inner_tables ==",
          "new_line_content": "           - the subquery is correlated with, or",
          "content_same": false
        },
        {
          "line": 2461,
          "old_api": "consider_plan",
          "new_api": null,
          "old_text": "consider_plan(idx, current_record_count, current_read_time,\n                        &trace_one_table)",
          "new_text": null,
          "old_line_content": "          consider_plan(idx, current_record_count, current_read_time,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2463,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT((remaining_tables_after != 0) ||\n                      ((cur_embedding_map == 0) &&\n                       (join->positions[idx].dups_producing_tables == 0)))",
          "new_text": null,
          "old_line_content": "          DBUG_ASSERT((remaining_tables_after != 0) ||",
          "new_line_content": "          Opt_trace_array trace_rest(trace, \"rest_of_plan\");",
          "content_same": false
        },
        {
          "line": 1442,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "join->select_lex->sj_nests.is_empty()",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(join->select_lex->sj_nests.is_empty());",
          "new_line_content": "    Thus 'optimize_straight_join' can be used at any stage of the query",
          "content_same": false
        },
        {
          "line": 2467,
          "old_api": "backout_nj_state",
          "new_api": null,
          "old_text": "backout_nj_state(remaining_tables, s)",
          "new_text": null,
          "old_line_content": "        backout_nj_state(remaining_tables, s);",
          "new_line_content": "                                               current_record_count,",
          "content_same": false
        },
        {
          "line": 2468,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(join->best_ref + idx, saved_refs,\n               sizeof(JOIN_TAB*) * (join->tables - idx))",
          "new_text": null,
          "old_line_content": "        memcpy(join->best_ref + idx, saved_refs,",
          "new_line_content": "                                               current_read_time,",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": "is_set",
          "new_api": null,
          "old_text": "table->quick_keys.is_set(key)",
          "new_text": null,
          "old_line_content": "            if (!table_deps && table->quick_keys.is_set(key) &&     // (1)",
          "new_line_content": "              record estimate for the quick object for (b,c).",
          "content_same": false
        },
        {
          "line": 2470,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(eq_ref_ext)",
          "new_text": null,
          "old_line_content": "        DBUG_RETURN(eq_ref_ext);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1449,
          "old_api": "is_started",
          "new_api": null,
          "old_text": "trace->is_started()",
          "new_text": null,
          "old_line_content": "    if (unlikely(trace->is_started()))",
          "new_line_content": "  uint idx= join->const_tables;",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": "used_tables",
          "new_api": null,
          "old_text": "outer->used_tables()",
          "new_text": null,
          "old_line_content": "    if (!((not_available_tables) & outer->used_tables()))",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1451,
          "old_api": "trace_plan_prefix",
          "new_api": null,
          "old_text": "trace_plan_prefix(join, idx, excluded_tables)",
          "new_text": null,
          "old_line_content": "      trace_plan_prefix(join, idx, excluded_tables);",
          "new_line_content": "  double    read_time=    0.0;",
          "content_same": false
        },
        {
          "line": 1452,
          "old_api": "add_utf8_table",
          "new_api": null,
          "old_text": "trace_table.add_utf8_table(s->table)",
          "new_text": null,
          "old_line_content": "      trace_table.add_utf8_table(s->table);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2477,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(join->best_ref + idx, saved_refs, sizeof(JOIN_TAB*) * (join->tables-idx))",
          "new_text": null,
          "old_line_content": "  memcpy(join->best_ref + idx, saved_refs, sizeof(JOIN_TAB*) * (join->tables-idx));",
          "new_line_content": "                       (join->positions[idx].dups_producing_tables == 0)));",
          "content_same": false
        },
        {
          "line": 1459,
          "old_api": "check_interleaving_with_nj",
          "new_api": null,
          "old_text": "check_interleaving_with_nj(s)",
          "new_text": null,
          "old_line_content": "    DBUG_ASSERT(!check_interleaving_with_nj(s));",
          "new_line_content": "    POSITION * const position= join->positions + idx;",
          "content_same": false
        },
        {
          "line": 3508,
          "old_api": "semijoin_firstmatch_loosescan_access_paths",
          "new_api": null,
          "old_text": "semijoin_firstmatch_loosescan_access_paths(\n                                        pos->first_firstmatch_table, idx,\n                                        remaining_tables, false, false,\n                                        &rowcount, &cost)",
          "new_text": null,
          "old_line_content": "        (void)semijoin_firstmatch_loosescan_access_paths(",
          "new_line_content": "          Trying to add an sj-inner table whose sj-nest has an outer correlated ",
          "content_same": false
        },
        {
          "line": 2483,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(!eq_ref_ext)",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(!eq_ref_ext);",
          "new_line_content": "      } // if (added_to_eq_ref_extension)",
          "content_same": false
        },
        {
          "line": 2484,
          "old_api": "best_extension_by_limited_search",
          "new_api": null,
          "old_text": "best_extension_by_limited_search(remaining_tables,\n                                       idx,\n                                       record_count,\n                                       read_time,\n                                       current_search_depth)",
          "new_text": null,
          "old_line_content": "  if (best_extension_by_limited_search(remaining_tables,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3507,
          "old_api": "add_alnum",
          "new_api": null,
          "old_text": "trace_one_strategy.add_alnum(\"strategy\", \"FirstMatch\")",
          "new_text": null,
          "old_line_content": "        trace_one_strategy.add_alnum(\"strategy\", \"FirstMatch\");",
          "new_line_content": "        /*",
          "content_same": false
        },
        {
          "line": 1976,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"Optimize_table_order::best_extension_by_limited_search\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"Optimize_table_order::best_extension_by_limited_search\");",
          "new_line_content": "                          (0 < current_search_depth <= join->tables+1).",
          "content_same": false
        },
        {
          "line": 1978,
          "old_api": "DBUG_EXECUTE_IF",
          "new_api": null,
          "old_text": "DBUG_EXECUTE_IF(\"bug13820776_2\", thd->killed= THD::KILL_QUERY;)",
          "new_text": null,
          "old_line_content": "  DBUG_EXECUTE_IF(\"bug13820776_2\", thd->killed= THD::KILL_QUERY;);",
          "new_line_content": "  @return false if successful, true if error",
          "content_same": false
        },
        {
          "line": 1467,
          "old_api": "set_prefix_costs",
          "new_api": null,
          "old_text": "position->set_prefix_costs(read_time, record_count)",
          "new_text": null,
          "old_line_content": "    position->set_prefix_costs(read_time, record_count);",
          "new_line_content": "      Dependency computation (make_join_statistics()) and proper ordering",
          "content_same": false
        },
        {
          "line": 1468,
          "old_api": "no_semijoin",
          "new_api": null,
          "old_text": "position->no_semijoin()",
          "new_text": null,
          "old_line_content": "    position->no_semijoin(); // advance_sj_state() is not needed",
          "new_line_content": "      based on them (join_tab_cmp*) guarantee that this order is compatible",
          "content_same": false
        },
        {
          "line": 1980,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(true)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1470,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_table.add(\"cost_for_plan\", read_time).\n      add(\"rows_for_plan\", record_count)",
          "new_text": null,
          "old_line_content": "    trace_table.add(\"cost_for_plan\", read_time).",
          "new_line_content": "    */",
          "content_same": false
        },
        {
          "line": 2491,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(eq_ref_ext)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(eq_ref_ext);",
          "new_line_content": "    'eq_ref' heuristc didn't find a table to be appended to",
          "content_same": false
        },
        {
          "line": 3007,
          "old_api": "add_utf8_table",
          "new_api": null,
          "old_text": "trace_one_table.add_utf8_table(tab->table)",
          "new_text": null,
          "old_line_content": "      trace_one_table.add_utf8_table(tab->table);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 3010,
          "old_api": "best_access_path",
          "new_api": null,
          "old_text": "best_access_path(tab, remaining_tables, i, \n                       i < no_jbuf_before,\n                       rowcount * inner_fanout * outer_fanout,\n                       dst_pos)",
          "new_text": null,
          "old_line_content": "      best_access_path(tab, remaining_tables, i, ",
          "new_line_content": "    POSITION *const dst_pos= final ? positions + i : &regular_pos;",
          "content_same": false
        },
        {
          "line": 3524,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_one_strategy.add(\"cost\", *current_cost).\n          add(\"rows\", *current_rowcount)",
          "new_text": null,
          "old_line_content": "        trace_one_strategy.add(\"cost\", *current_cost).",
          "new_line_content": "        /*",
          "content_same": false
        },
        {
          "line": 3016,
          "old_api": "semijoin_loosescan_fill_driving_table_position",
          "new_api": null,
          "old_text": "semijoin_loosescan_fill_driving_table_position(tab,\n                                                           remaining_tables,\n                                                           i, dst_pos)",
          "new_text": null,
          "old_line_content": "        if (semijoin_loosescan_fill_driving_table_position(tab,",
          "new_line_content": "    if ((i == first_tab && loosescan) || positions[i].use_join_buffer)",
          "content_same": false
        },
        {
          "line": 3528,
          "old_api": "add",
          "new_api": null,
          "old_text": "trace_one_strategy.add(\"chosen\", true)",
          "new_text": null,
          "old_line_content": "        trace_one_strategy.add(\"chosen\", true);",
          "new_line_content": "          semijoin_firstmatch_loosescan_access_paths() but the problem is that",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": "type",
          "new_api": null,
          "old_text": "outer->type()",
          "new_text": null,
          "old_line_content": "    if (outer->type() == Item::FIELD_ITEM)",
          "new_line_content": "      the COND_EQUAL of the join nest which embeds the field's table. For",
          "content_same": false
        },
        {
          "line": 1997,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "join->select_lex->sj_nests.is_empty()",
          "new_text": null,
          "old_line_content": "  const bool has_sj= !(join->select_lex->sj_nests.is_empty() || emb_sjm_nest);",
          "new_line_content": "     so continue expanding it further with the tables in 'remaining_tables'.",
          "content_same": false
        },
        {
          "line": 974,
          "old_api": "type",
          "new_api": null,
          "old_text": "inner->type()",
          "new_text": null,
          "old_line_content": "    else if (inner->type() == Item::FIELD_ITEM)",
          "new_line_content": "      select * from t1 left join t1 as t2",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": "set_if_bigger",
          "new_api": null,
          "old_text": "set_if_bigger(tmp_fanout, 1.0)",
          "new_text": null,
          "old_line_content": "              set_if_bigger(tmp_fanout, 1.0);",
          "new_line_content": "                tmp_fanout=",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "static_cast<Item_field *>(item)",
          "new_api": null,
          "old_text": "static_cast<Item_field *>(item)",
          "new_text": null,
          "old_line_content": "    Item_field *const item_field= static_cast<Item_field *>(item);",
          "new_line_content": "      containing, among others: t2.a=t1.a",
          "content_same": false
        },
        {
          "line": 3029,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(false)",
          "new_text": null,
          "old_line_content": "          DBUG_RETURN(false);",
          "new_line_content": "                                                           remaining_tables,",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": "outer_join_nest",
          "new_api": null,
          "old_text": "item_field->field->table->pos_in_table_list->outer_join_nest()",
          "new_text": null,
          "old_line_content": "        item_field->field->table->pos_in_table_list->outer_join_nest();",
          "new_line_content": "    Item *item;",
          "content_same": false
        },
        {
          "line": 3545,
          "old_api": "optimizer_switch_flag",
          "new_api": null,
          "old_text": "thd->optimizer_switch_flag(OPTIMIZER_SWITCH_LOOSE_SCAN)",
          "new_text": null,
          "old_line_content": "  if (thd->optimizer_switch_flag(OPTIMIZER_SWITCH_LOOSE_SCAN))",
          "new_line_content": "    LooseScan Strategy",
          "content_same": false
        },
        {
          "line": 3043,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(loosescan && !final)",
          "new_text": null,
          "old_line_content": "      DBUG_ASSERT(loosescan && !final);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3044,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(false)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(false);",
          "new_line_content": "      pos= dst_pos;",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": "is_set",
          "new_api": null,
          "old_text": "table->covering_keys.is_set(key)",
          "new_text": null,
          "old_line_content": "        if (table->covering_keys.is_set(key))",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": "is_set",
          "new_api": null,
          "old_text": "table->quick_keys.is_set(key)",
          "new_text": null,
          "old_line_content": "          if (table->quick_keys.is_set(key) &&",
          "new_line_content": "            current estimate, make the adjustment.",
          "content_same": false
        },
        {
          "line": 2027,
          "old_api": "check_interleaving_with_nj",
          "new_api": null,
          "old_text": "check_interleaving_with_nj(s)",
          "new_text": null,
          "old_line_content": "        (!idx || !check_interleaving_with_nj(s)))",
          "new_line_content": "    const table_map real_table_bit= s->table->map;",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": "test",
          "new_api": null,
          "old_text": "test(ref_or_null_part &\n                                                     const_part)",
          "new_text": null,
          "old_line_content": "              table->quick_n_ranges[key] == 1 + test(ref_or_null_part &",
          "new_line_content": "            applied to first table->quick_key_parts[key] key parts.",
          "content_same": false
        },
        {
          "line": 3564,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(emb_sj_nest != first_emb_sj_nest)",
          "new_text": null,
          "old_line_content": "        DBUG_ASSERT(emb_sj_nest != first_emb_sj_nest);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2031,
          "old_api": "is_started",
          "new_api": null,
          "old_text": "trace->is_started()",
          "new_text": null,
          "old_line_content": "      if (unlikely(trace->is_started()))",
          "new_line_content": "      be uncond. swapped to maintain '#rows-ordered' best_ref[].",
          "content_same": false
        },
        {
          "line": 2033,
          "old_api": "trace_plan_prefix",
          "new_api": null,
          "old_text": "trace_plan_prefix(join, idx, excluded_tables)",
          "new_text": null,
          "old_line_content": "        trace_plan_prefix(join, idx, excluded_tables);",
          "new_line_content": "    */",
          "content_same": false
        },
        {
          "line": 2034,
          "old_api": "add_utf8_table",
          "new_api": null,
          "old_text": "trace_one_table.add_utf8_table(s->table)",
          "new_text": null,
          "old_line_content": "        trace_one_table.add_utf8_table(s->table);",
          "new_line_content": "    swap_variables(JOIN_TAB*, join->best_ref[idx], *pos);",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": "set_if_smaller",
          "new_api": null,
          "old_text": "set_if_smaller(tmp_fanout,\n                       (double) thd->variables.max_seeks_for_key)",
          "new_text": null,
          "old_line_content": "        set_if_smaller(tmp_fanout,",
          "new_line_content": "          {",
          "content_same": false
        },
        {
          "line": 3061,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(true)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(true);",
          "new_line_content": "    if (tab->emb_sj_nest)",
          "content_same": false
        },
        {
          "line": 1527,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(!(remaining_tables & tab->table->map))",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(!(remaining_tables & tab->table->map));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2041,
          "old_api": "best_access_path",
          "new_api": null,
          "old_text": "best_access_path(s, remaining_tables, idx, false, record_count, \n                       position)",
          "new_text": null,
          "old_line_content": "      best_access_path(s, remaining_tables, idx, false, record_count, ",
          "new_line_content": "      double current_record_count, current_read_time;",
          "content_same": false
        },
        {
          "line": 510,
          "old_api": "min",
          "new_api": null,
          "old_text": "min(tmp_fanout, tab->worst_seeks)",
          "new_text": null,
          "old_line_content": "          cur_read_cost= prefix_rowcount * min(tmp_fanout, tab->worst_seeks);",
          "new_line_content": "        {",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 36,
      "total_additions": 231,
      "total_deletions": 227,
      "total_api_changes": 494
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 12,
        "api_related_lines": 494,
        "non_api_lines": 6,
        "non_api_line_numbers": [
          517,
          518,
          520,
          330,
          332,
          333
        ]
      }
    },
    "api_calls_before": 327,
    "api_calls_after": 331,
    "diff_info": {
      "added_lines": 12,
      "removed_lines": 0,
      "total_diff_lines": 31
    }
  }
}