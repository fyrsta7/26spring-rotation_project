{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/mysql-server/modified_file/78e067e69ab7afa9f02b03e1c3f398e4da4d7377",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/mysql-server/modified_file/78e067e69ab7afa9f02b03e1c3f398e4da4d7377/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/mysql-server/modified_file/78e067e69ab7afa9f02b03e1c3f398e4da4d7377/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/mysql-server/modified_file/78e067e69ab7afa9f02b03e1c3f398e4da4d7377/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 1688,
          "old_api": "ha_rnd_init",
          "new_api": "DBUG_RETURN",
          "old_text": "head->file->ha_rnd_init(1)",
          "new_text": "DBUG_RETURN(error)",
          "old_line_content": "  if ((error= head->file->ha_rnd_init(1)))",
          "new_line_content": "      DBUG_RETURN(error);",
          "content_same": false
        },
        {
          "line": 1701,
          "old_api": "push_back",
          "new_api": "DBUG_PRINT",
          "old_text": "quick_selects.push_back(quick_sel_range)",
          "new_text": "DBUG_PRINT(\"error\", (\"ROR index_merge rnd_init call failed\"))",
          "old_line_content": "  return quick_selects.push_back(quick_sel_range);",
          "new_line_content": "    DBUG_PRINT(\"error\", (\"ROR index_merge rnd_init call failed\"));",
          "content_same": false
        },
        {
          "line": 1804,
          "old_api": "increment_use_count",
          "new_api": "clone",
          "old_text": "increment_use_count(1)",
          "new_text": "left->clone(param, tmp, next_arg)",
          "old_line_content": "  increment_use_count(1);",
          "new_line_content": "      if (!(tmp->left=left->clone(param, tmp, next_arg)))",
          "content_same": false
        },
        {
          "line": 2138,
          "old_api": "bitmap_clear_bit",
          "new_api": "bitmap_copy",
          "old_text": "bitmap_clear_bit(&param->needed_fields, key_part->fieldnr-1)",
          "new_text": "bitmap_copy(&param->needed_fields, table->read_set)",
          "old_line_content": "      bitmap_clear_bit(&param->needed_fields, key_part->fieldnr-1);",
          "new_line_content": "  bitmap_copy(&param->needed_fields, table->read_set);",
          "content_same": false
        },
        {
          "line": 2231,
          "old_api": "scan_time",
          "new_api": "DBUG_PRINT",
          "old_text": "head->file->scan_time()",
          "new_text": "DBUG_PRINT(\"info\", (\"records: %lu\", (ulong) head->file->stats.records))",
          "old_line_content": "  read_time= (double) head->file->scan_time() + scan_time + 1.1;",
          "new_line_content": "  DBUG_PRINT(\"info\", (\"records: %lu\", (ulong) head->file->stats.records));",
          "content_same": false
        },
        {
          "line": 2242,
          "old_api": "is_clear_all",
          "new_api": "scan_time",
          "old_text": "keys_to_use.is_clear_all()",
          "new_text": "head->file->scan_time()",
          "old_line_content": "  if (!keys_to_use.is_clear_all())",
          "new_line_content": "  read_time= (double) head->file->scan_time() + scan_time + 1.1;",
          "content_same": false
        },
        {
          "line": 2252,
          "old_api": "DBUG_RETURN",
          "new_api": "intersect",
          "old_text": "DBUG_RETURN(0)",
          "new_text": "keys_to_use.intersect(head->keys_in_use_for_query)",
          "old_line_content": "      DBUG_RETURN(0);                           // Fatal error flag is set",
          "new_line_content": "  keys_to_use.intersect(head->keys_in_use_for_query);",
          "content_same": false
        },
        {
          "line": 2430,
          "old_api": "get_best_disjunct_quick",
          "new_api": "optimizer_flag",
          "old_text": "get_best_disjunct_quick(&param, imerge, best_read_time)",
          "new_text": "optimizer_flag(thd, OPTIMIZER_SWITCH_INDEX_MERGE)",
          "old_line_content": "            new_conj_trp= get_best_disjunct_quick(&param, imerge, best_read_time);",
          "new_line_content": "        if (optimizer_flag(thd, OPTIMIZER_SWITCH_INDEX_MERGE))",
          "content_same": false
        },
        {
          "line": 2469,
          "old_api": "test",
          "new_api": "MYF",
          "old_text": "test(quick)",
          "new_text": "MYF(0)",
          "old_line_content": "  DBUG_RETURN(records ? test(quick) : -1);",
          "new_line_content": "    free_root(&alloc,MYF(0));\t\t\t// Return memory & allocator",
          "content_same": false
        },
        {
          "line": 2704,
          "old_api": "dbug_tmp_use_all_columns",
          "new_api": "init_sql_alloc",
          "old_text": "dbug_tmp_use_all_columns(table, old_sets, \n                           table->read_set, table->write_set)",
          "new_text": "init_sql_alloc(&alloc, thd->variables.range_alloc_block_size, 0)",
          "old_line_content": "  dbug_tmp_use_all_columns(table, old_sets, ",
          "new_line_content": "  init_sql_alloc(&alloc, thd->variables.range_alloc_block_size, 0);",
          "content_same": false
        },
        {
          "line": 2751,
          "old_api": "init_all_partitions_iterator",
          "new_api": "is_empty",
          "old_text": "init_all_partitions_iterator(part_info, &prune_param.part_iter)",
          "new_text": "tree->merges.is_empty()",
          "old_line_content": "    init_all_partitions_iterator(part_info, &prune_param.part_iter);",
          "new_line_content": "  if (tree->merges.is_empty())",
          "content_same": false
        },
        {
          "line": 2793,
          "old_api": "test",
          "new_api": "find_used_partitions_imerge_list",
          "old_text": "test(!res)",
          "new_text": "find_used_partitions_imerge_list(&prune_param,\n                                                       tree->merges)",
          "old_line_content": "  retval= test(!res);",
          "new_line_content": "      if (-1 == (res= find_used_partitions_imerge_list(&prune_param,",
          "content_same": false
        },
        {
          "line": 2804,
          "old_api": "DBUG_RETURN",
          "new_api": "test",
          "old_text": "DBUG_RETURN(retval)",
          "new_text": "test(!res)",
          "old_line_content": "  DBUG_RETURN(retval);",
          "new_line_content": "  retval= test(!res);",
          "content_same": false
        },
        {
          "line": 2878,
          "old_api": "DBUG_PRINT",
          "new_api": "store_key_image_to_rec",
          "old_text": "DBUG_PRINT(\"enter\", (\"Mark partition %u as used\", part_id))",
          "new_text": "store_key_image_to_rec(sel_arg->field, sel_arg->min_value,\n                           parts[sel_arg->part].length)",
          "old_line_content": "  DBUG_PRINT(\"enter\", (\"Mark partition %u as used\", part_id));",
          "new_line_content": "    store_key_image_to_rec(sel_arg->field, sel_arg->min_value,",
          "content_same": false
        },
        {
          "line": 2890,
          "old_api": "DBUG_ENTER",
          "new_api": "bitmap_set_bit",
          "old_text": "DBUG_ENTER(\"mark_full_partition_used_with_parts\")",
          "new_text": "bitmap_set_bit(&part_info->used_partitions, part_id)",
          "old_line_content": "  DBUG_ENTER(\"mark_full_partition_used_with_parts\");",
          "new_line_content": "  bitmap_set_bit(&part_info->used_partitions, part_id);",
          "content_same": false
        },
        {
          "line": 2935,
          "old_api": "bitmap_set_prefix",
          "new_api": "bitmap_buffer_size",
          "old_text": "bitmap_set_prefix(&all_merges, n_bits)",
          "new_text": "bitmap_buffer_size(n_bits)",
          "old_line_content": "  bitmap_set_prefix(&all_merges, n_bits);",
          "new_line_content": "  bitmap_bytes= bitmap_buffer_size(n_bits);",
          "content_same": false
        },
        {
          "line": 3316,
          "old_api": "bitmap_set_bit",
          "new_api": "is_error",
          "old_text": "bitmap_set_bit(&ppar->subparts_bitmap, subpart_id)",
          "new_text": "range_par->thd->is_error()",
          "old_line_content": "        bitmap_set_bit(&ppar->subparts_bitmap, subpart_id);",
          "new_line_content": "        DBUG_ASSERT(range_par->thd->is_error());",
          "content_same": false
        },
        {
          "line": 3324,
          "old_api": "bitmap_is_set",
          "new_api": "bitmap_clear_all",
          "old_text": "bitmap_is_set(&ppar->subparts_bitmap, i)",
          "new_text": "bitmap_clear_all(&ppar->subparts_bitmap)",
          "old_line_content": "          if (bitmap_is_set(&ppar->subparts_bitmap, i))",
          "new_line_content": "      bitmap_clear_all(&ppar->subparts_bitmap);",
          "content_same": false
        },
        {
          "line": 3325,
          "old_api": "bitmap_set_bit",
          "new_api": "get_next",
          "old_text": "bitmap_set_bit(&ppar->part_info->used_partitions,\n                           part_id * ppar->part_info->num_subparts + i)",
          "new_text": "subpart_iter.get_next(&subpart_iter)",
          "old_line_content": "            bitmap_set_bit(&ppar->part_info->used_partitions,",
          "new_line_content": "      while ((subpart_id= subpart_iter.get_next(&subpart_iter)) !=",
          "content_same": false
        },
        {
          "line": 3331,
          "old_api": "is_singlepoint",
          "new_api": "get_next",
          "old_text": "key_tree->is_singlepoint()",
          "new_text": "ppar->part_iter.get_next(&ppar->part_iter)",
          "old_line_content": "    if (key_tree->is_singlepoint())",
          "new_line_content": "      while ((part_id= ppar->part_iter.get_next(&ppar->part_iter)) !=",
          "content_same": false
        },
        {
          "line": 3342,
          "old_api": "dbug_print_singlepoint_range",
          "new_api": "is_singlepoint",
          "old_text": "dbug_print_singlepoint_range(ppar->arg_stack,\n                                                       ppar->part_fields)",
          "new_text": "key_tree->is_singlepoint()",
          "old_line_content": "        DBUG_EXECUTE(\"info\", dbug_print_singlepoint_range(ppar->arg_stack,",
          "new_line_content": "    if (key_tree->is_singlepoint())",
          "content_same": false
        },
        {
          "line": 3384,
          "old_api": "get_next",
          "new_api": "dbug_print_singlepoint_range",
          "old_text": "ppar->part_iter.get_next(&ppar->part_iter)",
          "new_text": "dbug_print_singlepoint_range(ppar->arg_stack_end- \n                                                       ppar->subpart_fields,\n                                                       ppar->subpart_fields)",
          "old_line_content": "        while ((part_id= ppar->part_iter.get_next(&ppar->part_iter)) !=",
          "new_line_content": "        DBUG_EXECUTE(\"info\", dbug_print_singlepoint_range(ppar->arg_stack_end- ",
          "content_same": false
        },
        {
          "line": 3585,
          "old_api": "bitmap_buffer_size",
          "new_api": "alloc_root",
          "old_text": "bitmap_buffer_size(ppar->part_info->num_subparts)",
          "new_text": "alloc_root(alloc, sizeof(SEL_ARG*)* \n                                                      total_parts)",
          "old_line_content": "    uint32 bufsize= bitmap_buffer_size(ppar->part_info->num_subparts);",
          "new_line_content": "      !(ppar->arg_stack= (SEL_ARG**)alloc_root(alloc, sizeof(SEL_ARG*)* ",
          "content_same": false
        },
        {
          "line": 3599,
          "old_api": "key_length",
          "new_api": "bitmap_init",
          "old_text": "uint16)(*field)->key_length()",
          "new_text": "bitmap_init(&ppar->subparts_bitmap, buf, ppar->part_info->num_subparts,\n                FALSE)",
          "old_line_content": "    key_part->length= (uint16)(*field)->key_length();",
          "new_line_content": "    bitmap_init(&ppar->subparts_bitmap, buf, ppar->part_info->num_subparts,",
          "content_same": false
        },
        {
          "line": 3672,
          "old_api": "DBUG_ENTER",
          "new_api": "length",
          "old_text": "DBUG_ENTER(\"dbug_print_segment_range\")",
          "new_text": "str.length(0)",
          "old_line_content": "  DBUG_ENTER(\"dbug_print_segment_range\");",
          "new_line_content": "    str.length(0);",
          "content_same": false
        },
        {
          "line": 3692,
          "old_api": "store_key_image_to_rec",
          "new_api": "fputs",
          "old_text": "store_key_image_to_rec(part->field, arg->max_value, part->length)",
          "new_text": "fputs(\" <= \", DBUG_FILE)",
          "old_line_content": "    store_key_image_to_rec(part->field, arg->max_value, part->length);",
          "new_line_content": "      fputs(\" <= \", DBUG_FILE);",
          "content_same": false
        },
        {
          "line": 3695,
          "old_api": "fputs",
          "new_api": "fprintf",
          "old_text": "fputs(\"\\n\", DBUG_FILE)",
          "new_text": "fprintf(DBUG_FILE, \"%s\", part->field->field_name)",
          "old_line_content": "  fputs(\"\\n\", DBUG_FILE);",
          "new_line_content": "  fprintf(DBUG_FILE, \"%s\", part->field->field_name);",
          "content_same": false
        },
        {
          "line": 3763,
          "old_api": "rows2double",
          "new_api": "primary_key_is_clustered",
          "old_text": "rows2double(records)",
          "new_text": "param->table->file->primary_key_is_clustered()",
          "old_line_content": "      n_blocks * (1.0 - pow(1.0 - 1.0/n_blocks, rows2double(records)));",
          "new_line_content": "  if (param->table->file->primary_key_is_clustered())",
          "content_same": false
        },
        {
          "line": 3939,
          "old_api": "DBUG_RETURN",
          "new_api": "DBUG_PRINT",
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": "DBUG_PRINT(\"info\", (\"index_merge scans cost %g\", imerge_cost))",
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "  DBUG_PRINT(\"info\", (\"index_merge scans cost %g\", imerge_cost));",
          "content_same": false
        },
        {
          "line": 3948,
          "old_api": "optimizer_flag",
          "new_api": "DBUG_PRINT",
          "old_text": "optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_UNION)",
          "new_text": "DBUG_PRINT(\"info\", (\"Sum of index_merge scans is more expensive than \"\n                        \"full table scan, bailing out\"))",
          "old_line_content": "      optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_UNION))",
          "new_line_content": "    DBUG_PRINT(\"info\", (\"Sum of index_merge scans is more expensive than \"",
          "content_same": false
        },
        {
          "line": 3975,
          "old_api": "Unique::get_cost_calc_buff_size((ulong)non_cpk_scan_records,\n                                    param->table->file->ref_length,\n                                    param->thd->variables.sortbuff_size)",
          "new_api": "get_sweep_read_cost",
          "old_text": "Unique::get_cost_calc_buff_size((ulong)non_cpk_scan_records,\n                                    param->table->file->ref_length,\n                                    param->thd->variables.sortbuff_size)",
          "new_text": "get_sweep_read_cost(param, non_cpk_scan_records)",
          "old_line_content": "    Unique::get_cost_calc_buff_size((ulong)non_cpk_scan_records,",
          "new_line_content": "  imerge_cost += get_sweep_read_cost(param, non_cpk_scan_records);",
          "content_same": false
        },
        {
          "line": 3998,
          "old_api": "min",
          "new_api": "Unique::get_use_cost(param->imerge_cost_buff, (uint)non_cpk_scan_records,\n                         param->table->file->ref_length,\n                         param->thd->variables.sortbuff_size)",
          "old_text": "min(imerge_trp->records,\n                               param->table->file->stats.records)",
          "new_text": "Unique::get_use_cost(param->imerge_cost_buff, (uint)non_cpk_scan_records,\n                         param->table->file->ref_length,\n                         param->thd->variables.sortbuff_size)",
          "old_line_content": "      imerge_trp->records= min(imerge_trp->records,",
          "new_line_content": "    Unique::get_use_cost(param->imerge_cost_buff, (uint)non_cpk_scan_records,",
          "content_same": false
        },
        {
          "line": 4009,
          "old_api": "optimizer_flag",
          "new_api": "min",
          "old_text": "optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_UNION)",
          "new_text": "min(imerge_trp->records,\n                               param->table->file->stats.records)",
          "old_line_content": "      !optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_UNION))",
          "new_line_content": "      imerge_trp->records= min(imerge_trp->records,",
          "content_same": false
        },
        {
          "line": 4099,
          "old_api": "DBUG_RETURN",
          "new_api": "DBUG_PRINT",
          "old_text": "DBUG_RETURN(roru)",
          "new_text": "DBUG_PRINT(\"info\", (\"ROR-union: cost %g, %d members\", roru_total_cost,\n                      n_child_scans))",
          "old_line_content": "      DBUG_RETURN(roru);",
          "new_line_content": "  DBUG_PRINT(\"info\", (\"ROR-union: cost %g, %d members\", roru_total_cost,",
          "content_same": false
        },
        {
          "line": 4215,
          "old_api": "bitmap_set_bit",
          "new_api": "bitmap_init",
          "old_text": "bitmap_set_bit(&ror_scan->covered_fields, key_part->fieldnr-1)",
          "new_text": "bitmap_init(&ror_scan->covered_fields, bitmap_buf,\n                  param->table->s->fields, FALSE)",
          "old_line_content": "      bitmap_set_bit(&ror_scan->covered_fields, key_part->fieldnr-1);",
          "new_line_content": "  if (bitmap_init(&ror_scan->covered_fields, bitmap_buf,",
          "content_same": false
        },
        {
          "line": 4218,
          "old_api": "get_index_only_read_time",
          "new_api": "bitmap_clear_all",
          "old_text": "get_index_only_read_time(param, param->table->quick_rows[ror_scan->keynr],\n                             ror_scan->keynr)",
          "new_text": "bitmap_clear_all(&ror_scan->covered_fields)",
          "old_line_content": "    get_index_only_read_time(param, param->table->quick_rows[ror_scan->keynr],",
          "new_line_content": "  bitmap_clear_all(&ror_scan->covered_fields);",
          "content_same": false
        },
        {
          "line": 4472,
          "old_api": "store_min",
          "new_api": "DBUG_PRINT",
          "old_text": "tuple_arg->store_min(key_part->store_length, &key_ptr, 0)",
          "new_text": "DBUG_PRINT(\"info\",(\"sel_arg step\"))",
          "old_line_content": "        tuple_arg->store_min(key_part->store_length, &key_ptr, 0);",
          "new_line_content": "    DBUG_PRINT(\"info\",(\"sel_arg step\"));",
          "content_same": false
        },
        {
          "line": 4489,
          "old_api": "rows2double",
          "new_api": "store_min",
          "old_text": "rows2double(prev_records)",
          "new_text": "tuple_arg->store_min(key_part[tuple_arg->part].store_length,\n                             &key_ptr, 0)",
          "old_line_content": "        double tmp= rows2double(records)/rows2double(prev_records);",
          "new_line_content": "        tuple_arg->store_min(key_part[tuple_arg->part].store_length,",
          "content_same": false
        },
        {
          "line": 4566,
          "old_api": "DBUG_RETURN",
          "new_api": "DBUG_ENTER",
          "old_text": "DBUG_RETURN(FALSE)",
          "new_text": "DBUG_ENTER(\"ror_intersect_add\")",
          "old_line_content": "    DBUG_RETURN(FALSE);",
          "new_line_content": "  DBUG_ENTER(\"ror_intersect_add\");",
          "content_same": false
        },
        {
          "line": 4589,
          "old_api": "DBUG_PRINT",
          "new_api": "rows2double",
          "old_text": "DBUG_PRINT(\"info\", (\"ROR-intersect is covering now\"))",
          "new_text": "rows2double(info->index_records)",
          "old_line_content": "      DBUG_PRINT(\"info\", (\"ROR-intersect is covering now\"));",
          "new_line_content": "    info->index_scan_costs += rows2double(info->index_records) / ",
          "content_same": false
        },
        {
          "line": 4695,
          "old_api": "alloc_root",
          "new_api": "DBUG_RETURN",
          "old_text": "alloc_root(param->mem_root,\n                                                     sizeof(ROR_SCAN_INFO*)*\n                                                     param->keys)",
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "  if (!(tree->ror_scans= (ROR_SCAN_INFO**)alloc_root(param->mem_root,",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 4754,
          "old_api": "ror_intersect_add",
          "new_api": "ror_intersect_init",
          "old_text": "ror_intersect_add(intersect, *cur_ror_scan, FALSE)",
          "new_text": "ror_intersect_init(param)",
          "old_line_content": "    if (!ror_intersect_add(intersect, *cur_ror_scan, FALSE))",
          "new_line_content": "  if (!(intersect= ror_intersect_init(param)) || ",
          "content_same": false
        },
        {
          "line": 4765,
          "old_api": "ror_intersect_cpy",
          "new_api": "ror_intersect_add",
          "old_text": "ror_intersect_cpy(intersect_best, intersect)",
          "new_text": "ror_intersect_add(intersect, *cur_ror_scan, FALSE)",
          "old_line_content": "      ror_intersect_cpy(intersect_best, intersect);",
          "new_line_content": "    if (!ror_intersect_add(intersect, *cur_ror_scan, FALSE))",
          "content_same": false
        },
        {
          "line": 4784,
          "old_api": "ror_intersect_cpy",
          "new_api": "DBUG_PRINT",
          "old_text": "ror_intersect_cpy(intersect, intersect_best)",
          "new_text": "DBUG_PRINT(\"info\", (\"None of scans increase selectivity\"))",
          "old_line_content": "  ror_intersect_cpy(intersect, intersect_best);",
          "new_line_content": "    DBUG_PRINT(\"info\", (\"None of scans increase selectivity\"));",
          "content_same": false
        },
        {
          "line": 4819,
          "old_api": "set_if_smaller",
          "new_api": "alloc_root",
          "old_text": "set_if_smaller(param->table->quick_condition_rows, best_rows)",
          "new_text": "alloc_root(param->mem_root,\n                                       sizeof(ROR_SCAN_INFO*)*best_num)",
          "old_line_content": "    set_if_smaller(param->table->quick_condition_rows, best_rows);",
          "new_line_content": "           (ROR_SCAN_INFO**)alloc_root(param->mem_root,",
          "content_same": false
        },
        {
          "line": 4827,
          "old_api": "DBUG_RETURN",
          "new_api": "double2rows",
          "old_text": "DBUG_RETURN(trp)",
          "new_text": "double2rows(intersect_best->out_rows)",
          "old_line_content": "  DBUG_RETURN(trp);",
          "new_line_content": "    ha_rows best_rows = double2rows(intersect_best->out_rows);",
          "content_same": false
        },
        {
          "line": 4949,
          "old_api": "DBUG_PRINT",
          "new_api": "bitmap_union",
          "old_text": "DBUG_PRINT(\"info\", (\"Covering ROR-intersect scans cost: %g\", total_cost))",
          "new_text": "bitmap_union(covered_fields, &(*ror_scan_mark)->covered_fields)",
          "old_line_content": "  DBUG_PRINT(\"info\", (\"Covering ROR-intersect scans cost: %g\", total_cost));",
          "new_line_content": "    bitmap_union(covered_fields, &(*ror_scan_mark)->covered_fields);",
          "content_same": false
        },
        {
          "line": 4950,
          "old_api": "print_ror_scans_arr",
          "new_api": "bitmap_is_subset",
          "old_text": "print_ror_scans_arr(param->table,\n                                           \"creating covering ROR-intersect\",\n                                           tree->ror_scans, ror_scan_mark)",
          "new_text": "bitmap_is_subset(&param->needed_fields, covered_fields)",
          "old_line_content": "  DBUG_EXECUTE(\"info\", print_ror_scans_arr(param->table,",
          "new_line_content": "    all_covered= bitmap_is_subset(&param->needed_fields, covered_fields);",
          "content_same": false
        },
        {
          "line": 4961,
          "old_api": "DBUG_RETURN",
          "new_api": "print_ror_scans_arr",
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": "print_ror_scans_arr(param->table,\n                                           \"creating covering ROR-intersect\",\n                                           tree->ror_scans, ror_scan_mark)",
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "  DBUG_EXECUTE(\"info\", print_ror_scans_arr(param->table,",
          "content_same": false
        },
        {
          "line": 4967,
          "old_api": "alloc_root",
          "new_api": "log",
          "old_text": "alloc_root(param->mem_root,\n                                                     sizeof(ROR_SCAN_INFO*)*\n                                                     best_num)",
          "new_text": "log((double)(ror_scan_mark - tree->ror_scans))",
          "old_line_content": "  if (!(trp->first_scan= (ROR_SCAN_INFO**)alloc_root(param->mem_root,",
          "new_line_content": "                log((double)(ror_scan_mark - tree->ror_scans)) /",
          "content_same": false
        },
        {
          "line": 4982,
          "old_api": "DBUG_RETURN",
          "new_api": "memcpy",
          "old_text": "DBUG_RETURN(trp)",
          "new_text": "memcpy(trp->first_scan, tree->ror_scans, best_num*sizeof(ROR_SCAN_INFO*))",
          "old_line_content": "  DBUG_RETURN(trp);",
          "new_line_content": "  memcpy(trp->first_scan, tree->ror_scans, best_num*sizeof(ROR_SCAN_INFO*));",
          "content_same": false
        },
        {
          "line": 5046,
          "old_api": "index_flags",
          "new_api": "is_set",
          "old_text": "param->table->file->index_flags(keynr, param->max_key_part,1)",
          "new_text": "param->table->covering_keys.is_set(keynr)",
          "old_line_content": "          (param->table->file->index_flags(keynr, param->max_key_part,1) &",
          "new_line_content": "                            (bool) param->table->covering_keys.is_set(keynr);",
          "content_same": false
        },
        {
          "line": 5101,
          "old_api": "DBUG_RETURN",
          "new_api": "is_set",
          "old_text": "DBUG_RETURN(read_plan)",
          "new_text": "tree->ror_scans_map.is_set(idx)",
          "old_line_content": "  DBUG_RETURN(read_plan);",
          "new_line_content": "      read_plan->is_ror= tree->ror_scans_map.is_set(idx);",
          "content_same": false
        },
        {
          "line": 5158,
          "old_api": "DBUG_RETURN",
          "new_api": "print_ror_scans_arr",
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": "print_ror_scans_arr(param->table,\n                                             \"creating ROR-intersect\",\n                                             first_scan, last_scan)",
          "old_line_content": "        DBUG_RETURN(NULL);",
          "new_line_content": "    DBUG_EXECUTE(\"info\", print_ror_scans_arr(param->table,",
          "content_same": false
        },
        {
          "line": 5186,
          "old_api": "DBUG_ENTER",
          "new_api": "DBUG_RETURN",
          "old_text": "DBUG_ENTER(\"TRP_ROR_UNION::make_quick\")",
          "new_text": "DBUG_RETURN(quick_intrsect)",
          "old_line_content": "  DBUG_ENTER(\"TRP_ROR_UNION::make_quick\");",
          "new_line_content": "  DBUG_RETURN(quick_intrsect);",
          "content_same": false
        },
        {
          "line": 5197,
          "old_api": "DBUG_RETURN",
          "new_api": "DBUG_ENTER",
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": "DBUG_ENTER(\"TRP_ROR_UNION::make_quick\")",
          "old_line_content": "        DBUG_RETURN(NULL);",
          "new_line_content": "  DBUG_ENTER(\"TRP_ROR_UNION::make_quick\");",
          "content_same": false
        },
        {
          "line": 5368,
          "old_api": "get_mm_parts",
          "new_api": "create_item",
          "old_text": "get_mm_parts(param, cond_func, field, Item_func::LT_FUNC,\n                             value_item, cmp_type)",
          "new_text": "func->array->create_item()",
          "old_line_content": "          tree= get_mm_parts(param, cond_func, field, Item_func::LT_FUNC,",
          "new_line_content": "        Item *value_item= func->array->create_item();",
          "content_same": false
        },
        {
          "line": 5463,
          "old_api": "argument_count",
          "new_api": "tree_or",
          "old_text": "func->argument_count()",
          "new_text": "tree_or(param, tree, tree2)",
          "old_line_content": "          for (arg= func->arguments()+2, end= arg+func->argument_count()-2;",
          "new_line_content": "          tree= tree_or(param, tree, tree2);",
          "content_same": false
        },
        {
          "line": 5474,
          "old_api": "arguments",
          "new_api": "argument_count",
          "old_text": "get_mm_parts(param, cond_func, field, Item_func::EQ_FUNC,\n                         func->arguments()[1], cmp_type)",
          "new_text": "func->argument_count()",
          "old_line_content": "      tree= get_mm_parts(param, cond_func, field, Item_func::EQ_FUNC,",
          "new_line_content": "          for (arg= func->arguments()+2, end= arg+func->argument_count()-2;",
          "content_same": false
        },
        {
          "line": 5601,
          "old_api": "get_func_mm_tree",
          "new_api": "DBUG_ENTER",
          "old_text": "get_func_mm_tree(param, cond_func, field, value, cmp_type, inv)",
          "new_text": "DBUG_ENTER(\"get_full_func_mm_tree\")",
          "old_line_content": "    ftree= get_func_mm_tree(param, cond_func, field, value, cmp_type, inv);",
          "new_line_content": "  DBUG_ENTER(\"get_full_func_mm_tree\");",
          "content_same": false
        },
        {
          "line": 5610,
          "old_api": "eq",
          "new_api": "cmp_type",
          "old_text": "field->eq(f)",
          "new_text": "field->cmp_type()",
          "old_line_content": "      if (field->eq(f))",
          "new_line_content": "  Item_result cmp_type= field->cmp_type();",
          "content_same": false
        },
        {
          "line": 5644,
          "old_api": "statement_should_be_aborted",
          "new_api": "type",
          "old_text": "param->statement_should_be_aborted()",
          "new_text": "cond->type()",
          "old_line_content": "        if (param->statement_should_be_aborted())",
          "new_line_content": "  if (cond->type() == Item::COND_ITEM)",
          "content_same": false
        },
        {
          "line": 5646,
          "old_api": "tree_and",
          "new_api": "argument_list",
          "old_text": "tree_and(param,tree,new_tree)",
          "new_text": "(Item_cond*) cond)->argument_list()",
          "old_line_content": "        tree= tree_and(param,tree,new_tree);",
          "new_line_content": "    List_iterator<Item> li(*((Item_cond*) cond)->argument_list());",
          "content_same": false
        },
        {
          "line": 5654,
          "old_api": "statement_should_be_aborted",
          "new_api": "get_mm_tree",
          "old_text": "param->statement_should_be_aborted()",
          "new_text": "get_mm_tree(param,item)",
          "old_line_content": "      if (param->statement_should_be_aborted())",
          "new_line_content": "        SEL_TREE *new_tree= get_mm_tree(param,item);",
          "content_same": false
        },
        {
          "line": 5655,
          "old_api": "DBUG_RETURN",
          "new_api": "statement_should_be_aborted",
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": "param->statement_should_be_aborted()",
          "old_line_content": "        DBUG_RETURN(NULL);",
          "new_line_content": "        if (param->statement_should_be_aborted())",
          "content_same": false
        },
        {
          "line": 5664,
          "old_api": "tree_or",
          "new_api": "get_mm_tree",
          "old_text": "tree_or(param,tree,new_tree)",
          "new_text": "get_mm_tree(param,li++)",
          "old_line_content": "          tree= tree_or(param,tree,new_tree);",
          "new_line_content": "      tree= get_mm_tree(param,li++);",
          "content_same": false
        },
        {
          "line": 5673,
          "old_api": "const_item",
          "new_api": "statement_should_be_aborted",
          "old_text": "cond->const_item()",
          "new_text": "param->statement_should_be_aborted()",
          "old_line_content": "  if (cond->const_item())",
          "new_line_content": "          if (new_tree == NULL || param->statement_should_be_aborted())",
          "content_same": false
        },
        {
          "line": 5694,
          "old_api": "used_tables",
          "new_api": "val_int",
          "old_text": "cond->used_tables()",
          "new_text": "cond->val_int()",
          "old_line_content": "    ref_tables= cond->used_tables();",
          "new_line_content": "    tree= cond->val_int() ? new(tmp_root) SEL_TREE(SEL_TREE::ALWAYS) :",
          "content_same": false
        },
        {
          "line": 5703,
          "old_api": "functype",
          "new_api": "type",
          "old_text": "cond_func->functype()",
          "new_text": "cond->type()",
          "old_line_content": "      cond_func->functype() == Item_func::IN_FUNC)",
          "new_line_content": "  if (cond->type() != Item::FUNC_ITEM)",
          "content_same": false
        },
        {
          "line": 5705,
          "old_api": "select_optimize",
          "new_api": "used_tables",
          "old_text": "cond_func->select_optimize()",
          "new_text": "cond->used_tables()",
          "old_line_content": "  else if (cond_func->select_optimize() == Item_func::OPTIMIZE_NONE)",
          "new_line_content": "    ref_tables= cond->used_tables();",
          "content_same": false
        },
        {
          "line": 5714,
          "old_api": "arguments",
          "new_api": "functype",
          "old_text": "cond_func->arguments()[0]->real_item()",
          "new_text": "cond_func->functype()",
          "old_line_content": "      field_item= (Item_field*) (cond_func->arguments()[0]->real_item());",
          "new_line_content": "      cond_func->functype() == Item_func::IN_FUNC)",
          "content_same": false
        },
        {
          "line": 5726,
          "old_api": "arguments",
          "new_api": "get_full_func_mm_tree",
          "old_text": "cond_func->arguments()[i]->real_item()",
          "new_text": "get_full_func_mm_tree(param, cond_func, field_item, NULL, inv)",
          "old_line_content": "        field_item= (Item_field*) (cond_func->arguments()[i]->real_item());",
          "new_line_content": "      ftree= get_full_func_mm_tree(param, cond_func, field_item, NULL, inv);",
          "content_same": false
        },
        {
          "line": 5762,
          "old_api": "used_tables",
          "new_api": "DBUG_RETURN",
          "old_text": "value->used_tables()",
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "    ref_tables= value->used_tables();",
          "new_line_content": "      DBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 5771,
          "old_api": "tree_and",
          "new_api": "DBUG_RETURN",
          "old_text": "tree_and(param, ftree, tree)",
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "        ftree= !ftree ? tree : tree_and(param, ftree, tree);",
          "new_line_content": "      DBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 5780,
          "old_api": "arguments",
          "new_api": "get_mm_parts",
          "old_text": "cond_func->arguments()[0]->real_item()",
          "new_text": "get_mm_parts(param, cond, field, Item_func::EQ_FUNC,\n\t\t           value,cmp_type)",
          "old_line_content": "      field_item= (Item_field*) (cond_func->arguments()[0]->real_item());",
          "new_line_content": "        tree= get_mm_parts(param, cond, field, Item_func::EQ_FUNC,",
          "content_same": false
        },
        {
          "line": 5791,
          "old_api": "DBUG_RETURN",
          "new_api": "arguments",
          "old_text": "DBUG_RETURN(0)",
          "new_text": "cond_func->arguments()[0]->real_item()",
          "old_line_content": "      DBUG_RETURN(0);",
          "new_line_content": "      field_item= (Item_field*) (cond_func->arguments()[0]->real_item());",
          "content_same": false
        },
        {
          "line": 5792,
          "old_api": "get_full_func_mm_tree",
          "new_api": "arguments",
          "old_text": "get_full_func_mm_tree(param, cond_func, field_item, value, inv)",
          "new_text": "cond_func->arguments()",
          "old_line_content": "    ftree= get_full_func_mm_tree(param, cond_func, field_item, value, inv);",
          "new_line_content": "      value= cond_func->arg_count > 1 ? cond_func->arguments()[1] : 0;",
          "content_same": false
        },
        {
          "line": 5795,
          "old_api": "DBUG_RETURN",
          "new_api": "arguments",
          "old_text": "DBUG_RETURN(ftree)",
          "new_text": "cond_func->arguments()[1]->real_item()->type()",
          "old_line_content": "  DBUG_RETURN(ftree);",
          "new_line_content": "             cond_func->arguments()[1]->real_item()->type() ==",
          "content_same": false
        },
        {
          "line": 5823,
          "old_api": "get_mm_leaf",
          "new_api": "used_tables",
          "old_text": "get_mm_leaf(param,cond_func,\n\t\t\t    key_part->field,key_part,type,value)",
          "new_text": "value->used_tables()",
          "old_line_content": "\tsel_arg=get_mm_leaf(param,cond_func,",
          "new_line_content": "      value->used_tables() & ~(param->prev_tables | param->read_tables))",
          "content_same": false
        },
        {
          "line": 5841,
          "old_api": "set_bit",
          "new_api": "DBUG_RETURN",
          "old_text": "tree->keys_map.set_bit(key_part->key)",
          "new_text": "DBUG_RETURN(tree)",
          "old_line_content": "      tree->keys_map.set_bit(key_part->key);",
          "new_line_content": "\t  DBUG_RETURN(tree);",
          "content_same": false
        },
        {
          "line": 6015,
          "old_api": "int2store",
          "new_api": "length",
          "old_text": "int2store(min_str+maybe_null,min_length)",
          "new_text": "res->length()",
          "old_line_content": "      int2store(min_str+maybe_null,min_length);",
          "new_line_content": "\t\t\t      res->ptr(), res->length(),",
          "content_same": false
        },
        {
          "line": 6048,
          "old_api": "result_type",
          "new_api": "real_item",
          "old_text": "value->result_type()",
          "new_text": "value->real_item()->type()",
          "old_line_content": "                                                value->result_type()))",
          "new_line_content": "  if (value->real_item()->type() == Item::STRING_ITEM &&",
          "content_same": false
        },
        {
          "line": 6134,
          "old_api": "get_key_image",
          "new_api": "is_real_null",
          "old_text": "field->get_key_image(str+maybe_null, key_part->length,\n                       key_part->image_type)",
          "new_text": "field->is_real_null()",
          "old_line_content": "  field->get_key_image(str+maybe_null, key_part->length,",
          "new_line_content": "  if (type != Item_func::EQUAL_FUNC && field->is_real_null())",
          "content_same": false
        },
        {
          "line": 6344,
          "old_api": "test_use_count",
          "new_api": "simple_key",
          "old_text": "*key1)->test_use_count(*key1)",
          "new_text": "*key2)->simple_key()",
          "old_line_content": "          (*key1)->test_use_count(*key1);",
          "new_line_content": "      if (*key2 && !(*key2)->simple_key())",
          "content_same": false
        },
        {
          "line": 6350,
          "old_api": "is_clear_all",
          "new_api": "DBUG_RETURN",
          "old_text": "result_keys.is_clear_all()",
          "new_text": "DBUG_RETURN(tree1)",
          "old_line_content": "  if (!result_keys.is_clear_all())",
          "new_line_content": "        DBUG_RETURN(tree1);",
          "content_same": false
        },
        {
          "line": 6352,
          "old_api": "empty",
          "new_api": "set_bit",
          "old_text": "tree1->merges.empty()",
          "new_text": "result_keys.set_bit(key1 - tree1->keys)",
          "old_line_content": "    tree1->merges.empty();",
          "new_line_content": "      result_keys.set_bit(key1 - tree1->keys);",
          "content_same": false
        },
        {
          "line": 6489,
          "old_api": "sel_trees_can_be_ored",
          "new_api": "DBUG_RETURN",
          "old_text": "sel_trees_can_be_ored(tree1, tree2, param)",
          "new_text": "DBUG_RETURN(tree2)",
          "old_line_content": "  if (sel_trees_can_be_ored(tree1, tree2, param))",
          "new_line_content": "    DBUG_RETURN(tree2);",
          "content_same": false
        },
        {
          "line": 6500,
          "old_api": "set_bit",
          "new_api": "sel_trees_can_be_ored",
          "old_text": "result_keys.set_bit(key1 - tree1->keys)",
          "new_text": "sel_trees_can_be_ored(tree1, tree2, param)",
          "old_line_content": "        result_keys.set_bit(key1 - tree1->keys);",
          "new_line_content": "  if (sel_trees_can_be_ored(tree1, tree2, param))",
          "content_same": false
        },
        {
          "line": 6543,
          "old_api": "swap_variables",
          "new_api": "is_empty",
          "old_text": "swap_variables(SEL_TREE*, tree1, tree2)",
          "new_text": "tree2->merges.is_empty()",
          "old_line_content": "        swap_variables(SEL_TREE*, tree1, tree2);",
          "new_line_content": "    else if (!tree1->merges.is_empty() && !tree2->merges.is_empty())",
          "content_same": false
        },
        {
          "line": 6545,
          "old_api": "remove_nonrange_trees",
          "new_api": "imerge_list_or_list",
          "old_text": "remove_nonrange_trees(param, tree2)",
          "new_text": "imerge_list_or_list(param, &tree1->merges, &tree2->merges)",
          "old_line_content": "      if (param->remove_jump_scans && remove_nonrange_trees(param, tree2))",
          "new_line_content": "      if (imerge_list_or_list(param, &tree1->merges, &tree2->merges))",
          "content_same": false
        },
        {
          "line": 6554,
          "old_api": "DBUG_RETURN",
          "new_api": "swap_variables",
          "old_text": "DBUG_RETURN(result)",
          "new_text": "swap_variables(SEL_TREE*, tree1, tree2)",
          "old_line_content": "  DBUG_RETURN(result);",
          "new_line_content": "        swap_variables(SEL_TREE*, tree1, tree2);",
          "content_same": false
        },
        {
          "line": 6581,
          "old_api": "key_and",
          "new_api": "increment_use_count",
          "old_text": "key_and(param, next->next_key_part, key2, clone_flag)",
          "new_text": "key2->increment_use_count((int) key1->elements-1)",
          "old_line_content": "      SEL_ARG *tmp= key_and(param, next->next_key_part, key2, clone_flag);",
          "new_line_content": "    key2->increment_use_count((int) key1->elements-1);",
          "content_same": false
        },
        {
          "line": 6646,
          "old_api": "swap_clone_flag",
          "new_api": "clone_tree",
          "old_text": "swap_clone_flag(clone_flag)",
          "new_text": "key1->clone_tree(param)",
          "old_line_content": "    clone_flag=swap_clone_flag(clone_flag);",
          "new_line_content": "      if (!(key1= key1->clone_tree(param)))",
          "content_same": false
        },
        {
          "line": 6684,
          "old_api": "free_tree",
          "new_api": "and_all_keys",
          "old_text": "key2->free_tree()",
          "new_text": "and_all_keys(param, key1, key2, clone_flag)",
          "old_line_content": "    key2->free_tree();",
          "new_line_content": "\treturn and_all_keys(param, key1, key2, clone_flag);",
          "content_same": false
        },
        {
          "line": 6694,
          "old_api": "cmp_min_to_min",
          "new_api": "free_tree",
          "old_text": "e1->cmp_min_to_min(e2)",
          "new_text": "key1->free_tree()",
          "old_line_content": "    int cmp=e1->cmp_min_to_min(e2);",
          "new_line_content": "    key1->free_tree();",
          "content_same": false
        },
        {
          "line": 6705,
          "old_api": "increment_use_count",
          "new_api": "cmp_min_to_min",
          "old_text": "e2->increment_use_count(1)",
          "new_text": "e1->cmp_min_to_min(e2)",
          "old_line_content": "    e2->increment_use_count(1);",
          "new_line_content": "    int cmp=e1->cmp_min_to_min(e2);",
          "content_same": false
        },
        {
          "line": 6708,
          "old_api": "clone_and",
          "new_api": "get_range",
          "old_text": "e1->clone_and(e2)",
          "new_text": "get_range(&e1,&e2,key1)",
          "old_line_content": "      SEL_ARG *new_arg= e1->clone_and(e2);",
          "new_line_content": "      if (get_range(&e1,&e2,key1))",
          "content_same": false
        },
        {
          "line": 6719,
          "old_api": "cmp_max_to_max",
          "new_api": "clone_and",
          "old_text": "e1->cmp_max_to_max(e2)",
          "new_text": "e1->clone_and(e2)",
          "old_line_content": "    if (e1->cmp_max_to_max(e2) < 0)",
          "new_line_content": "      SEL_ARG *new_arg= e1->clone_and(e2);",
          "content_same": false
        },
        {
          "line": 6735,
          "old_api": "find_range",
          "new_api": "free_tree",
          "old_text": "root1->find_range(*e2)",
          "new_text": "key1->free_tree()",
          "old_line_content": "  (*e1)=root1->find_range(*e2);\t\t\t// first e1->min < e2->min",
          "new_line_content": "  key1->free_tree();",
          "content_same": false
        },
        {
          "line": 6736,
          "old_api": "cmp_max_to_min",
          "new_api": "free_tree",
          "old_text": "*e1)->cmp_max_to_min(*e2)",
          "new_text": "key2->free_tree()",
          "old_line_content": "  if ((*e1)->cmp_max_to_min(*e2) < 0)",
          "new_line_content": "  key2->free_tree();",
          "content_same": false
        },
        {
          "line": 6856,
          "old_api": "clone_tree",
          "new_api": "free_tree",
          "old_text": "key1->clone_tree(param)",
          "new_text": "key1->free_tree()",
          "old_line_content": "    if (key1->use_count > 0 || !(key1=key1->clone_tree(param)))",
          "new_line_content": "    key1->free_tree();",
          "content_same": false
        },
        {
          "line": 6889,
          "old_api": "copy_min",
          "new_api": "eq_tree",
          "old_text": "key2->copy_min(tmp)",
          "new_text": "eq_tree(tmp->next_key_part,key2->next_key_part)",
          "old_line_content": "\tkey2->copy_min(tmp);",
          "new_line_content": "      if (cmp == -2 && eq_tree(tmp->next_key_part,key2->next_key_part))",
          "content_same": false
        },
        {
          "line": 6904,
          "old_api": "cmp_min_to_max",
          "new_api": "make_root",
          "old_text": "tmp->cmp_min_to_max(key2)",
          "new_text": "key1->make_root()",
          "old_line_content": "      if ((tmp_cmp=tmp->cmp_min_to_max(key2)) > 0) // if tmp.min > key2.max",
          "new_line_content": "\t  key1->make_root();",
          "content_same": false
        },
        {
          "line": 6918,
          "old_api": "increment_use_count",
          "new_api": "eq_tree",
          "old_text": "key2->increment_use_count(-1)",
          "new_text": "eq_tree(tmp->next_key_part,key2->next_key_part)",
          "old_line_content": "\t  key2->increment_use_count(-1);\t// Free not used tree",
          "new_line_content": "\tif (tmp_cmp == 2 && eq_tree(tmp->next_key_part,key2->next_key_part))",
          "content_same": false
        },
        {
          "line": 6945,
          "old_api": "eq_tree",
          "new_api": "insert",
          "old_text": "eq_tree(tmp->next_key_part,key2->next_key_part)",
          "new_text": "key1->insert(key2)",
          "old_line_content": "    if (eq_tree(tmp->next_key_part,key2->next_key_part))",
          "new_line_content": "\t    key1=key1->insert(key2);\t\t// Will destroy key2_root",
          "content_same": false
        },
        {
          "line": 6964,
          "old_api": "cmp_min_to_max",
          "new_api": "merge_flags",
          "old_text": "last->next->cmp_min_to_max(key2)",
          "new_text": "tmp->merge_flags(key2)",
          "old_line_content": "\twhile (last->next && last->next->cmp_min_to_max(key2) <= 0 &&",
          "new_line_content": "\ttmp->merge_flags(key2);\t\t\t// Copy maybe flags",
          "content_same": false
        },
        {
          "line": 6965,
          "old_api": "eq_tree",
          "new_api": "increment_use_count",
          "old_text": "eq_tree(last->next->next_key_part,key2->next_key_part)",
          "new_text": "key2->increment_use_count(-1)",
          "old_line_content": "\t       eq_tree(last->next->next_key_part,key2->next_key_part))",
          "new_line_content": "\tkey2->increment_use_count(-1);\t\t// Free not used tree",
          "content_same": false
        },
        {
          "line": 7030,
          "old_api": "clone_first",
          "new_api": "increment_use_count",
          "old_text": "key.clone_first(tmp)",
          "new_text": "new_arg->increment_use_count(key1->use_count+1)",
          "old_line_content": "\tSEL_ARG *new_arg=key.clone_first(tmp);",
          "new_line_content": "\tnew_arg->increment_use_count(key1->use_count+1);",
          "content_same": false
        },
        {
          "line": 7041,
          "old_api": "key_or",
          "new_api": "clone_first",
          "old_text": "key_or(param, tmp->next_key_part, key.next_key_part)",
          "new_text": "key.clone_first(tmp)",
          "old_line_content": "\ttmp->next_key_part= key_or(param, tmp->next_key_part, key.next_key_part);",
          "new_line_content": "\tSEL_ARG *new_arg=key.clone_first(tmp);",
          "content_same": false
        },
        {
          "line": 7065,
          "old_api": "clone_last",
          "new_api": "cmp_min_to_max",
          "old_text": "tmp->clone_last(&key)",
          "new_text": "tmp->cmp_min_to_max(&key)",
          "old_line_content": "\tSEL_ARG *new_arg=tmp->clone_last(&key); // tmp.min <= x <= key.max",
          "new_line_content": "\tif (tmp->cmp_min_to_max(&key) > 0)",
          "content_same": false
        },
        {
          "line": 7118,
          "old_api": "eq_tree",
          "new_api": "is_same",
          "old_text": "eq_tree(a->right,b->right)",
          "new_text": "a->is_same(b)",
          "old_line_content": "    if (!eq_tree(a->right,b->right))",
          "new_line_content": "  if (!a || !b || !a->is_same(b))",
          "content_same": false
        },
        {
          "line": 7373,
          "old_api": "test_rb_tree",
          "new_api": "right_rotate",
          "old_text": "test_rb_tree(root,root->parent)",
          "new_text": "right_rotate(&root,par)",
          "old_line_content": "  test_rb_tree(root,root->parent);",
          "new_line_content": "\t  right_rotate(&root,par);",
          "content_same": false
        },
        {
          "line": 7677,
          "old_api": "min",
          "new_api": "check_quick_keys",
          "old_text": "min(param->table->quick_condition_rows, records)",
          "new_text": "check_quick_keys(param, idx, tree,\n                            param->min_key, 0, -1,\n                            param->max_key, 0, -1)",
          "old_line_content": "        min(param->table->quick_condition_rows, records);",
          "new_line_content": "  records= check_quick_keys(param, idx, tree,",
          "content_same": false
        },
        {
          "line": 7767,
          "old_api": "store_max",
          "new_api": "check_quick_keys",
          "old_text": "key_tree->store_max(param->key[idx][key_tree->part].store_length,\n                                        &tmp_max_key, max_key_flag)",
          "new_text": "check_quick_keys(param, idx, key_tree->left,\n                             min_key, min_key_flag, min_keypart,\n\t\t\t     max_key, max_key_flag, max_keypart)",
          "old_line_content": "  tmp_max_keypart+= key_tree->store_max(param->key[idx][key_tree->part].store_length,",
          "new_line_content": "    records=check_quick_keys(param, idx, key_tree->left,",
          "content_same": false
        },
        {
          "line": 7780,
          "old_api": "key_length",
          "new_api": "uint) (tmp_min_key - param->min_key)",
          "old_text": "param->table->field[fieldnr]->key_length()",
          "new_text": "uint) (tmp_min_key - param->min_key)",
          "old_line_content": "    if (param->table->field[fieldnr]->key_length() !=",
          "new_line_content": "  min_key_length= (uint) (tmp_min_key - param->min_key);",
          "content_same": false
        },
        {
          "line": 7796,
          "old_api": "check_quick_keys",
          "new_api": "is_null_interval",
          "old_text": "check_quick_keys(param,idx,key_tree->next_key_part, tmp_min_key,\n                           min_key_flag | key_tree->min_flag, tmp_min_keypart,\n                           tmp_max_key, max_key_flag | key_tree->max_flag,\n                           tmp_max_keypart)",
          "new_text": "key_tree->is_null_interval()",
          "old_line_content": "      tmp=check_quick_keys(param,idx,key_tree->next_key_part, tmp_min_key,",
          "new_line_content": "  if (!param->first_null_comp && key_tree->is_null_interval())",
          "content_same": false
        },
        {
          "line": 7823,
          "old_api": "uint) (tmp_max_key - param->max_key)",
          "new_api": "store_min_key",
          "old_text": "uint) (tmp_max_key - param->max_key)",
          "new_text": "key_tree->next_key_part->store_min_key(param->key[idx],\n                                             &tmp_min_key,\n                                             &tmp_min_flag,\n                                             MAX_KEY)",
          "old_line_content": "    max_key_length= (uint) (tmp_max_key - param->max_key);",
          "new_line_content": "      key_tree->next_key_part->store_min_key(param->key[idx],",
          "content_same": false
        },
        {
          "line": 7887,
          "old_api": "make_keypart_map",
          "new_api": "records_in_range",
          "old_text": "make_keypart_map(tmp_min_keypart)",
          "new_text": "param->table->file->records_in_range(keynr,\n                                                &min_range, (key_range*) 0)",
          "old_line_content": "      min_range.keypart_map= make_keypart_map(tmp_min_keypart);",
          "new_line_content": "      tmp= param->table->file->records_in_range(keynr,",
          "content_same": false
        },
        {
          "line": 8082,
          "old_api": "get_quick_keys",
          "new_api": "store_max",
          "old_text": "get_quick_keys(param,quick,key,key_tree->next_key_part,\n\t\t\t tmp_min_key, min_key_flag | key_tree->min_flag,\n\t\t\t tmp_max_key, max_key_flag | key_tree->max_flag)",
          "new_text": "key_tree->store_max(key[key_tree->part].store_length,\n                                 &tmp_max_key,max_key_flag)",
          "old_line_content": "      if (get_quick_keys(param,quick,key,key_tree->next_key_part,",
          "new_line_content": "  max_part+= key_tree->store_max(key[key_tree->part].store_length,",
          "content_same": false
        },
        {
          "line": 8138,
          "old_api": "uint) (tmp_min_key - param->min_key)",
          "new_api": "uint) (tmp_max_key - param->max_key)",
          "old_text": "uint) (tmp_min_key - param->min_key)",
          "new_text": "uint) (tmp_max_key - param->max_key)",
          "old_line_content": "                             (uint) (tmp_min_key - param->min_key)))",
          "new_line_content": "    if (length == (uint) (tmp_max_key - param->max_key) &&",
          "content_same": false
        },
        {
          "line": 8149,
          "old_api": "make_keypart_map",
          "new_api": "uint) (tmp_min_key - param->min_key)",
          "old_text": "make_keypart_map(min_part)",
          "new_text": "uint) (tmp_min_key - param->min_key)",
          "old_line_content": "                               min_part >=0 ? make_keypart_map(min_part) : 0,",
          "new_line_content": "                             (uint) (tmp_min_key - param->min_key)))",
          "content_same": false
        },
        {
          "line": 8159,
          "old_api": "insert_dynamic",
          "new_api": "uint) (tmp_min_key - param->min_key)",
          "old_text": "insert_dynamic(&quick->ranges, (uchar*) &range)",
          "new_text": "uint) (tmp_min_key - param->min_key)",
          "old_line_content": "  if (insert_dynamic(&quick->ranges, (uchar*) &range))",
          "new_line_content": "\t\t\t       (uint) (tmp_min_key - param->min_key),",
          "content_same": false
        },
        {
          "line": 8299,
          "old_api": "make_prev_keypart_map",
          "new_api": "init",
          "old_text": "make_prev_keypart_map(ref->key_parts)",
          "new_text": "quick->init()",
          "old_line_content": "    make_prev_keypart_map(ref->key_parts);",
          "new_line_content": "  if (quick->init())",
          "content_same": false
        },
        {
          "line": 8303,
          "old_api": "alloc_root",
          "new_api": "cp_buffer_from_ref",
          "old_text": "alloc_root(&quick->alloc,sizeof(KEY_PART)*ref->key_parts)",
          "new_text": "cp_buffer_from_ref(thd, table, ref)",
          "old_line_content": "\talloc_root(&quick->alloc,sizeof(KEY_PART)*ref->key_parts)))",
          "new_line_content": "  if ((cp_buffer_from_ref(thd, table, ref) && thd->is_fatal_error) ||",
          "content_same": false
        },
        {
          "line": 8385,
          "old_api": "reset",
          "new_api": "set_keyread",
          "old_text": "cur_quick->reset()",
          "new_text": "head->set_keyread(TRUE)",
          "old_line_content": "  if (cur_quick->init() || cur_quick->reset())",
          "new_line_content": "  head->set_keyread(TRUE);",
          "content_same": false
        },
        {
          "line": 8386,
          "old_api": "DBUG_RETURN",
          "new_api": "prepare_for_position",
          "old_text": "DBUG_RETURN(1)",
          "new_text": "head->prepare_for_position()",
          "old_line_content": "    DBUG_RETURN(1);",
          "new_line_content": "  head->prepare_for_position();",
          "content_same": false
        },
        {
          "line": 8390,
          "old_api": "DBUG_ABORT",
          "new_api": "DBUG_ASSERT",
          "old_text": "DBUG_ABORT()",
          "new_text": "DBUG_ASSERT(cur_quick != 0)",
          "old_line_content": "    DBUG_EXECUTE_IF(\"index_merge_may_not_create_a_Unique\", DBUG_ABORT(); );",
          "new_line_content": "  DBUG_ASSERT(cur_quick != 0);",
          "content_same": false
        },
        {
          "line": 8401,
          "old_api": "filesort_free_buffers",
          "new_api": "DBUG_ABORT",
          "old_text": "filesort_free_buffers(head, false)",
          "new_text": "DBUG_ABORT()",
          "old_line_content": "    filesort_free_buffers(head, false);",
          "new_line_content": "    DBUG_EXECUTE_IF(\"index_merge_may_not_create_a_Unique\", DBUG_ABORT(); );",
          "content_same": false
        },
        {
          "line": 8411,
          "old_api": "get_next",
          "new_api": "reset",
          "old_text": "cur_quick->get_next()",
          "new_text": "unique->reset()",
          "old_line_content": "    while ((result= cur_quick->get_next()) == HA_ERR_END_OF_FILE)",
          "new_line_content": "    unique->reset();",
          "content_same": false
        },
        {
          "line": 8419,
          "old_api": "ha_index_end",
          "new_api": "DBUG_RETURN",
          "old_text": "cur_quick->file->ha_index_end()",
          "new_text": "DBUG_RETURN(1)",
          "old_line_content": "        cur_quick->file->ha_index_end();",
          "new_line_content": "    DBUG_RETURN(1);",
          "content_same": false
        },
        {
          "line": 8452,
          "old_api": "get",
          "new_api": "position",
          "old_text": "unique->get(head)",
          "new_text": "cur_quick->file->position(cur_quick->record)",
          "old_line_content": "  result= unique->get(head);",
          "new_line_content": "    cur_quick->file->position(cur_quick->record);",
          "content_same": false
        },
        {
          "line": 8455,
          "old_api": "set_keyread",
          "new_api": "DBUG_RETURN",
          "old_text": "head->set_keyread(FALSE)",
          "new_text": "DBUG_RETURN(1)",
          "old_line_content": "  head->set_keyread(FALSE);",
          "new_line_content": "      DBUG_RETURN(1);",
          "content_same": false
        },
        {
          "line": 8487,
          "old_api": "init",
          "new_api": "get_next",
          "old_text": "pk_quick_select->init()",
          "new_text": "pk_quick_select->get_next()",
          "old_line_content": "      if ((result= pk_quick_select->init()) ||",
          "new_line_content": "    DBUG_RETURN(pk_quick_select->get_next());",
          "content_same": false
        },
        {
          "line": 8489,
          "old_api": "DBUG_RETURN",
          "new_api": "read_record",
          "old_text": "DBUG_RETURN(result)",
          "new_text": "read_record.read_record(&read_record)",
          "old_line_content": "        DBUG_RETURN(result);",
          "new_line_content": "  if ((result= read_record.read_record(&read_record)) == -1)",
          "content_same": false
        },
        {
          "line": 8548,
          "old_api": "unlock_row",
          "new_api": "DBUG_ENTER",
          "old_text": "quick->file->unlock_row()",
          "new_text": "DBUG_ENTER(\"QUICK_ROR_INTERSECT_SELECT::get_next\")",
          "old_line_content": "        quick->file->unlock_row(); /* row not in range; unlock */",
          "new_line_content": "  DBUG_ENTER(\"QUICK_ROR_INTERSECT_SELECT::get_next\");",
          "content_same": false
        },
        {
          "line": 8564,
          "old_api": "rewind",
          "new_api": "DBUG_RETURN",
          "old_text": "quick_it.rewind()",
          "new_text": "DBUG_RETURN(error)",
          "old_line_content": "        quick_it.rewind();",
          "new_line_content": "      DBUG_RETURN(error);",
          "content_same": false
        },
        {
          "line": 8605,
          "old_api": "position",
          "new_api": "row_in_ranges",
          "old_text": "quick->file->position(quick->record)",
          "new_text": "cpk_quick->row_in_ranges()",
          "old_line_content": "          quick->file->position(quick->record);",
          "new_line_content": "          while (!cpk_quick->row_in_ranges())",
          "content_same": false
        },
        {
          "line": 8607,
          "old_api": "memcpy",
          "new_api": "unlock_row",
          "old_text": "memcpy(last_rowid, quick->file->ref, head->file->ref_length)",
          "new_text": "quick->file->unlock_row()",
          "old_line_content": "        memcpy(last_rowid, quick->file->ref, head->file->ref_length);",
          "new_line_content": "            quick->file->unlock_row(); /* row not in range; unlock */",
          "content_same": false
        },
        {
          "line": 8608,
          "old_api": "unlock_row",
          "new_api": "get_next",
          "old_text": "quick_with_last_rowid->file->unlock_row()",
          "new_text": "quick->get_next()",
          "old_line_content": "        quick_with_last_rowid->file->unlock_row();",
          "new_line_content": "            if ((error= quick->get_next()))",
          "content_same": false
        },
        {
          "line": 8658,
          "old_api": "memcpy",
          "new_api": "DBUG_ENTER",
          "old_text": "memcpy(cur_rowid, quick->last_rowid, rowid_length)",
          "new_text": "DBUG_ENTER(\"QUICK_ROR_UNION_SELECT::get_next\")",
          "old_line_content": "      memcpy(cur_rowid, quick->last_rowid, rowid_length);",
          "new_line_content": "  DBUG_ENTER(\"QUICK_ROR_UNION_SELECT::get_next\");",
          "content_same": false
        },
        {
          "line": 8665,
          "old_api": "queue_remove",
          "new_api": "DBUG_RETURN",
          "old_text": "queue_remove(&queue, 0)",
          "new_text": "DBUG_RETURN(HA_ERR_END_OF_FILE)",
          "old_line_content": "        queue_remove(&queue, 0);",
          "new_line_content": "        DBUG_RETURN(HA_ERR_END_OF_FILE);",
          "content_same": false
        },
        {
          "line": 8669,
          "old_api": "save_last_pos",
          "new_api": "memcpy",
          "old_text": "quick->save_last_pos()",
          "new_text": "memcpy(cur_rowid, quick->last_rowid, rowid_length)",
          "old_line_content": "        quick->save_last_pos();",
          "new_line_content": "      memcpy(cur_rowid, quick->last_rowid, rowid_length);",
          "content_same": false
        },
        {
          "line": 8680,
          "old_api": "cmp_ref",
          "new_api": "save_last_pos",
          "old_text": "head->file->cmp_ref(cur_rowid, prev_rowid)",
          "new_text": "quick->save_last_pos()",
          "old_line_content": "        dup_row= !head->file->cmp_ref(cur_rowid, prev_rowid);",
          "new_line_content": "        quick->save_last_pos();",
          "content_same": false
        },
        {
          "line": 8708,
          "old_api": "DBUG_EXECUTE_IF",
          "new_api": "DBUG_ENTER",
          "old_text": "DBUG_EXECUTE_IF(\"bug14365043_2\",\n                    DBUG_SET(\"+d,ha_index_init_fail\");)",
          "new_text": "DBUG_ENTER(\"QUICK_RANGE_SELECT::reset\")",
          "old_line_content": "    DBUG_EXECUTE_IF(\"bug14365043_2\",",
          "new_line_content": "  DBUG_ENTER(\"QUICK_RANGE_SELECT::reset\");",
          "content_same": false
        },
        {
          "line": 8720,
          "old_api": "min",
          "new_api": "DBUG_SET",
          "old_text": "min(multi_range_count, ranges.elements)",
          "new_text": "DBUG_SET(\"+d,ha_index_init_fail\")",
          "old_line_content": "    DBUG_ASSERT(multi_range_length == min(multi_range_count, ranges.elements));",
          "new_line_content": "                    DBUG_SET(\"+d,ha_index_init_fail\"););",
          "content_same": false
        },
        {
          "line": 8721,
          "old_api": "DBUG_RETURN",
          "new_api": "ha_index_init",
          "old_text": "DBUG_RETURN(0)",
          "new_text": "file->ha_index_init(index,1)",
          "old_line_content": "    DBUG_RETURN(0);",
          "new_line_content": "    if ((error= file->ha_index_init(index,1)))",
          "content_same": false
        },
        {
          "line": 8731,
          "old_api": "MYF",
          "new_api": "min",
          "old_text": "MYF(MY_WME)",
          "new_text": "min(multi_range_count, ranges.elements)",
          "old_line_content": "                                            MYF(MY_WME))))",
          "new_line_content": "    DBUG_ASSERT(multi_range_length == min(multi_range_count, ranges.elements));",
          "content_same": false
        },
        {
          "line": 8760,
          "old_api": "my_free",
          "new_api": "MYF",
          "old_text": "my_free(multi_range)",
          "new_text": "MYF(MY_WME)",
          "old_line_content": "      my_free(multi_range);",
          "new_line_content": "           ! my_multi_malloc(MYF(MY_WME),",
          "content_same": false
        },
        {
          "line": 8813,
          "old_api": "column_bitmaps_set_no_signal",
          "new_api": "DBUG_ENTER",
          "old_text": "head->column_bitmaps_set_no_signal(&column_bitmap, &column_bitmap)",
          "new_text": "DBUG_ENTER(\"QUICK_RANGE_SELECT::get_next\")",
          "old_line_content": "    head->column_bitmaps_set_no_signal(&column_bitmap, &column_bitmap);",
          "new_line_content": "  DBUG_ENTER(\"QUICK_RANGE_SELECT::get_next\");",
          "content_same": false
        },
        {
          "line": 8936,
          "old_api": "DBUG_RETURN",
          "new_api": "make_min_endpoint",
          "old_text": "DBUG_RETURN(result)",
          "new_text": "last_range->make_min_endpoint(&start_key, prefix_length, keypart_map)",
          "old_line_content": "      DBUG_RETURN(result);",
          "new_line_content": "    last_range->make_min_endpoint(&start_key, prefix_length, keypart_map);",
          "content_same": false
        },
        {
          "line": 8957,
          "old_api": "DBUG_RETURN",
          "new_api": "DBUG_ENTER",
          "old_text": "DBUG_RETURN(result)",
          "new_text": "DBUG_ENTER(\"QUICK_RANGE_SELECT_GEOM::get_next\")",
          "old_line_content": "\tDBUG_RETURN(result);",
          "new_line_content": "  DBUG_ENTER(\"QUICK_RANGE_SELECT_GEOM::get_next\");",
          "content_same": false
        },
        {
          "line": 8965,
          "old_api": "DBUG_RETURN",
          "new_api": "index_next_same",
          "old_text": "DBUG_RETURN(HA_ERR_END_OF_FILE)",
          "new_text": "file->index_next_same(record, last_range->min_key,\n\t\t\t\t    last_range->min_length)",
          "old_line_content": "      DBUG_RETURN(HA_ERR_END_OF_FILE);",
          "new_line_content": "      result= file->index_next_same(record, last_range->min_key,",
          "content_same": false
        },
        {
          "line": 9096,
          "old_api": "DBUG_RETURN",
          "new_api": "index_prev",
          "old_text": "DBUG_RETURN(HA_ERR_END_OF_FILE)",
          "new_text": "file->index_prev(record)",
          "old_line_content": "      DBUG_RETURN(HA_ERR_END_OF_FILE);\t\t// All ranges used",
          "new_line_content": "                file->index_prev(record));",
          "content_same": false
        },
        {
          "line": 9103,
          "old_api": "cmp_prev",
          "new_api": "DBUG_RETURN",
          "old_text": "cmp_prev(last_range)",
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "      if (cmp_prev(last_range) == 0)",
          "new_line_content": "\tDBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 9113,
          "old_api": "index_read_map",
          "new_api": "DBUG_RETURN",
          "old_text": "file->index_read_map(record, last_range->max_key,\n                                    last_range->max_keypart_map,\n                                    HA_READ_KEY_EXACT)",
          "new_text": "DBUG_RETURN(local_error)",
          "old_line_content": "      result = file->index_read_map(record, last_range->max_key,",
          "new_line_content": "\tDBUG_RETURN(local_error);\t\t// Empty table",
          "content_same": false
        },
        {
          "line": 9262,
          "old_api": "append",
          "new_api": "STRING_WITH_LEN",
          "old_text": "str->append(',')",
          "new_text": "STRING_WITH_LEN(\"sort_union(\")",
          "old_line_content": "    str->append(',');",
          "new_line_content": "  str->append(STRING_WITH_LEN(\"sort_union(\"));",
          "content_same": false
        },
        {
          "line": 9273,
          "old_api": "STRING_WITH_LEN",
          "new_api": "append",
          "old_text": "STRING_WITH_LEN(\"intersect(\")",
          "new_text": "str->append(',')",
          "old_line_content": "  str->append(STRING_WITH_LEN(\"intersect(\"));",
          "new_line_content": "    str->append(',');",
          "content_same": false
        },
        {
          "line": 9297,
          "old_api": "STRING_WITH_LEN",
          "new_api": "append",
          "old_text": "STRING_WITH_LEN(\"union(\")",
          "new_text": "str->append(',')",
          "old_line_content": "  str->append(STRING_WITH_LEN(\"union(\"));",
          "new_line_content": "    str->append(',');",
          "content_same": false
        },
        {
          "line": 9317,
          "old_api": "longlong2str",
          "new_api": "append",
          "old_text": "longlong2str(max_used_key_length, buf, 10)",
          "new_text": "str->append(')')",
          "old_line_content": "  length= longlong2str(max_used_key_length, buf, 10) - buf;",
          "new_line_content": "  str->append(')');",
          "content_same": false
        },
        {
          "line": 9386,
          "old_api": "append",
          "new_api": "longlong2str",
          "old_text": "used_lengths->append(buf, length)",
          "new_text": "longlong2str(quick->max_used_key_length, buf, 10)",
          "old_line_content": "    used_lengths->append(buf, length);",
          "new_line_content": "    length= longlong2str(quick->max_used_key_length, buf, 10) - buf;",
          "content_same": false
        },
        {
          "line": 9635,
          "old_api": "sum_func",
          "new_api": "DBUG_RETURN",
          "old_text": "min_max_item->sum_func()",
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "      else if (min_max_item->sum_func() == Item_sum::MAX_FUNC)",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 9646,
          "old_api": "get_arg",
          "new_api": "sum_func",
          "old_text": "min_max_item->get_arg(0)->real_item()",
          "new_text": "min_max_item->sum_func()",
          "old_line_content": "      Item *expr= min_max_item->get_arg(0)->real_item();",
          "new_line_content": "      else if (min_max_item->sum_func() == Item_sum::MAX_FUNC)",
          "content_same": false
        },
        {
          "line": 9651,
          "old_api": "eq",
          "new_api": "sum_func",
          "old_text": "min_max_arg_item->eq(expr, 1)",
          "new_text": "min_max_item->sum_func()",
          "old_line_content": "        else if (! min_max_arg_item->eq(expr, 1))",
          "new_line_content": "                min_max_item->sum_func() == Item_sum::AVG_DISTINCT_FUNC))",
          "content_same": false
        },
        {
          "line": 9662,
          "old_api": "DBUG_RETURN",
          "new_api": "eq",
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": "min_max_arg_item->eq(expr, 1)",
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "        else if (! min_max_arg_item->eq(expr, 1))",
          "content_same": false
        },
        {
          "line": 9746,
          "old_api": "is_set",
          "new_api": "ha_table_flags",
          "old_text": "cur_field->part_of_key_not_clustered.is_set(cur_index)",
          "new_text": "table->file->ha_table_flags()",
          "old_line_content": "            !cur_field->part_of_key_not_clustered.is_set(cur_index))",
          "new_line_content": "        (table->file->ha_table_flags() & HA_PRIMARY_KEY_IN_READ_INDEX))",
          "content_same": false
        },
        {
          "line": 9969,
          "old_api": "check_quick_select",
          "new_api": "uint) \n                     (first_non_infix_part - first_non_group_part)",
          "old_text": "check_quick_select(param, cur_param_idx,\n                                                    cur_index_tree, TRUE)",
          "new_text": "uint) \n                     (first_non_infix_part - first_non_group_part)",
          "old_line_content": "      cur_quick_prefix_records= check_quick_select(param, cur_param_idx,",
          "new_line_content": "    key_infix_parts= cur_key_infix_len ? (uint) ",
          "content_same": false
        },
        {
          "line": 10005,
          "old_api": "check_group_min_max_predicates",
          "new_api": "memcpy (key_infix, cur_key_infix, sizeof (key_infix))",
          "old_text": "check_group_min_max_predicates(join->conds, min_max_arg_item,\n                                      (index_info->flags & HA_SPATIAL) ?\n                                      Field::itMBR : Field::itRAW)",
          "new_text": "memcpy (key_infix, cur_key_infix, sizeof (key_infix))",
          "old_line_content": "      !check_group_min_max_predicates(join->conds, min_max_arg_item,",
          "new_line_content": "        memcpy (key_infix, cur_key_infix, sizeof (key_infix));",
          "content_same": false
        },
        {
          "line": 10087,
          "old_api": "check_group_min_max_predicates",
          "new_api": "DBUG_ASSERT",
          "old_text": "check_group_min_max_predicates(and_or_arg, min_max_arg_item,\n                                         image_type)",
          "new_text": "DBUG_ASSERT(cond && min_max_arg_item)",
          "old_line_content": "      if (!check_group_min_max_predicates(and_or_arg, min_max_arg_item,",
          "new_line_content": "  DBUG_ASSERT(cond && min_max_arg_item);",
          "content_same": false
        },
        {
          "line": 10089,
          "old_api": "DBUG_RETURN",
          "new_api": "real_item",
          "old_text": "DBUG_RETURN(FALSE)",
          "new_text": "cond->real_item()",
          "old_line_content": "        DBUG_RETURN(FALSE);",
          "new_line_content": "  cond= cond->real_item();",
          "content_same": false
        },
        {
          "line": 10123,
          "old_api": "func_name",
          "new_api": "full_name",
          "old_text": "pred->func_name()",
          "new_text": "cond->full_name()",
          "old_line_content": "  DBUG_PRINT(\"info\", (\"Analyzing: %s\", pred->func_name()));",
          "new_line_content": "    DBUG_PRINT(\"info\", (\"Analyzing: %s\", cond->full_name()));",
          "content_same": false
        },
        {
          "line": 10124,
          "old_api": "pred->argument_count ()",
          "new_api": "DBUG_RETURN",
          "old_text": "pred->argument_count ()",
          "new_text": "DBUG_RETURN(TRUE)",
          "old_line_content": "  for (uint arg_idx= 0; arg_idx < pred->argument_count (); arg_idx++)",
          "new_line_content": "    DBUG_RETURN(TRUE);",
          "content_same": false
        },
        {
          "line": 10128,
          "old_api": "type",
          "new_api": "DBUG_ASSERT",
          "old_text": "cur_arg->type()",
          "new_text": "DBUG_ASSERT(cond_type == Item::FUNC_ITEM)",
          "old_line_content": "    if (cur_arg->type() == Item::FIELD_ITEM)",
          "new_line_content": "  DBUG_ASSERT(cond_type == Item::FUNC_ITEM);",
          "content_same": false
        },
        {
          "line": 10147,
          "old_api": "DBUG_RETURN",
          "new_api": "functype",
          "old_text": "DBUG_RETURN(FALSE)",
          "new_text": "pred->functype()",
          "old_line_content": "          DBUG_RETURN(FALSE);",
          "new_line_content": "        Item_func::Functype pred_type= pred->functype();",
          "content_same": false
        },
        {
          "line": 10165,
          "old_api": "charset",
          "new_api": "simple_pred",
          "old_text": "(Field_str*) min_max_arg_item->field)->charset()",
          "new_text": "simple_pred(pred, args, &inv)",
          "old_line_content": "              ((Field_str*) min_max_arg_item->field)->charset() !=",
          "new_line_content": "        if (!simple_pred(pred, args, &inv))",
          "content_same": false
        },
        {
          "line": 10166,
          "old_api": "compare_collation",
          "new_api": "DBUG_RETURN",
          "old_text": "pred->compare_collation()",
          "new_text": "DBUG_RETURN(FALSE)",
          "old_line_content": "              pred->compare_collation())",
          "new_line_content": "          DBUG_RETURN(FALSE);",
          "content_same": false
        },
        {
          "line": 10174,
          "old_api": "DBUG_RETURN",
          "new_api": "result_type",
          "old_text": "DBUG_RETURN(FALSE)",
          "new_text": "args[1]->result_type()",
          "old_line_content": "          DBUG_RETURN(FALSE);",
          "new_line_content": "            ((args[1]->result_type() == STRING_RESULT &&",
          "content_same": false
        },
        {
          "line": 10177,
          "old_api": "type",
          "new_api": "compare_collation",
          "old_text": "cur_arg->type()",
          "new_text": "pred->compare_collation()",
          "old_line_content": "    else if (cur_arg->type() == Item::FUNC_ITEM)",
          "new_line_content": "              pred->compare_collation())",
          "content_same": false
        },
        {
          "line": 10183,
          "old_api": "const_item",
          "new_api": "result_type",
          "old_text": "cur_arg->const_item()",
          "new_text": "args[1]->result_type()",
          "old_line_content": "    else if (cur_arg->const_item())",
          "new_line_content": "             (args[1]->result_type() != STRING_RESULT &&",
          "content_same": false
        },
        {
          "line": 10262,
          "old_api": "all_same",
          "new_api": "get_sel_arg_for_keypart",
          "old_text": "all_same(tree_first_range, curr_tree)",
          "new_text": "get_sel_arg_for_keypart(field,\n                                  cur_kp->next_key_part,\n                                  &curr_tree)",
          "old_line_content": "    else if (!all_same(tree_first_range, curr_tree))",
          "new_line_content": "      if (get_sel_arg_for_keypart(field,",
          "content_same": false
        },
        {
          "line": 10631,
          "old_api": "DBUG_RETURN",
          "new_api": "DBUG_ENTER",
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": "DBUG_ENTER(\"TRP_GROUP_MIN_MAX::make_quick\")",
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "  DBUG_ENTER(\"TRP_GROUP_MIN_MAX::make_quick\");",
          "content_same": false
        },
        {
          "line": 10916,
          "old_api": "insert_dynamic",
          "new_api": "memcmp",
          "old_text": "insert_dynamic(&min_max_ranges, (uchar*)&range)",
          "new_text": "memcmp(sel_range->min_value, sel_range->max_value,\n                    min_max_arg_len)",
          "old_line_content": "  if (insert_dynamic(&min_max_ranges, (uchar*)&range))",
          "new_line_content": "    else if (memcmp(sel_range->min_value, sel_range->max_value,",
          "content_same": false
        },
        {
          "line": 11056,
          "old_api": "key_copy",
          "new_api": "ha_index_init",
          "old_text": "key_copy(last_prefix, record, index_info, group_prefix_len)",
          "new_text": "file->ha_index_init(index,1)",
          "old_line_content": "  key_copy(last_prefix, record, index_info, group_prefix_len);",
          "new_line_content": "  if ((result= file->ha_index_init(index,1)))",
          "content_same": false
        },
        {
          "line": 11058,
          "old_api": "DBUG_RETURN",
          "new_api": "MYF",
          "old_text": "DBUG_RETURN(0)",
          "new_text": "MYF(0)",
          "old_line_content": "  DBUG_RETURN(0);",
          "new_line_content": "    head->file->print_error(result, MYF(0));",
          "content_same": false
        },
        {
          "line": 11133,
          "old_api": "next_min",
          "new_api": "DBUG_ASSERT",
          "old_text": "next_min()",
          "new_text": "DBUG_ASSERT(is_last_prefix <= 0)",
          "old_line_content": "      min_res= next_min();",
          "new_line_content": "      DBUG_ASSERT(is_last_prefix <= 0);",
          "content_same": false
        },
        {
          "line": 11154,
          "old_api": "index_read_map",
          "new_api": "update_max_result",
          "old_text": "file->index_read_map(record, group_prefix,\n                                   make_prev_keypart_map(real_key_parts),\n                                   HA_READ_KEY_EXACT)",
          "new_text": "update_max_result()",
          "old_line_content": "      result= file->index_read_map(record, group_prefix,",
          "new_line_content": "        update_max_result();",
          "content_same": false
        },
        {
          "line": 11165,
          "old_api": "DBUG_RETURN",
          "new_api": "index_read_map",
          "old_text": "DBUG_RETURN(result)",
          "new_text": "file->index_read_map(record, group_prefix,\n                                   make_prev_keypart_map(real_key_parts),\n                                   HA_READ_KEY_EXACT)",
          "old_line_content": "  DBUG_RETURN(result);",
          "new_line_content": "      result= file->index_read_map(record, group_prefix,",
          "content_same": false
        },
        {
          "line": 11211,
          "old_api": "DBUG_RETURN",
          "new_api": "next_min_in_range",
          "old_text": "DBUG_RETURN(result)",
          "new_text": "next_min_in_range()",
          "old_line_content": "        DBUG_RETURN(result);",
          "new_line_content": "    if ((result= next_min_in_range()))",
          "content_same": false
        },
        {
          "line": 11254,
          "old_api": "DBUG_RETURN",
          "new_api": "key_restore",
          "old_text": "DBUG_RETURN(result)",
          "new_text": "key_restore(record, key_buf, index_info, 0)",
          "old_line_content": "  DBUG_RETURN(result);",
          "new_line_content": "          key_restore(record, key_buf, index_info, 0);",
          "content_same": false
        },
        {
          "line": 11447,
          "old_api": "key_cmp",
          "new_api": "DBUG_ASSERT",
          "old_text": "key_cmp(min_max_arg_part, (const uchar*) cur_range->max_key,\n                 min_max_arg_len)",
          "new_text": "DBUG_ASSERT(min_max_ranges.elements > 0)",
          "old_line_content": "        (key_cmp(min_max_arg_part, (const uchar*) cur_range->max_key,",
          "new_line_content": "  DBUG_ASSERT(min_max_ranges.elements > 0);",
          "content_same": false
        },
        {
          "line": 11509,
          "old_api": "memcpy",
          "new_api": "key_cmp",
          "old_text": "memcpy(max_key, group_prefix, real_prefix_len)",
          "new_text": "key_cmp(index_info->key_part, group_prefix, real_prefix_len)",
          "old_line_content": "      memcpy(max_key, group_prefix, real_prefix_len);",
          "new_line_content": "    if (key_cmp(index_info->key_part, group_prefix, real_prefix_len))",
          "content_same": false
        },
        {
          "line": 11766,
          "old_api": "length",
          "new_api": "DBUG_ENTER",
          "old_text": "tmp.length()",
          "new_text": "DBUG_ENTER(\"print_sel_tree\")",
          "old_line_content": "      if (tmp.length())",
          "new_line_content": "  DBUG_ENTER(\"print_sel_tree\");",
          "content_same": false
        },
        {
          "line": 11774,
          "old_api": "ptr",
          "new_api": "is_set",
          "old_text": "tmp.ptr()",
          "new_text": "tree_map->is_set(idx)",
          "old_line_content": "  DBUG_PRINT(\"info\", (\"SEL_TREE: 0x%lx (%s)  scans: %s\", (long) tree, msg, tmp.ptr()));",
          "new_line_content": "    if (tree_map->is_set(idx))",
          "content_same": false
        },
        {
          "line": 11795,
          "old_api": "length",
          "new_api": "DBUG_ENTER",
          "old_text": "tmp.length()",
          "new_text": "DBUG_ENTER(\"print_ror_scans_arr\")",
          "old_line_content": "  if (!tmp.length())",
          "new_line_content": "  DBUG_ENTER(\"print_ror_scans_arr\");",
          "content_same": false
        },
        {
          "line": 11829,
          "old_api": "fwrite",
          "new_api": "dbug_tmp_use_all_columns",
          "old_text": "fwrite(\"NULL\",sizeof(char),4,DBUG_FILE)",
          "new_text": "dbug_tmp_use_all_columns(table, old_sets, table->read_set, table->write_set)",
          "old_line_content": "\tfwrite(\"NULL\",sizeof(char),4,DBUG_FILE);",
          "new_line_content": "  dbug_tmp_use_all_columns(table, old_sets, table->read_set, table->write_set);",
          "content_same": false
        },
        {
          "line": 11836,
          "old_api": "type",
          "new_api": "real_maybe_null",
          "old_text": "field->type()",
          "new_text": "field->real_maybe_null()",
          "old_line_content": "    if (field->type() == MYSQL_TYPE_BIT)",
          "new_line_content": "    if (field->real_maybe_null())",
          "content_same": false
        },
        {
          "line": 11840,
          "old_api": "length",
          "new_api": "fwrite",
          "old_text": "tmp.length()",
          "new_text": "fwrite(\"NULL\",sizeof(char),4,DBUG_FILE)",
          "old_line_content": "    fwrite(tmp.ptr(),sizeof(char),tmp.length(),DBUG_FILE);",
          "new_line_content": "\tfwrite(\"NULL\",sizeof(char),4,DBUG_FILE);",
          "content_same": false
        },
        {
          "line": 11853,
          "old_api": "DBUG_ENTER",
          "new_api": "fputc",
          "old_text": "DBUG_ENTER(\"print_quick\")",
          "new_text": "fputc('/',DBUG_FILE)",
          "old_line_content": "  DBUG_ENTER(\"print_quick\");",
          "new_line_content": "      fputc('/',DBUG_FILE);",
          "content_same": false
        },
        {
          "line": 11898,
          "old_api": "fputs",
          "new_api": "print_key",
          "old_text": "fputs(\" < \",DBUG_FILE)",
          "new_text": "print_key(key_parts, range->min_key, range->min_length)",
          "old_line_content": "\t  fputs(\" < \",DBUG_FILE);",
          "new_line_content": "        print_key(key_parts, range->min_key, range->min_length);",
          "content_same": false
        },
        {
          "line": 11914,
          "old_api": "fprintf",
          "new_api": "fputs",
          "old_text": "fprintf(DBUG_FILE, \"%*squick index_merge select\\n\", indent, \"\")",
          "new_text": "fputs(\"\\n\",DBUG_FILE)",
          "old_line_content": "  fprintf(DBUG_FILE, \"%*squick index_merge select\\n\", indent, \"\");",
          "new_line_content": "      fputs(\"\\n\",DBUG_FILE);",
          "content_same": false
        },
        {
          "line": 11932,
          "old_api": "fprintf",
          "new_api": "dbug_dump",
          "old_text": "fprintf(DBUG_FILE, \"%*smerged scans {\\n\", indent, \"\")",
          "new_text": "pk_quick_select->dbug_dump(indent+2, verbose)",
          "old_line_content": "  fprintf(DBUG_FILE, \"%*smerged scans {\\n\", indent, \"\");",
          "new_line_content": "    pk_quick_select->dbug_dump(indent+2, verbose);",
          "content_same": false
        },
        {
          "line": 11934,
          "old_api": "dbug_dump",
          "new_api": "fprintf",
          "old_text": "quick->dbug_dump(indent+2, verbose)",
          "new_text": "fprintf(DBUG_FILE, \"%*s}\\n\", indent, \"\")",
          "old_line_content": "    quick->dbug_dump(indent+2, verbose);",
          "new_line_content": "  fprintf(DBUG_FILE, \"%*s}\\n\", indent, \"\");",
          "content_same": false
        },
        {
          "line": 11988,
          "old_api": "dbug_dump",
          "new_api": "fprintf",
          "old_text": "quick_prefix_select->dbug_dump(indent + 2, verbose)",
          "new_text": "fprintf(DBUG_FILE,\n          \"%*squick_group_min_max_select: index %s (%d), length: %d\\n\",\n\t  indent, \"\", index_info->name, index, max_used_key_length)",
          "old_line_content": "    quick_prefix_select->dbug_dump(indent + 2, verbose);",
          "new_line_content": "  fprintf(DBUG_FILE,",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 6144,
          "old_api": null,
          "new_api": "is_real_null",
          "old_text": null,
          "new_text": "field->is_real_null()",
          "old_line_content": "    In case (a) the condition is false for all values, and in case (b) it",
          "new_line_content": "    *str= (uchar) field->is_real_null();        // Set to 1 if null",
          "content_same": false
        },
        {
          "line": 4097,
          "old_api": null,
          "new_api": "get_sweep_read_cost",
          "old_text": null,
          "new_text": "get_sweep_read_cost(param, roru_total_records)",
          "old_line_content": "      roru->read_cost= roru_total_cost;",
          "new_line_content": "                   get_sweep_read_cost(param, roru_total_records);",
          "content_same": false
        },
        {
          "line": 6145,
          "old_api": null,
          "new_api": "get_key_image",
          "old_text": null,
          "new_text": "field->get_key_image(str+maybe_null, key_part->length,\n                       key_part->image_type)",
          "old_line_content": "    is true for all values, so we can avoid unnecessary retrieval and condition",
          "new_line_content": "  field->get_key_image(str+maybe_null, key_part->length,",
          "content_same": false
        },
        {
          "line": 10248,
          "old_api": null,
          "new_api": "eq",
          "old_text": null,
          "new_text": "keypart_tree->field->eq(field)",
          "old_line_content": "    SEL_ARG *curr_tree= NULL;",
          "new_line_content": "  if (keypart_tree->field->eq(field))",
          "content_same": false
        },
        {
          "line": 4110,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(roru)",
          "old_line_content": "    get_index_only_read_time()",
          "new_line_content": "      DBUG_RETURN(roru);",
          "content_same": false
        },
        {
          "line": 10255,
          "old_api": null,
          "new_api": "first",
          "old_text": null,
          "new_text": "keypart_tree->first()",
          "old_line_content": "    }",
          "new_line_content": "  SEL_ARG *first_kp=  keypart_tree->first();",
          "content_same": false
        },
        {
          "line": 4113,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(imerge_trp)",
          "old_line_content": "      keynr    key to read",
          "new_line_content": "  DBUG_RETURN(imerge_trp);",
          "content_same": false
        },
        {
          "line": 6161,
          "old_api": null,
          "new_api": "result_type",
          "old_text": null,
          "new_text": "field->result_type()",
          "old_line_content": "        tree->type= SEL_ARG::IMPOSSIBLE;",
          "new_line_content": "  if (field->result_type() == INT_RESULT &&",
          "content_same": false
        },
        {
          "line": 6162,
          "old_api": null,
          "new_api": "result_type",
          "old_text": null,
          "new_text": "value->result_type()",
          "old_line_content": "        goto end;",
          "new_line_content": "      value->result_type() == INT_RESULT &&",
          "content_same": false
        },
        {
          "line": 6163,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "field->type()",
          "old_line_content": "      }",
          "new_line_content": "      ((field->type() == FIELD_TYPE_BIT || ",
          "content_same": false
        },
        {
          "line": 6167,
          "old_api": null,
          "new_api": "val_int",
          "old_text": null,
          "new_text": "value->val_int()",
          "old_line_content": "        goto end;",
          "new_line_content": "    longlong item_val= value->val_int();",
          "content_same": false
        },
        {
          "line": 8217,
          "old_api": null,
          "new_api": "is_key_used",
          "old_text": null,
          "new_text": "is_key_used(head, index, fields)",
          "old_line_content": "  }",
          "new_line_content": "  return is_key_used(head, index, fields);",
          "content_same": false
        },
        {
          "line": 10273,
          "old_api": null,
          "new_api": "all_same",
          "old_text": null,
          "new_text": "all_same(tree_first_range, curr_tree)",
          "old_line_content": "    get_constant_key_infix()",
          "new_line_content": "    else if (!all_same(tree_first_range, curr_tree))",
          "content_same": false
        },
        {
          "line": 8226,
          "old_api": null,
          "new_api": "is_key_used",
          "old_text": null,
          "new_text": "is_key_used(head, quick->index, fields)",
          "old_line_content": "  {",
          "new_line_content": "    if (is_key_used(head, quick->index, fields))",
          "content_same": false
        },
        {
          "line": 6185,
          "old_api": null,
          "new_api": "stored_field_cmp_to_item",
          "old_text": null,
          "new_text": "stored_field_cmp_to_item(param->thd, field, value)",
          "old_line_content": "    break;",
          "new_line_content": "    if (stored_field_cmp_to_item(param->thd, field, value) == 0)",
          "content_same": false
        },
        {
          "line": 8238,
          "old_api": null,
          "new_api": "is_key_used",
          "old_text": null,
          "new_text": "is_key_used(head, quick->index, fields)",
          "old_line_content": "  {",
          "new_line_content": "    if (is_key_used(head, quick->index, fields))",
          "content_same": false
        },
        {
          "line": 5782,
          "old_api": null,
          "new_api": "tree_and",
          "old_text": null,
          "new_text": "tree_and(param, ftree, tree)",
          "old_line_content": "    }",
          "new_line_content": "        ftree= !ftree ? tree : tree_and(param, ftree, tree);",
          "content_same": false
        },
        {
          "line": 2102,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(this->key_infix, key_infix_arg, key_infix_len)",
          "old_line_content": "  Fill param->needed_fields with bitmap of fields used in the query.",
          "new_line_content": "        memcpy(this->key_infix, key_infix_arg, key_infix_len);",
          "content_same": false
        },
        {
          "line": 6200,
          "old_api": null,
          "new_api": "stored_field_cmp_to_item",
          "old_text": null,
          "new_text": "stored_field_cmp_to_item(param->thd, field, value)",
          "old_line_content": "  case Item_func::SP_EQUALS_FUNC:",
          "new_line_content": "        (stored_field_cmp_to_item(param->thd, field, value) <= 0))",
          "content_same": false
        },
        {
          "line": 8250,
          "old_api": null,
          "new_api": "is_keys_used",
          "old_text": null,
          "new_text": "quick->is_keys_used(fields)",
          "old_line_content": "    get_quick_select_for_ref()",
          "new_line_content": "    if (quick->is_keys_used(fields))",
          "content_same": false
        },
        {
          "line": 6207,
          "old_api": null,
          "new_api": "stored_field_cmp_to_item",
          "old_text": null,
          "new_text": "stored_field_cmp_to_item(param->thd, field, value)",
          "old_line_content": "    break;",
          "new_line_content": "        (stored_field_cmp_to_item(param->thd, field, value) < 0))",
          "content_same": false
        },
        {
          "line": 2133,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(param->mem_root,\n                                  param->fields_bitmap_size)",
          "old_line_content": "    /* The table uses clustered PK and it is not internally generated */",
          "new_line_content": "  if (!(tmp= (my_bitmap_map*) alloc_root(param->mem_root,",
          "content_same": false
        },
        {
          "line": 2135,
          "old_api": null,
          "new_api": "bitmap_init",
          "old_text": null,
          "new_text": "bitmap_init(&param->needed_fields, tmp, table->s->fields, FALSE)",
          "old_line_content": "    KEY_PART_INFO *key_part_end= key_part +",
          "new_line_content": "      bitmap_init(&param->needed_fields, tmp, table->s->fields, FALSE))",
          "content_same": false
        },
        {
          "line": 2139,
          "old_api": null,
          "new_api": "bitmap_union",
          "old_text": null,
          "new_text": "bitmap_union(&param->needed_fields, table->write_set)",
          "old_line_content": "  }",
          "new_line_content": "  bitmap_union(&param->needed_fields, table->write_set);",
          "content_same": false
        },
        {
          "line": 2142,
          "old_api": null,
          "new_api": "primary_key_is_clustered",
          "old_text": null,
          "new_text": "param->table->file->primary_key_is_clustered()",
          "old_line_content": "",
          "new_line_content": "  if (pk != MAX_KEY && param->table->file->primary_key_is_clustered())",
          "content_same": false
        },
        {
          "line": 10340,
          "old_api": null,
          "new_api": "get_sel_arg_for_keypart",
          "old_text": null,
          "new_text": "get_sel_arg_for_keypart(cur_part->field, index_range_tree,\n                                &cur_range)",
          "old_line_content": "      else",
          "new_line_content": "    if (get_sel_arg_for_keypart(cur_part->field, index_range_tree,",
          "content_same": false
        },
        {
          "line": 2149,
          "old_api": null,
          "new_api": "bitmap_clear_bit",
          "old_text": null,
          "new_text": "bitmap_clear_bit(&param->needed_fields, key_part->fieldnr-1)",
          "old_line_content": "      thd               Current thread",
          "new_line_content": "      bitmap_clear_bit(&param->needed_fields, key_part->fieldnr-1);",
          "content_same": false
        },
        {
          "line": 4198,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"make_ror_scan\")",
          "old_line_content": "  ror_scan->records= param->table->quick_rows[keynr];",
          "new_line_content": "  DBUG_ENTER(\"make_ror_scan\");",
          "content_same": false
        },
        {
          "line": 6252,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(tree)",
          "old_line_content": "** MAYBE:\t Condition may exists when tables are read",
          "new_line_content": "  DBUG_RETURN(tree);",
          "content_same": false
        },
        {
          "line": 4211,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(param->mem_root,\n                                                param->fields_bitmap_size)",
          "old_line_content": "                               param->table->key_info[keynr].key_parts;",
          "new_line_content": "  if (!(bitmap_buf= (my_bitmap_map*) alloc_root(param->mem_root,",
          "content_same": false
        },
        {
          "line": 4213,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "  {",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 8310,
          "old_api": null,
          "new_api": "make_prev_keypart_map",
          "old_text": null,
          "new_text": "make_prev_keypart_map(ref->key_parts)",
          "old_line_content": "    key_part->length=       key_info->key_part[part].length;",
          "new_line_content": "    make_prev_keypart_map(ref->key_parts);",
          "content_same": false
        },
        {
          "line": 4217,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "  ror_scan->index_read_cost=",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 8314,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(&quick->alloc,sizeof(KEY_PART)*ref->key_parts)",
          "old_line_content": "  }",
          "new_line_content": "\talloc_root(&quick->alloc,sizeof(KEY_PART)*ref->key_parts)))",
          "content_same": false
        },
        {
          "line": 6537,
          "old_api": null,
          "new_api": "or_sel_tree",
          "old_text": null,
          "new_text": "merge->or_sel_tree(param, tree1)",
          "old_line_content": "        result= tree1;",
          "new_line_content": "          (merge->or_sel_tree(param, tree1)) ||",
          "content_same": false
        },
        {
          "line": 6538,
          "old_api": null,
          "new_api": "or_sel_tree",
          "old_text": null,
          "new_text": "merge->or_sel_tree(param, tree2)",
          "old_line_content": "    }",
          "new_line_content": "          (merge->or_sel_tree(param, tree2)))",
          "content_same": false
        },
        {
          "line": 4225,
          "old_api": null,
          "new_api": "bitmap_is_set",
          "old_text": null,
          "new_text": "bitmap_is_set(&param->needed_fields, key_part->fieldnr-1)",
          "old_line_content": "  Compare two ROR_SCAN_INFO** by  E(#records_matched) * key_record_length.",
          "new_line_content": "    if (bitmap_is_set(&param->needed_fields, key_part->fieldnr-1))",
          "content_same": false
        },
        {
          "line": 4226,
          "old_api": null,
          "new_api": "bitmap_set_bit",
          "old_text": null,
          "new_text": "bitmap_set_bit(&ror_scan->covered_fields, key_part->fieldnr-1)",
          "old_line_content": "  SYNOPSIS",
          "new_line_content": "      bitmap_set_bit(&ror_scan->covered_fields, key_part->fieldnr-1);",
          "content_same": false
        },
        {
          "line": 10372,
          "old_api": null,
          "new_api": "DBUG_ASSERT (field_length > 0)",
          "old_text": null,
          "new_text": "DBUG_ASSERT (field_length > 0)",
          "old_line_content": "    }",
          "new_line_content": "      DBUG_ASSERT (field_length > 0);",
          "content_same": false
        },
        {
          "line": 4229,
          "old_api": null,
          "new_api": "get_index_only_read_time",
          "old_text": null,
          "new_text": "get_index_only_read_time(param, param->table->quick_rows[ror_scan->keynr],\n                             ror_scan->keynr)",
          "old_line_content": "      b ptr to second compared value",
          "new_line_content": "    get_index_only_read_time(param, param->table->quick_rows[ror_scan->keynr],",
          "content_same": false
        },
        {
          "line": 8326,
          "old_api": null,
          "new_api": "insert_dynamic",
          "old_text": null,
          "new_text": "insert_dynamic(&quick->ranges,(uchar*)&range)",
          "old_line_content": "    QUICK_RANGE *null_range;",
          "new_line_content": "  if (insert_dynamic(&quick->ranges,(uchar*)&range))",
          "content_same": false
        },
        {
          "line": 10374,
          "old_api": null,
          "new_api": "bzero",
          "old_text": null,
          "new_text": "bzero(key_ptr+1,field_length-1)",
          "old_line_content": "      return false;",
          "new_line_content": "      bzero(key_ptr+1,field_length-1);",
          "content_same": false
        },
        {
          "line": 4231,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(ror_scan)",
          "old_line_content": "  RETURN",
          "new_line_content": "  DBUG_RETURN(ror_scan);",
          "content_same": false
        },
        {
          "line": 10378,
          "old_api": null,
          "new_api": "memcmp",
          "old_text": null,
          "new_text": "memcmp(cur_range->min_value, cur_range->max_value, field_length)",
          "old_line_content": "    *first_non_infix_part= last_part;",
          "new_line_content": "    else if (memcmp(cur_range->min_value, cur_range->max_value, field_length) == 0)",
          "content_same": false
        },
        {
          "line": 10380,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(key_ptr, cur_range->min_value, field_length)",
          "old_line_content": "  return TRUE;",
          "new_line_content": "      memcpy(key_ptr, cur_range->min_value, field_length);",
          "content_same": false
        },
        {
          "line": 8342,
          "old_api": null,
          "new_api": "make_prev_keypart_map",
          "old_text": null,
          "new_text": "make_prev_keypart_map(ref->key_parts)",
          "old_line_content": "err:",
          "new_line_content": "                      make_prev_keypart_map(ref->key_parts),",
          "content_same": false
        },
        {
          "line": 8344,
          "old_api": null,
          "new_api": "make_prev_keypart_map",
          "old_text": null,
          "new_text": "make_prev_keypart_map(ref->key_parts)",
          "old_line_content": "  return 0;",
          "new_line_content": "                      make_prev_keypart_map(ref->key_parts), EQ_RANGE)))",
          "content_same": false
        },
        {
          "line": 4250,
          "old_api": null,
          "new_api": "rows2double",
          "old_text": null,
          "new_text": "rows2double((*a)->records)",
          "old_line_content": "  SYNOPSIS",
          "new_line_content": "  double val1= rows2double((*a)->records) * (*a)->key_rec_length;",
          "content_same": false
        },
        {
          "line": 8347,
          "old_api": null,
          "new_api": "insert_dynamic",
          "old_text": null,
          "new_text": "insert_dynamic(&quick->ranges,(uchar*)&null_range)",
          "old_line_content": "",
          "new_line_content": "    if (insert_dynamic(&quick->ranges,(uchar*)&null_range))",
          "content_same": false
        },
        {
          "line": 4251,
          "old_api": null,
          "new_api": "rows2double",
          "old_text": null,
          "new_text": "rows2double((*b)->records)",
          "old_line_content": "    cmp_ror_scan_info_covering()",
          "new_line_content": "  double val2= rows2double((*b)->records) * (*b)->key_rec_length;",
          "content_same": false
        },
        {
          "line": 6311,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"tree_and\")",
          "old_line_content": "    if (tree2->type == SEL_TREE::KEY)",
          "new_line_content": "  DBUG_ENTER(\"tree_and\");",
          "content_same": false
        },
        {
          "line": 6315,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(tree1)",
          "old_line_content": "  if (tree2->type == SEL_TREE::MAYBE)",
          "new_line_content": "    DBUG_RETURN(tree1);",
          "content_same": false
        },
        {
          "line": 6317,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(tree1)",
          "old_line_content": "    tree1->type=SEL_TREE::KEY_SMALLER;",
          "new_line_content": "    DBUG_RETURN(tree1);",
          "content_same": false
        },
        {
          "line": 6319,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(tree2)",
          "old_line_content": "  }",
          "new_line_content": "    DBUG_RETURN(tree2);",
          "content_same": false
        },
        {
          "line": 2227,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"SQL_SELECT::test_quick_select\")",
          "old_line_content": "  records= head->file->stats.records;",
          "new_line_content": "  DBUG_ENTER(\"SQL_SELECT::test_quick_select\");",
          "content_same": false
        },
        {
          "line": 2228,
          "old_api": null,
          "new_api": "to_ulonglong",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"enter\",(\"keys_to_use: %lu  prev_tables: %lu  const_tables: %lu\",\n\t\t      (ulong) keys_to_use.to_ulonglong(), (ulong) prev_tables,\n\t\t      (ulong) const_tables))",
          "old_line_content": "  if (!records)",
          "new_line_content": "  DBUG_PRINT(\"enter\",(\"keys_to_use: %lu  prev_tables: %lu  const_tables: %lu\",",
          "content_same": false
        },
        {
          "line": 2229,
          "old_api": null,
          "new_api": "to_ulonglong",
          "old_text": null,
          "new_text": "keys_to_use.to_ulonglong()",
          "old_line_content": "    records++;\t\t\t\t\t/* purecov: inspected */",
          "new_line_content": "\t\t      (ulong) keys_to_use.to_ulonglong(), (ulong) prev_tables,",
          "content_same": false
        },
        {
          "line": 10419,
          "old_api": null,
          "new_api": "eq",
          "old_text": null,
          "new_text": "field->eq(part->field)",
          "old_line_content": "    get_index_range_tree()",
          "new_line_content": "    if (field->eq(part->field))",
          "content_same": false
        },
        {
          "line": 6324,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(tree2)",
          "old_line_content": "  SEL_ARG **key1,**key2,**end;",
          "new_line_content": "    DBUG_RETURN(tree2);",
          "content_same": false
        },
        {
          "line": 6329,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(tree1)",
          "old_line_content": "    if (*key1 || *key2)",
          "new_line_content": "    DBUG_RETURN(tree1);",
          "content_same": false
        },
        {
          "line": 2234,
          "old_api": null,
          "new_api": "clear_all",
          "old_text": null,
          "new_text": "needed_reg.clear_all()",
          "old_line_content": "  if (limit < records)",
          "new_line_content": "  needed_reg.clear_all();",
          "content_same": false
        },
        {
          "line": 2235,
          "old_api": null,
          "new_api": "clear_all",
          "old_text": null,
          "new_text": "quick_keys.clear_all()",
          "old_line_content": "    read_time= (double) records + scan_time + 1; // Force to use index",
          "new_line_content": "  quick_keys.clear_all();",
          "content_same": false
        },
        {
          "line": 2236,
          "old_api": null,
          "new_api": "is_clear_all",
          "old_text": null,
          "new_text": "keys_to_use.is_clear_all()",
          "old_line_content": "  else if (read_time <= 2.0 && !force_quick_range)",
          "new_line_content": "  if (keys_to_use.is_clear_all())",
          "content_same": false
        },
        {
          "line": 6332,
          "old_api": null,
          "new_api": "clear_all",
          "old_text": null,
          "new_text": "result_keys.clear_all()",
          "old_line_content": "\tflag|=CLONE_KEY1_MAYBE;",
          "new_line_content": "  result_keys.clear_all();",
          "content_same": false
        },
        {
          "line": 8382,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"QUICK_INDEX_MERGE_SELECT::read_keys_and_merge\")",
          "old_line_content": "    We reuse the same instance of handler so we need to call both init and ",
          "new_line_content": "  DBUG_ENTER(\"QUICK_INDEX_MERGE_SELECT::read_keys_and_merge\");",
          "content_same": false
        },
        {
          "line": 8388,
          "old_api": null,
          "new_api": "rewind",
          "old_text": null,
          "new_text": "cur_quick_it.rewind()",
          "old_line_content": "  if (unique == NULL)",
          "new_line_content": "  cur_quick_it.rewind();",
          "content_same": false
        },
        {
          "line": 6342,
          "old_api": null,
          "new_api": "simple_key",
          "old_text": null,
          "new_text": "*key1)->simple_key()",
          "old_line_content": "#ifdef EXTRA_DEBUG",
          "new_line_content": "      if (*key1 && !(*key1)->simple_key())",
          "content_same": false
        },
        {
          "line": 2248,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "    KEY *key_info;",
          "new_line_content": "    DBUG_RETURN(0);\t\t\t\t/* No need for quick select */",
          "content_same": false
        },
        {
          "line": 2250,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\",(\"Time to scan table: %g\", read_time))",
          "old_line_content": "",
          "new_line_content": "  DBUG_PRINT(\"info\",(\"Time to scan table: %g\", read_time));",
          "content_same": false
        },
        {
          "line": 6346,
          "old_api": null,
          "new_api": "key_and",
          "old_text": null,
          "new_text": "key_and(param, *key1, *key2, flag)",
          "old_line_content": "    }",
          "new_line_content": "      *key1=key_and(param, *key1, *key2, flag);",
          "content_same": false
        },
        {
          "line": 8396,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "cur_quick->reset()",
          "old_line_content": "                       thd->variables.sortbuff_size);",
          "new_line_content": "  if (cur_quick->init() || cur_quick->reset())",
          "content_same": false
        },
        {
          "line": 8397,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(1)",
          "old_line_content": "  }",
          "new_line_content": "    DBUG_RETURN(1);",
          "content_same": false
        },
        {
          "line": 2253,
          "old_api": null,
          "new_api": "is_clear_all",
          "old_text": null,
          "new_text": "keys_to_use.is_clear_all()",
          "old_line_content": "",
          "new_line_content": "  if (!keys_to_use.is_clear_all())",
          "content_same": false
        },
        {
          "line": 8402,
          "old_api": null,
          "new_api": "DBUG_EXECUTE_IF",
          "old_text": null,
          "new_text": "DBUG_EXECUTE_IF(\"only_one_Unique_may_be_created\", \n                    DBUG_SET(\"+d,index_merge_may_not_create_a_Unique\"); )",
          "old_line_content": "  }",
          "new_line_content": "    DBUG_EXECUTE_IF(\"only_one_Unique_may_be_created\", ",
          "content_same": false
        },
        {
          "line": 8403,
          "old_api": null,
          "new_api": "DBUG_SET",
          "old_text": null,
          "new_text": "DBUG_SET(\"+d,index_merge_may_not_create_a_Unique\")",
          "old_line_content": "",
          "new_line_content": "                    DBUG_SET(\"+d,index_merge_may_not_create_a_Unique\"); );",
          "content_same": false
        },
        {
          "line": 6355,
          "old_api": null,
          "new_api": "test_use_count",
          "old_text": null,
          "new_text": "*key1)->test_use_count(*key1)",
          "old_line_content": "",
          "new_line_content": "          (*key1)->test_use_count(*key1);",
          "content_same": false
        },
        {
          "line": 2262,
          "old_api": null,
          "new_api": "check_stack_overrun",
          "old_text": null,
          "new_text": "check_stack_overrun(thd, 2*STACK_MIN_SIZE + sizeof(PARAM), buff)",
          "old_line_content": "    param.mem_root= &alloc;",
          "new_line_content": "    if (check_stack_overrun(thd, 2*STACK_MIN_SIZE + sizeof(PARAM), buff))",
          "content_same": false
        },
        {
          "line": 2263,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "    param.old_root= thd->mem_root;",
          "new_line_content": "      DBUG_RETURN(0);                           // Fatal error flag is set",
          "content_same": false
        },
        {
          "line": 6361,
          "old_api": null,
          "new_api": "is_clear_all",
          "old_text": null,
          "new_text": "result_keys.is_clear_all()",
          "old_line_content": "",
          "new_line_content": "  if (!result_keys.is_clear_all())",
          "content_same": false
        },
        {
          "line": 2267,
          "old_api": null,
          "new_api": "ha_table_flags",
          "old_text": null,
          "new_text": "head->file->ha_table_flags()",
          "old_line_content": "    param.remove_jump_scans= TRUE;",
          "new_line_content": "    param.baseflag= head->file->ha_table_flags();",
          "content_same": false
        },
        {
          "line": 8412,
          "old_api": null,
          "new_api": "filesort_free_buffers",
          "old_text": null,
          "new_text": "filesort_free_buffers(head, false)",
          "old_line_content": "    {",
          "new_line_content": "    filesort_free_buffers(head, false);",
          "content_same": false
        },
        {
          "line": 6363,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "tree1->merges.empty()",
          "old_line_content": "  Check if two SEL_TREES can be combined into one (i.e. a single key range",
          "new_line_content": "    tree1->merges.empty();",
          "content_same": false
        },
        {
          "line": 6364,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(tree1)",
          "old_line_content": "  read can be constructed for \"cond_of_tree1 OR cond_of_tree2\" ) without",
          "new_line_content": "    DBUG_RETURN(tree1);",
          "content_same": false
        },
        {
          "line": 8415,
          "old_api": null,
          "new_api": "get_size",
          "old_text": null,
          "new_text": "unique->get_size()",
          "old_line_content": "      if (!cur_quick)",
          "new_line_content": "  DBUG_ASSERT(file->ref_length == unique->get_size());",
          "content_same": false
        },
        {
          "line": 8416,
          "old_api": null,
          "new_api": "get_max_in_memory_size",
          "old_text": null,
          "new_text": "unique->get_max_in_memory_size()",
          "old_line_content": "        break;",
          "new_line_content": "  DBUG_ASSERT(thd->variables.sortbuff_size == unique->get_max_in_memory_size());",
          "content_same": false
        },
        {
          "line": 6368,
          "old_api": null,
          "new_api": "imerge_list_and_list",
          "old_text": null,
          "new_text": "imerge_list_and_list(&tree1->merges, &tree2->merges)",
          "old_line_content": "bool sel_trees_can_be_ored(SEL_TREE *tree1, SEL_TREE *tree2, ",
          "new_line_content": "  imerge_list_and_list(&tree1->merges, &tree2->merges);",
          "content_same": false
        },
        {
          "line": 6369,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(tree1)",
          "old_line_content": "                           RANGE_OPT_PARAM* param)",
          "new_line_content": "  DBUG_RETURN(tree1);",
          "content_same": false
        },
        {
          "line": 7778,
          "old_api": null,
          "new_api": "store_max",
          "old_text": null,
          "new_text": "key_tree->store_max(param->key[idx][key_tree->part].store_length,\n                                        &tmp_max_key, max_key_flag)",
          "old_line_content": "    uint16 fieldnr= param->table->key_info[param->real_keynr[idx]].",
          "new_line_content": "  tmp_max_keypart+= key_tree->store_max(param->key[idx][key_tree->part].store_length,",
          "content_same": false
        },
        {
          "line": 8422,
          "old_api": null,
          "new_api": "get_next",
          "old_text": null,
          "new_text": "cur_quick->get_next()",
          "old_line_content": "    }",
          "new_line_content": "    while ((result= cur_quick->get_next()) == HA_ERR_END_OF_FILE)",
          "content_same": false
        },
        {
          "line": 4327,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(param->mem_root,\n                                              sizeof(ROR_INTERSECT_INFO))",
          "old_line_content": "  info->index_scan_costs= 0.0;",
          "new_line_content": "  if (!(info= (ROR_INTERSECT_INFO*)alloc_root(param->mem_root,",
          "content_same": false
        },
        {
          "line": 8424,
          "old_api": null,
          "new_api": "range_end",
          "old_text": null,
          "new_text": "cur_quick->range_end()",
          "old_line_content": "    if (result)",
          "new_line_content": "      cur_quick->range_end();",
          "content_same": false
        },
        {
          "line": 2281,
          "old_api": null,
          "new_api": "init_sql_alloc",
          "old_text": null,
          "new_text": "init_sql_alloc(&alloc, thd->variables.range_alloc_block_size, 0)",
          "old_line_content": "    thd->mem_root= &alloc;",
          "new_line_content": "    init_sql_alloc(&alloc, thd->variables.range_alloc_block_size, 0);",
          "content_same": false
        },
        {
          "line": 2282,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(&alloc,\n                                                  sizeof(KEY_PART)*\n                                                  head->s->key_parts)",
          "old_line_content": "",
          "new_line_content": "    if (!(param.key_parts= (KEY_PART*) alloc_root(&alloc,",
          "content_same": false
        },
        {
          "line": 4331,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(param->mem_root,\n                                         param->fields_bitmap_size)",
          "old_line_content": "  return info;",
          "new_line_content": "  if (!(buf= (my_bitmap_map*) alloc_root(param->mem_root,",
          "content_same": false
        },
        {
          "line": 2285,
          "old_api": null,
          "new_api": "fill_used_fields_bitmap",
          "old_text": null,
          "new_text": "fill_used_fields_bitmap(&param)",
          "old_line_content": "      This is used in get_mm_parts function.",
          "new_line_content": "        fill_used_fields_bitmap(&param))",
          "content_same": false
        },
        {
          "line": 8430,
          "old_api": null,
          "new_api": "ha_index_end",
          "old_text": null,
          "new_text": "cur_quick->file->ha_index_end()",
          "old_line_content": "      }",
          "new_line_content": "        cur_quick->file->ha_index_end();",
          "content_same": false
        },
        {
          "line": 8431,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "cur_quick->reset()",
          "old_line_content": "      break;",
          "new_line_content": "      if (cur_quick->init() || cur_quick->reset())",
          "content_same": false
        },
        {
          "line": 8432,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(1)",
          "old_line_content": "    }",
          "new_line_content": "        DBUG_RETURN(1);",
          "content_same": false
        },
        {
          "line": 2288,
          "old_api": null,
          "new_api": "MYF",
          "old_text": null,
          "new_text": "MYF(0)",
          "old_line_content": "    for (idx=0 ; idx < head->s->keys ; idx++, key_info++)",
          "new_line_content": "      free_root(&alloc,MYF(0));\t\t\t// Return memory & allocator",
          "content_same": false
        },
        {
          "line": 2289,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "    {",
          "new_line_content": "      DBUG_RETURN(0);\t\t\t\t// Can't use range",
          "content_same": false
        },
        {
          "line": 4334,
          "old_api": null,
          "new_api": "bitmap_init",
          "old_text": null,
          "new_text": "bitmap_init(&info->covered_fields, buf, param->table->s->fields,\n                  FALSE)",
          "old_line_content": "void ror_intersect_cpy(ROR_INTERSECT_INFO *dst, const ROR_INTERSECT_INFO *src)",
          "new_line_content": "  if (bitmap_init(&info->covered_fields, buf, param->table->s->fields,",
          "content_same": false
        },
        {
          "line": 6383,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"sel_trees_can_be_ored\")",
          "old_line_content": "    {",
          "new_line_content": "  DBUG_ENTER(\"sel_trees_can_be_ored\");",
          "content_same": false
        },
        {
          "line": 4341,
          "old_api": null,
          "new_api": "bitmap_clear_all",
          "old_text": null,
          "new_text": "bitmap_clear_all(&info->covered_fields)",
          "old_line_content": "  dst->index_records= src->index_records;",
          "new_line_content": "  bitmap_clear_all(&info->covered_fields);",
          "content_same": false
        },
        {
          "line": 6384,
          "old_api": null,
          "new_api": "intersect",
          "old_text": null,
          "new_text": "common_keys.intersect(tree2->keys_map)",
          "old_line_content": "      key1= tree1->keys + key_no;",
          "new_line_content": "  common_keys.intersect(tree2->keys_map);",
          "content_same": false
        },
        {
          "line": 8439,
          "old_api": null,
          "new_api": "range_end",
          "old_text": null,
          "new_text": "cur_quick->range_end()",
          "old_line_content": "      continue;",
          "new_line_content": "        cur_quick->range_end();",
          "content_same": false
        },
        {
          "line": 8440,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "",
          "new_line_content": "        DBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 6386,
          "old_api": null,
          "new_api": "is_clear_all",
          "old_text": null,
          "new_text": "common_keys.is_clear_all()",
          "old_line_content": "      if ((*key1)->part == (*key2)->part)",
          "new_line_content": "  if (common_keys.is_clear_all())",
          "content_same": false
        },
        {
          "line": 6387,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(FALSE)",
          "old_line_content": "      {",
          "new_line_content": "    DBUG_RETURN(FALSE);",
          "content_same": false
        },
        {
          "line": 6393,
          "old_api": null,
          "new_api": "is_set",
          "old_text": null,
          "new_text": "common_keys.is_set(key_no)",
          "old_line_content": "}",
          "new_line_content": "    if (common_keys.is_set(key_no))",
          "content_same": false
        },
        {
          "line": 4348,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(dst->covered_fields.bitmap, src->covered_fields.bitmap, \n         no_bytes_in_map(&src->covered_fields))",
          "old_line_content": "  Get selectivity of a ROR scan wrt ROR-intersection.",
          "new_line_content": "  memcpy(dst->covered_fields.bitmap, src->covered_fields.bitmap, ",
          "content_same": false
        },
        {
          "line": 4349,
          "old_api": null,
          "new_api": "no_bytes_in_map",
          "old_text": null,
          "new_text": "no_bytes_in_map(&src->covered_fields)",
          "old_line_content": "",
          "new_line_content": "         no_bytes_in_map(&src->covered_fields));",
          "content_same": false
        },
        {
          "line": 8446,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(1)",
          "old_line_content": "",
          "new_line_content": "      DBUG_RETURN(1);",
          "content_same": false
        },
        {
          "line": 2302,
          "old_api": null,
          "new_api": "is_set",
          "old_text": null,
          "new_text": "keys_to_use.is_set(idx)",
          "old_line_content": "\tkey_parts->part=\t part;",
          "new_line_content": "      if (!keys_to_use.is_set(idx))",
          "content_same": false
        },
        {
          "line": 6399,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(TRUE)",
          "old_line_content": "    param  Range analysis parameter",
          "new_line_content": "        DBUG_RETURN(TRUE);",
          "content_same": false
        },
        {
          "line": 8449,
          "old_api": null,
          "new_api": "row_in_ranges",
          "old_text": null,
          "new_text": "pk_quick_select->row_in_ranges()",
          "old_line_content": "    head->sort structure so it can be used to iterate through the rowids",
          "new_line_content": "    if (pk_quick_select && pk_quick_select->row_in_ranges())",
          "content_same": false
        },
        {
          "line": 6403,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(FALSE)",
          "old_line_content": "    This function walks through tree->keys[] and removes the SEL_ARG* trees",
          "new_line_content": "  DBUG_RETURN(FALSE);",
          "content_same": false
        },
        {
          "line": 8453,
          "old_api": null,
          "new_api": "unique_add",
          "old_text": null,
          "new_text": "unique->unique_add((char*)cur_quick->file->ref)",
          "old_line_content": "  doing_pk_scan= FALSE;",
          "new_line_content": "    result= unique->unique_add((char*)cur_quick->file->ref);",
          "content_same": false
        },
        {
          "line": 8463,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "unique->get(head)",
          "old_line_content": "  NOTES",
          "new_line_content": "  result= unique->get(head);",
          "content_same": false
        },
        {
          "line": 8466,
          "old_api": null,
          "new_api": "set_keyread",
          "old_text": null,
          "new_text": "head->set_keyread(FALSE)",
          "old_line_content": "      2. QUICK_RANGE_SELECT with clustered primary key (if any).",
          "new_line_content": "  head->set_keyread(FALSE);",
          "content_same": false
        },
        {
          "line": 8467,
          "old_api": null,
          "new_api": "init_read_record",
          "old_text": null,
          "new_text": "init_read_record(&read_record, thd, head, (SQL_SELECT*) 0, 1 , 1, TRUE)",
          "old_line_content": "    The sets of rows retrieved in 1) and 2) are guaranteed to be disjoint.",
          "new_line_content": "  init_read_record(&read_record, thd, head, (SQL_SELECT*) 0, 1 , 1, TRUE);",
          "content_same": false
        },
        {
          "line": 8468,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "*/",
          "new_line_content": "  DBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 2329,
          "old_api": null,
          "new_api": "is_clear_all",
          "old_text": null,
          "new_text": "head->covering_keys.is_clear_all()",
          "old_line_content": "",
          "new_line_content": "    if (!head->covering_keys.is_clear_all())",
          "content_same": false
        },
        {
          "line": 2331,
          "old_api": null,
          "new_api": "find_shortest_key",
          "old_text": null,
          "new_text": "find_shortest_key(head, &head->covering_keys)",
          "old_line_content": "    TRP_GROUP_MIN_MAX *group_trp;",
          "new_line_content": "      int key_for_use= find_shortest_key(head, &head->covering_keys);",
          "content_same": false
        },
        {
          "line": 2332,
          "old_api": null,
          "new_api": "get_index_only_read_time",
          "old_text": null,
          "new_text": "get_index_only_read_time(&param, records,\n                                                     key_for_use)",
          "old_line_content": "    double best_read_time= read_time;",
          "new_line_content": "      double key_read_time= (get_index_only_read_time(&param, records,",
          "content_same": false
        },
        {
          "line": 2335,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\",  (\"'all'+'using index' scan will be using key %d, \"\n                           \"read time %g\", key_for_use, key_read_time))",
          "old_line_content": "    {",
          "new_line_content": "      DBUG_PRINT(\"info\",  (\"'all'+'using index' scan will be using key %d, \"",
          "content_same": false
        },
        {
          "line": 8484,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"QUICK_INDEX_MERGE_SELECT::get_next\")",
          "old_line_content": "    if (pk_quick_select)",
          "new_line_content": "  DBUG_ENTER(\"QUICK_INDEX_MERGE_SELECT::get_next\");",
          "content_same": false
        },
        {
          "line": 2347,
          "old_api": null,
          "new_api": "get_mm_tree",
          "old_text": null,
          "new_text": "get_mm_tree(&param,cond)",
          "old_line_content": "        */",
          "new_line_content": "      if ((tree= get_mm_tree(&param,cond)))",
          "content_same": false
        },
        {
          "line": 8492,
          "old_api": null,
          "new_api": "end_read_record",
          "old_text": null,
          "new_text": "end_read_record(&read_record)",
          "old_line_content": "  }",
          "new_line_content": "    end_read_record(&read_record);",
          "content_same": false
        },
        {
          "line": 8493,
          "old_api": null,
          "new_api": "free_io_cache",
          "old_text": null,
          "new_text": "free_io_cache(head)",
          "old_line_content": "",
          "new_line_content": "    free_io_cache(head);",
          "content_same": false
        },
        {
          "line": 10541,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"cost_group_min_max\")",
          "old_line_content": "    /* each group contains 10% of all records */",
          "new_line_content": "  DBUG_ENTER(\"cost_group_min_max\");",
          "content_same": false
        },
        {
          "line": 8498,
          "old_api": null,
          "new_api": "init",
          "old_text": null,
          "new_text": "pk_quick_select->init()",
          "old_line_content": "/*",
          "new_line_content": "      if ((result= pk_quick_select->init()) ||",
          "content_same": false
        },
        {
          "line": 8499,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "pk_quick_select->reset()",
          "old_line_content": "  Retrieve next record.",
          "new_line_content": "          (result= pk_quick_select->reset()))",
          "content_same": false
        },
        {
          "line": 8500,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "  SYNOPSIS",
          "new_line_content": "        DBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 8501,
          "old_api": null,
          "new_api": "get_next",
          "old_text": null,
          "new_text": "pk_quick_select->get_next()",
          "old_line_content": "     QUICK_ROR_INTERSECT_SELECT::get_next()",
          "new_line_content": "      DBUG_RETURN(pk_quick_select->get_next());",
          "content_same": false
        },
        {
          "line": 10547,
          "old_api": null,
          "new_api": "uint)(table_records / keys_per_block)",
          "old_text": null,
          "new_text": "uint)(table_records / keys_per_block)",
          "old_line_content": "  {",
          "new_line_content": "  num_blocks= (uint)(table_records / keys_per_block) + 1;",
          "content_same": false
        },
        {
          "line": 8505,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "    records with rowid <= some_rowid_val and no intersected select has",
          "new_line_content": "  DBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 10553,
          "old_api": null,
          "new_api": "uint)(table_records / 10)",
          "old_text": null,
          "new_text": "uint)(table_records / 10)",
          "old_line_content": "",
          "new_line_content": "    keys_per_group= (uint)(table_records / 10) + 1;",
          "content_same": false
        },
        {
          "line": 10554,
          "old_api": null,
          "new_api": "uint)(table_records / keys_per_group)",
          "old_text": null,
          "new_text": "uint)(table_records / keys_per_group)",
          "old_line_content": "  if (used_key_parts > group_key_parts)",
          "new_line_content": "  num_groups= (uint)(table_records / keys_per_group) + 1;",
          "content_same": false
        },
        {
          "line": 2368,
          "old_api": null,
          "new_api": "get_best_group_min_max",
          "old_text": null,
          "new_text": "get_best_group_min_max(&param, tree, best_read_time)",
          "old_line_content": "",
          "new_line_content": "    group_trp= get_best_group_min_max(&param, tree, best_read_time);",
          "content_same": false
        },
        {
          "line": 10561,
          "old_api": null,
          "new_api": "rint",
          "old_text": null,
          "new_text": "rint(num_groups * quick_prefix_selectivity)",
          "old_line_content": "      p_overlap= 1.0;       /* a block, it will overlap at least two blocks. */",
          "new_line_content": "    num_groups= (uint) rint(num_groups * quick_prefix_selectivity);",
          "content_same": false
        },
        {
          "line": 10562,
          "old_api": null,
          "new_api": "set_if_bigger",
          "old_text": null,
          "new_text": "set_if_bigger(num_groups, 1)",
          "old_line_content": "    else",
          "new_line_content": "    set_if_bigger(num_groups, 1);",
          "content_same": false
        },
        {
          "line": 2371,
          "old_api": null,
          "new_api": "min",
          "old_text": null,
          "new_text": "min(group_trp->records,\n                                             head->file->stats.records)",
          "old_line_content": "      /*",
          "new_line_content": "      param.table->quick_condition_rows= min(group_trp->records,",
          "content_same": false
        },
        {
          "line": 6472,
          "old_api": null,
          "new_api": "clear_bit",
          "old_text": null,
          "new_text": "tree->keys_map.clear_bit(i)",
          "old_line_content": "tree_or(RANGE_OPT_PARAM *param,SEL_TREE *tree1,SEL_TREE *tree2)",
          "new_line_content": "        tree->keys_map.clear_bit(i);",
          "content_same": false
        },
        {
          "line": 10577,
          "old_api": null,
          "new_api": "min",
          "old_text": null,
          "new_text": "min(p_overlap, 1.0)",
          "old_line_content": "    TODO: If there is no WHERE clause and no other expressions, there should be",
          "new_line_content": "      p_overlap= min(p_overlap, 1.0);",
          "content_same": false
        },
        {
          "line": 2386,
          "old_api": null,
          "new_api": "is_empty",
          "old_text": null,
          "new_text": "tree->merges.is_empty()",
          "old_line_content": "          best_read_time= best_trp->read_cost;",
          "new_line_content": "      if (tree->merges.is_empty())",
          "content_same": false
        },
        {
          "line": 10579,
          "old_api": null,
          "new_api": "min",
          "old_text": null,
          "new_text": "min(num_groups * (1 + p_overlap), num_blocks)",
          "old_line_content": "    scan as computed in SQL_SELECT::test_quick_select().",
          "new_line_content": "    io_cost= (double) min(num_groups * (1 + p_overlap), num_blocks);",
          "content_same": false
        },
        {
          "line": 6485,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"tree_or\")",
          "old_line_content": "",
          "new_line_content": "  DBUG_ENTER(\"tree_or\");",
          "content_same": false
        },
        {
          "line": 6487,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "  key_map  result_keys;",
          "new_line_content": "    DBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 2393,
          "old_api": null,
          "new_api": "get_key_scans_params",
          "old_text": null,
          "new_text": "get_key_scans_params(&param, tree, FALSE, TRUE,\n                                             best_read_time)",
          "old_line_content": "        */",
          "new_line_content": "        if ((range_trp= get_key_scans_params(&param, tree, FALSE, TRUE,",
          "content_same": false
        },
        {
          "line": 6491,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(tree1)",
          "old_line_content": "    /* Join the trees key per key */",
          "new_line_content": "    DBUG_RETURN(tree1);",
          "content_same": false
        },
        {
          "line": 6493,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(tree1)",
          "old_line_content": "    for (key1= tree1->keys,key2= tree2->keys,end= key1+param->keys ;",
          "new_line_content": "    DBUG_RETURN(tree1);\t\t\t\t// Can't use this",
          "content_same": false
        },
        {
          "line": 6495,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(tree2)",
          "old_line_content": "    {",
          "new_line_content": "    DBUG_RETURN(tree2);",
          "content_same": false
        },
        {
          "line": 6499,
          "old_api": null,
          "new_api": "clear_all",
          "old_text": null,
          "new_text": "result_keys.clear_all()",
          "old_line_content": "        result=tree1;\t\t\t\t// Added to tree1",
          "new_line_content": "  result_keys.clear_all();",
          "content_same": false
        },
        {
          "line": 10597,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\",\n             (\"table rows: %lu  keys/block: %u  keys/group: %u  result rows: %lu  blocks: %u\",\n              (ulong)table_records, keys_per_block, keys_per_group, \n              (ulong) *records, num_blocks))",
          "old_line_content": "  SYNOPSIS",
          "new_line_content": "  DBUG_PRINT(\"info\",",
          "content_same": false
        },
        {
          "line": 2406,
          "old_api": null,
          "new_api": "optimizer_flag",
          "old_text": null,
          "new_text": "optimizer_flag(thd, OPTIMIZER_SWITCH_INDEX_MERGE)",
          "old_line_content": "            /*",
          "new_line_content": "             optimizer_flag(thd, OPTIMIZER_SWITCH_INDEX_MERGE))",
          "content_same": false
        },
        {
          "line": 8554,
          "old_api": null,
          "new_api": "get_next",
          "old_text": null,
          "new_text": "quick->get_next()",
          "old_line_content": "",
          "new_line_content": "    error= quick->get_next();",
          "content_same": false
        },
        {
          "line": 4458,
          "old_api": null,
          "new_api": "bitmap_is_set",
          "old_text": null,
          "new_text": "bitmap_is_set(&info->covered_fields,\n                                        key_part->fieldnr-1)",
          "old_line_content": "  for (sel_arg= scan->sel_arg; sel_arg;",
          "new_line_content": "  bool prev_covered= test(bitmap_is_set(&info->covered_fields,",
          "content_same": false
        },
        {
          "line": 2412,
          "old_api": null,
          "new_api": "get_best_ror_intersect",
          "old_text": null,
          "new_text": "get_best_ror_intersect(&param, tree, best_read_time,\n                                                &can_build_covering)",
          "old_line_content": "                                                           best_read_time)))",
          "new_line_content": "          if ((rori_trp= get_best_ror_intersect(&param, tree, best_read_time,",
          "content_same": false
        },
        {
          "line": 8557,
          "old_api": null,
          "new_api": "row_in_ranges",
          "old_text": null,
          "new_text": "cpk_quick->row_in_ranges()",
          "old_line_content": "    last_rowid_count= 1;",
          "new_line_content": "      while (!error && !cpk_quick->row_in_ranges())",
          "content_same": false
        },
        {
          "line": 6507,
          "old_api": null,
          "new_api": "key_or",
          "old_text": null,
          "new_text": "key_or(param, *key1, *key2)",
          "old_line_content": "    if (result)",
          "new_line_content": "      *key1=key_or(param, *key1, *key2);",
          "content_same": false
        },
        {
          "line": 8559,
          "old_api": null,
          "new_api": "unlock_row",
          "old_text": null,
          "new_text": "quick->file->unlock_row()",
          "old_line_content": "",
          "new_line_content": "        quick->file->unlock_row(); /* row not in range; unlock */",
          "content_same": false
        },
        {
          "line": 8560,
          "old_api": null,
          "new_api": "get_next",
          "old_text": null,
          "new_text": "quick->get_next()",
          "old_line_content": "    while (last_rowid_count < quick_selects.elements)",
          "new_line_content": "        error= quick->get_next();",
          "content_same": false
        },
        {
          "line": 6511,
          "old_api": null,
          "new_api": "set_bit",
          "old_text": null,
          "new_text": "result_keys.set_bit(key1 - tree1->keys)",
          "old_line_content": "  {",
          "new_line_content": "        result_keys.set_bit(key1 - tree1->keys);",
          "content_same": false
        },
        {
          "line": 6514,
          "old_api": null,
          "new_api": "test_use_count",
          "old_text": null,
          "new_text": "*key1)->test_use_count(*key1)",
          "old_line_content": "    {",
          "new_line_content": "          (*key1)->test_use_count(*key1);",
          "content_same": false
        },
        {
          "line": 4467,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"ror_scan_selectivity\")",
          "old_line_content": "      ha_rows records;",
          "new_line_content": "  DBUG_ENTER(\"ror_scan_selectivity\");",
          "content_same": false
        },
        {
          "line": 8566,
          "old_api": null,
          "new_api": "position",
          "old_text": null,
          "new_text": "quick->file->position(quick->record)",
          "old_line_content": "      }",
          "new_line_content": "    quick->file->position(quick->record);",
          "content_same": false
        },
        {
          "line": 8567,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(last_rowid, quick->file->ref, head->file->ref_length)",
          "old_line_content": "",
          "new_line_content": "    memcpy(last_rowid, quick->file->ref, head->file->ref_length);",
          "content_same": false
        },
        {
          "line": 2422,
          "old_api": null,
          "new_api": "get_best_covering_ror_intersect",
          "old_text": null,
          "new_text": "get_best_covering_ror_intersect(&param, tree,\n                                                           best_read_time)",
          "old_line_content": "          SEL_IMERGE *imerge;",
          "new_line_content": "                (rori_trp= get_best_covering_ror_intersect(&param, tree,",
          "content_same": false
        },
        {
          "line": 4473,
          "old_api": null,
          "new_api": "bitmap_is_set",
          "old_text": null,
          "new_text": "bitmap_is_set(&info->covered_fields,\n                                    key_part[sel_arg->part].fieldnr-1)",
          "old_line_content": "        keypart_map= 1;",
          "new_line_content": "    cur_covered= test(bitmap_is_set(&info->covered_fields,",
          "content_same": false
        },
        {
          "line": 6524,
          "old_api": null,
          "new_api": "is_empty",
          "old_text": null,
          "new_text": "tree2->merges.is_empty()",
          "old_line_content": "      if (!(result= new SEL_TREE()) || !(merge= new SEL_IMERGE()) ||",
          "new_line_content": "    if (tree1->merges.is_empty() && tree2->merges.is_empty())",
          "content_same": false
        },
        {
          "line": 8575,
          "old_api": null,
          "new_api": "rewind",
          "old_text": null,
          "new_text": "quick_it.rewind()",
          "old_line_content": "          if (!current_thd->transaction_rollback_request)",
          "new_line_content": "        quick_it.rewind();",
          "content_same": false
        },
        {
          "line": 6528,
          "old_api": null,
          "new_api": "remove_nonrange_trees",
          "old_text": null,
          "new_text": "remove_nonrange_trees(param, tree1)",
          "old_line_content": "        result= NULL;",
          "new_line_content": "        bool no_trees= remove_nonrange_trees(param, tree1);",
          "content_same": false
        },
        {
          "line": 6529,
          "old_api": null,
          "new_api": "remove_nonrange_trees",
          "old_text": null,
          "new_text": "remove_nonrange_trees(param, tree2)",
          "old_line_content": "      else",
          "new_line_content": "        no_trees= no_trees || remove_nonrange_trees(param, tree2);",
          "content_same": false
        },
        {
          "line": 2435,
          "old_api": null,
          "new_api": "LINT_INIT",
          "old_text": null,
          "new_text": "LINT_INIT(new_conj_trp)",
          "old_line_content": "                                   best_conj_trp->read_cost))",
          "new_line_content": "          LINT_INIT(new_conj_trp); /* no empty index_merge lists possible */",
          "content_same": false
        },
        {
          "line": 2436,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\",(\"No range reads possible,\"\n                             \" trying to construct index_merge\"))",
          "old_line_content": "              best_conj_trp= new_conj_trp;",
          "new_line_content": "          DBUG_PRINT(\"info\",(\"No range reads possible,\"",
          "content_same": false
        },
        {
          "line": 8581,
          "old_api": null,
          "new_api": "DBUG_EXECUTE_IF",
          "old_text": null,
          "new_text": "DBUG_EXECUTE_IF(\"innodb_quick_report_deadlock\",\n                        DBUG_SET(\"+d,innodb_report_deadlock\");)",
          "old_line_content": "        if (cmp < 0)",
          "new_line_content": "        DBUG_EXECUTE_IF(\"innodb_quick_report_deadlock\",",
          "content_same": false
        },
        {
          "line": 8582,
          "old_api": null,
          "new_api": "DBUG_SET",
          "old_text": null,
          "new_text": "DBUG_SET(\"+d,innodb_report_deadlock\")",
          "old_line_content": "        {",
          "new_line_content": "                        DBUG_SET(\"+d,innodb_report_deadlock\"););",
          "content_same": false
        },
        {
          "line": 8583,
          "old_api": null,
          "new_api": "get_next",
          "old_text": null,
          "new_text": "quick->get_next()",
          "old_line_content": "          /* This row is being skipped.  Release lock on it. */",
          "new_line_content": "        if ((error= quick->get_next()))",
          "content_same": false
        },
        {
          "line": 4483,
          "old_api": null,
          "new_api": "store_min",
          "old_text": null,
          "new_text": "tuple_arg->store_min(key_part->store_length, &key_ptr, 0)",
          "old_line_content": "      min_range.keypart_map= max_range.keypart_map= keypart_map;",
          "new_line_content": "        tuple_arg->store_min(key_part->store_length, &key_ptr, 0);",
          "content_same": false
        },
        {
          "line": 2441,
          "old_api": null,
          "new_api": "get_best_disjunct_quick",
          "old_text": null,
          "new_text": "get_best_disjunct_quick(&param, imerge, best_read_time)",
          "old_line_content": "      }",
          "new_line_content": "            new_conj_trp= get_best_disjunct_quick(&param, imerge, best_read_time);",
          "content_same": false
        },
        {
          "line": 6531,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(new SEL_TREE(SEL_TREE::ALWAYS))",
          "old_line_content": "    }",
          "new_line_content": "          DBUG_RETURN(new SEL_TREE(SEL_TREE::ALWAYS));",
          "content_same": false
        },
        {
          "line": 8587,
          "old_api": null,
          "new_api": "unlock_row",
          "old_text": null,
          "new_text": "quick_with_last_rowid->file->unlock_row()",
          "old_line_content": "",
          "new_line_content": "            quick_with_last_rowid->file->unlock_row();",
          "content_same": false
        },
        {
          "line": 8588,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(error)",
          "old_line_content": "      /* Ok, current select 'caught up' and returned ref >= cur_ref */",
          "new_line_content": "          DBUG_RETURN(error);",
          "content_same": false
        },
        {
          "line": 2443,
          "old_api": null,
          "new_api": "set_if_smaller",
          "old_text": null,
          "new_text": "set_if_smaller(param.table->quick_condition_rows, \n                             new_conj_trp->records)",
          "old_line_content": "",
          "new_line_content": "              set_if_smaller(param.table->quick_condition_rows, ",
          "content_same": false
        },
        {
          "line": 8590,
          "old_api": null,
          "new_api": "position",
          "old_text": null,
          "new_text": "quick->file->position(quick->record)",
          "old_line_content": "      {",
          "new_line_content": "        quick->file->position(quick->record);",
          "content_same": false
        },
        {
          "line": 8591,
          "old_api": null,
          "new_api": "cmp_ref",
          "old_text": null,
          "new_text": "head->file->cmp_ref(quick->file->ref, last_rowid)",
          "old_line_content": "        /* Found a row with ref > cur_ref. Make it a new 'candidate' */",
          "new_line_content": "        cmp= head->file->cmp_ref(quick->file->ref, last_rowid);",
          "content_same": false
        },
        {
          "line": 4495,
          "old_api": null,
          "new_api": "info->param->table->file->\n                records_in_range(scan->keynr, &min_range, &max_range)",
          "old_text": null,
          "new_text": "info->param->table->file->\n                records_in_range(scan->keynr, &min_range, &max_range)",
          "old_line_content": "      {",
          "new_line_content": "      records= (info->param->table->file->",
          "content_same": false
        },
        {
          "line": 6536,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "result->merges.push_back(merge)",
          "old_line_content": "      else",
          "new_line_content": "          (result->merges.push_back(merge)) ||",
          "content_same": false
        },
        {
          "line": 10642,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "    if (quick_prefix_records == HA_POS_ERROR)",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 8595,
          "old_api": null,
          "new_api": "unlock_row",
          "old_text": null,
          "new_text": "quick->file->unlock_row()",
          "old_line_content": "          {",
          "new_line_content": "          quick->file->unlock_row();",
          "content_same": false
        },
        {
          "line": 10644,
          "old_api": null,
          "new_api": "init",
          "old_text": null,
          "new_text": "quick->init()",
          "old_line_content": "    else",
          "new_line_content": "  if (quick->init())",
          "content_same": false
        },
        {
          "line": 4500,
          "old_api": null,
          "new_api": "rows2double",
          "old_text": null,
          "new_text": "rows2double(prev_records)",
          "old_line_content": "    prev_covered= cur_covered;",
          "new_line_content": "        double tmp= rows2double(records)/rows2double(prev_records);",
          "content_same": false
        },
        {
          "line": 4501,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"Selectivity multiplier: %g\", tmp))",
          "old_line_content": "  }",
          "new_line_content": "        DBUG_PRINT(\"info\", (\"Selectivity multiplier: %g\", tmp));",
          "content_same": false
        },
        {
          "line": 10647,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "                                                   index_tree,",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 6553,
          "old_api": null,
          "new_api": "is_empty",
          "old_text": null,
          "new_text": "tree1->merges.is_empty()",
          "old_line_content": "  }",
          "new_line_content": "      if (tree1->merges.is_empty())",
          "content_same": false
        },
        {
          "line": 10652,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(quick_prefix_records > 0)",
          "old_line_content": "      attribute, and create an array of QUICK_RANGES to be used by the",
          "new_line_content": "    DBUG_ASSERT(quick_prefix_records > 0);",
          "content_same": false
        },
        {
          "line": 2461,
          "old_api": null,
          "new_api": "init",
          "old_text": null,
          "new_text": "quick->init()",
          "old_line_content": "  }",
          "new_line_content": "      if (!(quick= best_trp->make_quick(&param, TRUE)) || quick->init())",
          "content_same": false
        },
        {
          "line": 6556,
          "old_api": null,
          "new_api": "remove_nonrange_trees",
          "old_text": null,
          "new_text": "remove_nonrange_trees(param, tree2)",
          "old_line_content": "",
          "new_line_content": "      if (param->remove_jump_scans && remove_nonrange_trees(param, tree2))",
          "content_same": false
        },
        {
          "line": 6557,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(new SEL_TREE(SEL_TREE::ALWAYS))",
          "old_line_content": "",
          "new_line_content": "         DBUG_RETURN(new SEL_TREE(SEL_TREE::ALWAYS));",
          "content_same": false
        },
        {
          "line": 6559,
          "old_api": null,
          "new_api": "imerge_list_or_tree",
          "old_text": null,
          "new_text": "imerge_list_or_tree(param, &tree1->merges, tree2)",
          "old_line_content": "",
          "new_line_content": "      if (imerge_list_or_tree(param, &tree1->merges, tree2))",
          "content_same": false
        },
        {
          "line": 10657,
          "old_api": null,
          "new_api": "get_quick_select",
          "old_text": null,
          "new_text": "get_quick_select(param, param_idx,\n                                                   index_tree,\n                                                   &quick->alloc)",
          "old_line_content": "      SEL_ARG *min_max_range= index_tree;",
          "new_line_content": "      quick->quick_prefix_select= get_quick_select(param, param_idx,",
          "content_same": false
        },
        {
          "line": 4515,
          "old_api": null,
          "new_api": "rows2double",
          "old_text": null,
          "new_text": "rows2double(info->param->table->quick_rows[scan->keynr])",
          "old_line_content": "  Check if adding a ROR scan to a ROR-intersection reduces its cost of",
          "new_line_content": "    double tmp= rows2double(info->param->table->quick_rows[scan->keynr]) /",
          "content_same": false
        },
        {
          "line": 8612,
          "old_api": null,
          "new_api": "unlock_row",
          "old_text": null,
          "new_text": "quick_with_last_rowid->file->unlock_row()",
          "old_line_content": "      else",
          "new_line_content": "                quick_with_last_rowid->file->unlock_row();",
          "content_same": false
        },
        {
          "line": 8613,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(error)",
          "old_line_content": "      {",
          "new_line_content": "              DBUG_RETURN(error);",
          "content_same": false
        },
        {
          "line": 4516,
          "old_api": null,
          "new_api": "rows2double",
          "old_text": null,
          "new_text": "rows2double(prev_records)",
          "old_line_content": "  ROR-intersection and if yes, update parameters of ROR-intersection,",
          "new_line_content": "                rows2double(prev_records);",
          "content_same": false
        },
        {
          "line": 4517,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"Selectivity multiplier: %g\", tmp))",
          "old_line_content": "  including its cost.",
          "new_line_content": "    DBUG_PRINT(\"info\", (\"Selectivity multiplier: %g\", tmp));",
          "content_same": false
        },
        {
          "line": 8616,
          "old_api": null,
          "new_api": "position",
          "old_text": null,
          "new_text": "quick->file->position(quick->record)",
          "old_line_content": "      }",
          "new_line_content": "          quick->file->position(quick->record);",
          "content_same": false
        },
        {
          "line": 4520,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"Returning multiplier: %g\", selectivity_mult))",
          "old_line_content": "    ror_intersect_add()",
          "new_line_content": "  DBUG_PRINT(\"info\", (\"Returning multiplier: %g\", selectivity_mult));",
          "content_same": false
        },
        {
          "line": 8618,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(last_rowid, quick->file->ref, head->file->ref_length)",
          "old_line_content": "",
          "new_line_content": "        memcpy(last_rowid, quick->file->ref, head->file->ref_length);",
          "content_same": false
        },
        {
          "line": 8619,
          "old_api": null,
          "new_api": "unlock_row",
          "old_text": null,
          "new_text": "quick_with_last_rowid->file->unlock_row()",
          "old_line_content": "    /* We get here if we got the same row ref in all scans. */",
          "new_line_content": "        quick_with_last_rowid->file->unlock_row();",
          "content_same": false
        },
        {
          "line": 2474,
          "old_api": null,
          "new_api": "print_quick",
          "old_text": null,
          "new_text": "print_quick(quick, &needed_reg)",
          "old_line_content": " ****************************************************************************/",
          "new_line_content": "  DBUG_EXECUTE(\"info\", print_quick(quick, &needed_reg););",
          "content_same": false
        },
        {
          "line": 4521,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(selectivity_mult)",
          "old_line_content": "      param        Parameter from test_quick_select",
          "new_line_content": "  DBUG_RETURN(selectivity_mult);",
          "content_same": false
        },
        {
          "line": 6565,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "  ulong use_count=key1->use_count;",
          "new_line_content": "  DBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 10671,
          "old_api": null,
          "new_api": "eq",
          "old_text": null,
          "new_text": "min_max_range->field->eq(min_max_arg_part->field)",
          "old_line_content": "        {",
          "new_line_content": "        if (min_max_range->field->eq(min_max_arg_part->field))",
          "content_same": false
        },
        {
          "line": 2480,
          "old_api": null,
          "new_api": "test",
          "old_text": null,
          "new_text": "test(quick)",
          "old_line_content": "  This part of the code does partition pruning. Partition pruning solves the",
          "new_line_content": "  DBUG_RETURN(records ? test(quick) : -1);",
          "content_same": false
        },
        {
          "line": 8632,
          "old_api": null,
          "new_api": "rnd_pos",
          "old_text": null,
          "new_text": "head->file->rnd_pos(head->record[0], last_rowid)",
          "old_line_content": "  NOTES",
          "new_line_content": "      error= head->file->rnd_pos(head->record[0], last_rowid);",
          "content_same": false
        },
        {
          "line": 10681,
          "old_api": null,
          "new_api": "add_range",
          "old_text": null,
          "new_text": "quick->add_range(min_max_range)",
          "old_line_content": "    quick->quick_prefix_select= NULL;",
          "new_line_content": "        if (quick->add_range(min_max_range))",
          "content_same": false
        },
        {
          "line": 8634,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(error)",
          "old_line_content": "    For each quick select in the queue a {key,rowid} tuple has been",
          "new_line_content": "  DBUG_RETURN(error);",
          "content_same": false
        },
        {
          "line": 6588,
          "old_api": null,
          "new_api": "first",
          "old_text": null,
          "new_text": "key1->first()",
          "old_line_content": "      if (use_count)",
          "new_line_content": "  for (next=key1->first(); next ; next=next->next)",
          "content_same": false
        },
        {
          "line": 10685,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "",
          "new_line_content": "          DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 6592,
          "old_api": null,
          "new_api": "key_and",
          "old_text": null,
          "new_text": "key_and(param, next->next_key_part, key2, clone_flag)",
          "old_line_content": "    }",
          "new_line_content": "      SEL_ARG *tmp= key_and(param, next->next_key_part, key2, clone_flag);",
          "content_same": false
        },
        {
          "line": 6595,
          "old_api": null,
          "new_api": "tree_delete",
          "old_text": null,
          "new_text": "key1->tree_delete(next)",
          "old_line_content": "  }",
          "new_line_content": "\tkey1=key1->tree_delete(next);",
          "content_same": false
        },
        {
          "line": 10694,
          "old_api": null,
          "new_api": "update_key_stat",
          "old_text": null,
          "new_text": "quick->update_key_stat()",
          "old_line_content": "    QUICK_GROUP_MIN_MAX_SELECT::QUICK_GROUP_MIN_MAX_SELECT()",
          "new_line_content": "  quick->update_key_stat();",
          "content_same": false
        },
        {
          "line": 10695,
          "old_api": null,
          "new_api": "adjust_prefix_ranges",
          "old_text": null,
          "new_text": "quick->adjust_prefix_ranges()",
          "old_line_content": "    table             The table being accessed",
          "new_line_content": "  quick->adjust_prefix_ranges();",
          "content_same": false
        },
        {
          "line": 6600,
          "old_api": null,
          "new_api": "increment_use_count",
          "old_text": null,
          "new_text": "next->increment_use_count(use_count)",
          "old_line_content": "}",
          "new_line_content": "\tnext->increment_use_count(use_count);",
          "content_same": false
        },
        {
          "line": 10697,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(quick)",
          "old_line_content": "    have_min          TRUE if the query selects a MIN function",
          "new_line_content": "  DBUG_RETURN(quick);",
          "content_same": false
        },
        {
          "line": 4567,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"Current out_rows= %g\", info->out_rows))",
          "old_line_content": "  }",
          "new_line_content": "  DBUG_PRINT(\"info\", (\"Current out_rows= %g\", info->out_rows));",
          "content_same": false
        },
        {
          "line": 4568,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"Adding scan on %s\",\n                      info->param->table->key_info[ror_scan->keynr].name))",
          "old_line_content": "  ",
          "new_line_content": "  DBUG_PRINT(\"info\", (\"Adding scan on %s\",",
          "content_same": false
        },
        {
          "line": 4570,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"is_cpk_scan: %d\",is_cpk_scan))",
          "old_line_content": "  ",
          "new_line_content": "  DBUG_PRINT(\"info\", (\"is_cpk_scan: %d\",is_cpk_scan));",
          "content_same": false
        },
        {
          "line": 8668,
          "old_api": null,
          "new_api": "queue_top",
          "old_text": null,
          "new_text": "queue_top(&queue)",
          "old_line_content": "      {",
          "new_line_content": "      quick= (QUICK_SELECT_I*)queue_top(&queue);",
          "content_same": false
        },
        {
          "line": 4572,
          "old_api": null,
          "new_api": "ror_scan_selectivity",
          "old_text": null,
          "new_text": "ror_scan_selectivity(info, ror_scan)",
          "old_line_content": "  {",
          "new_line_content": "  selectivity_mult = ror_scan_selectivity(info, ror_scan);",
          "content_same": false
        },
        {
          "line": 7829,
          "old_api": null,
          "new_api": "store_max_key",
          "old_text": null,
          "new_text": "key_tree->next_key_part->store_max_key(param->key[idx],\n                                             &tmp_max_key,\n                                             &tmp_max_flag,\n                                             MAX_KEY)",
          "old_line_content": "  }",
          "new_line_content": "      key_tree->next_key_part->store_max_key(param->key[idx],",
          "content_same": false
        },
        {
          "line": 8672,
          "old_api": null,
          "new_api": "get_next",
          "old_text": null,
          "new_text": "quick->get_next()",
          "old_line_content": "",
          "new_line_content": "      if ((error= quick->get_next()))",
          "content_same": false
        },
        {
          "line": 4576,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"The scan doesn't improve selectivity.\"))",
          "old_line_content": "      per check this gives us:",
          "new_line_content": "    DBUG_PRINT(\"info\", (\"The scan doesn't improve selectivity.\"));",
          "content_same": false
        },
        {
          "line": 4577,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(FALSE)",
          "old_line_content": "    */",
          "new_line_content": "    DBUG_RETURN(FALSE);",
          "content_same": false
        },
        {
          "line": 8675,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(error)",
          "old_line_content": "        /* No rows have been returned yet */",
          "new_line_content": "          DBUG_RETURN(error);",
          "content_same": false
        },
        {
          "line": 8676,
          "old_api": null,
          "new_api": "queue_remove",
          "old_text": null,
          "new_text": "queue_remove(&queue, 0)",
          "old_line_content": "        dup_row= FALSE;",
          "new_line_content": "        queue_remove(&queue, 0);",
          "content_same": false
        },
        {
          "line": 8681,
          "old_api": null,
          "new_api": "queue_replaced",
          "old_text": null,
          "new_text": "queue_replaced(&queue)",
          "old_line_content": "    } while (dup_row);",
          "new_line_content": "        queue_replaced(&queue);",
          "content_same": false
        },
        {
          "line": 6641,
          "old_api": null,
          "new_api": "swap_clone_flag",
          "old_text": null,
          "new_text": "swap_clone_flag(clone_flag)",
          "old_line_content": "       !(clone_flag & CLONE_KEY1_MAYBE) &&",
          "new_line_content": "      clone_flag=swap_clone_flag(clone_flag);",
          "content_same": false
        },
        {
          "line": 7833,
          "old_api": null,
          "new_api": "uint) (tmp_min_key - param->min_key)",
          "old_text": null,
          "new_text": "uint) (tmp_min_key - param->min_key)",
          "old_line_content": "",
          "new_line_content": "    min_key_length= (uint) (tmp_min_key - param->min_key);",
          "content_same": false
        },
        {
          "line": 8691,
          "old_api": null,
          "new_api": "cmp_ref",
          "old_text": null,
          "new_text": "head->file->cmp_ref(cur_rowid, prev_rowid)",
          "old_line_content": "",
          "new_line_content": "        dup_row= !head->file->cmp_ref(cur_rowid, prev_rowid);",
          "content_same": false
        },
        {
          "line": 4596,
          "old_api": null,
          "new_api": "bitmap_union",
          "old_text": null,
          "new_text": "bitmap_union(&info->covered_fields, &ror_scan->covered_fields)",
          "old_line_content": "  if (!info->is_covering)",
          "new_line_content": "    bitmap_union(&info->covered_fields, &ror_scan->covered_fields);",
          "content_same": false
        },
        {
          "line": 4597,
          "old_api": null,
          "new_api": "bitmap_is_subset",
          "old_text": null,
          "new_text": "bitmap_is_subset(&info->param->needed_fields,\n                                               &info->covered_fields)",
          "old_line_content": "  {",
          "new_line_content": "    if (!info->is_covering && bitmap_is_subset(&info->param->needed_fields,",
          "content_same": false
        },
        {
          "line": 7834,
          "old_api": null,
          "new_api": "uint) (tmp_max_key - param->max_key)",
          "old_text": null,
          "new_text": "uint) (tmp_max_key - param->max_key)",
          "old_line_content": "  keynr=param->real_keynr[idx];",
          "new_line_content": "    max_key_length= (uint) (tmp_max_key - param->max_key);",
          "content_same": false
        },
        {
          "line": 6648,
          "old_api": null,
          "new_api": "and_all_keys",
          "old_text": null,
          "new_text": "and_all_keys(param, key1, key2, clone_flag)",
          "old_line_content": "",
          "new_line_content": "    return and_all_keys(param, key1, key2, clone_flag);",
          "content_same": false
        },
        {
          "line": 8698,
          "old_api": null,
          "new_api": "rnd_pos",
          "old_text": null,
          "new_text": "head->file->rnd_pos(quick->record, prev_rowid)",
          "old_line_content": "  next=0;",
          "new_line_content": "    error= head->file->rnd_pos(quick->record, prev_rowid);",
          "content_same": false
        },
        {
          "line": 8700,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(error)",
          "old_line_content": "  in_range= FALSE;",
          "new_line_content": "  DBUG_RETURN(error);",
          "content_same": false
        },
        {
          "line": 4606,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"info->total_cost: %g\", info->total_cost))",
          "old_line_content": "}",
          "new_line_content": "  DBUG_PRINT(\"info\", (\"info->total_cost: %g\", info->total_cost));",
          "content_same": false
        },
        {
          "line": 6657,
          "old_api": null,
          "new_api": "swap_clone_flag",
          "old_text": null,
          "new_text": "swap_clone_flag(clone_flag)",
          "old_line_content": "      key1->use_count++;",
          "new_line_content": "    clone_flag=swap_clone_flag(clone_flag);",
          "content_same": false
        },
        {
          "line": 4610,
          "old_api": null,
          "new_api": "double2rows",
          "old_text": null,
          "new_text": "double2rows(info->out_rows)",
          "old_line_content": "  Get best ROR-intersection plan using non-covering ROR-intersection search",
          "new_line_content": "      get_sweep_read_cost(info->param, double2rows(info->out_rows));",
          "content_same": false
        },
        {
          "line": 4611,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"info->total_cost= %g\", info->total_cost))",
          "old_line_content": "  algorithm. The returned plan may be covering.",
          "new_line_content": "    DBUG_PRINT(\"info\", (\"info->total_cost= %g\", info->total_cost));",
          "content_same": false
        },
        {
          "line": 4613,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"New out_rows: %g\", info->out_rows))",
          "old_line_content": "  SYNOPSIS",
          "new_line_content": "  DBUG_PRINT(\"info\", (\"New out_rows: %g\", info->out_rows));",
          "content_same": false
        },
        {
          "line": 4614,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"New cost: %g, %scovering\", info->total_cost,\n                      info->is_covering?\"\" : \"non-\"))",
          "old_line_content": "    get_best_ror_intersect()",
          "new_line_content": "  DBUG_PRINT(\"info\", (\"New cost: %g, %scovering\", info->total_cost,",
          "content_same": false
        },
        {
          "line": 4616,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(TRUE)",
          "old_line_content": "      tree             Transformed restriction condition to be used to look",
          "new_line_content": "  DBUG_RETURN(TRUE);",
          "content_same": false
        },
        {
          "line": 6666,
          "old_api": null,
          "new_api": "clone_tree",
          "old_text": null,
          "new_text": "key1->clone_tree(param)",
          "old_line_content": "    }",
          "new_line_content": "      if (!(key1=key1->clone_tree(param)))",
          "content_same": false
        },
        {
          "line": 10763,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(!parent_alloc)",
          "old_line_content": "/*",
          "new_line_content": "  DBUG_ASSERT(!parent_alloc);",
          "content_same": false
        },
        {
          "line": 8717,
          "old_api": null,
          "new_api": "column_bitmaps_set_no_signal",
          "old_text": null,
          "new_text": "head->column_bitmaps_set_no_signal(&column_bitmap, &column_bitmap)",
          "old_line_content": "  /* Do not allocate the buffers twice. */",
          "new_line_content": "      head->column_bitmaps_set_no_signal(&column_bitmap, &column_bitmap);",
          "content_same": false
        },
        {
          "line": 10766,
          "old_api": null,
          "new_api": "init_sql_alloc",
          "old_text": null,
          "new_text": "init_sql_alloc(&alloc, join->thd->variables.range_alloc_block_size, 0)",
          "old_line_content": "  SYNOPSIS",
          "new_line_content": "    init_sql_alloc(&alloc, join->thd->variables.range_alloc_block_size, 0);",
          "content_same": false
        },
        {
          "line": 8719,
          "old_api": null,
          "new_api": "DBUG_EXECUTE_IF",
          "old_text": null,
          "new_text": "DBUG_EXECUTE_IF(\"bug14365043_2\",\n                    DBUG_SET(\"+d,ha_index_init_fail\");)",
          "old_line_content": "  {",
          "new_line_content": "    DBUG_EXECUTE_IF(\"bug14365043_2\",",
          "content_same": false
        },
        {
          "line": 6672,
          "old_api": null,
          "new_api": "key_and",
          "old_text": null,
          "new_text": "key_and(param, key1->next_key_part, \n                                  key2->next_key_part, clone_flag)",
          "old_line_content": "\tkey1->use_count--;\t\t\t// Incremented in and_all_keys",
          "new_line_content": "      key1->next_key_part=key_and(param, key1->next_key_part, ",
          "content_same": false
        },
        {
          "line": 10770,
          "old_api": null,
          "new_api": "bzero",
          "old_text": null,
          "new_text": "bzero(&alloc, sizeof(MEM_ROOT))",
          "old_line_content": "    The method performs initialization that cannot be done in the constructor",
          "new_line_content": "    bzero(&alloc, sizeof(MEM_ROOT));            // ensure that it's not used",
          "content_same": false
        },
        {
          "line": 8723,
          "old_api": null,
          "new_api": "MYF",
          "old_text": null,
          "new_text": "MYF(0)",
          "old_line_content": "",
          "new_line_content": "        file->print_error(error, MYF(0));",
          "content_same": false
        },
        {
          "line": 8724,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(error)",
          "old_line_content": "  /* Allocate the ranges array. */",
          "new_line_content": "        DBUG_RETURN(error);",
          "content_same": false
        },
        {
          "line": 6680,
          "old_api": null,
          "new_api": "maybe_smaller",
          "old_text": null,
          "new_text": "key1->maybe_smaller()",
          "old_line_content": "  if ((key1->min_flag | key2->min_flag) & GEOM_FLAG)",
          "new_line_content": "      key1->maybe_smaller();",
          "content_same": false
        },
        {
          "line": 8732,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "  {",
          "new_line_content": "    DBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 8736,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(ranges.elements)",
          "old_line_content": "  if (! multi_range)",
          "new_line_content": "  DBUG_ASSERT(ranges.elements);",
          "content_same": false
        },
        {
          "line": 8737,
          "old_api": null,
          "new_api": "min",
          "old_text": null,
          "new_text": "min(multi_range_count, ranges.elements)",
          "old_line_content": "  {",
          "new_line_content": "  multi_range_length= min(multi_range_count, ranges.elements);",
          "content_same": false
        },
        {
          "line": 8738,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(multi_range_length > 0)",
          "old_line_content": "    multi_range_length= 0;",
          "new_line_content": "  DBUG_ASSERT(multi_range_length > 0);",
          "content_same": false
        },
        {
          "line": 7842,
          "old_api": null,
          "new_api": "unlikely",
          "old_text": null,
          "new_text": "unlikely(param->thd->killed != 0)",
          "old_line_content": "  {",
          "new_line_content": "  if (unlikely(param->thd->killed != 0))",
          "content_same": false
        },
        {
          "line": 8740,
          "old_api": null,
          "new_api": "my_malloc",
          "old_text": null,
          "new_text": "my_malloc(multi_range_length *\n                                            sizeof(KEY_MULTI_RANGE),\n                                            MYF(MY_WME))",
          "old_line_content": "  }",
          "new_line_content": "                                  my_malloc(multi_range_length *",
          "content_same": false
        },
        {
          "line": 8742,
          "old_api": null,
          "new_api": "MYF",
          "old_text": null,
          "new_text": "MYF(MY_WME)",
          "old_line_content": "  /* Allocate the handler buffer if necessary.  */",
          "new_line_content": "                                            MYF(MY_WME))))",
          "content_same": false
        },
        {
          "line": 6695,
          "old_api": null,
          "new_api": "free_tree",
          "old_text": null,
          "new_text": "key2->free_tree()",
          "old_line_content": "    if (cmp < 0)",
          "new_line_content": "    key2->free_tree();",
          "content_same": false
        },
        {
          "line": 10796,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(&alloc, group_prefix_len)",
          "old_line_content": "  {",
          "new_line_content": "  if (!(last_prefix= (uchar*) alloc_root(&alloc, group_prefix_len)))",
          "content_same": false
        },
        {
          "line": 6701,
          "old_api": null,
          "new_api": "first",
          "old_text": null,
          "new_text": "key2->first()",
          "old_line_content": "      continue;",
          "new_line_content": "  SEL_ARG *e1=key1->first(), *e2=key2->first(), *new_tree=0;",
          "content_same": false
        },
        {
          "line": 8750,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(HA_ERR_OUT_OF_MEM)",
          "old_line_content": "                             &multi_range_buff,",
          "new_line_content": "    DBUG_RETURN(HA_ERR_OUT_OF_MEM);",
          "content_same": false
        },
        {
          "line": 8754,
          "old_api": null,
          "new_api": "ha_table_flags",
          "old_text": null,
          "new_text": "file->ha_table_flags()",
          "old_line_content": "    {",
          "new_line_content": "  if (file->ha_table_flags() & HA_NEED_READ_RANGE_BUFFER)",
          "content_same": false
        },
        {
          "line": 10802,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(&alloc,\n                                         real_prefix_len + min_max_arg_len)",
          "old_line_content": "    if (!tmp_key_infix)",
          "new_line_content": "  if (!(group_prefix= (uchar*) alloc_root(&alloc,",
          "content_same": false
        },
        {
          "line": 8756,
          "old_api": null,
          "new_api": "min",
          "old_text": null,
          "new_text": "min(multi_range_bufsiz,\n                       ((uint)QUICK_SELECT_I::records + 1)* head->s->reclength)",
          "old_line_content": "      mrange_bufsiz/= 2;",
          "new_line_content": "    mrange_bufsiz= min(multi_range_bufsiz,",
          "content_same": false
        },
        {
          "line": 6711,
          "old_api": null,
          "new_api": "get_range",
          "old_text": null,
          "new_text": "get_range(&e2,&e1,key2)",
          "old_line_content": "      new_arg->next_key_part=next;",
          "new_line_content": "    else if (get_range(&e2,&e1,key2))",
          "content_same": false
        },
        {
          "line": 6713,
          "old_api": null,
          "new_api": "key_and",
          "old_text": null,
          "new_text": "key_and(param, e1->next_key_part, e2->next_key_part,\n                          clone_flag)",
          "old_line_content": "      {",
          "new_line_content": "    SEL_ARG *next=key_and(param, e1->next_key_part, e2->next_key_part,",
          "content_same": false
        },
        {
          "line": 6715,
          "old_api": null,
          "new_api": "increment_use_count",
          "old_text": null,
          "new_text": "e1->increment_use_count(1)",
          "old_line_content": "      }",
          "new_line_content": "    e1->increment_use_count(1);",
          "content_same": false
        },
        {
          "line": 10812,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(&alloc, key_infix_len)",
          "old_line_content": "",
          "new_line_content": "    uchar *tmp_key_infix= (uchar*) alloc_root(&alloc, key_infix_len);",
          "content_same": false
        },
        {
          "line": 6716,
          "old_api": null,
          "new_api": "increment_use_count",
          "old_text": null,
          "new_text": "e2->increment_use_count(1)",
          "old_line_content": "      else",
          "new_line_content": "    e2->increment_use_count(1);",
          "content_same": false
        },
        {
          "line": 10815,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(tmp_key_infix, this->key_infix, key_infix_len)",
          "old_line_content": "      if (!(min_functions= new List<Item_sum>))",
          "new_line_content": "    memcpy(tmp_key_infix, this->key_infix, key_infix_len);",
          "content_same": false
        },
        {
          "line": 8771,
          "old_api": null,
          "new_api": "my_free",
          "old_text": null,
          "new_text": "my_free(multi_range)",
          "old_line_content": "    /*",
          "new_line_content": "      my_free(multi_range);",
          "content_same": false
        },
        {
          "line": 10821,
          "old_api": null,
          "new_api": "my_init_dynamic_array",
          "old_text": null,
          "new_text": "my_init_dynamic_array(&min_max_ranges, sizeof(QUICK_RANGE*), 16, 16)",
          "old_line_content": "    {",
          "new_line_content": "    if (my_init_dynamic_array(&min_max_ranges, sizeof(QUICK_RANGE*), 16, 16))",
          "content_same": false
        },
        {
          "line": 8774,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(HA_ERR_OUT_OF_MEM)",
          "old_line_content": "      which gives us valgrind warnings in compare_record[])",
          "new_line_content": "      DBUG_RETURN(HA_ERR_OUT_OF_MEM);",
          "content_same": false
        },
        {
          "line": 6728,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "new_tree->insert(new_arg)",
          "old_line_content": "  return new_tree;",
          "new_line_content": "\tnew_tree=new_tree->insert(new_arg);",
          "content_same": false
        },
        {
          "line": 5815,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"get_mm_parts\")",
          "old_line_content": "  {",
          "new_line_content": "  DBUG_ENTER(\"get_mm_parts\");",
          "content_same": false
        },
        {
          "line": 6730,
          "old_api": null,
          "new_api": "cmp_max_to_max",
          "old_text": null,
          "new_text": "e1->cmp_max_to_max(e2)",
          "old_line_content": "",
          "new_line_content": "    if (e1->cmp_max_to_max(e2) < 0)",
          "content_same": false
        },
        {
          "line": 8787,
          "old_api": null,
          "new_api": "bzero",
          "old_text": null,
          "new_text": "bzero((char*) mrange_buff, mrange_bufsiz)",
          "old_line_content": "    QUICK_RANGE_SELECT::get_next()",
          "new_line_content": "    bzero((char*) mrange_buff, mrange_bufsiz);",
          "content_same": false
        },
        {
          "line": 4691,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"get_best_ror_intersect\")",
          "old_line_content": "  ROR_SCAN_INFO *cpk_scan= NULL;",
          "new_line_content": "  DBUG_ENTER(\"get_best_ror_intersect\");",
          "content_same": false
        },
        {
          "line": 8790,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "    Record is read into table->record[0]",
          "new_line_content": "  DBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 4694,
          "old_api": null,
          "new_api": "optimizer_flag",
          "old_text": null,
          "new_text": "optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_INTERSECT)",
          "old_line_content": "",
          "new_line_content": "      !optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_INTERSECT))",
          "content_same": false
        },
        {
          "line": 6746,
          "old_api": null,
          "new_api": "find_range",
          "old_text": null,
          "new_text": "root1->find_range(*e2)",
          "old_line_content": "  return 0;",
          "new_line_content": "  (*e1)=root1->find_range(*e2);\t\t\t// first e1->min < e2->min",
          "content_same": false
        },
        {
          "line": 10843,
          "old_api": null,
          "new_api": "sum_func",
          "old_text": null,
          "new_text": "min_max_item->sum_func()",
          "old_line_content": "",
          "new_line_content": "      if (have_min && (min_max_item->sum_func() == Item_sum::MIN_FUNC))",
          "content_same": false
        },
        {
          "line": 10844,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "min_functions->push_back(min_max_item)",
          "old_line_content": "    if (have_max)",
          "new_line_content": "        min_functions->push_back(min_max_item);",
          "content_same": false
        },
        {
          "line": 10845,
          "old_api": null,
          "new_api": "sum_func",
          "old_text": null,
          "new_text": "min_max_item->sum_func()",
          "old_line_content": "    {",
          "new_line_content": "      else if (have_max && (min_max_item->sum_func() == Item_sum::MAX_FUNC))",
          "content_same": false
        },
        {
          "line": 10846,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "max_functions->push_back(min_max_item)",
          "old_line_content": "      if (!(max_functions_it= new List_iterator<Item_sum>(*max_functions)))",
          "new_line_content": "        max_functions->push_back(min_max_item);",
          "content_same": false
        },
        {
          "line": 6747,
          "old_api": null,
          "new_api": "cmp_max_to_min",
          "old_text": null,
          "new_text": "*e1)->cmp_max_to_min(*e2)",
          "old_line_content": "}",
          "new_line_content": "  if ((*e1)->cmp_max_to_min(*e2) < 0)",
          "content_same": false
        },
        {
          "line": 6751,
          "old_api": null,
          "new_api": "cmp_min_to_max",
          "old_text": null,
          "new_text": "*e1)->cmp_min_to_max(*e2)",
          "old_line_content": "   Combine two range expression under a common OR. On a logical level, the",
          "new_line_content": "    if ((*e1)->cmp_min_to_max(*e2) > 0)",
          "content_same": false
        },
        {
          "line": 4706,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(param->mem_root,\n                                                     sizeof(ROR_SCAN_INFO*)*\n                                                     param->keys)",
          "old_line_content": "      continue;",
          "new_line_content": "  if (!(tree->ror_scans= (ROR_SCAN_INFO**)alloc_root(param->mem_root,",
          "content_same": false
        },
        {
          "line": 4710,
          "old_api": null,
          "new_api": "primary_key_is_clustered",
          "old_text": null,
          "new_text": "param->table->file->primary_key_is_clustered()",
          "old_line_content": "    {",
          "new_line_content": "  cpk_no= ((param->table->file->primary_key_is_clustered()) ?",
          "content_same": false
        },
        {
          "line": 4716,
          "old_api": null,
          "new_api": "is_set",
          "old_text": null,
          "new_text": "tree->ror_scans_map.is_set(idx)",
          "old_line_content": "  }",
          "new_line_content": "    if (!tree->ror_scans_map.is_set(idx))",
          "content_same": false
        },
        {
          "line": 8814,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(multi_range_length && multi_range &&\n              (cur_range >= (QUICK_RANGE**) ranges.buffer) &&\n              (cur_range <= (QUICK_RANGE**) ranges.buffer + ranges.elements))",
          "old_line_content": "  }",
          "new_line_content": "  DBUG_ASSERT(multi_range_length && multi_range &&",
          "content_same": false
        },
        {
          "line": 4718,
          "old_api": null,
          "new_api": "make_ror_scan",
          "old_text": null,
          "new_text": "make_ror_scan(param, idx, tree->keys[idx])",
          "old_line_content": "  tree->ror_scans_end= cur_ror_scan;",
          "new_line_content": "    if (!(scan= make_ror_scan(param, idx, tree->keys[idx])))",
          "content_same": false
        },
        {
          "line": 10870,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::~QUICK_GROUP_MIN_MAX_SELECT\")",
          "old_line_content": "",
          "new_line_content": "  DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::~QUICK_GROUP_MIN_MAX_SELECT\");",
          "content_same": false
        },
        {
          "line": 8824,
          "old_api": null,
          "new_api": "column_bitmaps_set_no_signal",
          "old_text": null,
          "new_text": "head->column_bitmaps_set_no_signal(&column_bitmap, &column_bitmap)",
          "old_line_content": "    }",
          "new_line_content": "    head->column_bitmaps_set_no_signal(&column_bitmap, &column_bitmap);",
          "content_same": false
        },
        {
          "line": 10872,
          "old_api": null,
          "new_api": "ha_index_end",
          "old_text": null,
          "new_text": "file->ha_index_end()",
          "old_line_content": "/*",
          "new_line_content": "    file->ha_index_end();",
          "content_same": false
        },
        {
          "line": 10874,
          "old_api": null,
          "new_api": "delete_dynamic",
          "old_text": null,
          "new_text": "delete_dynamic(&min_max_ranges)",
          "old_line_content": "",
          "new_line_content": "    delete_dynamic(&min_max_ranges);",
          "content_same": false
        },
        {
          "line": 10875,
          "old_api": null,
          "new_api": "MYF",
          "old_text": null,
          "new_text": "MYF(0)",
          "old_line_content": "  SYNOPSIS",
          "new_line_content": "  free_root(&alloc,MYF(0));",
          "content_same": false
        },
        {
          "line": 4730,
          "old_api": null,
          "new_api": "print_ror_scans_arr",
          "old_text": null,
          "new_text": "print_ror_scans_arr(param->table, \"original\",\n                                          tree->ror_scans,\n                                          tree->ror_scans_end)",
          "old_line_content": "                                          tree->ror_scans,",
          "new_line_content": "  DBUG_EXECUTE(\"info\",print_ror_scans_arr(param->table, \"original\",",
          "content_same": false
        },
        {
          "line": 2687,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"prune_partitions\")",
          "old_line_content": "  PART_PRUNE_PARAM prune_param;",
          "new_line_content": "  DBUG_ENTER(\"prune_partitions\");",
          "content_same": false
        },
        {
          "line": 8832,
          "old_api": null,
          "new_api": "read_multi_range_next",
          "old_text": null,
          "new_text": "file->read_multi_range_next(&mrange)",
          "old_line_content": "      if (in_ror_merged_scan)",
          "new_line_content": "      result= file->read_multi_range_next(&mrange);",
          "content_same": false
        },
        {
          "line": 2690,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(FALSE)",
          "old_line_content": "  my_bitmap_map *old_sets[2];",
          "new_line_content": "    DBUG_RETURN(FALSE); /* not a partitioned table */",
          "content_same": false
        },
        {
          "line": 4738,
          "old_api": null,
          "new_api": "my_qsort",
          "old_text": null,
          "new_text": "my_qsort(tree->ror_scans, tree->n_ror_scans, sizeof(ROR_SCAN_INFO*),\n           (qsort_cmp)cmp_ror_scan_info)",
          "old_line_content": "    return NULL;",
          "new_line_content": "  my_qsort(tree->ror_scans, tree->n_ror_scans, sizeof(ROR_SCAN_INFO*),",
          "content_same": false
        },
        {
          "line": 4740,
          "old_api": null,
          "new_api": "print_ror_scans_arr",
          "old_text": null,
          "new_text": "print_ror_scans_arr(param->table, \"ordered\",\n                                          tree->ror_scans,\n                                          tree->ror_scans_end)",
          "old_line_content": "",
          "new_line_content": "  DBUG_EXECUTE(\"info\",print_ror_scans_arr(param->table, \"ordered\",",
          "content_same": false
        },
        {
          "line": 8837,
          "old_api": null,
          "new_api": "min",
          "old_text": null,
          "new_text": "min(multi_range_length, ranges.elements -\n                    (cur_range - (QUICK_RANGE**) ranges.buffer))",
          "old_line_content": "    for (mrange_slot= multi_range, mrange_end= mrange_slot+count;",
          "new_line_content": "    uint count= min(multi_range_length, ranges.elements -",
          "content_same": false
        },
        {
          "line": 2694,
          "old_api": null,
          "new_api": "mark_all_partitions_as_used",
          "old_text": null,
          "new_text": "mark_all_partitions_as_used(part_info)",
          "old_line_content": "  range_par->mem_root= &alloc;",
          "new_line_content": "    mark_all_partitions_as_used(part_info);",
          "content_same": false
        },
        {
          "line": 2695,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(FALSE)",
          "old_line_content": "  range_par->old_root= thd->mem_root;",
          "new_line_content": "    DBUG_RETURN(FALSE);",
          "content_same": false
        },
        {
          "line": 4746,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(param->mem_root,\n                                                     sizeof(ROR_SCAN_INFO*)*\n                                                     tree->n_ror_scans)",
          "old_line_content": "",
          "new_line_content": "  if (!(intersect_scans= (ROR_SCAN_INFO**)alloc_root(param->mem_root,",
          "content_same": false
        },
        {
          "line": 8844,
          "old_api": null,
          "new_api": "column_bitmaps_set_no_signal",
          "old_text": null,
          "new_text": "head->column_bitmaps_set_no_signal(save_read_set, save_write_set)",
          "old_line_content": "      mrange_slot->range_flag= last_range->flag;",
          "new_line_content": "        head->column_bitmaps_set_no_signal(save_read_set, save_write_set);",
          "content_same": false
        },
        {
          "line": 8845,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(HA_ERR_END_OF_FILE)",
          "old_line_content": "    }",
          "new_line_content": "      DBUG_RETURN(HA_ERR_END_OF_FILE);",
          "content_same": false
        },
        {
          "line": 4755,
          "old_api": null,
          "new_api": "ror_intersect_init",
          "old_text": null,
          "new_text": "ror_intersect_init(param)",
          "old_line_content": "    {",
          "new_line_content": "      !(intersect_best= ror_intersect_init(param)))",
          "content_same": false
        },
        {
          "line": 2708,
          "old_api": null,
          "new_api": "create_partition_index_description",
          "old_text": null,
          "new_text": "create_partition_index_description(&prune_param)",
          "old_line_content": "  /* range_par->cond doesn't need initialization */",
          "new_line_content": "  if (create_partition_index_description(&prune_param))",
          "content_same": false
        },
        {
          "line": 8853,
          "old_api": null,
          "new_api": "make_min_endpoint",
          "old_text": null,
          "new_text": "last_range->make_min_endpoint(&mrange_slot->start_key)",
          "old_line_content": "",
          "new_line_content": "      last_range->make_min_endpoint(&mrange_slot->start_key);",
          "content_same": false
        },
        {
          "line": 8854,
          "old_api": null,
          "new_api": "make_max_endpoint",
          "old_text": null,
          "new_text": "last_range->make_max_endpoint(&mrange_slot->end_key)",
          "old_line_content": "end:",
          "new_line_content": "      last_range->make_max_endpoint(&mrange_slot->end_key);",
          "content_same": false
        },
        {
          "line": 2710,
          "old_api": null,
          "new_api": "mark_all_partitions_as_used",
          "old_text": null,
          "new_text": "mark_all_partitions_as_used(part_info)",
          "old_line_content": "  range_par->current_table= table->map;",
          "new_line_content": "    mark_all_partitions_as_used(part_info);",
          "content_same": false
        },
        {
          "line": 2711,
          "old_api": null,
          "new_api": "MYF",
          "old_text": null,
          "new_text": "MYF(0)",
          "old_line_content": "",
          "new_line_content": "    free_root(&alloc,MYF(0));\t\t// Return memory & allocator",
          "content_same": false
        },
        {
          "line": 2712,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(FALSE)",
          "old_line_content": "  range_par->keys= 1; // one index",
          "new_line_content": "    DBUG_RETURN(FALSE);",
          "content_same": false
        },
        {
          "line": 8858,
          "old_api": null,
          "new_api": "read_multi_range_first",
          "old_text": null,
          "new_text": "file->read_multi_range_first(&mrange, multi_range, count,\n                                         sorted, multi_range_buff)",
          "old_line_content": "    /* Restore bitmaps set on entry */",
          "new_line_content": "    result= file->read_multi_range_first(&mrange, multi_range, count,",
          "content_same": false
        },
        {
          "line": 2715,
          "old_api": null,
          "new_api": "dbug_tmp_use_all_columns",
          "old_text": null,
          "new_text": "dbug_tmp_use_all_columns(table, old_sets, \n                           table->read_set, table->write_set)",
          "old_line_content": "  range_par->real_keynr[0]= 0;",
          "new_line_content": "  dbug_tmp_use_all_columns(table, old_sets, ",
          "content_same": false
        },
        {
          "line": 8870,
          "old_api": null,
          "new_api": "column_bitmaps_set_no_signal",
          "old_text": null,
          "new_text": "head->column_bitmaps_set_no_signal(save_read_set, save_write_set)",
          "old_line_content": "",
          "new_line_content": "    head->column_bitmaps_set_no_signal(save_read_set, save_write_set);",
          "content_same": false
        },
        {
          "line": 8872,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "  prefix with length prefix_length and which is different from cur_prefix,",
          "new_line_content": "  DBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 10921,
          "old_api": null,
          "new_api": "make_keypart_map",
          "old_text": null,
          "new_text": "make_keypart_map(sel_range->part)",
          "old_line_content": "",
          "new_line_content": "                         make_keypart_map(sel_range->part),",
          "content_same": false
        },
        {
          "line": 4776,
          "old_api": null,
          "new_api": "ror_intersect_cpy",
          "old_text": null,
          "new_text": "ror_intersect_cpy(intersect_best, intersect)",
          "old_line_content": "    ",
          "new_line_content": "      ror_intersect_cpy(intersect_best, intersect);",
          "content_same": false
        },
        {
          "line": 10923,
          "old_api": null,
          "new_api": "make_keypart_map",
          "old_text": null,
          "new_text": "make_keypart_map(sel_range->part)",
          "old_line_content": "  Opens the ranges if there are more conditions in quick_prefix_select than",
          "new_line_content": "                         make_keypart_map(sel_range->part),",
          "content_same": false
        },
        {
          "line": 2732,
          "old_api": null,
          "new_api": "bitmap_clear_all",
          "old_text": null,
          "new_text": "bitmap_clear_all(&part_info->used_partitions)",
          "old_line_content": "  {",
          "new_line_content": "  bitmap_clear_all(&part_info->used_partitions);",
          "content_same": false
        },
        {
          "line": 6826,
          "old_api": null,
          "new_api": "free_tree",
          "old_text": null,
          "new_text": "key2->free_tree()",
          "old_line_content": "  key2->use_count--;",
          "new_line_content": "      key2->free_tree();",
          "content_same": false
        },
        {
          "line": 10927,
          "old_api": null,
          "new_api": "insert_dynamic",
          "old_text": null,
          "new_text": "insert_dynamic(&min_max_ranges, (uchar*)&range)",
          "old_line_content": "    QUICK_GROUP_MIN_MAX_SELECT::adjust_prefix_ranges()",
          "new_line_content": "  if (insert_dynamic(&min_max_ranges, (uchar*)&range))",
          "content_same": false
        },
        {
          "line": 4785,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 2738,
          "old_api": null,
          "new_api": "get_mm_tree",
          "old_text": null,
          "new_text": "get_mm_tree(range_par, pprune_cond)",
          "old_line_content": "    goto all_used;",
          "new_line_content": "  tree= get_mm_tree(range_par, pprune_cond);",
          "content_same": false
        },
        {
          "line": 6833,
          "old_api": null,
          "new_api": "free_tree",
          "old_text": null,
          "new_text": "key1->free_tree()",
          "old_line_content": "    return 0;\t\t\t\t\t// Can't optimize this",
          "new_line_content": "    key1->free_tree();",
          "content_same": false
        },
        {
          "line": 4788,
          "old_api": null,
          "new_api": "print_ror_scans_arr",
          "old_text": null,
          "new_text": "print_ror_scans_arr(param->table,\n                                          \"best ROR-intersection\",\n                                          intersect_scans,\n                                          intersect_scans_best)",
          "old_line_content": "    Check if we should add a CPK scan. If the obtained ROR-intersection is ",
          "new_line_content": "  DBUG_EXECUTE(\"info\",print_ror_scans_arr(param->table,",
          "content_same": false
        },
        {
          "line": 6842,
          "old_api": null,
          "new_api": "free_tree",
          "old_text": null,
          "new_text": "key1->free_tree()",
          "old_line_content": "  }",
          "new_line_content": "    key1->free_tree();",
          "content_same": false
        },
        {
          "line": 4795,
          "old_api": null,
          "new_api": "ror_intersect_cpy",
          "old_text": null,
          "new_text": "ror_intersect_cpy(intersect, intersect_best)",
          "old_line_content": "    {",
          "new_line_content": "  ror_intersect_cpy(intersect, intersect_best);",
          "content_same": false
        },
        {
          "line": 6843,
          "old_api": null,
          "new_api": "free_tree",
          "old_text": null,
          "new_text": "key2->free_tree()",
          "old_line_content": "  if (key2->type == SEL_ARG::MAYBE_KEY)",
          "new_line_content": "    key2->free_tree();",
          "content_same": false
        },
        {
          "line": 6850,
          "old_api": null,
          "new_api": "free_tree",
          "old_text": null,
          "new_text": "key2->free_tree()",
          "old_line_content": "  if (key1->use_count > 0)",
          "new_line_content": "    key2->free_tree();",
          "content_same": false
        },
        {
          "line": 4804,
          "old_api": null,
          "new_api": "ror_intersect_add",
          "old_text": null,
          "new_text": "ror_intersect_add(intersect, cpk_scan, TRUE)",
          "old_line_content": "  {",
          "new_line_content": "    if (ror_intersect_add(intersect, cpk_scan, TRUE) && ",
          "content_same": false
        },
        {
          "line": 8905,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"QUICK_RANGE_SELECT::get_next_prefix\")",
          "old_line_content": "                                   HA_READ_AFTER_KEY);",
          "new_line_content": "  DBUG_ENTER(\"QUICK_RANGE_SELECT::get_next_prefix\");",
          "content_same": false
        },
        {
          "line": 8906,
          "old_api": null,
          "new_api": "make_prev_keypart_map",
          "old_text": null,
          "new_text": "make_prev_keypart_map(group_key_parts)",
          "old_line_content": "      if (result || last_range->max_keypart_map == 0)",
          "new_line_content": "  const key_part_map keypart_map= make_prev_keypart_map(group_key_parts);",
          "content_same": false
        },
        {
          "line": 2762,
          "old_api": null,
          "new_api": "init_all_partitions_iterator",
          "old_text": null,
          "new_text": "init_all_partitions_iterator(part_info, &prune_param.part_iter)",
          "old_line_content": "        SEL_TREE that represents an expression in form         ",
          "new_line_content": "    init_all_partitions_iterator(part_info, &prune_param.part_iter);",
          "content_same": false
        },
        {
          "line": 2763,
          "old_api": null,
          "new_api": "find_used_partitions",
          "old_text": null,
          "new_text": "find_used_partitions(&prune_param,\n                                                            tree->keys[0])",
          "old_line_content": "          sel_imerge = (tree1 OR tree2 OR ... OR treeN)",
          "new_line_content": "    if (!tree->keys[0] || (-1 == (res= find_used_partitions(&prune_param,",
          "content_same": false
        },
        {
          "line": 4817,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(trp)",
          "old_line_content": "    if (!best_rows)",
          "new_line_content": "      DBUG_RETURN(trp);",
          "content_same": false
        },
        {
          "line": 8914,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(cur_prefix != NULL)",
          "old_line_content": "",
          "new_line_content": "      DBUG_ASSERT(cur_prefix != NULL);",
          "content_same": false
        },
        {
          "line": 8915,
          "old_api": null,
          "new_api": "index_read_map",
          "old_text": null,
          "new_text": "file->index_read_map(record, cur_prefix, keypart_map,\n                                   HA_READ_AFTER_KEY)",
          "old_line_content": "    uint count= ranges.elements - (cur_range - (QUICK_RANGE**) ranges.buffer);",
          "new_line_content": "      result= file->index_read_map(record, cur_prefix, keypart_map,",
          "content_same": false
        },
        {
          "line": 10962,
          "old_api": null,
          "new_api": "get_dynamic",
          "old_text": null,
          "new_text": "get_dynamic(arr, (uchar*)&range, inx)",
          "old_line_content": "  SYNOPSIS",
          "new_line_content": "      get_dynamic(arr, (uchar*)&range, inx);",
          "content_same": false
        },
        {
          "line": 4821,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "    trp->index_scan_costs= intersect_best->index_scan_costs;",
          "new_line_content": "      DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 8918,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "      /* Ranges have already been used up before. None is left for read. */",
          "new_line_content": "        DBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 4822,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(trp->first_scan, intersect_scans, best_num*sizeof(ROR_SCAN_INFO*))",
          "old_line_content": "    trp->cpk_scan= cpk_scan_used? cpk_scan: NULL;",
          "new_line_content": "    memcpy(trp->first_scan, intersect_scans, best_num*sizeof(ROR_SCAN_INFO*));",
          "content_same": false
        },
        {
          "line": 6867,
          "old_api": null,
          "new_api": "clone_tree",
          "old_text": null,
          "new_text": "key1->clone_tree(param)",
          "old_line_content": "    int cmp;",
          "new_line_content": "    if (key1->use_count > 0 || !(key1=key1->clone_tree(param)))",
          "content_same": false
        },
        {
          "line": 8921,
          "old_api": null,
          "new_api": "make_max_endpoint",
          "old_text": null,
          "new_text": "last_range->make_max_endpoint(&previous_endpoint, prefix_length, keypart_map)",
          "old_line_content": "    }",
          "new_line_content": "      last_range->make_max_endpoint(&previous_endpoint, prefix_length, keypart_map);",
          "content_same": false
        },
        {
          "line": 8922,
          "old_api": null,
          "new_api": "compare_key",
          "old_text": null,
          "new_text": "file->compare_key(&previous_endpoint)",
          "old_line_content": "    last_range= *(cur_range++);",
          "new_line_content": "      if (file->compare_key(&previous_endpoint) <= 0)",
          "content_same": false
        },
        {
          "line": 8923,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "",
          "new_line_content": "        DBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 2780,
          "old_api": null,
          "new_api": "head",
          "old_text": null,
          "new_text": "find_used_partitions_imerge(&prune_param,\n                                                  tree->merges.head())",
          "old_line_content": "        can't really analyze properly.",
          "new_line_content": "      if (-1 == (res= find_used_partitions_imerge(&prune_param,",
          "content_same": false
        },
        {
          "line": 2781,
          "old_api": null,
          "new_api": "head",
          "old_text": null,
          "new_text": "tree->merges.head()",
          "old_line_content": "      */",
          "new_line_content": "                                                  tree->merges.head())))",
          "content_same": false
        },
        {
          "line": 4830,
          "old_api": null,
          "new_api": "set_if_smaller",
          "old_text": null,
          "new_text": "set_if_smaller(param->table->quick_condition_rows, best_rows)",
          "old_line_content": "",
          "new_line_content": "    set_if_smaller(param->table->quick_condition_rows, best_rows);",
          "content_same": false
        },
        {
          "line": 6875,
          "old_api": null,
          "new_api": "first",
          "old_text": null,
          "new_text": "key2->first()",
          "old_line_content": "    {\t\t\t\t\t\t// Found tmp.max < key2.min",
          "new_line_content": "  for (key2=key2->first(); key2; )",
          "content_same": false
        },
        {
          "line": 6877,
          "old_api": null,
          "new_api": "find_range",
          "old_text": null,
          "new_text": "key1->find_range(key2)",
          "old_line_content": "      /* key1 on the left of key2 non-overlapping */",
          "new_line_content": "    SEL_ARG *tmp=key1->find_range(key2);\t// Find key1.min <= key2.min",
          "content_same": false
        },
        {
          "line": 4834,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"Returning non-covering ROR-intersect plan:\"\n                        \"cost %g, records %lu\",\n                        trp->read_cost, (ulong) trp->records))",
          "old_line_content": "    get_best_covering_ror_intersect()",
          "new_line_content": "    DBUG_PRINT(\"info\", (\"Returning non-covering ROR-intersect plan:\"",
          "content_same": false
        },
        {
          "line": 8931,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(HA_ERR_END_OF_FILE)",
          "old_line_content": "\t\t\t\t   TRUE);",
          "new_line_content": "      DBUG_RETURN(HA_ERR_END_OF_FILE);",
          "content_same": false
        },
        {
          "line": 6882,
          "old_api": null,
          "new_api": "first",
          "old_text": null,
          "new_text": "key1->first()",
          "old_line_content": "\tif (key2_shared)",
          "new_line_content": "      tmp=key1->first();\t\t\t// tmp.min > key2.min",
          "content_same": false
        },
        {
          "line": 6885,
          "old_api": null,
          "new_api": "cmp_max_to_min",
          "old_text": null,
          "new_text": "tmp->cmp_max_to_min(key2)",
          "old_line_content": "\t    return 0;\t\t// out of memory",
          "new_line_content": "    else if ((cmp=tmp->cmp_max_to_min(key2)) < 0)",
          "content_same": false
        },
        {
          "line": 4838,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(trp)",
          "old_line_content": "",
          "new_line_content": "  DBUG_RETURN(trp);",
          "content_same": false
        },
        {
          "line": 8937,
          "old_api": null,
          "new_api": "make_max_endpoint",
          "old_text": null,
          "new_text": "last_range->make_max_endpoint(&end_key, prefix_length, keypart_map)",
          "old_line_content": "    last_range= 0;\t\t\t// No matching rows; go to next range",
          "new_line_content": "    last_range->make_max_endpoint(&end_key, prefix_length, keypart_map);",
          "content_same": false
        },
        {
          "line": 8939,
          "old_api": null,
          "new_api": "read_range_first",
          "old_text": null,
          "new_text": "file->read_range_first(last_range->min_keypart_map ? &start_key : 0,\n\t\t\t\t   last_range->max_keypart_map ? &end_key : 0,\n                                   test(last_range->flag & EQ_RANGE),\n\t\t\t\t   TRUE)",
          "old_line_content": "}",
          "new_line_content": "    result= file->read_range_first(last_range->min_keypart_map ? &start_key : 0,",
          "content_same": false
        },
        {
          "line": 8941,
          "old_api": null,
          "new_api": "test",
          "old_text": null,
          "new_text": "test(last_range->flag & EQ_RANGE)",
          "old_line_content": "",
          "new_line_content": "                                   test(last_range->flag & EQ_RANGE),",
          "content_same": false
        },
        {
          "line": 6897,
          "old_api": null,
          "new_api": "increment_use_count",
          "old_text": null,
          "new_text": "key2->increment_use_count(key1->use_count+1)",
          "old_line_content": "      }",
          "new_line_content": "\t  key2->increment_use_count(key1->use_count+1);",
          "content_same": false
        },
        {
          "line": 8947,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "",
          "new_line_content": "      DBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 6900,
          "old_api": null,
          "new_api": "copy_min",
          "old_text": null,
          "new_text": "key2->copy_min(tmp)",
          "old_line_content": "    }",
          "new_line_content": "\tkey2->copy_min(tmp);",
          "content_same": false
        },
        {
          "line": 6901,
          "old_api": null,
          "new_api": "tree_delete",
          "old_text": null,
          "new_text": "key1->tree_delete(tmp)",
          "old_line_content": "    if (cmp < 0)",
          "new_line_content": "\tif (!(key1=key1->tree_delete(tmp)))",
          "content_same": false
        },
        {
          "line": 2809,
          "old_api": null,
          "new_api": "mark_all_partitions_as_used",
          "old_text": null,
          "new_text": "mark_all_partitions_as_used(prune_param.part_info)",
          "old_line_content": "  Store field key image to table record",
          "new_line_content": "  mark_all_partitions_as_used(prune_param.part_info);",
          "content_same": false
        },
        {
          "line": 2811,
          "old_api": null,
          "new_api": "dbug_tmp_restore_column_maps",
          "old_text": null,
          "new_text": "dbug_tmp_restore_column_maps(table->read_set, table->write_set, old_sets)",
          "old_line_content": "  SYNOPSIS",
          "new_line_content": "  dbug_tmp_restore_column_maps(table->read_set, table->write_set, old_sets);",
          "content_same": false
        },
        {
          "line": 2814,
          "old_api": null,
          "new_api": "MYF",
          "old_text": null,
          "new_text": "MYF(0)",
          "old_line_content": "      ptr    Field value in key format",
          "new_line_content": "  free_root(&alloc,MYF(0));\t\t\t// Return memory & allocator",
          "content_same": false
        },
        {
          "line": 2815,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(retval)",
          "old_line_content": "      len    Length of the value, in bytes",
          "new_line_content": "  DBUG_RETURN(retval);",
          "content_same": false
        },
        {
          "line": 11009,
          "old_api": null,
          "new_api": "get_dynamic",
          "old_text": null,
          "new_text": "get_dynamic(&min_max_ranges, (uchar*)&cur_range, 0)",
          "old_line_content": "  {",
          "new_line_content": "      get_dynamic(&min_max_ranges, (uchar*)&cur_range, 0);",
          "content_same": false
        },
        {
          "line": 6915,
          "old_api": null,
          "new_api": "cmp_min_to_max",
          "old_text": null,
          "new_text": "tmp->cmp_min_to_max(key2)",
          "old_line_content": "\t      return new SEL_ARG(SEL_ARG::MAYBE_KEY);",
          "new_line_content": "      if ((tmp_cmp=tmp->cmp_min_to_max(key2)) > 0) // if tmp.min > key2.max",
          "content_same": false
        },
        {
          "line": 8968,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "",
          "new_line_content": "\tDBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 6920,
          "old_api": null,
          "new_api": "copy_min_to_min",
          "old_text": null,
          "new_text": "tmp->copy_min_to_min(key2)",
          "old_line_content": "\t  continue;",
          "new_line_content": "\t  tmp->copy_min_to_min(key2);",
          "content_same": false
        },
        {
          "line": 6921,
          "old_api": null,
          "new_api": "merge_flags",
          "old_text": null,
          "new_text": "key1->merge_flags(key2)",
          "old_line_content": "\t}",
          "new_line_content": "\t  key1->merge_flags(key2);",
          "content_same": false
        },
        {
          "line": 11019,
          "old_api": null,
          "new_api": "real_maybe_null",
          "old_text": null,
          "new_text": "min_max_arg_part->field->real_maybe_null()",
          "old_line_content": "    used_key_parts++;",
          "new_line_content": "           min_max_arg_part->field->real_maybe_null())",
          "content_same": false
        },
        {
          "line": 8976,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(HA_ERR_END_OF_FILE)",
          "old_line_content": "  }",
          "new_line_content": "      DBUG_RETURN(HA_ERR_END_OF_FILE);",
          "content_same": false
        },
        {
          "line": 6929,
          "old_api": null,
          "new_api": "increment_use_count",
          "old_text": null,
          "new_text": "key2->increment_use_count(-1)",
          "old_line_content": "\t      return 0;\t\t\t\t// OOM",
          "new_line_content": "\t  key2->increment_use_count(-1);\t// Free not used tree",
          "content_same": false
        },
        {
          "line": 4882,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"get_best_covering_ror_intersect\")",
          "old_line_content": "    Assume set I is [ror_scan .. ror_scans_end)",
          "new_line_content": "  DBUG_ENTER(\"get_best_covering_ror_intersect\");",
          "content_same": false
        },
        {
          "line": 8980,
          "old_api": null,
          "new_api": "index_read_map",
          "old_text": null,
          "new_text": "file->index_read_map(record, last_range->min_key,\n                                 last_range->min_keypart_map,\n                                 (ha_rkey_function)(last_range->flag ^\n                                                    GEOM_FLAG))",
          "old_line_content": "/*",
          "new_line_content": "    result= file->index_read_map(record, last_range->min_key,",
          "content_same": false
        },
        {
          "line": 4884,
          "old_api": null,
          "new_api": "optimizer_flag",
          "old_text": null,
          "new_text": "optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_INTERSECT)",
          "old_line_content": "",
          "new_line_content": "  if (!optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_INTERSECT))",
          "content_same": false
        },
        {
          "line": 8982,
          "old_api": null,
          "new_api": "ha_rkey_function)(last_range->flag ^\n                                                    GEOM_FLAG)",
          "old_text": null,
          "new_text": "ha_rkey_function)(last_range->flag ^\n                                                    GEOM_FLAG)",
          "old_line_content": "",
          "new_line_content": "                                 (ha_rkey_function)(last_range->flag ^",
          "content_same": false
        },
        {
          "line": 4885,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "  /*I=set of all covering indexes */",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 2840,
          "old_api": null,
          "new_api": "real_maybe_null",
          "old_text": null,
          "new_text": "field->real_maybe_null()",
          "old_line_content": "                                    field->table->write_set);",
          "new_line_content": "  if (field->real_maybe_null())",
          "content_same": false
        },
        {
          "line": 8985,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "    which reads all necessary parts of the index that is scanned by this",
          "new_line_content": "      DBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 2844,
          "old_api": null,
          "new_api": "set_null",
          "old_text": null,
          "new_text": "field->set_null()",
          "old_line_content": "",
          "new_line_content": "      field->set_null();",
          "content_same": false
        },
        {
          "line": 6941,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "key1->insert(cpy)",
          "old_line_content": "    /* ",
          "new_line_content": "\t    key1=key1->insert(cpy);",
          "content_same": false
        },
        {
          "line": 6942,
          "old_api": null,
          "new_api": "increment_use_count",
          "old_text": null,
          "new_text": "key2->increment_use_count(key1->use_count+1)",
          "old_line_content": "      tmp.min >= key2.min && tmp.min <= key.max  (overlapping ranges)",
          "new_line_content": "\t    key2->increment_use_count(key1->use_count+1);",
          "content_same": false
        },
        {
          "line": 2847,
          "old_api": null,
          "new_api": "set_notnull",
          "old_text": null,
          "new_text": "field->set_notnull()",
          "old_line_content": "  For SEL_ARG* array, store sel_arg->min values into table record buffer",
          "new_line_content": "    field->set_notnull();",
          "content_same": false
        },
        {
          "line": 2850,
          "old_api": null,
          "new_api": "dbug_tmp_use_all_columns",
          "old_text": null,
          "new_text": "dbug_tmp_use_all_columns(field->table,\n                                    field->table->write_set)",
          "old_line_content": "    store_selargs_to_rec()",
          "new_line_content": "  old_map= dbug_tmp_use_all_columns(field->table,",
          "content_same": false
        },
        {
          "line": 2852,
          "old_api": null,
          "new_api": "set_key_image",
          "old_text": null,
          "new_text": "field->set_key_image(ptr, len)",
          "old_line_content": "      start  Array of SEL_ARG* for which the minimum values should be stored",
          "new_line_content": "  field->set_key_image(ptr, len); ",
          "content_same": false
        },
        {
          "line": 2853,
          "old_api": null,
          "new_api": "dbug_tmp_restore_column_map",
          "old_text": null,
          "new_text": "dbug_tmp_restore_column_map(field->table->write_set, old_map)",
          "old_line_content": "      num    Number of elements in the array",
          "new_line_content": "  dbug_tmp_restore_column_map(field->table->write_set, old_map);",
          "content_same": false
        },
        {
          "line": 4901,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(param->mem_root,\n                                               param->fields_bitmap_size)",
          "old_line_content": "",
          "new_line_content": "    covered_fields->bitmap= (my_bitmap_map*)alloc_root(param->mem_root,",
          "content_same": false
        },
        {
          "line": 4904,
          "old_api": null,
          "new_api": "bitmap_init",
          "old_text": null,
          "new_text": "bitmap_init(covered_fields, covered_fields->bitmap,\n                  param->table->s->fields, FALSE)",
          "old_line_content": "                                           \"building covering ROR-I\",",
          "new_line_content": "      bitmap_init(covered_fields, covered_fields->bitmap,",
          "content_same": false
        },
        {
          "line": 4906,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "  do",
          "new_line_content": "    DBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 4907,
          "old_api": null,
          "new_api": "bitmap_clear_all",
          "old_text": null,
          "new_text": "bitmap_clear_all(covered_fields)",
          "old_line_content": "  {",
          "new_line_content": "  bitmap_clear_all(covered_fields);",
          "content_same": false
        },
        {
          "line": 6956,
          "old_api": null,
          "new_api": "eq_tree",
          "old_text": null,
          "new_text": "eq_tree(tmp->next_key_part,key2->next_key_part)",
          "old_line_content": "      else",
          "new_line_content": "    if (eq_tree(tmp->next_key_part,key2->next_key_part))",
          "content_same": false
        },
        {
          "line": 11053,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::reset\")",
          "old_line_content": "  if (result == HA_ERR_END_OF_FILE)",
          "new_line_content": "  DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::reset\");",
          "content_same": false
        },
        {
          "line": 6958,
          "old_api": null,
          "new_api": "is_same",
          "old_text": null,
          "new_text": "tmp->is_same(key2)",
          "old_line_content": "\tSEL_ARG *last=tmp;",
          "new_line_content": "      if (tmp->is_same(key2))",
          "content_same": false
        },
        {
          "line": 11055,
          "old_api": null,
          "new_api": "set_keyread",
          "old_text": null,
          "new_text": "head->set_keyread(TRUE)",
          "old_line_content": "  /* Save the prefix of the last group. */",
          "new_line_content": "  head->set_keyread(TRUE); /* We need only the key attributes */",
          "content_same": false
        },
        {
          "line": 4913,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"Building covering ROR-intersection\"))",
          "old_line_content": "    */",
          "new_line_content": "  DBUG_PRINT(\"info\", (\"Building covering ROR-intersection\"));",
          "content_same": false
        },
        {
          "line": 4914,
          "old_api": null,
          "new_api": "print_ror_scans_arr",
          "old_text": null,
          "new_text": "print_ror_scans_arr(param->table,\n                                           \"building covering ROR-I\",\n                                           ror_scan_mark, ror_scans_end)",
          "old_line_content": "    for (ROR_SCAN_INFO **scan= ror_scan_mark; scan != ror_scans_end; ++scan)",
          "new_line_content": "  DBUG_EXECUTE(\"info\", print_ror_scans_arr(param->table,",
          "content_same": false
        },
        {
          "line": 11059,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "}",
          "new_line_content": "    DBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 11061,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "quick_prefix_select->reset()",
          "old_line_content": "",
          "new_line_content": "  if (quick_prefix_select && quick_prefix_select->reset())",
          "content_same": false
        },
        {
          "line": 11062,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(1)",
          "old_line_content": "",
          "new_line_content": "    DBUG_RETURN(1);",
          "content_same": false
        },
        {
          "line": 11063,
          "old_api": null,
          "new_api": "index_last",
          "old_text": null,
          "new_text": "file->index_last(record)",
          "old_line_content": "/* ",
          "new_line_content": "  result= file->index_last(record);",
          "content_same": false
        },
        {
          "line": 11065,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "",
          "new_line_content": "    DBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 9018,
          "old_api": null,
          "new_api": "dynamic_array_ptr",
          "old_text": null,
          "new_text": "dynamic_array_ptr(&ranges, mid)",
          "old_line_content": "}",
          "new_line_content": "    if (cmp_next(*(QUICK_RANGE**)dynamic_array_ptr(&ranges, mid)))",
          "content_same": false
        },
        {
          "line": 11067,
          "old_api": null,
          "new_api": "key_copy",
          "old_text": null,
          "new_text": "key_copy(last_prefix, record, index_info, group_prefix_len)",
          "old_line_content": "    QUICK_GROUP_MIN_MAX_SELECT::get_next()",
          "new_line_content": "  key_copy(last_prefix, record, index_info, group_prefix_len);",
          "content_same": false
        },
        {
          "line": 7898,
          "old_api": null,
          "new_api": "make_keypart_map",
          "old_text": null,
          "new_text": "make_keypart_map(tmp_min_keypart)",
          "old_line_content": "    }",
          "new_line_content": "      min_range.keypart_map= make_keypart_map(tmp_min_keypart);",
          "content_same": false
        },
        {
          "line": 11069,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "  DESCRIPTION",
          "new_line_content": "  DBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 4927,
          "old_api": null,
          "new_api": "bitmap_subtract",
          "old_text": null,
          "new_text": "bitmap_subtract(&(*scan)->covered_fields, covered_fields)",
          "old_line_content": "                                             \"remaining scans\",",
          "new_line_content": "      bitmap_subtract(&(*scan)->covered_fields, covered_fields);",
          "content_same": false
        },
        {
          "line": 6975,
          "old_api": null,
          "new_api": "cmp_min_to_max",
          "old_text": null,
          "new_text": "last->next->cmp_min_to_max(key2)",
          "old_line_content": "          */",
          "new_line_content": "\twhile (last->next && last->next->cmp_min_to_max(key2) <= 0 &&",
          "content_same": false
        },
        {
          "line": 4929,
          "old_api": null,
          "new_api": "bitmap_bits_set",
          "old_text": null,
          "new_text": "bitmap_bits_set(&(*scan)->covered_fields)",
          "old_line_content": "",
          "new_line_content": "        bitmap_bits_set(&(*scan)->covered_fields);",
          "content_same": false
        },
        {
          "line": 6976,
          "old_api": null,
          "new_api": "eq_tree",
          "old_text": null,
          "new_text": "eq_tree(last->next->next_key_part,key2->next_key_part)",
          "old_line_content": "\t  SEL_ARG *save=last;",
          "new_line_content": "\t       eq_tree(last->next->next_key_part,key2->next_key_part))",
          "content_same": false
        },
        {
          "line": 9027,
          "old_api": null,
          "new_api": "dynamic_array_ptr",
          "old_text": null,
          "new_text": "dynamic_array_ptr(&ranges, mid)",
          "old_line_content": "  for now, this seems to work right at least.",
          "new_line_content": "  res= *(QUICK_RANGE**)dynamic_array_ptr(&ranges, mid);",
          "content_same": false
        },
        {
          "line": 9028,
          "old_api": null,
          "new_api": "cmp_prev",
          "old_text": null,
          "new_text": "cmp_prev(res)",
          "old_line_content": " */",
          "new_line_content": "  return (!cmp_next(res) && !cmp_prev(res));",
          "content_same": false
        },
        {
          "line": 4931,
          "old_api": null,
          "new_api": "bitmap_get_first",
          "old_text": null,
          "new_text": "bitmap_get_first(&(*scan)->covered_fields)",
          "old_line_content": "    total_cost += (*ror_scan_mark)->index_read_cost;",
          "new_line_content": "        bitmap_get_first(&(*scan)->covered_fields);",
          "content_same": false
        },
        {
          "line": 4934,
          "old_api": null,
          "new_api": "my_qsort",
          "old_text": null,
          "new_text": "my_qsort(ror_scan_mark, ror_scans_end-ror_scan_mark, sizeof(ROR_SCAN_INFO*),\n             (qsort_cmp)cmp_ror_scan_info_covering)",
          "old_line_content": "                        param->table->key_info[(*ror_scan_mark)->keynr].name));",
          "new_line_content": "    my_qsort(ror_scan_mark, ror_scans_end-ror_scan_mark, sizeof(ROR_SCAN_INFO*),",
          "content_same": false
        },
        {
          "line": 2888,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"mark_full_partition_used_no_parts\")",
          "old_line_content": "  uint32 start= part_id * part_info->num_subparts;",
          "new_line_content": "  DBUG_ENTER(\"mark_full_partition_used_no_parts\");",
          "content_same": false
        },
        {
          "line": 2889,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"enter\", (\"Mark partition %u as used\", part_id))",
          "old_line_content": "  uint32 end=   start + part_info->num_subparts; ",
          "new_line_content": "  DBUG_PRINT(\"enter\", (\"Mark partition %u as used\", part_id));",
          "content_same": false
        },
        {
          "line": 4937,
          "old_api": null,
          "new_api": "print_ror_scans_arr",
          "old_text": null,
          "new_text": "print_ror_scans_arr(param->table,\n                                             \"remaining scans\",\n                                             ror_scan_mark, ror_scans_end)",
          "old_line_content": "    /* F=F-covered by first(I) */",
          "new_line_content": "    DBUG_EXECUTE(\"info\", print_ror_scans_arr(param->table,",
          "content_same": false
        },
        {
          "line": 6989,
          "old_api": null,
          "new_api": "tree_delete",
          "old_text": null,
          "new_text": "key1->tree_delete(save)",
          "old_line_content": "        {",
          "new_line_content": "\t  key1=key1->tree_delete(save);",
          "content_same": false
        },
        {
          "line": 4944,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"Adding scan on %s\",\n                        param->table->key_info[(*ror_scan_mark)->keynr].name))",
          "old_line_content": "",
          "new_line_content": "    DBUG_PRINT(\"info\", (\"Adding scan on %s\",",
          "content_same": false
        },
        {
          "line": 4947,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "    cost total_cost.",
          "new_line_content": "      DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 2901,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"mark_full_partition_used_with_parts\")",
          "old_line_content": "  Find the set of used partitions for List<SEL_IMERGE>",
          "new_line_content": "  DBUG_ENTER(\"mark_full_partition_used_with_parts\");",
          "content_same": false
        },
        {
          "line": 6997,
          "old_api": null,
          "new_api": "copy_min",
          "old_text": null,
          "new_text": "last->copy_min(first)",
          "old_line_content": "          }",
          "new_line_content": "        last->copy_min(first);",
          "content_same": false
        },
        {
          "line": 6998,
          "old_api": null,
          "new_api": "copy_min",
          "old_text": null,
          "new_text": "last->copy_min(key2)",
          "old_line_content": "          else",
          "new_line_content": "        bool full_range= last->copy_min(key2);",
          "content_same": false
        },
        {
          "line": 2905,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"1:Mark subpartition %u as used\", start))",
          "old_line_content": "      key_tree  Intervals tree to perform pruning for.",
          "new_line_content": "    DBUG_PRINT(\"info\", (\"1:Mark subpartition %u as used\", start));",
          "content_same": false
        },
        {
          "line": 2906,
          "old_api": null,
          "new_api": "bitmap_set_bit",
          "old_text": null,
          "new_text": "bitmap_set_bit(&part_info->used_partitions, start)",
          "old_line_content": "      ",
          "new_line_content": "    bitmap_set_bit(&part_info->used_partitions, start);",
          "content_same": false
        },
        {
          "line": 4954,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "  /* Add priority queue use cost. */",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 7001,
          "old_api": null,
          "new_api": "cmp_max_to_min",
          "old_text": null,
          "new_text": "key2->cmp_max_to_min(last->next)",
          "old_line_content": "\tif (full_range)",
          "new_line_content": "          if (last->next && key2->cmp_max_to_min(last->next) >= 0)",
          "content_same": false
        },
        {
          "line": 4960,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"Covering ROR-intersect scans cost: %g\", total_cost))",
          "old_line_content": "  if (total_cost > read_time)",
          "new_line_content": "  DBUG_PRINT(\"info\", (\"Covering ROR-intersect scans cost: %g\", total_cost));",
          "content_same": false
        },
        {
          "line": 9058,
          "old_api": null,
          "new_api": "push_front",
          "old_text": null,
          "new_text": "rev_ranges.push_front(*pr)",
          "old_line_content": "}",
          "new_line_content": "    rev_ranges.push_front(*pr);",
          "content_same": false
        },
        {
          "line": 7010,
          "old_api": null,
          "new_api": "copy_max",
          "old_text": null,
          "new_text": "last->copy_max(key2)",
          "old_line_content": "      }",
          "new_line_content": "            full_range= last->copy_max(key2);",
          "content_same": false
        },
        {
          "line": 4966,
          "old_api": null,
          "new_api": "rows2double",
          "old_text": null,
          "new_text": "rows2double(records)",
          "old_line_content": "  uint best_num= (ror_scan_mark - tree->ror_scans);",
          "new_line_content": "  total_cost += rows2double(records)*",
          "content_same": false
        },
        {
          "line": 7014,
          "old_api": null,
          "new_api": "free_tree",
          "old_text": null,
          "new_text": "key1->free_tree()",
          "old_line_content": "    {\t\t\t\t\t\t// tmp.min <= x < key2.min",
          "new_line_content": "\t  key1->free_tree();",
          "content_same": false
        },
        {
          "line": 7016,
          "old_api": null,
          "new_api": "increment_use_count",
          "old_text": null,
          "new_text": "key2->increment_use_count(-1)",
          "old_line_content": "      if (!new_arg)",
          "new_line_content": "\t    key2->increment_use_count(-1);\t// Free not used tree",
          "content_same": false
        },
        {
          "line": 4969,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"Covering ROR-intersect full cost: %g\", total_cost))",
          "old_line_content": "                                                     best_num)))",
          "new_line_content": "  DBUG_PRINT(\"info\", (\"Covering ROR-intersect full cost: %g\", total_cost));",
          "content_same": false
        },
        {
          "line": 9067,
          "old_api": null,
          "new_api": "rewind",
          "old_text": null,
          "new_text": "rev_it.rewind()",
          "old_line_content": "   *   - if it is an EQ_RANGE, which means that max key covers the entire",
          "new_line_content": "  rev_it.rewind();",
          "content_same": false
        },
        {
          "line": 11116,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::get_next\")",
          "old_line_content": "      this->record contains the current prefix in record format.",
          "new_line_content": "  DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::get_next\");",
          "content_same": false
        },
        {
          "line": 4972,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "  trp->last_scan=  trp->first_scan + best_num;",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 4976,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(trp)",
          "old_line_content": "  trp->cpk_scan= NULL;",
          "new_line_content": "    DBUG_RETURN(trp);",
          "content_same": false
        },
        {
          "line": 7024,
          "old_api": null,
          "new_api": "cmp_min_to_min",
          "old_text": null,
          "new_text": "tmp->cmp_min_to_min(key2)",
          "old_line_content": "    // tmp.min >= key2.min && tmp.min <= key2.max",
          "new_line_content": "    if (cmp >= 0 && tmp->cmp_min_to_min(key2) < 0)",
          "content_same": false
        },
        {
          "line": 9074,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"QUICK_SELECT_DESC::get_next\")",
          "old_line_content": "   */",
          "new_line_content": "  DBUG_ENTER(\"QUICK_SELECT_DESC::get_next\");",
          "content_same": false
        },
        {
          "line": 4978,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(param->mem_root,\n                                                     sizeof(ROR_SCAN_INFO*)*\n                                                     best_num)",
          "old_line_content": "",
          "new_line_content": "  if (!(trp->first_scan= (ROR_SCAN_INFO**)alloc_root(param->mem_root,",
          "content_same": false
        },
        {
          "line": 11124,
          "old_api": null,
          "new_api": "next_prefix",
          "old_text": null,
          "new_text": "next_prefix()",
          "old_line_content": "    else ",
          "new_line_content": "    result= next_prefix();",
          "content_same": false
        },
        {
          "line": 4981,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "              trp->read_cost, (ulong) trp->records));",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 7026,
          "old_api": null,
          "new_api": "clone_first",
          "old_text": null,
          "new_text": "tmp->clone_first(key2)",
          "old_line_content": "    for (;;)",
          "new_line_content": "      SEL_ARG *new_arg=tmp->clone_first(key2);",
          "content_same": false
        },
        {
          "line": 7031,
          "old_api": null,
          "new_api": "copy_min_to_min",
          "old_text": null,
          "new_text": "tmp->copy_min_to_min(key2)",
          "old_line_content": "\tif (!new_arg)",
          "new_line_content": "      tmp->copy_min_to_min(key2);",
          "content_same": false
        },
        {
          "line": 2936,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(ppar->range_param.mem_root,\n                                                bitmap_bytes)",
          "old_line_content": "",
          "new_line_content": "  if (!(bitmap_buf= (my_bitmap_map*) alloc_root(ppar->range_param.mem_root,",
          "content_same": false
        },
        {
          "line": 7032,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "key1->insert(new_arg)",
          "old_line_content": "\t  return 0;\t\t\t\t// OOM",
          "new_line_content": "      key1=key1->insert(new_arg);",
          "content_same": false
        },
        {
          "line": 11131,
          "old_api": null,
          "new_api": "key_cmp",
          "old_text": null,
          "new_text": "key_cmp(index_info->key_part, last_prefix,\n                              group_prefix_len)",
          "old_line_content": "    if (have_min)",
          "new_line_content": "      is_last_prefix= key_cmp(index_info->key_part, last_prefix,",
          "content_same": false
        },
        {
          "line": 4988,
          "old_api": null,
          "new_api": "set_if_smaller",
          "old_text": null,
          "new_text": "set_if_smaller(param->table->quick_condition_rows, records)",
          "old_line_content": "  Also update PARAM members and store ROR scans info in the SEL_TREE.",
          "new_line_content": "  set_if_smaller(param->table->quick_condition_rows, records); ",
          "content_same": false
        },
        {
          "line": 4990,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\",\n             (\"Returning covering ROR-intersect plan: cost %g, records %lu\",\n              trp->read_cost, (ulong) trp->records))",
          "old_line_content": "    get_key_scans_params",
          "new_line_content": "  DBUG_PRINT(\"info\",",
          "content_same": false
        },
        {
          "line": 2943,
          "old_api": null,
          "new_api": "head",
          "old_text": null,
          "new_text": "merges.head()",
          "old_line_content": "    {",
          "new_line_content": "    return find_used_partitions_imerge(ppar, merges.head());",
          "content_same": false
        },
        {
          "line": 7039,
          "old_api": null,
          "new_api": "cmp_min_to_min",
          "old_text": null,
          "new_text": "tmp->cmp_min_to_min(&key)",
          "old_line_content": "\ttmp->maybe_flag|= key.maybe_flag;",
          "new_line_content": "      if (tmp->cmp_min_to_min(&key) > 0)",
          "content_same": false
        },
        {
          "line": 2945,
          "old_api": null,
          "new_api": "bitmap_init",
          "old_text": null,
          "new_text": "bitmap_init(&all_merges, bitmap_buf, n_bits, FALSE)",
          "old_line_content": "      return 0;",
          "new_line_content": "  bitmap_init(&all_merges, bitmap_buf, n_bits, FALSE);",
          "content_same": false
        },
        {
          "line": 2946,
          "old_api": null,
          "new_api": "bitmap_set_prefix",
          "old_text": null,
          "new_text": "bitmap_set_prefix(&all_merges, n_bits)",
          "old_line_content": "    }",
          "new_line_content": "  bitmap_set_prefix(&all_merges, n_bits);",
          "content_same": false
        },
        {
          "line": 4993,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(trp)",
          "old_line_content": "      index_read_must_be_used if TRUE, assume 'index only' option will be set",
          "new_line_content": "  DBUG_RETURN(trp);",
          "content_same": false
        },
        {
          "line": 7045,
          "old_api": null,
          "new_api": "increment_use_count",
          "old_text": null,
          "new_text": "new_arg->increment_use_count(key1->use_count+1)",
          "old_line_content": "\tif (!(tmp=tmp->next))",
          "new_line_content": "\t  new_arg->increment_use_count(key1->use_count+1);",
          "content_same": false
        },
        {
          "line": 9094,
          "old_api": null,
          "new_api": "index_next_same",
          "old_text": null,
          "new_text": "file->index_next_same(record, last_range->min_key,\n                                      last_range->min_length)",
          "old_line_content": "",
          "new_line_content": "                file->index_next_same(record, last_range->min_key,",
          "content_same": false
        },
        {
          "line": 7046,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "key1->insert(new_arg)",
          "old_line_content": "\t{",
          "new_line_content": "\tkey1=key1->insert(new_arg);",
          "content_same": false
        },
        {
          "line": 2952,
          "old_api": null,
          "new_api": "find_used_partitions_imerge",
          "old_text": null,
          "new_text": "find_used_partitions_imerge(ppar, imerge)",
          "old_line_content": "      return 0;",
          "new_line_content": "    int res= find_used_partitions_imerge(ppar, imerge);",
          "content_same": false
        },
        {
          "line": 11144,
          "old_api": null,
          "new_api": "next_min",
          "old_text": null,
          "new_text": "next_min()",
          "old_line_content": "      /* If a MIN was found, a MAX must have been found as well. */",
          "new_line_content": "      min_res= next_min();",
          "content_same": false
        },
        {
          "line": 11146,
          "old_api": null,
          "new_api": "update_min_result",
          "old_text": null,
          "new_text": "update_min_result()",
          "old_line_content": "                  (have_max && have_min && (max_res == 0)));",
          "new_line_content": "        update_min_result();",
          "content_same": false
        },
        {
          "line": 9099,
          "old_api": null,
          "new_api": "ref",
          "old_text": null,
          "new_text": "rev_it.ref()",
          "old_line_content": "    {",
          "new_line_content": "\tif (cmp_prev(*rev_it.ref()) == 0)",
          "content_same": false
        },
        {
          "line": 9100,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "      int local_error;",
          "new_line_content": "\t  DBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 7048,
          "old_api": null,
          "new_api": "cmp_max_to_max",
          "old_text": null,
          "new_text": "tmp->cmp_max_to_max(&key)",
          "old_line_content": "\t  if (!tmp2)",
          "new_line_content": "      if ((cmp=tmp->cmp_max_to_max(&key)) <= 0)",
          "content_same": false
        },
        {
          "line": 7051,
          "old_api": null,
          "new_api": "increment_use_count",
          "old_text": null,
          "new_text": "key.increment_use_count(key1->use_count+1)",
          "old_line_content": "\t  key2=key2->next;",
          "new_line_content": "\tkey.increment_use_count(key1->use_count+1);",
          "content_same": false
        },
        {
          "line": 7052,
          "old_api": null,
          "new_api": "key_or",
          "old_text": null,
          "new_text": "key_or(param, tmp->next_key_part, key.next_key_part)",
          "old_line_content": "\t  goto end;",
          "new_line_content": "\ttmp->next_key_part= key_or(param, tmp->next_key_part, key.next_key_part);",
          "content_same": false
        },
        {
          "line": 2960,
          "old_api": null,
          "new_api": "bitmap_intersect",
          "old_text": null,
          "new_text": "bitmap_intersect(&all_merges, &ppar->part_info->used_partitions)",
          "old_line_content": "",
          "new_line_content": "      bitmap_intersect(&all_merges, &ppar->part_info->used_partitions);",
          "content_same": false
        },
        {
          "line": 11152,
          "old_api": null,
          "new_api": "next_max",
          "old_text": null,
          "new_text": "next_max()",
          "old_line_content": "    */",
          "new_line_content": "      max_res= next_max();",
          "content_same": false
        },
        {
          "line": 2962,
          "old_api": null,
          "new_api": "bitmap_is_clear_all",
          "old_text": null,
          "new_text": "bitmap_is_clear_all(&all_merges)",
          "old_line_content": "/*",
          "new_line_content": "    if (bitmap_is_clear_all(&all_merges))",
          "content_same": false
        },
        {
          "line": 9107,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(HA_ERR_END_OF_FILE)",
          "old_line_content": "    }",
          "new_line_content": "      DBUG_RETURN(HA_ERR_END_OF_FILE);\t\t// All ranges used",
          "content_same": false
        },
        {
          "line": 11156,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT((have_max && !have_min) ||\n                  (have_max && have_min && (max_res == 0)))",
          "old_line_content": "                                   HA_READ_KEY_EXACT);",
          "new_line_content": "      DBUG_ASSERT((have_max && !have_min) ||",
          "content_same": false
        },
        {
          "line": 2965,
          "old_api": null,
          "new_api": "bitmap_clear_all",
          "old_text": null,
          "new_text": "bitmap_clear_all(&ppar->part_info->used_partitions)",
          "old_line_content": "    find_used_partitions_imerge()",
          "new_line_content": "    bitmap_clear_all(&ppar->part_info->used_partitions);",
          "content_same": false
        },
        {
          "line": 7055,
          "old_api": null,
          "new_api": "copy_max_to_min",
          "old_text": null,
          "new_text": "key.copy_max_to_min(tmp)",
          "old_line_content": "\t{",
          "new_line_content": "\tkey.copy_max_to_min(tmp);",
          "content_same": false
        },
        {
          "line": 2967,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(ppar->part_info->used_partitions.bitmap, all_merges.bitmap,\n         bitmap_bytes)",
          "old_line_content": "      key_tree  Intervals tree to perform pruning for.",
          "new_line_content": "  memcpy(ppar->part_info->used_partitions.bitmap, all_merges.bitmap,",
          "content_same": false
        },
        {
          "line": 9112,
          "old_api": null,
          "new_api": "index_last",
          "old_text": null,
          "new_text": "file->index_last(record)",
          "old_line_content": "    {",
          "new_line_content": "      if ((local_error=file->index_last(record)))",
          "content_same": false
        },
        {
          "line": 7061,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "key1->insert(tmp2)",
          "old_line_content": "\t}",
          "new_line_content": "\t  key1=key1->insert(tmp2);",
          "content_same": false
        },
        {
          "line": 9114,
          "old_api": null,
          "new_api": "cmp_prev",
          "old_text": null,
          "new_text": "cmp_prev(last_range)",
          "old_line_content": "                                    last_range->max_keypart_map,",
          "new_line_content": "      if (cmp_prev(last_range) == 0)",
          "content_same": false
        },
        {
          "line": 9115,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "                                    HA_READ_KEY_EXACT);",
          "new_line_content": "\tDBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 5021,
          "old_api": null,
          "new_api": "primary_key_is_clustered",
          "old_text": null,
          "new_text": "param->table->file->primary_key_is_clustered()",
          "old_line_content": "  for (idx= 0,key=tree->keys, end=key+param->keys;",
          "new_line_content": "  bool pk_is_clustered= param->table->file->primary_key_is_clustered();",
          "content_same": false
        },
        {
          "line": 11166,
          "old_api": null,
          "new_api": "make_prev_keypart_map",
          "old_text": null,
          "new_text": "make_prev_keypart_map(real_key_parts)",
          "old_line_content": "}",
          "new_line_content": "                                   make_prev_keypart_map(real_key_parts),",
          "content_same": false
        },
        {
          "line": 5022,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"get_key_scans_params\")",
          "old_line_content": "       key != end ;",
          "new_line_content": "  DBUG_ENTER(\"get_key_scans_params\");",
          "content_same": false
        },
        {
          "line": 7070,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "key1->insert(tmp2)",
          "old_line_content": "\t/* Increment key count as it may be used for next loop */",
          "new_line_content": "\t  key1=key1->insert(tmp2);",
          "content_same": false
        },
        {
          "line": 9124,
          "old_api": null,
          "new_api": "index_read_map",
          "old_text": null,
          "new_text": "file->index_read_map(record, last_range->max_key,\n                                    last_range->max_keypart_map,\n                                    HA_READ_KEY_EXACT)",
          "old_line_content": "                                  last_range->max_keypart_map,",
          "new_line_content": "      result = file->index_read_map(record, last_range->max_key,",
          "content_same": false
        },
        {
          "line": 5028,
          "old_api": null,
          "new_api": "print_sel_tree",
          "old_text": null,
          "new_text": "print_sel_tree(param, tree, &tree->keys_map,\n                                      \"tree scans\")",
          "old_line_content": "    {",
          "new_line_content": "  DBUG_EXECUTE(\"info\", print_sel_tree(param, tree, &tree->keys_map,",
          "content_same": false
        },
        {
          "line": 5030,
          "old_api": null,
          "new_api": "clear_all",
          "old_text": null,
          "new_text": "tree->ror_scans_map.clear_all()",
          "old_line_content": "      if ((*key)->type == SEL_ARG::MAYBE_KEY ||",
          "new_line_content": "  tree->ror_scans_map.clear_all();",
          "content_same": false
        },
        {
          "line": 7076,
          "old_api": null,
          "new_api": "clone_last",
          "old_text": null,
          "new_text": "tmp->clone_last(&key)",
          "old_line_content": "    }",
          "new_line_content": "\tSEL_ARG *new_arg=tmp->clone_last(&key); // tmp.min <= x <= key.max",
          "content_same": false
        },
        {
          "line": 11176,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "    Find the minimal key within this group such that the key satisfies the query",
          "new_line_content": "  DBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 7079,
          "old_api": null,
          "new_api": "copy_max_to_min",
          "old_text": null,
          "new_text": "tmp->copy_max_to_min(&key)",
          "old_line_content": "",
          "new_line_content": "\ttmp->copy_max_to_min(&key);",
          "content_same": false
        },
        {
          "line": 9130,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(last_range->flag & NEAR_MAX ||\n                  (last_range->flag & EQ_RANGE && \n                   used_key_parts > head->key_info[index].key_parts) ||\n                  range_reads_after_key(last_range))",
          "old_line_content": "    {",
          "new_line_content": "      DBUG_ASSERT(last_range->flag & NEAR_MAX ||",
          "content_same": false
        },
        {
          "line": 7080,
          "old_api": null,
          "new_api": "increment_use_count",
          "old_text": null,
          "new_text": "tmp->increment_use_count(key1->use_count+1)",
          "old_line_content": "end:",
          "new_line_content": "\ttmp->increment_use_count(key1->use_count+1);",
          "content_same": false
        },
        {
          "line": 7082,
          "old_api": null,
          "new_api": "increment_use_count",
          "old_text": null,
          "new_text": "key.increment_use_count(1)",
          "old_line_content": "  {",
          "new_line_content": "\tkey.increment_use_count(1);",
          "content_same": false
        },
        {
          "line": 9133,
          "old_api": null,
          "new_api": "range_reads_after_key",
          "old_text": null,
          "new_text": "range_reads_after_key(last_range)",
          "old_line_content": "      last_range= 0;                            // Not found, to next range",
          "new_line_content": "                  range_reads_after_key(last_range));",
          "content_same": false
        },
        {
          "line": 9134,
          "old_api": null,
          "new_api": "index_read_map",
          "old_text": null,
          "new_text": "file->index_read_map(record, last_range->max_key,\n                                  last_range->max_keypart_map,\n                                  ((last_range->flag & NEAR_MAX) ?\n                                   HA_READ_BEFORE_KEY :\n                                   HA_READ_PREFIX_LAST_OR_PREV))",
          "old_line_content": "      continue;",
          "new_line_content": "      result=file->index_read_map(record, last_range->max_key,",
          "content_same": false
        },
        {
          "line": 7083,
          "old_api": null,
          "new_api": "key_or",
          "old_text": null,
          "new_text": "key_or(param, tmp->next_key_part, key.next_key_part)",
          "old_line_content": "    SEL_ARG *next=key2->next;",
          "new_line_content": "\tnew_arg->next_key_part= key_or(param, tmp->next_key_part, key.next_key_part);",
          "content_same": false
        },
        {
          "line": 7084,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "key1->insert(new_arg)",
          "old_line_content": "    if (key2_shared)",
          "new_line_content": "\tkey1=key1->insert(new_arg);",
          "content_same": false
        },
        {
          "line": 5043,
          "old_api": null,
          "new_api": "set_bit",
          "old_text": null,
          "new_text": "param->needed_reg->set_bit(keynr)",
          "old_line_content": "      double cpu_cost= (double) found_records / TIME_FOR_COMPARE;",
          "new_line_content": "        param->needed_reg->set_bit(keynr);",
          "content_same": false
        },
        {
          "line": 9143,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "  }",
          "new_line_content": "\tDBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 5048,
          "old_api": null,
          "new_api": "check_quick_select",
          "old_text": null,
          "new_text": "check_quick_select(param, idx, *key, update_tbl_stats)",
          "old_line_content": "          !(pk_is_clustered && keynr == param->table->s->primary_key))",
          "new_line_content": "      found_records= check_quick_select(param, idx, *key, update_tbl_stats);",
          "content_same": false
        },
        {
          "line": 9147,
          "old_api": null,
          "new_api": "cmp_prev",
          "old_text": null,
          "new_text": "cmp_prev(last_range)",
          "old_line_content": "/**",
          "new_line_content": "    if (cmp_prev(last_range) == 0)",
          "content_same": false
        },
        {
          "line": 3003,
          "old_api": null,
          "new_api": "init_all_partitions_iterator",
          "old_text": null,
          "new_text": "init_all_partitions_iterator(ppar->part_info, &ppar->part_iter)",
          "old_line_content": "",
          "new_line_content": "    init_all_partitions_iterator(ppar->part_info, &ppar->part_iter);",
          "content_same": false
        },
        {
          "line": 3005,
          "old_api": null,
          "new_api": "find_used_partitions",
          "old_text": null,
          "new_text": "find_used_partitions(ppar, key_tree)",
          "old_line_content": "    find_used_partitions()",
          "new_line_content": "    if (!key_tree || (-1 == (res |= find_used_partitions(ppar, key_tree))))",
          "content_same": false
        },
        {
          "line": 5052,
          "old_api": null,
          "new_api": "set_bit",
          "old_text": null,
          "new_text": "tree->ror_scans_map.set_bit(idx)",
          "old_line_content": "          0.01 is added to avoid races between range and 'index' scan.",
          "new_line_content": "        tree->ror_scans_map.set_bit(idx);",
          "content_same": false
        },
        {
          "line": 9151,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "",
          "new_line_content": "      DBUG_RETURN(0);\t\t\t\t// Found key is in range",
          "content_same": false
        },
        {
          "line": 7100,
          "old_api": null,
          "new_api": "increment_use_count",
          "old_text": null,
          "new_text": "key2->increment_use_count(key1->use_count+1)",
          "old_line_content": "",
          "new_line_content": "      key2->increment_use_count(key1->use_count+1);",
          "content_same": false
        },
        {
          "line": 5057,
          "old_api": null,
          "new_api": "index_flags",
          "old_text": null,
          "new_text": "param->table->file->index_flags(keynr, param->max_key_part,1)",
          "old_line_content": "      else",
          "new_line_content": "          (param->table->file->index_flags(keynr, param->max_key_part,1) &",
          "content_same": false
        },
        {
          "line": 7101,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "key1->insert(tmp)",
          "old_line_content": "/* Compare if two trees are equal */",
          "new_line_content": "      key1=key1->insert(tmp);",
          "content_same": false
        },
        {
          "line": 7104,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "key1->insert(key2)",
          "old_line_content": "{",
          "new_line_content": "      key1=key1->insert(key2);\t\t\t// Will destroy key2_root",
          "content_same": false
        },
        {
          "line": 11206,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::next_min\")",
          "old_line_content": "    if (key_infix_len > 0)",
          "new_line_content": "  DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::next_min\");",
          "content_same": false
        },
        {
          "line": 5065,
          "old_api": null,
          "new_api": "get_index_only_read_time",
          "old_text": null,
          "new_text": "get_index_only_read_time(param,found_records,keynr)",
          "old_line_content": "                                                       found_records) +",
          "new_line_content": "        found_read_time= get_index_only_read_time(param,found_records,keynr) +",
          "content_same": false
        },
        {
          "line": 11212,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "    }",
          "new_line_content": "      DBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 5074,
          "old_api": null,
          "new_api": "read_time",
          "old_text": null,
          "new_text": "param->table->file->read_time(keynr,\n                                                       param->range_count,\n                                                       found_records)",
          "old_line_content": "        read_time=    found_read_time;",
          "new_line_content": "\tfound_read_time= param->table->file->read_time(keynr,",
          "content_same": false
        },
        {
          "line": 11219,
          "old_api": null,
          "new_api": "index_read_map",
          "old_text": null,
          "new_text": "file->index_read_map(record, group_prefix,\n                                        make_prev_keypart_map(real_key_parts),\n                                        HA_READ_KEY_EXACT)",
          "old_line_content": "      - min_max_arg_part->field->ptr points to some place in 'record'.",
          "new_line_content": "      if ((result= file->index_read_map(record, group_prefix,",
          "content_same": false
        },
        {
          "line": 11220,
          "old_api": null,
          "new_api": "make_prev_keypart_map",
          "old_text": null,
          "new_text": "make_prev_keypart_map(real_key_parts)",
          "old_line_content": "    */",
          "new_line_content": "                                        make_prev_keypart_map(real_key_parts),",
          "content_same": false
        },
        {
          "line": 7122,
          "old_api": null,
          "new_api": "eq_tree",
          "old_text": null,
          "new_text": "eq_tree(a->left,b->left)",
          "old_line_content": "    return 0;",
          "new_line_content": "    if (!eq_tree(a->left,b->left))",
          "content_same": false
        },
        {
          "line": 11222,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "    {",
          "new_line_content": "        DBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 5079,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\",(\"key %s: found_read_time: %g (cur. read_time: %g)\",\n                         param->table->key_info[keynr].name, found_read_time,\n                         read_time))",
          "old_line_content": "    }",
          "new_line_content": "      DBUG_PRINT(\"info\",(\"key %s: found_read_time: %g (cur. read_time: %g)\",",
          "content_same": false
        },
        {
          "line": 7129,
          "old_api": null,
          "new_api": "eq_tree",
          "old_text": null,
          "new_text": "eq_tree(a->right,b->right)",
          "old_line_content": "  return 1;",
          "new_line_content": "    if (!eq_tree(a->right,b->right))",
          "content_same": false
        },
        {
          "line": 11232,
          "old_api": null,
          "new_api": "is_null",
          "old_text": null,
          "new_text": "min_max_arg_part->field->is_null()",
          "old_line_content": "        prefix with the group's prefix. If it is from the next group, then the",
          "new_line_content": "    if (min_max_arg_part && min_max_arg_part->field->is_null())",
          "content_same": false
        },
        {
          "line": 7137,
          "old_api": null,
          "new_api": "eq_tree",
          "old_text": null,
          "new_text": "eq_tree(a->next_key_part, b->next_key_part)",
          "old_line_content": "",
          "new_line_content": "\t!eq_tree(a->next_key_part, b->next_key_part))",
          "content_same": false
        },
        {
          "line": 11237,
          "old_api": null,
          "new_api": "key_copy",
          "old_text": null,
          "new_text": "key_copy(key_buf, record, index_info, 0)",
          "old_line_content": "        next call to next_min(), and to save one lookup in the next call. For",
          "new_line_content": "      key_copy(key_buf, record, index_info, 0);",
          "content_same": false
        },
        {
          "line": 11238,
          "old_api": null,
          "new_api": "index_read_map",
          "old_text": null,
          "new_text": "file->index_read_map(record, key_buf,\n                                   make_keypart_map(real_key_parts),\n                                   HA_READ_AFTER_KEY)",
          "old_line_content": "        this add a new member 'this->next_group_prefix'.",
          "new_line_content": "      result= file->index_read_map(record, key_buf,",
          "content_same": false
        },
        {
          "line": 11239,
          "old_api": null,
          "new_api": "make_keypart_map",
          "old_text": null,
          "new_text": "make_keypart_map(real_key_parts)",
          "old_line_content": "      */",
          "new_line_content": "                                   make_keypart_map(real_key_parts),",
          "content_same": false
        },
        {
          "line": 5093,
          "old_api": null,
          "new_api": "print_sel_tree",
          "old_text": null,
          "new_text": "print_sel_tree(param, tree, &tree->ror_scans_map,\n                                      \"ROR scans\")",
          "old_line_content": "                 (\"Returning range plan for key %s, cost %g, records %lu\",",
          "new_line_content": "  DBUG_EXECUTE(\"info\", print_sel_tree(param, tree, &tree->ror_scans_map,",
          "content_same": false
        },
        {
          "line": 5103,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\",\n                 (\"Returning range plan for key %s, cost %g, records %lu\",\n                  param->table->key_info[param->real_keynr[idx]].name,\n                  read_plan->read_cost, (ulong) read_plan->records))",
          "old_line_content": "",
          "new_line_content": "      DBUG_PRINT(\"info\",",
          "content_same": false
        },
        {
          "line": 7152,
          "old_api": null,
          "new_api": "cmp_min_to_min",
          "old_text": null,
          "new_text": "key->cmp_min_to_min(element)",
          "old_line_content": "\t/* Link in list */",
          "new_line_content": "    if (key->cmp_min_to_min(element) > 0)",
          "content_same": false
        },
        {
          "line": 9202,
          "old_api": null,
          "new_api": "is_null",
          "old_text": null,
          "new_text": "key_part->field->is_null()",
          "old_line_content": "    if (cmp > 0)",
          "new_line_content": "        if (!key_part->field->is_null())",
          "content_same": false
        },
        {
          "line": 11253,
          "old_api": null,
          "new_api": "key_cmp",
          "old_text": null,
          "new_text": "key_cmp(index_info->key_part, group_prefix, real_prefix_len)",
          "old_line_content": "  */",
          "new_line_content": "        if (key_cmp(index_info->key_part, group_prefix, real_prefix_len))",
          "content_same": false
        },
        {
          "line": 9206,
          "old_api": null,
          "new_api": "is_null",
          "old_text": null,
          "new_text": "key_part->field->is_null()",
          "old_line_content": "}",
          "new_line_content": "      else if (key_part->field->is_null())",
          "content_same": false
        },
        {
          "line": 5110,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"No 'range' table read plan found\"))",
          "old_line_content": "  QUICK_RANGE_SELECT *quick;",
          "new_line_content": "    DBUG_PRINT(\"info\", (\"No 'range' table read plan found\"));",
          "content_same": false
        },
        {
          "line": 5112,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(read_plan)",
          "old_line_content": "  if (!(quick_imerge= new QUICK_INDEX_MERGE_SELECT(param->thd, param->table)))",
          "new_line_content": "  DBUG_RETURN(read_plan);",
          "content_same": false
        },
        {
          "line": 9211,
          "old_api": null,
          "new_api": "key_cmp",
          "old_text": null,
          "new_text": "key_part->field->key_cmp(key, key_part->length)",
          "old_line_content": "*/",
          "new_line_content": "    if ((cmp=key_part->field->key_cmp(key, key_part->length)) < 0)",
          "content_same": false
        },
        {
          "line": 11265,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "    Lookup the maximal key of the group, and store it into this->record.",
          "new_line_content": "  DBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 7179,
          "old_api": null,
          "new_api": "rb_insert",
          "old_text": null,
          "new_text": "rb_insert(key)",
          "old_line_content": "*/",
          "new_line_content": "  SEL_ARG *root=rb_insert(key);\t\t\t// rebalance tree",
          "content_same": false
        },
        {
          "line": 5132,
          "old_api": null,
          "new_api": "make_quick",
          "old_text": null,
          "new_text": "*range_scan)->make_quick(param, FALSE, &quick_imerge->alloc)",
          "old_line_content": "QUICK_SELECT_I *TRP_ROR_INTERSECT::make_quick(PARAM *param,",
          "new_line_content": "          ((*range_scan)->make_quick(param, FALSE, &quick_imerge->alloc)))||",
          "content_same": false
        },
        {
          "line": 5133,
          "old_api": null,
          "new_api": "push_quick_back",
          "old_text": null,
          "new_text": "quick_imerge->push_quick_back(quick)",
          "old_line_content": "                                              bool retrieve_full_rows,",
          "new_line_content": "        quick_imerge->push_quick_back(quick))",
          "content_same": false
        },
        {
          "line": 9230,
          "old_api": null,
          "new_api": "key_cmp",
          "old_text": null,
          "new_text": "key_cmp(key_part_info, range_arg->min_key,\n               range_arg->min_length)",
          "old_line_content": " */",
          "new_line_content": "  cmp= key_cmp(key_part_info, range_arg->min_key,",
          "content_same": false
        },
        {
          "line": 11289,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::next_max\")",
          "old_line_content": "",
          "new_line_content": "  DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::next_max\");",
          "content_same": false
        },
        {
          "line": 11293,
          "old_api": null,
          "new_api": "next_max_in_range",
          "old_text": null,
          "new_text": "next_max_in_range()",
          "old_line_content": "  value.",
          "new_line_content": "    result= next_max_in_range();",
          "content_same": false
        },
        {
          "line": 5149,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"TRP_ROR_INTERSECT::make_quick\")",
          "old_line_content": "                                             first_scan, last_scan););",
          "new_line_content": "  DBUG_ENTER(\"TRP_ROR_INTERSECT::make_quick\");",
          "content_same": false
        },
        {
          "line": 11295,
          "old_api": null,
          "new_api": "index_read_map",
          "old_text": null,
          "new_text": "file->index_read_map(record, group_prefix,\n                                 make_prev_keypart_map(real_key_parts),\n                                 HA_READ_PREFIX_LAST)",
          "old_line_content": "  Implements a specialized loose index access method for queries ",
          "new_line_content": "    result= file->index_read_map(record, group_prefix,",
          "content_same": false
        },
        {
          "line": 11296,
          "old_api": null,
          "new_api": "make_prev_keypart_map",
          "old_text": null,
          "new_text": "make_prev_keypart_map(real_key_parts)",
          "old_line_content": "  containing aggregate functions with distinct of the form:",
          "new_line_content": "                                 make_prev_keypart_map(real_key_parts),",
          "content_same": false
        },
        {
          "line": 7201,
          "old_api": null,
          "new_api": "cmp_min_to_min",
          "old_text": null,
          "new_text": "element->cmp_min_to_min(key)",
          "old_line_content": "}",
          "new_line_content": "    int cmp=element->cmp_min_to_min(key);",
          "content_same": false
        },
        {
          "line": 11298,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "  This method comes to replace the index scan + Unique class ",
          "new_line_content": "  DBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 9254,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "str->append(key_info->name)",
          "old_line_content": "    if (!first)",
          "new_line_content": "  str->append(key_info->name);",
          "content_same": false
        },
        {
          "line": 5164,
          "old_api": null,
          "new_api": "get_quick_select",
          "old_text": null,
          "new_text": "get_quick_select(param, (*first_scan)->idx,\n                                    (*first_scan)->sel_arg, alloc)",
          "old_line_content": "                                    cpk_scan->sel_arg, alloc)))",
          "new_line_content": "      if (!(quick= get_quick_select(param, (*first_scan)->idx,",
          "content_same": false
        },
        {
          "line": 5166,
          "old_api": null,
          "new_api": "push_quick_back",
          "old_text": null,
          "new_text": "quick_intrsect->push_quick_back(quick)",
          "old_line_content": "        delete quick_intrsect;",
          "new_line_content": "          quick_intrsect->push_quick_back(quick))",
          "content_same": false
        },
        {
          "line": 5169,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "      quick->file= NULL; ",
          "new_line_content": "        DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 9266,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "str->append(',')",
          "old_line_content": "}",
          "new_line_content": "      str->append(',');",
          "content_same": false
        },
        {
          "line": 9269,
          "old_api": null,
          "new_api": "add_info_string",
          "old_text": null,
          "new_text": "quick->add_info_string(str)",
          "old_line_content": "{",
          "new_line_content": "    quick->add_info_string(str);",
          "content_same": false
        },
        {
          "line": 5174,
          "old_api": null,
          "new_api": "get_quick_select",
          "old_text": null,
          "new_text": "get_quick_select(param, cpk_scan->idx,\n                                    cpk_scan->sel_arg, alloc)",
          "old_line_content": "  }",
          "new_line_content": "      if (!(quick= get_quick_select(param, cpk_scan->idx,",
          "content_same": false
        },
        {
          "line": 9274,
          "old_api": null,
          "new_api": "add_info_string",
          "old_text": null,
          "new_text": "pk_quick_select->add_info_string(str)",
          "old_line_content": "  while ((quick= it++))",
          "new_line_content": "    pk_quick_select->add_info_string(str);",
          "content_same": false
        },
        {
          "line": 5178,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "",
          "new_line_content": "        DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 9276,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "str->append(')')",
          "old_line_content": "    KEY *key_info= head->key_info + quick->index;",
          "new_line_content": "  str->append(')');",
          "content_same": false
        },
        {
          "line": 3132,
          "old_api": null,
          "new_api": "check_stack_overrun",
          "old_text": null,
          "new_text": "check_stack_overrun(range_par->thd, 3*STACK_MIN_SIZE, NULL)",
          "old_line_content": "  ppar->cur_subpart_fields+= ppar->is_subpart_keypart[key_tree_part];",
          "new_line_content": "  if (check_stack_overrun(range_par->thd, 3*STACK_MIN_SIZE, NULL))",
          "content_same": false
        },
        {
          "line": 3137,
          "old_api": null,
          "new_api": "find_used_partitions",
          "old_text": null,
          "new_text": "find_used_partitions(ppar,key_tree->left)",
          "old_line_content": "    /*",
          "new_line_content": "    if (-1 == (left_res= find_used_partitions(ppar,key_tree->left)))",
          "content_same": false
        },
        {
          "line": 7234,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"tree_delete\")",
          "old_line_content": "  if (!key->parent)",
          "new_line_content": "  DBUG_ENTER(\"tree_delete\");",
          "content_same": false
        },
        {
          "line": 9284,
          "old_api": null,
          "new_api": "STRING_WITH_LEN",
          "old_text": null,
          "new_text": "STRING_WITH_LEN(\"intersect(\")",
          "old_line_content": "  {",
          "new_line_content": "  str->append(STRING_WITH_LEN(\"intersect(\"));",
          "content_same": false
        },
        {
          "line": 11337,
          "old_api": null,
          "new_api": "key_cmp (key_part, group_prefix, group_prefix_len)",
          "old_text": null,
          "new_text": "key_cmp (key_part, group_prefix, group_prefix_len)",
          "old_line_content": "                                HA_READ_AFTER_KEY);",
          "new_line_content": "    while (!key_cmp (key_part, group_prefix, group_prefix_len))",
          "content_same": false
        },
        {
          "line": 11339,
          "old_api": null,
          "new_api": "index_next",
          "old_text": null,
          "new_text": "file->index_next(record)",
          "old_line_content": "",
          "new_line_content": "      result= file->index_next(record);",
          "content_same": false
        },
        {
          "line": 9292,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "str->append(key_info->name)",
          "old_line_content": "void QUICK_ROR_UNION_SELECT::add_info_string(String *str)",
          "new_line_content": "    str->append(key_info->name);",
          "content_same": false
        },
        {
          "line": 7244,
          "old_api": null,
          "new_api": "increment_use_count",
          "old_text": null,
          "new_text": "key->increment_use_count(-1)",
          "old_line_content": "      nod->parent=fix_par;",
          "new_line_content": "  key->increment_use_count(-1);",
          "content_same": false
        },
        {
          "line": 7248,
          "old_api": null,
          "new_api": "parent_ptr",
          "old_text": null,
          "new_text": "key->parent_ptr()",
          "old_line_content": "  {",
          "new_line_content": "    par=key->parent_ptr();",
          "content_same": false
        },
        {
          "line": 9298,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "str->append(key_info->name)",
          "old_line_content": "  while ((quick= it++))",
          "new_line_content": "    str->append(key_info->name);",
          "content_same": false
        },
        {
          "line": 11346,
          "old_api": null,
          "new_api": "index_read_map",
          "old_text": null,
          "new_text": "file->index_read_map(record, group_prefix,\n                                make_prev_keypart_map(group_key_parts),\n                                HA_READ_AFTER_KEY)",
          "old_line_content": "",
          "new_line_content": "    return file->index_read_map(record, group_prefix,",
          "content_same": false
        },
        {
          "line": 9300,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "str->append(')')",
          "old_line_content": "    if (!first)",
          "new_line_content": "  str->append(')');",
          "content_same": false
        },
        {
          "line": 11347,
          "old_api": null,
          "new_api": "make_prev_keypart_map",
          "old_text": null,
          "new_text": "make_prev_keypart_map(group_key_parts)",
          "old_line_content": "  DESCRIPTION",
          "new_line_content": "                                make_prev_keypart_map(group_key_parts),",
          "content_same": false
        },
        {
          "line": 3157,
          "old_api": null,
          "new_api": "find_used_partitions",
          "old_text": null,
          "new_text": "find_used_partitions(ppar, key_tree->next_key_part)",
          "old_line_content": "      /* Collect left and right bound, their lengths and flags */",
          "new_line_content": "      res= find_used_partitions(ppar, key_tree->next_key_part);",
          "content_same": false
        },
        {
          "line": 5206,
          "old_api": null,
          "new_api": "make_quick",
          "old_text": null,
          "new_text": "*scan)->make_quick(param, FALSE, &quick_roru->alloc)",
          "old_line_content": "/*",
          "new_line_content": "      if (!(quick= (*scan)->make_quick(param, FALSE, &quick_roru->alloc)) ||",
          "content_same": false
        },
        {
          "line": 5207,
          "old_api": null,
          "new_api": "push_quick_back",
          "old_text": null,
          "new_text": "quick_roru->push_quick_back(quick)",
          "old_line_content": "  Build a SEL_TREE for <> or NOT BETWEEN predicate",
          "new_line_content": "          quick_roru->push_quick_back(quick))",
          "content_same": false
        },
        {
          "line": 5208,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": " ",
          "new_line_content": "        DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 9308,
          "old_api": null,
          "new_api": "STRING_WITH_LEN",
          "old_text": null,
          "new_text": "STRING_WITH_LEN(\"union(\")",
          "old_line_content": "",
          "new_line_content": "  str->append(STRING_WITH_LEN(\"union(\"));",
          "content_same": false
        },
        {
          "line": 5213,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(quick_roru)",
          "old_line_content": "      field       field in the predicate",
          "new_line_content": "  DBUG_RETURN(quick_roru);",
          "content_same": false
        },
        {
          "line": 9312,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "str->append(',')",
          "old_line_content": "{",
          "new_line_content": "      str->append(',');",
          "content_same": false
        },
        {
          "line": 9315,
          "old_api": null,
          "new_api": "add_info_string",
          "old_text": null,
          "new_text": "quick->add_info_string(str)",
          "old_line_content": "  KEY *key_info= head->key_info + index;",
          "new_line_content": "    quick->add_info_string(str);",
          "content_same": false
        },
        {
          "line": 7267,
          "old_api": null,
          "new_api": "parent_ptr",
          "old_text": null,
          "new_text": "tmp->parent_ptr()",
          "old_line_content": "    *par=tmp;",
          "new_line_content": "    nod= *tmp->parent_ptr()= tmp->right;\t// unlink tmp from tree",
          "content_same": false
        },
        {
          "line": 3173,
          "old_api": null,
          "new_api": "store_min",
          "old_text": null,
          "new_text": "key_tree->store_min(ppar->key[key_tree->part].store_length,\n                          &tmp_min_key, ppar->cur_min_flag)",
          "old_line_content": "          There are more key parts for partition pruning to handle",
          "new_line_content": "      key_tree->store_min(ppar->key[key_tree->part].store_length,",
          "content_same": false
        },
        {
          "line": 3175,
          "old_api": null,
          "new_api": "store_max",
          "old_text": null,
          "new_text": "key_tree->store_max(ppar->key[key_tree->part].store_length,\n                          &tmp_max_key, ppar->cur_max_flag)",
          "old_line_content": "          condition.",
          "new_line_content": "      key_tree->store_max(ppar->key[key_tree->part].store_length,",
          "content_same": false
        },
        {
          "line": 9327,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "key_names->append(key_info->name)",
          "old_line_content": "  QUICK_RANGE_SELECT *quick;",
          "new_line_content": "  key_names->append(key_info->name);",
          "content_same": false
        },
        {
          "line": 9328,
          "old_api": null,
          "new_api": "longlong2str",
          "old_text": null,
          "new_text": "longlong2str(max_used_key_length, buf, 10)",
          "old_line_content": "",
          "new_line_content": "  length= longlong2str(max_used_key_length, buf, 10) - buf;",
          "content_same": false
        },
        {
          "line": 9329,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "used_lengths->append(buf, length)",
          "old_line_content": "  List_iterator_fast<QUICK_RANGE_SELECT> it(quick_selects);",
          "new_line_content": "  used_lengths->append(buf, length);",
          "content_same": false
        },
        {
          "line": 11376,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::next_prefix\")",
          "old_line_content": "  else",
          "new_line_content": "  DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::next_prefix\");",
          "content_same": false
        },
        {
          "line": 7284,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "",
          "new_line_content": "    DBUG_RETURN(0);\t\t\t\t// Maybe root later",
          "content_same": false
        },
        {
          "line": 3189,
          "old_api": null,
          "new_api": "uint)(tmp_max_key - max_key)",
          "old_text": null,
          "new_text": "uint)(tmp_max_key - max_key)",
          "old_line_content": "          ",
          "new_line_content": "            (memcmp(min_key, max_key, (uint)(tmp_max_key - max_key)) == 0) &&",
          "content_same": false
        },
        {
          "line": 11381,
          "old_api": null,
          "new_api": "get_next_prefix",
          "old_text": null,
          "new_text": "quick_prefix_select->get_next_prefix(group_prefix_len,\n                                                      group_key_parts, \n                                                      cur_prefix)",
          "old_line_content": "      if (result)",
          "new_line_content": "    if ((result= quick_prefix_select->get_next_prefix(group_prefix_len,",
          "content_same": false
        },
        {
          "line": 7286,
          "old_api": null,
          "new_api": "rb_delete_fixup",
          "old_text": null,
          "new_text": "rb_delete_fixup(root,nod,fix_par)",
          "old_line_content": "",
          "new_line_content": "    root=rb_delete_fixup(root,nod,fix_par);",
          "content_same": false
        },
        {
          "line": 11384,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "    }",
          "new_line_content": "      DBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 5240,
          "old_api": null,
          "new_api": "get_mm_parts",
          "old_text": null,
          "new_text": "get_mm_parts(param, cond_func, field, Item_func::LT_FUNC,\n                     lt_value, cmp_type)",
          "old_line_content": "",
          "new_line_content": "  tree= get_mm_parts(param, cond_func, field, Item_func::LT_FUNC,",
          "content_same": false
        },
        {
          "line": 7287,
          "old_api": null,
          "new_api": "test_rb_tree",
          "old_text": null,
          "new_text": "test_rb_tree(root,root->parent)",
          "old_line_content": "static void left_rotate(SEL_ARG **root,SEL_ARG *leaf)",
          "new_line_content": "  test_rb_tree(root,root->parent);",
          "content_same": false
        },
        {
          "line": 5244,
          "old_api": null,
          "new_api": "get_mm_parts",
          "old_text": null,
          "new_text": "get_mm_parts(param, cond_func, field,\n\t\t\t\t\t    Item_func::GT_FUNC,\n\t\t\t\t\t    gt_value, cmp_type)",
          "old_line_content": "  SYNOPSIS",
          "new_line_content": "    tree= tree_or(param, tree, get_mm_parts(param, cond_func, field,",
          "content_same": false
        },
        {
          "line": 7292,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(root)",
          "old_line_content": "    y->left->parent=leaf;",
          "new_line_content": "  DBUG_RETURN(root);",
          "content_same": false
        },
        {
          "line": 11391,
          "old_api": null,
          "new_api": "index_first",
          "old_text": null,
          "new_text": "file->index_first(record)",
          "old_line_content": "      if (result)",
          "new_line_content": "      result= file->index_first(record);",
          "content_same": false
        },
        {
          "line": 3201,
          "old_api": null,
          "new_api": "find_used_partitions",
          "old_text": null,
          "new_text": "find_used_partitions(ppar, key_tree->next_key_part)",
          "old_line_content": "        uint tmp_min_flag= key_tree->min_flag,",
          "new_line_content": "          res= find_used_partitions(ppar, key_tree->next_key_part);",
          "content_same": false
        },
        {
          "line": 11393,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "    }",
          "new_line_content": "        DBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 9347,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "key_names->append(',')",
          "old_line_content": "    KEY *key_info= head->key_info + pk_quick_select->index;",
          "new_line_content": "      key_names->append(',');",
          "content_same": false
        },
        {
          "line": 11399,
          "old_api": null,
          "new_api": "index_next_different (is_index_scan, file, index_info->key_part,\n                            record, group_prefix, group_prefix_len, \n                            group_key_parts)",
          "old_text": null,
          "new_text": "index_next_different (is_index_scan, file, index_info->key_part,\n                            record, group_prefix, group_prefix_len, \n                            group_key_parts)",
          "old_line_content": "  if (key_infix_len > 0)",
          "new_line_content": "      result= index_next_different (is_index_scan, file, index_info->key_part,",
          "content_same": false
        },
        {
          "line": 9353,
          "old_api": null,
          "new_api": "longlong2str",
          "old_text": null,
          "new_text": "longlong2str(quick->max_used_key_length, buf, 10)",
          "old_line_content": "  }",
          "new_line_content": "    length= longlong2str(quick->max_used_key_length, buf, 10) - buf;",
          "content_same": false
        },
        {
          "line": 9354,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "used_lengths->append(buf, length)",
          "old_line_content": "}",
          "new_line_content": "    used_lengths->append(buf, length);",
          "content_same": false
        },
        {
          "line": 7307,
          "old_api": null,
          "new_api": "parent_ptr",
          "old_text": null,
          "new_text": "leaf->parent_ptr()",
          "old_line_content": "  if (!(y->parent=leaf->parent))",
          "new_line_content": "    *leaf->parent_ptr()=y;",
          "content_same": false
        },
        {
          "line": 9359,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "key_names->append(',')",
          "old_line_content": "  char buf[64];",
          "new_line_content": "    key_names->append(',');",
          "content_same": false
        },
        {
          "line": 9360,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "key_names->append(key_info->name)",
          "old_line_content": "  uint length;",
          "new_line_content": "    key_names->append(key_info->name);",
          "content_same": false
        },
        {
          "line": 9361,
          "old_api": null,
          "new_api": "longlong2str",
          "old_text": null,
          "new_text": "longlong2str(pk_quick_select->max_used_key_length, buf, 10)",
          "old_line_content": "  bool first= TRUE;",
          "new_line_content": "    length= longlong2str(pk_quick_select->max_used_key_length, buf, 10) - buf;",
          "content_same": false
        },
        {
          "line": 9362,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "used_lengths->append(',')",
          "old_line_content": "  QUICK_RANGE_SELECT *quick;",
          "new_line_content": "    used_lengths->append(',');",
          "content_same": false
        },
        {
          "line": 9363,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "used_lengths->append(buf, length)",
          "old_line_content": "  List_iterator_fast<QUICK_RANGE_SELECT> it(quick_selects);",
          "new_line_content": "    used_lengths->append(buf, length);",
          "content_same": false
        },
        {
          "line": 3215,
          "old_api": null,
          "new_api": "store_min_key",
          "old_text": null,
          "new_text": "key_tree->next_key_part->store_min_key(ppar->key,\n                                                 &tmp_min_key,\n                                                 &tmp_min_flag,\n                                                 ppar->last_part_partno)",
          "old_line_content": "      else",
          "new_line_content": "          key_tree->next_key_part->store_min_key(ppar->key,",
          "content_same": false
        },
        {
          "line": 11408,
          "old_api": null,
          "new_api": "key_copy",
          "old_text": null,
          "new_text": "key_copy(group_prefix, record, index_info, group_prefix_len)",
          "old_line_content": "  Find the minimal key in a group that satisfies some range conditions for the",
          "new_line_content": "  key_copy(group_prefix, record, index_info, group_prefix_len);",
          "content_same": false
        },
        {
          "line": 11411,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(group_prefix + group_prefix_len,\n           key_infix, key_infix_len)",
          "old_line_content": "  SYNOPSIS",
          "new_line_content": "    memcpy(group_prefix + group_prefix_len,",
          "content_same": false
        },
        {
          "line": 3220,
          "old_api": null,
          "new_api": "store_max_key",
          "old_text": null,
          "new_text": "key_tree->next_key_part->store_max_key(ppar->key,\n                                                 &tmp_max_key,\n                                                 &tmp_max_flag,\n                                                 ppar->last_part_partno)",
          "old_line_content": "      else",
          "new_line_content": "          key_tree->next_key_part->store_max_key(ppar->key,",
          "content_same": false
        },
        {
          "line": 11414,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "  DESCRIPTION",
          "new_line_content": "  DBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 7321,
          "old_api": null,
          "new_api": "parent_ptr",
          "old_text": null,
          "new_text": "leaf->parent_ptr()",
          "old_line_content": "",
          "new_line_content": "    *leaf->parent_ptr()=y;",
          "content_same": false
        },
        {
          "line": 5274,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"get_func_mm_tree\")",
          "old_line_content": "    {",
          "new_line_content": "  DBUG_ENTER(\"get_func_mm_tree\");",
          "content_same": false
        },
        {
          "line": 5276,
          "old_api": null,
          "new_api": "functype",
          "old_text": null,
          "new_text": "cond_func->functype()",
          "old_line_content": "      {",
          "new_line_content": "  switch (cond_func->functype()) {",
          "content_same": false
        },
        {
          "line": 5279,
          "old_api": null,
          "new_api": "get_ne_mm_tree",
          "old_text": null,
          "new_text": "get_ne_mm_tree(param, cond_func, field, value, value, cmp_type)",
          "old_line_content": "      }",
          "new_line_content": "    tree= get_ne_mm_tree(param, cond_func, field, value, value, cmp_type);",
          "content_same": false
        },
        {
          "line": 5289,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "cond_func->arguments()",
          "old_line_content": "                                                   cmp_type));",
          "new_line_content": "                             cond_func->arguments()[2], cmp_type);",
          "content_same": false
        },
        {
          "line": 7781,
          "old_api": null,
          "new_api": "uint) (tmp_max_key - param->max_key)",
          "old_text": null,
          "new_text": "uint) (tmp_max_key - param->max_key)",
          "old_line_content": "        param->key[idx][key_tree->part].length)",
          "new_line_content": "  max_key_length= (uint) (tmp_max_key - param->max_key);",
          "content_same": false
        },
        {
          "line": 9387,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "used_lengths->append(buf, length)",
          "old_line_content": "  }",
          "new_line_content": "    used_lengths->append(buf, length);",
          "content_same": false
        },
        {
          "line": 5293,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "get_mm_parts(param, cond_func, field, Item_func::GE_FUNC,\n\t\t           cond_func->arguments()[1],cmp_type)",
          "old_line_content": "    else",
          "new_line_content": "        tree= get_mm_parts(param, cond_func, field, Item_func::GE_FUNC,",
          "content_same": false
        },
        {
          "line": 9393,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "key_names->append(',')",
          "old_line_content": "  bool first= TRUE;",
          "new_line_content": "    key_names->append(',');",
          "content_same": false
        },
        {
          "line": 9394,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "key_names->append(key_info->name)",
          "old_line_content": "  QUICK_SELECT_I *quick;",
          "new_line_content": "    key_names->append(key_info->name);",
          "content_same": false
        },
        {
          "line": 9395,
          "old_api": null,
          "new_api": "longlong2str",
          "old_text": null,
          "new_text": "longlong2str(cpk_quick->max_used_key_length, buf, 10)",
          "old_line_content": "  List_iterator_fast<QUICK_SELECT_I> it(quick_selects);",
          "new_line_content": "    length= longlong2str(cpk_quick->max_used_key_length, buf, 10) - buf;",
          "content_same": false
        },
        {
          "line": 9396,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "used_lengths->append(',')",
          "old_line_content": "  while ((quick= it++))",
          "new_line_content": "    used_lengths->append(',');",
          "content_same": false
        },
        {
          "line": 9397,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "used_lengths->append(buf, length)",
          "old_line_content": "  {",
          "new_line_content": "    used_lengths->append(buf, length);",
          "content_same": false
        },
        {
          "line": 5297,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "get_mm_parts(param, cond_func, field,\n\t\t\t\t\t           Item_func::LE_FUNC,\n\t\t\t\t\t           cond_func->arguments()[2],\n                                                   cmp_type)",
          "old_line_content": "                                               Item_func::LT_FUNC):",
          "new_line_content": "          tree= tree_and(param, tree, get_mm_parts(param, cond_func, field,",
          "content_same": false
        },
        {
          "line": 5299,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "cond_func->arguments()",
          "old_line_content": "                                               Item_func::GE_FUNC)),",
          "new_line_content": "\t\t\t\t\t           cond_func->arguments()[2],",
          "content_same": false
        },
        {
          "line": 3256,
          "old_api": null,
          "new_api": "ppar->part_info->\n             get_part_iter_for_interval(ppar->part_info,\n                                        FALSE,\n                                        store_length_array,\n                                        range_par->min_key,\n                                        range_par->max_key,\n                                        tmp_min_key - range_par->min_key,\n                                        tmp_max_key - range_par->max_key,\n                                        flag,\n                                        &ppar->part_iter)",
          "old_text": null,
          "new_text": "ppar->part_info->\n             get_part_iter_for_interval(ppar->part_info,\n                                        FALSE,\n                                        store_length_array,\n                                        range_par->min_key,\n                                        range_par->max_key,\n                                        tmp_min_key - range_par->min_key,\n                                        tmp_max_key - range_par->max_key,\n                                        flag,\n                                        &ppar->part_iter)",
          "old_line_content": "          goto pop_and_go_right; /* res==0 --> no satisfying partitions */",
          "new_line_content": "        res= ppar->part_info->",
          "content_same": false
        },
        {
          "line": 5305,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "get_mm_parts(param, cond_func, field,\n                         (inv ?\n                          (value == (Item*)1 ? Item_func::GT_FUNC :\n                                               Item_func::LT_FUNC):\n                          (value == (Item*)1 ? Item_func::LE_FUNC :\n                                               Item_func::GE_FUNC)),\n                         cond_func->arguments()[0], cmp_type)",
          "old_line_content": "    Item_func_in *func=(Item_func_in*) cond_func;",
          "new_line_content": "      tree= get_mm_parts(param, cond_func, field,",
          "content_same": false
        },
        {
          "line": 7350,
          "old_api": null,
          "new_api": "left_rotate",
          "old_text": null,
          "new_text": "left_rotate(&root,leaf->parent)",
          "old_line_content": "      y= par2->left;",
          "new_line_content": "\t  left_rotate(&root,leaf->parent);",
          "content_same": false
        },
        {
          "line": 11451,
          "old_api": null,
          "new_api": "get_dynamic",
          "old_text": null,
          "new_text": "get_dynamic(&min_max_ranges, (uchar*)&cur_range, range_idx)",
          "old_line_content": "    if (cur_range->flag & NO_MIN_RANGE)",
          "new_line_content": "    get_dynamic(&min_max_ranges, (uchar*)&cur_range, range_idx);",
          "content_same": false
        },
        {
          "line": 7355,
          "old_api": null,
          "new_api": "right_rotate",
          "old_text": null,
          "new_text": "right_rotate(&root,par2)",
          "old_line_content": "\tleaf=par2;",
          "new_line_content": "\tright_rotate(&root,par2);",
          "content_same": false
        },
        {
          "line": 5311,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "cond_func->arguments()",
          "old_line_content": "    */",
          "new_line_content": "                         cond_func->arguments()[0], cmp_type);",
          "content_same": false
        },
        {
          "line": 11458,
          "old_api": null,
          "new_api": "key_cmp",
          "old_text": null,
          "new_text": "key_cmp(min_max_arg_part, (const uchar*) cur_range->max_key,\n                 min_max_arg_len)",
          "old_line_content": "      /* Extend the search key with the lower boundary for this range. */",
          "new_line_content": "        (key_cmp(min_max_arg_part, (const uchar*) cur_range->max_key,",
          "content_same": false
        },
        {
          "line": 9413,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "used_lengths->append(',')",
          "old_line_content": "",
          "new_line_content": "      used_lengths->append(',');",
          "content_same": false
        },
        {
          "line": 9414,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "key_names->append(',')",
          "old_line_content": "static inline uint get_field_keypart(KEY *index, Field *field);",
          "new_line_content": "      key_names->append(',');",
          "content_same": false
        },
        {
          "line": 9416,
          "old_api": null,
          "new_api": "add_keys_and_lengths",
          "old_text": null,
          "new_text": "quick->add_keys_and_lengths(key_names, used_lengths)",
          "old_line_content": "                                             PARAM *param, uint *param_idx);",
          "new_line_content": "    quick->add_keys_and_lengths(key_names, used_lengths);",
          "content_same": false
        },
        {
          "line": 11464,
          "old_api": null,
          "new_api": "make_prev_keypart_map",
          "old_text": null,
          "new_text": "make_prev_keypart_map(real_key_parts)",
          "old_line_content": "                 HA_READ_AFTER_KEY : HA_READ_KEY_OR_NEXT;",
          "new_line_content": "      keypart_map= make_prev_keypart_map(real_key_parts);",
          "content_same": false
        },
        {
          "line": 3275,
          "old_api": null,
          "new_api": "init_all_partitions_iterator",
          "old_text": null,
          "new_text": "init_all_partitions_iterator(ppar->part_info, &ppar->part_iter)",
          "old_line_content": "        */",
          "new_line_content": "        init_all_partitions_iterator(ppar->part_info, &ppar->part_iter);",
          "content_same": false
        },
        {
          "line": 11470,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(group_prefix + real_prefix_len, cur_range->min_key,\n             cur_range->min_length)",
          "old_line_content": "      if ((result == HA_ERR_KEY_NOT_FOUND || result == HA_ERR_END_OF_FILE) &&",
          "new_line_content": "      memcpy(group_prefix + real_prefix_len, cur_range->min_key,",
          "content_same": false
        },
        {
          "line": 11472,
          "old_api": null,
          "new_api": "make_keypart_map",
          "old_text": null,
          "new_text": "make_keypart_map(real_key_parts)",
          "old_line_content": "        continue; /* Check the next range. */",
          "new_line_content": "      keypart_map= make_keypart_map(real_key_parts);",
          "content_same": false
        },
        {
          "line": 5328,
          "old_api": null,
          "new_api": "result_type",
          "old_text": null,
          "new_text": "func->array->result_type()",
          "old_line_content": "          The most straightforward way to produce it is to convert NOT IN",
          "new_line_content": "      if (func->array && func->array->result_type() != ROW_RESULT)",
          "content_same": false
        },
        {
          "line": 7378,
          "old_api": null,
          "new_api": "left_rotate",
          "old_text": null,
          "new_text": "left_rotate(&root,par2)",
          "old_line_content": "SEL_ARG *rb_delete_fixup(SEL_ARG *root,SEL_ARG *key,SEL_ARG *par)",
          "new_line_content": "\tleft_rotate(&root,par2);",
          "content_same": false
        },
        {
          "line": 11478,
          "old_api": null,
          "new_api": "index_read_map",
          "old_text": null,
          "new_text": "file->index_read_map(record, group_prefix, keypart_map, find_flag)",
          "old_line_content": "      */",
          "new_line_content": "    result= file->index_read_map(record, group_prefix, keypart_map, find_flag);",
          "content_same": false
        },
        {
          "line": 7384,
          "old_api": null,
          "new_api": "test_rb_tree",
          "old_text": null,
          "new_text": "test_rb_tree(root,root->parent)",
          "old_line_content": "  while (x != root && x->color == SEL_ARG::BLACK)",
          "new_line_content": "  test_rb_tree(root,root->parent);",
          "content_same": false
        },
        {
          "line": 3298,
          "old_api": null,
          "new_api": "dbug_print_segment_range",
          "old_text": null,
          "new_text": "dbug_print_segment_range(key_tree,\n                                                    range_par->key_parts)",
          "old_line_content": "                                         &subpart_iter);",
          "new_line_content": "      DBUG_EXECUTE(\"info\", dbug_print_segment_range(key_tree,",
          "content_same": false
        },
        {
          "line": 3300,
          "old_api": null,
          "new_api": "ppar->part_info->\n           get_subpart_iter_for_interval(ppar->part_info,\n                                         TRUE,\n                                         NULL, /* Currently not used here */\n                                         key_tree->min_value, \n                                         key_tree->max_value,\n                                         0, 0, /* Those are ignored here */\n                                         key_tree->min_flag |\n                                           key_tree->max_flag,\n                                         &subpart_iter)",
          "old_text": null,
          "new_text": "ppar->part_info->\n           get_subpart_iter_for_interval(ppar->part_info,\n                                         TRUE,\n                                         NULL, /* Currently not used here */\n                                         key_tree->min_value, \n                                         key_tree->max_value,\n                                         0, 0, /* Those are ignored here */\n                                         key_tree->min_flag |\n                                           key_tree->max_flag,\n                                         &subpart_iter)",
          "old_line_content": "      {",
          "new_line_content": "      res= ppar->part_info->",
          "content_same": false
        },
        {
          "line": 7404,
          "old_api": null,
          "new_api": "left_rotate",
          "old_text": null,
          "new_text": "left_rotate(&root,par)",
          "old_line_content": "\t{",
          "new_line_content": "\tleft_rotate(&root,par);",
          "content_same": false
        },
        {
          "line": 11503,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(tmp_record, record, head->s->rec_buff_length)",
          "old_line_content": "",
          "new_line_content": "      memcpy(tmp_record, record, head->s->rec_buff_length);",
          "content_same": false
        },
        {
          "line": 7418,
          "old_api": null,
          "new_api": "right_rotate",
          "old_text": null,
          "new_text": "right_rotate(&root,w)",
          "old_line_content": "    else",
          "new_line_content": "\t  right_rotate(&root,w);",
          "content_same": false
        },
        {
          "line": 3327,
          "old_api": null,
          "new_api": "bitmap_set_bit",
          "old_text": null,
          "new_text": "bitmap_set_bit(&ppar->subparts_bitmap, subpart_id)",
          "old_line_content": "      }",
          "new_line_content": "        bitmap_set_bit(&ppar->subparts_bitmap, subpart_id);",
          "content_same": false
        },
        {
          "line": 11519,
          "old_api": null,
          "new_api": "my_alloca",
          "old_text": null,
          "new_text": "my_alloca(real_prefix_len + min_max_arg_len)",
          "old_line_content": "        the key is greater than the maximum",
          "new_line_content": "      uchar *max_key= (uchar*) my_alloca(real_prefix_len + min_max_arg_len);",
          "content_same": false
        },
        {
          "line": 11520,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(max_key, group_prefix, real_prefix_len)",
          "old_line_content": "      */",
          "new_line_content": "      memcpy(max_key, group_prefix, real_prefix_len);",
          "content_same": false
        },
        {
          "line": 11521,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(max_key + real_prefix_len, cur_range->max_key,\n             cur_range->max_length)",
          "old_line_content": "      if (((cur_range->flag & NEAR_MAX) && cmp_res == 0) ||",
          "new_line_content": "      memcpy(max_key + real_prefix_len, cur_range->max_key,",
          "content_same": false
        },
        {
          "line": 5378,
          "old_api": null,
          "new_api": "value_to_item",
          "old_text": null,
          "new_text": "func->array->value_to_item(i, value_item)",
          "old_line_content": "          tree= NULL;",
          "new_line_content": "          func->array->value_to_item(i, value_item);",
          "content_same": false
        },
        {
          "line": 11524,
          "old_api": null,
          "new_api": "key_cmp",
          "old_text": null,
          "new_text": "key_cmp(index_info->key_part, max_key,\n                           real_prefix_len + min_max_arg_len)",
          "old_line_content": "        result= HA_ERR_KEY_NOT_FOUND;",
          "new_line_content": "      int cmp_res= key_cmp(index_info->key_part, max_key,",
          "content_same": false
        },
        {
          "line": 5379,
          "old_api": null,
          "new_api": "get_mm_parts",
          "old_text": null,
          "new_text": "get_mm_parts(param, cond_func, field, Item_func::LT_FUNC,\n                             value_item, cmp_type)",
          "old_line_content": "          break;",
          "new_line_content": "          tree= get_mm_parts(param, cond_func, field, Item_func::LT_FUNC,",
          "content_same": false
        },
        {
          "line": 7424,
          "old_api": null,
          "new_api": "left_rotate",
          "old_text": null,
          "new_text": "left_rotate(&root,par)",
          "old_line_content": "\tpar->color=SEL_ARG::RED;",
          "new_line_content": "\tleft_rotate(&root,par);",
          "content_same": false
        },
        {
          "line": 3335,
          "old_api": null,
          "new_api": "bitmap_is_set",
          "old_text": null,
          "new_text": "bitmap_is_set(&ppar->subparts_bitmap, i)",
          "old_line_content": "          ppar->part_info->get_part_iter_for_interval == NULL)",
          "new_line_content": "          if (bitmap_is_set(&ppar->subparts_bitmap, i))",
          "content_same": false
        },
        {
          "line": 3336,
          "old_api": null,
          "new_api": "bitmap_set_bit",
          "old_text": null,
          "new_text": "bitmap_set_bit(&ppar->part_info->used_partitions,\n                           part_id * ppar->part_info->num_subparts + i)",
          "old_line_content": "      {",
          "new_line_content": "            bitmap_set_bit(&ppar->part_info->used_partitions,",
          "content_same": false
        },
        {
          "line": 7436,
          "old_api": null,
          "new_api": "right_rotate",
          "old_text": null,
          "new_text": "right_rotate(&root,par)",
          "old_line_content": "\t{",
          "new_line_content": "\tright_rotate(&root,par);",
          "content_same": false
        },
        {
          "line": 5395,
          "old_api": null,
          "new_api": "compare_elems",
          "old_text": null,
          "new_text": "func->array->compare_elems(i, i-1)",
          "old_line_content": "",
          "new_line_content": "          if (func->array->compare_elems(i, i-1))",
          "content_same": false
        },
        {
          "line": 11540,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(result == 0)",
          "old_line_content": "    result= 0;",
          "new_line_content": "    DBUG_ASSERT(result == 0);",
          "content_same": false
        },
        {
          "line": 5398,
          "old_api": null,
          "new_api": "value_to_item",
          "old_text": null,
          "new_text": "func->array->value_to_item(i, value_item)",
          "old_line_content": "            {",
          "new_line_content": "            func->array->value_to_item(i, value_item);",
          "content_same": false
        },
        {
          "line": 5399,
          "old_api": null,
          "new_api": "get_mm_parts",
          "old_text": null,
          "new_text": "get_mm_parts(param, cond_func, field, Item_func::LT_FUNC,\n                                value_item, cmp_type)",
          "old_line_content": "              SEL_ARG *new_interval, *last_val;",
          "new_line_content": "            tree2= get_mm_parts(param, cond_func, field, Item_func::LT_FUNC,",
          "content_same": false
        },
        {
          "line": 3352,
          "old_api": null,
          "new_api": "store_selargs_to_rec",
          "old_text": null,
          "new_text": "store_selargs_to_rec(ppar, ppar->arg_stack, ppar->part_fields)",
          "old_line_content": "        }",
          "new_line_content": "        store_selargs_to_rec(ppar, ppar->arg_stack, ppar->part_fields);",
          "content_same": false
        },
        {
          "line": 3353,
          "old_api": null,
          "new_api": "dbug_print_singlepoint_range",
          "old_text": null,
          "new_text": "dbug_print_singlepoint_range(ppar->arg_stack,\n                                                       ppar->part_fields)",
          "old_line_content": "        /* Rembember the limit we got - single partition #part_id */",
          "new_line_content": "        DBUG_EXECUTE(\"info\", dbug_print_singlepoint_range(ppar->arg_stack,",
          "content_same": false
        },
        {
          "line": 7450,
          "old_api": null,
          "new_api": "left_rotate",
          "old_text": null,
          "new_text": "left_rotate(&root,w)",
          "old_line_content": "    par=x->parent;",
          "new_line_content": "\t  left_rotate(&root,w);",
          "content_same": false
        },
        {
          "line": 3358,
          "old_api": null,
          "new_api": "get_top_partition_id_func",
          "old_text": null,
          "new_text": "ppar->get_top_partition_id_func(ppar->part_info, &part_id,\n                                            &func_value)",
          "old_line_content": "          then we'll mark full partition as used. ",
          "new_line_content": "        if (ppar->get_top_partition_id_func(ppar->part_info, &part_id,",
          "content_same": false
        },
        {
          "line": 11550,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(record, tmp_record, head->s->rec_buff_length)",
          "old_line_content": "  SYNOPSIS",
          "new_line_content": "    memcpy(record, tmp_record, head->s->rec_buff_length);",
          "content_same": false
        },
        {
          "line": 7456,
          "old_api": null,
          "new_api": "right_rotate",
          "old_text": null,
          "new_text": "right_rotate(&root,par)",
          "old_line_content": "",
          "new_line_content": "\tright_rotate(&root,par);",
          "content_same": false
        },
        {
          "line": 3365,
          "old_api": null,
          "new_api": "init_single_partition_iterator",
          "old_text": null,
          "new_text": "init_single_partition_iterator(part_id, &ppar->part_iter)",
          "old_line_content": "          ppar->cur_subpart_fields == ppar->subpart_fields)",
          "new_line_content": "        init_single_partition_iterator(part_id, &ppar->part_iter);",
          "content_same": false
        },
        {
          "line": 5413,
          "old_api": null,
          "new_api": "last",
          "old_text": null,
          "new_text": "tree->keys[idx]->last()",
          "old_line_content": "                  and an index with definition",
          "new_line_content": "                  ((last_val= tree->keys[idx]->last())))",
          "content_same": false
        },
        {
          "line": 3382,
          "old_api": null,
          "new_api": "store_selargs_to_rec",
          "old_text": null,
          "new_text": "store_selargs_to_rec(ppar, ppar->arg_stack_end - ppar->subpart_fields,\n                             ppar->subpart_fields)",
          "old_line_content": "",
          "new_line_content": "        store_selargs_to_rec(ppar, ppar->arg_stack_end - ppar->subpart_fields,",
          "content_same": false
        },
        {
          "line": 7479,
          "old_api": null,
          "new_api": "sql_print_error",
          "old_text": null,
          "new_text": "sql_print_error(\"Wrong tree: Parent doesn't point at parent\")",
          "old_line_content": "  {\t\t\t\t\t\t// Dummy test",
          "new_line_content": "    sql_print_error(\"Wrong tree: Parent doesn't point at parent\");",
          "content_same": false
        },
        {
          "line": 7486,
          "old_api": null,
          "new_api": "sql_print_error",
          "old_text": null,
          "new_text": "sql_print_error(\"Wrong tree: Found two red in a row\")",
          "old_line_content": "  {",
          "new_line_content": "    sql_print_error(\"Wrong tree: Found two red in a row\");",
          "content_same": false
        },
        {
          "line": 3391,
          "old_api": null,
          "new_api": "get_subpartition_id",
          "old_text": null,
          "new_text": "part_info->get_subpartition_id(part_info, &subpart_id)",
          "old_line_content": "        goto pop_and_go_right;",
          "new_line_content": "        if (part_info->get_subpartition_id(part_info, &subpart_id))",
          "content_same": false
        },
        {
          "line": 11585,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(min_max_ranges.elements > 0)",
          "old_line_content": "        !(cur_range->flag & NO_MIN_RANGE) &&",
          "new_line_content": "  DBUG_ASSERT(min_max_ranges.elements > 0);",
          "content_same": false
        },
        {
          "line": 3395,
          "old_api": null,
          "new_api": "get_next",
          "old_text": null,
          "new_text": "ppar->part_iter.get_next(&ppar->part_iter)",
          "old_line_content": "    {",
          "new_line_content": "        while ((part_id= ppar->part_iter.get_next(&ppar->part_iter)) !=",
          "content_same": false
        },
        {
          "line": 7491,
          "old_api": null,
          "new_api": "sql_print_error",
          "old_text": null,
          "new_text": "sql_print_error(\"Wrong tree: Found right == left\")",
          "old_line_content": "  }",
          "new_line_content": "    sql_print_error(\"Wrong tree: Found right == left\");",
          "content_same": false
        },
        {
          "line": 11589,
          "old_api": null,
          "new_api": "get_dynamic",
          "old_text": null,
          "new_text": "get_dynamic(&min_max_ranges, (uchar*)&cur_range, range_idx - 1)",
          "old_line_content": "",
          "new_line_content": "    get_dynamic(&min_max_ranges, (uchar*)&cur_range, range_idx - 1);",
          "content_same": false
        },
        {
          "line": 3398,
          "old_api": null,
          "new_api": "bitmap_set_bit",
          "old_text": null,
          "new_text": "bitmap_set_bit(&part_info->used_partitions,\n                         part_id * part_info->num_subparts + subpart_id)",
          "old_line_content": "        we're processing subpartititoning's key parts, this means we'll not be",
          "new_line_content": "          bitmap_set_bit(&part_info->used_partitions,",
          "content_same": false
        },
        {
          "line": 7494,
          "old_api": null,
          "new_api": "test_rb_tree",
          "old_text": null,
          "new_text": "test_rb_tree(element->left,element)",
          "old_line_content": "",
          "new_line_content": "  count_l=test_rb_tree(element->left,element);",
          "content_same": false
        },
        {
          "line": 7495,
          "old_api": null,
          "new_api": "test_rb_tree",
          "old_text": null,
          "new_text": "test_rb_tree(element->right,element)",
          "old_line_content": "",
          "new_line_content": "  count_r=test_rb_tree(element->right,element);",
          "content_same": false
        },
        {
          "line": 5451,
          "old_api": null,
          "new_api": "tree_or",
          "old_text": null,
          "new_text": "tree_or(param, tree, tree2)",
          "old_line_content": "                              value_item, cmp_type);",
          "new_line_content": "            tree= tree_or(param, tree, tree2);",
          "content_same": false
        },
        {
          "line": 7500,
          "old_api": null,
          "new_api": "sql_print_error",
          "old_text": null,
          "new_text": "sql_print_error(\"Wrong tree: Incorrect black-count: %d - %d\",\n\t    count_l,count_r)",
          "old_line_content": "  @param root  An RB-Root node in a SEL_ARG graph.",
          "new_line_content": "    sql_print_error(\"Wrong tree: Incorrect black-count: %d - %d\",",
          "content_same": false
        },
        {
          "line": 11597,
          "old_api": null,
          "new_api": "key_cmp",
          "old_text": null,
          "new_text": "key_cmp(min_max_arg_part, (const uchar*) cur_range->min_key,\n                 min_max_arg_len)",
          "old_line_content": "      /* Extend the search key with the upper boundary for this range. */",
          "new_line_content": "        (key_cmp(min_max_arg_part, (const uchar*) cur_range->min_key,",
          "content_same": false
        },
        {
          "line": 11603,
          "old_api": null,
          "new_api": "make_prev_keypart_map",
          "old_text": null,
          "new_text": "make_prev_keypart_map(real_key_parts)",
          "old_line_content": "                 HA_READ_BEFORE_KEY : HA_READ_PREFIX_LAST_OR_PREV;",
          "new_line_content": "      keypart_map= make_prev_keypart_map(real_key_parts);",
          "content_same": false
        },
        {
          "line": 5461,
          "old_api": null,
          "new_api": "get_mm_parts",
          "old_text": null,
          "new_text": "get_mm_parts(param, cond_func, field, Item_func::GT_FUNC,\n                              value_item, cmp_type)",
          "old_line_content": "        {",
          "new_line_content": "          tree2= get_mm_parts(param, cond_func, field, Item_func::GT_FUNC,",
          "content_same": false
        },
        {
          "line": 11609,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(group_prefix + real_prefix_len, cur_range->max_key,\n             cur_range->max_length)",
          "old_line_content": "    {",
          "new_line_content": "      memcpy(group_prefix + real_prefix_len, cur_range->max_key,",
          "content_same": false
        },
        {
          "line": 11611,
          "old_api": null,
          "new_api": "make_keypart_map",
          "old_text": null,
          "new_text": "make_keypart_map(real_key_parts)",
          "old_line_content": "          (cur_range->flag & EQ_RANGE))",
          "new_line_content": "      keypart_map= make_keypart_map(real_key_parts);",
          "content_same": false
        },
        {
          "line": 5468,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "get_ne_mm_tree(param, cond_func, field,\n                             func->arguments()[1], func->arguments()[1],\n                             cmp_type)",
          "old_line_content": "          }",
          "new_line_content": "        tree= get_ne_mm_tree(param, cond_func, field,",
          "content_same": false
        },
        {
          "line": 5469,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "func->arguments()",
          "old_line_content": "        }",
          "new_line_content": "                             func->arguments()[1], func->arguments()[1],",
          "content_same": false
        },
        {
          "line": 11617,
          "old_api": null,
          "new_api": "index_read_map",
          "old_text": null,
          "new_text": "file->index_read_map(record, group_prefix, keypart_map, find_flag)",
          "old_line_content": "      */",
          "new_line_content": "    result= file->index_read_map(record, group_prefix, keypart_map, find_flag);",
          "content_same": false
        },
        {
          "line": 3429,
          "old_api": null,
          "new_api": "find_used_partitions",
          "old_text": null,
          "new_text": "find_used_partitions(ppar, key_tree->next_key_part)",
          "old_line_content": "    */",
          "new_line_content": "    res= find_used_partitions(ppar, key_tree->next_key_part);",
          "content_same": false
        },
        {
          "line": 5477,
          "old_api": null,
          "new_api": "get_ne_mm_tree",
          "old_text": null,
          "new_text": "get_ne_mm_tree(param, cond_func, field, \n                                                        *arg, *arg, cmp_type)",
          "old_line_content": "      {",
          "new_line_content": "            tree=  tree_and(param, tree, get_ne_mm_tree(param, cond_func, field, ",
          "content_same": false
        },
        {
          "line": 5485,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "get_mm_parts(param, cond_func, field, Item_func::EQ_FUNC,\n                         func->arguments()[1], cmp_type)",
          "old_line_content": "        }",
          "new_line_content": "      tree= get_mm_parts(param, cond_func, field, Item_func::EQ_FUNC,",
          "content_same": false
        },
        {
          "line": 5486,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "func->arguments()",
          "old_line_content": "      }",
          "new_line_content": "                         func->arguments()[1], cmp_type);",
          "content_same": false
        },
        {
          "line": 5490,
          "old_api": null,
          "new_api": "argument_count",
          "old_text": null,
          "new_text": "func->argument_count()",
          "old_line_content": "  default: ",
          "new_line_content": "        for (arg= func->arguments()+2, end= arg+func->argument_count()-2;",
          "content_same": false
        },
        {
          "line": 11636,
          "old_api": null,
          "new_api": "key_cmp",
          "old_text": null,
          "new_text": "key_cmp(index_info->key_part, group_prefix, real_prefix_len)",
          "old_line_content": "      /* Compare the found key with min_key. */",
          "new_line_content": "    if (key_cmp(index_info->key_part, group_prefix, real_prefix_len))",
          "content_same": false
        },
        {
          "line": 5493,
          "old_api": null,
          "new_api": "get_mm_parts",
          "old_text": null,
          "new_text": "get_mm_parts(param, cond_func, field, \n                                                  Item_func::EQ_FUNC,\n                                                  *arg, cmp_type)",
          "old_line_content": "       Here the function for the following predicates are processed:",
          "new_line_content": "          tree= tree_or(param, tree, get_mm_parts(param, cond_func, field, ",
          "content_same": false
        },
        {
          "line": 3450,
          "old_api": null,
          "new_api": "get_next",
          "old_text": null,
          "new_text": "ppar->part_iter.get_next(&ppar->part_iter)",
          "old_line_content": "    */",
          "new_line_content": "      while ((part_id= ppar->part_iter.get_next(&ppar->part_iter)) !=",
          "content_same": false
        },
        {
          "line": 11643,
          "old_api": null,
          "new_api": "my_alloca",
          "old_text": null,
          "new_text": "my_alloca(real_prefix_len + min_max_arg_len)",
          "old_line_content": "        the key is less than the minimum",
          "new_line_content": "      uchar *min_key= (uchar*) my_alloca(real_prefix_len + min_max_arg_len);",
          "content_same": false
        },
        {
          "line": 11644,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(min_key, group_prefix, real_prefix_len)",
          "old_line_content": "      */",
          "new_line_content": "      memcpy(min_key, group_prefix, real_prefix_len);",
          "content_same": false
        },
        {
          "line": 3453,
          "old_api": null,
          "new_api": "mark_full_partition_used",
          "old_text": null,
          "new_text": "ppar->mark_full_partition_used(ppar->part_info, part_id)",
          "old_line_content": "",
          "new_line_content": "        ppar->mark_full_partition_used(ppar->part_info, part_id);",
          "content_same": false
        },
        {
          "line": 11645,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(min_key + real_prefix_len, cur_range->min_key,\n             cur_range->min_length)",
          "old_line_content": "      if (((cur_range->flag & NEAR_MIN) && cmp_res == 0) ||",
          "new_line_content": "      memcpy(min_key + real_prefix_len, cur_range->min_key,",
          "content_same": false
        },
        {
          "line": 3456,
          "old_api": null,
          "new_api": "test",
          "old_text": null,
          "new_text": "test(found)",
          "old_line_content": "  ppar->arg_stack_end--;",
          "new_line_content": "      res= test(found);",
          "content_same": false
        },
        {
          "line": 11648,
          "old_api": null,
          "new_api": "key_cmp",
          "old_text": null,
          "new_text": "key_cmp(index_info->key_part, min_key,\n                           real_prefix_len + min_max_arg_len)",
          "old_line_content": "    }",
          "new_line_content": "      int cmp_res= key_cmp(index_info->key_part, min_key,",
          "content_same": false
        },
        {
          "line": 7552,
          "old_api": null,
          "new_api": "first",
          "old_text": null,
          "new_text": "root->first()",
          "old_line_content": "}",
          "new_line_content": "  for (root=root->first(); root ; root=root->next)",
          "content_same": false
        },
        {
          "line": 3462,
          "old_api": null,
          "new_api": "init_all_partitions_iterator",
          "old_text": null,
          "new_text": "init_all_partitions_iterator(ppar->part_info, &ppar->part_iter)",
          "old_line_content": "  if (key_tree->right != &null_element)",
          "new_line_content": "    init_all_partitions_iterator(ppar->part_info, &ppar->part_iter);",
          "content_same": false
        },
        {
          "line": 5511,
          "old_api": null,
          "new_api": "functype",
          "old_text": null,
          "new_text": "cond_func->functype()",
          "old_line_content": "  Build conjunction of all SEL_TREEs for a simple predicate applying equalities",
          "new_line_content": "      (value != cond_func->arguments()[0]) ? cond_func->functype() :",
          "content_same": false
        },
        {
          "line": 5512,
          "old_api": null,
          "new_api": "rev_functype",
          "old_text": null,
          "new_text": "(Item_bool_func2*) cond_func)->rev_functype()",
          "old_line_content": " ",
          "new_line_content": "        ((Item_bool_func2*) cond_func)->rev_functype();",
          "content_same": false
        },
        {
          "line": 5513,
          "old_api": null,
          "new_api": "get_mm_parts",
          "old_text": null,
          "new_text": "get_mm_parts(param, cond_func, field, func_type, value, cmp_type)",
          "old_line_content": "  SYNOPSIS",
          "new_line_content": "    tree= get_mm_parts(param, cond_func, field, func_type, value, cmp_type);",
          "content_same": false
        },
        {
          "line": 7559,
          "old_api": null,
          "new_api": "count_key_part_usage",
          "old_text": null,
          "new_text": "count_key_part_usage(root->next_key_part,key)",
          "old_line_content": "    SEL_ARG::test_use_count()",
          "new_line_content": "\tcount+=count_key_part_usage(root->next_key_part,key);",
          "content_same": false
        },
        {
          "line": 5517,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(tree)",
          "old_line_content": "      field_item  field in the predicate",
          "new_line_content": "  DBUG_RETURN(tree);",
          "content_same": false
        },
        {
          "line": 9614,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"get_best_group_min_max\")",
          "old_line_content": "  /* Check (SA1,SA4) and store the only MIN/MAX argument - the C attribute.*/",
          "new_line_content": "  DBUG_ENTER(\"get_best_group_min_max\");",
          "content_same": false
        },
        {
          "line": 9618,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "  List_iterator<Item> select_items_it(join->fields_list);",
          "new_line_content": "    DBUG_RETURN(NULL);        /* This is not a select statement. */",
          "content_same": false
        },
        {
          "line": 3475,
          "old_api": null,
          "new_api": "find_used_partitions",
          "old_text": null,
          "new_text": "find_used_partitions(ppar,key_tree->right)",
          "old_line_content": "",
          "new_line_content": "    if (-1 == (right_res= find_used_partitions(ppar,key_tree->right)))",
          "content_same": false
        },
        {
          "line": 9621,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "  if ((!join->group_list) && /* Neither GROUP BY nor a DISTINCT query. */",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 9623,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "      !is_agg_distinct)",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 9626,
          "old_api": null,
          "new_api": "make_sum_func_list",
          "old_text": null,
          "new_text": "join->make_sum_func_list(join->all_fields, join->fields_list, 1)",
          "old_line_content": "",
          "new_line_content": "  if (join->make_sum_func_list(join->all_fields, join->fields_list, 1))",
          "content_same": false
        },
        {
          "line": 9627,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "  if (join->sum_funcs[0])",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 3484,
          "old_api": null,
          "new_api": "bitmap_set_all",
          "old_text": null,
          "new_text": "bitmap_set_all(&part_info->used_partitions)",
          "old_line_content": "  DESCRIPTION",
          "new_line_content": "  bitmap_set_all(&part_info->used_partitions);",
          "content_same": false
        },
        {
          "line": 9630,
          "old_api": null,
          "new_api": "is_indexed_agg_distinct",
          "old_text": null,
          "new_text": "is_indexed_agg_distinct(join, &agg_distinct_flds)",
          "old_line_content": "    Item_sum **func_ptr= join->sum_funcs;",
          "new_line_content": "  is_agg_distinct = is_indexed_agg_distinct(join, &agg_distinct_flds);",
          "content_same": false
        },
        {
          "line": 7585,
          "old_api": null,
          "new_api": "sql_print_information",
          "old_text": null,
          "new_text": "sql_print_information(\"Use_count: Wrong count %lu for root\",use_count)",
          "old_line_content": "      if (count > pos->next_key_part->use_count)",
          "new_line_content": "    sql_print_information(\"Use_count: Wrong count %lu for root\",use_count);",
          "content_same": false
        },
        {
          "line": 7590,
          "old_api": null,
          "new_api": "first",
          "old_text": null,
          "new_text": "first()",
          "old_line_content": "\treturn;",
          "new_line_content": "  for (SEL_ARG *pos=first(); pos ; pos=pos->next)",
          "content_same": false
        },
        {
          "line": 7595,
          "old_api": null,
          "new_api": "count_key_part_usage",
          "old_text": null,
          "new_text": "count_key_part_usage(root,pos->next_key_part)",
          "old_line_content": "  if (e_count != elements)",
          "new_line_content": "      ulong count=count_key_part_usage(root,pos->next_key_part);",
          "content_same": false
        },
        {
          "line": 9644,
          "old_api": null,
          "new_api": "sum_func",
          "old_text": null,
          "new_text": "min_max_item->sum_func()",
          "old_line_content": "",
          "new_line_content": "      if (min_max_item->sum_func() == Item_sum::MIN_FUNC)",
          "content_same": false
        },
        {
          "line": 11694,
          "old_api": null,
          "new_api": "rewind",
          "old_text": null,
          "new_text": "min_functions_it->rewind()",
          "old_line_content": "",
          "new_line_content": "  min_functions_it->rewind();",
          "content_same": false
        },
        {
          "line": 7598,
          "old_api": null,
          "new_api": "sql_print_information",
          "old_text": null,
          "new_text": "sql_print_information(\"Use_count: Wrong count for key at 0x%lx, %lu \"\n                              \"should be %lu\", (long unsigned int)pos,\n                              pos->next_key_part->use_count, count)",
          "old_line_content": "}",
          "new_line_content": "        sql_print_information(\"Use_count: Wrong count for key at 0x%lx, %lu \"",
          "content_same": false
        },
        {
          "line": 11696,
          "old_api": null,
          "new_api": "reset_and_add",
          "old_text": null,
          "new_text": "min_func->reset_and_add()",
          "old_line_content": "    The method iterates through all MAX functions and updates the result value",
          "new_line_content": "    min_func->reset_and_add();",
          "content_same": false
        },
        {
          "line": 9649,
          "old_api": null,
          "new_api": "sum_func",
          "old_text": null,
          "new_text": "min_max_item->sum_func()",
          "old_line_content": "        if (! min_max_arg_item)",
          "new_line_content": "               (min_max_item->sum_func() == Item_sum::COUNT_DISTINCT_FUNC ||",
          "content_same": false
        },
        {
          "line": 9650,
          "old_api": null,
          "new_api": "sum_func",
          "old_text": null,
          "new_text": "min_max_item->sum_func()",
          "old_line_content": "          min_max_arg_item= (Item_field*) expr;",
          "new_line_content": "                min_max_item->sum_func() == Item_sum::SUM_DISTINCT_FUNC ||",
          "content_same": false
        },
        {
          "line": 7603,
          "old_api": null,
          "new_api": "test_use_count",
          "old_text": null,
          "new_text": "pos->next_key_part->test_use_count(root)",
          "old_line_content": "  Calculate estimate of number records that will be retrieved by a range",
          "new_line_content": "      pos->next_key_part->test_use_count(root);",
          "content_same": false
        },
        {
          "line": 9654,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "      else",
          "new_line_content": "        DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 7607,
          "old_api": null,
          "new_api": "sql_print_warning",
          "old_text": null,
          "new_text": "sql_print_warning(\"Wrong use count: %u (should be %u) for tree at 0x%lx\",\n                      e_count, elements, (long unsigned int) this)",
          "old_line_content": "      param  Parameter from test_quick_select",
          "new_line_content": "    sql_print_warning(\"Wrong use count: %u (should be %u) for tree at 0x%lx\",",
          "content_same": false
        },
        {
          "line": 9657,
          "old_api": null,
          "new_api": "get_arg",
          "old_text": null,
          "new_text": "min_max_item->get_arg(0)->real_item()",
          "old_line_content": "  }",
          "new_line_content": "      Item *expr= min_max_item->get_arg(0)->real_item();",
          "content_same": false
        },
        {
          "line": 9658,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "expr->type()",
          "old_line_content": "",
          "new_line_content": "      if (expr->type() == Item::FIELD_ITEM) /* Is it an attribute? */",
          "content_same": false
        },
        {
          "line": 3517,
          "old_api": null,
          "new_api": "real_type",
          "old_text": null,
          "new_text": "*pfield)->real_type()",
          "old_line_content": "",
          "new_line_content": "    enum_field_types ftype= (*pfield)->real_type();",
          "content_same": false
        },
        {
          "line": 9663,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "  }",
          "new_line_content": "          DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 9666,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "  if (join->select_distinct)",
          "new_line_content": "        DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 9673,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "  }",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 11726,
          "old_api": null,
          "new_api": "rewind",
          "old_text": null,
          "new_text": "max_functions_it->rewind()",
          "old_line_content": "    QUICK_GROUP_MIN_MAX_SELECT::add_keys_and_lengths()",
          "new_line_content": "  max_functions_it->rewind();",
          "content_same": false
        },
        {
          "line": 11728,
          "old_api": null,
          "new_api": "reset_and_add",
          "old_text": null,
          "new_text": "max_func->reset_and_add()",
          "old_line_content": "    used_lengths [out] Corresponding lengths of the index names",
          "new_line_content": "    max_func->reset_and_add();",
          "content_same": false
        },
        {
          "line": 9681,
          "old_api": null,
          "new_api": "real_item",
          "old_text": null,
          "new_text": "item->real_item()->type()",
          "old_line_content": "",
          "new_line_content": "      if (item->real_item()->type() != Item::FIELD_ITEM)",
          "content_same": false
        },
        {
          "line": 9682,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "  /*",
          "new_line_content": "        DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 9689,
          "old_api": null,
          "new_api": "real_item",
          "old_text": null,
          "new_text": "*tmp_group->item)->real_item()->type()",
          "old_line_content": "  /* Cost-related variables for the best index so far. */",
          "new_line_content": "    if ((*tmp_group->item)->real_item()->type() != Item::FIELD_ITEM)",
          "content_same": false
        },
        {
          "line": 9690,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "  double best_read_cost= DBL_MAX;",
          "new_line_content": "      DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 7643,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"check_quick_select\")",
          "old_line_content": "  if (tree->type == SEL_ARG::IMPOSSIBLE)",
          "new_line_content": "  DBUG_ENTER(\"check_quick_select\");",
          "content_same": false
        },
        {
          "line": 3553,
          "old_api": null,
          "new_api": "fields_ok_for_partition_index",
          "old_text": null,
          "new_text": "fields_ok_for_partition_index(part_info->part_field_array)",
          "old_line_content": "",
          "new_line_content": "  used_part_fields= fields_ok_for_partition_index(part_info->part_field_array) ?",
          "content_same": false
        },
        {
          "line": 7649,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(HA_POS_ERROR)",
          "old_line_content": "  if ((key_alg != HA_KEY_ALG_BTREE) && (key_alg!= HA_KEY_ALG_UNDEF))",
          "new_line_content": "    DBUG_RETURN(HA_POS_ERROR);\t\t\t// Can't use it",
          "content_same": false
        },
        {
          "line": 3556,
          "old_api": null,
          "new_api": "fields_ok_for_partition_index",
          "old_text": null,
          "new_text": "fields_ok_for_partition_index(part_info->subpart_field_array)",
          "old_line_content": "    used_subpart_fields?(int)(used_part_fields + used_subpart_fields - 1): -1;",
          "new_line_content": "    fields_ok_for_partition_index(part_info->subpart_field_array)? ",
          "content_same": false
        },
        {
          "line": 5605,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "cond_func->arguments()[i]->real_item()",
          "old_line_content": "    Item_equal_iterator it(*item_equal);",
          "new_line_content": "    Item *arg= cond_func->arguments()[i]->real_item();",
          "content_same": false
        },
        {
          "line": 5607,
          "old_api": null,
          "new_api": "used_tables",
          "old_text": null,
          "new_text": "arg->used_tables()",
          "old_line_content": "    while ((item= it++))",
          "new_line_content": "      ref_tables|= arg->used_tables();",
          "content_same": false
        },
        {
          "line": 11752,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "key_names->append(index_info->name)",
          "old_line_content": "  SEL_ARG **key,**end;",
          "new_line_content": "  key_names->append(index_info->name);",
          "content_same": false
        },
        {
          "line": 11753,
          "old_api": null,
          "new_api": "longlong2str",
          "old_text": null,
          "new_text": "longlong2str(max_used_key_length, buf, 10)",
          "old_line_content": "  int idx;",
          "new_line_content": "  length= longlong2str(max_used_key_length, buf, 10) - buf;",
          "content_same": false
        },
        {
          "line": 11754,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "used_lengths->append(buf, length)",
          "old_line_content": "  char buff[1024];",
          "new_line_content": "  used_lengths->append(buf, length);",
          "content_same": false
        },
        {
          "line": 7655,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0L)",
          "old_line_content": "  {",
          "new_line_content": "    DBUG_RETURN(0L);\t\t\t\t// Impossible select. return",
          "content_same": false
        },
        {
          "line": 5612,
          "old_api": null,
          "new_api": "get_func_mm_tree",
          "old_text": null,
          "new_text": "get_func_mm_tree(param, cond_func, field, value, cmp_type, inv)",
          "old_line_content": "      if (!((ref_tables | f->table->map) & param_comp))",
          "new_line_content": "    ftree= get_func_mm_tree(param, cond_func, field, value, cmp_type, inv);",
          "content_same": false
        },
        {
          "line": 7657,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(HA_POS_ERROR)",
          "old_line_content": "      Clustered PK scan is a special case, check_quick_keys doesn't recognize",
          "new_line_content": "    DBUG_RETURN(HA_POS_ERROR);\t\t\t\t// Don't use tree",
          "content_same": false
        },
        {
          "line": 3569,
          "old_api": null,
          "new_api": "is_sub_partitioned",
          "old_text": null,
          "new_text": "part_info->is_sub_partitioned()",
          "old_line_content": "  KEY_PART *key_part;",
          "new_line_content": "  if (part_info->is_sub_partitioned())",
          "content_same": false
        },
        {
          "line": 5621,
          "old_api": null,
          "new_api": "eq",
          "old_text": null,
          "new_text": "field->eq(f)",
          "old_line_content": "",
          "new_line_content": "      if (field->eq(f))",
          "content_same": false
        },
        {
          "line": 7672,
          "old_api": null,
          "new_api": "primary_key_is_clustered",
          "old_text": null,
          "new_text": "param->table->file->primary_key_is_clustered()",
          "old_line_content": "    {",
          "new_line_content": "               param->table->file->primary_key_is_clustered());",
          "content_same": false
        },
        {
          "line": 11769,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "tmp.length(0)",
          "old_line_content": "    }",
          "new_line_content": "  tmp.length(0);",
          "content_same": false
        },
        {
          "line": 5625,
          "old_api": null,
          "new_api": "get_func_mm_tree",
          "old_text": null,
          "new_text": "get_func_mm_tree(param, cond_func, f, value, cmp_type, inv)",
          "old_line_content": "{",
          "new_line_content": "        tree= get_func_mm_tree(param, cond_func, f, value, cmp_type, inv);",
          "content_same": false
        },
        {
          "line": 5626,
          "old_api": null,
          "new_api": "tree_and",
          "old_text": null,
          "new_text": "tree_and(param, ftree, tree)",
          "old_line_content": "  SEL_TREE *tree=0;",
          "new_line_content": "        ftree= !ftree ? tree : tree_and(param, ftree, tree);",
          "content_same": false
        },
        {
          "line": 5630,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(ftree)",
          "old_line_content": "  Item *value= 0;",
          "new_line_content": "  DBUG_RETURN(ftree);",
          "content_same": false
        },
        {
          "line": 3583,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(alloc, sizeof(KEY_PART)*\n                                               total_parts)",
          "old_line_content": "  {",
          "new_line_content": "      !(key_part= (KEY_PART*)alloc_root(alloc, sizeof(KEY_PART)*",
          "content_same": false
        },
        {
          "line": 11777,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "tmp.length()",
          "old_line_content": "}",
          "new_line_content": "      if (tmp.length())",
          "content_same": false
        },
        {
          "line": 11778,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "tmp.append(',')",
          "old_line_content": "",
          "new_line_content": "        tmp.append(',');",
          "content_same": false
        },
        {
          "line": 3587,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(alloc, sizeof(my_bool)*\n                                                           total_parts)",
          "old_line_content": "      return TRUE;",
          "new_line_content": "      !(ppar->is_part_keypart= (my_bool*)alloc_root(alloc, sizeof(my_bool)*",
          "content_same": false
        },
        {
          "line": 11779,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "tmp.append(param->table->key_info[keynr].name)",
          "old_line_content": "",
          "new_line_content": "      tmp.append(param->table->key_info[keynr].name);",
          "content_same": false
        },
        {
          "line": 9733,
          "old_api": null,
          "new_api": "is_set",
          "old_text": null,
          "new_text": "table->covering_keys.is_set(cur_index)",
          "old_line_content": "    */",
          "new_line_content": "    if (!table->covering_keys.is_set(cur_index))",
          "content_same": false
        },
        {
          "line": 3589,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(alloc, sizeof(my_bool)*\n                                                           total_parts)",
          "old_line_content": "                FALSE);",
          "new_line_content": "      !(ppar->is_subpart_keypart= (my_bool*)alloc_root(alloc, sizeof(my_bool)*",
          "content_same": false
        },
        {
          "line": 11782,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "tmp.length()",
          "old_line_content": "                                struct st_ror_scan_info **end)",
          "new_line_content": "  if (!tmp.length())",
          "content_same": false
        },
        {
          "line": 11783,
          "old_api": null,
          "new_api": "STRING_WITH_LEN",
          "old_text": null,
          "new_text": "STRING_WITH_LEN(\"(empty)\")",
          "old_line_content": "{",
          "new_line_content": "    tmp.append(STRING_WITH_LEN(\"(empty)\"));",
          "content_same": false
        },
        {
          "line": 11785,
          "old_api": null,
          "new_api": "ptr",
          "old_text": null,
          "new_text": "tmp.ptr()",
          "old_line_content": "",
          "new_line_content": "  DBUG_PRINT(\"info\", (\"SEL_TREE: 0x%lx (%s)  scans: %s\", (long) tree, msg, tmp.ptr()));",
          "content_same": false
        },
        {
          "line": 5642,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"get_mm_tree\")",
          "old_line_content": "      {",
          "new_line_content": "  DBUG_ENTER(\"get_mm_tree\");",
          "content_same": false
        },
        {
          "line": 7684,
          "old_api": null,
          "new_api": "set_bit",
          "old_text": null,
          "new_text": "param->table->quick_keys.set_bit(key)",
          "old_line_content": "    if (cpk_scan)",
          "new_line_content": "      param->table->quick_keys.set_bit(key);",
          "content_same": false
        },
        {
          "line": 3596,
          "old_api": null,
          "new_api": "bitmap_buffer_size",
          "old_text": null,
          "new_text": "bitmap_buffer_size(ppar->part_info->num_subparts)",
          "old_line_content": "  {",
          "new_line_content": "    uint32 bufsize= bitmap_buffer_size(ppar->part_info->num_subparts);",
          "content_same": false
        },
        {
          "line": 3597,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(alloc, bufsize)",
          "old_line_content": "    key_part->key=          0;",
          "new_line_content": "    if (!(buf= (my_bitmap_map*) alloc_root(alloc, bufsize)))",
          "content_same": false
        },
        {
          "line": 7688,
          "old_api": null,
          "new_api": "min",
          "old_text": null,
          "new_text": "min(param->table->quick_condition_rows, records)",
          "old_line_content": "    param->is_ror_scan= FALSE;",
          "new_line_content": "        min(param->table->quick_condition_rows, records);",
          "content_same": false
        },
        {
          "line": 5648,
          "old_api": null,
          "new_api": "functype",
          "old_text": null,
          "new_text": "(Item_cond*) cond)->functype()",
          "old_line_content": "          break;",
          "new_line_content": "    if (((Item_cond*) cond)->functype() == Item_func::COND_AND_FUNC)",
          "content_same": false
        },
        {
          "line": 7698,
          "old_api": null,
          "new_api": "index_flags",
          "old_text": null,
          "new_text": "param->table->file->index_flags(key, 0, TRUE)",
          "old_line_content": "    check_quick_keys()",
          "new_line_content": "  if (param->table->file->index_flags(key, 0, TRUE) & HA_KEY_SCAN_NOT_ROR)",
          "content_same": false
        },
        {
          "line": 7700,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"exit\", (\"Records: %lu\", (ulong) records))",
          "old_line_content": "      idx           Number of key to use in PARAM::keys in list of used keys",
          "new_line_content": "  DBUG_PRINT(\"exit\", (\"Records: %lu\", (ulong) records));",
          "content_same": false
        },
        {
          "line": 7701,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(records)",
          "old_line_content": "                    (param->real_keynr[idx] holds the key number in table)",
          "new_line_content": "  DBUG_RETURN(records);",
          "content_same": false
        },
        {
          "line": 11799,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "tmp.length(0)",
          "old_line_content": "}",
          "new_line_content": "  tmp.length(0);",
          "content_same": false
        },
        {
          "line": 5656,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "      if (tree)",
          "new_line_content": "          DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 5657,
          "old_api": null,
          "new_api": "tree_and",
          "old_text": null,
          "new_text": "tree_and(param,tree,new_tree)",
          "old_line_content": "      {",
          "new_line_content": "        tree= tree_and(param,tree,new_tree);",
          "content_same": false
        },
        {
          "line": 3610,
          "old_api": null,
          "new_api": "key_length",
          "old_text": null,
          "new_text": "uint16)(*field)->key_length()",
          "old_line_content": "    */",
          "new_line_content": "    key_part->length= (uint16)(*field)->key_length();",
          "content_same": false
        },
        {
          "line": 3611,
          "old_api": null,
          "new_api": "get_partition_field_store_length",
          "old_text": null,
          "new_text": "get_partition_field_store_length(*field)",
          "old_line_content": "    key_part->flag=         0;",
          "new_line_content": "    key_part->store_length= (uint16)get_partition_field_store_length(*field);",
          "content_same": false
        },
        {
          "line": 9756,
          "old_api": null,
          "new_api": "bitmap_is_set",
          "old_text": null,
          "new_text": "bitmap_is_set(table->read_set, cur_field->field_index)",
          "old_line_content": "    if (join->group_list)",
          "new_line_content": "        if (bitmap_is_set(table->read_set, cur_field->field_index) &&",
          "content_same": false
        },
        {
          "line": 9757,
          "old_api": null,
          "new_api": "is_set",
          "old_text": null,
          "new_text": "cur_field->part_of_key_not_clustered.is_set(cur_index)",
          "old_line_content": "    {",
          "new_line_content": "            !cur_field->part_of_key_not_clustered.is_set(cur_index))",
          "content_same": false
        },
        {
          "line": 11802,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "tmp.length()",
          "old_line_content": "** Print a quick range for debugging",
          "new_line_content": "    if (tmp.length())",
          "content_same": false
        },
        {
          "line": 3613,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"part %u length %u store_length %u\", part,\n                         key_part->length, key_part->store_length))",
          "old_line_content": "",
          "new_line_content": "    DBUG_PRINT(\"info\", (\"part %u length %u store_length %u\", part,",
          "content_same": false
        },
        {
          "line": 11803,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "tmp.append(',')",
          "old_line_content": "** TODO:",
          "new_line_content": "      tmp.append(',');",
          "content_same": false
        },
        {
          "line": 11804,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "tmp.append(table->key_info[(*start)->keynr].name)",
          "old_line_content": "** This should be changed to use a String to store each row instead",
          "new_line_content": "    tmp.append(table->key_info[(*start)->keynr].name);",
          "content_same": false
        },
        {
          "line": 11806,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "tmp.length()",
          "old_line_content": "*****************************************************************************/",
          "new_line_content": "  if (!tmp.length())",
          "content_same": false
        },
        {
          "line": 9763,
          "old_api": null,
          "new_api": "clear_all",
          "old_text": null,
          "new_text": "used_key_parts_map.clear_all()",
          "old_line_content": "      {",
          "new_line_content": "    used_key_parts_map.clear_all();",
          "content_same": false
        },
        {
          "line": 11807,
          "old_api": null,
          "new_api": "STRING_WITH_LEN",
          "old_text": null,
          "new_text": "STRING_WITH_LEN(\"(empty)\")",
          "old_line_content": "",
          "new_line_content": "    tmp.append(STRING_WITH_LEN(\"(empty)\"));",
          "content_same": false
        },
        {
          "line": 11808,
          "old_api": null,
          "new_api": "ptr",
          "old_text": null,
          "new_text": "tmp.ptr()",
          "old_line_content": "static void",
          "new_line_content": "  DBUG_PRINT(\"info\", (\"ROR key scans (%s): %s\", msg, tmp.ptr()));",
          "content_same": false
        },
        {
          "line": 5665,
          "old_api": null,
          "new_api": "statement_should_be_aborted",
          "old_text": null,
          "new_text": "param->statement_should_be_aborted()",
          "old_line_content": "          if (tree == NULL || tree->type == SEL_TREE::ALWAYS)",
          "new_line_content": "      if (param->statement_should_be_aborted())",
          "content_same": false
        },
        {
          "line": 5666,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "            break;",
          "new_line_content": "        DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 5672,
          "old_api": null,
          "new_api": "get_mm_tree",
          "old_text": null,
          "new_text": "get_mm_tree(param,item)",
          "old_line_content": "  /* Here when simple cond */",
          "new_line_content": "          SEL_TREE *new_tree=get_mm_tree(param,item);",
          "content_same": false
        },
        {
          "line": 5674,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "  {",
          "new_line_content": "            DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 5675,
          "old_api": null,
          "new_api": "tree_or",
          "old_text": null,
          "new_text": "tree_or(param,tree,new_tree)",
          "old_line_content": "    /*",
          "new_line_content": "          tree= tree_or(param,tree,new_tree);",
          "content_same": false
        },
        {
          "line": 5681,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(tree)",
          "old_line_content": "    MEM_ROOT *tmp_root= param->mem_root;",
          "new_line_content": "    DBUG_RETURN(tree);",
          "content_same": false
        },
        {
          "line": 5684,
          "old_api": null,
          "new_api": "const_item",
          "old_text": null,
          "new_text": "cond->const_item()",
          "old_line_content": "                            new(tmp_root) SEL_TREE(SEL_TREE::IMPOSSIBLE);",
          "new_line_content": "  if (cond->const_item())",
          "content_same": false
        },
        {
          "line": 9781,
          "old_api": null,
          "new_api": "real_item",
          "old_text": null,
          "new_text": "*tmp_group->item)->real_item()->type()",
          "old_line_content": "      }",
          "new_line_content": "        DBUG_ASSERT((*tmp_group->item)->real_item()->type() == Item::FIELD_ITEM);",
          "content_same": false
        },
        {
          "line": 9782,
          "old_api": null,
          "new_api": "real_item",
          "old_text": null,
          "new_text": "*tmp_group->item)->real_item()",
          "old_line_content": "    }",
          "new_line_content": "        Item_field *group_field= (Item_field *) (*tmp_group->item)->real_item();",
          "content_same": false
        },
        {
          "line": 9783,
          "old_api": null,
          "new_api": "eq",
          "old_text": null,
          "new_text": "group_field->field->eq(cur_part->field)",
          "old_line_content": "    /*",
          "new_line_content": "        if (group_field->field->eq(cur_part->field))",
          "content_same": false
        },
        {
          "line": 3641,
          "old_api": null,
          "new_api": "print_partitioning_index",
          "old_text": null,
          "new_text": "print_partitioning_index(range_par->key_parts,\n                                                range_par->key_parts_end)",
          "old_line_content": "  DBUG_LOCK_FILE;",
          "new_line_content": "  DBUG_EXECUTE(\"info\", print_partitioning_index(range_par->key_parts,",
          "content_same": false
        },
        {
          "line": 9788,
          "old_api": null,
          "new_api": "set_bit",
          "old_text": null,
          "new_text": "used_key_parts_map.set_bit(max_key_part)",
          "old_line_content": "      Later group_fields_array of ORDER objects is used to convert the query",
          "new_line_content": "          used_key_parts_map.set_bit(max_key_part);",
          "content_same": false
        },
        {
          "line": 3651,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"print_partitioning_index\")",
          "old_line_content": "",
          "new_line_content": "  DBUG_ENTER(\"print_partitioning_index\");",
          "content_same": false
        },
        {
          "line": 3653,
          "old_api": null,
          "new_api": "fprintf",
          "old_text": null,
          "new_text": "fprintf(DBUG_FILE, \"partitioning INDEX(\")",
          "old_line_content": "static void dbug_print_field(Field *field)",
          "new_line_content": "  fprintf(DBUG_FILE, \"partitioning INDEX(\");",
          "content_same": false
        },
        {
          "line": 11846,
          "old_api": null,
          "new_api": "set_key_image",
          "old_text": null,
          "new_text": "field->set_key_image(key, key_part->length)",
          "old_line_content": "",
          "new_line_content": "    field->set_key_image(key, key_part->length);",
          "content_same": false
        },
        {
          "line": 11847,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "field->type()",
          "old_line_content": "",
          "new_line_content": "    if (field->type() == MYSQL_TYPE_BIT)",
          "content_same": false
        },
        {
          "line": 11848,
          "old_api": null,
          "new_api": "val_int_as_str",
          "old_text": null,
          "new_text": "field->val_int_as_str(&tmp, 1)",
          "old_line_content": "static void print_quick(QUICK_SELECT_I *quick, const key_map *needed_reg)",
          "new_line_content": "      (void) field->val_int_as_str(&tmp, 1);",
          "content_same": false
        },
        {
          "line": 3658,
          "old_api": null,
          "new_api": "fputs",
          "old_text": null,
          "new_text": "fputs(\");\\n\", DBUG_FILE)",
          "old_line_content": "  {",
          "new_line_content": "  fputs(\");\\n\", DBUG_FILE);",
          "content_same": false
        },
        {
          "line": 11850,
          "old_api": null,
          "new_api": "val_str",
          "old_text": null,
          "new_text": "field->val_str(&tmp)",
          "old_line_content": "  char buf[MAX_KEY/8+1];",
          "new_line_content": "      field->val_str(&tmp);",
          "content_same": false
        },
        {
          "line": 11851,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "tmp.length()",
          "old_line_content": "  TABLE *table;",
          "new_line_content": "    fwrite(tmp.ptr(),sizeof(char),tmp.length(),DBUG_FILE);",
          "content_same": false
        },
        {
          "line": 5708,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "  param->cond= cond;",
          "new_line_content": "      DBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 5709,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(new SEL_TREE(SEL_TREE::MAYBE))",
          "old_line_content": "",
          "new_line_content": "    DBUG_RETURN(new SEL_TREE(SEL_TREE::MAYBE));",
          "content_same": false
        },
        {
          "line": 9807,
          "old_api": null,
          "new_api": "rewind",
          "old_text": null,
          "new_text": "select_items_it.rewind()",
          "old_line_content": "        /* not doing loose index scan for derived tables */",
          "new_line_content": "        select_items_it.rewind();",
          "content_same": false
        },
        {
          "line": 11855,
          "old_api": null,
          "new_api": "dbug_tmp_restore_column_maps",
          "old_text": null,
          "new_text": "dbug_tmp_restore_column_maps(table->read_set, table->write_set, old_sets)",
          "old_line_content": "    DBUG_VOID_RETURN;",
          "new_line_content": "  dbug_tmp_restore_column_maps(table->read_set, table->write_set, old_sets);",
          "content_same": false
        },
        {
          "line": 5713,
          "old_api": null,
          "new_api": "functype",
          "old_text": null,
          "new_text": "cond_func->functype()",
          "old_line_content": "    {",
          "new_line_content": "  if (cond_func->functype() == Item_func::BETWEEN ||",
          "content_same": false
        },
        {
          "line": 3666,
          "old_api": null,
          "new_api": "is_real_null",
          "old_text": null,
          "new_text": "field->is_real_null()",
          "old_line_content": "}",
          "new_line_content": "  if (field->is_real_null())",
          "content_same": false
        },
        {
          "line": 3667,
          "old_api": null,
          "new_api": "fprintf",
          "old_text": null,
          "new_text": "fprintf(DBUG_FILE, \"NULL\")",
          "old_line_content": "",
          "new_line_content": "    fprintf(DBUG_FILE, \"NULL\");",
          "content_same": false
        },
        {
          "line": 5716,
          "old_api": null,
          "new_api": "select_optimize",
          "old_text": null,
          "new_text": "cond_func->select_optimize()",
          "old_line_content": "    }",
          "new_line_content": "  else if (cond_func->select_optimize() == Item_func::OPTIMIZE_NONE)",
          "content_same": false
        },
        {
          "line": 5717,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "",
          "new_line_content": "    DBUG_RETURN(0);\t\t\t       ",
          "content_same": false
        },
        {
          "line": 7757,
          "old_api": null,
          "new_api": "max",
          "old_text": null,
          "new_text": "max(param->max_key_part,key_tree->part)",
          "old_line_content": "                             min_key, min_key_flag, min_keypart,",
          "new_line_content": "  param->max_key_part=max(param->max_key_part,key_tree->part);",
          "content_same": false
        },
        {
          "line": 9815,
          "old_api": null,
          "new_api": "real_item",
          "old_text": null,
          "new_text": "item->real_item()",
          "old_line_content": "          If it was present, then its corresponding key part was alredy used.",
          "new_line_content": "        item_field= (Item_field*) item->real_item(); ",
          "content_same": false
        },
        {
          "line": 9816,
          "old_api": null,
          "new_api": "real_item",
          "old_text": null,
          "new_text": "item->real_item()->type()",
          "old_line_content": "        */",
          "new_line_content": "        DBUG_ASSERT(item->real_item()->type() == Item::FIELD_ITEM);",
          "content_same": false
        },
        {
          "line": 11864,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"print_quick\")",
          "old_line_content": "",
          "new_line_content": "  DBUG_ENTER(\"print_quick\");",
          "content_same": false
        },
        {
          "line": 3674,
          "old_api": null,
          "new_api": "val_str",
          "old_text": null,
          "new_text": "field->val_str(&str)",
          "old_line_content": "  if (!(arg->min_flag & NO_MIN_RANGE))",
          "new_line_content": "    pstr= field->val_str(&str);",
          "content_same": false
        },
        {
          "line": 3675,
          "old_api": null,
          "new_api": "c_ptr_safe",
          "old_text": null,
          "new_text": "pstr->c_ptr_safe()",
          "old_line_content": "  {",
          "new_line_content": "    fprintf(DBUG_FILE, \"'%s'\", pstr->c_ptr_safe());",
          "content_same": false
        },
        {
          "line": 5721,
          "old_api": null,
          "new_api": "functype",
          "old_text": null,
          "new_text": "cond_func->functype()",
          "old_line_content": "    */",
          "new_line_content": "  switch (cond_func->functype()) {",
          "content_same": false
        },
        {
          "line": 5723,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "cond_func->arguments()[0]->real_item()->type()",
          "old_line_content": "    {",
          "new_line_content": "    if (cond_func->arguments()[0]->real_item()->type() == Item::FIELD_ITEM)",
          "content_same": false
        },
        {
          "line": 11870,
          "old_api": null,
          "new_api": "dbug_tmp_use_all_columns",
          "old_text": null,
          "new_text": "dbug_tmp_use_all_columns(table, old_sets, table->read_set, table->write_set)",
          "old_line_content": "void QUICK_RANGE_SELECT::dbug_dump(int indent, bool verbose)",
          "new_line_content": "  dbug_tmp_use_all_columns(table, old_sets, table->read_set, table->write_set);",
          "content_same": false
        },
        {
          "line": 9823,
          "old_api": null,
          "new_api": "get_field_keypart",
          "old_text": null,
          "new_text": "get_field_keypart(cur_index_info, item_field->field)",
          "old_line_content": "        cur_group_prefix_len+= cur_part->store_length;",
          "new_line_content": "        key_part_nr= get_field_keypart(cur_index_info, item_field->field);",
          "content_same": false
        },
        {
          "line": 11871,
          "old_api": null,
          "new_api": "dbug_dump",
          "old_text": null,
          "new_text": "quick->dbug_dump(0, TRUE)",
          "old_line_content": "{",
          "new_line_content": "  quick->dbug_dump(0, TRUE);",
          "content_same": false
        },
        {
          "line": 11872,
          "old_api": null,
          "new_api": "dbug_tmp_restore_column_maps",
          "old_text": null,
          "new_text": "dbug_tmp_restore_column_maps(table->read_set, table->write_set, old_sets)",
          "old_line_content": "  /* purecov: begin inspected */",
          "new_line_content": "  dbug_tmp_restore_column_maps(table->read_set, table->write_set, old_sets);",
          "content_same": false
        },
        {
          "line": 11874,
          "old_api": null,
          "new_api": "print",
          "old_text": null,
          "new_text": "needed_reg->print(buf)",
          "old_line_content": "\t  indent, \"\", head->key_info[index].name, max_used_key_length);",
          "new_line_content": "  fprintf(DBUG_FILE,\"other_keys: 0x%s:\\n\", needed_reg->print(buf));",
          "content_same": false
        },
        {
          "line": 3683,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"dbug_print_segment_range\")",
          "old_line_content": "",
          "new_line_content": "  DBUG_ENTER(\"dbug_print_segment_range\");",
          "content_same": false
        },
        {
          "line": 9828,
          "old_api": null,
          "new_api": "is_set",
          "old_text": null,
          "new_text": "used_key_parts_map.is_set(key_part_nr)",
          "old_line_content": "      /*",
          "new_line_content": "        if (used_key_parts_map.is_set(key_part_nr))",
          "content_same": false
        },
        {
          "line": 5725,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "cond_func->arguments()[0]->real_item()",
          "old_line_content": "      {",
          "new_line_content": "      field_item= (Item_field*) (cond_func->arguments()[0]->real_item());",
          "content_same": false
        },
        {
          "line": 7776,
          "old_api": null,
          "new_api": "store_min",
          "old_text": null,
          "new_text": "key_tree->store_min(param->key[idx][key_tree->part].store_length,\n                                        &tmp_min_key, min_key_flag)",
          "old_line_content": "      Actually we're cutting off some ROR scans here.",
          "new_line_content": "  tmp_min_keypart+= key_tree->store_min(param->key[idx][key_tree->part].store_length,",
          "content_same": false
        },
        {
          "line": 3687,
          "old_api": null,
          "new_api": "store_key_image_to_rec",
          "old_text": null,
          "new_text": "store_key_image_to_rec(part->field, arg->min_value, part->length)",
          "old_line_content": "  {",
          "new_line_content": "    store_key_image_to_rec(part->field, arg->min_value, part->length);",
          "content_same": false
        },
        {
          "line": 3688,
          "old_api": null,
          "new_api": "dbug_print_field",
          "old_text": null,
          "new_text": "dbug_print_field(part->field)",
          "old_line_content": "    if (arg->max_flag & NEAR_MAX)",
          "new_line_content": "    dbug_print_field(part->field);",
          "content_same": false
        },
        {
          "line": 5735,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "cond_func->arguments()[i]->real_item()->type()",
          "old_line_content": "        else ",
          "new_line_content": "      if (cond_func->arguments()[i]->real_item()->type() == Item::FIELD_ITEM)",
          "content_same": false
        },
        {
          "line": 3690,
          "old_api": null,
          "new_api": "fputs",
          "old_text": null,
          "new_text": "fputs(\" < \", DBUG_FILE)",
          "old_line_content": "    else",
          "new_line_content": "      fputs(\" < \", DBUG_FILE);",
          "content_same": false
        },
        {
          "line": 9835,
          "old_api": null,
          "new_api": "set_bit",
          "old_text": null,
          "new_text": "used_key_parts_map.set_bit(key_part_nr)",
          "old_line_content": "      all_parts= (1ULL << max_key_part) - 1;",
          "new_line_content": "        used_key_parts_map.set_bit(key_part_nr);",
          "content_same": false
        },
        {
          "line": 11884,
          "old_api": null,
          "new_api": "fprintf",
          "old_text": null,
          "new_text": "fprintf(DBUG_FILE, \"%*squick range select, key %s, length: %d\\n\",\n\t  indent, \"\", head->key_info[index].name, max_used_key_length)",
          "old_line_content": "      range= *pr;",
          "new_line_content": "  fprintf(DBUG_FILE, \"%*squick range select, key %s, length: %d\\n\",",
          "content_same": false
        },
        {
          "line": 9837,
          "old_api": null,
          "new_api": "max",
          "old_text": null,
          "new_text": "max(max_key_part,key_part_nr)",
          "old_line_content": "      if (all_parts != cur_parts)",
          "new_line_content": "        max_key_part= max(max_key_part,key_part_nr);",
          "content_same": false
        },
        {
          "line": 5737,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "cond_func->arguments()[i]->real_item()",
          "old_line_content": "      }",
          "new_line_content": "        field_item= (Item_field*) (cond_func->arguments()[i]->real_item());",
          "content_same": false
        },
        {
          "line": 5738,
          "old_api": null,
          "new_api": "get_full_func_mm_tree",
          "old_text": null,
          "new_text": "get_full_func_mm_tree(param, cond_func, \n                                    field_item, (Item*)(intptr)i, inv)",
          "old_line_content": "      else if (inv)",
          "new_line_content": "        SEL_TREE *tmp= get_full_func_mm_tree(param, cond_func, ",
          "content_same": false
        },
        {
          "line": 5742,
          "old_api": null,
          "new_api": "tree_or",
          "old_text": null,
          "new_text": "tree_or(param, tree, tmp)",
          "old_line_content": "      }",
          "new_line_content": "          tree= !tree ? tmp : tree_or(param, tree, tmp);",
          "content_same": false
        },
        {
          "line": 7791,
          "old_api": null,
          "new_api": "key_length",
          "old_text": null,
          "new_text": "param->table->field[fieldnr]->key_length()",
          "old_line_content": "  {\t\t\t\t\t\t// const key as prefix",
          "new_line_content": "    if (param->table->field[fieldnr]->key_length() !=",
          "content_same": false
        },
        {
          "line": 5747,
          "old_api": null,
          "new_api": "tree_and",
          "old_text": null,
          "new_text": "tree_and(param, tree, tmp)",
          "old_line_content": "  case Item_func::IN_FUNC:",
          "new_line_content": "          tree= tree_and(param, tree, tmp);",
          "content_same": false
        },
        {
          "line": 3700,
          "old_api": null,
          "new_api": "fputs",
          "old_text": null,
          "new_text": "fputs(\" < \", DBUG_FILE)",
          "old_line_content": "",
          "new_line_content": "      fputs(\" < \", DBUG_FILE);",
          "content_same": false
        },
        {
          "line": 3702,
          "old_api": null,
          "new_api": "fputs",
          "old_text": null,
          "new_text": "fputs(\" <= \", DBUG_FILE)",
          "old_line_content": "  Print a singlepoint multi-keypart range interval to debug trace",
          "new_line_content": "      fputs(\" <= \", DBUG_FILE);",
          "content_same": false
        },
        {
          "line": 9847,
          "old_api": null,
          "new_api": "to_ulonglong",
          "old_text": null,
          "new_text": "used_key_parts_map.to_ulonglong()",
          "old_line_content": "      min_max_arg_part= cur_index_info->key_part + key_part_nr - 1;",
          "new_line_content": "      cur_parts= used_key_parts_map.to_ulonglong() >> 1;",
          "content_same": false
        },
        {
          "line": 3703,
          "old_api": null,
          "new_api": "store_key_image_to_rec",
          "old_text": null,
          "new_text": "store_key_image_to_rec(part->field, arg->max_value, part->length)",
          "old_line_content": " ",
          "new_line_content": "    store_key_image_to_rec(part->field, arg->max_value, part->length);",
          "content_same": false
        },
        {
          "line": 3704,
          "old_api": null,
          "new_api": "dbug_print_field",
          "old_text": null,
          "new_text": "dbug_print_field(part->field)",
          "old_line_content": "  SYNOPSIS",
          "new_line_content": "    dbug_print_field(part->field);",
          "content_same": false
        },
        {
          "line": 11894,
          "old_api": null,
          "new_api": "fprintf",
          "old_text": null,
          "new_text": "fprintf(DBUG_FILE, \"%*s\", indent + 2, \"\")",
          "old_line_content": "",
          "new_line_content": "      fprintf(DBUG_FILE, \"%*s\", indent + 2, \"\");",
          "content_same": false
        },
        {
          "line": 3706,
          "old_api": null,
          "new_api": "fputs",
          "old_text": null,
          "new_text": "fputs(\"\\n\", DBUG_FILE)",
          "old_line_content": "      start  Array of SEL_ARG* ptrs representing conditions on key parts",
          "new_line_content": "  fputs(\"\\n\", DBUG_FILE);",
          "content_same": false
        },
        {
          "line": 5756,
          "old_api": null,
          "new_api": "tree_and",
          "old_text": null,
          "new_text": "tree_and(param, ftree, tree)",
          "old_line_content": "  case Item_func::MULT_EQUAL_FUNC:",
          "new_line_content": "    ftree = tree_and(param, ftree, tree);",
          "content_same": false
        },
        {
          "line": 7804,
          "old_api": null,
          "new_api": "uint) (tmp_max_key - max_key)",
          "old_text": null,
          "new_text": "uint) (tmp_max_key - max_key)",
          "old_line_content": "      /* The interval for current key part is not c1 <= keyXpartY <= c1 */",
          "new_line_content": "\t!memcmp(min_key, max_key, (uint) (tmp_max_key - max_key)) &&",
          "content_same": false
        },
        {
          "line": 11902,
          "old_api": null,
          "new_api": "fputs",
          "old_text": null,
          "new_text": "fputs(\" <= \",DBUG_FILE)",
          "old_line_content": "      }",
          "new_line_content": "\t  fputs(\" <= \",DBUG_FILE);",
          "content_same": false
        },
        {
          "line": 9855,
          "old_api": null,
          "new_api": "get_field_keypart",
          "old_text": null,
          "new_text": "get_field_keypart(cur_index_info, min_max_arg_item->field)",
          "old_line_content": "    /*",
          "new_line_content": "      key_part_nr= get_field_keypart(cur_index_info, min_max_arg_item->field);",
          "content_same": false
        },
        {
          "line": 11904,
          "old_api": null,
          "new_api": "fputs",
          "old_text": null,
          "new_text": "fputs(\"X\",DBUG_FILE)",
          "old_line_content": "    }",
          "new_line_content": "      fputs(\"X\",DBUG_FILE);",
          "content_same": false
        },
        {
          "line": 5761,
          "old_api": null,
          "new_api": "key_item",
          "old_text": null,
          "new_text": "func->key_item()->real_item()->type()",
          "old_line_content": "    Item_equal_iterator it(*item_equal);",
          "new_line_content": "    if (func->key_item()->real_item()->type() != Item::FIELD_ITEM)",
          "content_same": false
        },
        {
          "line": 7807,
          "old_api": null,
          "new_api": "check_quick_keys",
          "old_text": null,
          "new_text": "check_quick_keys(param,idx,key_tree->next_key_part, tmp_min_key,\n                           min_key_flag | key_tree->min_flag, tmp_min_keypart,\n                           tmp_max_key, max_key_flag | key_tree->max_flag,\n                           tmp_max_keypart)",
          "old_line_content": "",
          "new_line_content": "      tmp=check_quick_keys(param,idx,key_tree->next_key_part, tmp_min_key,",
          "content_same": false
        },
        {
          "line": 5763,
          "old_api": null,
          "new_api": "key_item",
          "old_text": null,
          "new_text": "func->key_item()->real_item()",
          "old_line_content": "    while ((field_item= it++))",
          "new_line_content": "    field_item= (Item_field*) (func->key_item()->real_item());",
          "content_same": false
        },
        {
          "line": 5764,
          "old_api": null,
          "new_api": "get_full_func_mm_tree",
          "old_text": null,
          "new_text": "get_full_func_mm_tree(param, cond_func, field_item, NULL, inv)",
          "old_line_content": "    {",
          "new_line_content": "    ftree= get_full_func_mm_tree(param, cond_func, field_item, NULL, inv);",
          "content_same": false
        },
        {
          "line": 11909,
          "old_api": null,
          "new_api": "fputs",
          "old_text": null,
          "new_text": "fputs(\" < \",DBUG_FILE)",
          "old_line_content": "",
          "new_line_content": "\t  fputs(\" < \",DBUG_FILE);",
          "content_same": false
        },
        {
          "line": 11911,
          "old_api": null,
          "new_api": "fputs",
          "old_text": null,
          "new_text": "fputs(\" <= \",DBUG_FILE)",
          "old_line_content": "{",
          "new_line_content": "\t  fputs(\" <= \",DBUG_FILE);",
          "content_same": false
        },
        {
          "line": 1672,
          "old_api": null,
          "new_api": "init_ror_merged_scan",
          "old_text": null,
          "new_text": "quick->init_ror_merged_scan(false)",
          "old_line_content": "  */",
          "new_line_content": "      error= quick->init_ror_merged_scan(false);",
          "content_same": false
        },
        {
          "line": 11912,
          "old_api": null,
          "new_api": "print_key",
          "old_text": null,
          "new_text": "print_key(key_parts, range->max_key, range->max_length)",
          "old_line_content": "  List_iterator_fast<QUICK_RANGE_SELECT> it(quick_selects);",
          "new_line_content": "        print_key(key_parts, range->max_key, range->max_length);",
          "content_same": false
        },
        {
          "line": 5770,
          "old_api": null,
          "new_api": "get_const",
          "old_text": null,
          "new_text": "item_equal->get_const()",
          "old_line_content": "\t\t           value,cmp_type);",
          "new_line_content": "    if (!(value= item_equal->get_const()))",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(1)",
          "old_line_content": "  {",
          "new_line_content": "        DBUG_RETURN(1);",
          "content_same": false
        },
        {
          "line": 5773,
          "old_api": null,
          "new_api": "used_tables",
          "old_text": null,
          "new_text": "value->used_tables()",
          "old_line_content": "    }",
          "new_line_content": "    ref_tables= value->used_tables();",
          "content_same": false
        },
        {
          "line": 1679,
          "old_api": null,
          "new_api": "queue_remove_all",
          "old_text": null,
          "new_text": "queue_remove_all(&queue)",
          "old_line_content": "    {",
          "new_line_content": "  queue_remove_all(&queue);",
          "content_same": false
        },
        {
          "line": 3727,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"dbug_print_singlepoint_range\")",
          "old_line_content": "  DBUG_UNLOCK_FILE;",
          "new_line_content": "  DBUG_ENTER(\"dbug_print_singlepoint_range\");",
          "content_same": false
        },
        {
          "line": 5777,
          "old_api": null,
          "new_api": "cmp_type",
          "old_text": null,
          "new_text": "field->cmp_type()",
          "old_line_content": "  default:",
          "new_line_content": "      Item_result cmp_type= field->cmp_type();",
          "content_same": false
        },
        {
          "line": 11925,
          "old_api": null,
          "new_api": "fprintf",
          "old_text": null,
          "new_text": "fprintf(DBUG_FILE, \"%*squick index_merge select\\n\", indent, \"\")",
          "old_line_content": "",
          "new_line_content": "  fprintf(DBUG_FILE, \"%*squick index_merge select\\n\", indent, \"\");",
          "content_same": false
        },
        {
          "line": 3734,
          "old_api": null,
          "new_api": "fprintf",
          "old_text": null,
          "new_text": "fprintf(DBUG_FILE, \"%s%s=\", (arg==start)?\"\":\", \", field->field_name)",
          "old_line_content": " ****************************************************************************/",
          "new_line_content": "    fprintf(DBUG_FILE, \"%s%s=\", (arg==start)?\"\":\", \", field->field_name);",
          "content_same": false
        },
        {
          "line": 1687,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "quick->reset()",
          "old_line_content": "",
          "new_line_content": "    if ((error= quick->reset()))",
          "content_same": false
        },
        {
          "line": 3735,
          "old_api": null,
          "new_api": "dbug_print_field",
          "old_text": null,
          "new_text": "dbug_print_field(field)",
          "old_line_content": "#endif",
          "new_line_content": "    dbug_print_field(field);",
          "content_same": false
        },
        {
          "line": 1689,
          "old_api": null,
          "new_api": "get_next",
          "old_text": null,
          "new_text": "quick->get_next()",
          "old_line_content": "  {",
          "new_line_content": "    if ((error= quick->get_next()))",
          "content_same": false
        },
        {
          "line": 11926,
          "old_api": null,
          "new_api": "fprintf",
          "old_text": null,
          "new_text": "fprintf(DBUG_FILE, \"%*smerged scans {\\n\", indent, \"\")",
          "old_line_content": "void QUICK_ROR_INTERSECT_SELECT::dbug_dump(int indent, bool verbose)",
          "new_line_content": "  fprintf(DBUG_FILE, \"%*smerged scans {\\n\", indent, \"\");",
          "content_same": false
        },
        {
          "line": 3737,
          "old_api": null,
          "new_api": "fputs",
          "old_text": null,
          "new_text": "fputs(\"\\n\", DBUG_FILE)",
          "old_line_content": "",
          "new_line_content": "  fputs(\"\\n\", DBUG_FILE);",
          "content_same": false
        },
        {
          "line": 11928,
          "old_api": null,
          "new_api": "dbug_dump",
          "old_text": null,
          "new_text": "quick->dbug_dump(indent+2, verbose)",
          "old_line_content": "  List_iterator_fast<QUICK_RANGE_SELECT> it(quick_selects);",
          "new_line_content": "    quick->dbug_dump(indent+2, verbose);",
          "content_same": false
        },
        {
          "line": 1693,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(error)",
          "old_line_content": "",
          "new_line_content": "      DBUG_RETURN(error);",
          "content_same": false
        },
        {
          "line": 11931,
          "old_api": null,
          "new_api": "fprintf",
          "old_text": null,
          "new_text": "fprintf(DBUG_FILE, \"%*sclustered PK quick:\\n\", indent, \"\")",
          "old_line_content": "          indent, \"\", need_to_fetch_row? \"\":\"non-\");",
          "new_line_content": "    fprintf(DBUG_FILE, \"%*sclustered PK quick:\\n\", indent, \"\");",
          "content_same": false
        },
        {
          "line": 1695,
          "old_api": null,
          "new_api": "save_last_pos",
          "old_text": null,
          "new_text": "quick->save_last_pos()",
          "old_line_content": "}",
          "new_line_content": "    quick->save_last_pos();",
          "content_same": false
        },
        {
          "line": 1696,
          "old_api": null,
          "new_api": "queue_insert",
          "old_text": null,
          "new_text": "queue_insert(&queue, (uchar*)quick)",
          "old_line_content": "",
          "new_line_content": "    queue_insert(&queue, (uchar*)quick);",
          "content_same": false
        },
        {
          "line": 5786,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(ftree)",
          "old_line_content": "    {",
          "new_line_content": "    DBUG_RETURN(ftree);",
          "content_same": false
        },
        {
          "line": 5789,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "cond_func->arguments()[0]->real_item()->type()",
          "old_line_content": "    }",
          "new_line_content": "    if (cond_func->arguments()[0]->real_item()->type() == Item::FIELD_ITEM)",
          "content_same": false
        },
        {
          "line": 9891,
          "old_api": null,
          "new_api": "get_index_range_tree",
          "old_text": null,
          "new_text": "get_index_range_tree(cur_index, tree, param,\n                                                        &dummy)",
          "old_line_content": "      {",
          "new_line_content": "        SEL_ARG *index_range_tree= get_index_range_tree(cur_index, tree, param,",
          "content_same": false
        },
        {
          "line": 1699,
          "old_api": null,
          "new_api": "ha_rnd_init",
          "old_text": null,
          "new_text": "head->file->ha_rnd_init(1)",
          "old_line_content": "QUICK_ROR_UNION_SELECT::push_quick_back(QUICK_SELECT_I *quick_sel_range)",
          "new_line_content": "  if ((error= head->file->ha_rnd_init(1)))",
          "content_same": false
        },
        {
          "line": 9893,
          "old_api": null,
          "new_api": "get_constant_key_infix",
          "old_text": null,
          "new_text": "get_constant_key_infix(cur_index_info, index_range_tree,\n                                    first_non_group_part, min_max_arg_part,\n                                    last_part, thd, cur_key_infix, \n                                    &cur_key_infix_len,\n                                    &first_non_infix_part)",
          "old_line_content": "          There is a gap but no range tree, thus no predicates at all for the",
          "new_line_content": "        if (!get_constant_key_infix(cur_index_info, index_range_tree,",
          "content_same": false
        },
        {
          "line": 1702,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(error)",
          "old_line_content": "}",
          "new_line_content": "    DBUG_RETURN(error);",
          "content_same": false
        },
        {
          "line": 11941,
          "old_api": null,
          "new_api": "fprintf",
          "old_text": null,
          "new_text": "fprintf(DBUG_FILE, \"%*squick ROR-intersect select, %scovering\\n\",\n          indent, \"\", need_to_fetch_row? \"\":\"non-\")",
          "old_line_content": "}",
          "new_line_content": "  fprintf(DBUG_FILE, \"%*squick ROR-intersect select, %scovering\\n\",",
          "content_same": false
        },
        {
          "line": 11943,
          "old_api": null,
          "new_api": "fprintf",
          "old_text": null,
          "new_text": "fprintf(DBUG_FILE, \"%*smerged scans {\\n\", indent, \"\")",
          "old_line_content": "void QUICK_ROR_UNION_SELECT::dbug_dump(int indent, bool verbose)",
          "new_line_content": "  fprintf(DBUG_FILE, \"%*smerged scans {\\n\", indent, \"\");",
          "content_same": false
        },
        {
          "line": 1705,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "{",
          "new_line_content": "  DBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 11945,
          "old_api": null,
          "new_api": "dbug_dump",
          "old_text": null,
          "new_text": "quick->dbug_dump(indent+2, verbose)",
          "old_line_content": "  List_iterator_fast<QUICK_SELECT_I> it(quick_selects);",
          "new_line_content": "    quick->dbug_dump(indent+2, verbose);",
          "content_same": false
        },
        {
          "line": 5794,
          "old_api": null,
          "new_api": "have_rev_func",
          "old_text": null,
          "new_text": "cond_func->have_rev_func()",
          "old_line_content": "",
          "new_line_content": "    else if (cond_func->have_rev_func() &&",
          "content_same": false
        },
        {
          "line": 5798,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "cond_func->arguments()[1]->real_item()",
          "old_line_content": "",
          "new_line_content": "      field_item= (Item_field*) (cond_func->arguments()[1]->real_item());",
          "content_same": false
        },
        {
          "line": 11949,
          "old_api": null,
          "new_api": "dbug_dump",
          "old_text": null,
          "new_text": "cpk_quick->dbug_dump(indent+2, verbose)",
          "old_line_content": "  while ((quick= it++))",
          "new_line_content": "    cpk_quick->dbug_dump(indent+2, verbose);",
          "content_same": false
        },
        {
          "line": 5799,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "cond_func->arguments()",
          "old_line_content": "static SEL_TREE *",
          "new_line_content": "      value= cond_func->arguments()[0];",
          "content_same": false
        },
        {
          "line": 5802,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "\t     Item *value, Item_result cmp_type)",
          "new_line_content": "      DBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 1712,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "quick_selects.push_back(quick_sel_range)",
          "old_line_content": "  DBUG_VOID_RETURN;",
          "new_line_content": "  return quick_selects.push_back(quick_sel_range);",
          "content_same": false
        },
        {
          "line": 5803,
          "old_api": null,
          "new_api": "get_full_func_mm_tree",
          "old_text": null,
          "new_text": "get_full_func_mm_tree(param, cond_func, field_item, value, inv)",
          "old_line_content": "{",
          "new_line_content": "    ftree= get_full_func_mm_tree(param, cond_func, field_item, value, inv);",
          "content_same": false
        },
        {
          "line": 3762,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"get_sweep_read_cost\")",
          "old_line_content": "    double busy_blocks=",
          "new_line_content": "  DBUG_ENTER(\"get_sweep_read_cost\");",
          "content_same": false
        },
        {
          "line": 7851,
          "old_api": null,
          "new_api": "memcmp",
          "old_text": null,
          "new_text": "memcmp(param->min_key, param->max_key, min_key_length)",
          "old_line_content": "        If we get here, the condition on the key was converted to form",
          "new_line_content": "      !memcmp(param->min_key, param->max_key, min_key_length) &&",
          "content_same": false
        },
        {
          "line": 1717,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"QUICK_ROR_UNION_SELECT::~QUICK_ROR_UNION_SELECT\")",
          "old_line_content": "  :min_key(0),max_key(0),min_length(0),max_length(0),",
          "new_line_content": "  DBUG_ENTER(\"QUICK_ROR_UNION_SELECT::~QUICK_ROR_UNION_SELECT\");",
          "content_same": false
        },
        {
          "line": 1718,
          "old_api": null,
          "new_api": "delete_queue",
          "old_text": null,
          "new_text": "delete_queue(&queue)",
          "old_line_content": "   flag(NO_MIN_RANGE | NO_MAX_RANGE),",
          "new_line_content": "  delete_queue(&queue);",
          "content_same": false
        },
        {
          "line": 1719,
          "old_api": null,
          "new_api": "delete_elements",
          "old_text": null,
          "new_text": "quick_selects.delete_elements()",
          "old_line_content": "  min_keypart_map(0), max_keypart_map(0)",
          "new_line_content": "  quick_selects.delete_elements();",
          "content_same": false
        },
        {
          "line": 3765,
          "old_api": null,
          "new_api": "read_time",
          "old_text": null,
          "new_text": "param->table->file->read_time(param->table->s->primary_key,\n                                          (uint)records, records)",
          "old_line_content": "      busy_blocks= 1.0;",
          "new_line_content": "    result= param->table->file->read_time(param->table->s->primary_key,",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": null,
          "new_api": "ha_rnd_end",
          "old_text": null,
          "new_text": "head->file->ha_rnd_end()",
          "old_line_content": "",
          "new_line_content": "    head->file->ha_rnd_end();",
          "content_same": false
        },
        {
          "line": 1722,
          "old_api": null,
          "new_api": "MYF",
          "old_text": null,
          "new_text": "MYF(0)",
          "old_line_content": "SEL_ARG::SEL_ARG(SEL_ARG &arg) :Sql_alloc()",
          "new_line_content": "  free_root(&alloc,MYF(0));",
          "content_same": false
        },
        {
          "line": 11958,
          "old_api": null,
          "new_api": "fprintf",
          "old_text": null,
          "new_text": "fprintf(DBUG_FILE, \"%*squick ROR-union select\\n\", indent, \"\")",
          "old_line_content": "  SYNOPSIS",
          "new_line_content": "  fprintf(DBUG_FILE, \"%*squick ROR-union select\\n\", indent, \"\");",
          "content_same": false
        },
        {
          "line": 11959,
          "old_api": null,
          "new_api": "fprintf",
          "old_text": null,
          "new_text": "fprintf(DBUG_FILE, \"%*smerged scans {\\n\", indent, \"\")",
          "old_line_content": "    QUICK_GROUP_MIN_MAX_SELECT::dbug_dump()",
          "new_line_content": "  fprintf(DBUG_FILE, \"%*smerged scans {\\n\", indent, \"\");",
          "content_same": false
        },
        {
          "line": 11961,
          "old_api": null,
          "new_api": "dbug_dump",
          "old_text": null,
          "new_text": "quick->dbug_dump(indent+2, verbose)",
          "old_line_content": "    verbose If TRUE show more detailed output.",
          "new_line_content": "    quick->dbug_dump(indent+2, verbose);",
          "content_same": false
        },
        {
          "line": 11962,
          "old_api": null,
          "new_api": "fprintf",
          "old_text": null,
          "new_text": "fprintf(DBUG_FILE, \"%*s}\\n\", indent, \"\")",
          "old_line_content": "",
          "new_line_content": "  fprintf(DBUG_FILE, \"%*s}\\n\", indent, \"\");",
          "content_same": false
        },
        {
          "line": 3771,
          "old_api": null,
          "new_api": "ulonglong2double",
          "old_text": null,
          "new_text": "ulonglong2double(param->table->file->stats.data_file_length)",
          "old_line_content": "    if (max_cost != DBL_MAX  && (busy_blocks+index_reads_cost) >= n_blocks)",
          "new_line_content": "      ceil(ulonglong2double(param->table->file->stats.data_file_length) /",
          "content_same": false
        },
        {
          "line": 3774,
          "old_api": null,
          "new_api": "rows2double",
          "old_text": null,
          "new_text": "rows2double(records)",
          "old_line_content": "    JOIN *join= param->thd->lex->select_lex.join;",
          "new_line_content": "      n_blocks * (1.0 - pow(1.0 - 1.0/n_blocks, rows2double(records)));",
          "content_same": false
        },
        {
          "line": 3777,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\",(\"sweep: nblocks: %g, busy_blocks: %g\", n_blocks,\n                       busy_blocks))",
          "old_line_content": "      /* No join, assume reading is done in one 'sweep' */",
          "new_line_content": "    DBUG_PRINT(\"info\",(\"sweep: nblocks: %g, busy_blocks: %g\", n_blocks,",
          "content_same": false
        },
        {
          "line": 5817,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "    {",
          "new_line_content": "    DBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 5824,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "\t\t\t    key_part->field,key_part,type,value);",
          "new_line_content": "    DBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 5827,
          "old_api": null,
          "new_api": "eq",
          "old_text": null,
          "new_text": "field->eq(key_part->field)",
          "old_line_content": "\tif (sel_arg->type == SEL_ARG::IMPOSSIBLE)",
          "new_line_content": "    if (field->eq(key_part->field))",
          "content_same": false
        },
        {
          "line": 7871,
          "old_api": null,
          "new_api": "uint) (tmp_max_key - max_key)",
          "old_text": null,
          "new_text": "uint) (tmp_max_key - max_key)",
          "old_line_content": "      min_range.length= min_key_length;",
          "new_line_content": "            !memcmp(min_key, max_key, (uint) (tmp_max_key - max_key)) &&",
          "content_same": false
        },
        {
          "line": 7873,
          "old_api": null,
          "new_api": "is_key_scan_ror",
          "old_text": null,
          "new_text": "is_key_scan_ror(param, keynr, key_tree->part + 1)",
          "old_line_content": "      /* In this case tmp_min_flag contains the handler-read-function */",
          "new_line_content": "            is_key_scan_ror(param, keynr, key_tree->part + 1)))",
          "content_same": false
        },
        {
          "line": 5831,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "\t}",
          "new_line_content": "\tDBUG_RETURN(0);\t\t\t\t// OOM",
          "content_same": false
        },
        {
          "line": 9928,
          "old_api": null,
          "new_api": "walk",
          "old_text": null,
          "new_text": "join->conds->walk(&Item::find_item_in_field_list_processor, 0,\n                              (uchar*) key_part_range)",
          "old_line_content": "    {",
          "new_line_content": "        if (join->conds->walk(&Item::find_item_in_field_list_processor, 0,",
          "content_same": false
        },
        {
          "line": 5832,
          "old_api": null,
          "new_api": "used_tables",
          "old_text": null,
          "new_text": "value->used_tables()",
          "old_line_content": "      }",
          "new_line_content": "      if (!value || !(value->used_tables() & ~param->read_tables))",
          "content_same": false
        },
        {
          "line": 5834,
          "old_api": null,
          "new_api": "get_mm_leaf",
          "old_text": null,
          "new_text": "get_mm_leaf(param,cond_func,\n\t\t\t    key_part->field,key_part,type,value)",
          "old_line_content": "      {",
          "new_line_content": "\tsel_arg=get_mm_leaf(param,cond_func,",
          "content_same": false
        },
        {
          "line": 7883,
          "old_api": null,
          "new_api": "make_keypart_map",
          "old_text": null,
          "new_text": "make_keypart_map(tmp_min_keypart)",
          "old_line_content": "      min_range.key=    param->min_key;",
          "new_line_content": "      min_range.keypart_map= make_keypart_map(tmp_min_keypart);",
          "content_same": false
        },
        {
          "line": 7885,
          "old_api": null,
          "new_api": "ha_rkey_function) (tmp_min_flag ^ GEOM_FLAG)",
          "old_text": null,
          "new_text": "ha_rkey_function) (tmp_min_flag ^ GEOM_FLAG)",
          "old_line_content": "      min_range.flag=   (tmp_min_flag & NEAR_MIN ? HA_READ_AFTER_KEY :",
          "new_line_content": "      min_range.flag=   (ha_rkey_function) (tmp_min_flag ^ GEOM_FLAG);",
          "content_same": false
        },
        {
          "line": 9944,
          "old_api": null,
          "new_api": "bitmap_is_set",
          "old_text": null,
          "new_text": "bitmap_is_set(table->read_set, cur_part->field->field_index)",
          "old_line_content": "    {",
          "new_line_content": "        if (bitmap_is_set(table->read_set, cur_part->field->field_index))",
          "content_same": false
        },
        {
          "line": 3801,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"return\",(\"cost: %g\", result))",
          "old_line_content": "      read_time Don't create scans with cost > read_time",
          "new_line_content": "  DBUG_PRINT(\"return\",(\"cost: %g\", result));",
          "content_same": false
        },
        {
          "line": 3802,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(result)",
          "old_line_content": "",
          "new_line_content": "  DBUG_RETURN(result);",
          "content_same": false
        },
        {
          "line": 11993,
          "old_api": null,
          "new_api": "fprintf",
          "old_text": null,
          "new_text": "fprintf(DBUG_FILE, \"%*susing key_infix with length %d:\\n\",\n            indent, \"\", key_infix_len)",
          "old_line_content": "            indent, \"\", min_max_ranges.elements);",
          "new_line_content": "    fprintf(DBUG_FILE, \"%*susing key_infix with length %d:\\n\",",
          "content_same": false
        },
        {
          "line": 5848,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": "}",
          "new_line_content": "\t  DBUG_RETURN(0);\t\t\t// OOM",
          "content_same": false
        },
        {
          "line": 5851,
          "old_api": null,
          "new_api": "sel_add",
          "old_text": null,
          "new_text": "sel_add(tree->keys[key_part->key],sel_arg)",
          "old_line_content": "static SEL_ARG *",
          "new_line_content": "      tree->keys[key_part->key]=sel_add(tree->keys[key_part->key],sel_arg);",
          "content_same": false
        },
        {
          "line": 11998,
          "old_api": null,
          "new_api": "fprintf",
          "old_text": null,
          "new_text": "fprintf(DBUG_FILE, \"%*susing quick_range_select:\\n\", indent, \"\")",
          "old_line_content": "#endif /* !DBUG_OFF */",
          "new_line_content": "    fprintf(DBUG_FILE, \"%*susing quick_range_select:\\n\", indent, \"\");",
          "content_same": false
        },
        {
          "line": 1759,
          "old_api": null,
          "new_api": "real_maybe_null",
          "old_text": null,
          "new_text": "f->real_maybe_null()",
          "old_line_content": "  :min_flag(min_flag_),max_flag(max_flag_),maybe_flag(maybe_flag_),",
          "new_line_content": "  :min_flag(0), max_flag(0), maybe_flag(0), maybe_null(f->real_maybe_null()),",
          "content_same": false
        },
        {
          "line": 11999,
          "old_api": null,
          "new_api": "dbug_dump",
          "old_text": null,
          "new_text": "quick_prefix_select->dbug_dump(indent + 2, verbose)",
          "old_line_content": "",
          "new_line_content": "    quick_prefix_select->dbug_dump(indent + 2, verbose);",
          "content_same": false
        },
        {
          "line": 5852,
          "old_api": null,
          "new_api": "set_bit",
          "old_text": null,
          "new_text": "tree->keys_map.set_bit(key_part->key)",
          "old_line_content": "get_mm_leaf(RANGE_OPT_PARAM *param, COND *conf_func, Field *field,",
          "new_line_content": "      tree->keys_map.set_bit(key_part->key);",
          "content_same": false
        },
        {
          "line": 5856,
          "old_api": null,
          "new_api": "is_clear_all",
          "old_text": null,
          "new_text": "tree->keys_map.is_clear_all()",
          "old_line_content": "  bool optimize_range;",
          "new_line_content": "  if (tree && tree->merges.is_empty() && tree->keys_map.is_clear_all())",
          "content_same": false
        },
        {
          "line": 12003,
          "old_api": null,
          "new_api": "fprintf",
          "old_text": null,
          "new_text": "fprintf(DBUG_FILE, \"%*susing %d quick_ranges for MIN/MAX:\\n\",\n            indent, \"\", min_max_ranges.elements)",
          "old_line_content": "",
          "new_line_content": "    fprintf(DBUG_FILE, \"%*susing %d quick_ranges for MIN/MAX:\\n\",",
          "content_same": false
        },
        {
          "line": 5858,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(tree)",
          "old_line_content": "  MEM_ROOT *alloc= param->mem_root;",
          "new_line_content": "  DBUG_RETURN(tree);",
          "content_same": false
        },
        {
          "line": 9957,
          "old_api": null,
          "new_api": "get_index_range_tree",
          "old_text": null,
          "new_text": "get_index_range_tree(cur_index, tree, param,\n                                                      &dummy)",
          "old_line_content": "    /* If we got to this point, cur_index_info passes the test. */",
          "new_line_content": "      SEL_ARG *index_range_tree= get_index_range_tree(cur_index, tree, param,",
          "content_same": false
        },
        {
          "line": 7903,
          "old_api": null,
          "new_api": "make_keypart_map",
          "old_text": null,
          "new_text": "make_keypart_map(tmp_max_keypart)",
          "old_line_content": "  records+=tmp;",
          "new_line_content": "      max_range.keypart_map= make_keypart_map(tmp_max_keypart);",
          "content_same": false
        },
        {
          "line": 7904,
          "old_api": null,
          "new_api": "records_in_range",
          "old_text": null,
          "new_text": "param->table->file->records_in_range(keynr,\n                                               (min_key_length ? &min_range :\n                                                (key_range*) 0),\n                                               (max_key_length ? &max_range :\n                                                (key_range*) 0))",
          "old_line_content": "  if (key_tree->right != &null_element)",
          "new_line_content": "      tmp=param->table->file->records_in_range(keynr,",
          "content_same": false
        },
        {
          "line": 9960,
          "old_api": null,
          "new_api": "get_sel_arg_for_keypart",
          "old_text": null,
          "new_text": "get_sel_arg_for_keypart(min_max_arg_part->field,\n                                  index_range_tree, &cur_range)",
          "old_line_content": "    cur_used_key_parts= cur_group_key_parts + key_infix_parts;",
          "new_line_content": "      if (get_sel_arg_for_keypart(min_max_arg_part->field,",
          "content_same": false
        },
        {
          "line": 5866,
          "old_api": null,
          "new_api": "real_maybe_null",
          "old_text": null,
          "new_text": "field->real_maybe_null()",
          "old_line_content": "    function because it evaluates the value of its argument, while",
          "new_line_content": "  uint maybe_null=(uint) field->real_maybe_null();",
          "content_same": false
        },
        {
          "line": 1771,
          "old_api": null,
          "new_api": "real_maybe_null",
          "old_text": null,
          "new_text": "field_->real_maybe_null()",
          "old_line_content": "",
          "new_line_content": "   part(part_),maybe_null(field_->real_maybe_null()), elements(1),use_count(1),",
          "content_same": false
        },
        {
          "line": 5873,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"get_mm_leaf\")",
          "old_line_content": "  if (!value)\t\t\t\t\t// IS NULL or IS NOT NULL",
          "new_line_content": "  DBUG_ENTER(\"get_mm_leaf\");",
          "content_same": false
        },
        {
          "line": 7924,
          "old_api": null,
          "new_api": "check_quick_keys",
          "old_text": null,
          "new_text": "check_quick_keys(param, idx, key_tree->right,\n                         min_key, min_key_flag, min_keypart,\n                         max_key, max_key_flag, max_keypart)",
          "old_line_content": "",
          "new_line_content": "    tmp=check_quick_keys(param, idx, key_tree->right,",
          "content_same": false
        },
        {
          "line": 9977,
          "old_api": null,
          "new_api": "get_index_range_tree",
          "old_text": null,
          "new_text": "get_index_range_tree(cur_index, tree, param,\n                                           &cur_param_idx)",
          "old_line_content": "      If cur_read_cost is lower than best_read_cost use cur_index.",
          "new_line_content": "      cur_index_tree= get_index_range_tree(cur_index, tree, param,",
          "content_same": false
        },
        {
          "line": 9980,
          "old_api": null,
          "new_api": "check_quick_select",
          "old_text": null,
          "new_text": "check_quick_select(param, cur_param_idx,\n                                                    cur_index_tree, TRUE)",
          "old_line_content": "    */",
          "new_line_content": "      cur_quick_prefix_records= check_quick_select(param, cur_param_idx,",
          "content_same": false
        },
        {
          "line": 9983,
          "old_api": null,
          "new_api": "cost_group_min_max",
          "old_text": null,
          "new_text": "cost_group_min_max(table, cur_index_info, cur_used_key_parts,\n                       cur_group_key_parts, tree, cur_index_tree,\n                       cur_quick_prefix_records, have_min, have_max,\n                       &cur_read_cost, &cur_records)",
          "old_line_content": "      index_info= cur_index_info;",
          "new_line_content": "    cost_group_min_max(table, cur_index_info, cur_used_key_parts,",
          "content_same": false
        },
        {
          "line": 1812,
          "old_api": null,
          "new_api": "clone",
          "old_text": null,
          "new_text": "right->clone(param, tmp, next_arg)",
          "old_line_content": "  in the red-black tree",
          "new_line_content": "      if (!(tmp->right= right->clone(param, tmp, next_arg)))",
          "content_same": false
        },
        {
          "line": 1815,
          "old_api": null,
          "new_api": "increment_use_count",
          "old_text": null,
          "new_text": "increment_use_count(1)",
          "old_line_content": "  SEL_ARG   first SEL_ARG in the interval list",
          "new_line_content": "  increment_use_count(1);",
          "content_same": false
        },
        {
          "line": 10012,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "  */",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 5916,
          "old_api": null,
          "new_api": "result_type",
          "old_text": null,
          "new_text": "field->result_type()",
          "old_line_content": "    // @todo: use is_spatial_operator() instead?",
          "new_line_content": "  if (field->result_type() == STRING_RESULT &&",
          "content_same": false
        },
        {
          "line": 5917,
          "old_api": null,
          "new_api": "match_collation_to_optimize_range",
          "old_text": null,
          "new_text": "(Field_str*) field)->match_collation_to_optimize_range()",
          "old_line_content": "    switch (type) {",
          "new_line_content": "      ((Field_str*) field)->match_collation_to_optimize_range() &&",
          "content_same": false
        },
        {
          "line": 5918,
          "old_api": null,
          "new_api": "result_type",
          "old_text": null,
          "new_text": "value->result_type()",
          "old_line_content": "    case Item_func::SP_EQUALS_FUNC:",
          "new_line_content": "      value->result_type() == STRING_RESULT &&",
          "content_same": false
        },
        {
          "line": 10016,
          "old_api": null,
          "new_api": "check_group_min_max_predicates",
          "old_text": null,
          "new_text": "check_group_min_max_predicates(join->conds, min_max_arg_item,\n                                      (index_info->flags & HA_SPATIAL) ?\n                                      Field::itMBR : Field::itRAW)",
          "old_line_content": "",
          "new_line_content": "      !check_group_min_max_predicates(join->conds, min_max_arg_item,",
          "content_same": false
        },
        {
          "line": 5920,
          "old_api": null,
          "new_api": "compare_collation",
          "old_text": null,
          "new_text": "conf_func->compare_collation()",
          "old_line_content": "    case Item_func::SP_INTERSECTS_FUNC:",
          "new_line_content": "      ((Field_str*)field)->charset() != conf_func->compare_collation() &&",
          "content_same": false
        },
        {
          "line": 5921,
          "old_api": null,
          "new_api": "compare_collation",
          "old_text": null,
          "new_text": "conf_func->compare_collation()",
          "old_line_content": "    case Item_func::SP_TOUCHES_FUNC:",
          "new_line_content": "      !(conf_func->compare_collation()->state & MY_CS_BINSORT &&",
          "content_same": false
        },
        {
          "line": 10019,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "                 TRP_GROUP_MIN_MAX(have_min, have_max, is_agg_distinct,",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 10025,
          "old_api": null,
          "new_api": "primary_key_is_clustered",
          "old_text": null,
          "new_text": "table->file->primary_key_is_clustered()",
          "old_line_content": "                                   tree, best_index_tree, best_param_idx,",
          "new_line_content": "      table->file->primary_key_is_clustered())",
          "content_same": false
        },
        {
          "line": 10026,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "                                   best_quick_prefix_records);",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 3885,
          "old_api": null,
          "new_api": "primary_key_is_clustered",
          "old_text": null,
          "new_text": "param->table->file->primary_key_is_clustered()",
          "old_line_content": "",
          "new_line_content": "  bool pk_is_clustered= param->table->file->primary_key_is_clustered();",
          "content_same": false
        },
        {
          "line": 7983,
          "old_api": null,
          "new_api": "primary_key_is_clustered",
          "old_text": null,
          "new_text": "param->table->file->primary_key_is_clustered()",
          "old_line_content": "      return FALSE;",
          "new_line_content": "  if (!param->table->file->primary_key_is_clustered() || pk_number == MAX_KEY)",
          "content_same": false
        },
        {
          "line": 1840,
          "old_api": null,
          "new_api": "first",
          "old_text": null,
          "new_text": "const_cast<SEL_ARG*>(this)->first()",
          "old_line_content": "}",
          "new_line_content": "  return const_cast<SEL_ARG*>(this)->first();",
          "content_same": false
        },
        {
          "line": 3894,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"get_best_disjunct_quick\")",
          "old_line_content": "  */",
          "new_line_content": "  DBUG_ENTER(\"get_best_disjunct_quick\");",
          "content_same": false
        },
        {
          "line": 3895,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\", (\"Full table scan cost: %g\", read_time))",
          "old_line_content": "  for (ptree= imerge->trees, cur_child= range_scans;",
          "new_line_content": "  DBUG_PRINT(\"info\", (\"Full table scan cost: %g\", read_time));",
          "content_same": false
        },
        {
          "line": 10041,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "               (\"Returning group min/max plan: cost: %g, records: %lu\",",
          "new_line_content": "      DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 3897,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(param->mem_root,\n                                             sizeof(TRP_RANGE*)*\n                                             n_child_scans)",
          "old_line_content": "       ptree++, cur_child++)",
          "new_line_content": "  if (!(range_scans= (TRP_RANGE**)alloc_root(param->mem_root,",
          "content_same": false
        },
        {
          "line": 3900,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "                                        \"tree in SEL_IMERGE\"););",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 5948,
          "old_api": null,
          "new_api": "optimize_range",
          "old_text": null,
          "new_text": "field->optimize_range(param->real_keynr[key_part->key],\n                                          key_part->part)",
          "old_line_content": "    size_t length, offset, min_length, max_length;",
          "new_line_content": "    optimize_range= field->optimize_range(param->real_keynr[key_part->key],",
          "content_same": false
        },
        {
          "line": 10048,
          "old_api": null,
          "new_api": "use_index_scan",
          "old_text": null,
          "new_text": "read_plan->use_index_scan()",
          "old_line_content": "",
          "new_line_content": "      read_plan->use_index_scan();",
          "content_same": false
        },
        {
          "line": 10051,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\",\n               (\"Returning group min/max plan: cost: %g, records: %lu\",\n                read_plan->read_cost, (ulong) read_plan->records))",
          "old_line_content": "  with constants.",
          "new_line_content": "    DBUG_PRINT(\"info\",",
          "content_same": false
        },
        {
          "line": 3910,
          "old_api": null,
          "new_api": "print_sel_tree",
          "old_text": null,
          "new_text": "print_sel_tree(param, *ptree, &(*ptree)->keys_map,\n                                        \"tree in SEL_IMERGE\")",
          "old_line_content": "    }",
          "new_line_content": "    DBUG_EXECUTE(\"info\", print_sel_tree(param, *ptree, &(*ptree)->keys_map,",
          "content_same": false
        },
        {
          "line": 10056,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(read_plan)",
          "old_line_content": "                      clause being analyzed",
          "new_line_content": "  DBUG_RETURN(read_plan);",
          "content_same": false
        },
        {
          "line": 3912,
          "old_api": null,
          "new_api": "get_key_scans_params",
          "old_text": null,
          "new_text": "get_key_scans_params(param, *ptree, TRUE, FALSE, read_time)",
          "old_line_content": "      continue;",
          "new_line_content": "    if (!(*cur_child= get_key_scans_params(param, *ptree, TRUE, FALSE, read_time)))",
          "content_same": false
        },
        {
          "line": 5960,
          "old_api": null,
          "new_api": "pack_length",
          "old_text": null,
          "new_text": "field->pack_length()",
          "old_line_content": "      TODO:",
          "new_line_content": "    uint field_length= field->pack_length()+maybe_null;",
          "content_same": false
        },
        {
          "line": 5964,
          "old_api": null,
          "new_api": "val_str",
          "old_text": null,
          "new_text": "value->val_str(&tmp)",
          "old_line_content": "    if (res != &tmp)",
          "new_line_content": "    if (!(res= value->val_str(&tmp)))",
          "content_same": false
        },
        {
          "line": 1874,
          "old_api": null,
          "new_api": "real_maybe_null",
          "old_text": null,
          "new_text": "field->real_maybe_null()",
          "old_line_content": "  if (cmp) return cmp < 0 ? -1 : 1;\t\t// The values differed",
          "new_line_content": "  if (field->real_maybe_null())\t\t\t// If null is part of key",
          "content_same": false
        },
        {
          "line": 5977,
          "old_api": null,
          "new_api": "copy",
          "old_text": null,
          "new_text": "tmp.copy(*res)",
          "old_line_content": "      /* key packed with length prefix */",
          "new_line_content": "      tmp.copy(*res);\t\t\t\t// Get own copy",
          "content_same": false
        },
        {
          "line": 8026,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"get_quick_select\")",
          "old_line_content": "",
          "new_line_content": "  DBUG_ENTER(\"get_quick_select\");",
          "content_same": false
        },
        {
          "line": 1884,
          "old_api": null,
          "new_api": "key_cmp",
          "old_text": null,
          "new_text": "field->key_cmp(a , b)",
          "old_line_content": "    return (a_flag & NEAR_MIN) ? 1 : -1;",
          "new_line_content": "  cmp=field->key_cmp(a , b);",
          "content_same": false
        },
        {
          "line": 5980,
          "old_api": null,
          "new_api": "cmp_type",
          "old_text": null,
          "new_text": "field->cmp_type()",
          "old_line_content": "    }",
          "new_line_content": "    if (field->cmp_type() != STRING_RESULT)",
          "content_same": false
        },
        {
          "line": 8031,
          "old_api": null,
          "new_api": "test",
          "old_text": null,
          "new_text": "test(parent_alloc)",
          "old_line_content": "\t\t       param->max_key,0))",
          "new_line_content": "                                      test(parent_alloc),",
          "content_same": false
        },
        {
          "line": 8036,
          "old_api": null,
          "new_api": "test",
          "old_text": null,
          "new_text": "test(parent_alloc)",
          "old_line_content": "    else",
          "new_line_content": "                                 test(parent_alloc));",
          "content_same": false
        },
        {
          "line": 10086,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"check_group_min_max_predicates\")",
          "old_line_content": "    {",
          "new_line_content": "  DBUG_ENTER(\"check_group_min_max_predicates\");",
          "content_same": false
        },
        {
          "line": 8041,
          "old_api": null,
          "new_api": "get_quick_keys",
          "old_text": null,
          "new_text": "get_quick_keys(param,quick,param->key[idx],key_tree,param->min_key,0,\n\t\t       param->max_key,0)",
          "old_line_content": "                    sizeof(KEY_PART)*",
          "new_line_content": "\tget_quick_keys(param,quick,param->key[idx],key_tree,param->min_key,0,",
          "content_same": false
        },
        {
          "line": 10090,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "cond->type()",
          "old_line_content": "    }",
          "new_line_content": "  Item::Type cond_type= cond->type();",
          "content_same": false
        },
        {
          "line": 5994,
          "old_api": null,
          "new_api": "unlikely",
          "old_text": null,
          "new_text": "unlikely(length < field_length)",
          "old_line_content": "    length+=offset;",
          "new_line_content": "      if (unlikely(length < field_length))",
          "content_same": false
        },
        {
          "line": 10093,
          "old_api": null,
          "new_api": "func_name",
          "old_text": null,
          "new_text": "(Item_func*) cond)->func_name()",
          "old_line_content": "",
          "new_line_content": "    DBUG_PRINT(\"info\", (\"Analyzing: %s\", ((Item_func*) cond)->func_name()));",
          "content_same": false
        },
        {
          "line": 10094,
          "old_api": null,
          "new_api": "argument_list",
          "old_text": null,
          "new_text": "(Item_cond*) cond)->argument_list()",
          "old_line_content": "  /*",
          "new_line_content": "    List_iterator_fast<Item> li(*((Item_cond*) cond)->argument_list());",
          "content_same": false
        },
        {
          "line": 3950,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "    roru_read_plans= (TABLE_READ_PLAN**)range_scans;",
          "new_line_content": "    DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 10098,
          "old_api": null,
          "new_api": "check_group_min_max_predicates",
          "old_text": null,
          "new_text": "check_group_min_max_predicates(and_or_arg, min_max_arg_item,\n                                         image_type)",
          "old_line_content": "    optimization all queries with subselects in the WHERE clause. What has to",
          "new_line_content": "      if (!check_group_min_max_predicates(and_or_arg, min_max_arg_item,",
          "content_same": false
        },
        {
          "line": 1907,
          "old_api": null,
          "new_api": "clone",
          "old_text": null,
          "new_text": "clone(param, (SEL_ARG *) 0, &next_arg)",
          "old_line_content": "  Table rows retrieval plan. Range optimizer creates QUICK_SELECT_I-derived",
          "new_line_content": "  if (!(root= clone(param, (SEL_ARG *) 0, &next_arg)))",
          "content_same": false
        },
        {
          "line": 10100,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(FALSE)",
          "old_line_content": "    the MIN/MAX argument field, and disallow the optimization only if this is",
          "new_line_content": "        DBUG_RETURN(FALSE);",
          "content_same": false
        },
        {
          "line": 8050,
          "old_api": null,
          "new_api": "memdup_root",
          "old_text": null,
          "new_text": "memdup_root(parent_alloc? parent_alloc : &quick->alloc,\n                    (char*) param->key[idx],\n                    sizeof(KEY_PART)*\n                    param->table->key_info[param->real_keynr[idx]].key_parts)",
          "old_line_content": "** Fix this to get all possible sub_ranges",
          "new_line_content": "        memdup_root(parent_alloc? parent_alloc : &quick->alloc,",
          "content_same": false
        },
        {
          "line": 10102,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(TRUE)",
          "old_line_content": "  */",
          "new_line_content": "    DBUG_RETURN(TRUE);",
          "content_same": false
        },
        {
          "line": 3959,
          "old_api": null,
          "new_api": "optimizer_flag",
          "old_text": null,
          "new_text": "optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_UNION)",
          "old_line_content": "     */",
          "new_line_content": "      optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_UNION))",
          "content_same": false
        },
        {
          "line": 6006,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(alloc, length*2)",
          "old_line_content": "\t\t\t      wild_one, wild_many,",
          "new_line_content": "    if (!(min_str= (uchar*) alloc_root(alloc, length*2)))",
          "content_same": false
        },
        {
          "line": 8056,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(quick)",
          "old_line_content": "{",
          "new_line_content": "  DBUG_RETURN(quick);",
          "content_same": false
        },
        {
          "line": 6014,
          "old_api": null,
          "new_api": "charset",
          "old_text": null,
          "new_text": "field->charset()",
          "old_line_content": "    {",
          "new_line_content": "    like_error= my_like_range(field->charset(),",
          "content_same": false
        },
        {
          "line": 10115,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(FALSE)",
          "old_line_content": "",
          "new_line_content": "    DBUG_RETURN(FALSE);",
          "content_same": false
        },
        {
          "line": 3976,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\",(\"index_merge cost with rowid-to-row scan: %g\",\n                     imerge_cost))",
          "old_line_content": "                                    param->table->file->ref_length,",
          "new_line_content": "  DBUG_PRINT(\"info\",(\"index_merge cost with rowid-to-row scan: %g\",",
          "content_same": false
        },
        {
          "line": 6026,
          "old_api": null,
          "new_api": "int2store",
          "old_text": null,
          "new_text": "int2store(min_str+maybe_null,min_length)",
          "old_line_content": "",
          "new_line_content": "      int2store(min_str+maybe_null,min_length);",
          "content_same": false
        },
        {
          "line": 3979,
          "old_api": null,
          "new_api": "optimizer_flag",
          "old_text": null,
          "new_text": "optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_SORT_UNION)",
          "old_line_content": "  {",
          "new_line_content": "      !optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_SORT_UNION))",
          "content_same": false
        },
        {
          "line": 6027,
          "old_api": null,
          "new_api": "int2store",
          "old_text": null,
          "new_text": "int2store(max_str+maybe_null,max_length)",
          "old_line_content": "  /*",
          "new_line_content": "      int2store(max_str+maybe_null,max_length);",
          "content_same": false
        },
        {
          "line": 8075,
          "old_api": null,
          "new_api": "get_quick_keys",
          "old_text": null,
          "new_text": "get_quick_keys(param,quick,key,key_tree->left,\n\t\t       min_key,min_key_flag, max_key, max_key_flag)",
          "old_line_content": "      key_tree->next_key_part->type == SEL_ARG::KEY_RANGE &&",
          "new_line_content": "    if (get_quick_keys(param,quick,key,key_tree->left,",
          "content_same": false
        },
        {
          "line": 8080,
          "old_api": null,
          "new_api": "store_min",
          "old_text": null,
          "new_text": "key_tree->store_min(key[key_tree->part].store_length,\n                                 &tmp_min_key,min_key_flag)",
          "old_line_content": "\t key_tree->min_flag==0 && key_tree->max_flag==0)",
          "new_line_content": "  min_part+= key_tree->store_min(key[key_tree->part].store_length,",
          "content_same": false
        },
        {
          "line": 3986,
          "old_api": null,
          "new_api": "Unique::get_cost_calc_buff_size((ulong)non_cpk_scan_records,\n                                    param->table->file->ref_length,\n                                    param->thd->variables.sortbuff_size)",
          "old_text": null,
          "new_text": "Unique::get_cost_calc_buff_size((ulong)non_cpk_scan_records,\n                                    param->table->file->ref_length,\n                                    param->thd->variables.sortbuff_size)",
          "old_line_content": "  imerge_cost +=",
          "new_line_content": "    Unique::get_cost_calc_buff_size((ulong)non_cpk_scan_records,",
          "content_same": false
        },
        {
          "line": 10132,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "pred->arguments()",
          "old_line_content": "       /*",
          "new_line_content": "  Item **arguments= pred->arguments();",
          "content_same": false
        },
        {
          "line": 10134,
          "old_api": null,
          "new_api": "func_name",
          "old_text": null,
          "new_text": "pred->func_name()",
          "old_line_content": "         condition that compares the MIN/MAX argument with a constant.",
          "new_line_content": "  DBUG_PRINT(\"info\", (\"Analyzing: %s\", pred->func_name()));",
          "content_same": false
        },
        {
          "line": 10135,
          "old_api": null,
          "new_api": "pred->argument_count ()",
          "old_text": null,
          "new_text": "pred->argument_count ()",
          "old_line_content": "       */",
          "new_line_content": "  for (uint arg_idx= 0; arg_idx < pred->argument_count (); arg_idx++)",
          "content_same": false
        },
        {
          "line": 3991,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(param->mem_root,\n                                                     unique_calc_buff_size)",
          "old_line_content": "                     imerge_cost, read_time));",
          "new_line_content": "    if (!(param->imerge_cost_buff= (uint*)alloc_root(param->mem_root,",
          "content_same": false
        },
        {
          "line": 10137,
          "old_api": null,
          "new_api": "real_item",
          "old_text": null,
          "new_text": "arguments[arg_idx]->real_item()",
          "old_line_content": "        if (pred_type != Item_func::EQUAL_FUNC     &&",
          "new_line_content": "    cur_arg= arguments[arg_idx]->real_item();",
          "content_same": false
        },
        {
          "line": 10138,
          "old_api": null,
          "new_api": "full_name",
          "old_text": null,
          "new_text": "cur_arg->full_name()",
          "old_line_content": "            pred_type != Item_func::LT_FUNC        &&",
          "new_line_content": "    DBUG_PRINT(\"info\", (\"cur_arg: %s\", cur_arg->full_name()));",
          "content_same": false
        },
        {
          "line": 10139,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "cur_arg->type()",
          "old_line_content": "            pred_type != Item_func::LE_FUNC        &&",
          "new_line_content": "    if (cur_arg->type() == Item::FIELD_ITEM)",
          "content_same": false
        },
        {
          "line": 3993,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(NULL)",
          "old_line_content": "  {",
          "new_line_content": "      DBUG_RETURN(NULL);",
          "content_same": false
        },
        {
          "line": 10141,
          "old_api": null,
          "new_api": "eq",
          "old_text": null,
          "new_text": "min_max_arg_item->eq(cur_arg, 1)",
          "old_line_content": "            pred_type != Item_func::GE_FUNC        &&",
          "new_line_content": "      if (min_max_arg_item->eq(cur_arg, 1)) ",
          "content_same": false
        },
        {
          "line": 6042,
          "old_api": null,
          "new_api": "result_type",
          "old_text": null,
          "new_text": "field->result_type()",
          "old_line_content": "  if (err > 0)",
          "new_line_content": "  if (field->result_type() == STRING_RESULT &&",
          "content_same": false
        },
        {
          "line": 6043,
          "old_api": null,
          "new_api": "result_type",
          "old_text": null,
          "new_text": "value->result_type()",
          "old_line_content": "  {",
          "new_line_content": "      value->result_type() != STRING_RESULT &&",
          "content_same": false
        },
        {
          "line": 8090,
          "old_api": null,
          "new_api": "uint)(tmp_max_key - max_key)",
          "old_text": null,
          "new_text": "uint)(tmp_max_key - max_key)",
          "old_line_content": "      if (!tmp_min_flag)",
          "new_line_content": "         memcmp(min_key, max_key, (uint)(tmp_max_key - max_key))==0 &&",
          "content_same": false
        },
        {
          "line": 4001,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\",(\"index_merge total cost: %g (wanted: less then %g)\",\n                     imerge_cost, read_time))",
          "old_line_content": "      imerge_trp->range_scans_end= range_scans + n_child_scans;",
          "new_line_content": "  DBUG_PRINT(\"info\",(\"index_merge total cost: %g (wanted: less then %g)\",",
          "content_same": false
        },
        {
          "line": 6049,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "field->type()",
          "old_line_content": "      {",
          "new_line_content": "      (field->type() == MYSQL_TYPE_DATE ||",
          "content_same": false
        },
        {
          "line": 6050,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "field->type()",
          "old_line_content": "        tree= new (alloc) SEL_ARG(field, 0, 0);",
          "new_line_content": "       field->type() == MYSQL_TYPE_DATETIME))",
          "content_same": false
        },
        {
          "line": 6052,
          "old_api": null,
          "new_api": "save_in_field_no_warnings",
          "old_text": null,
          "new_text": "value->save_in_field_no_warnings(field, 1)",
          "old_line_content": "        field->table->in_use->variables.sql_mode= orig_sql_mode;",
          "new_line_content": "  err= value->save_in_field_no_warnings(field, 1);",
          "content_same": false
        },
        {
          "line": 8093,
          "old_api": null,
          "new_api": "get_quick_keys",
          "old_text": null,
          "new_text": "get_quick_keys(param,quick,key,key_tree->next_key_part,\n\t\t\t tmp_min_key, min_key_flag | key_tree->min_flag,\n\t\t\t tmp_max_key, max_key_flag | key_tree->max_flag)",
          "old_line_content": "                                                          &tmp_min_flag,",
          "new_line_content": "      if (get_quick_keys(param,quick,key,key_tree->next_key_part,",
          "content_same": false
        },
        {
          "line": 8102,
          "old_api": null,
          "new_api": "store_min_key",
          "old_text": null,
          "new_text": "key_tree->next_key_part->store_min_key(key,\n                                                          &tmp_min_key,\n                                                          &tmp_min_flag,\n                                                          MAX_KEY)",
          "old_line_content": "  }",
          "new_line_content": "        min_part+= key_tree->next_key_part->store_min_key(key,",
          "content_same": false
        },
        {
          "line": 1959,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(mem_root, (uint) size)",
          "old_line_content": "",
          "new_line_content": "  { return (void*) alloc_root(mem_root, (uint) size); }",
          "content_same": false
        },
        {
          "line": 1960,
          "old_api": null,
          "new_api": "TRASH",
          "old_text": null,
          "new_text": "TRASH(ptr, size)",
          "old_line_content": "/*",
          "new_line_content": "  static void operator delete(void *ptr,size_t size) { TRASH(ptr, size); }",
          "content_same": false
        },
        {
          "line": 6055,
          "old_api": null,
          "new_api": "result_type",
          "old_text": null,
          "new_text": "value->result_type()",
          "old_line_content": "      else",
          "new_line_content": "    if (field->cmp_type() != value->result_type())",
          "content_same": false
        },
        {
          "line": 6058,
          "old_api": null,
          "new_api": "result_type",
          "old_text": null,
          "new_text": "field->result_type()",
          "old_line_content": "          TODO: We should return trees of the type SEL_ARG::IMPOSSIBLE",
          "new_line_content": "          value->result_type() == item_cmp_type(field->result_type(),",
          "content_same": false
        },
        {
          "line": 6059,
          "old_api": null,
          "new_api": "result_type",
          "old_text": null,
          "new_text": "value->result_type()",
          "old_line_content": "          for the cases like int_field > 999999999999999999999999 as well.",
          "new_line_content": "                                                value->result_type()))",
          "content_same": false
        },
        {
          "line": 8107,
          "old_api": null,
          "new_api": "store_max_key",
          "old_text": null,
          "new_text": "key_tree->next_key_part->store_max_key(key,\n                                                          &tmp_max_key,\n                                                          &tmp_max_flag,\n                                                          MAX_KEY)",
          "old_line_content": "  }",
          "new_line_content": "        max_part+= key_tree->next_key_part->store_max_key(key,",
          "content_same": false
        },
        {
          "line": 10158,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(FALSE)",
          "old_line_content": "        if (args[0] && args[1] && !args[2] && // this is a binary function",
          "new_line_content": "          DBUG_RETURN(FALSE);",
          "content_same": false
        },
        {
          "line": 10162,
          "old_api": null,
          "new_api": "bzero",
          "old_text": null,
          "new_text": "bzero(args, 3 * sizeof(Item*))",
          "old_line_content": "            */",
          "new_line_content": "        bzero(args, 3 * sizeof(Item*));",
          "content_same": false
        },
        {
          "line": 4020,
          "old_api": null,
          "new_api": "optimizer_flag",
          "old_text": null,
          "new_text": "optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_UNION)",
          "old_line_content": "  roru_index_costs= 0.0;",
          "new_line_content": "      !optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_UNION))",
          "content_same": false
        },
        {
          "line": 4021,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(imerge_trp)",
          "old_line_content": "  roru_total_records= 0;",
          "new_line_content": "    DBUG_RETURN(imerge_trp);",
          "content_same": false
        },
        {
          "line": 6073,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "field->type()",
          "old_line_content": "",
          "new_line_content": "        if (err == 3 && field->type() == FIELD_TYPE_DATE &&",
          "content_same": false
        },
        {
          "line": 10170,
          "old_api": null,
          "new_api": "result_type",
          "old_text": null,
          "new_text": "min_max_arg_item->result_type()",
          "old_line_content": "               number.",
          "new_line_content": "            min_max_arg_item->result_type() == STRING_RESULT &&",
          "content_same": false
        },
        {
          "line": 4026,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(param->mem_root,\n                                        sizeof(TABLE_READ_PLAN*)*\n                                        n_child_scans)",
          "old_line_content": "       ptree != imerge->trees_next;",
          "new_line_content": "          (TABLE_READ_PLAN**)alloc_root(param->mem_root,",
          "content_same": false
        },
        {
          "line": 4029,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(imerge_trp)",
          "old_line_content": "    /*",
          "new_line_content": "    DBUG_RETURN(imerge_trp);",
          "content_same": false
        },
        {
          "line": 10176,
          "old_api": null,
          "new_api": "charset",
          "old_text": null,
          "new_text": "(Field_str*) min_max_arg_item->field)->charset()",
          "old_line_content": "    }",
          "new_line_content": "              ((Field_str*) min_max_arg_item->field)->charset() !=",
          "content_same": false
        },
        {
          "line": 1992,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"TRP_RANGE::make_quick\")",
          "old_line_content": "",
          "new_line_content": "    DBUG_ENTER(\"TRP_RANGE::make_quick\");",
          "content_same": false
        },
        {
          "line": 10184,
          "old_api": null,
          "new_api": "result_type",
          "old_text": null,
          "new_text": "args[1]->result_type()",
          "old_line_content": "    {",
          "new_line_content": "              min_max_arg_item->field->cmp_type() != args[1]->result_type())))",
          "content_same": false
        },
        {
          "line": 1994,
          "old_api": null,
          "new_api": "get_quick_select",
          "old_text": null,
          "new_text": "get_quick_select(param, key_idx, key, parent_alloc)",
          "old_line_content": "",
          "new_line_content": "    if ((quick= get_quick_select(param, key_idx, key, parent_alloc)))",
          "content_same": false
        },
        {
          "line": 10185,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(FALSE)",
          "old_line_content": "      /*",
          "new_line_content": "          DBUG_RETURN(FALSE);",
          "content_same": false
        },
        {
          "line": 10188,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "cur_arg->type()",
          "old_line_content": "      */",
          "new_line_content": "    else if (cur_arg->type() == Item::FUNC_ITEM)",
          "content_same": false
        },
        {
          "line": 8137,
          "old_api": null,
          "new_api": "uint) (tmp_min_key - param->min_key)",
          "old_text": null,
          "new_text": "uint) (tmp_min_key - param->min_key)",
          "old_line_content": "                             param->min_key,",
          "new_line_content": "    uint length= (uint) (tmp_min_key - param->min_key);",
          "content_same": false
        },
        {
          "line": 10190,
          "old_api": null,
          "new_api": "check_group_min_max_predicates",
          "old_text": null,
          "new_text": "check_group_min_max_predicates(cur_arg, min_max_arg_item,\n                                         image_type)",
          "old_line_content": "    }",
          "new_line_content": "      if (!check_group_min_max_predicates(cur_arg, min_max_arg_item,",
          "content_same": false
        },
        {
          "line": 1999,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(quick)",
          "old_line_content": "  virtual ~TRP_ROR_INTERSECT() {}             /* Remove gcc warning */",
          "new_line_content": "    DBUG_RETURN(quick);",
          "content_same": false
        },
        {
          "line": 8139,
          "old_api": null,
          "new_api": "memcmp",
          "old_text": null,
          "new_text": "memcmp(param->min_key,param->max_key,length)",
          "old_line_content": "          flag|= NULL_RANGE;",
          "new_line_content": "\t!memcmp(param->min_key,param->max_key,length))",
          "content_same": false
        },
        {
          "line": 10194,
          "old_api": null,
          "new_api": "const_item",
          "old_text": null,
          "new_text": "cur_arg->const_item()",
          "old_line_content": "",
          "new_line_content": "    else if (cur_arg->const_item())",
          "content_same": false
        },
        {
          "line": 4050,
          "old_api": null,
          "new_api": "param->table->file->\n              read_time(param->real_keynr[(*cur_child)->key_idx], 1,\n                        (*cur_child)->records)",
          "old_text": null,
          "new_text": "param->table->file->\n              read_time(param->real_keynr[(*cur_child)->key_idx], 1,\n                        (*cur_child)->records)",
          "old_line_content": "    {",
          "new_line_content": "      cost= param->table->file->",
          "content_same": false
        },
        {
          "line": 8147,
          "old_api": null,
          "new_api": "null_part_in_key",
          "old_text": null,
          "new_text": "null_part_in_key(key,\n                             param->min_key,\n                             (uint) (tmp_min_key - param->min_key))",
          "old_line_content": "  if (!(range= new QUICK_RANGE(param->min_key,",
          "new_line_content": "            null_part_in_key(key,",
          "content_same": false
        },
        {
          "line": 4053,
          "old_api": null,
          "new_api": "rows2double",
          "old_text": null,
          "new_text": "rows2double((*cur_child)->records)",
          "old_line_content": "      else",
          "new_line_content": "              rows2double((*cur_child)->records) / TIME_FOR_COMPARE;",
          "content_same": false
        },
        {
          "line": 10203,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(FALSE)",
          "old_line_content": "",
          "new_line_content": "      DBUG_RETURN(FALSE);",
          "content_same": false
        },
        {
          "line": 4059,
          "old_api": null,
          "new_api": "get_best_ror_intersect",
          "old_text": null,
          "new_text": "get_best_ror_intersect(param, *ptree, cost,\n                                                 &dummy)",
          "old_line_content": "        ((TRP_ROR_INTERSECT*)(*cur_roru_plan))->index_scan_costs;",
          "new_line_content": "    if (!(*cur_roru_plan= get_best_ror_intersect(param, *ptree, cost,",
          "content_same": false
        },
        {
          "line": 6109,
          "old_api": null,
          "new_api": "result_type",
          "old_text": null,
          "new_text": "field->result_type()",
          "old_line_content": "  }",
          "new_line_content": "    else if (err == 1 && field->result_type() == INT_RESULT)",
          "content_same": false
        },
        {
          "line": 10206,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(TRUE)",
          "old_line_content": "",
          "new_line_content": "  DBUG_RETURN(TRUE);",
          "content_same": false
        },
        {
          "line": 6111,
          "old_api": null,
          "new_api": "val_int",
          "old_text": null,
          "new_text": "value->val_int()",
          "old_line_content": "  {",
          "new_line_content": "      if (type == Item_func::LT_FUNC && (value->val_int() > 0))",
          "content_same": false
        },
        {
          "line": 8160,
          "old_api": null,
          "new_api": "make_keypart_map",
          "old_text": null,
          "new_text": "make_keypart_map(min_part)",
          "old_line_content": "    return 1;",
          "new_line_content": "                               min_part >=0 ? make_keypart_map(min_part) : 0,",
          "content_same": false
        },
        {
          "line": 4065,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(imerge_trp)",
          "old_line_content": "  /*",
          "new_line_content": "        DBUG_RETURN(imerge_trp);",
          "content_same": false
        },
        {
          "line": 6114,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "field->type()",
          "old_line_content": "    tree= &null_element;                        // cmp with NULL is never TRUE",
          "new_line_content": "               (field->type() != FIELD_TYPE_BIT) &&",
          "content_same": false
        },
        {
          "line": 8162,
          "old_api": null,
          "new_api": "uint) (tmp_max_key - param->max_key)",
          "old_text": null,
          "new_text": "uint) (tmp_max_key - param->max_key)",
          "old_line_content": " end:",
          "new_line_content": "\t\t\t       (uint) (tmp_max_key - param->max_key),",
          "content_same": false
        },
        {
          "line": 8163,
          "old_api": null,
          "new_api": "make_keypart_map",
          "old_text": null,
          "new_text": "make_keypart_map(max_part)",
          "old_line_content": "  if (key_tree->right != &null_element)",
          "new_line_content": "                               max_part >=0 ? make_keypart_map(max_part) : 0,",
          "content_same": false
        },
        {
          "line": 6117,
          "old_api": null,
          "new_api": "val_int",
          "old_text": null,
          "new_text": "value->val_int()",
          "old_line_content": "  field->table->in_use->variables.sql_mode= orig_sql_mode;",
          "new_line_content": "               (value->val_int() < 0))",
          "content_same": false
        },
        {
          "line": 8167,
          "old_api": null,
          "new_api": "set_if_bigger",
          "old_text": null,
          "new_text": "set_if_bigger(quick->max_used_key_length, range->min_length)",
          "old_line_content": "  return 0;",
          "new_line_content": "  set_if_bigger(quick->max_used_key_length, range->min_length);",
          "content_same": false
        },
        {
          "line": 8168,
          "old_api": null,
          "new_api": "set_if_bigger",
          "old_text": null,
          "new_text": "set_if_bigger(quick->max_used_key_length, range->max_length)",
          "old_line_content": "}",
          "new_line_content": "  set_if_bigger(quick->max_used_key_length, range->max_length);",
          "content_same": false
        },
        {
          "line": 8169,
          "old_api": null,
          "new_api": "set_if_bigger",
          "old_text": null,
          "new_text": "set_if_bigger(quick->used_key_parts, (uint) key_tree->part+1)",
          "old_line_content": "",
          "new_line_content": "  set_if_bigger(quick->used_key_parts, (uint) key_tree->part+1);",
          "content_same": false
        },
        {
          "line": 8170,
          "old_api": null,
          "new_api": "insert_dynamic",
          "old_text": null,
          "new_text": "insert_dynamic(&quick->ranges, (uchar*) &range)",
          "old_line_content": "/*",
          "new_line_content": "  if (insert_dynamic(&quick->ranges, (uchar*) &range))",
          "content_same": false
        },
        {
          "line": 8175,
          "old_api": null,
          "new_api": "get_quick_keys",
          "old_text": null,
          "new_text": "get_quick_keys(param,quick,key,key_tree->right,\n\t\t\t  min_key,min_key_flag,\n\t\t\t  max_key,max_key_flag)",
          "old_line_content": "{",
          "new_line_content": "    return get_quick_keys(param,quick,key,key_tree->right,",
          "content_same": false
        },
        {
          "line": 4082,
          "old_api": null,
          "new_api": "ha_rows)(roru_intersect_part*\n                                  param->table->file->stats.records)",
          "old_text": null,
          "new_text": "ha_rows)(roru_intersect_part*\n                                  param->table->file->stats.records)",
          "old_line_content": "  double roru_total_cost;",
          "new_line_content": "  roru_total_records -= (ha_rows)(roru_intersect_part*",
          "content_same": false
        },
        {
          "line": 6140,
          "old_api": null,
          "new_api": "alloc_root",
          "old_text": null,
          "new_text": "alloc_root(alloc, key_part->store_length+1)",
          "old_line_content": "    Check if we are comparing an UNSIGNED integer with a negative constant.",
          "new_line_content": "  str= (uchar*) alloc_root(alloc, key_part->store_length+1);",
          "content_same": false
        },
        {
          "line": 4095,
          "old_api": null,
          "new_api": "log",
          "old_text": null,
          "new_text": "log((double)n_child_scans)",
          "old_line_content": "      roru->first_ror= roru_read_plans;",
          "new_line_content": "                   rows2double(roru_total_records)*log((double)n_child_scans) /",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 10244,
          "old_api": "first",
          "new_api": null,
          "old_text": "keypart_tree->first()",
          "new_text": null,
          "old_line_content": "  SEL_ARG *first_kp=  keypart_tree->first();",
          "new_line_content": "                        SEL_ARG **cur_range)",
          "content_same": false
        },
        {
          "line": 4102,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(imerge_trp)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(imerge_trp);",
          "new_line_content": "  if (roru_total_cost < read_time)",
          "content_same": false
        },
        {
          "line": 6150,
          "old_api": "result_type",
          "new_api": null,
          "old_text": "field->result_type()",
          "new_text": null,
          "old_line_content": "  if (field->result_type() == INT_RESULT &&",
          "new_line_content": "  /*",
          "content_same": false
        },
        {
          "line": 6151,
          "old_api": "result_type",
          "new_api": null,
          "old_text": "value->result_type()",
          "new_text": null,
          "old_line_content": "      value->result_type() == INT_RESULT &&",
          "new_line_content": "    Check if we are comparing an UNSIGNED integer with a negative constant.",
          "content_same": false
        },
        {
          "line": 6152,
          "old_api": "type",
          "new_api": null,
          "old_text": "field->type()",
          "new_text": null,
          "old_line_content": "      ((field->type() == FIELD_TYPE_BIT || ",
          "new_line_content": "    In this case we know that:",
          "content_same": false
        },
        {
          "line": 10251,
          "old_api": "get_sel_arg_for_keypart",
          "new_api": null,
          "old_text": "get_sel_arg_for_keypart(field,\n                                  cur_kp->next_key_part,\n                                  &curr_tree)",
          "new_text": null,
          "old_line_content": "      if (get_sel_arg_for_keypart(field,",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 6156,
          "old_api": "val_int",
          "new_api": null,
          "old_text": "value->val_int()",
          "new_text": null,
          "old_line_content": "    longlong item_val= value->val_int();",
          "new_line_content": "    is true for all values, so we can avoid unnecessary retrieval and condition",
          "content_same": false
        },
        {
          "line": 8206,
          "old_api": "is_key_used",
          "new_api": null,
          "old_text": "is_key_used(head, index, fields)",
          "new_text": null,
          "old_line_content": "  return is_key_used(head, index, fields);",
          "new_line_content": "       key+= key_part++->store_length)",
          "content_same": false
        },
        {
          "line": 8215,
          "old_api": "is_key_used",
          "new_api": null,
          "old_text": "is_key_used(head, quick->index, fields)",
          "new_text": null,
          "old_line_content": "    if (is_key_used(head, quick->index, fields))",
          "new_line_content": "bool QUICK_SELECT_I::is_keys_used(const MY_BITMAP *fields)",
          "content_same": false
        },
        {
          "line": 6174,
          "old_api": "stored_field_cmp_to_item",
          "new_api": null,
          "old_text": "stored_field_cmp_to_item(param->thd, field, value)",
          "new_text": null,
          "old_line_content": "    if (stored_field_cmp_to_item(param->thd, field, value) == 0)",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 8227,
          "old_api": "is_key_used",
          "new_api": null,
          "old_text": "is_key_used(head, quick->index, fields)",
          "new_text": null,
          "old_line_content": "    if (is_key_used(head, quick->index, fields))",
          "new_line_content": "      return 1;",
          "content_same": false
        },
        {
          "line": 2091,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(this->key_infix, key_infix_arg, key_infix_len)",
          "new_text": null,
          "old_line_content": "        memcpy(this->key_infix, key_infix_arg, key_infix_len);",
          "new_line_content": "                    uint param_idx_arg, ha_rows quick_prefix_records_arg)",
          "content_same": false
        },
        {
          "line": 6189,
          "old_api": "stored_field_cmp_to_item",
          "new_api": null,
          "old_text": "stored_field_cmp_to_item(param->thd, field, value)",
          "new_text": null,
          "old_line_content": "        (stored_field_cmp_to_item(param->thd, field, value) <= 0))",
          "new_line_content": "    if (!maybe_null)",
          "content_same": false
        },
        {
          "line": 8239,
          "old_api": "is_keys_used",
          "new_api": null,
          "old_text": "quick->is_keys_used(fields)",
          "new_text": null,
          "old_line_content": "    if (quick->is_keys_used(fields))",
          "new_line_content": "      return 1;",
          "content_same": false
        },
        {
          "line": 6196,
          "old_api": "stored_field_cmp_to_item",
          "new_api": null,
          "old_text": "stored_field_cmp_to_item(param->thd, field, value)",
          "new_text": null,
          "old_line_content": "        (stored_field_cmp_to_item(param->thd, field, value) < 0))",
          "new_line_content": "    break;",
          "content_same": false
        },
        {
          "line": 6525,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "result->merges.push_back(merge)",
          "new_text": null,
          "old_line_content": "          (result->merges.push_back(merge)) ||",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 6527,
          "old_api": "or_sel_tree",
          "new_api": null,
          "old_text": "merge->or_sel_tree(param, tree2)",
          "new_text": null,
          "old_line_content": "          (merge->or_sel_tree(param, tree2)))",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 2122,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(param->mem_root,\n                                  param->fields_bitmap_size)",
          "new_text": null,
          "old_line_content": "  if (!(tmp= (my_bitmap_map*) alloc_root(param->mem_root,",
          "new_line_content": "    0  Ok",
          "content_same": false
        },
        {
          "line": 2124,
          "old_api": "bitmap_init",
          "new_api": null,
          "old_text": "bitmap_init(&param->needed_fields, tmp, table->s->fields, FALSE)",
          "new_text": null,
          "old_line_content": "      bitmap_init(&param->needed_fields, tmp, table->s->fields, FALSE))",
          "new_line_content": "*/",
          "content_same": false
        },
        {
          "line": 2127,
          "old_api": "bitmap_copy",
          "new_api": null,
          "old_text": "bitmap_copy(&param->needed_fields, table->read_set)",
          "new_text": null,
          "old_line_content": "  bitmap_copy(&param->needed_fields, table->read_set);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2128,
          "old_api": "bitmap_union",
          "new_api": null,
          "old_text": "bitmap_union(&param->needed_fields, table->write_set)",
          "new_text": null,
          "old_line_content": "  bitmap_union(&param->needed_fields, table->write_set);",
          "new_line_content": "  TABLE *table= param->table;",
          "content_same": false
        },
        {
          "line": 2131,
          "old_api": "primary_key_is_clustered",
          "new_api": null,
          "old_text": "param->table->file->primary_key_is_clustered()",
          "new_text": null,
          "old_line_content": "  if (pk != MAX_KEY && param->table->file->primary_key_is_clustered())",
          "new_line_content": "  param->tmp_covered_fields.bitmap= 0;",
          "content_same": false
        },
        {
          "line": 10329,
          "old_api": "get_sel_arg_for_keypart",
          "new_api": null,
          "old_text": "get_sel_arg_for_keypart(cur_part->field, index_range_tree,\n                                &cur_range)",
          "new_text": null,
          "old_line_content": "    if (get_sel_arg_for_keypart(cur_part->field, index_range_tree,",
          "new_line_content": "    cur_range= NULL;",
          "content_same": false
        },
        {
          "line": 4187,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"make_ror_scan\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"make_ror_scan\");",
          "new_line_content": "  RETURN",
          "content_same": false
        },
        {
          "line": 4189,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(param->mem_root,\n                                             sizeof(ROR_SCAN_INFO))",
          "new_text": null,
          "old_line_content": "  if (!(ror_scan= (ROR_SCAN_INFO*)alloc_root(param->mem_root,",
          "new_line_content": "    ROR scan structure containing a scan for {idx, sel_arg}",
          "content_same": false
        },
        {
          "line": 4191,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8288,
          "old_api": "init",
          "new_api": null,
          "old_text": "quick->init()",
          "new_text": null,
          "old_line_content": "  if (quick->init())",
          "new_line_content": "  quick= new QUICK_RANGE_SELECT(thd, table, ref->key, 0);",
          "content_same": false
        },
        {
          "line": 6241,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(tree)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(tree);",
          "new_line_content": "  case Item_func::SP_OVERLAPS_FUNC:",
          "content_same": false
        },
        {
          "line": 8292,
          "old_api": "cp_buffer_from_ref",
          "new_api": null,
          "old_text": "cp_buffer_from_ref(thd, table, ref)",
          "new_text": null,
          "old_line_content": "  if ((cp_buffer_from_ref(thd, table, ref) && thd->is_fatal_error) ||",
          "new_line_content": "    return back default mem_root (thd->mem_root) changed by",
          "content_same": false
        },
        {
          "line": 4204,
          "old_api": "bitmap_init",
          "new_api": null,
          "old_text": "bitmap_init(&ror_scan->covered_fields, bitmap_buf,\n                  param->table->s->fields, FALSE)",
          "new_text": null,
          "old_line_content": "  if (bitmap_init(&ror_scan->covered_fields, bitmap_buf,",
          "new_line_content": "  ror_scan->idx= idx;",
          "content_same": false
        },
        {
          "line": 4206,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "  ror_scan->key_rec_length= (param->table->key_info[keynr].key_length +",
          "content_same": false
        },
        {
          "line": 4207,
          "old_api": "bitmap_clear_all",
          "new_api": null,
          "old_text": "bitmap_clear_all(&ror_scan->covered_fields)",
          "new_text": null,
          "old_line_content": "  bitmap_clear_all(&ror_scan->covered_fields);",
          "new_line_content": "                             param->table->file->ref_length);",
          "content_same": false
        },
        {
          "line": 7756,
          "old_api": "check_quick_keys",
          "new_api": null,
          "old_text": "check_quick_keys(param, idx, key_tree->left,\n                             min_key, min_key_flag, min_keypart,\n\t\t\t     max_key, max_key_flag, max_keypart)",
          "new_text": null,
          "old_line_content": "    records=check_quick_keys(param, idx, key_tree->left,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4214,
          "old_api": "bitmap_is_set",
          "new_api": null,
          "old_text": "bitmap_is_set(&param->needed_fields, key_part->fieldnr-1)",
          "new_text": null,
          "old_line_content": "    if (bitmap_is_set(&param->needed_fields, key_part->fieldnr-1))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 10361,
          "old_api": "DBUG_ASSERT (field_length > 0)",
          "new_api": null,
          "old_text": "DBUG_ASSERT (field_length > 0)",
          "new_text": null,
          "old_line_content": "      DBUG_ASSERT (field_length > 0);",
          "new_line_content": "      return false;",
          "content_same": false
        },
        {
          "line": 10363,
          "old_api": "bzero",
          "new_api": null,
          "old_text": "bzero(key_ptr+1,field_length-1)",
          "new_text": null,
          "old_line_content": "      bzero(key_ptr+1,field_length-1);",
          "new_line_content": "    uint field_length= cur_part->store_length;",
          "content_same": false
        },
        {
          "line": 8315,
          "old_api": "insert_dynamic",
          "new_api": null,
          "old_text": "insert_dynamic(&quick->ranges,(uchar*)&range)",
          "new_text": null,
          "old_line_content": "  if (insert_dynamic(&quick->ranges,(uchar*)&range))",
          "new_line_content": "    goto err;",
          "content_same": false
        },
        {
          "line": 4220,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(ror_scan)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(ror_scan);",
          "new_line_content": "  KEY_PART_INFO *key_part= param->table->key_info[keynr].key_part;",
          "content_same": false
        },
        {
          "line": 10367,
          "old_api": "memcmp",
          "new_api": null,
          "old_text": "memcmp(cur_range->min_value, cur_range->max_value, field_length)",
          "new_text": null,
          "old_line_content": "    else if (memcmp(cur_range->min_value, cur_range->max_value, field_length) == 0)",
          "new_line_content": "      /*",
          "content_same": false
        },
        {
          "line": 10369,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(key_ptr, cur_range->min_value, field_length)",
          "new_text": null,
          "old_line_content": "      memcpy(key_ptr, cur_range->min_value, field_length);",
          "new_line_content": "        to a \"null value\" (is_null_string) that may not always be long",
          "content_same": false
        },
        {
          "line": 8331,
          "old_api": "make_prev_keypart_map",
          "new_api": null,
          "old_text": "make_prev_keypart_map(ref->key_parts)",
          "new_text": null,
          "old_line_content": "                      make_prev_keypart_map(ref->key_parts),",
          "new_line_content": "     For example:",
          "content_same": false
        },
        {
          "line": 8333,
          "old_api": "make_prev_keypart_map",
          "new_api": null,
          "old_text": "make_prev_keypart_map(ref->key_parts)",
          "new_text": null,
          "old_line_content": "                      make_prev_keypart_map(ref->key_parts), EQ_RANGE)))",
          "new_line_content": "       and have ref->null_ref_key set. Will create a new NULL range here.",
          "content_same": false
        },
        {
          "line": 4239,
          "old_api": "rows2double",
          "new_api": null,
          "old_text": "rows2double((*a)->records)",
          "new_text": null,
          "old_line_content": "  double val1= rows2double((*a)->records) * (*a)->key_rec_length;",
          "new_line_content": "      a ptr to first compared value",
          "content_same": false
        },
        {
          "line": 8336,
          "old_api": "insert_dynamic",
          "new_api": null,
          "old_text": "insert_dynamic(&quick->ranges,(uchar*)&null_range)",
          "new_text": null,
          "old_line_content": "    if (insert_dynamic(&quick->ranges,(uchar*)&null_range))",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 4240,
          "old_api": "rows2double",
          "new_api": null,
          "old_text": "rows2double((*b)->records)",
          "new_text": null,
          "old_line_content": "  double val2= rows2double((*b)->records) * (*b)->key_rec_length;",
          "new_line_content": "      b ptr to second compared value",
          "content_same": false
        },
        {
          "line": 6300,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"tree_and\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"tree_and\");",
          "new_line_content": "  return root;",
          "content_same": false
        },
        {
          "line": 6302,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(tree2)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(tree2);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6304,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(tree1)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(tree1);",
          "new_line_content": "#define CLONE_KEY2_MAYBE 2",
          "content_same": false
        },
        {
          "line": 6306,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(tree1)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(tree1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6308,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(tree2)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(tree2);",
          "new_line_content": "static SEL_TREE *",
          "content_same": false
        },
        {
          "line": 2216,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"SQL_SELECT::test_quick_select\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"SQL_SELECT::test_quick_select\");",
          "new_line_content": "   -1 if impossible select (i.e. certainly no rows will be selected)",
          "content_same": false
        },
        {
          "line": 2217,
          "old_api": "to_ulonglong",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"enter\",(\"keys_to_use: %lu  prev_tables: %lu  const_tables: %lu\",\n\t\t      (ulong) keys_to_use.to_ulonglong(), (ulong) prev_tables,\n\t\t      (ulong) const_tables))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"enter\",(\"keys_to_use: %lu  prev_tables: %lu  const_tables: %lu\",",
          "new_line_content": "    0 if can't use quick_select",
          "content_same": false
        },
        {
          "line": 2218,
          "old_api": "to_ulonglong",
          "new_api": null,
          "old_text": "keys_to_use.to_ulonglong()",
          "new_text": null,
          "old_line_content": "\t\t      (ulong) keys_to_use.to_ulonglong(), (ulong) prev_tables,",
          "new_line_content": "    1 if found usable ranges and quick select has been successfully created.",
          "content_same": false
        },
        {
          "line": 10408,
          "old_api": "eq",
          "new_api": null,
          "old_text": "field->eq(part->field)",
          "new_text": null,
          "old_line_content": "    if (field->eq(part->field))",
          "new_line_content": "    Positive number which is the consecutive number of the key part, or",
          "content_same": false
        },
        {
          "line": 2220,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"records: %lu\", (ulong) head->file->stats.records))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\", (\"records: %lu\", (ulong) head->file->stats.records));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6318,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(tree1)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(tree1);",
          "new_line_content": "  if (tree2->type == SEL_TREE::IMPOSSIBLE || tree1->type == SEL_TREE::ALWAYS)",
          "content_same": false
        },
        {
          "line": 2223,
          "old_api": "clear_all",
          "new_api": null,
          "old_text": "needed_reg.clear_all()",
          "new_text": null,
          "old_line_content": "  needed_reg.clear_all();",
          "new_line_content": "\t\t\t\t  ha_rows limit, bool force_quick_range)",
          "content_same": false
        },
        {
          "line": 2224,
          "old_api": "clear_all",
          "new_api": null,
          "old_text": "quick_keys.clear_all()",
          "new_text": null,
          "old_line_content": "  quick_keys.clear_all();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2225,
          "old_api": "is_clear_all",
          "new_api": null,
          "old_text": "keys_to_use.is_clear_all()",
          "new_text": null,
          "old_line_content": "  if (keys_to_use.is_clear_all())",
          "new_line_content": "  uint idx;",
          "content_same": false
        },
        {
          "line": 2226,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(0);",
          "new_line_content": "  double scan_time;",
          "content_same": false
        },
        {
          "line": 8371,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"QUICK_INDEX_MERGE_SELECT::read_keys_and_merge\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"QUICK_INDEX_MERGE_SELECT::read_keys_and_merge\");",
          "new_line_content": "  RETURN",
          "content_same": false
        },
        {
          "line": 6321,
          "old_api": "clear_all",
          "new_api": null,
          "old_text": "result_keys.clear_all()",
          "new_text": null,
          "old_line_content": "  result_keys.clear_all();",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 6548,
          "old_api": "imerge_list_or_tree",
          "new_api": null,
          "old_text": "imerge_list_or_tree(param, &tree1->merges, tree2)",
          "new_text": null,
          "old_line_content": "      if (imerge_list_or_tree(param, &tree1->merges, tree2))",
          "new_line_content": "        result= tree1;",
          "content_same": false
        },
        {
          "line": 8374,
          "old_api": "set_keyread",
          "new_api": null,
          "old_text": "head->set_keyread(TRUE)",
          "new_text": null,
          "old_line_content": "  head->set_keyread(TRUE);",
          "new_line_content": "*/",
          "content_same": false
        },
        {
          "line": 8375,
          "old_api": "prepare_for_position",
          "new_api": null,
          "old_text": "head->prepare_for_position()",
          "new_text": null,
          "old_line_content": "  head->prepare_for_position();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7770,
          "old_api": "uint) (tmp_max_key - param->max_key)",
          "new_api": null,
          "old_text": "uint) (tmp_max_key - param->max_key)",
          "new_text": null,
          "old_line_content": "  max_key_length= (uint) (tmp_max_key - param->max_key);",
          "new_line_content": "    if (records == HA_POS_ERROR)\t\t\t// Impossible",
          "content_same": false
        },
        {
          "line": 8377,
          "old_api": "rewind",
          "new_api": null,
          "old_text": "cur_quick_it.rewind()",
          "new_text": null,
          "old_line_content": "  cur_quick_it.rewind();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 8379,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(cur_quick != 0)",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(cur_quick != 0);",
          "new_line_content": "  QUICK_RANGE_SELECT* cur_quick;",
          "content_same": false
        },
        {
          "line": 6331,
          "old_api": "simple_key",
          "new_api": null,
          "old_text": "*key1)->simple_key()",
          "new_text": null,
          "old_line_content": "      if (*key1 && !(*key1)->simple_key())",
          "new_line_content": "  key_map  result_keys;",
          "content_same": false
        },
        {
          "line": 6333,
          "old_api": "simple_key",
          "new_api": null,
          "old_text": "*key2)->simple_key()",
          "new_text": null,
          "old_line_content": "      if (*key2 && !(*key2)->simple_key())",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 2239,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\",(\"Time to scan table: %g\", read_time))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\",(\"Time to scan table: %g\", read_time));",
          "new_line_content": "  if (!records)",
          "content_same": false
        },
        {
          "line": 6335,
          "old_api": "key_and",
          "new_api": null,
          "old_text": "key_and(param, *key1, *key2, flag)",
          "new_text": null,
          "old_line_content": "      *key1=key_and(param, *key1, *key2, flag);",
          "new_line_content": "  SEL_ARG **key1,**key2,**end;",
          "content_same": false
        },
        {
          "line": 2241,
          "old_api": "intersect",
          "new_api": null,
          "old_text": "keys_to_use.intersect(head->keys_in_use_for_query)",
          "new_text": null,
          "old_line_content": "  keys_to_use.intersect(head->keys_in_use_for_query);",
          "new_line_content": "  scan_time= (double) records / TIME_FOR_COMPARE + 1;",
          "content_same": false
        },
        {
          "line": 6339,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(tree1)",
          "new_text": null,
          "old_line_content": "        DBUG_RETURN(tree1);",
          "new_line_content": "    uint flag=0;",
          "content_same": false
        },
        {
          "line": 6341,
          "old_api": "set_bit",
          "new_api": null,
          "old_text": "result_keys.set_bit(key1 - tree1->keys)",
          "new_text": null,
          "old_line_content": "      result_keys.set_bit(key1 - tree1->keys);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 8391,
          "old_api": "DBUG_EXECUTE_IF",
          "new_api": null,
          "old_text": "DBUG_EXECUTE_IF(\"only_one_Unique_may_be_created\", \n                    DBUG_SET(\"+d,index_merge_may_not_create_a_Unique\"); )",
          "new_text": null,
          "old_line_content": "    DBUG_EXECUTE_IF(\"only_one_Unique_may_be_created\", ",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 8392,
          "old_api": "DBUG_SET",
          "new_api": null,
          "old_text": "DBUG_SET(\"+d,index_merge_may_not_create_a_Unique\")",
          "new_text": null,
          "old_line_content": "                    DBUG_SET(\"+d,index_merge_may_not_create_a_Unique\"); );",
          "new_line_content": "  /*",
          "content_same": false
        },
        {
          "line": 2251,
          "old_api": "check_stack_overrun",
          "new_api": null,
          "old_text": "check_stack_overrun(thd, 2*STACK_MIN_SIZE + sizeof(PARAM), buff)",
          "new_text": null,
          "old_line_content": "    if (check_stack_overrun(thd, 2*STACK_MIN_SIZE + sizeof(PARAM), buff))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8400,
          "old_api": "reset",
          "new_api": null,
          "old_text": "unique->reset()",
          "new_text": null,
          "old_line_content": "    unique->reset();",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 2256,
          "old_api": "ha_table_flags",
          "new_api": null,
          "old_text": "head->file->ha_table_flags()",
          "new_text": null,
          "old_line_content": "    param.baseflag= head->file->ha_table_flags();",
          "new_line_content": "    MEM_ROOT alloc;",
          "content_same": false
        },
        {
          "line": 6353,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(tree1)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(tree1);",
          "new_line_content": "#ifdef EXTRA_DEBUG",
          "content_same": false
        },
        {
          "line": 8404,
          "old_api": "get_size",
          "new_api": null,
          "old_text": "unique->get_size()",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(file->ref_length == unique->get_size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8405,
          "old_api": "get_max_in_memory_size",
          "new_api": null,
          "old_text": "unique->get_max_in_memory_size()",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(thd->variables.sortbuff_size == unique->get_max_in_memory_size());",
          "new_line_content": "    unique= new Unique(refpos_order_cmp, (void *)file,",
          "content_same": false
        },
        {
          "line": 6357,
          "old_api": "imerge_list_and_list",
          "new_api": null,
          "old_text": "imerge_list_and_list(&tree1->merges, &tree2->merges)",
          "new_text": null,
          "old_line_content": "  imerge_list_and_list(&tree1->merges, &tree2->merges);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 6358,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(tree1)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(tree1);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 8408,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(1)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(1);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 4316,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(param->mem_root,\n                                              sizeof(ROR_INTERSECT_INFO))",
          "new_text": null,
          "old_line_content": "  if (!(info= (ROR_INTERSECT_INFO*)alloc_root(param->mem_root,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8413,
          "old_api": "range_end",
          "new_api": null,
          "old_text": "cur_quick->range_end()",
          "new_text": null,
          "old_line_content": "      cur_quick->range_end();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2270,
          "old_api": "init_sql_alloc",
          "new_api": null,
          "old_text": "init_sql_alloc(&alloc, thd->variables.range_alloc_block_size, 0)",
          "new_text": null,
          "old_line_content": "    init_sql_alloc(&alloc, thd->variables.range_alloc_block_size, 0);",
          "new_line_content": "    param.current_table= head->map;",
          "content_same": false
        },
        {
          "line": 2271,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(&alloc,\n                                                  sizeof(KEY_PART)*\n                                                  head->s->key_parts)",
          "new_text": null,
          "old_line_content": "    if (!(param.key_parts= (KEY_PART*) alloc_root(&alloc,",
          "new_line_content": "    param.table=head;",
          "content_same": false
        },
        {
          "line": 4320,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(param->mem_root,\n                                         param->fields_bitmap_size)",
          "new_text": null,
          "old_line_content": "  if (!(buf= (my_bitmap_map*) alloc_root(param->mem_root,",
          "new_line_content": "*/",
          "content_same": false
        },
        {
          "line": 2274,
          "old_api": "fill_used_fields_bitmap",
          "new_api": null,
          "old_text": "fill_used_fields_bitmap(&param)",
          "new_text": null,
          "old_line_content": "        fill_used_fields_bitmap(&param))",
          "new_line_content": "    param.old_root= thd->mem_root;",
          "content_same": false
        },
        {
          "line": 4323,
          "old_api": "bitmap_init",
          "new_api": null,
          "old_text": "bitmap_init(&info->covered_fields, buf, param->table->s->fields,\n                  FALSE)",
          "new_text": null,
          "old_line_content": "  if (bitmap_init(&info->covered_fields, buf, param->table->s->fields,",
          "new_line_content": "ROR_INTERSECT_INFO* ror_intersect_init(const PARAM *param)",
          "content_same": false
        },
        {
          "line": 8420,
          "old_api": "reset",
          "new_api": null,
          "old_text": "cur_quick->reset()",
          "new_text": null,
          "old_line_content": "      if (cur_quick->init() || cur_quick->reset())",
          "new_line_content": "  for (;;)",
          "content_same": false
        },
        {
          "line": 8421,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(1)",
          "new_text": null,
          "old_line_content": "        DBUG_RETURN(1);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 2277,
          "old_api": "MYF",
          "new_api": null,
          "old_text": "MYF(0)",
          "new_text": null,
          "old_line_content": "      free_root(&alloc,MYF(0));\t\t\t// Return memory & allocator",
          "new_line_content": "    param.using_real_indexes= TRUE;",
          "content_same": false
        },
        {
          "line": 2278,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(0);\t\t\t\t// Can't use range",
          "new_line_content": "    param.remove_jump_scans= TRUE;",
          "content_same": false
        },
        {
          "line": 6372,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"sel_trees_can_be_ored\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"sel_trees_can_be_ored\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6373,
          "old_api": "intersect",
          "new_api": null,
          "old_text": "common_keys.intersect(tree2->keys_map)",
          "new_text": null,
          "old_line_content": "  common_keys.intersect(tree2->keys_map);",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 4330,
          "old_api": "bitmap_clear_all",
          "new_api": null,
          "old_text": "bitmap_clear_all(&info->covered_fields)",
          "new_text": null,
          "old_line_content": "  bitmap_clear_all(&info->covered_fields);",
          "new_line_content": "  info->param= param;",
          "content_same": false
        },
        {
          "line": 6375,
          "old_api": "is_clear_all",
          "new_api": null,
          "old_text": "common_keys.is_clear_all()",
          "new_text": null,
          "old_line_content": "  if (common_keys.is_clear_all())",
          "new_line_content": "  read can be constructed for \"cond_of_tree1 OR cond_of_tree2\" ) without",
          "content_same": false
        },
        {
          "line": 8428,
          "old_api": "range_end",
          "new_api": null,
          "old_text": "cur_quick->range_end()",
          "new_text": null,
          "old_line_content": "        cur_quick->range_end();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8429,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(result)",
          "new_text": null,
          "old_line_content": "        DBUG_RETURN(result);",
          "new_line_content": "      if (cur_quick->file->inited)",
          "content_same": false
        },
        {
          "line": 6376,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(FALSE)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(FALSE);",
          "new_line_content": "  using index_merge.",
          "content_same": false
        },
        {
          "line": 6382,
          "old_api": "is_set",
          "new_api": null,
          "old_text": "common_keys.is_set(key_no)",
          "new_text": null,
          "old_line_content": "    if (common_keys.is_set(key_no))",
          "new_line_content": "  key_map common_keys= tree1->keys_map;",
          "content_same": false
        },
        {
          "line": 4337,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(dst->covered_fields.bitmap, src->covered_fields.bitmap, \n         no_bytes_in_map(&src->covered_fields))",
          "new_text": null,
          "old_line_content": "  memcpy(dst->covered_fields.bitmap, src->covered_fields.bitmap, ",
          "new_line_content": "  info->is_covering= FALSE;",
          "content_same": false
        },
        {
          "line": 4338,
          "old_api": "no_bytes_in_map",
          "new_api": null,
          "old_text": "no_bytes_in_map(&src->covered_fields)",
          "new_text": null,
          "old_line_content": "         no_bytes_in_map(&src->covered_fields));",
          "new_line_content": "  info->index_scan_costs= 0.0;",
          "content_same": false
        },
        {
          "line": 8435,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(1)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(1);",
          "new_line_content": "    if (result)",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": "is_set",
          "new_api": null,
          "old_text": "keys_to_use.is_set(idx)",
          "new_text": null,
          "old_line_content": "      if (!keys_to_use.is_set(idx))",
          "new_line_content": "    key_parts= param.key_parts;",
          "content_same": false
        },
        {
          "line": 6388,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(TRUE)",
          "new_text": null,
          "old_line_content": "        DBUG_RETURN(TRUE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8438,
          "old_api": "row_in_ranges",
          "new_api": null,
          "old_text": "pk_quick_select->row_in_ranges()",
          "new_text": null,
          "old_line_content": "    if (pk_quick_select && pk_quick_select->row_in_ranges())",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 6392,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(FALSE)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(FALSE);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 8441,
          "old_api": "position",
          "new_api": null,
          "old_text": "cur_quick->file->position(cur_quick->record)",
          "new_text": null,
          "old_line_content": "    cur_quick->file->position(cur_quick->record);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 8442,
          "old_api": "unique_add",
          "new_api": null,
          "old_text": "unique->unique_add((char*)cur_quick->file->ref)",
          "new_text": null,
          "old_line_content": "    result= unique->unique_add((char*)cur_quick->file->ref);",
          "new_line_content": "      break;",
          "content_same": false
        },
        {
          "line": 8444,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(1)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8456,
          "old_api": "init_read_record",
          "new_api": null,
          "old_text": "init_read_record(&read_record, thd, head, (SQL_SELECT*) 0, 1 , 1, TRUE)",
          "new_text": null,
          "old_line_content": "  init_read_record(&read_record, thd, head, (SQL_SELECT*) 0, 1 , 1, TRUE);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 8457,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(result)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(result);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2318,
          "old_api": "is_clear_all",
          "new_api": null,
          "old_text": "head->covering_keys.is_clear_all()",
          "new_text": null,
          "old_line_content": "    if (!head->covering_keys.is_clear_all())",
          "new_line_content": "        key_parts->image_type =",
          "content_same": false
        },
        {
          "line": 2320,
          "old_api": "find_shortest_key",
          "new_api": null,
          "old_text": "find_shortest_key(head, &head->covering_keys)",
          "new_text": null,
          "old_line_content": "      int key_for_use= find_shortest_key(head, &head->covering_keys);",
          "new_line_content": "        /* Only HA_PART_KEY_SEG is used */",
          "content_same": false
        },
        {
          "line": 2321,
          "old_api": "get_index_only_read_time",
          "new_api": null,
          "old_text": "get_index_only_read_time(&param, records,\n                                                     key_for_use)",
          "new_text": null,
          "old_line_content": "      double key_read_time= (get_index_only_read_time(&param, records,",
          "new_line_content": "        key_parts->flag=         (uint8) key_part_info->key_part_flag;",
          "content_same": false
        },
        {
          "line": 2324,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\",  (\"'all'+'using index' scan will be using key %d, \"\n                           \"read time %g\", key_for_use, key_read_time))",
          "new_text": null,
          "old_line_content": "      DBUG_PRINT(\"info\",  (\"'all'+'using index' scan will be using key %d, \"",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 8473,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"QUICK_INDEX_MERGE_SELECT::get_next\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"QUICK_INDEX_MERGE_SELECT::get_next\");",
          "new_line_content": "  Get next row for index_merge.",
          "content_same": false
        },
        {
          "line": 8476,
          "old_api": "get_next",
          "new_api": null,
          "old_text": "pk_quick_select->get_next()",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(pk_quick_select->get_next());",
          "new_line_content": "      1. rowids stored in Unique.",
          "content_same": false
        },
        {
          "line": 8478,
          "old_api": "read_record",
          "new_api": null,
          "old_text": "read_record.read_record(&read_record)",
          "new_text": null,
          "old_line_content": "  if ((result= read_record.read_record(&read_record)) == -1)",
          "new_line_content": "    The sets of rows retrieved in 1) and 2) are guaranteed to be disjoint.",
          "content_same": false
        },
        {
          "line": 2336,
          "old_api": "get_mm_tree",
          "new_api": null,
          "old_text": "get_mm_tree(&param,cond)",
          "new_text": null,
          "old_line_content": "      if ((tree= get_mm_tree(&param,cond)))",
          "new_line_content": "                           \"read time %g\", key_for_use, key_read_time));",
          "content_same": false
        },
        {
          "line": 8481,
          "old_api": "end_read_record",
          "new_api": null,
          "old_text": "end_read_record(&read_record)",
          "new_text": null,
          "old_line_content": "    end_read_record(&read_record);",
          "new_line_content": "int QUICK_INDEX_MERGE_SELECT::get_next()",
          "content_same": false
        },
        {
          "line": 8482,
          "old_api": "free_io_cache",
          "new_api": null,
          "old_text": "free_io_cache(head)",
          "new_text": null,
          "old_line_content": "    free_io_cache(head);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 10530,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"cost_group_min_max\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"cost_group_min_max\");",
          "new_line_content": "  ha_rows table_records;",
          "content_same": false
        },
        {
          "line": 8488,
          "old_api": "reset",
          "new_api": null,
          "old_text": "pk_quick_select->reset()",
          "new_text": null,
          "old_line_content": "          (result= pk_quick_select->reset()))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 10536,
          "old_api": "uint)(table_records / keys_per_block)",
          "new_api": null,
          "old_text": "uint)(table_records / keys_per_block)",
          "new_text": null,
          "old_line_content": "  num_blocks= (uint)(table_records / keys_per_block) + 1;",
          "new_line_content": "                          /* formed by a key infix. */",
          "content_same": false
        },
        {
          "line": 8490,
          "old_api": "get_next",
          "new_api": null,
          "old_text": "pk_quick_select->get_next()",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(pk_quick_select->get_next());",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 8494,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(result)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(result);",
          "new_line_content": "    /* All rows from Unique have been retrieved, do a clustered PK scan */",
          "content_same": false
        },
        {
          "line": 10542,
          "old_api": "uint)(table_records / 10)",
          "new_api": null,
          "old_text": "uint)(table_records / 10)",
          "new_text": null,
          "old_line_content": "    keys_per_group= (uint)(table_records / 10) + 1;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 10543,
          "old_api": "uint)(table_records / keys_per_group)",
          "new_api": null,
          "old_text": "uint)(table_records / keys_per_group)",
          "new_text": null,
          "old_line_content": "  num_groups= (uint)(table_records / keys_per_group) + 1;",
          "new_line_content": "  table_records= table->file->stats.records;",
          "content_same": false
        },
        {
          "line": 2357,
          "old_api": "get_best_group_min_max",
          "new_api": null,
          "old_text": "get_best_group_min_max(&param, tree, best_read_time)",
          "new_text": null,
          "old_line_content": "    group_trp= get_best_group_min_max(&param, tree, best_read_time);",
          "new_line_content": "          can construct a group-min-max quick select",
          "content_same": false
        },
        {
          "line": 10550,
          "old_api": "rint",
          "new_api": null,
          "old_text": "rint(num_groups * quick_prefix_selectivity)",
          "new_text": null,
          "old_line_content": "    num_groups= (uint) rint(num_groups * quick_prefix_selectivity);",
          "new_line_content": "  keys_per_group= index_info->rec_per_key[group_key_parts - 1];",
          "content_same": false
        },
        {
          "line": 10551,
          "old_api": "set_if_bigger",
          "new_api": null,
          "old_text": "set_if_bigger(num_groups, 1)",
          "new_text": null,
          "old_line_content": "    set_if_bigger(num_groups, 1);",
          "new_line_content": "  if (keys_per_group == 0) /* If there is no statistics try to guess */",
          "content_same": false
        },
        {
          "line": 2360,
          "old_api": "min",
          "new_api": null,
          "old_text": "min(group_trp->records,\n                                             head->file->stats.records)",
          "new_text": null,
          "old_line_content": "      param.table->quick_condition_rows= min(group_trp->records,",
          "new_line_content": "          tree= NULL;",
          "content_same": false
        },
        {
          "line": 6461,
          "old_api": "clear_bit",
          "new_api": null,
          "old_text": "tree->keys_map.clear_bit(i)",
          "new_text": null,
          "old_line_content": "        tree->keys_map.clear_bit(i);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 10566,
          "old_api": "min",
          "new_api": null,
          "old_text": "min(p_overlap, 1.0)",
          "new_text": null,
          "old_line_content": "      p_overlap= min(p_overlap, 1.0);",
          "new_line_content": "  { /*",
          "content_same": false
        },
        {
          "line": 2375,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "tree->merges.is_empty()",
          "new_text": null,
          "old_line_content": "      if (tree->merges.is_empty())",
          "new_line_content": "        best_trp= group_trp;",
          "content_same": false
        },
        {
          "line": 10568,
          "old_api": "min",
          "new_api": null,
          "old_text": "min(num_groups * (1 + p_overlap), num_blocks)",
          "new_text": null,
          "old_line_content": "    io_cost= (double) min(num_groups * (1 + p_overlap), num_blocks);",
          "new_line_content": "      different blocks.",
          "content_same": false
        },
        {
          "line": 6474,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"tree_or\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"tree_or\");",
          "new_line_content": "      else",
          "content_same": false
        },
        {
          "line": 6476,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(0);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2382,
          "old_api": "get_key_scans_params",
          "new_api": null,
          "old_text": "get_key_scans_params(&param, tree, FALSE, TRUE,\n                                             best_read_time)",
          "new_text": null,
          "old_line_content": "        if ((range_trp= get_key_scans_params(&param, tree, FALSE, TRUE,",
          "new_line_content": "      /*",
          "content_same": false
        },
        {
          "line": 6478,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(tree2)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(tree2);",
          "new_line_content": "  return !res;",
          "content_same": false
        },
        {
          "line": 6480,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(tree1)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(tree1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6482,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(tree1)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(tree1);\t\t\t\t// Can't use this",
          "new_line_content": "static SEL_TREE *",
          "content_same": false
        },
        {
          "line": 6484,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(tree2)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(tree2);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 6488,
          "old_api": "clear_all",
          "new_api": null,
          "old_text": "result_keys.clear_all()",
          "new_text": null,
          "old_line_content": "  result_keys.clear_all();",
          "new_line_content": "  if (tree1->type == SEL_TREE::IMPOSSIBLE || tree2->type == SEL_TREE::ALWAYS)",
          "content_same": false
        },
        {
          "line": 8537,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"QUICK_ROR_INTERSECT_SELECT::get_next\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"QUICK_ROR_INTERSECT_SELECT::get_next\");",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 10586,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\",\n             (\"table rows: %lu  keys/block: %u  keys/group: %u  result rows: %lu  blocks: %u\",\n              (ulong)table_records, keys_per_block, keys_per_group, \n              (ulong) *records, num_blocks))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2395,
          "old_api": "optimizer_flag",
          "new_api": null,
          "old_text": "optimizer_flag(thd, OPTIMIZER_SWITCH_INDEX_MERGE)",
          "new_text": null,
          "old_line_content": "             optimizer_flag(thd, OPTIMIZER_SWITCH_INDEX_MERGE))",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 8543,
          "old_api": "get_next",
          "new_api": null,
          "old_text": "quick->get_next()",
          "new_text": null,
          "old_line_content": "    error= quick->get_next();",
          "new_line_content": "  it */",
          "content_same": false
        },
        {
          "line": 4447,
          "old_api": "bitmap_is_set",
          "new_api": null,
          "old_text": "bitmap_is_set(&info->covered_fields,\n                                        key_part->fieldnr-1)",
          "new_text": null,
          "old_line_content": "  bool prev_covered= test(bitmap_is_set(&info->covered_fields,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2401,
          "old_api": "get_best_ror_intersect",
          "new_api": null,
          "old_text": "get_best_ror_intersect(&param, tree, best_read_time,\n                                                &can_build_covering)",
          "new_text": null,
          "old_line_content": "          if ((rori_trp= get_best_ror_intersect(&param, tree, best_read_time,",
          "new_line_content": "          Simultaneous key scans and row deletes on several handler",
          "content_same": false
        },
        {
          "line": 8546,
          "old_api": "row_in_ranges",
          "new_api": null,
          "old_text": "cpk_quick->row_in_ranges()",
          "new_text": null,
          "old_line_content": "      while (!error && !cpk_quick->row_in_ranges())",
          "new_line_content": "  int error, cmp;",
          "content_same": false
        },
        {
          "line": 6496,
          "old_api": "key_or",
          "new_api": null,
          "old_text": "key_or(param, *key1, *key2)",
          "new_text": null,
          "old_line_content": "      *key1=key_or(param, *key1, *key2);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8549,
          "old_api": "get_next",
          "new_api": null,
          "old_text": "quick->get_next()",
          "new_text": null,
          "old_line_content": "        error= quick->get_next();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6503,
          "old_api": "test_use_count",
          "new_api": null,
          "old_text": "*key1)->test_use_count(*key1)",
          "new_text": null,
          "old_line_content": "          (*key1)->test_use_count(*key1);",
          "new_line_content": "    SEL_ARG **key1,**key2,**end;",
          "content_same": false
        },
        {
          "line": 4456,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"ror_scan_selectivity\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"ror_scan_selectivity\");",
          "new_line_content": "  key_part_map keypart_map= 0;",
          "content_same": false
        },
        {
          "line": 8553,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(error)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(error);",
          "new_line_content": "    quick= quick_it++;",
          "content_same": false
        },
        {
          "line": 8555,
          "old_api": "position",
          "new_api": null,
          "old_text": "quick->file->position(quick->record)",
          "new_text": null,
          "old_line_content": "    quick->file->position(quick->record);",
          "new_line_content": "    if (cpk_quick)",
          "content_same": false
        },
        {
          "line": 8556,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(last_rowid, quick->file->ref, head->file->ref_length)",
          "new_text": null,
          "old_line_content": "    memcpy(last_rowid, quick->file->ref, head->file->ref_length);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2411,
          "old_api": "get_best_covering_ror_intersect",
          "new_api": null,
          "old_text": "get_best_covering_ror_intersect(&param, tree,\n                                                           best_read_time)",
          "new_text": null,
          "old_line_content": "                (rori_trp= get_best_covering_ror_intersect(&param, tree,",
          "new_line_content": "          */",
          "content_same": false
        },
        {
          "line": 4461,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\",(\"sel_arg step\"))",
          "new_text": null,
          "old_line_content": "    DBUG_PRINT(\"info\",(\"sel_arg step\"));",
          "new_line_content": "  key_range max_range;",
          "content_same": false
        },
        {
          "line": 4462,
          "old_api": "bitmap_is_set",
          "new_api": null,
          "old_text": "bitmap_is_set(&info->covered_fields,\n                                    key_part[sel_arg->part].fieldnr-1)",
          "new_text": null,
          "old_line_content": "    cur_covered= test(bitmap_is_set(&info->covered_fields,",
          "new_line_content": "  min_range.key= key_val;",
          "content_same": false
        },
        {
          "line": 6513,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "tree2->merges.is_empty()",
          "new_text": null,
          "old_line_content": "    if (tree1->merges.is_empty() && tree2->merges.is_empty())",
          "new_line_content": "        if (param->alloced_sel_args < SEL_ARG::MAX_SEL_ARGS) ",
          "content_same": false
        },
        {
          "line": 2419,
          "old_api": "optimizer_flag",
          "new_api": null,
          "old_text": "optimizer_flag(thd, OPTIMIZER_SWITCH_INDEX_MERGE)",
          "new_text": null,
          "old_line_content": "        if (optimizer_flag(thd, OPTIMIZER_SWITCH_INDEX_MERGE))",
          "new_line_content": "              and worth doing.",
          "content_same": false
        },
        {
          "line": 6517,
          "old_api": "remove_nonrange_trees",
          "new_api": null,
          "old_text": "remove_nonrange_trees(param, tree1)",
          "new_text": null,
          "old_line_content": "        bool no_trees= remove_nonrange_trees(param, tree1);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 6518,
          "old_api": "remove_nonrange_trees",
          "new_api": null,
          "old_text": "remove_nonrange_trees(param, tree2)",
          "new_text": null,
          "old_line_content": "        no_trees= no_trees || remove_nonrange_trees(param, tree2);",
          "new_line_content": "    if (result)",
          "content_same": false
        },
        {
          "line": 2424,
          "old_api": "LINT_INIT",
          "new_api": null,
          "old_text": "LINT_INIT(new_conj_trp)",
          "new_text": null,
          "old_line_content": "          LINT_INIT(new_conj_trp); /* no empty index_merge lists possible */",
          "new_line_content": "              best_trp= rori_trp;",
          "content_same": false
        },
        {
          "line": 2425,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\",(\"No range reads possible,\"\n                             \" trying to construct index_merge\"))",
          "new_text": null,
          "old_line_content": "          DBUG_PRINT(\"info\",(\"No range reads possible,\"",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 8570,
          "old_api": "DBUG_EXECUTE_IF",
          "new_api": null,
          "old_text": "DBUG_EXECUTE_IF(\"innodb_quick_report_deadlock\",\n                        DBUG_SET(\"+d,innodb_report_deadlock\");)",
          "new_text": null,
          "old_line_content": "        DBUG_EXECUTE_IF(\"innodb_quick_report_deadlock\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8571,
          "old_api": "DBUG_SET",
          "new_api": null,
          "old_text": "DBUG_SET(\"+d,innodb_report_deadlock\")",
          "new_text": null,
          "old_line_content": "                        DBUG_SET(\"+d,innodb_report_deadlock\"););",
          "new_line_content": "    while (last_rowid_count < quick_selects.elements)",
          "content_same": false
        },
        {
          "line": 8572,
          "old_api": "get_next",
          "new_api": null,
          "old_text": "quick->get_next()",
          "new_text": null,
          "old_line_content": "        if ((error= quick->get_next()))",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 10620,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"TRP_GROUP_MIN_MAX::make_quick\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"TRP_GROUP_MIN_MAX::make_quick\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4478,
          "old_api": "store_min",
          "new_api": null,
          "old_text": "tuple_arg->store_min(key_part[tuple_arg->part].store_length,\n                             &key_ptr, 0)",
          "new_text": null,
          "old_line_content": "        tuple_arg->store_min(key_part[tuple_arg->part].store_length,",
          "new_line_content": "      ha_rows records;",
          "content_same": false
        },
        {
          "line": 6520,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(new SEL_TREE(SEL_TREE::ALWAYS))",
          "new_text": null,
          "old_line_content": "          DBUG_RETURN(new SEL_TREE(SEL_TREE::ALWAYS));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 8576,
          "old_api": "unlock_row",
          "new_api": null,
          "old_text": "quick_with_last_rowid->file->unlock_row()",
          "new_text": null,
          "old_line_content": "            quick_with_last_rowid->file->unlock_row();",
          "new_line_content": "        quick= quick_it++;",
          "content_same": false
        },
        {
          "line": 8577,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(error)",
          "new_text": null,
          "old_line_content": "          DBUG_RETURN(error);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2432,
          "old_api": "set_if_smaller",
          "new_api": null,
          "old_text": "set_if_smaller(param.table->quick_condition_rows, \n                             new_conj_trp->records)",
          "new_text": null,
          "old_line_content": "              set_if_smaller(param.table->quick_condition_rows, ",
          "new_line_content": "          /* Try creating index_merge/ROR-union scan. */",
          "content_same": false
        },
        {
          "line": 8579,
          "old_api": "position",
          "new_api": null,
          "old_text": "quick->file->position(quick->record)",
          "new_text": null,
          "old_line_content": "        quick->file->position(quick->record);",
          "new_line_content": "      do",
          "content_same": false
        },
        {
          "line": 8580,
          "old_api": "cmp_ref",
          "new_api": null,
          "old_text": "head->file->cmp_ref(quick->file->ref, last_rowid)",
          "new_text": null,
          "old_line_content": "        cmp= head->file->cmp_ref(quick->file->ref, last_rowid);",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 4484,
          "old_api": "info->param->table->file->\n                records_in_range(scan->keynr, &min_range, &max_range)",
          "new_api": null,
          "old_text": "info->param->table->file->\n                records_in_range(scan->keynr, &min_range, &max_range)",
          "new_text": null,
          "old_line_content": "      records= (info->param->table->file->",
          "new_line_content": "        keypart_map= 1;",
          "content_same": false
        },
        {
          "line": 5775,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(ftree)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(ftree);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 6526,
          "old_api": "or_sel_tree",
          "new_api": null,
          "old_text": "merge->or_sel_tree(param, tree1)",
          "new_text": null,
          "old_line_content": "          (merge->or_sel_tree(param, tree1)) ||",
          "new_line_content": "      if (param->remove_jump_scans)",
          "content_same": false
        },
        {
          "line": 8584,
          "old_api": "unlock_row",
          "new_api": null,
          "old_text": "quick->file->unlock_row()",
          "new_text": null,
          "old_line_content": "          quick->file->unlock_row();",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 10633,
          "old_api": "init",
          "new_api": null,
          "old_text": "quick->init()",
          "new_text": null,
          "old_line_content": "  if (quick->init())",
          "new_line_content": "  quick= new QUICK_GROUP_MIN_MAX_SELECT(param->table,",
          "content_same": false
        },
        {
          "line": 4490,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"Selectivity multiplier: %g\", tmp))",
          "new_text": null,
          "old_line_content": "        DBUG_PRINT(\"info\", (\"Selectivity multiplier: %g\", tmp));",
          "new_line_content": "                             &key_ptr, 0);",
          "content_same": false
        },
        {
          "line": 6532,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "tree2->merges.is_empty()",
          "new_text": null,
          "old_line_content": "    else if (!tree1->merges.is_empty() && !tree2->merges.is_empty())",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 10636,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "                                        have_agg_distinct, min_max_arg_part,",
          "content_same": false
        },
        {
          "line": 6534,
          "old_api": "imerge_list_or_list",
          "new_api": null,
          "old_text": "imerge_list_or_list(param, &tree1->merges, &tree2->merges)",
          "new_text": null,
          "old_line_content": "      if (imerge_list_or_list(param, &tree1->merges, &tree2->merges))",
          "new_line_content": "      /* both trees are \"range\" trees, produce new index merge structure */",
          "content_same": false
        },
        {
          "line": 6542,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "tree1->merges.is_empty()",
          "new_text": null,
          "old_line_content": "      if (tree1->merges.is_empty())",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 5778,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "cond_func->arguments()[0]->real_item()->type()",
          "new_text": null,
          "old_line_content": "    if (cond_func->arguments()[0]->real_item()->type() == Item::FIELD_ITEM)",
          "new_line_content": "      if (!((ref_tables | field->table->map) & param_comp))",
          "content_same": false
        },
        {
          "line": 10641,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(quick_prefix_records > 0)",
          "new_text": null,
          "old_line_content": "    DBUG_ASSERT(quick_prefix_records > 0);",
          "new_line_content": "  if (!quick)",
          "content_same": false
        },
        {
          "line": 8594,
          "old_api": "row_in_ranges",
          "new_api": null,
          "old_text": "cpk_quick->row_in_ranges()",
          "new_text": null,
          "old_line_content": "          while (!cpk_quick->row_in_ranges())",
          "new_line_content": "          /* This row is being skipped.  Release lock on it. */",
          "content_same": false
        },
        {
          "line": 2450,
          "old_api": "init",
          "new_api": null,
          "old_text": "quick->init()",
          "new_text": null,
          "old_line_content": "      if (!(quick= best_trp->make_quick(&param, TRUE)) || quick->init())",
          "new_line_content": "            best_trp= best_conj_trp;",
          "content_same": false
        },
        {
          "line": 8596,
          "old_api": "unlock_row",
          "new_api": null,
          "old_text": "quick->file->unlock_row()",
          "new_text": null,
          "old_line_content": "            quick->file->unlock_row(); /* row not in range; unlock */",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 8597,
          "old_api": "get_next",
          "new_api": null,
          "old_text": "quick->get_next()",
          "new_text": null,
          "old_line_content": "            if ((error= quick->get_next()))",
          "new_line_content": "      } while (cmp < 0);",
          "content_same": false
        },
        {
          "line": 10646,
          "old_api": "get_quick_select",
          "new_api": null,
          "old_text": "get_quick_select(param, param_idx,\n                                                   index_tree,\n                                                   &quick->alloc)",
          "new_text": null,
          "old_line_content": "      quick->quick_prefix_select= get_quick_select(param, param_idx,",
          "new_line_content": "    delete quick;",
          "content_same": false
        },
        {
          "line": 6546,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(new SEL_TREE(SEL_TREE::ALWAYS))",
          "new_text": null,
          "old_line_content": "         DBUG_RETURN(new SEL_TREE(SEL_TREE::ALWAYS));",
          "new_line_content": "        result= new SEL_TREE(SEL_TREE::ALWAYS);",
          "content_same": false
        },
        {
          "line": 4504,
          "old_api": "rows2double",
          "new_api": null,
          "old_text": "rows2double(info->param->table->quick_rows[scan->keynr])",
          "new_text": null,
          "old_line_content": "    double tmp= rows2double(info->param->table->quick_rows[scan->keynr]) /",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 8601,
          "old_api": "unlock_row",
          "new_api": null,
          "old_text": "quick_with_last_rowid->file->unlock_row()",
          "new_text": null,
          "old_line_content": "                quick_with_last_rowid->file->unlock_row();",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 8602,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(error)",
          "new_text": null,
          "old_line_content": "              DBUG_RETURN(error);",
          "new_line_content": "        /* Found a row with ref > cur_ref. Make it a new 'candidate' */",
          "content_same": false
        },
        {
          "line": 2458,
          "old_api": "MYF",
          "new_api": null,
          "old_text": "MYF(0)",
          "new_text": null,
          "old_line_content": "    free_root(&alloc,MYF(0));\t\t\t// Return memory & allocator",
          "new_line_content": "    if (best_trp)",
          "content_same": false
        },
        {
          "line": 4505,
          "old_api": "rows2double",
          "new_api": null,
          "old_text": "rows2double(prev_records)",
          "new_text": null,
          "old_line_content": "                rows2double(prev_records);",
          "new_line_content": "      else",
          "content_same": false
        },
        {
          "line": 4506,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"Selectivity multiplier: %g\", tmp))",
          "new_text": null,
          "old_line_content": "    DBUG_PRINT(\"info\", (\"Selectivity multiplier: %g\", tmp));",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 4509,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"Returning multiplier: %g\", selectivity_mult))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\", (\"Returning multiplier: %g\", selectivity_mult));",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2463,
          "old_api": "print_quick",
          "new_api": null,
          "old_text": "print_quick(quick, &needed_reg)",
          "new_text": null,
          "old_line_content": "  DBUG_EXECUTE(\"info\", print_quick(quick, &needed_reg););",
          "new_line_content": "        delete quick;",
          "content_same": false
        },
        {
          "line": 4510,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(selectivity_mult)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(selectivity_mult);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 5781,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "cond_func->arguments()",
          "new_text": null,
          "old_line_content": "      value= cond_func->arg_count > 1 ? cond_func->arguments()[1] : 0;",
          "new_line_content": "\t\t           value,cmp_type);",
          "content_same": false
        },
        {
          "line": 10660,
          "old_api": "eq",
          "new_api": null,
          "old_text": "min_max_range->field->eq(min_max_arg_part->field)",
          "new_text": null,
          "old_line_content": "        if (min_max_range->field->eq(min_max_arg_part->field))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6570,
          "old_api": "increment_use_count",
          "new_api": null,
          "old_text": "key2->increment_use_count((int) key1->elements-1)",
          "new_text": null,
          "old_line_content": "    key2->increment_use_count((int) key1->elements-1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8621,
          "old_api": "rnd_pos",
          "new_api": null,
          "old_text": "head->file->rnd_pos(head->record[0], last_rowid)",
          "new_text": null,
          "old_line_content": "      error= head->file->rnd_pos(head->record[0], last_rowid);",
          "new_line_content": "        quick_with_last_rowid= quick;",
          "content_same": false
        },
        {
          "line": 10670,
          "old_api": "add_range",
          "new_api": null,
          "old_text": "quick->add_range(min_max_range)",
          "new_text": null,
          "old_line_content": "        if (quick->add_range(min_max_range))",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 8623,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(error)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(error);",
          "new_line_content": "      else",
          "content_same": false
        },
        {
          "line": 6577,
          "old_api": "first",
          "new_api": null,
          "old_text": "key1->first()",
          "new_text": null,
          "old_line_content": "  for (next=key1->first(); next ; next=next->next)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 10674,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "          DBUG_RETURN(NULL);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 6584,
          "old_api": "tree_delete",
          "new_api": null,
          "old_text": "key1->tree_delete(next)",
          "new_text": null,
          "old_line_content": "\tkey1=key1->tree_delete(next);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 10683,
          "old_api": "update_key_stat",
          "new_api": null,
          "old_text": "quick->update_key_stat()",
          "new_text": null,
          "old_line_content": "  quick->update_key_stat();",
          "new_line_content": "          delete quick;",
          "content_same": false
        },
        {
          "line": 10684,
          "old_api": "adjust_prefix_ranges",
          "new_api": null,
          "old_text": "quick->adjust_prefix_ranges()",
          "new_text": null,
          "old_line_content": "  quick->adjust_prefix_ranges();",
          "new_line_content": "          quick= NULL;",
          "content_same": false
        },
        {
          "line": 6589,
          "old_api": "increment_use_count",
          "new_api": null,
          "old_text": "next->increment_use_count(use_count)",
          "new_text": null,
          "old_line_content": "\tnext->increment_use_count(use_count);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 10686,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(quick)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(quick);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 7822,
          "old_api": "uint) (tmp_min_key - param->min_key)",
          "new_api": null,
          "old_text": "uint) (tmp_min_key - param->min_key)",
          "new_text": null,
          "old_line_content": "    min_key_length= (uint) (tmp_min_key - param->min_key);",
          "new_line_content": "      tmp_min_keypart+=",
          "content_same": false
        },
        {
          "line": 8647,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"QUICK_ROR_UNION_SELECT::get_next\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"QUICK_ROR_UNION_SELECT::get_next\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4555,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"ror_intersect_add\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"ror_intersect_add\");",
          "new_line_content": "                           ror_scan_selectivity({scan1,...}, scanN). ",
          "content_same": false
        },
        {
          "line": 4556,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"Current out_rows= %g\", info->out_rows))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\", (\"Current out_rows= %g\", info->out_rows));",
          "new_line_content": "  RETURN",
          "content_same": false
        },
        {
          "line": 4557,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"Adding scan on %s\",\n                      info->param->table->key_info[ror_scan->keynr].name))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\", (\"Adding scan on %s\",",
          "new_line_content": "    TRUE   ROR scan added to ROR-intersection, cost updated.",
          "content_same": false
        },
        {
          "line": 8654,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(HA_ERR_END_OF_FILE)",
          "new_text": null,
          "old_line_content": "        DBUG_RETURN(HA_ERR_END_OF_FILE);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 4559,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"is_cpk_scan: %d\",is_cpk_scan))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\", (\"is_cpk_scan: %d\",is_cpk_scan));",
          "new_line_content": "*/",
          "content_same": false
        },
        {
          "line": 8657,
          "old_api": "queue_top",
          "new_api": null,
          "old_text": "queue_top(&queue)",
          "new_text": null,
          "old_line_content": "      quick= (QUICK_SELECT_I*)queue_top(&queue);",
          "new_line_content": "  uchar *tmp;",
          "content_same": false
        },
        {
          "line": 4561,
          "old_api": "ror_scan_selectivity",
          "new_api": null,
          "old_text": "ror_scan_selectivity(info, ror_scan)",
          "new_text": null,
          "old_line_content": "  selectivity_mult = ror_scan_selectivity(info, ror_scan);",
          "new_line_content": "static bool ror_intersect_add(ROR_INTERSECT_INFO *info,",
          "content_same": false
        },
        {
          "line": 8661,
          "old_api": "get_next",
          "new_api": null,
          "old_text": "quick->get_next()",
          "new_text": null,
          "old_line_content": "      if ((error= quick->get_next()))",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 4565,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"The scan doesn't improve selectivity.\"))",
          "new_text": null,
          "old_line_content": "    DBUG_PRINT(\"info\", (\"The scan doesn't improve selectivity.\"));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8664,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(error)",
          "new_text": null,
          "old_line_content": "          DBUG_RETURN(error);",
          "new_line_content": "      if (!queue.elements)",
          "content_same": false
        },
        {
          "line": 8670,
          "old_api": "queue_replaced",
          "new_api": null,
          "old_text": "queue_replaced(&queue)",
          "new_text": null,
          "old_line_content": "        queue_replaced(&queue);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4578,
          "old_api": "rows2double",
          "new_api": null,
          "old_text": "rows2double(info->index_records)",
          "new_text": null,
          "old_line_content": "    info->index_scan_costs += rows2double(info->index_records) / ",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 6630,
          "old_api": "swap_clone_flag",
          "new_api": null,
          "old_text": "swap_clone_flag(clone_flag)",
          "new_text": null,
          "old_line_content": "      clone_flag=swap_clone_flag(clone_flag);",
          "new_line_content": "key_and(RANGE_OPT_PARAM *param, SEL_ARG *key1, SEL_ARG *key2, uint clone_flag)",
          "content_same": false
        },
        {
          "line": 7831,
          "old_api": "unlikely",
          "new_api": null,
          "old_text": "unlikely(param->thd->killed != 0)",
          "new_text": null,
          "old_line_content": "  if (unlikely(param->thd->killed != 0))",
          "new_line_content": "                                             &tmp_max_flag,",
          "content_same": false
        },
        {
          "line": 4585,
          "old_api": "bitmap_union",
          "new_api": null,
          "old_text": "bitmap_union(&info->covered_fields, &ror_scan->covered_fields)",
          "new_text": null,
          "old_line_content": "    bitmap_union(&info->covered_fields, &ror_scan->covered_fields);",
          "new_line_content": "      CPK scan is used to filter out rows. We apply filtering for ",
          "content_same": false
        },
        {
          "line": 4586,
          "old_api": "bitmap_is_subset",
          "new_api": null,
          "old_text": "bitmap_is_subset(&info->param->needed_fields,\n                                               &info->covered_fields)",
          "new_text": null,
          "old_line_content": "    if (!info->is_covering && bitmap_is_subset(&info->param->needed_fields,",
          "new_line_content": "      each record of every scan. Assuming 1/TIME_FOR_COMPARE_ROWID",
          "content_same": false
        },
        {
          "line": 6635,
          "old_api": "clone_tree",
          "new_api": null,
          "old_text": "key1->clone_tree(param)",
          "new_text": null,
          "old_line_content": "      if (!(key1= key1->clone_tree(param)))",
          "new_line_content": "    return key1;",
          "content_same": false
        },
        {
          "line": 6637,
          "old_api": "and_all_keys",
          "new_api": null,
          "old_text": "and_all_keys(param, key1, key2, clone_flag)",
          "new_text": null,
          "old_line_content": "    return and_all_keys(param, key1, key2, clone_flag);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 8687,
          "old_api": "rnd_pos",
          "new_api": null,
          "old_text": "head->file->rnd_pos(quick->record, prev_rowid)",
          "new_text": null,
          "old_line_content": "    error= head->file->rnd_pos(quick->record, prev_rowid);",
          "new_line_content": "        dup_row= FALSE;",
          "content_same": false
        },
        {
          "line": 8689,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(error)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(error);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 4595,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"info->total_cost: %g\", info->total_cost))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\", (\"info->total_cost: %g\", info->total_cost));",
          "new_line_content": "    info->index_scan_costs += ror_scan->index_read_cost;",
          "content_same": false
        },
        {
          "line": 4599,
          "old_api": "double2rows",
          "new_api": null,
          "old_text": "double2rows(info->out_rows)",
          "new_text": null,
          "old_line_content": "      get_sweep_read_cost(info->param, double2rows(info->out_rows));",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 8697,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"QUICK_RANGE_SELECT::reset\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"QUICK_RANGE_SELECT::reset\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4602,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"New out_rows: %g\", info->out_rows))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\", (\"New out_rows: %g\", info->out_rows));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4603,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"New cost: %g, %scovering\", info->total_cost,\n                      info->is_covering?\"\" : \"non-\"))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\", (\"New cost: %g, %scovering\", info->total_cost,",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 4605,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(TRUE)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(TRUE);",
          "new_line_content": "  info->total_cost= info->index_scan_costs;",
          "content_same": false
        },
        {
          "line": 6655,
          "old_api": "clone_tree",
          "new_api": null,
          "old_text": "key1->clone_tree(param)",
          "new_text": null,
          "old_line_content": "      if (!(key1=key1->clone_tree(param)))",
          "new_line_content": "  {\t\t\t\t\t\t// Put simple key in key2",
          "content_same": false
        },
        {
          "line": 10752,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(!parent_alloc)",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(!parent_alloc);",
          "new_line_content": "  records= records_arg;",
          "content_same": false
        },
        {
          "line": 8706,
          "old_api": "column_bitmaps_set_no_signal",
          "new_api": null,
          "old_text": "head->column_bitmaps_set_no_signal(&column_bitmap, &column_bitmap)",
          "new_text": null,
          "old_line_content": "      head->column_bitmaps_set_no_signal(&column_bitmap, &column_bitmap);",
          "new_line_content": "  uint  mrange_bufsiz;",
          "content_same": false
        },
        {
          "line": 10755,
          "old_api": "init_sql_alloc",
          "new_api": null,
          "old_text": "init_sql_alloc(&alloc, join->thd->variables.range_alloc_block_size, 0)",
          "new_text": null,
          "old_line_content": "    init_sql_alloc(&alloc, join->thd->variables.range_alloc_block_size, 0);",
          "new_line_content": "  real_prefix_len= group_prefix_len + key_infix_len;",
          "content_same": false
        },
        {
          "line": 8709,
          "old_api": "DBUG_SET",
          "new_api": null,
          "old_text": "DBUG_SET(\"+d,ha_index_init_fail\")",
          "new_text": null,
          "old_line_content": "                    DBUG_SET(\"+d,ha_index_init_fail\"););",
          "new_line_content": "  next=0;",
          "content_same": false
        },
        {
          "line": 8710,
          "old_api": "ha_index_init",
          "new_api": null,
          "old_text": "file->ha_index_init(index,1)",
          "new_text": null,
          "old_line_content": "    if ((error= file->ha_index_init(index,1)))",
          "new_line_content": "  last_range= NULL;",
          "content_same": false
        },
        {
          "line": 10759,
          "old_api": "bzero",
          "new_api": null,
          "old_text": "bzero(&alloc, sizeof(MEM_ROOT))",
          "new_text": null,
          "old_line_content": "    bzero(&alloc, sizeof(MEM_ROOT));            // ensure that it's not used",
          "new_line_content": "  /*",
          "content_same": false
        },
        {
          "line": 8712,
          "old_api": "MYF",
          "new_api": null,
          "old_text": "MYF(0)",
          "new_text": null,
          "old_line_content": "        file->print_error(error, MYF(0));",
          "new_line_content": "  cur_range= (QUICK_RANGE**) ranges.buffer;",
          "content_same": false
        },
        {
          "line": 8713,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(error)",
          "new_text": null,
          "old_line_content": "        DBUG_RETURN(error);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6661,
          "old_api": "key_and",
          "new_api": null,
          "old_text": "key_and(param, key1->next_key_part, \n                                  key2->next_key_part, clone_flag)",
          "new_text": null,
          "old_line_content": "      key1->next_key_part=key_and(param, key1->next_key_part, ",
          "new_line_content": "  if (key2->type == SEL_ARG::MAYBE_KEY)",
          "content_same": false
        },
        {
          "line": 6669,
          "old_api": "maybe_smaller",
          "new_api": null,
          "old_text": "key1->maybe_smaller()",
          "new_text": null,
          "old_line_content": "      key1->maybe_smaller();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 6673,
          "old_api": "and_all_keys",
          "new_api": null,
          "old_text": "and_all_keys(param, key1, key2, clone_flag)",
          "new_text": null,
          "old_line_content": "\treturn and_all_keys(param, key1, key2, clone_flag);",
          "new_line_content": "                                  key2->next_key_part, clone_flag);",
          "content_same": false
        },
        {
          "line": 8725,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(ranges.elements)",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(ranges.elements);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 8726,
          "old_api": "min",
          "new_api": null,
          "old_text": "min(multi_range_count, ranges.elements)",
          "new_text": null,
          "old_line_content": "  multi_range_length= min(multi_range_count, ranges.elements);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 8727,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(multi_range_length > 0)",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(multi_range_length > 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8729,
          "old_api": "my_malloc",
          "new_api": null,
          "old_text": "my_malloc(multi_range_length *\n                                            sizeof(KEY_MULTI_RANGE),\n                                            MYF(MY_WME))",
          "new_text": null,
          "old_line_content": "                                  my_malloc(multi_range_length *",
          "new_line_content": "  if (multi_range_length)",
          "content_same": false
        },
        {
          "line": 6683,
          "old_api": "free_tree",
          "new_api": null,
          "old_text": "key1->free_tree()",
          "new_text": null,
          "old_line_content": "    key1->free_tree();",
          "new_line_content": "\tkey1->use_count--;\t\t\t// Incremented in and_all_keys",
          "content_same": false
        },
        {
          "line": 10785,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(&alloc, group_prefix_len)",
          "new_text": null,
          "old_line_content": "  if (!(last_prefix= (uchar*) alloc_root(&alloc, group_prefix_len)))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6690,
          "old_api": "first",
          "new_api": null,
          "old_text": "key2->first()",
          "new_text": null,
          "old_line_content": "  SEL_ARG *e1=key1->first(), *e2=key2->first(), *new_tree=0;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8739,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(HA_ERR_OUT_OF_MEM)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(HA_ERR_OUT_OF_MEM);",
          "new_line_content": "  while (multi_range_length && ! (multi_range= (KEY_MULTI_RANGE*)",
          "content_same": false
        },
        {
          "line": 8743,
          "old_api": "ha_table_flags",
          "new_api": null,
          "old_text": "file->ha_table_flags()",
          "new_text": null,
          "old_line_content": "  if (file->ha_table_flags() & HA_NEED_READ_RANGE_BUFFER)",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 10791,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(&alloc,\n                                         real_prefix_len + min_max_arg_len)",
          "new_text": null,
          "old_line_content": "  if (!(group_prefix= (uchar*) alloc_root(&alloc,",
          "new_line_content": "int QUICK_GROUP_MIN_MAX_SELECT::init()",
          "content_same": false
        },
        {
          "line": 8745,
          "old_api": "min",
          "new_api": null,
          "old_text": "min(multi_range_bufsiz,\n                       ((uint)QUICK_SELECT_I::records + 1)* head->s->reclength)",
          "new_text": null,
          "old_line_content": "    mrange_bufsiz= min(multi_range_bufsiz,",
          "new_line_content": "    multi_range_length/= 2;",
          "content_same": false
        },
        {
          "line": 6697,
          "old_api": "get_range",
          "new_api": null,
          "old_text": "get_range(&e1,&e2,key1)",
          "new_text": null,
          "old_line_content": "      if (get_range(&e1,&e2,key1))",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 6700,
          "old_api": "get_range",
          "new_api": null,
          "old_text": "get_range(&e2,&e1,key2)",
          "new_text": null,
          "old_line_content": "    else if (get_range(&e2,&e1,key2))",
          "new_line_content": "  key2->use_count--;",
          "content_same": false
        },
        {
          "line": 8749,
          "old_api": "MYF",
          "new_api": null,
          "old_text": "MYF(MY_WME)",
          "new_text": null,
          "old_line_content": "           ! my_multi_malloc(MYF(MY_WME),",
          "new_line_content": "    multi_range_length= 0;",
          "content_same": false
        },
        {
          "line": 6702,
          "old_api": "key_and",
          "new_api": null,
          "old_text": "key_and(param, e1->next_key_part, e2->next_key_part,\n                          clone_flag)",
          "new_text": null,
          "old_line_content": "    SEL_ARG *next=key_and(param, e1->next_key_part, e2->next_key_part,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6704,
          "old_api": "increment_use_count",
          "new_api": null,
          "old_text": "e1->increment_use_count(1)",
          "new_text": null,
          "old_line_content": "    e1->increment_use_count(1);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 10801,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(&alloc, key_infix_len)",
          "new_text": null,
          "old_line_content": "    uchar *tmp_key_infix= (uchar*) alloc_root(&alloc, key_infix_len);",
          "new_line_content": "  */",
          "content_same": false
        },
        {
          "line": 10804,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(tmp_key_infix, this->key_infix, key_infix_len)",
          "new_text": null,
          "old_line_content": "    memcpy(tmp_key_infix, this->key_infix, key_infix_len);",
          "new_line_content": "    return 1;",
          "content_same": false
        },
        {
          "line": 10810,
          "old_api": "my_init_dynamic_array",
          "new_api": null,
          "old_text": "my_init_dynamic_array(&min_max_ranges, sizeof(QUICK_RANGE*), 16, 16)",
          "new_text": null,
          "old_line_content": "    if (my_init_dynamic_array(&min_max_ranges, sizeof(QUICK_RANGE*), 16, 16))",
          "new_line_content": "      allocate a new buffer and copy the key_infix into it.",
          "content_same": false
        },
        {
          "line": 8763,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(HA_ERR_OUT_OF_MEM)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(HA_ERR_OUT_OF_MEM);",
          "new_line_content": "                             &mrange_buff, (uint) mrange_bufsiz,",
          "content_same": false
        },
        {
          "line": 6717,
          "old_api": "insert",
          "new_api": null,
          "old_text": "new_tree->insert(new_arg)",
          "new_text": null,
          "old_line_content": "\tnew_tree=new_tree->insert(new_arg);",
          "new_line_content": "    if (!next || next->type != SEL_ARG::IMPOSSIBLE)",
          "content_same": false
        },
        {
          "line": 6724,
          "old_api": "free_tree",
          "new_api": null,
          "old_text": "key1->free_tree()",
          "new_text": null,
          "old_line_content": "  key1->free_tree();",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 6725,
          "old_api": "free_tree",
          "new_api": null,
          "old_text": "key2->free_tree()",
          "new_text": null,
          "old_line_content": "  key2->free_tree();",
          "new_line_content": "\tnew_tree=new_arg;",
          "content_same": false
        },
        {
          "line": 8776,
          "old_api": "bzero",
          "new_api": null,
          "old_text": "bzero((char*) mrange_buff, mrange_bufsiz)",
          "new_text": null,
          "old_line_content": "    bzero((char*) mrange_buff, mrange_bufsiz);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4680,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"get_best_ror_intersect\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"get_best_ror_intersect\");",
          "new_line_content": "    ROR-intersection table read plan",
          "content_same": false
        },
        {
          "line": 8779,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(0);",
          "new_line_content": "    multi_range_buff->buffer_end= mrange_buff + mrange_bufsiz;",
          "content_same": false
        },
        {
          "line": 4683,
          "old_api": "optimizer_flag",
          "new_api": null,
          "old_text": "optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_INTERSECT)",
          "new_text": null,
          "old_line_content": "      !optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_INTERSECT))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4684,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "static",
          "content_same": false
        },
        {
          "line": 10832,
          "old_api": "sum_func",
          "new_api": null,
          "old_text": "min_max_item->sum_func()",
          "new_text": null,
          "old_line_content": "      if (have_min && (min_max_item->sum_func() == Item_sum::MIN_FUNC))",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 10833,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "min_functions->push_back(min_max_item)",
          "new_text": null,
          "old_line_content": "        min_functions->push_back(min_max_item);",
          "new_line_content": "      if (!(max_functions= new List<Item_sum>))",
          "content_same": false
        },
        {
          "line": 10834,
          "old_api": "sum_func",
          "new_api": null,
          "old_text": "min_max_item->sum_func()",
          "new_text": null,
          "old_line_content": "      else if (have_max && (min_max_item->sum_func() == Item_sum::MAX_FUNC))",
          "new_line_content": "        return 1;",
          "content_same": false
        },
        {
          "line": 10835,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "max_functions->push_back(min_max_item)",
          "new_text": null,
          "old_line_content": "        max_functions->push_back(min_max_item);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 6740,
          "old_api": "cmp_min_to_max",
          "new_api": null,
          "old_text": "*e1)->cmp_min_to_max(*e2)",
          "new_text": null,
          "old_line_content": "    if ((*e1)->cmp_min_to_max(*e2) > 0)",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 4699,
          "old_api": "primary_key_is_clustered",
          "new_api": null,
          "old_text": "param->table->file->primary_key_is_clustered()",
          "new_text": null,
          "old_line_content": "  cpk_no= ((param->table->file->primary_key_is_clustered()) ?",
          "new_line_content": "    them. Also find and save clustered PK scan if there is one.",
          "content_same": false
        },
        {
          "line": 4705,
          "old_api": "is_set",
          "new_api": null,
          "old_text": "tree->ror_scans_map.is_set(idx)",
          "new_text": null,
          "old_line_content": "    if (!tree->ror_scans_map.is_set(idx))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8802,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"QUICK_RANGE_SELECT::get_next\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"QUICK_RANGE_SELECT::get_next\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8803,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(multi_range_length && multi_range &&\n              (cur_range >= (QUICK_RANGE**) ranges.buffer) &&\n              (cur_range <= (QUICK_RANGE**) ranges.buffer + ranges.elements))",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(multi_range_length && multi_range &&",
          "new_line_content": "  RETURN",
          "content_same": false
        },
        {
          "line": 4707,
          "old_api": "make_ror_scan",
          "new_api": null,
          "old_text": "make_ror_scan(param, idx, tree->keys[idx])",
          "new_text": null,
          "old_line_content": "    if (!(scan= make_ror_scan(param, idx, tree->keys[idx])))",
          "new_line_content": "                                                     sizeof(ROR_SCAN_INFO*)*",
          "content_same": false
        },
        {
          "line": 10859,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::~QUICK_GROUP_MIN_MAX_SELECT\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::~QUICK_GROUP_MIN_MAX_SELECT\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 10861,
          "old_api": "ha_index_end",
          "new_api": null,
          "old_text": "file->ha_index_end()",
          "new_text": null,
          "old_line_content": "    file->ha_index_end();",
          "new_line_content": "  else",
          "content_same": false
        },
        {
          "line": 10863,
          "old_api": "delete_dynamic",
          "new_api": null,
          "old_text": "delete_dynamic(&min_max_ranges)",
          "new_text": null,
          "old_line_content": "    delete_dynamic(&min_max_ranges);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 10864,
          "old_api": "MYF",
          "new_api": null,
          "old_text": "MYF(0)",
          "new_text": null,
          "old_line_content": "  free_root(&alloc,MYF(0));",
          "new_line_content": "  return 0;",
          "content_same": false
        },
        {
          "line": 4719,
          "old_api": "print_ror_scans_arr",
          "new_api": null,
          "old_text": "print_ror_scans_arr(param->table, \"original\",\n                                          tree->ror_scans,\n                                          tree->ror_scans_end)",
          "new_text": null,
          "old_line_content": "  DBUG_EXECUTE(\"info\",print_ror_scans_arr(param->table, \"original\",",
          "new_line_content": "      return NULL;",
          "content_same": false
        },
        {
          "line": 2676,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"prune_partitions\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"prune_partitions\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8821,
          "old_api": "read_multi_range_next",
          "new_api": null,
          "old_text": "file->read_multi_range_next(&mrange)",
          "new_text": null,
          "old_line_content": "      result= file->read_multi_range_next(&mrange);",
          "new_line_content": "      We don't need to signal the bitmap change as the bitmap is always the",
          "content_same": false
        },
        {
          "line": 2679,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(FALSE)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(FALSE); /* not a partitioned table */",
          "new_line_content": "           records will satisfy pprune_cond)",
          "content_same": false
        },
        {
          "line": 4727,
          "old_api": "my_qsort",
          "new_api": null,
          "old_text": "my_qsort(tree->ror_scans, tree->n_ror_scans, sizeof(ROR_SCAN_INFO*),\n           (qsort_cmp)cmp_ror_scan_info)",
          "new_text": null,
          "old_line_content": "  my_qsort(tree->ror_scans, tree->n_ror_scans, sizeof(ROR_SCAN_INFO*),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 4729,
          "old_api": "print_ror_scans_arr",
          "new_api": null,
          "old_text": "print_ror_scans_arr(param->table, \"ordered\",\n                                          tree->ror_scans,\n                                          tree->ror_scans_end)",
          "new_text": null,
          "old_line_content": "  DBUG_EXECUTE(\"info\",print_ror_scans_arr(param->table, \"ordered\",",
          "new_line_content": "  tree->ror_scans_end= cur_ror_scan;",
          "content_same": false
        },
        {
          "line": 8826,
          "old_api": "min",
          "new_api": null,
          "old_text": "min(multi_range_length, ranges.elements -\n                    (cur_range - (QUICK_RANGE**) ranges.buffer))",
          "new_text": null,
          "old_line_content": "    uint count= min(multi_range_length, ranges.elements -",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2683,
          "old_api": "mark_all_partitions_as_used",
          "new_api": null,
          "old_text": "mark_all_partitions_as_used(part_info)",
          "new_text": null,
          "old_line_content": "    mark_all_partitions_as_used(part_info);",
          "new_line_content": "bool prune_partitions(THD *thd, TABLE *table, Item *pprune_cond)",
          "content_same": false
        },
        {
          "line": 2684,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(FALSE)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(FALSE);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 4735,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(param->mem_root,\n                                                     sizeof(ROR_SCAN_INFO*)*\n                                                     tree->n_ror_scans)",
          "new_text": null,
          "old_line_content": "  if (!(intersect_scans= (ROR_SCAN_INFO**)alloc_root(param->mem_root,",
          "new_line_content": "    ROR_SCAN_INFO's.",
          "content_same": false
        },
        {
          "line": 8833,
          "old_api": "column_bitmaps_set_no_signal",
          "new_api": null,
          "old_text": "head->column_bitmaps_set_no_signal(save_read_set, save_write_set)",
          "new_text": null,
          "old_line_content": "        head->column_bitmaps_set_no_signal(save_read_set, save_write_set);",
          "new_line_content": "      if (result != HA_ERR_END_OF_FILE)",
          "content_same": false
        },
        {
          "line": 8834,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(HA_ERR_END_OF_FILE)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(HA_ERR_END_OF_FILE);",
          "new_line_content": "        goto end;",
          "content_same": false
        },
        {
          "line": 2693,
          "old_api": "init_sql_alloc",
          "new_api": null,
          "old_text": "init_sql_alloc(&alloc, thd->variables.range_alloc_block_size, 0)",
          "new_text": null,
          "old_line_content": "  init_sql_alloc(&alloc, thd->variables.range_alloc_block_size, 0);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 4743,
          "old_api": "ror_intersect_init",
          "new_api": null,
          "old_text": "ror_intersect_init(param)",
          "new_text": null,
          "old_line_content": "  if (!(intersect= ror_intersect_init(param)) || ",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4744,
          "old_api": "ror_intersect_init",
          "new_api": null,
          "old_text": "ror_intersect_init(param)",
          "new_text": null,
          "old_line_content": "      !(intersect_best= ror_intersect_init(param)))",
          "new_line_content": "  ROR_SCAN_INFO **intersect_scans; /* ROR scans used in index intersection */",
          "content_same": false
        },
        {
          "line": 2697,
          "old_api": "create_partition_index_description",
          "new_api": null,
          "old_text": "create_partition_index_description(&prune_param)",
          "new_text": null,
          "old_line_content": "  if (create_partition_index_description(&prune_param))",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 8842,
          "old_api": "make_min_endpoint",
          "new_api": null,
          "old_text": "last_range->make_min_endpoint(&mrange_slot->start_key)",
          "new_text": null,
          "old_line_content": "      last_range->make_min_endpoint(&mrange_slot->start_key);",
          "new_line_content": "      in_range= FALSE;",
          "content_same": false
        },
        {
          "line": 8843,
          "old_api": "make_max_endpoint",
          "new_api": null,
          "old_text": "last_range->make_max_endpoint(&mrange_slot->end_key)",
          "new_text": null,
          "old_line_content": "      last_range->make_max_endpoint(&mrange_slot->end_key);",
          "new_line_content": "      if (in_ror_merged_scan)",
          "content_same": false
        },
        {
          "line": 2699,
          "old_api": "mark_all_partitions_as_used",
          "new_api": null,
          "old_text": "mark_all_partitions_as_used(part_info)",
          "new_text": null,
          "old_line_content": "    mark_all_partitions_as_used(part_info);",
          "new_line_content": "  MEM_ROOT alloc;",
          "content_same": false
        },
        {
          "line": 2700,
          "old_api": "MYF",
          "new_api": null,
          "old_text": "MYF(0)",
          "new_text": null,
          "old_line_content": "    free_root(&alloc,MYF(0));\t\t// Return memory & allocator",
          "new_line_content": "  RANGE_OPT_PARAM  *range_par= &prune_param.range_param;",
          "content_same": false
        },
        {
          "line": 2701,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(FALSE)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(FALSE);",
          "new_line_content": "  my_bitmap_map *old_sets[2];",
          "content_same": false
        },
        {
          "line": 8847,
          "old_api": "read_multi_range_first",
          "new_api": null,
          "old_text": "file->read_multi_range_first(&mrange, multi_range, count,\n                                         sorted, multi_range_buff)",
          "new_text": null,
          "old_line_content": "    result= file->read_multi_range_first(&mrange, multi_range, count,",
          "new_line_content": "    KEY_MULTI_RANGE *mrange_slot, *mrange_end;",
          "content_same": false
        },
        {
          "line": 10905,
          "old_api": "memcmp",
          "new_api": null,
          "old_text": "memcmp(sel_range->min_value, sel_range->max_value,\n                    min_max_arg_len)",
          "new_text": null,
          "old_line_content": "    else if (memcmp(sel_range->min_value, sel_range->max_value,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8859,
          "old_api": "column_bitmaps_set_no_signal",
          "new_api": null,
          "old_text": "head->column_bitmaps_set_no_signal(save_read_set, save_write_set)",
          "new_text": null,
          "old_line_content": "    head->column_bitmaps_set_no_signal(save_read_set, save_write_set);",
          "new_line_content": "                                         sorted, multi_range_buff);",
          "content_same": false
        },
        {
          "line": 8861,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(result)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(result);",
          "new_line_content": "      goto end;",
          "content_same": false
        },
        {
          "line": 10910,
          "old_api": "make_keypart_map",
          "new_api": null,
          "old_text": "make_keypart_map(sel_range->part)",
          "new_text": null,
          "old_line_content": "                         make_keypart_map(sel_range->part),",
          "new_line_content": "  if (!(sel_range->min_flag & NO_MIN_RANGE) &&",
          "content_same": false
        },
        {
          "line": 6815,
          "old_api": "free_tree",
          "new_api": null,
          "old_text": "key2->free_tree()",
          "new_text": null,
          "old_line_content": "      key2->free_tree();",
          "new_line_content": "   ( 2  <  kp1 < 10 AND 1 < kp2 < 20 ) OR",
          "content_same": false
        },
        {
          "line": 10912,
          "old_api": "make_keypart_map",
          "new_api": null,
          "old_text": "make_keypart_map(sel_range->part)",
          "new_text": null,
          "old_line_content": "                         make_keypart_map(sel_range->part),",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 2721,
          "old_api": "bitmap_clear_all",
          "new_api": null,
          "old_text": "bitmap_clear_all(&part_info->used_partitions)",
          "new_text": null,
          "old_line_content": "  bitmap_clear_all(&part_info->used_partitions);",
          "new_line_content": "  range_par->current_table= table->map;",
          "content_same": false
        },
        {
          "line": 4773,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"None of scans increase selectivity\"))",
          "new_text": null,
          "old_line_content": "    DBUG_PRINT(\"info\", (\"None of scans increase selectivity\"));",
          "new_line_content": "    if (intersect->total_cost < min_cost)",
          "content_same": false
        },
        {
          "line": 4774,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2727,
          "old_api": "get_mm_tree",
          "new_api": null,
          "old_text": "get_mm_tree(range_par, pprune_cond)",
          "new_text": null,
          "old_line_content": "  tree= get_mm_tree(range_par, pprune_cond);",
          "new_line_content": "  range_par->alloced_sel_args= 0;",
          "content_same": false
        },
        {
          "line": 6822,
          "old_api": "free_tree",
          "new_api": null,
          "old_text": "key1->free_tree()",
          "new_text": null,
          "old_line_content": "    key1->free_tree();",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 4777,
          "old_api": "print_ror_scans_arr",
          "new_api": null,
          "old_text": "print_ror_scans_arr(param->table,\n                                          \"best ROR-intersection\",\n                                          intersect_scans,\n                                          intersect_scans_best)",
          "new_text": null,
          "old_line_content": "  DBUG_EXECUTE(\"info\",print_ror_scans_arr(param->table,",
          "new_line_content": "      intersect_scans_best= intersect_scans_end;",
          "content_same": false
        },
        {
          "line": 6831,
          "old_api": "free_tree",
          "new_api": null,
          "old_text": "key1->free_tree()",
          "new_text": null,
          "old_line_content": "    key1->free_tree();",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 6832,
          "old_api": "free_tree",
          "new_api": null,
          "old_text": "key2->free_tree()",
          "new_text": null,
          "old_line_content": "    key2->free_tree();",
          "new_line_content": "    key1->use_count--;",
          "content_same": false
        },
        {
          "line": 2740,
          "old_api": "is_empty",
          "new_api": null,
          "old_text": "tree->merges.is_empty()",
          "new_text": null,
          "old_line_content": "  if (tree->merges.is_empty())",
          "new_line_content": "    goto all_used;",
          "content_same": false
        },
        {
          "line": 6839,
          "old_api": "free_tree",
          "new_api": null,
          "old_text": "key2->free_tree()",
          "new_text": null,
          "old_line_content": "    key2->free_tree();",
          "new_line_content": "  if (key1->part != key2->part || ",
          "content_same": false
        },
        {
          "line": 4793,
          "old_api": "ror_intersect_add",
          "new_api": null,
          "old_text": "ror_intersect_add(intersect, cpk_scan, TRUE)",
          "new_text": null,
          "old_line_content": "    if (ror_intersect_add(intersect, cpk_scan, TRUE) && ",
          "new_line_content": "  *are_all_covering= intersect->is_covering;",
          "content_same": false
        },
        {
          "line": 6845,
          "old_api": "free_tree",
          "new_api": null,
          "old_text": "key1->free_tree()",
          "new_text": null,
          "old_line_content": "    key1->free_tree();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 8894,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"QUICK_RANGE_SELECT::get_next_prefix\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"QUICK_RANGE_SELECT::get_next_prefix\");",
          "new_line_content": "    duplication.",
          "content_same": false
        },
        {
          "line": 8895,
          "old_api": "make_prev_keypart_map",
          "new_api": null,
          "old_text": "make_prev_keypart_map(group_key_parts)",
          "new_text": null,
          "old_line_content": "  const key_part_map keypart_map= make_prev_keypart_map(group_key_parts);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2752,
          "old_api": "find_used_partitions",
          "new_api": null,
          "old_text": "find_used_partitions(&prune_param,\n                                                            tree->keys[0])",
          "new_text": null,
          "old_line_content": "    if (!tree->keys[0] || (-1 == (res= find_used_partitions(&prune_param,",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 4806,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(trp)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(trp);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 8903,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(cur_prefix != NULL)",
          "new_text": null,
          "old_line_content": "      DBUG_ASSERT(cur_prefix != NULL);",
          "new_line_content": "                                        uchar *cur_prefix)",
          "content_same": false
        },
        {
          "line": 8904,
          "old_api": "index_read_map",
          "new_api": null,
          "old_text": "file->index_read_map(record, cur_prefix, keypart_map,\n                                   HA_READ_AFTER_KEY)",
          "new_text": null,
          "old_line_content": "      result= file->index_read_map(record, cur_prefix, keypart_map,",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 10951,
          "old_api": "get_dynamic",
          "new_api": null,
          "old_text": "get_dynamic(arr, (uchar*)&range, inx)",
          "new_text": null,
          "old_line_content": "      get_dynamic(arr, (uchar*)&range, inx);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 4808,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(param->mem_root,\n                                       sizeof(ROR_SCAN_INFO*)*best_num)",
          "new_text": null,
          "old_line_content": "           (ROR_SCAN_INFO**)alloc_root(param->mem_root,",
          "new_line_content": "      intersect_best= intersect; //just set pointer here",
          "content_same": false
        },
        {
          "line": 8907,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(result)",
          "new_text": null,
          "old_line_content": "        DBUG_RETURN(result);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4810,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(NULL);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 4811,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(trp->first_scan, intersect_scans, best_num*sizeof(ROR_SCAN_INFO*))",
          "new_text": null,
          "old_line_content": "    memcpy(trp->first_scan, intersect_scans, best_num*sizeof(ROR_SCAN_INFO*));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8910,
          "old_api": "make_max_endpoint",
          "new_api": null,
          "old_text": "last_range->make_max_endpoint(&previous_endpoint, prefix_length, keypart_map)",
          "new_text": null,
          "old_line_content": "      last_range->make_max_endpoint(&previous_endpoint, prefix_length, keypart_map);",
          "new_line_content": "    int result;",
          "content_same": false
        },
        {
          "line": 8911,
          "old_api": "compare_key",
          "new_api": null,
          "old_text": "file->compare_key(&previous_endpoint)",
          "new_text": null,
          "old_line_content": "      if (file->compare_key(&previous_endpoint) <= 0)",
          "new_line_content": "    if (last_range)",
          "content_same": false
        },
        {
          "line": 8912,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "        DBUG_RETURN(0);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2769,
          "old_api": "head",
          "new_api": null,
          "old_text": "find_used_partitions_imerge(&prune_param,\n                                                  tree->merges.head())",
          "new_text": null,
          "old_line_content": "      if (-1 == (res= find_used_partitions_imerge(&prune_param,",
          "new_line_content": "    if (tree->merges.elements == 1)",
          "content_same": false
        },
        {
          "line": 2770,
          "old_api": "head",
          "new_api": null,
          "old_text": "tree->merges.head()",
          "new_text": null,
          "old_line_content": "                                                  tree->merges.head())))",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 4816,
          "old_api": "double2rows",
          "new_api": null,
          "old_text": "double2rows(intersect_best->out_rows)",
          "new_text": null,
          "old_line_content": "    ha_rows best_rows = double2rows(intersect_best->out_rows);",
          "new_line_content": "    if (!(trp= new (param->mem_root) TRP_ROR_INTERSECT))",
          "content_same": false
        },
        {
          "line": 6864,
          "old_api": "first",
          "new_api": null,
          "old_text": "key2->first()",
          "new_text": null,
          "old_line_content": "  for (key2=key2->first(); key2; )",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 6866,
          "old_api": "find_range",
          "new_api": null,
          "old_text": "key1->find_range(key2)",
          "new_text": null,
          "old_line_content": "    SEL_ARG *tmp=key1->find_range(key2);\t// Find key1.min <= key2.min",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4823,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"Returning non-covering ROR-intersect plan:\"\n                        \"cost %g, records %lu\",\n                        trp->read_cost, (ulong) trp->records))",
          "new_text": null,
          "old_line_content": "    DBUG_PRINT(\"info\", (\"Returning non-covering ROR-intersect plan:\"",
          "new_line_content": "    trp->last_scan=  trp->first_scan + best_num;",
          "content_same": false
        },
        {
          "line": 8920,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(HA_ERR_END_OF_FILE)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(HA_ERR_END_OF_FILE);",
          "new_line_content": "      key_range previous_endpoint;",
          "content_same": false
        },
        {
          "line": 6871,
          "old_api": "first",
          "new_api": null,
          "old_text": "key1->first()",
          "new_text": null,
          "old_line_content": "      tmp=key1->first();\t\t\t// tmp.min > key2.min",
          "new_line_content": "  // Add tree at key2 to tree at key1",
          "content_same": false
        },
        {
          "line": 6874,
          "old_api": "cmp_max_to_min",
          "new_api": null,
          "old_text": "tmp->cmp_max_to_min(key2)",
          "new_text": null,
          "old_line_content": "    else if ((cmp=tmp->cmp_max_to_min(key2)) < 0)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8925,
          "old_api": "make_min_endpoint",
          "new_api": null,
          "old_text": "last_range->make_min_endpoint(&start_key, prefix_length, keypart_map)",
          "new_text": null,
          "old_line_content": "    last_range->make_min_endpoint(&start_key, prefix_length, keypart_map);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8926,
          "old_api": "make_max_endpoint",
          "new_api": null,
          "old_text": "last_range->make_max_endpoint(&end_key, prefix_length, keypart_map)",
          "new_text": null,
          "old_line_content": "    last_range->make_max_endpoint(&end_key, prefix_length, keypart_map);",
          "new_line_content": "    uint count= ranges.elements - (cur_range - (QUICK_RANGE**) ranges.buffer);",
          "content_same": false
        },
        {
          "line": 2782,
          "old_api": "find_used_partitions_imerge_list",
          "new_api": null,
          "old_text": "find_used_partitions_imerge_list(&prune_param,\n                                                       tree->merges)",
          "new_text": null,
          "old_line_content": "      if (-1 == (res= find_used_partitions_imerge_list(&prune_param,",
          "new_line_content": "        goto all_used;",
          "content_same": false
        },
        {
          "line": 8928,
          "old_api": "read_range_first",
          "new_api": null,
          "old_text": "file->read_range_first(last_range->min_keypart_map ? &start_key : 0,\n\t\t\t\t   last_range->max_keypart_map ? &end_key : 0,\n                                   test(last_range->flag & EQ_RANGE),\n\t\t\t\t   TRUE)",
          "new_text": null,
          "old_line_content": "    result= file->read_range_first(last_range->min_keypart_map ? &start_key : 0,",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 6878,
          "old_api": "eq_tree",
          "new_api": null,
          "old_text": "eq_tree(tmp->next_key_part,key2->next_key_part)",
          "new_text": null,
          "old_line_content": "      if (cmp == -2 && eq_tree(tmp->next_key_part,key2->next_key_part))",
          "new_line_content": "    int cmp;",
          "content_same": false
        },
        {
          "line": 8930,
          "old_api": "test",
          "new_api": null,
          "old_text": "test(last_range->flag & EQ_RANGE)",
          "new_text": null,
          "old_line_content": "                                   test(last_range->flag & EQ_RANGE),",
          "new_line_content": "      last_range= 0;",
          "content_same": false
        },
        {
          "line": 6886,
          "old_api": "increment_use_count",
          "new_api": null,
          "old_text": "key2->increment_use_count(key1->use_count+1)",
          "new_text": null,
          "old_line_content": "\t  key2->increment_use_count(key1->use_count+1);",
          "new_line_content": "    {\t\t\t\t\t\t// Found tmp.max < key2.min",
          "content_same": false
        },
        {
          "line": 6890,
          "old_api": "tree_delete",
          "new_api": null,
          "old_text": "key1->tree_delete(tmp)",
          "new_text": null,
          "old_line_content": "\tif (!(key1=key1->tree_delete(tmp)))",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 10987,
          "old_api": "get_dynamic",
          "new_api": null,
          "old_text": "get_dynamic(&min_max_ranges, (uchar*)&cur_range,\n                  min_max_ranges.elements - 1)",
          "new_text": null,
          "old_line_content": "      get_dynamic(&min_max_ranges, (uchar*)&cur_range,",
          "new_line_content": "    None",
          "content_same": false
        },
        {
          "line": 6893,
          "old_api": "make_root",
          "new_api": null,
          "old_text": "key1->make_root()",
          "new_text": null,
          "old_line_content": "\t  key1->make_root();",
          "new_line_content": "\tif (key2_shared)",
          "content_same": false
        },
        {
          "line": 2798,
          "old_api": "mark_all_partitions_as_used",
          "new_api": null,
          "old_text": "mark_all_partitions_as_used(prune_param.part_info)",
          "new_text": null,
          "old_line_content": "  mark_all_partitions_as_used(prune_param.part_info);",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 2800,
          "old_api": "dbug_tmp_restore_column_maps",
          "new_api": null,
          "old_text": "dbug_tmp_restore_column_maps(table->read_set, table->write_set, old_sets)",
          "new_text": null,
          "old_line_content": "  dbug_tmp_restore_column_maps(table->read_set, table->write_set, old_sets);",
          "new_line_content": "    res == 0 => no used partitions => retval=TRUE",
          "content_same": false
        },
        {
          "line": 8946,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"QUICK_RANGE_SELECT_GEOM::get_next\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"QUICK_RANGE_SELECT_GEOM::get_next\");",
          "new_line_content": "    if (result != HA_ERR_END_OF_FILE)",
          "content_same": false
        },
        {
          "line": 2803,
          "old_api": "MYF",
          "new_api": null,
          "old_text": "MYF(0)",
          "new_text": null,
          "old_line_content": "  free_root(&alloc,MYF(0));\t\t\t// Return memory & allocator",
          "new_line_content": "  */",
          "content_same": false
        },
        {
          "line": 8954,
          "old_api": "index_next_same",
          "new_api": null,
          "old_text": "file->index_next_same(record, last_range->min_key,\n\t\t\t\t    last_range->min_length)",
          "new_text": null,
          "old_line_content": "      result= file->index_next_same(record, last_range->min_key,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6907,
          "old_api": "eq_tree",
          "new_api": null,
          "old_text": "eq_tree(tmp->next_key_part,key2->next_key_part)",
          "new_text": null,
          "old_line_content": "\tif (tmp_cmp == 2 && eq_tree(tmp->next_key_part,key2->next_key_part))",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 6909,
          "old_api": "copy_min_to_min",
          "new_api": null,
          "old_text": "tmp->copy_min_to_min(key2)",
          "new_text": null,
          "old_line_content": "\t  tmp->copy_min_to_min(key2);",
          "new_line_content": "      if (!(tmp=next))\t\t\t\t// tmp.min > key2.min",
          "content_same": false
        },
        {
          "line": 6910,
          "old_api": "merge_flags",
          "new_api": null,
          "old_text": "key1->merge_flags(key2)",
          "new_text": null,
          "old_line_content": "\t  key1->merge_flags(key2);",
          "new_line_content": "\tbreak;\t\t\t\t\t// Copy rest of key2",
          "content_same": false
        },
        {
          "line": 11008,
          "old_api": "real_maybe_null",
          "new_api": null,
          "old_text": "min_max_arg_part->field->real_maybe_null()",
          "new_text": null,
          "old_line_content": "           min_max_arg_part->field->real_maybe_null())",
          "new_line_content": "    { /* Check if the left-most range has an upper boundary. */",
          "content_same": false
        },
        {
          "line": 4871,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"get_best_covering_ror_intersect\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"get_best_covering_ror_intersect\");",
          "new_line_content": "      I=I-first(I);",
          "content_same": false
        },
        {
          "line": 8969,
          "old_api": "index_read_map",
          "new_api": null,
          "old_text": "file->index_read_map(record, last_range->min_key,\n                                 last_range->min_keypart_map,\n                                 (ha_rkey_function)(last_range->flag ^\n                                                    GEOM_FLAG))",
          "new_text": null,
          "old_line_content": "    result= file->index_read_map(record, last_range->min_key,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4873,
          "old_api": "optimizer_flag",
          "new_api": null,
          "old_text": "optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_INTERSECT)",
          "new_text": null,
          "old_line_content": "  if (!optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_INTERSECT))",
          "new_line_content": "*/",
          "content_same": false
        },
        {
          "line": 8971,
          "old_api": "ha_rkey_function)(last_range->flag ^\n                                                    GEOM_FLAG)",
          "new_api": null,
          "old_text": "ha_rkey_function)(last_range->flag ^\n                                                    GEOM_FLAG)",
          "new_text": null,
          "old_line_content": "                                 (ha_rkey_function)(last_range->flag ^",
          "new_line_content": "    uint count= ranges.elements - (cur_range - (QUICK_RANGE**) ranges.buffer);",
          "content_same": false
        },
        {
          "line": 4874,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2829,
          "old_api": "real_maybe_null",
          "new_api": null,
          "old_text": "field->real_maybe_null()",
          "new_text": null,
          "old_line_content": "  if (field->real_maybe_null())",
          "new_line_content": "    Copy the field value from its key image to the table record. The source",
          "content_same": false
        },
        {
          "line": 8974,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(result)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(result);",
          "new_line_content": "      /* Ranges have already been used up before. None is left for read. */",
          "content_same": false
        },
        {
          "line": 2833,
          "old_api": "set_null",
          "new_api": null,
          "old_text": "field->set_null()",
          "new_text": null,
          "old_line_content": "      field->set_null();",
          "new_line_content": "*/",
          "content_same": false
        },
        {
          "line": 6930,
          "old_api": "insert",
          "new_api": null,
          "old_text": "key1->insert(cpy)",
          "new_text": null,
          "old_line_content": "\t    key1=key1->insert(cpy);",
          "new_line_content": "\t  key2=key2->next;",
          "content_same": false
        },
        {
          "line": 6931,
          "old_api": "increment_use_count",
          "new_api": null,
          "old_text": "key2->increment_use_count(key1->use_count+1)",
          "new_text": null,
          "old_line_content": "\t    key2->increment_use_count(key1->use_count+1);",
          "new_line_content": "\t  continue;",
          "content_same": false
        },
        {
          "line": 2836,
          "old_api": "set_notnull",
          "new_api": null,
          "old_text": "field->set_notnull()",
          "new_text": null,
          "old_line_content": "    field->set_notnull();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 6934,
          "old_api": "insert",
          "new_api": null,
          "old_text": "key1->insert(key2)",
          "new_text": null,
          "old_line_content": "\t    key1=key1->insert(key2);\t\t// Will destroy key2_root",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 2839,
          "old_api": "dbug_tmp_use_all_columns",
          "new_api": null,
          "old_text": "dbug_tmp_use_all_columns(field->table,\n                                    field->table->write_set)",
          "new_text": null,
          "old_line_content": "  old_map= dbug_tmp_use_all_columns(field->table,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2841,
          "old_api": "set_key_image",
          "new_api": null,
          "old_text": "field->set_key_image(ptr, len)",
          "new_text": null,
          "old_line_content": "  field->set_key_image(ptr, len); ",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 2842,
          "old_api": "dbug_tmp_restore_column_map",
          "new_api": null,
          "old_text": "dbug_tmp_restore_column_map(field->table->write_set, old_map)",
          "new_text": null,
          "old_line_content": "  dbug_tmp_restore_column_map(field->table->write_set, old_map);",
          "new_line_content": "    if (*ptr)",
          "content_same": false
        },
        {
          "line": 4890,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(param->mem_root,\n                                               param->fields_bitmap_size)",
          "new_text": null,
          "old_line_content": "    covered_fields->bitmap= (my_bitmap_map*)alloc_root(param->mem_root,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4893,
          "old_api": "bitmap_init",
          "new_api": null,
          "old_text": "bitmap_init(covered_fields, covered_fields->bitmap,\n                  param->table->s->fields, FALSE)",
          "new_text": null,
          "old_line_content": "      bitmap_init(covered_fields, covered_fields->bitmap,",
          "new_line_content": "    Assume set I is [ror_scan .. ror_scans_end)",
          "content_same": false
        },
        {
          "line": 4895,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4896,
          "old_api": "bitmap_clear_all",
          "new_api": null,
          "old_text": "bitmap_clear_all(covered_fields)",
          "new_text": null,
          "old_line_content": "  bitmap_clear_all(covered_fields);",
          "new_line_content": "  /*I=set of all covering indexes */",
          "content_same": false
        },
        {
          "line": 11042,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::reset\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::reset\");",
          "new_line_content": "    Initialize the index chosen for access and find and store the prefix",
          "content_same": false
        },
        {
          "line": 6947,
          "old_api": "is_same",
          "new_api": null,
          "old_text": "tmp->is_same(key2)",
          "new_text": null,
          "old_line_content": "      if (tmp->is_same(key2))",
          "new_line_content": "\t  continue;",
          "content_same": false
        },
        {
          "line": 11044,
          "old_api": "set_keyread",
          "new_api": null,
          "old_text": "head->set_keyread(TRUE)",
          "new_text": null,
          "old_line_content": "  head->set_keyread(TRUE); /* We need only the key attributes */",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 11045,
          "old_api": "ha_index_init",
          "new_api": null,
          "old_text": "file->ha_index_init(index,1)",
          "new_text": null,
          "old_line_content": "  if ((result= file->ha_index_init(index,1)))",
          "new_line_content": "  RETURN",
          "content_same": false
        },
        {
          "line": 4902,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"Building covering ROR-intersection\"))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\", (\"Building covering ROR-intersection\"));",
          "new_line_content": "                                               param->fields_bitmap_size);",
          "content_same": false
        },
        {
          "line": 11047,
          "old_api": "MYF",
          "new_api": null,
          "old_text": "MYF(0)",
          "new_text": null,
          "old_line_content": "    head->file->print_error(result, MYF(0));",
          "new_line_content": "    other  Error code",
          "content_same": false
        },
        {
          "line": 11048,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(result)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(result);",
          "new_line_content": "*/",
          "content_same": false
        },
        {
          "line": 4903,
          "old_api": "print_ror_scans_arr",
          "new_api": null,
          "old_text": "print_ror_scans_arr(param->table,\n                                           \"building covering ROR-I\",\n                                           ror_scan_mark, ror_scans_end)",
          "new_text": null,
          "old_line_content": "  DBUG_EXECUTE(\"info\", print_ror_scans_arr(param->table,",
          "new_line_content": "  if (!covered_fields->bitmap ||",
          "content_same": false
        },
        {
          "line": 11050,
          "old_api": "reset",
          "new_api": null,
          "old_text": "quick_prefix_select->reset()",
          "new_text": null,
          "old_line_content": "  if (quick_prefix_select && quick_prefix_select->reset())",
          "new_line_content": "int QUICK_GROUP_MIN_MAX_SELECT::reset(void)",
          "content_same": false
        },
        {
          "line": 11051,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(1)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(1);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 11052,
          "old_api": "index_last",
          "new_api": null,
          "old_text": "file->index_last(record)",
          "new_text": null,
          "old_line_content": "  result= file->index_last(record);",
          "new_line_content": "  int result;",
          "content_same": false
        },
        {
          "line": 6953,
          "old_api": "merge_flags",
          "new_api": null,
          "old_text": "tmp->merge_flags(key2)",
          "new_text": null,
          "old_line_content": "\ttmp->merge_flags(key2);\t\t\t// Copy maybe flags",
          "new_line_content": "      tmp.min >= key2.min && tmp.min <= key.max  (overlapping ranges)",
          "content_same": false
        },
        {
          "line": 11054,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 9007,
          "old_api": "dynamic_array_ptr",
          "new_api": null,
          "old_text": "dynamic_array_ptr(&ranges, mid)",
          "new_text": null,
          "old_line_content": "    if (cmp_next(*(QUICK_RANGE**)dynamic_array_ptr(&ranges, mid)))",
          "new_line_content": "*/",
          "content_same": false
        },
        {
          "line": 6954,
          "old_api": "increment_use_count",
          "new_api": null,
          "old_text": "key2->increment_use_count(-1)",
          "new_text": null,
          "old_line_content": "\tkey2->increment_use_count(-1);\t\t// Free not used tree",
          "new_line_content": "      key2.min <= tmp.min <= key2.max ",
          "content_same": false
        },
        {
          "line": 2867,
          "old_api": "store_key_image_to_rec",
          "new_api": null,
          "old_text": "store_key_image_to_rec(sel_arg->field, sel_arg->min_value,\n                           parts[sel_arg->part].length)",
          "new_text": null,
          "old_line_content": "    store_key_image_to_rec(sel_arg->field, sel_arg->min_value,",
          "new_line_content": "    For each SEL_ARG* interval in the specified array, store the left edge",
          "content_same": false
        },
        {
          "line": 4916,
          "old_api": "bitmap_subtract",
          "new_api": null,
          "old_text": "bitmap_subtract(&(*scan)->covered_fields, covered_fields)",
          "new_text": null,
          "old_line_content": "      bitmap_subtract(&(*scan)->covered_fields, covered_fields);",
          "new_line_content": "                                           ror_scan_mark, ror_scans_end););",
          "content_same": false
        },
        {
          "line": 4918,
          "old_api": "bitmap_bits_set",
          "new_api": null,
          "old_text": "bitmap_bits_set(&(*scan)->covered_fields)",
          "new_text": null,
          "old_line_content": "        bitmap_bits_set(&(*scan)->covered_fields);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 9016,
          "old_api": "dynamic_array_ptr",
          "new_api": null,
          "old_text": "dynamic_array_ptr(&ranges, mid)",
          "new_text": null,
          "old_line_content": "  res= *(QUICK_RANGE**)dynamic_array_ptr(&ranges, mid);",
          "new_line_content": "  while (min != max)",
          "content_same": false
        },
        {
          "line": 9017,
          "old_api": "cmp_prev",
          "new_api": null,
          "old_text": "cmp_prev(res)",
          "new_text": null,
          "old_line_content": "  return (!cmp_next(res) && !cmp_prev(res));",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 4920,
          "old_api": "bitmap_get_first",
          "new_api": null,
          "old_text": "bitmap_get_first(&(*scan)->covered_fields)",
          "new_text": null,
          "old_line_content": "        bitmap_get_first(&(*scan)->covered_fields);",
          "new_line_content": "      Update changed sorting info:",
          "content_same": false
        },
        {
          "line": 4923,
          "old_api": "my_qsort",
          "new_api": null,
          "old_text": "my_qsort(ror_scan_mark, ror_scans_end-ror_scan_mark, sizeof(ROR_SCAN_INFO*),\n             (qsort_cmp)cmp_ror_scan_info_covering)",
          "new_text": null,
          "old_line_content": "    my_qsort(ror_scan_mark, ror_scans_end-ror_scan_mark, sizeof(ROR_SCAN_INFO*),",
          "new_line_content": "      Calculate and save these values for each of remaining scans.",
          "content_same": false
        },
        {
          "line": 2877,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"mark_full_partition_used_no_parts\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"mark_full_partition_used_no_parts\");",
          "new_line_content": "    SEL_ARG *sel_arg= (*start);",
          "content_same": false
        },
        {
          "line": 4926,
          "old_api": "print_ror_scans_arr",
          "new_api": null,
          "old_text": "print_ror_scans_arr(param->table,\n                                             \"remaining scans\",\n                                             ror_scan_mark, ror_scans_end)",
          "new_text": null,
          "old_line_content": "    DBUG_EXECUTE(\"info\", print_ror_scans_arr(param->table,",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2879,
          "old_api": "bitmap_set_bit",
          "new_api": null,
          "old_text": "bitmap_set_bit(&part_info->used_partitions, part_id)",
          "new_text": null,
          "old_line_content": "  bitmap_set_bit(&part_info->used_partitions, part_id);",
          "new_line_content": "                           parts[sel_arg->part].length);",
          "content_same": false
        },
        {
          "line": 6978,
          "old_api": "tree_delete",
          "new_api": null,
          "old_text": "key1->tree_delete(save)",
          "new_text": null,
          "old_line_content": "\t  key1=key1->tree_delete(save);",
          "new_line_content": "          /*",
          "content_same": false
        },
        {
          "line": 4933,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"Adding scan on %s\",\n                        param->table->key_info[(*ror_scan_mark)->keynr].name))",
          "new_text": null,
          "old_line_content": "    DBUG_PRINT(\"info\", (\"Adding scan on %s\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4936,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(NULL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4938,
          "old_api": "bitmap_union",
          "new_api": null,
          "old_text": "bitmap_union(covered_fields, &(*ror_scan_mark)->covered_fields)",
          "new_text": null,
          "old_line_content": "    bitmap_union(covered_fields, &(*ror_scan_mark)->covered_fields);",
          "new_line_content": "                                             \"remaining scans\",",
          "content_same": false
        },
        {
          "line": 4939,
          "old_api": "bitmap_is_subset",
          "new_api": null,
          "old_text": "bitmap_is_subset(&param->needed_fields, covered_fields)",
          "new_text": null,
          "old_line_content": "    all_covered= bitmap_is_subset(&param->needed_fields, covered_fields);",
          "new_line_content": "                                             ror_scan_mark, ror_scans_end););",
          "content_same": false
        },
        {
          "line": 6986,
          "old_api": "copy_min",
          "new_api": null,
          "old_text": "last->copy_min(first)",
          "new_text": null,
          "old_line_content": "        last->copy_min(first);",
          "new_line_content": "          */",
          "content_same": false
        },
        {
          "line": 6987,
          "old_api": "copy_min",
          "new_api": null,
          "old_text": "last->copy_min(key2)",
          "new_text": null,
          "old_line_content": "        bool full_range= last->copy_min(key2);",
          "new_line_content": "\t  SEL_ARG *save=last;",
          "content_same": false
        },
        {
          "line": 2894,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"1:Mark subpartition %u as used\", start))",
          "new_text": null,
          "old_line_content": "    DBUG_PRINT(\"info\", (\"1:Mark subpartition %u as used\", start));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2895,
          "old_api": "bitmap_set_bit",
          "new_api": null,
          "old_text": "bitmap_set_bit(&part_info->used_partitions, start)",
          "new_text": null,
          "old_line_content": "    bitmap_set_bit(&part_info->used_partitions, start);",
          "new_line_content": "/* Mark a partition as used in the case when there are subpartitions */",
          "content_same": false
        },
        {
          "line": 4943,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "    records += (*ror_scan_mark)->records;",
          "content_same": false
        },
        {
          "line": 6990,
          "old_api": "cmp_max_to_min",
          "new_api": null,
          "old_text": "key2->cmp_max_to_min(last->next)",
          "new_text": null,
          "old_line_content": "          if (last->next && key2->cmp_max_to_min(last->next) >= 0)",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 9047,
          "old_api": "push_front",
          "new_api": null,
          "old_text": "rev_ranges.push_front(*pr)",
          "new_text": null,
          "old_line_content": "    rev_ranges.push_front(*pr);",
          "new_line_content": "  /* ",
          "content_same": false
        },
        {
          "line": 6999,
          "old_api": "copy_max",
          "new_api": null,
          "old_text": "last->copy_max(key2)",
          "new_text": null,
          "old_line_content": "            full_range= last->copy_max(key2);",
          "new_line_content": "        if (!full_range)",
          "content_same": false
        },
        {
          "line": 4955,
          "old_api": "rows2double",
          "new_api": null,
          "old_text": "rows2double(records)",
          "new_text": null,
          "old_line_content": "  total_cost += rows2double(records)*",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4956,
          "old_api": "log",
          "new_api": null,
          "old_text": "log((double)(ror_scan_mark - tree->ror_scans))",
          "new_text": null,
          "old_line_content": "                log((double)(ror_scan_mark - tree->ror_scans)) /",
          "new_line_content": "  /*",
          "content_same": false
        },
        {
          "line": 7003,
          "old_api": "free_tree",
          "new_api": null,
          "old_text": "key1->free_tree()",
          "new_text": null,
          "old_line_content": "\t  key1->free_tree();",
          "new_line_content": "            last->max_value= last->next->min_value;",
          "content_same": false
        },
        {
          "line": 4958,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"Covering ROR-intersect full cost: %g\", total_cost))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\", (\"Covering ROR-intersect full cost: %g\", total_cost));",
          "new_line_content": "    cost total_cost.",
          "content_same": false
        },
        {
          "line": 7005,
          "old_api": "increment_use_count",
          "new_api": null,
          "old_text": "key2->increment_use_count(-1)",
          "new_text": null,
          "old_line_content": "\t    key2->increment_use_count(-1);\t// Free not used tree",
          "new_line_content": "              last->max_flag&= ~NEAR_MAX;",
          "content_same": false
        },
        {
          "line": 9056,
          "old_api": "rewind",
          "new_api": null,
          "old_text": "rev_it.rewind()",
          "new_text": null,
          "old_line_content": "  rev_it.rewind();",
          "new_line_content": "  QUICK_RANGE **end_range= pr + ranges.elements;",
          "content_same": false
        },
        {
          "line": 11105,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::get_next\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::get_next\");",
          "new_line_content": "#ifdef HPUX11",
          "content_same": false
        },
        {
          "line": 4965,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(trp)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(trp);",
          "new_line_content": "  /* Add priority queue use cost. */",
          "content_same": false
        },
        {
          "line": 7013,
          "old_api": "cmp_min_to_min",
          "new_api": null,
          "old_text": "tmp->cmp_min_to_min(key2)",
          "new_text": null,
          "old_line_content": "    if (cmp >= 0 && tmp->cmp_min_to_min(key2) < 0)",
          "new_line_content": "\t{\t\t\t\t\t// Full range",
          "content_same": false
        },
        {
          "line": 9063,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"QUICK_SELECT_DESC::get_next\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"QUICK_SELECT_DESC::get_next\");",
          "new_line_content": "    if ((r->flag & EQ_RANGE) &&",
          "content_same": false
        },
        {
          "line": 7015,
          "old_api": "clone_first",
          "new_api": null,
          "old_text": "tmp->clone_first(key2)",
          "new_text": null,
          "old_line_content": "      SEL_ARG *new_arg=tmp->clone_first(key2);",
          "new_line_content": "\t  for (; key2 ; key2=key2->next)",
          "content_same": false
        },
        {
          "line": 11113,
          "old_api": "next_prefix",
          "new_api": null,
          "old_text": "next_prefix()",
          "new_text": null,
          "old_line_content": "    result= next_prefix();",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 4970,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4971,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(trp->first_scan, tree->ror_scans, best_num*sizeof(ROR_SCAN_INFO*))",
          "new_text": null,
          "old_line_content": "  memcpy(trp->first_scan, tree->ror_scans, best_num*sizeof(ROR_SCAN_INFO*));",
          "new_line_content": "  if (total_cost > read_time)",
          "content_same": false
        },
        {
          "line": 2924,
          "old_api": "bitmap_buffer_size",
          "new_api": null,
          "old_text": "bitmap_buffer_size(n_bits)",
          "new_text": null,
          "old_line_content": "  bitmap_bytes= bitmap_buffer_size(n_bits);",
          "new_line_content": "  RETURN ",
          "content_same": false
        },
        {
          "line": 2925,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(ppar->range_param.mem_root,\n                                                bitmap_bytes)",
          "new_text": null,
          "old_line_content": "  if (!(bitmap_buf= (my_bitmap_map*) alloc_root(ppar->range_param.mem_root,",
          "new_line_content": "    See find_used_partitions()",
          "content_same": false
        },
        {
          "line": 7019,
          "old_api": "increment_use_count",
          "new_api": null,
          "old_text": "new_arg->increment_use_count(key1->use_count+1)",
          "new_text": null,
          "old_line_content": "\tnew_arg->increment_use_count(key1->use_count+1);",
          "new_line_content": "\t  return 0;",
          "content_same": false
        },
        {
          "line": 7020,
          "old_api": "copy_min_to_min",
          "new_api": null,
          "old_text": "tmp->copy_min_to_min(key2)",
          "new_text": null,
          "old_line_content": "      tmp->copy_min_to_min(key2);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 11120,
          "old_api": "key_cmp",
          "new_api": null,
          "old_text": "key_cmp(index_info->key_part, last_prefix,\n                              group_prefix_len)",
          "new_text": null,
          "old_line_content": "      is_last_prefix= key_cmp(index_info->key_part, last_prefix,",
          "new_line_content": "    group is reached.",
          "content_same": false
        },
        {
          "line": 4977,
          "old_api": "set_if_smaller",
          "new_api": null,
          "old_text": "set_if_smaller(param->table->quick_condition_rows, records)",
          "new_text": null,
          "old_line_content": "  set_if_smaller(param->table->quick_condition_rows, records); ",
          "new_line_content": "  uint best_num= (ror_scan_mark - tree->ror_scans);",
          "content_same": false
        },
        {
          "line": 11122,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(is_last_prefix <= 0)",
          "new_text": null,
          "old_line_content": "      DBUG_ASSERT(is_last_prefix <= 0);",
          "new_line_content": "  do",
          "content_same": false
        },
        {
          "line": 4979,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\",\n             (\"Returning covering ROR-intersect plan: cost %g, records %lu\",\n              trp->read_cost, (ulong) trp->records))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\",",
          "new_line_content": "                                                     sizeof(ROR_SCAN_INFO*)*",
          "content_same": false
        },
        {
          "line": 2932,
          "old_api": "head",
          "new_api": null,
          "old_text": "merges.head()",
          "new_text": null,
          "old_line_content": "    return find_used_partitions_imerge(ppar, merges.head());",
          "new_line_content": "  uint bitmap_bytes;",
          "content_same": false
        },
        {
          "line": 7021,
          "old_api": "insert",
          "new_api": null,
          "old_text": "key1->insert(new_arg)",
          "new_text": null,
          "old_line_content": "      key1=key1->insert(new_arg);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2934,
          "old_api": "bitmap_init",
          "new_api": null,
          "old_text": "bitmap_init(&all_merges, bitmap_buf, n_bits, FALSE)",
          "new_text": null,
          "old_line_content": "  bitmap_init(&all_merges, bitmap_buf, n_bits, FALSE);",
          "new_line_content": "  uint n_bits= ppar->part_info->used_partitions.n_bits;",
          "content_same": false
        },
        {
          "line": 7028,
          "old_api": "cmp_min_to_min",
          "new_api": null,
          "old_text": "tmp->cmp_min_to_min(&key)",
          "new_text": null,
          "old_line_content": "      if (tmp->cmp_min_to_min(&key) > 0)",
          "new_line_content": "\treturn 0;\t\t\t\t// OOM",
          "content_same": false
        },
        {
          "line": 7034,
          "old_api": "increment_use_count",
          "new_api": null,
          "old_text": "new_arg->increment_use_count(key1->use_count+1)",
          "new_text": null,
          "old_line_content": "\t  new_arg->increment_use_count(key1->use_count+1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 9083,
          "old_api": "index_next_same",
          "new_api": null,
          "old_text": "file->index_next_same(record, last_range->min_key,\n                                      last_range->min_length)",
          "new_text": null,
          "old_line_content": "                file->index_next_same(record, last_range->min_key,",
          "new_line_content": "   *   - otherwise (not NEAR_MAX == include the key), go after the key,",
          "content_same": false
        },
        {
          "line": 7035,
          "old_api": "insert",
          "new_api": null,
          "old_text": "key1->insert(new_arg)",
          "new_text": null,
          "old_line_content": "\tkey1=key1->insert(new_arg);",
          "new_line_content": "    // tmp.min >= key2.min && tmp.min <= key2.max",
          "content_same": false
        },
        {
          "line": 9085,
          "old_api": "index_prev",
          "new_api": null,
          "old_text": "file->index_prev(record)",
          "new_text": null,
          "old_line_content": "                file->index_prev(record));",
          "new_line_content": "   */",
          "content_same": false
        },
        {
          "line": 2941,
          "old_api": "find_used_partitions_imerge",
          "new_api": null,
          "old_text": "find_used_partitions_imerge(ppar, imerge)",
          "new_text": null,
          "old_line_content": "    int res= find_used_partitions_imerge(ppar, imerge);",
          "new_line_content": "      partitions marked as used then actually needed.",
          "content_same": false
        },
        {
          "line": 11135,
          "old_api": "update_min_result",
          "new_api": null,
          "old_text": "update_min_result()",
          "new_text": null,
          "old_line_content": "        update_min_result();",
          "new_line_content": "    else ",
          "content_same": false
        },
        {
          "line": 9088,
          "old_api": "ref",
          "new_api": null,
          "old_text": "rev_it.ref()",
          "new_text": null,
          "old_line_content": "\tif (cmp_prev(*rev_it.ref()) == 0)",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 9089,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "\t  DBUG_RETURN(0);",
          "new_line_content": "    int result;",
          "content_same": false
        },
        {
          "line": 7037,
          "old_api": "cmp_max_to_max",
          "new_api": null,
          "old_text": "tmp->cmp_max_to_max(&key)",
          "new_text": null,
          "old_line_content": "      if ((cmp=tmp->cmp_max_to_max(&key)) <= 0)",
          "new_line_content": "    for (;;)",
          "content_same": false
        },
        {
          "line": 7040,
          "old_api": "increment_use_count",
          "new_api": null,
          "old_text": "key.increment_use_count(key1->use_count+1)",
          "new_text": null,
          "old_line_content": "\tkey.increment_use_count(key1->use_count+1);",
          "new_line_content": "      {\t\t\t\t\t\t// key.min <= x < tmp.min",
          "content_same": false
        },
        {
          "line": 9092,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(result)",
          "new_text": null,
          "old_line_content": "\tDBUG_RETURN(result);",
          "new_line_content": "      result = ((last_range->flag & EQ_RANGE && ",
          "content_same": false
        },
        {
          "line": 2949,
          "old_api": "bitmap_intersect",
          "new_api": null,
          "old_text": "bitmap_intersect(&all_merges, &ppar->part_info->used_partitions)",
          "new_text": null,
          "old_line_content": "      bitmap_intersect(&all_merges, &ppar->part_info->used_partitions);",
          "new_line_content": "  SEL_IMERGE *imerge;",
          "content_same": false
        },
        {
          "line": 11141,
          "old_api": "next_max",
          "new_api": null,
          "old_text": "next_max()",
          "new_text": null,
          "old_line_content": "      max_res= next_max();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2951,
          "old_api": "bitmap_is_clear_all",
          "new_api": null,
          "old_text": "bitmap_is_clear_all(&all_merges)",
          "new_text": null,
          "old_line_content": "    if (bitmap_is_clear_all(&all_merges))",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 11143,
          "old_api": "update_max_result",
          "new_api": null,
          "old_text": "update_max_result()",
          "new_text": null,
          "old_line_content": "        update_max_result();",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 11145,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT((have_max && !have_min) ||\n                  (have_max && have_min && (max_res == 0)))",
          "new_text": null,
          "old_line_content": "      DBUG_ASSERT((have_max && !have_min) ||",
          "new_line_content": "      if (min_res == 0)",
          "content_same": false
        },
        {
          "line": 2954,
          "old_api": "bitmap_clear_all",
          "new_api": null,
          "old_text": "bitmap_clear_all(&ppar->part_info->used_partitions)",
          "new_text": null,
          "old_line_content": "    bitmap_clear_all(&ppar->part_info->used_partitions);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 7044,
          "old_api": "copy_max_to_min",
          "new_api": null,
          "old_text": "key.copy_max_to_min(tmp)",
          "new_text": null,
          "old_line_content": "\tkey.copy_max_to_min(tmp);",
          "new_line_content": "\tif ((new_arg->next_key_part=key.next_key_part))",
          "content_same": false
        },
        {
          "line": 2956,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(ppar->part_info->used_partitions.bitmap, all_merges.bitmap,\n         bitmap_bytes)",
          "new_text": null,
          "old_line_content": "  memcpy(ppar->part_info->used_partitions.bitmap, all_merges.bitmap,",
          "new_line_content": "      return 0;",
          "content_same": false
        },
        {
          "line": 9101,
          "old_api": "index_last",
          "new_api": null,
          "old_text": "file->index_last(record)",
          "new_text": null,
          "old_line_content": "      if ((local_error=file->index_last(record)))",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 9102,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(local_error)",
          "new_text": null,
          "old_line_content": "\tDBUG_RETURN(local_error);\t\t// Empty table",
          "new_line_content": "      else if (result != HA_ERR_END_OF_FILE)",
          "content_same": false
        },
        {
          "line": 7050,
          "old_api": "insert",
          "new_api": null,
          "old_text": "key1->insert(tmp2)",
          "new_text": null,
          "old_line_content": "\t  key1=key1->insert(tmp2);",
          "new_line_content": "\ttmp->maybe_flag|= key.maybe_flag;",
          "content_same": false
        },
        {
          "line": 9104,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "\tDBUG_RETURN(0);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 7054,
          "old_api": "cmp_min_to_max",
          "new_api": null,
          "old_text": "tmp->cmp_min_to_max(&key)",
          "new_text": null,
          "old_line_content": "\tif (tmp->cmp_min_to_max(&key) > 0)",
          "new_line_content": "\t  break;",
          "content_same": false
        },
        {
          "line": 5010,
          "old_api": "primary_key_is_clustered",
          "new_api": null,
          "old_text": "param->table->file->primary_key_is_clustered()",
          "new_text": null,
          "old_line_content": "  bool pk_is_clustered= param->table->file->primary_key_is_clustered();",
          "new_line_content": "*/",
          "content_same": false
        },
        {
          "line": 11155,
          "old_api": "make_prev_keypart_map",
          "new_api": null,
          "old_text": "make_prev_keypart_map(real_key_parts)",
          "new_text": null,
          "old_line_content": "                                   make_prev_keypart_map(real_key_parts),",
          "new_line_content": "      /* If a MIN was found, a MAX must have been found as well. */",
          "content_same": false
        },
        {
          "line": 5011,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"get_key_scans_params\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"get_key_scans_params\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7059,
          "old_api": "insert",
          "new_api": null,
          "old_text": "key1->insert(tmp2)",
          "new_text": null,
          "old_line_content": "\t  key1=key1->insert(tmp2);",
          "new_line_content": "\t  if (!tmp2)",
          "content_same": false
        },
        {
          "line": 5017,
          "old_api": "print_sel_tree",
          "new_api": null,
          "old_text": "print_sel_tree(param, tree, &tree->keys_map,\n                                      \"tree scans\")",
          "new_text": null,
          "old_line_content": "  DBUG_EXECUTE(\"info\", print_sel_tree(param, tree, &tree->keys_map,",
          "new_line_content": "  int idx;",
          "content_same": false
        },
        {
          "line": 5019,
          "old_api": "clear_all",
          "new_api": null,
          "old_text": "tree->ror_scans_map.clear_all()",
          "new_text": null,
          "old_line_content": "  tree->ror_scans_map.clear_all();",
          "new_line_content": "  ha_rows UNINIT_VAR(best_records);              /* protected by key_to_read */",
          "content_same": false
        },
        {
          "line": 7068,
          "old_api": "copy_max_to_min",
          "new_api": null,
          "old_text": "tmp->copy_max_to_min(&key)",
          "new_text": null,
          "old_line_content": "\ttmp->copy_max_to_min(&key);",
          "new_line_content": "\t  if (!tmp2)",
          "content_same": false
        },
        {
          "line": 7069,
          "old_api": "increment_use_count",
          "new_api": null,
          "old_text": "tmp->increment_use_count(key1->use_count+1)",
          "new_text": null,
          "old_line_content": "\ttmp->increment_use_count(key1->use_count+1);",
          "new_line_content": "\t    return 0;\t\t\t\t// OOM",
          "content_same": false
        },
        {
          "line": 9119,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(last_range->flag & NEAR_MAX ||\n                  (last_range->flag & EQ_RANGE && \n                   used_key_parts > head->key_info[index].key_parts) ||\n                  range_reads_after_key(last_range))",
          "new_text": null,
          "old_line_content": "      DBUG_ASSERT(last_range->flag & NEAR_MAX ||",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7071,
          "old_api": "increment_use_count",
          "new_api": null,
          "old_text": "key.increment_use_count(1)",
          "new_text": null,
          "old_line_content": "\tkey.increment_use_count(1);",
          "new_line_content": "\t  break;",
          "content_same": false
        },
        {
          "line": 7072,
          "old_api": "key_or",
          "new_api": null,
          "old_text": "key_or(param, tmp->next_key_part, key.next_key_part)",
          "new_text": null,
          "old_line_content": "\tnew_arg->next_key_part= key_or(param, tmp->next_key_part, key.next_key_part);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 9122,
          "old_api": "range_reads_after_key",
          "new_api": null,
          "old_text": "range_reads_after_key(last_range)",
          "new_text": null,
          "old_line_content": "                  range_reads_after_key(last_range));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 9123,
          "old_api": "index_read_map",
          "new_api": null,
          "old_text": "file->index_read_map(record, last_range->max_key,\n                                  last_range->max_keypart_map,\n                                  ((last_range->flag & NEAR_MAX) ?\n                                   HA_READ_BEFORE_KEY :\n                                   HA_READ_PREFIX_LAST_OR_PREV))",
          "new_text": null,
          "old_line_content": "      result=file->index_read_map(record, last_range->max_key,",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 7073,
          "old_api": "insert",
          "new_api": null,
          "old_text": "key1->insert(new_arg)",
          "new_text": null,
          "old_line_content": "\tkey1=key1->insert(new_arg);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 5032,
          "old_api": "set_bit",
          "new_api": null,
          "old_text": "param->needed_reg->set_bit(keynr)",
          "new_text": null,
          "old_line_content": "        param->needed_reg->set_bit(keynr);",
          "new_line_content": "  for (idx= 0,key=tree->keys, end=key+param->keys;",
          "content_same": false
        },
        {
          "line": 5035,
          "old_api": "is_set",
          "new_api": null,
          "old_text": "param->table->covering_keys.is_set(keynr)",
          "new_text": null,
          "old_line_content": "                            (bool) param->table->covering_keys.is_set(keynr);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 9132,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(result)",
          "new_text": null,
          "old_line_content": "\tDBUG_RETURN(result);",
          "new_line_content": "                   used_key_parts > head->key_info[index].key_parts) ||",
          "content_same": false
        },
        {
          "line": 5037,
          "old_api": "check_quick_select",
          "new_api": null,
          "old_text": "check_quick_select(param, idx, *key, update_tbl_stats)",
          "new_text": null,
          "old_line_content": "      found_records= check_quick_select(param, idx, *key, update_tbl_stats);",
          "new_line_content": "    double found_read_time;",
          "content_same": false
        },
        {
          "line": 9136,
          "old_api": "cmp_prev",
          "new_api": null,
          "old_text": "cmp_prev(last_range)",
          "new_text": null,
          "old_line_content": "    if (cmp_prev(last_range) == 0)",
          "new_line_content": "                                  ((last_range->flag & NEAR_MAX) ?",
          "content_same": false
        },
        {
          "line": 2992,
          "old_api": "init_all_partitions_iterator",
          "new_api": null,
          "old_text": "init_all_partitions_iterator(ppar->part_info, &ppar->part_iter)",
          "new_text": null,
          "old_line_content": "    init_all_partitions_iterator(ppar->part_info, &ppar->part_iter);",
          "new_line_content": "  int res= 0;",
          "content_same": false
        },
        {
          "line": 2994,
          "old_api": "find_used_partitions",
          "new_api": null,
          "old_text": "find_used_partitions(ppar, key_tree)",
          "new_text": null,
          "old_line_content": "    if (!key_tree || (-1 == (res |= find_used_partitions(ppar, key_tree))))",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 5041,
          "old_api": "set_bit",
          "new_api": null,
          "old_text": "tree->ror_scans_map.set_bit(idx)",
          "new_text": null,
          "old_line_content": "        tree->ror_scans_map.set_bit(idx);",
          "new_line_content": "      if ((*key)->type == SEL_ARG::MAYBE_KEY ||",
          "content_same": false
        },
        {
          "line": 9140,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(0);\t\t\t\t// Found key is in range",
          "new_line_content": "    if (result)",
          "content_same": false
        },
        {
          "line": 7089,
          "old_api": "increment_use_count",
          "new_api": null,
          "old_text": "key2->increment_use_count(key1->use_count+1)",
          "new_text": null,
          "old_line_content": "      key2->increment_use_count(key1->use_count+1);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 7090,
          "old_api": "insert",
          "new_api": null,
          "old_text": "key1->insert(tmp)",
          "new_text": null,
          "old_line_content": "      key1=key1->insert(tmp);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7093,
          "old_api": "insert",
          "new_api": null,
          "old_text": "key1->insert(key2)",
          "new_text": null,
          "old_line_content": "      key1=key1->insert(key2);\t\t\t// Will destroy key2_root",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 11195,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::next_min\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::next_min\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5054,
          "old_api": "get_index_only_read_time",
          "new_api": null,
          "old_text": "get_index_only_read_time(param,found_records,keynr)",
          "new_text": null,
          "old_line_content": "        found_read_time= get_index_only_read_time(param,found_records,keynr) +",
          "new_line_content": "      double cpu_cost= (double) found_records / TIME_FOR_COMPARE;",
          "content_same": false
        },
        {
          "line": 11200,
          "old_api": "next_min_in_range",
          "new_api": null,
          "old_text": "next_min_in_range()",
          "new_text": null,
          "old_line_content": "    if ((result= next_min_in_range()))",
          "new_line_content": "    other                if some error occurred",
          "content_same": false
        },
        {
          "line": 11201,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(result)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(result);",
          "new_line_content": "*/",
          "content_same": false
        },
        {
          "line": 7107,
          "old_api": "is_same",
          "new_api": null,
          "old_text": "a->is_same(b)",
          "new_text": null,
          "old_line_content": "  if (!a || !b || !a->is_same(b))",
          "new_line_content": "  key1->use_count++;",
          "content_same": false
        },
        {
          "line": 5063,
          "old_api": "read_time",
          "new_api": null,
          "old_text": "param->table->file->read_time(keynr,\n                                                       param->range_count,\n                                                       found_records)",
          "new_text": null,
          "old_line_content": "\tfound_read_time= param->table->file->read_time(keynr,",
          "new_line_content": "          0.01 is added to avoid races between range and 'index' scan.",
          "content_same": false
        },
        {
          "line": 11208,
          "old_api": "index_read_map",
          "new_api": null,
          "old_text": "file->index_read_map(record, group_prefix,\n                                        make_prev_keypart_map(real_key_parts),\n                                        HA_READ_KEY_EXACT)",
          "new_text": null,
          "old_line_content": "      if ((result= file->index_read_map(record, group_prefix,",
          "new_line_content": "  /* Find the MIN key using the eventually extended group prefix. */",
          "content_same": false
        },
        {
          "line": 11209,
          "old_api": "make_prev_keypart_map",
          "new_api": null,
          "old_text": "make_prev_keypart_map(real_key_parts)",
          "new_text": null,
          "old_line_content": "                                        make_prev_keypart_map(real_key_parts),",
          "new_line_content": "  if (min_max_ranges.elements > 0)",
          "content_same": false
        },
        {
          "line": 7111,
          "old_api": "eq_tree",
          "new_api": null,
          "old_text": "eq_tree(a->left,b->left)",
          "new_text": null,
          "old_line_content": "    if (!eq_tree(a->left,b->left))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5068,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\",(\"key %s: found_read_time: %g (cur. read_time: %g)\",\n                         param->table->key_info[keynr].name, found_read_time,\n                         read_time))",
          "new_text": null,
          "old_line_content": "      DBUG_PRINT(\"info\",(\"key %s: found_read_time: %g (cur. read_time: %g)\",",
          "new_line_content": "      else",
          "content_same": false
        },
        {
          "line": 11221,
          "old_api": "is_null",
          "new_api": null,
          "old_text": "min_max_arg_part->field->is_null()",
          "new_text": null,
          "old_line_content": "    if (min_max_arg_part && min_max_arg_part->field->is_null())",
          "new_line_content": "                                        HA_READ_KEY_EXACT)))",
          "content_same": false
        },
        {
          "line": 7126,
          "old_api": "eq_tree",
          "new_api": null,
          "old_text": "eq_tree(a->next_key_part, b->next_key_part)",
          "new_text": null,
          "old_line_content": "\t!eq_tree(a->next_key_part, b->next_key_part))",
          "new_line_content": "    return 0;",
          "content_same": false
        },
        {
          "line": 11226,
          "old_api": "key_copy",
          "new_api": null,
          "old_text": "key_copy(key_buf, record, index_info, 0)",
          "new_text": null,
          "old_line_content": "      key_copy(key_buf, record, index_info, 0);",
          "new_line_content": "      If the min/max argument field is NULL, skip subsequent rows in the same",
          "content_same": false
        },
        {
          "line": 11227,
          "old_api": "index_read_map",
          "new_api": null,
          "old_text": "file->index_read_map(record, key_buf,\n                                   make_keypart_map(real_key_parts),\n                                   HA_READ_AFTER_KEY)",
          "new_text": null,
          "old_line_content": "      result= file->index_read_map(record, key_buf,",
          "new_line_content": "      group with NULL in it. Notice that:",
          "content_same": false
        },
        {
          "line": 11228,
          "old_api": "make_keypart_map",
          "new_api": null,
          "old_text": "make_keypart_map(real_key_parts)",
          "new_text": null,
          "old_line_content": "                                   make_keypart_map(real_key_parts),",
          "new_line_content": "      - if the first row in a group doesn't have a NULL in the field, no row",
          "content_same": false
        },
        {
          "line": 5082,
          "old_api": "print_sel_tree",
          "new_api": null,
          "old_text": "print_sel_tree(param, tree, &tree->ror_scans_map,\n                                      \"ROR scans\")",
          "new_text": null,
          "old_line_content": "  DBUG_EXECUTE(\"info\", print_sel_tree(param, tree, &tree->ror_scans_map,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5090,
          "old_api": "is_set",
          "new_api": null,
          "old_text": "tree->ror_scans_map.is_set(idx)",
          "new_text": null,
          "old_line_content": "      read_plan->is_ror= tree->ror_scans_map.is_set(idx);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 5092,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\",\n                 (\"Returning range plan for key %s, cost %g, records %lu\",\n                  param->table->key_info[param->real_keynr[idx]].name,\n                  read_plan->read_cost, (ulong) read_plan->records))",
          "new_text": null,
          "old_line_content": "      DBUG_PRINT(\"info\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7141,
          "old_api": "cmp_min_to_min",
          "new_api": null,
          "old_text": "key->cmp_min_to_min(element)",
          "new_text": null,
          "old_line_content": "    if (key->cmp_min_to_min(element) > 0)",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 9191,
          "old_api": "is_null",
          "new_api": null,
          "old_text": "key_part->field->is_null()",
          "new_text": null,
          "old_line_content": "        if (!key_part->field->is_null())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 11242,
          "old_api": "key_cmp",
          "new_api": null,
          "old_text": "key_cmp(index_info->key_part, group_prefix, real_prefix_len)",
          "new_text": null,
          "old_line_content": "        if (key_cmp(index_info->key_part, group_prefix, real_prefix_len))",
          "new_line_content": "        Check if the new record belongs to the current group by comparing its",
          "content_same": false
        },
        {
          "line": 9195,
          "old_api": "is_null",
          "new_api": null,
          "old_text": "key_part->field->is_null()",
          "new_text": null,
          "old_line_content": "      else if (key_part->field->is_null())",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 11243,
          "old_api": "key_restore",
          "new_api": null,
          "old_text": "key_restore(record, key_buf, index_info, 0)",
          "new_text": null,
          "old_line_content": "          key_restore(record, key_buf, index_info, 0);",
          "new_line_content": "        prefix with the group's prefix. If it is from the next group, then the",
          "content_same": false
        },
        {
          "line": 5099,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"No 'range' table read plan found\"))",
          "new_text": null,
          "old_line_content": "    DBUG_PRINT(\"info\", (\"No 'range' table read plan found\"));",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 9200,
          "old_api": "key_cmp",
          "new_api": null,
          "old_text": "key_part->field->key_cmp(key, key_part->length)",
          "new_text": null,
          "old_line_content": "    if ((cmp=key_part->field->key_cmp(key, key_part->length)) < 0)",
          "new_line_content": "      if (*key)",
          "content_same": false
        },
        {
          "line": 7168,
          "old_api": "rb_insert",
          "new_api": null,
          "old_text": "rb_insert(key)",
          "new_text": null,
          "old_line_content": "  SEL_ARG *root=rb_insert(key);\t\t\t// rebalance tree",
          "new_line_content": "      key->prev->next=key;",
          "content_same": false
        },
        {
          "line": 5121,
          "old_api": "make_quick",
          "new_api": null,
          "old_text": "*range_scan)->make_quick(param, FALSE, &quick_imerge->alloc)",
          "new_text": null,
          "old_line_content": "          ((*range_scan)->make_quick(param, FALSE, &quick_imerge->alloc)))||",
          "new_line_content": "  QUICK_RANGE_SELECT *quick;",
          "content_same": false
        },
        {
          "line": 5122,
          "old_api": "push_quick_back",
          "new_api": null,
          "old_text": "quick_imerge->push_quick_back(quick)",
          "new_text": null,
          "old_line_content": "        quick_imerge->push_quick_back(quick))",
          "new_line_content": "  /* index_merge always retrieves full rows, ignore retrieve_full_rows */",
          "content_same": false
        },
        {
          "line": 9219,
          "old_api": "key_cmp",
          "new_api": null,
          "old_text": "key_cmp(key_part_info, range_arg->min_key,\n               range_arg->min_length)",
          "new_text": null,
          "old_line_content": "  cmp= key_cmp(key_part_info, range_arg->min_key,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 11278,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::next_max\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::next_max\");",
          "new_line_content": "  RETURN",
          "content_same": false
        },
        {
          "line": 11282,
          "old_api": "next_max_in_range",
          "new_api": null,
          "old_text": "next_max_in_range()",
          "new_text": null,
          "old_line_content": "    result= next_max_in_range();",
          "new_line_content": "    other                if some error occurred",
          "content_same": false
        },
        {
          "line": 5138,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"TRP_ROR_INTERSECT::make_quick\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"TRP_ROR_INTERSECT::make_quick\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 11284,
          "old_api": "index_read_map",
          "new_api": null,
          "old_text": "file->index_read_map(record, group_prefix,\n                                 make_prev_keypart_map(real_key_parts),\n                                 HA_READ_PREFIX_LAST)",
          "new_text": null,
          "old_line_content": "    result= file->index_read_map(record, group_prefix,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 11285,
          "old_api": "make_prev_keypart_map",
          "new_api": null,
          "old_text": "make_prev_keypart_map(real_key_parts)",
          "new_text": null,
          "old_line_content": "                                 make_prev_keypart_map(real_key_parts),",
          "new_line_content": "int QUICK_GROUP_MIN_MAX_SELECT::next_max()",
          "content_same": false
        },
        {
          "line": 7190,
          "old_api": "cmp_min_to_min",
          "new_api": null,
          "old_text": "element->cmp_min_to_min(key)",
          "new_text": null,
          "old_line_content": "    int cmp=element->cmp_min_to_min(key);",
          "new_line_content": "*/",
          "content_same": false
        },
        {
          "line": 11287,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(result)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(result);",
          "new_line_content": "  int result;",
          "content_same": false
        },
        {
          "line": 9243,
          "old_api": "append",
          "new_api": null,
          "old_text": "str->append(key_info->name)",
          "new_text": null,
          "old_line_content": "  str->append(key_info->name);",
          "new_line_content": "bool QUICK_SELECT_DESC::range_reads_after_key(QUICK_RANGE *range_arg)",
          "content_same": false
        },
        {
          "line": 5147,
          "old_api": "print_ror_scans_arr",
          "new_api": null,
          "old_text": "print_ror_scans_arr(param->table,\n                                             \"creating ROR-intersect\",\n                                             first_scan, last_scan)",
          "new_text": null,
          "old_line_content": "    DBUG_EXECUTE(\"info\", print_ror_scans_arr(param->table,",
          "new_line_content": "  QUICK_ROR_INTERSECT_SELECT *quick_intrsect;",
          "content_same": false
        },
        {
          "line": 5153,
          "old_api": "get_quick_select",
          "new_api": null,
          "old_text": "get_quick_select(param, (*first_scan)->idx,\n                                    (*first_scan)->sel_arg, alloc)",
          "new_text": null,
          "old_line_content": "      if (!(quick= get_quick_select(param, (*first_scan)->idx,",
          "new_line_content": "         new QUICK_ROR_INTERSECT_SELECT(param->thd, param->table,",
          "content_same": false
        },
        {
          "line": 9251,
          "old_api": "STRING_WITH_LEN",
          "new_api": null,
          "old_text": "STRING_WITH_LEN(\"sort_union(\")",
          "new_text": null,
          "old_line_content": "  str->append(STRING_WITH_LEN(\"sort_union(\"));",
          "new_line_content": "void QUICK_RANGE_SELECT::add_info_string(String *str)",
          "content_same": false
        },
        {
          "line": 5155,
          "old_api": "push_quick_back",
          "new_api": null,
          "old_text": "quick_intrsect->push_quick_back(quick)",
          "new_text": null,
          "old_line_content": "          quick_intrsect->push_quick_back(quick))",
          "new_line_content": "                                         FALSE),",
          "content_same": false
        },
        {
          "line": 9255,
          "old_api": "append",
          "new_api": null,
          "old_text": "str->append(',')",
          "new_text": null,
          "old_line_content": "      str->append(',');",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 9258,
          "old_api": "add_info_string",
          "new_api": null,
          "old_text": "quick->add_info_string(str)",
          "new_text": null,
          "old_line_content": "    quick->add_info_string(str);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 5163,
          "old_api": "get_quick_select",
          "new_api": null,
          "old_text": "get_quick_select(param, cpk_scan->idx,\n                                    cpk_scan->sel_arg, alloc)",
          "new_text": null,
          "old_line_content": "      if (!(quick= get_quick_select(param, cpk_scan->idx,",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 9263,
          "old_api": "add_info_string",
          "new_api": null,
          "old_text": "pk_quick_select->add_info_string(str)",
          "new_text": null,
          "old_line_content": "    pk_quick_select->add_info_string(str);",
          "new_line_content": "  while ((quick= it++))",
          "content_same": false
        },
        {
          "line": 5167,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "        DBUG_RETURN(NULL);",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 9265,
          "old_api": "append",
          "new_api": null,
          "old_text": "str->append(')')",
          "new_text": null,
          "old_line_content": "  str->append(')');",
          "new_line_content": "    if (!first)",
          "content_same": false
        },
        {
          "line": 3121,
          "old_api": "check_stack_overrun",
          "new_api": null,
          "old_text": "check_stack_overrun(range_par->thd, 3*STACK_MIN_SIZE, NULL)",
          "new_text": null,
          "old_line_content": "  if (check_stack_overrun(range_par->thd, 3*STACK_MIN_SIZE, NULL))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3126,
          "old_api": "find_used_partitions",
          "new_api": null,
          "old_text": "find_used_partitions(ppar,key_tree->left)",
          "new_text": null,
          "old_line_content": "    if (-1 == (left_res= find_used_partitions(ppar,key_tree->left)))",
          "new_line_content": "  int key_tree_part= (int)key_tree->part;",
          "content_same": false
        },
        {
          "line": 5175,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(quick_intrsect)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(quick_intrsect);",
          "new_line_content": "                                    cpk_scan->sel_arg, alloc)))",
          "content_same": false
        },
        {
          "line": 7223,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"tree_delete\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"tree_delete\");",
          "new_line_content": "    This also frees all sub trees that is used by the element",
          "content_same": false
        },
        {
          "line": 9278,
          "old_api": "append",
          "new_api": null,
          "old_text": "str->append(',')",
          "new_text": null,
          "old_line_content": "      str->append(',');",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 11326,
          "old_api": "key_cmp (key_part, group_prefix, group_prefix_len)",
          "new_api": null,
          "old_text": "key_cmp (key_part, group_prefix, group_prefix_len)",
          "new_text": null,
          "old_line_content": "    while (!key_cmp (key_part, group_prefix, group_prefix_len))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 11328,
          "old_api": "index_next",
          "new_api": null,
          "old_text": "file->index_next(record)",
          "new_text": null,
          "old_line_content": "      result= file->index_next(record);",
          "new_line_content": "                                KEY_PART_INFO *key_part, uchar * record, ",
          "content_same": false
        },
        {
          "line": 9281,
          "old_api": "append",
          "new_api": null,
          "old_text": "str->append(key_info->name)",
          "new_text": null,
          "old_line_content": "    str->append(key_info->name);",
          "new_line_content": "  bool first= TRUE;",
          "content_same": false
        },
        {
          "line": 7233,
          "old_api": "increment_use_count",
          "new_api": null,
          "old_text": "key->increment_use_count(-1)",
          "new_text": null,
          "old_line_content": "  key->increment_use_count(-1);",
          "new_line_content": "  SEL_ARG *root,*nod,**par,*fix_par;",
          "content_same": false
        },
        {
          "line": 7237,
          "old_api": "parent_ptr",
          "new_api": null,
          "old_text": "key->parent_ptr()",
          "new_text": null,
          "old_line_content": "    par=key->parent_ptr();",
          "new_line_content": "  this->parent= 0;",
          "content_same": false
        },
        {
          "line": 9286,
          "old_api": "append",
          "new_api": null,
          "old_text": "str->append(',')",
          "new_text": null,
          "old_line_content": "    str->append(',');",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 9287,
          "old_api": "append",
          "new_api": null,
          "old_text": "str->append(key_info->name)",
          "new_text": null,
          "old_line_content": "    str->append(key_info->name);",
          "new_line_content": "    KEY *key_info= head->key_info + quick->index;",
          "content_same": false
        },
        {
          "line": 11335,
          "old_api": "index_read_map",
          "new_api": null,
          "old_text": "file->index_read_map(record, group_prefix,\n                                make_prev_keypart_map(group_key_parts),\n                                HA_READ_AFTER_KEY)",
          "new_text": null,
          "old_line_content": "    return file->index_read_map(record, group_prefix,",
          "new_line_content": "    int result= 0;",
          "content_same": false
        },
        {
          "line": 11336,
          "old_api": "make_prev_keypart_map",
          "new_api": null,
          "old_text": "make_prev_keypart_map(group_key_parts)",
          "new_text": null,
          "old_line_content": "                                make_prev_keypart_map(group_key_parts),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3146,
          "old_api": "find_used_partitions",
          "new_api": null,
          "old_text": "find_used_partitions(ppar, key_tree->next_key_part)",
          "new_text": null,
          "old_line_content": "      res= find_used_partitions(ppar, key_tree->next_key_part);",
          "new_line_content": "  if (ignore_part_fields)",
          "content_same": false
        },
        {
          "line": 5195,
          "old_api": "make_quick",
          "new_api": null,
          "old_text": "*scan)->make_quick(param, FALSE, &quick_roru->alloc)",
          "new_text": null,
          "old_line_content": "      if (!(quick= (*scan)->make_quick(param, FALSE, &quick_roru->alloc)) ||",
          "new_line_content": "  TABLE_READ_PLAN **scan;",
          "content_same": false
        },
        {
          "line": 5196,
          "old_api": "push_quick_back",
          "new_api": null,
          "old_text": "quick_roru->push_quick_back(quick)",
          "new_text": null,
          "old_line_content": "          quick_roru->push_quick_back(quick))",
          "new_line_content": "  QUICK_SELECT_I *quick;",
          "content_same": false
        },
        {
          "line": 5202,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(quick_roru)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(quick_roru);",
          "new_line_content": "  if ((quick_roru= new QUICK_ROR_UNION_SELECT(param->thd, param->table)))",
          "content_same": false
        },
        {
          "line": 9301,
          "old_api": "append",
          "new_api": null,
          "old_text": "str->append(',')",
          "new_text": null,
          "old_line_content": "      str->append(',');",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 9304,
          "old_api": "add_info_string",
          "new_api": null,
          "old_text": "quick->add_info_string(str)",
          "new_text": null,
          "old_line_content": "    quick->add_info_string(str);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 7256,
          "old_api": "parent_ptr",
          "new_api": null,
          "old_text": "tmp->parent_ptr()",
          "new_text": null,
          "old_line_content": "    nod= *tmp->parent_ptr()= tmp->right;\t// unlink tmp from tree",
          "new_line_content": "    remove_color= key->color;",
          "content_same": false
        },
        {
          "line": 9306,
          "old_api": "append",
          "new_api": null,
          "old_text": "str->append(')')",
          "new_text": null,
          "old_line_content": "  str->append(')');",
          "new_line_content": "  QUICK_SELECT_I *quick;",
          "content_same": false
        },
        {
          "line": 3162,
          "old_api": "store_min",
          "new_api": null,
          "old_text": "key_tree->store_min(ppar->key[key_tree->part].store_length,\n                          &tmp_min_key, ppar->cur_min_flag)",
          "new_text": null,
          "old_line_content": "      key_tree->store_min(ppar->key[key_tree->part].store_length,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3164,
          "old_api": "store_max",
          "new_api": null,
          "old_text": "key_tree->store_max(ppar->key[key_tree->part].store_length,\n                          &tmp_max_key, ppar->cur_max_flag)",
          "new_text": null,
          "old_line_content": "      key_tree->store_max(ppar->key[key_tree->part].store_length,",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 9316,
          "old_api": "append",
          "new_api": null,
          "old_text": "key_names->append(key_info->name)",
          "new_text": null,
          "old_line_content": "  key_names->append(key_info->name);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 11365,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::next_prefix\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"QUICK_GROUP_MIN_MAX_SELECT::next_prefix\");",
          "new_line_content": "    this->record, on which relies this->next_min().",
          "content_same": false
        },
        {
          "line": 9318,
          "old_api": "append",
          "new_api": null,
          "old_text": "used_lengths->append(buf, length)",
          "new_text": null,
          "old_line_content": "  used_lengths->append(buf, length);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 7273,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(0);\t\t\t\t// Maybe root later",
          "new_line_content": "    tmp->parent=key->parent;\t\t\t// Move node in place of key",
          "content_same": false
        },
        {
          "line": 3178,
          "old_api": "uint)(tmp_max_key - max_key)",
          "new_api": null,
          "old_text": "uint)(tmp_max_key - max_key)",
          "new_text": null,
          "old_line_content": "            (memcmp(min_key, max_key, (uint)(tmp_max_key - max_key)) == 0) &&",
          "new_line_content": "      if (key_tree->next_key_part &&",
          "content_same": false
        },
        {
          "line": 11370,
          "old_api": "get_next_prefix",
          "new_api": null,
          "old_text": "quick_prefix_select->get_next_prefix(group_prefix_len,\n                                                      group_key_parts, \n                                                      cur_prefix)",
          "new_text": null,
          "old_line_content": "    if ((result= quick_prefix_select->get_next_prefix(group_prefix_len,",
          "new_line_content": "    HA_ERR_END_OF_FILE   if there are no more keys",
          "content_same": false
        },
        {
          "line": 7275,
          "old_api": "rb_delete_fixup",
          "new_api": null,
          "old_text": "rb_delete_fixup(root,nod,fix_par)",
          "new_text": null,
          "old_line_content": "    root=rb_delete_fixup(root,nod,fix_par);",
          "new_line_content": "    if ((tmp->right=key->right) != &null_element)",
          "content_same": false
        },
        {
          "line": 11373,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(result)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(result);",
          "new_line_content": "int QUICK_GROUP_MIN_MAX_SELECT::next_prefix()",
          "content_same": false
        },
        {
          "line": 5229,
          "old_api": "get_mm_parts",
          "new_api": null,
          "old_text": "get_mm_parts(param, cond_func, field, Item_func::LT_FUNC,\n                     lt_value, cmp_type)",
          "new_text": null,
          "old_line_content": "  tree= get_mm_parts(param, cond_func, field, Item_func::LT_FUNC,",
          "new_line_content": "  RETURN ",
          "content_same": false
        },
        {
          "line": 7276,
          "old_api": "test_rb_tree",
          "new_api": null,
          "old_text": "test_rb_tree(root,root->parent)",
          "new_text": null,
          "old_line_content": "  test_rb_tree(root,root->parent);",
          "new_line_content": "      tmp->right->parent=tmp;",
          "content_same": false
        },
        {
          "line": 5233,
          "old_api": "get_mm_parts",
          "new_api": null,
          "old_text": "get_mm_parts(param, cond_func, field,\n\t\t\t\t\t    Item_func::GT_FUNC,\n\t\t\t\t\t    gt_value, cmp_type)",
          "new_text": null,
          "old_line_content": "    tree= tree_or(param, tree, get_mm_parts(param, cond_func, field,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7281,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(root)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(root);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 11380,
          "old_api": "index_first",
          "new_api": null,
          "old_text": "file->index_first(record)",
          "new_text": null,
          "old_line_content": "      result= file->index_first(record);",
          "new_line_content": "    uchar *cur_prefix= seen_first_key ? group_prefix : NULL;",
          "content_same": false
        },
        {
          "line": 3190,
          "old_api": "find_used_partitions",
          "new_api": null,
          "old_text": "find_used_partitions(ppar, key_tree->next_key_part)",
          "new_text": null,
          "old_line_content": "          res= find_used_partitions(ppar, key_tree->next_key_part);",
          "new_line_content": "            !key_tree->min_flag && !key_tree->max_flag)",
          "content_same": false
        },
        {
          "line": 11382,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(result)",
          "new_text": null,
          "old_line_content": "        DBUG_RETURN(result);",
          "new_line_content": "                                                      group_key_parts, ",
          "content_same": false
        },
        {
          "line": 9336,
          "old_api": "append",
          "new_api": null,
          "old_text": "key_names->append(',')",
          "new_text": null,
          "old_line_content": "      key_names->append(',');",
          "new_line_content": "  uint length;",
          "content_same": false
        },
        {
          "line": 9337,
          "old_api": "append",
          "new_api": null,
          "old_text": "used_lengths->append(',')",
          "new_text": null,
          "old_line_content": "      used_lengths->append(',');",
          "new_line_content": "  bool first= TRUE;",
          "content_same": false
        },
        {
          "line": 11388,
          "old_api": "index_next_different (is_index_scan, file, index_info->key_part,\n                            record, group_prefix, group_prefix_len, \n                            group_key_parts)",
          "new_api": null,
          "old_text": "index_next_different (is_index_scan, file, index_info->key_part,\n                            record, group_prefix, group_prefix_len, \n                            group_key_parts)",
          "new_text": null,
          "old_line_content": "      result= index_next_different (is_index_scan, file, index_info->key_part,",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 9341,
          "old_api": "append",
          "new_api": null,
          "old_text": "key_names->append(key_info->name)",
          "new_text": null,
          "old_line_content": "    key_names->append(key_info->name);",
          "new_line_content": "  while ((quick= it++))",
          "content_same": false
        },
        {
          "line": 9342,
          "old_api": "longlong2str",
          "new_api": null,
          "old_text": "longlong2str(quick->max_used_key_length, buf, 10)",
          "new_text": null,
          "old_line_content": "    length= longlong2str(quick->max_used_key_length, buf, 10) - buf;",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 9343,
          "old_api": "append",
          "new_api": null,
          "old_text": "used_lengths->append(buf, length)",
          "new_text": null,
          "old_line_content": "    used_lengths->append(buf, length);",
          "new_line_content": "    if (first)",
          "content_same": false
        },
        {
          "line": 11392,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(result)",
          "new_text": null,
          "old_line_content": "        DBUG_RETURN(result);",
          "new_line_content": "      if (result)",
          "content_same": false
        },
        {
          "line": 7296,
          "old_api": "parent_ptr",
          "new_api": null,
          "old_text": "leaf->parent_ptr()",
          "new_text": null,
          "old_line_content": "    *leaf->parent_ptr()=y;",
          "new_line_content": "\t/* Functions to fix up the tree after insert and delete */",
          "content_same": false
        },
        {
          "line": 3204,
          "old_api": "store_min_key",
          "new_api": null,
          "old_text": "key_tree->next_key_part->store_min_key(ppar->key,\n                                                 &tmp_min_key,\n                                                 &tmp_min_flag,\n                                                 ppar->last_part_partno)",
          "new_text": null,
          "old_line_content": "          key_tree->next_key_part->store_min_key(ppar->key,",
          "new_line_content": "          ppar->cur_min_key= min_key;",
          "content_same": false
        },
        {
          "line": 9349,
          "old_api": "append",
          "new_api": null,
          "old_text": "key_names->append(key_info->name)",
          "new_text": null,
          "old_line_content": "    key_names->append(key_info->name);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 9350,
          "old_api": "longlong2str",
          "new_api": null,
          "old_text": "longlong2str(pk_quick_select->max_used_key_length, buf, 10)",
          "new_text": null,
          "old_line_content": "    length= longlong2str(pk_quick_select->max_used_key_length, buf, 10) - buf;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 9351,
          "old_api": "append",
          "new_api": null,
          "old_text": "used_lengths->append(',')",
          "new_text": null,
          "old_line_content": "    used_lengths->append(',');",
          "new_line_content": "    KEY *key_info= head->key_info + quick->index;",
          "content_same": false
        },
        {
          "line": 11397,
          "old_api": "key_copy",
          "new_api": null,
          "old_text": "key_copy(group_prefix, record, index_info, group_prefix_len)",
          "new_text": null,
          "old_line_content": "  key_copy(group_prefix, record, index_info, group_prefix_len);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 11400,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(group_prefix + group_prefix_len,\n           key_infix, key_infix_len)",
          "new_text": null,
          "old_line_content": "    memcpy(group_prefix + group_prefix_len,",
          "new_line_content": "                            record, group_prefix, group_prefix_len, ",
          "content_same": false
        },
        {
          "line": 3209,
          "old_api": "store_max_key",
          "new_api": null,
          "old_text": "key_tree->next_key_part->store_max_key(ppar->key,\n                                                 &tmp_max_key,\n                                                 &tmp_max_flag,\n                                                 ppar->last_part_partno)",
          "new_text": null,
          "old_line_content": "          key_tree->next_key_part->store_max_key(ppar->key,",
          "new_line_content": "          goto pop_and_go_right;",
          "content_same": false
        },
        {
          "line": 7310,
          "old_api": "parent_ptr",
          "new_api": null,
          "old_text": "leaf->parent_ptr()",
          "new_text": null,
          "old_line_content": "    *leaf->parent_ptr()=y;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 5263,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"get_func_mm_tree\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"get_func_mm_tree\");",
          "new_line_content": "                  (makes sense only when cond_func is BETWEEN or IN) ",
          "content_same": false
        },
        {
          "line": 5265,
          "old_api": "functype",
          "new_api": null,
          "old_text": "cond_func->functype()",
          "new_text": null,
          "old_line_content": "  switch (cond_func->functype()) {",
          "new_line_content": "  RETURN ",
          "content_same": false
        },
        {
          "line": 5268,
          "old_api": "get_ne_mm_tree",
          "new_api": null,
          "old_text": "get_ne_mm_tree(param, cond_func, field, value, value, cmp_type)",
          "new_text": null,
          "old_line_content": "    tree= get_ne_mm_tree(param, cond_func, field, value, value, cmp_type);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 9371,
          "old_api": "append",
          "new_api": null,
          "old_text": "key_names->append(',')",
          "new_text": null,
          "old_line_content": "      key_names->append(',');",
          "new_line_content": "  uint length;",
          "content_same": false
        },
        {
          "line": 9372,
          "old_api": "append",
          "new_api": null,
          "old_text": "used_lengths->append(',')",
          "new_text": null,
          "old_line_content": "      used_lengths->append(',');",
          "new_line_content": "  bool first= TRUE;",
          "content_same": false
        },
        {
          "line": 5277,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "cond_func->arguments()",
          "new_text": null,
          "old_line_content": "        tree= get_ne_mm_tree(param, cond_func, field, cond_func->arguments()[1],",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 9374,
          "old_api": "append",
          "new_api": null,
          "old_text": "key_names->append(key_info->name)",
          "new_text": null,
          "old_line_content": "    key_names->append(key_info->name);",
          "new_line_content": "  List_iterator_fast<QUICK_RANGE_SELECT> it(quick_selects);",
          "content_same": false
        },
        {
          "line": 9375,
          "old_api": "longlong2str",
          "new_api": null,
          "old_text": "longlong2str(quick->max_used_key_length, buf, 10)",
          "new_text": null,
          "old_line_content": "    length= longlong2str(quick->max_used_key_length, buf, 10) - buf;",
          "new_line_content": "  while ((quick= it++))",
          "content_same": false
        },
        {
          "line": 9376,
          "old_api": "append",
          "new_api": null,
          "old_text": "used_lengths->append(buf, length)",
          "new_text": null,
          "old_line_content": "    used_lengths->append(buf, length);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 5278,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "cond_func->arguments()",
          "new_text": null,
          "old_line_content": "                             cond_func->arguments()[2], cmp_type);",
          "new_line_content": "  case Item_func::NE_FUNC:",
          "content_same": false
        },
        {
          "line": 5282,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "get_mm_parts(param, cond_func, field, Item_func::GE_FUNC,\n\t\t           cond_func->arguments()[1],cmp_type)",
          "new_text": null,
          "old_line_content": "        tree= get_mm_parts(param, cond_func, field, Item_func::GE_FUNC,",
          "new_line_content": "  case Item_func::BETWEEN:",
          "content_same": false
        },
        {
          "line": 5283,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "cond_func->arguments()",
          "new_text": null,
          "old_line_content": "\t\t           cond_func->arguments()[1],cmp_type);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 5286,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "get_mm_parts(param, cond_func, field,\n\t\t\t\t\t           Item_func::LE_FUNC,\n\t\t\t\t\t           cond_func->arguments()[2],\n                                                   cmp_type)",
          "new_text": null,
          "old_line_content": "          tree= tree_and(param, tree, get_mm_parts(param, cond_func, field,",
          "new_line_content": "      if (inv)",
          "content_same": false
        },
        {
          "line": 9384,
          "old_api": "longlong2str",
          "new_api": null,
          "old_text": "longlong2str(cpk_quick->max_used_key_length, buf, 10)",
          "new_text": null,
          "old_line_content": "    length= longlong2str(cpk_quick->max_used_key_length, buf, 10) - buf;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 7339,
          "old_api": "left_rotate",
          "new_api": null,
          "old_text": "left_rotate(&root,leaf->parent)",
          "new_text": null,
          "old_line_content": "\t  left_rotate(&root,leaf->parent);",
          "new_line_content": "      if (y->color == RED)",
          "content_same": false
        },
        {
          "line": 11436,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(min_max_ranges.elements > 0)",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(min_max_ranges.elements > 0);",
          "new_line_content": "    other                if some error",
          "content_same": false
        },
        {
          "line": 3245,
          "old_api": "ppar->part_info->\n             get_part_iter_for_interval(ppar->part_info,\n                                        FALSE,\n                                        store_length_array,\n                                        range_par->min_key,\n                                        range_par->max_key,\n                                        tmp_min_key - range_par->min_key,\n                                        tmp_max_key - range_par->max_key,\n                                        flag,\n                                        &ppar->part_iter)",
          "new_api": null,
          "old_text": "ppar->part_info->\n             get_part_iter_for_interval(ppar->part_info,\n                                        FALSE,\n                                        store_length_array,\n                                        range_par->min_key,\n                                        range_par->max_key,\n                                        tmp_min_key - range_par->min_key,\n                                        tmp_max_key - range_par->max_key,\n                                        flag,\n                                        &ppar->part_iter)",
          "new_text": null,
          "old_line_content": "        res= ppar->part_info->",
          "new_line_content": "        simply set res= -1 as if the mapper had returned that.",
          "content_same": false
        },
        {
          "line": 11440,
          "old_api": "get_dynamic",
          "new_api": null,
          "old_text": "get_dynamic(&min_max_ranges, (uchar*)&cur_range, range_idx)",
          "new_text": null,
          "old_line_content": "    get_dynamic(&min_max_ranges, (uchar*)&cur_range, range_idx);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 7344,
          "old_api": "right_rotate",
          "new_api": null,
          "old_text": "right_rotate(&root,par2)",
          "new_text": null,
          "old_line_content": "\tright_rotate(&root,par2);",
          "new_line_content": "\tleaf->color=RED;\t\t/* And the loop continues */",
          "content_same": false
        },
        {
          "line": 5300,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "cond_func->arguments()",
          "new_text": null,
          "old_line_content": "                         cond_func->arguments()[0], cmp_type);",
          "new_line_content": "                                                   cmp_type));",
          "content_same": false
        },
        {
          "line": 9402,
          "old_api": "append",
          "new_api": null,
          "old_text": "used_lengths->append(',')",
          "new_text": null,
          "old_line_content": "      used_lengths->append(',');",
          "new_line_content": "                                                  String *used_lengths)",
          "content_same": false
        },
        {
          "line": 9403,
          "old_api": "append",
          "new_api": null,
          "old_text": "key_names->append(',')",
          "new_text": null,
          "old_line_content": "      key_names->append(',');",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 9405,
          "old_api": "add_keys_and_lengths",
          "new_api": null,
          "old_text": "quick->add_keys_and_lengths(key_names, used_lengths)",
          "new_text": null,
          "old_line_content": "    quick->add_keys_and_lengths(key_names, used_lengths);",
          "new_line_content": "  QUICK_SELECT_I *quick;",
          "content_same": false
        },
        {
          "line": 11453,
          "old_api": "make_prev_keypart_map",
          "new_api": null,
          "old_text": "make_prev_keypart_map(real_key_parts)",
          "new_text": null,
          "old_line_content": "      keypart_map= make_prev_keypart_map(real_key_parts);",
          "new_line_content": "    /*",
          "content_same": false
        },
        {
          "line": 3264,
          "old_api": "init_all_partitions_iterator",
          "new_api": null,
          "old_text": "init_all_partitions_iterator(ppar->part_info, &ppar->part_iter)",
          "new_text": null,
          "old_line_content": "        init_all_partitions_iterator(ppar->part_info, &ppar->part_iter);",
          "new_line_content": "                                        flag,",
          "content_same": false
        },
        {
          "line": 7362,
          "old_api": "right_rotate",
          "new_api": null,
          "old_text": "right_rotate(&root,par)",
          "new_text": null,
          "old_line_content": "\t  right_rotate(&root,par);",
          "new_line_content": "      if (y->color == RED)",
          "content_same": false
        },
        {
          "line": 11459,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(group_prefix + real_prefix_len, cur_range->min_key,\n             cur_range->min_length)",
          "new_text": null,
          "old_line_content": "      memcpy(group_prefix + real_prefix_len, cur_range->min_key,",
          "new_line_content": "                 min_max_arg_len) == 1))",
          "content_same": false
        },
        {
          "line": 11461,
          "old_api": "make_keypart_map",
          "new_api": null,
          "old_text": "make_keypart_map(real_key_parts)",
          "new_text": null,
          "old_line_content": "      keypart_map= make_keypart_map(real_key_parts);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5317,
          "old_api": "result_type",
          "new_api": null,
          "old_text": "func->array->result_type()",
          "new_text": null,
          "old_line_content": "      if (func->array && func->array->result_type() != ROW_RESULT)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7367,
          "old_api": "left_rotate",
          "new_api": null,
          "old_text": "left_rotate(&root,par2)",
          "new_text": null,
          "old_line_content": "\tleft_rotate(&root,par2);",
          "new_line_content": "\tleaf->color=RED;\t\t/* And the loop continues */",
          "content_same": false
        },
        {
          "line": 11467,
          "old_api": "index_read_map",
          "new_api": null,
          "old_text": "file->index_read_map(record, group_prefix, keypart_map, find_flag)",
          "new_text": null,
          "old_line_content": "    result= file->index_read_map(record, group_prefix, keypart_map, find_flag);",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 3287,
          "old_api": "dbug_print_segment_range",
          "new_api": null,
          "old_text": "dbug_print_segment_range(key_tree,\n                                                    range_par->key_parts)",
          "new_text": null,
          "old_line_content": "      DBUG_EXECUTE(\"info\", dbug_print_segment_range(key_tree,",
          "new_line_content": "        did_set_ignore_part_fields= TRUE;",
          "content_same": false
        },
        {
          "line": 3289,
          "old_api": "ppar->part_info->\n           get_subpart_iter_for_interval(ppar->part_info,\n                                         TRUE,\n                                         NULL, /* Currently not used here */\n                                         key_tree->min_value, \n                                         key_tree->max_value,\n                                         0, 0, /* Those are ignored here */\n                                         key_tree->min_flag |\n                                           key_tree->max_flag,\n                                         &subpart_iter)",
          "new_api": null,
          "old_text": "ppar->part_info->\n           get_subpart_iter_for_interval(ppar->part_info,\n                                         TRUE,\n                                         NULL, /* Currently not used here */\n                                         key_tree->min_value, \n                                         key_tree->max_value,\n                                         0, 0, /* Those are ignored here */\n                                         key_tree->min_flag |\n                                           key_tree->max_flag,\n                                         &subpart_iter)",
          "new_text": null,
          "old_line_content": "      res= ppar->part_info->",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 7393,
          "old_api": "left_rotate",
          "new_api": null,
          "old_text": "left_rotate(&root,par)",
          "new_text": null,
          "old_line_content": "\tleft_rotate(&root,par);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 11492,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(tmp_record, record, head->s->rec_buff_length)",
          "new_text": null,
          "old_line_content": "      memcpy(tmp_record, record, head->s->rec_buff_length);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3305,
          "old_api": "is_error",
          "new_api": null,
          "old_text": "range_par->thd->is_error()",
          "new_text": null,
          "old_line_content": "        DBUG_ASSERT(range_par->thd->is_error());",
          "new_line_content": "                                         key_tree->max_value,",
          "content_same": false
        },
        {
          "line": 11498,
          "old_api": "key_cmp",
          "new_api": null,
          "old_text": "key_cmp(index_info->key_part, group_prefix, real_prefix_len)",
          "new_text": null,
          "old_line_content": "    if (key_cmp(index_info->key_part, group_prefix, real_prefix_len))",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 5357,
          "old_api": "create_item",
          "new_api": null,
          "old_text": "func->array->create_item()",
          "new_text": null,
          "old_line_content": "        Item *value_item= func->array->create_item();",
          "new_line_content": "#define NOT_IN_IGNORE_THRESHOLD 1000",
          "content_same": false
        },
        {
          "line": 7407,
          "old_api": "right_rotate",
          "new_api": null,
          "old_text": "right_rotate(&root,w)",
          "new_text": null,
          "old_line_content": "\t  right_rotate(&root,w);",
          "new_line_content": "      if (w->left->color == SEL_ARG::BLACK && w->right->color == SEL_ARG::BLACK)",
          "content_same": false
        },
        {
          "line": 3313,
          "old_api": "bitmap_clear_all",
          "new_api": null,
          "old_text": "bitmap_clear_all(&ppar->subparts_bitmap)",
          "new_text": null,
          "old_line_content": "      bitmap_clear_all(&ppar->subparts_bitmap);",
          "new_line_content": "           The only case where we can get \"no satisfying subpartitions\"",
          "content_same": false
        },
        {
          "line": 3314,
          "old_api": "get_next",
          "new_api": null,
          "old_text": "subpart_iter.get_next(&subpart_iter)",
          "new_text": null,
          "old_line_content": "      while ((subpart_id= subpart_iter.get_next(&subpart_iter)) !=",
          "new_line_content": "           returned from the above call is when an error has occurred.",
          "content_same": false
        },
        {
          "line": 11508,
          "old_api": "my_alloca",
          "new_api": null,
          "old_text": "my_alloca(real_prefix_len + min_max_arg_len)",
          "new_text": null,
          "old_line_content": "      uchar *max_key= (uchar*) my_alloca(real_prefix_len + min_max_arg_len);",
          "new_line_content": "    /* Check if record belongs to the current group. */",
          "content_same": false
        },
        {
          "line": 7413,
          "old_api": "left_rotate",
          "new_api": null,
          "old_text": "left_rotate(&root,par)",
          "new_text": null,
          "old_line_content": "\tleft_rotate(&root,par);",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 11510,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(max_key + real_prefix_len, cur_range->max_key,\n             cur_range->max_length)",
          "new_text": null,
          "old_line_content": "      memcpy(max_key + real_prefix_len, cur_range->max_key,",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 5367,
          "old_api": "value_to_item",
          "new_api": null,
          "old_text": "func->array->value_to_item(i, value_item)",
          "new_text": null,
          "old_line_content": "          func->array->value_to_item(i, value_item);",
          "new_line_content": "        */",
          "content_same": false
        },
        {
          "line": 3320,
          "old_api": "get_next",
          "new_api": null,
          "old_text": "ppar->part_iter.get_next(&ppar->part_iter)",
          "new_text": null,
          "old_line_content": "      while ((part_id= ppar->part_iter.get_next(&ppar->part_iter)) !=",
          "new_line_content": "      if (res == -1)",
          "content_same": false
        },
        {
          "line": 11513,
          "old_api": "key_cmp",
          "new_api": null,
          "old_text": "key_cmp(index_info->key_part, max_key,\n                           real_prefix_len + min_max_arg_len)",
          "new_text": null,
          "old_line_content": "      int cmp_res= key_cmp(index_info->key_part, max_key,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 7425,
          "old_api": "right_rotate",
          "new_api": null,
          "old_text": "right_rotate(&root,par)",
          "new_text": null,
          "old_line_content": "\tright_rotate(&root,par);",
          "new_line_content": "\tx=root;",
          "content_same": false
        },
        {
          "line": 5384,
          "old_api": "compare_elems",
          "new_api": null,
          "old_text": "func->array->compare_elems(i, i-1)",
          "new_text": null,
          "old_line_content": "          if (func->array->compare_elems(i, i-1))",
          "new_line_content": "        } while (i < func->array->count && tree->type == SEL_TREE::IMPOSSIBLE);",
          "content_same": false
        },
        {
          "line": 11529,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(result == 0)",
          "new_text": null,
          "old_line_content": "    DBUG_ASSERT(result == 0);",
          "new_line_content": "        or",
          "content_same": false
        },
        {
          "line": 5387,
          "old_api": "value_to_item",
          "new_api": null,
          "old_text": "func->array->value_to_item(i, value_item)",
          "new_text": null,
          "old_line_content": "            func->array->value_to_item(i, value_item);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 5388,
          "old_api": "get_mm_parts",
          "new_api": null,
          "old_text": "get_mm_parts(param, cond_func, field, Item_func::LT_FUNC,\n                                value_item, cmp_type)",
          "new_text": null,
          "old_line_content": "            tree2= get_mm_parts(param, cond_func, field, Item_func::LT_FUNC,",
          "new_line_content": "          /* We get here in cases like \"t.unsigned NOT IN (-1,-2,-3) */",
          "content_same": false
        },
        {
          "line": 3341,
          "old_api": "store_selargs_to_rec",
          "new_api": null,
          "old_text": "store_selargs_to_rec(ppar, ppar->arg_stack, ppar->part_fields)",
          "new_text": null,
          "old_line_content": "        store_selargs_to_rec(ppar, ppar->arg_stack, ppar->part_fields);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7439,
          "old_api": "left_rotate",
          "new_api": null,
          "old_text": "left_rotate(&root,w)",
          "new_text": null,
          "old_line_content": "\t  left_rotate(&root,w);",
          "new_line_content": "      if (w->right->color == SEL_ARG::BLACK && w->left->color == SEL_ARG::BLACK)",
          "content_same": false
        },
        {
          "line": 3347,
          "old_api": "get_top_partition_id_func",
          "new_api": null,
          "old_text": "ppar->get_top_partition_id_func(ppar->part_info, &part_id,\n                                            &func_value)",
          "new_text": null,
          "old_line_content": "        if (ppar->get_top_partition_id_func(ppar->part_info, &part_id,",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 11539,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(record, tmp_record, head->s->rec_buff_length)",
          "new_text": null,
          "old_line_content": "    memcpy(record, tmp_record, head->s->rec_buff_length);",
          "new_line_content": "    /* If we got to this point, the current key qualifies as MIN. */",
          "content_same": false
        },
        {
          "line": 7445,
          "old_api": "right_rotate",
          "new_api": null,
          "old_text": "right_rotate(&root,par)",
          "new_text": null,
          "old_line_content": "\tright_rotate(&root,par);",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 3354,
          "old_api": "init_single_partition_iterator",
          "new_api": null,
          "old_text": "init_single_partition_iterator(part_id, &ppar->part_iter)",
          "new_text": null,
          "old_line_content": "        init_single_partition_iterator(part_id, &ppar->part_iter);",
          "new_line_content": "                                                       ppar->part_fields););",
          "content_same": false
        },
        {
          "line": 5402,
          "old_api": "last",
          "new_api": null,
          "old_text": "tree->keys[idx]->last()",
          "new_text": null,
          "old_line_content": "                  ((last_val= tree->keys[idx]->last())))",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 3371,
          "old_api": "store_selargs_to_rec",
          "new_api": null,
          "old_text": "store_selargs_to_rec(ppar, ppar->arg_stack_end - ppar->subpart_fields,\n                             ppar->subpart_fields)",
          "new_text": null,
          "old_line_content": "        store_selargs_to_rec(ppar, ppar->arg_stack_end - ppar->subpart_fields,",
          "new_line_content": "        set_full_part_if_bad_ret= TRUE;",
          "content_same": false
        },
        {
          "line": 7468,
          "old_api": "sql_print_error",
          "new_api": null,
          "old_text": "sql_print_error(\"Wrong tree: Parent doesn't point at parent\")",
          "new_text": null,
          "old_line_content": "    sql_print_error(\"Wrong tree: Parent doesn't point at parent\");",
          "new_line_content": "\t/* Test that the properties for a red-black tree hold */",
          "content_same": false
        },
        {
          "line": 3373,
          "old_api": "dbug_print_singlepoint_range",
          "new_api": null,
          "old_text": "dbug_print_singlepoint_range(ppar->arg_stack_end- \n                                                       ppar->subpart_fields,\n                                                       ppar->subpart_fields)",
          "new_text": null,
          "old_line_content": "        DBUG_EXECUTE(\"info\", dbug_print_singlepoint_range(ppar->arg_stack_end- ",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 7475,
          "old_api": "sql_print_error",
          "new_api": null,
          "old_text": "sql_print_error(\"Wrong tree: Found two red in a row\")",
          "new_text": null,
          "old_line_content": "    sql_print_error(\"Wrong tree: Found two red in a row\");",
          "new_line_content": "  if (element == &null_element)",
          "content_same": false
        },
        {
          "line": 3380,
          "old_api": "get_subpartition_id",
          "new_api": null,
          "old_text": "part_info->get_subpartition_id(part_info, &subpart_id)",
          "new_text": null,
          "old_line_content": "        if (part_info->get_subpartition_id(part_info, &subpart_id))",
          "new_line_content": "          fields. Save all constN constants into table record buffer.",
          "content_same": false
        },
        {
          "line": 11574,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(min_max_ranges.elements > 0)",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(min_max_ranges.elements > 0);",
          "new_line_content": "    HA_ERR_END_OF_FILE   - \"\" -",
          "content_same": false
        },
        {
          "line": 7480,
          "old_api": "sql_print_error",
          "new_api": null,
          "old_text": "sql_print_error(\"Wrong tree: Found right == left\")",
          "new_text": null,
          "old_line_content": "    sql_print_error(\"Wrong tree: Found right == left\");",
          "new_line_content": "    return -1;",
          "content_same": false
        },
        {
          "line": 11578,
          "old_api": "get_dynamic",
          "new_api": null,
          "old_text": "get_dynamic(&min_max_ranges, (uchar*)&cur_range, range_idx - 1)",
          "new_text": null,
          "old_line_content": "    get_dynamic(&min_max_ranges, (uchar*)&cur_range, range_idx - 1);",
          "new_line_content": "int QUICK_GROUP_MIN_MAX_SELECT::next_max_in_range()",
          "content_same": false
        },
        {
          "line": 3387,
          "old_api": "bitmap_set_bit",
          "new_api": null,
          "old_text": "bitmap_set_bit(&part_info->used_partitions,\n                         part_id * part_info->num_subparts + subpart_id)",
          "new_text": null,
          "old_line_content": "          bitmap_set_bit(&part_info->used_partitions,",
          "new_line_content": "        /* Find the subpartition (it's HASH/KEY so we always have one) */",
          "content_same": false
        },
        {
          "line": 7483,
          "old_api": "test_rb_tree",
          "new_api": null,
          "old_text": "test_rb_tree(element->left,element)",
          "new_text": null,
          "old_line_content": "  count_l=test_rb_tree(element->left,element);",
          "new_line_content": "      (element->left->color == SEL_ARG::RED ||",
          "content_same": false
        },
        {
          "line": 7484,
          "old_api": "test_rb_tree",
          "new_api": null,
          "old_text": "test_rb_tree(element->right,element)",
          "new_text": null,
          "old_line_content": "  count_r=test_rb_tree(element->right,element);",
          "new_line_content": "       element->right->color == SEL_ARG::RED))",
          "content_same": false
        },
        {
          "line": 5440,
          "old_api": "tree_or",
          "new_api": null,
          "old_text": "tree_or(param, tree, tree2)",
          "new_text": null,
          "old_line_content": "            tree= tree_or(param, tree, tree2);",
          "new_line_content": "                  const KEY_PART_INFO *kpi= key.key_part + new_interval->part;",
          "content_same": false
        },
        {
          "line": 7489,
          "old_api": "sql_print_error",
          "new_api": null,
          "old_text": "sql_print_error(\"Wrong tree: Incorrect black-count: %d - %d\",\n\t    count_l,count_r)",
          "new_text": null,
          "old_line_content": "    sql_print_error(\"Wrong tree: Incorrect black-count: %d - %d\",",
          "new_line_content": "  if (element->left == element->right && element->left != &null_element)",
          "content_same": false
        },
        {
          "line": 11586,
          "old_api": "key_cmp",
          "new_api": null,
          "old_text": "key_cmp(min_max_arg_part, (const uchar*) cur_range->min_key,\n                 min_max_arg_len)",
          "new_text": null,
          "old_line_content": "        (key_cmp(min_max_arg_part, (const uchar*) cur_range->min_key,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 11592,
          "old_api": "make_prev_keypart_map",
          "new_api": null,
          "old_text": "make_prev_keypart_map(real_key_parts)",
          "new_text": null,
          "old_line_content": "      keypart_map= make_prev_keypart_map(real_key_parts);",
          "new_line_content": "      If the current value for the min/max argument is smaller than the left",
          "content_same": false
        },
        {
          "line": 5450,
          "old_api": "get_mm_parts",
          "new_api": null,
          "old_text": "get_mm_parts(param, cond_func, field, Item_func::GT_FUNC,\n                              value_item, cmp_type)",
          "new_text": null,
          "old_line_content": "          tree2= get_mm_parts(param, cond_func, field, Item_func::GT_FUNC,",
          "new_line_content": "            */",
          "content_same": false
        },
        {
          "line": 5452,
          "old_api": "tree_or",
          "new_api": null,
          "old_text": "tree_or(param, tree, tree2)",
          "new_text": null,
          "old_line_content": "          tree= tree_or(param, tree, tree2);",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 11598,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(group_prefix + real_prefix_len, cur_range->max_key,\n             cur_range->max_length)",
          "new_text": null,
          "old_line_content": "      memcpy(group_prefix + real_prefix_len, cur_range->max_key,",
          "new_line_content": "                 min_max_arg_len) == -1))",
          "content_same": false
        },
        {
          "line": 11600,
          "old_api": "make_keypart_map",
          "new_api": null,
          "old_text": "make_keypart_map(real_key_parts)",
          "new_text": null,
          "old_line_content": "      keypart_map= make_keypart_map(real_key_parts);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5457,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "get_ne_mm_tree(param, cond_func, field,\n                             func->arguments()[1], func->arguments()[1],\n                             cmp_type)",
          "new_text": null,
          "old_line_content": "        tree= get_ne_mm_tree(param, cond_func, field,",
          "new_line_content": "          /* ",
          "content_same": false
        },
        {
          "line": 5458,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "func->arguments()",
          "new_text": null,
          "old_line_content": "                             func->arguments()[1], func->arguments()[1],",
          "new_line_content": "            Get the SEL_TREE for the last \"c_last < X < +inf\" interval ",
          "content_same": false
        },
        {
          "line": 11606,
          "old_api": "index_read_map",
          "new_api": null,
          "old_text": "file->index_read_map(record, group_prefix, keypart_map, find_flag)",
          "new_text": null,
          "old_line_content": "    result= file->index_read_map(record, group_prefix, keypart_map, find_flag);",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 3418,
          "old_api": "find_used_partitions",
          "new_api": null,
          "old_text": "find_used_partitions(ppar, key_tree->next_key_part)",
          "new_text": null,
          "old_line_content": "    res= find_used_partitions(ppar, key_tree->next_key_part);",
          "new_line_content": "        No meaning in continuing with rest of partitioning key parts.",
          "content_same": false
        },
        {
          "line": 5466,
          "old_api": "get_ne_mm_tree",
          "new_api": null,
          "old_text": "get_ne_mm_tree(param, cond_func, field, \n                                                        *arg, *arg, cmp_type)",
          "new_text": null,
          "old_line_content": "            tree=  tree_and(param, tree, get_ne_mm_tree(param, cond_func, field, ",
          "new_line_content": "      else",
          "content_same": false
        },
        {
          "line": 5475,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "func->arguments()",
          "new_text": null,
          "old_line_content": "                         func->arguments()[1], cmp_type);",
          "new_line_content": "               arg < end ; arg++)",
          "content_same": false
        },
        {
          "line": 5479,
          "old_api": "argument_count",
          "new_api": null,
          "old_text": "func->argument_count()",
          "new_text": null,
          "old_line_content": "        for (arg= func->arguments()+2, end= arg+func->argument_count()-2;",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 11625,
          "old_api": "key_cmp",
          "new_api": null,
          "old_text": "key_cmp(index_info->key_part, group_prefix, real_prefix_len)",
          "new_text": null,
          "old_line_content": "    if (key_cmp(index_info->key_part, group_prefix, real_prefix_len))",
          "new_line_content": "      /*",
          "content_same": false
        },
        {
          "line": 5482,
          "old_api": "get_mm_parts",
          "new_api": null,
          "old_text": "get_mm_parts(param, cond_func, field, \n                                                  Item_func::EQ_FUNC,\n                                                  *arg, cmp_type)",
          "new_text": null,
          "old_line_content": "          tree= tree_or(param, tree, get_mm_parts(param, cond_func, field, ",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3439,
          "old_api": "get_next",
          "new_api": null,
          "old_text": "ppar->part_iter.get_next(&ppar->part_iter)",
          "new_text": null,
          "old_line_content": "      while ((part_id= ppar->part_iter.get_next(&ppar->part_iter)) !=",
          "new_line_content": "      to ignore partitioning fields.",
          "content_same": false
        },
        {
          "line": 11632,
          "old_api": "my_alloca",
          "new_api": null,
          "old_text": "my_alloca(real_prefix_len + min_max_arg_len)",
          "new_text": null,
          "old_line_content": "      uchar *min_key= (uchar*) my_alloca(real_prefix_len + min_max_arg_len);",
          "new_line_content": "    if (cur_range->flag & EQ_RANGE)",
          "content_same": false
        },
        {
          "line": 11633,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(min_key, group_prefix, real_prefix_len)",
          "new_text": null,
          "old_line_content": "      memcpy(min_key, group_prefix, real_prefix_len);",
          "new_line_content": "      return 0; /* No need to perform the checks below for equal keys. */",
          "content_same": false
        },
        {
          "line": 3442,
          "old_api": "mark_full_partition_used",
          "new_api": null,
          "old_text": "ppar->mark_full_partition_used(ppar->part_info, part_id)",
          "new_text": null,
          "old_line_content": "        ppar->mark_full_partition_used(ppar->part_info, part_id);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 11634,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(min_key + real_prefix_len, cur_range->min_key,\n             cur_range->min_length)",
          "new_text": null,
          "old_line_content": "      memcpy(min_key + real_prefix_len, cur_range->min_key,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3445,
          "old_api": "test",
          "new_api": null,
          "old_text": "test(found)",
          "new_text": null,
          "old_line_content": "      res= test(found);",
          "new_line_content": "    if (res == -1)",
          "content_same": false
        },
        {
          "line": 11637,
          "old_api": "key_cmp",
          "new_api": null,
          "old_text": "key_cmp(index_info->key_part, min_key,\n                           real_prefix_len + min_max_arg_len)",
          "new_text": null,
          "old_line_content": "      int cmp_res= key_cmp(index_info->key_part, min_key,",
          "new_line_content": "      continue;                                 // Row not found",
          "content_same": false
        },
        {
          "line": 7541,
          "old_api": "first",
          "new_api": null,
          "old_text": "root->first()",
          "new_text": null,
          "old_line_content": "  for (root=root->first(); root ; root=root->next)",
          "new_line_content": "           |        |         $    |",
          "content_same": false
        },
        {
          "line": 3451,
          "old_api": "init_all_partitions_iterator",
          "new_api": null,
          "old_text": "init_all_partitions_iterator(ppar->part_info, &ppar->part_iter)",
          "new_text": null,
          "old_line_content": "    init_all_partitions_iterator(ppar->part_info, &ppar->part_iter);",
          "new_line_content": "             NOT_A_PARTITION_ID)",
          "content_same": false
        },
        {
          "line": 5500,
          "old_api": "functype",
          "new_api": null,
          "old_text": "cond_func->functype()",
          "new_text": null,
          "old_line_content": "      (value != cond_func->arguments()[0]) ? cond_func->functype() :",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 5501,
          "old_api": "rev_functype",
          "new_api": null,
          "old_text": "(Item_bool_func2*) cond_func)->rev_functype()",
          "new_text": null,
          "old_line_content": "        ((Item_bool_func2*) cond_func)->rev_functype();",
          "new_line_content": "  default: ",
          "content_same": false
        },
        {
          "line": 5502,
          "old_api": "get_mm_parts",
          "new_api": null,
          "old_text": "get_mm_parts(param, cond_func, field, func_type, value, cmp_type)",
          "new_text": null,
          "old_line_content": "    tree= get_mm_parts(param, cond_func, field, func_type, value, cmp_type);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 7548,
          "old_api": "count_key_part_usage",
          "new_api": null,
          "old_text": "count_key_part_usage(root->next_key_part,key)",
          "new_text": null,
          "old_line_content": "\tcount+=count_key_part_usage(root->next_key_part,key);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5506,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(tree)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(tree);",
          "new_line_content": "       If the predicate is of the form (value op field) it is handled",
          "content_same": false
        },
        {
          "line": 9603,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"get_best_group_min_max\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"get_best_group_min_max\");",
          "new_line_content": "  uint used_key_parts= 0;   /* Number of index key parts used for access. */",
          "content_same": false
        },
        {
          "line": 9607,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(NULL);        /* This is not a select statement. */",
          "new_line_content": "  uint key_part_nr;",
          "content_same": false
        },
        {
          "line": 3464,
          "old_api": "find_used_partitions",
          "new_api": null,
          "old_text": "find_used_partitions(ppar,key_tree->right)",
          "new_text": null,
          "old_line_content": "    if (-1 == (right_res= find_used_partitions(ppar,key_tree->right)))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 9610,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "  Item_field *item_field;",
          "content_same": false
        },
        {
          "line": 9612,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "  List<Item_field> agg_distinct_flds;",
          "content_same": false
        },
        {
          "line": 9615,
          "old_api": "make_sum_func_list",
          "new_api": null,
          "old_text": "join->make_sum_func_list(join->all_fields, join->fields_list, 1)",
          "new_text": null,
          "old_line_content": "  if (join->make_sum_func_list(join->all_fields, join->fields_list, 1))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 9616,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "  /* Perform few 'cheap' tests whether this access method is applicable. */",
          "content_same": false
        },
        {
          "line": 3473,
          "old_api": "bitmap_set_all",
          "new_api": null,
          "old_text": "bitmap_set_all(&part_info->used_partitions)",
          "new_text": null,
          "old_line_content": "  bitmap_set_all(&part_info->used_partitions);",
          "new_line_content": "  if (key_tree->right != &null_element)",
          "content_same": false
        },
        {
          "line": 9619,
          "old_api": "is_indexed_agg_distinct",
          "new_api": null,
          "old_text": "is_indexed_agg_distinct(join, &agg_distinct_flds)",
          "new_text": null,
          "old_line_content": "  is_agg_distinct = is_indexed_agg_distinct(join, &agg_distinct_flds);",
          "new_line_content": "  if ((join->tables != 1) ||  /* The query must reference one table. */",
          "content_same": false
        },
        {
          "line": 7574,
          "old_api": "sql_print_information",
          "new_api": null,
          "old_text": "sql_print_information(\"Use_count: Wrong count %lu for root\",use_count)",
          "new_text": null,
          "old_line_content": "    sql_print_information(\"Use_count: Wrong count %lu for root\",use_count);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 9624,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7579,
          "old_api": "first",
          "new_api": null,
          "old_text": "first()",
          "new_text": null,
          "old_line_content": "  for (SEL_ARG *pos=first(); pos ; pos=pos->next)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7584,
          "old_api": "count_key_part_usage",
          "new_api": null,
          "old_text": "count_key_part_usage(root,pos->next_key_part)",
          "new_text": null,
          "old_line_content": "      ulong count=count_key_part_usage(root,pos->next_key_part);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 9633,
          "old_api": "sum_func",
          "new_api": null,
          "old_text": "min_max_item->sum_func()",
          "new_text": null,
          "old_line_content": "      if (min_max_item->sum_func() == Item_sum::MIN_FUNC)",
          "new_line_content": "      (!join->select_distinct) &&",
          "content_same": false
        },
        {
          "line": 11683,
          "old_api": "rewind",
          "new_api": null,
          "old_text": "min_functions_it->rewind()",
          "new_text": null,
          "old_line_content": "  min_functions_it->rewind();",
          "new_line_content": "    MAX take their result value from the same buffer this->head->record[0]",
          "content_same": false
        },
        {
          "line": 7587,
          "old_api": "sql_print_information",
          "new_api": null,
          "old_text": "sql_print_information(\"Use_count: Wrong count for key at 0x%lx, %lu \"\n                              \"should be %lu\", (long unsigned int)pos,\n                              pos->next_key_part->use_count, count)",
          "new_text": null,
          "old_line_content": "        sql_print_information(\"Use_count: Wrong count for key at 0x%lx, %lu \"",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 11685,
          "old_api": "reset_and_add",
          "new_api": null,
          "old_text": "min_func->reset_and_add()",
          "new_text": null,
          "old_line_content": "    min_func->reset_and_add();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 9638,
          "old_api": "sum_func",
          "new_api": null,
          "old_text": "min_max_item->sum_func()",
          "new_text": null,
          "old_line_content": "               (min_max_item->sum_func() == Item_sum::COUNT_DISTINCT_FUNC ||",
          "new_line_content": "  if (join->sum_funcs[0])",
          "content_same": false
        },
        {
          "line": 9639,
          "old_api": "sum_func",
          "new_api": null,
          "old_text": "min_max_item->sum_func()",
          "new_text": null,
          "old_line_content": "                min_max_item->sum_func() == Item_sum::SUM_DISTINCT_FUNC ||",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 9640,
          "old_api": "sum_func",
          "new_api": null,
          "old_text": "min_max_item->sum_func()",
          "new_text": null,
          "old_line_content": "                min_max_item->sum_func() == Item_sum::AVG_DISTINCT_FUNC))",
          "new_line_content": "    Item_sum *min_max_item;",
          "content_same": false
        },
        {
          "line": 7592,
          "old_api": "test_use_count",
          "new_api": null,
          "old_text": "pos->next_key_part->test_use_count(root)",
          "new_text": null,
          "old_line_content": "      pos->next_key_part->test_use_count(root);",
          "new_line_content": "    e_count++;",
          "content_same": false
        },
        {
          "line": 9643,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "        DBUG_RETURN(NULL);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 7596,
          "old_api": "sql_print_warning",
          "new_api": null,
          "old_text": "sql_print_warning(\"Wrong use count: %u (should be %u) for tree at 0x%lx\",\n                      e_count, elements, (long unsigned int) this)",
          "new_text": null,
          "old_line_content": "    sql_print_warning(\"Wrong use count: %u (should be %u) for tree at 0x%lx\",",
          "new_line_content": "      if (count > pos->next_key_part->use_count)",
          "content_same": false
        },
        {
          "line": 9647,
          "old_api": "type",
          "new_api": null,
          "old_text": "expr->type()",
          "new_text": null,
          "old_line_content": "      if (expr->type() == Item::FIELD_ITEM) /* Is it an attribute? */",
          "new_line_content": "        have_max= TRUE;",
          "content_same": false
        },
        {
          "line": 3506,
          "old_api": "real_type",
          "new_api": null,
          "old_text": "*pfield)->real_type()",
          "new_text": null,
          "old_line_content": "    enum_field_types ftype= (*pfield)->real_type();",
          "new_line_content": "  RETURN ",
          "content_same": false
        },
        {
          "line": 9652,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "          DBUG_RETURN(NULL);",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 9655,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "        DBUG_RETURN(NULL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 11715,
          "old_api": "rewind",
          "new_api": null,
          "old_text": "max_functions_it->rewind()",
          "new_text": null,
          "old_line_content": "  max_functions_it->rewind();",
          "new_line_content": "    next_max() was called, because both MIN and MAX take their result value",
          "content_same": false
        },
        {
          "line": 11717,
          "old_api": "reset_and_add",
          "new_api": null,
          "old_text": "max_func->reset_and_add()",
          "new_text": null,
          "old_line_content": "    max_func->reset_and_add();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 9670,
          "old_api": "real_item",
          "new_api": null,
          "old_text": "item->real_item()->type()",
          "new_text": null,
          "old_line_content": "      if (item->real_item()->type() != Item::FIELD_ITEM)",
          "new_line_content": "  /* Check (SA7). */",
          "content_same": false
        },
        {
          "line": 9671,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "        DBUG_RETURN(NULL);",
          "new_line_content": "  if (is_agg_distinct && (have_max || have_min))",
          "content_same": false
        },
        {
          "line": 9678,
          "old_api": "real_item",
          "new_api": null,
          "old_text": "*tmp_group->item)->real_item()->type()",
          "new_text": null,
          "old_line_content": "    if ((*tmp_group->item)->real_item()->type() != Item::FIELD_ITEM)",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 9679,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(NULL);",
          "new_line_content": "    while ((item= select_items_it++))",
          "content_same": false
        },
        {
          "line": 7632,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"check_quick_select\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"check_quick_select\");",
          "new_line_content": "    Estimate # of records to be retrieved.",
          "content_same": false
        },
        {
          "line": 3542,
          "old_api": "fields_ok_for_partition_index",
          "new_api": null,
          "old_text": "fields_ok_for_partition_index(part_info->part_field_array)",
          "new_text": null,
          "old_line_content": "  used_part_fields= fields_ok_for_partition_index(part_info->part_field_array) ?",
          "new_line_content": "  RETURN",
          "content_same": false
        },
        {
          "line": 5590,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"get_full_func_mm_tree\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"get_full_func_mm_tree\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7638,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(HA_POS_ERROR)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(HA_POS_ERROR);\t\t\t// Can't use it",
          "new_line_content": "check_quick_select(PARAM *param,uint idx,SEL_ARG *tree, bool update_tbl_stats)",
          "content_same": false
        },
        {
          "line": 3545,
          "old_api": "fields_ok_for_partition_index",
          "new_api": null,
          "old_text": "fields_ok_for_partition_index(part_info->subpart_field_array)",
          "new_text": null,
          "old_line_content": "    fields_ok_for_partition_index(part_info->subpart_field_array)? ",
          "new_line_content": "*/",
          "content_same": false
        },
        {
          "line": 5594,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "cond_func->arguments()[i]->real_item()",
          "new_text": null,
          "old_line_content": "    Item *arg= cond_func->arguments()[i]->real_item();",
          "new_line_content": "                                       bool inv)",
          "content_same": false
        },
        {
          "line": 5596,
          "old_api": "used_tables",
          "new_api": null,
          "old_text": "arg->used_tables()",
          "new_text": null,
          "old_line_content": "      ref_tables|= arg->used_tables();",
          "new_line_content": "  SEL_TREE *tree= 0;",
          "content_same": false
        },
        {
          "line": 11741,
          "old_api": "append",
          "new_api": null,
          "old_text": "key_names->append(index_info->name)",
          "new_text": null,
          "old_line_content": "  key_names->append(index_info->name);",
          "new_line_content": "  DESCRIPTION",
          "content_same": false
        },
        {
          "line": 11742,
          "old_api": "longlong2str",
          "new_api": null,
          "old_text": "longlong2str(max_used_key_length, buf, 10)",
          "new_text": null,
          "old_line_content": "  length= longlong2str(max_used_key_length, buf, 10) - buf;",
          "new_line_content": "    This method is used by select_describe to extract the names of the",
          "content_same": false
        },
        {
          "line": 11743,
          "old_api": "append",
          "new_api": null,
          "old_text": "used_lengths->append(buf, length)",
          "new_text": null,
          "old_line_content": "  used_lengths->append(buf, length);",
          "new_line_content": "    indexes used by a quick select.",
          "content_same": false
        },
        {
          "line": 5599,
          "old_api": "cmp_type",
          "new_api": null,
          "old_text": "field->cmp_type()",
          "new_text": null,
          "old_line_content": "  Item_result cmp_type= field->cmp_type();",
          "new_line_content": "  table_map param_comp= ~(param->prev_tables | param->read_tables |",
          "content_same": false
        },
        {
          "line": 7644,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0L)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(0L);\t\t\t\t// Impossible select. return",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7646,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(HA_POS_ERROR)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(HA_POS_ERROR);\t\t\t\t// Don't use tree",
          "new_line_content": "  param->first_null_comp= 0;",
          "content_same": false
        },
        {
          "line": 3558,
          "old_api": "is_sub_partitioned",
          "new_api": null,
          "old_text": "part_info->is_sub_partitioned()",
          "new_text": null,
          "old_line_content": "  if (part_info->is_sub_partitioned())",
          "new_line_content": "  ",
          "content_same": false
        },
        {
          "line": 11755,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"print_sel_tree\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"print_sel_tree\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 7661,
          "old_api": "primary_key_is_clustered",
          "new_api": null,
          "old_text": "param->table->file->primary_key_is_clustered()",
          "new_text": null,
          "old_line_content": "               param->table->file->primary_key_is_clustered());",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 11758,
          "old_api": "length",
          "new_api": null,
          "old_text": "tmp.length(0)",
          "new_text": null,
          "old_line_content": "  tmp.length(0);",
          "new_line_content": "#ifndef DBUG_OFF",
          "content_same": false
        },
        {
          "line": 5614,
          "old_api": "get_func_mm_tree",
          "new_api": null,
          "old_text": "get_func_mm_tree(param, cond_func, f, value, cmp_type, inv)",
          "new_text": null,
          "old_line_content": "        tree= get_func_mm_tree(param, cond_func, f, value, cmp_type, inv);",
          "new_line_content": "  if (item_equal)",
          "content_same": false
        },
        {
          "line": 5615,
          "old_api": "tree_and",
          "new_api": null,
          "old_text": "tree_and(param, ftree, tree)",
          "new_text": null,
          "old_line_content": "        ftree= !ftree ? tree : tree_and(param, ftree, tree);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 7666,
          "old_api": "check_quick_keys",
          "new_api": null,
          "old_text": "check_quick_keys(param, idx, tree,\n                            param->min_key, 0, -1,\n                            param->max_key, 0, -1)",
          "new_text": null,
          "old_line_content": "  records= check_quick_keys(param, idx, tree,",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 11763,
          "old_api": "is_set",
          "new_api": null,
          "old_text": "tree_map->is_set(idx)",
          "new_text": null,
          "old_line_content": "    if (tree_map->is_set(idx))",
          "new_line_content": "  SEL_ARG **key,**end;",
          "content_same": false
        },
        {
          "line": 3572,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(alloc, sizeof(KEY_PART)*\n                                               total_parts)",
          "new_text": null,
          "old_line_content": "      !(key_part= (KEY_PART*)alloc_root(alloc, sizeof(KEY_PART)*",
          "new_line_content": "    ppar->get_top_partition_id_func= part_info->get_part_partition_id;",
          "content_same": false
        },
        {
          "line": 5619,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(ftree)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(ftree);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3574,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(alloc, sizeof(SEL_ARG*)* \n                                                      total_parts)",
          "new_text": null,
          "old_line_content": "      !(ppar->arg_stack= (SEL_ARG**)alloc_root(alloc, sizeof(SEL_ARG*)* ",
          "new_line_content": "  else",
          "content_same": false
        },
        {
          "line": 11767,
          "old_api": "append",
          "new_api": null,
          "old_text": "tmp.append(',')",
          "new_text": null,
          "old_line_content": "        tmp.append(',');",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3576,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(alloc, sizeof(my_bool)*\n                                                           total_parts)",
          "new_text": null,
          "old_line_content": "      !(ppar->is_part_keypart= (my_bool*)alloc_root(alloc, sizeof(my_bool)*",
          "new_line_content": "    ppar->mark_full_partition_used=  mark_full_partition_used_no_parts;",
          "content_same": false
        },
        {
          "line": 11768,
          "old_api": "append",
          "new_api": null,
          "old_text": "tmp.append(param->table->key_info[keynr].name)",
          "new_text": null,
          "old_line_content": "      tmp.append(param->table->key_info[keynr].name);",
          "new_line_content": "  String tmp(buff,sizeof(buff),&my_charset_bin);",
          "content_same": false
        },
        {
          "line": 9722,
          "old_api": "is_set",
          "new_api": null,
          "old_text": "table->covering_keys.is_set(cur_index)",
          "new_text": null,
          "old_line_content": "    if (!table->covering_keys.is_set(cur_index))",
          "new_line_content": "    uint key_infix_parts;",
          "content_same": false
        },
        {
          "line": 3578,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(alloc, sizeof(my_bool)*\n                                                           total_parts)",
          "new_text": null,
          "old_line_content": "      !(ppar->is_subpart_keypart= (my_bool*)alloc_root(alloc, sizeof(my_bool)*",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 11771,
          "old_api": "length",
          "new_api": null,
          "old_text": "tmp.length()",
          "new_text": null,
          "old_line_content": "  if (!tmp.length())",
          "new_line_content": "       key != end ;",
          "content_same": false
        },
        {
          "line": 11772,
          "old_api": "STRING_WITH_LEN",
          "new_api": null,
          "old_text": "STRING_WITH_LEN(\"(empty)\")",
          "new_text": null,
          "old_line_content": "    tmp.append(STRING_WITH_LEN(\"(empty)\"));",
          "new_line_content": "       key++,idx++)",
          "content_same": false
        },
        {
          "line": 7673,
          "old_api": "set_bit",
          "new_api": null,
          "old_text": "param->table->quick_keys.set_bit(key)",
          "new_text": null,
          "old_line_content": "      param->table->quick_keys.set_bit(key);",
          "new_line_content": "    param->is_ror_scan= !cpk_scan;",
          "content_same": false
        },
        {
          "line": 5631,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"get_mm_tree\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"get_mm_tree\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 5633,
          "old_api": "type",
          "new_api": null,
          "old_text": "cond->type()",
          "new_text": null,
          "old_line_content": "  if (cond->type() == Item::COND_ITEM)",
          "new_line_content": "\t/* make a select tree of all keys in condition */",
          "content_same": false
        },
        {
          "line": 3586,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(alloc, bufsize)",
          "new_text": null,
          "old_line_content": "    if (!(buf= (my_bitmap_map*) alloc_root(alloc, bufsize)))",
          "new_line_content": "                                                      total_parts)) ||",
          "content_same": false
        },
        {
          "line": 5635,
          "old_api": "argument_list",
          "new_api": null,
          "old_text": "(Item_cond*) cond)->argument_list()",
          "new_text": null,
          "old_line_content": "    List_iterator<Item> li(*((Item_cond*) cond)->argument_list());",
          "new_line_content": "static SEL_TREE *get_mm_tree(RANGE_OPT_PARAM *param,COND *cond)",
          "content_same": false
        },
        {
          "line": 3588,
          "old_api": "bitmap_init",
          "new_api": null,
          "old_text": "bitmap_init(&ppar->subparts_bitmap, buf, ppar->part_info->num_subparts,\n                FALSE)",
          "new_text": null,
          "old_line_content": "    bitmap_init(&ppar->subparts_bitmap, buf, ppar->part_info->num_subparts,",
          "new_line_content": "                                                           total_parts)) ||",
          "content_same": false
        },
        {
          "line": 5637,
          "old_api": "functype",
          "new_api": null,
          "old_text": "(Item_cond*) cond)->functype()",
          "new_text": null,
          "old_line_content": "    if (((Item_cond*) cond)->functype() == Item_func::COND_AND_FUNC)",
          "new_line_content": "  SEL_TREE *tree=0;",
          "content_same": false
        },
        {
          "line": 9735,
          "old_api": "ha_table_flags",
          "new_api": null,
          "old_text": "table->file->ha_table_flags()",
          "new_text": null,
          "old_line_content": "        (table->file->ha_table_flags() & HA_PRIMARY_KEY_IN_READ_INDEX))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 11784,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"print_ror_scans_arr\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"print_ror_scans_arr\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7687,
          "old_api": "index_flags",
          "new_api": null,
          "old_text": "param->table->file->index_flags(key, 0, TRUE)",
          "new_text": null,
          "old_line_content": "  if (param->table->file->index_flags(key, 0, TRUE) & HA_KEY_SCAN_NOT_ROR)",
          "new_line_content": "      param->table->quick_condition_rows=",
          "content_same": false
        },
        {
          "line": 7689,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"exit\", (\"Records: %lu\", (ulong) records))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"exit\", (\"Records: %lu\", (ulong) records));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 5643,
          "old_api": "get_mm_tree",
          "new_api": null,
          "old_text": "get_mm_tree(param,item)",
          "new_text": null,
          "old_line_content": "        SEL_TREE *new_tree= get_mm_tree(param,item);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 11788,
          "old_api": "length",
          "new_api": null,
          "old_text": "tmp.length(0)",
          "new_text": null,
          "old_line_content": "  tmp.length(0);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 5645,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "          DBUG_RETURN(NULL);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 7690,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(records)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(records);",
          "new_line_content": "    /*",
          "content_same": false
        },
        {
          "line": 11791,
          "old_api": "length",
          "new_api": null,
          "old_text": "tmp.length()",
          "new_text": null,
          "old_line_content": "    if (tmp.length())",
          "new_line_content": "static void print_ror_scans_arr(TABLE *table, const char *msg,",
          "content_same": false
        },
        {
          "line": 3600,
          "old_api": "get_partition_field_store_length",
          "new_api": null,
          "old_text": "get_partition_field_store_length(*field)",
          "new_text": null,
          "old_line_content": "    key_part->store_length= (uint16)get_partition_field_store_length(*field);",
          "new_line_content": "                FALSE);",
          "content_same": false
        },
        {
          "line": 9745,
          "old_api": "bitmap_is_set",
          "new_api": null,
          "old_text": "bitmap_is_set(table->read_set, cur_field->field_index)",
          "new_text": null,
          "old_line_content": "        if (bitmap_is_set(table->read_set, cur_field->field_index) &&",
          "new_line_content": "    if (pk < MAX_KEY && cur_index != pk &&",
          "content_same": false
        },
        {
          "line": 3602,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"part %u length %u store_length %u\", part,\n                         key_part->length, key_part->store_length))",
          "new_text": null,
          "old_line_content": "    DBUG_PRINT(\"info\", (\"part %u length %u store_length %u\", part,",
          "new_line_content": "  range_par->key_parts= key_part;",
          "content_same": false
        },
        {
          "line": 11792,
          "old_api": "append",
          "new_api": null,
          "old_text": "tmp.append(',')",
          "new_text": null,
          "old_line_content": "      tmp.append(',');",
          "new_line_content": "                                struct st_ror_scan_info **start,",
          "content_same": false
        },
        {
          "line": 11793,
          "old_api": "append",
          "new_api": null,
          "old_text": "tmp.append(table->key_info[(*start)->keynr].name)",
          "new_text": null,
          "old_line_content": "    tmp.append(table->key_info[(*start)->keynr].name);",
          "new_line_content": "                                struct st_ror_scan_info **end)",
          "content_same": false
        },
        {
          "line": 11796,
          "old_api": "STRING_WITH_LEN",
          "new_api": null,
          "old_text": "STRING_WITH_LEN(\"(empty)\")",
          "new_text": null,
          "old_line_content": "    tmp.append(STRING_WITH_LEN(\"(empty)\"));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 11797,
          "old_api": "ptr",
          "new_api": null,
          "old_text": "tmp.ptr()",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\", (\"ROR key scans (%s): %s\", msg, tmp.ptr()));",
          "new_line_content": "  char buff[1024];",
          "content_same": false
        },
        {
          "line": 5653,
          "old_api": "get_mm_tree",
          "new_api": null,
          "old_text": "get_mm_tree(param,li++)",
          "new_text": null,
          "old_line_content": "      tree= get_mm_tree(param,li++);",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 9752,
          "old_api": "clear_all",
          "new_api": null,
          "old_text": "used_key_parts_map.clear_all()",
          "new_text": null,
          "old_line_content": "    used_key_parts_map.clear_all();",
          "new_line_content": "        /*",
          "content_same": false
        },
        {
          "line": 5661,
          "old_api": "get_mm_tree",
          "new_api": null,
          "old_text": "get_mm_tree(param,item)",
          "new_text": null,
          "old_line_content": "          SEL_TREE *new_tree=get_mm_tree(param,item);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 5662,
          "old_api": "statement_should_be_aborted",
          "new_api": null,
          "old_text": "param->statement_should_be_aborted()",
          "new_text": null,
          "old_line_content": "          if (new_tree == NULL || param->statement_should_be_aborted())",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 5663,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "            DBUG_RETURN(NULL);",
          "new_line_content": "    {                                           // COND OR",
          "content_same": false
        },
        {
          "line": 5670,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(tree)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(tree);",
          "new_line_content": "        while ((item=li++))",
          "content_same": false
        },
        {
          "line": 9770,
          "old_api": "real_item",
          "new_api": null,
          "old_text": "*tmp_group->item)->real_item()->type()",
          "new_text": null,
          "old_line_content": "        DBUG_ASSERT((*tmp_group->item)->real_item()->type() == Item::FIELD_ITEM);",
          "new_line_content": "      end_part= cur_part + cur_index_info->key_parts;",
          "content_same": false
        },
        {
          "line": 9771,
          "old_api": "real_item",
          "new_api": null,
          "old_text": "*tmp_group->item)->real_item()",
          "new_text": null,
          "old_line_content": "        Item_field *group_field= (Item_field *) (*tmp_group->item)->real_item();",
          "new_line_content": "      /* Iterate in parallel over the GROUP list and the index parts. */",
          "content_same": false
        },
        {
          "line": 9772,
          "old_api": "eq",
          "new_api": null,
          "old_text": "group_field->field->eq(cur_part->field)",
          "new_text": null,
          "old_line_content": "        if (group_field->field->eq(cur_part->field))",
          "new_line_content": "      for (tmp_group= join->group_list; tmp_group && (cur_part != end_part);",
          "content_same": false
        },
        {
          "line": 11818,
          "old_api": "dbug_tmp_use_all_columns",
          "new_api": null,
          "old_text": "dbug_tmp_use_all_columns(table, old_sets, table->read_set, table->write_set)",
          "new_text": null,
          "old_line_content": "  dbug_tmp_use_all_columns(table, old_sets, table->read_set, table->write_set);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3630,
          "old_api": "print_partitioning_index",
          "new_api": null,
          "old_text": "print_partitioning_index(range_par->key_parts,\n                                                range_par->key_parts_end)",
          "new_text": null,
          "old_line_content": "  DBUG_EXECUTE(\"info\", print_partitioning_index(range_par->key_parts,",
          "new_line_content": "      switch to subpartitioning fields. (This will only happens if",
          "content_same": false
        },
        {
          "line": 9777,
          "old_api": "set_bit",
          "new_api": null,
          "old_text": "used_key_parts_map.set_bit(max_key_part)",
          "new_text": null,
          "old_line_content": "          used_key_parts_map.set_bit(max_key_part);",
          "new_line_content": "          tmp_group::item is an array of Item, is it OK to consider only the",
          "content_same": false
        },
        {
          "line": 11825,
          "old_api": "real_maybe_null",
          "new_api": null,
          "old_text": "field->real_maybe_null()",
          "new_text": null,
          "old_line_content": "    if (field->real_maybe_null())",
          "new_line_content": "  uint store_length;",
          "content_same": false
        },
        {
          "line": 5683,
          "old_api": "val_int",
          "new_api": null,
          "old_text": "cond->val_int()",
          "new_text": null,
          "old_line_content": "    tree= cond->val_int() ? new(tmp_root) SEL_TREE(SEL_TREE::ALWAYS) :",
          "new_line_content": "  /* Here when simple cond */",
          "content_same": false
        },
        {
          "line": 5686,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(tree)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(tree);",
          "new_line_content": "    /*",
          "content_same": false
        },
        {
          "line": 3640,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"print_partitioning_index\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"print_partitioning_index\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3642,
          "old_api": "fprintf",
          "new_api": null,
          "old_text": "fprintf(DBUG_FILE, \"partitioning INDEX(\")",
          "new_text": null,
          "old_line_content": "  fprintf(DBUG_FILE, \"partitioning INDEX(\");",
          "new_line_content": "                                                range_par->key_parts_end););",
          "content_same": false
        },
        {
          "line": 11835,
          "old_api": "set_key_image",
          "new_api": null,
          "old_text": "field->set_key_image(key, key_part->length)",
          "new_text": null,
          "old_line_content": "    field->set_key_image(key, key_part->length);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5692,
          "old_api": "type",
          "new_api": null,
          "old_text": "cond->type()",
          "new_text": null,
          "old_line_content": "  if (cond->type() != Item::FUNC_ITEM)",
          "new_line_content": "    MEM_ROOT *tmp_root= param->mem_root;",
          "content_same": false
        },
        {
          "line": 3645,
          "old_api": "fprintf",
          "new_api": null,
          "old_text": "fprintf(DBUG_FILE, \"%s%s\", p==parts?\"\":\" ,\", p->field->field_name)",
          "new_text": null,
          "old_line_content": "    fprintf(DBUG_FILE, \"%s%s\", p==parts?\"\":\" ,\", p->field->field_name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 11837,
          "old_api": "val_int_as_str",
          "new_api": null,
          "old_text": "field->val_int_as_str(&tmp, 1)",
          "new_text": null,
          "old_line_content": "      (void) field->val_int_as_str(&tmp, 1);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3647,
          "old_api": "fputs",
          "new_api": null,
          "old_text": "fputs(\");\\n\", DBUG_FILE)",
          "new_text": null,
          "old_line_content": "  fputs(\");\\n\", DBUG_FILE);",
          "new_line_content": "#ifndef DBUG_OFF",
          "content_same": false
        },
        {
          "line": 11839,
          "old_api": "val_str",
          "new_api": null,
          "old_text": "field->val_str(&tmp)",
          "new_text": null,
          "old_line_content": "      field->val_str(&tmp);",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 11842,
          "old_api": "fputc",
          "new_api": null,
          "old_text": "fputc('/',DBUG_FILE)",
          "new_text": null,
          "old_line_content": "      fputc('/',DBUG_FILE);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 5698,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(new SEL_TREE(SEL_TREE::MAYBE))",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(new SEL_TREE(SEL_TREE::MAYBE));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 9796,
          "old_api": "rewind",
          "new_api": null,
          "old_text": "select_items_it.rewind()",
          "new_text": null,
          "old_line_content": "        select_items_it.rewind();",
          "new_line_content": "      If GA2, then Store a new ORDER object in group_fields_array at the",
          "content_same": false
        },
        {
          "line": 11844,
          "old_api": "dbug_tmp_restore_column_maps",
          "new_api": null,
          "old_text": "dbug_tmp_restore_column_maps(table->read_set, table->write_set, old_sets)",
          "new_text": null,
          "old_line_content": "  dbug_tmp_restore_column_maps(table->read_set, table->write_set, old_sets);",
          "new_line_content": "      store_length--;",
          "content_same": false
        },
        {
          "line": 5702,
          "old_api": "functype",
          "new_api": null,
          "old_text": "cond_func->functype()",
          "new_text": null,
          "old_line_content": "  if (cond_func->functype() == Item_func::BETWEEN ||",
          "new_line_content": "\t\t          param->current_table);",
          "content_same": false
        },
        {
          "line": 3655,
          "old_api": "is_real_null",
          "new_api": null,
          "old_text": "field->is_real_null()",
          "new_text": null,
          "old_line_content": "  if (field->is_real_null())",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 7746,
          "old_api": "max",
          "new_api": null,
          "old_text": "max(param->max_key_part,key_tree->part)",
          "new_text": null,
          "old_line_content": "  param->max_key_part=max(param->max_key_part,key_tree->part);",
          "new_line_content": "static ha_rows",
          "content_same": false
        },
        {
          "line": 5706,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(0);\t\t\t       ",
          "new_line_content": "    if ((ref_tables & param->current_table) ||",
          "content_same": false
        },
        {
          "line": 9804,
          "old_api": "real_item",
          "new_api": null,
          "old_text": "item->real_item()",
          "new_text": null,
          "old_line_content": "        item_field= (Item_field*) item->real_item(); ",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 9805,
          "old_api": "real_item",
          "new_api": null,
          "old_text": "item->real_item()->type()",
          "new_text": null,
          "old_line_content": "        DBUG_ASSERT(item->real_item()->type() == Item::FIELD_ITEM);",
          "new_line_content": "      if (!is_agg_distinct)",
          "content_same": false
        },
        {
          "line": 3661,
          "old_api": "length",
          "new_api": null,
          "old_text": "str.length(0)",
          "new_text": null,
          "old_line_content": "    str.length(0);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3663,
          "old_api": "val_str",
          "new_api": null,
          "old_text": "field->val_str(&str)",
          "new_text": null,
          "old_line_content": "    pstr= field->val_str(&str);",
          "new_line_content": "/* Print field value into debug trace, in NULL-aware way. */",
          "content_same": false
        },
        {
          "line": 3664,
          "old_api": "c_ptr_safe",
          "new_api": null,
          "old_text": "pstr->c_ptr_safe()",
          "new_text": null,
          "old_line_content": "    fprintf(DBUG_FILE, \"'%s'\", pstr->c_ptr_safe());",
          "new_line_content": "static void dbug_print_field(Field *field)",
          "content_same": false
        },
        {
          "line": 5710,
          "old_api": "functype",
          "new_api": null,
          "old_text": "cond_func->functype()",
          "new_text": null,
          "old_line_content": "  switch (cond_func->functype()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 5712,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "cond_func->arguments()[0]->real_item()->type()",
          "new_text": null,
          "old_line_content": "    if (cond_func->arguments()[0]->real_item()->type() == Item::FIELD_ITEM)",
          "new_line_content": "  Item_func *cond_func= (Item_func*) cond;",
          "content_same": false
        },
        {
          "line": 11859,
          "old_api": "dbug_tmp_use_all_columns",
          "new_api": null,
          "old_text": "dbug_tmp_use_all_columns(table, old_sets, table->read_set, table->write_set)",
          "new_text": null,
          "old_line_content": "  dbug_tmp_use_all_columns(table, old_sets, table->read_set, table->write_set);",
          "new_line_content": "static void print_quick(QUICK_SELECT_I *quick, const key_map *needed_reg)",
          "content_same": false
        },
        {
          "line": 9812,
          "old_api": "get_field_keypart",
          "new_api": null,
          "old_text": "get_field_keypart(cur_index_info, item_field->field)",
          "new_text": null,
          "old_line_content": "        key_part_nr= get_field_keypart(cur_index_info, item_field->field);",
          "new_line_content": "             (Item *) agg_distinct_flds_it++ : select_items_it++)))",
          "content_same": false
        },
        {
          "line": 11860,
          "old_api": "dbug_dump",
          "new_api": null,
          "old_text": "quick->dbug_dump(0, TRUE)",
          "new_text": null,
          "old_line_content": "  quick->dbug_dump(0, TRUE);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 11861,
          "old_api": "dbug_tmp_restore_column_maps",
          "new_api": null,
          "old_text": "dbug_tmp_restore_column_maps(table->read_set, table->write_set, old_sets)",
          "new_text": null,
          "old_line_content": "  dbug_tmp_restore_column_maps(table->read_set, table->write_set, old_sets);",
          "new_line_content": "  char buf[MAX_KEY/8+1];",
          "content_same": false
        },
        {
          "line": 11863,
          "old_api": "print",
          "new_api": null,
          "old_text": "needed_reg->print(buf)",
          "new_text": null,
          "old_line_content": "  fprintf(DBUG_FILE,\"other_keys: 0x%s:\\n\", needed_reg->print(buf));",
          "new_line_content": "  my_bitmap_map *old_sets[2];",
          "content_same": false
        },
        {
          "line": 5715,
          "old_api": "get_full_func_mm_tree",
          "new_api": null,
          "old_text": "get_full_func_mm_tree(param, cond_func, field_item, NULL, inv)",
          "new_text": null,
          "old_line_content": "      ftree= get_full_func_mm_tree(param, cond_func, field_item, NULL, inv);",
          "new_line_content": "    inv= ((Item_func_opt_neg *) cond_func)->negated;",
          "content_same": false
        },
        {
          "line": 9817,
          "old_api": "is_set",
          "new_api": null,
          "old_text": "used_key_parts_map.is_set(key_part_nr)",
          "new_text": null,
          "old_line_content": "        if (used_key_parts_map.is_set(key_part_nr))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 7765,
          "old_api": "store_min",
          "new_api": null,
          "old_text": "key_tree->store_min(param->key[idx][key_tree->part].store_length,\n                                        &tmp_min_key, min_key_flag)",
          "new_text": null,
          "old_line_content": "  tmp_min_keypart+= key_tree->store_min(param->key[idx][key_tree->part].store_length,",
          "new_line_content": "    */",
          "content_same": false
        },
        {
          "line": 7769,
          "old_api": "uint) (tmp_min_key - param->min_key)",
          "new_api": null,
          "old_text": "uint) (tmp_min_key - param->min_key)",
          "new_text": null,
          "old_line_content": "  min_key_length= (uint) (tmp_min_key - param->min_key);",
          "new_line_content": "\t\t\t     max_key, max_key_flag, max_keypart);",
          "content_same": false
        },
        {
          "line": 3676,
          "old_api": "store_key_image_to_rec",
          "new_api": null,
          "old_text": "store_key_image_to_rec(part->field, arg->min_value, part->length)",
          "new_text": null,
          "old_line_content": "    store_key_image_to_rec(part->field, arg->min_value, part->length);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3677,
          "old_api": "dbug_print_field",
          "new_api": null,
          "old_text": "dbug_print_field(part->field)",
          "new_text": null,
          "old_line_content": "    dbug_print_field(part->field);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 5724,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "cond_func->arguments()[i]->real_item()->type()",
          "new_text": null,
          "old_line_content": "      if (cond_func->arguments()[i]->real_item()->type() == Item::FIELD_ITEM)",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3679,
          "old_api": "fputs",
          "new_api": null,
          "old_text": "fputs(\" < \", DBUG_FILE)",
          "new_text": null,
          "old_line_content": "      fputs(\" < \", DBUG_FILE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 9824,
          "old_api": "set_bit",
          "new_api": null,
          "old_text": "used_key_parts_map.set_bit(key_part_nr)",
          "new_text": null,
          "old_line_content": "        used_key_parts_map.set_bit(key_part_nr);",
          "new_line_content": "        /*",
          "content_same": false
        },
        {
          "line": 3681,
          "old_api": "fputs",
          "new_api": null,
          "old_text": "fputs(\" <= \", DBUG_FILE)",
          "new_text": null,
          "old_line_content": "      fputs(\" <= \", DBUG_FILE);",
          "new_line_content": "static void dbug_print_segment_range(SEL_ARG *arg, KEY_PART *part)",
          "content_same": false
        },
        {
          "line": 9826,
          "old_api": "max",
          "new_api": null,
          "old_text": "max(max_key_part,key_part_nr)",
          "new_text": null,
          "old_line_content": "        max_key_part= max(max_key_part,key_part_nr);",
          "new_line_content": "          If it was present, then its corresponding key part was alredy used.",
          "content_same": false
        },
        {
          "line": 11873,
          "old_api": "fprintf",
          "new_api": null,
          "old_text": "fprintf(DBUG_FILE, \"%*squick range select, key %s, length: %d\\n\",\n\t  indent, \"\", head->key_info[index].name, max_used_key_length)",
          "new_text": null,
          "old_line_content": "  fprintf(DBUG_FILE, \"%*squick range select, key %s, length: %d\\n\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3684,
          "old_api": "fprintf",
          "new_api": null,
          "old_text": "fprintf(DBUG_FILE, \"%s\", part->field->field_name)",
          "new_text": null,
          "old_line_content": "  fprintf(DBUG_FILE, \"%s\", part->field->field_name);",
          "new_line_content": "  DBUG_LOCK_FILE;",
          "content_same": false
        },
        {
          "line": 5727,
          "old_api": "get_full_func_mm_tree",
          "new_api": null,
          "old_text": "get_full_func_mm_tree(param, cond_func, \n                                    field_item, (Item*)(intptr)i, inv)",
          "new_text": null,
          "old_line_content": "        SEL_TREE *tmp= get_full_func_mm_tree(param, cond_func, ",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 5731,
          "old_api": "tree_or",
          "new_api": null,
          "old_text": "tree_or(param, tree, tmp)",
          "new_text": null,
          "old_line_content": "          tree= !tree ? tmp : tree_or(param, tree, tmp);",
          "new_line_content": "      the comments for the function get_full_func_mm_tree()",
          "content_same": false
        },
        {
          "line": 5736,
          "old_api": "tree_and",
          "new_api": null,
          "old_text": "tree_and(param, tree, tmp)",
          "new_text": null,
          "old_line_content": "          tree= tree_and(param, tree, tmp);",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 3689,
          "old_api": "fputs",
          "new_api": null,
          "old_text": "fputs(\" < \", DBUG_FILE)",
          "new_text": null,
          "old_line_content": "      fputs(\" < \", DBUG_FILE);",
          "new_line_content": "    if (arg->min_flag & NEAR_MIN)",
          "content_same": false
        },
        {
          "line": 7785,
          "old_api": "is_null_interval",
          "new_api": null,
          "old_text": "key_tree->is_null_interval()",
          "new_text": null,
          "old_line_content": "  if (!param->first_null_comp && key_tree->is_null_interval())",
          "new_line_content": "    /*",
          "content_same": false
        },
        {
          "line": 3691,
          "old_api": "fputs",
          "new_api": null,
          "old_text": "fputs(\" <= \", DBUG_FILE)",
          "new_text": null,
          "old_line_content": "      fputs(\" <= \", DBUG_FILE);",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 9836,
          "old_api": "to_ulonglong",
          "new_api": null,
          "old_text": "used_key_parts_map.to_ulonglong()",
          "new_text": null,
          "old_line_content": "      cur_parts= used_key_parts_map.to_ulonglong() >> 1;",
          "new_line_content": "        ++cur_group_key_parts;",
          "content_same": false
        },
        {
          "line": 3693,
          "old_api": "dbug_print_field",
          "new_api": null,
          "old_text": "dbug_print_field(part->field)",
          "new_text": null,
          "old_line_content": "    dbug_print_field(part->field);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 11883,
          "old_api": "fprintf",
          "new_api": null,
          "old_text": "fprintf(DBUG_FILE, \"%*s\", indent + 2, \"\")",
          "new_text": null,
          "old_line_content": "      fprintf(DBUG_FILE, \"%*s\", indent + 2, \"\");",
          "new_line_content": "  /* purecov: begin inspected */",
          "content_same": false
        },
        {
          "line": 11887,
          "old_api": "print_key",
          "new_api": null,
          "old_text": "print_key(key_parts, range->min_key, range->min_length)",
          "new_text": null,
          "old_line_content": "        print_key(key_parts, range->min_key, range->min_length);",
          "new_line_content": "  if (verbose)",
          "content_same": false
        },
        {
          "line": 11889,
          "old_api": "fputs",
          "new_api": null,
          "old_text": "fputs(\" < \",DBUG_FILE)",
          "new_text": null,
          "old_line_content": "\t  fputs(\" < \",DBUG_FILE);",
          "new_line_content": "    QUICK_RANGE *range;",
          "content_same": false
        },
        {
          "line": 5745,
          "old_api": "tree_and",
          "new_api": null,
          "old_text": "tree_and(param, ftree, tree)",
          "new_text": null,
          "old_line_content": "    ftree = tree_and(param, ftree, tree);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 11891,
          "old_api": "fputs",
          "new_api": null,
          "old_text": "fputs(\" <= \",DBUG_FILE)",
          "new_text": null,
          "old_line_content": "\t  fputs(\" <= \",DBUG_FILE);",
          "new_line_content": "    QUICK_RANGE **end_range= pr + ranges.elements;",
          "content_same": false
        },
        {
          "line": 9844,
          "old_api": "get_field_keypart",
          "new_api": null,
          "old_text": "get_field_keypart(cur_index_info, min_max_arg_item->field)",
          "new_text": null,
          "old_line_content": "      key_part_nr= get_field_keypart(cur_index_info, min_max_arg_item->field);",
          "new_line_content": "      */",
          "content_same": false
        },
        {
          "line": 11893,
          "old_api": "fputs",
          "new_api": null,
          "old_text": "fputs(\"X\",DBUG_FILE)",
          "new_text": null,
          "old_line_content": "      fputs(\"X\",DBUG_FILE);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 5750,
          "old_api": "key_item",
          "new_api": null,
          "old_text": "func->key_item()->real_item()->type()",
          "new_text": null,
          "old_line_content": "    if (func->key_item()->real_item()->type() != Item::FIELD_ITEM)",
          "new_line_content": "      { ",
          "content_same": false
        },
        {
          "line": 5751,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(0);",
          "new_line_content": "        tree= 0;",
          "content_same": false
        },
        {
          "line": 5752,
          "old_api": "key_item",
          "new_api": null,
          "old_text": "func->key_item()->real_item()",
          "new_text": null,
          "old_line_content": "    field_item= (Item_field*) (func->key_item()->real_item());",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 5753,
          "old_api": "get_full_func_mm_tree",
          "new_api": null,
          "old_text": "get_full_func_mm_tree(param, cond_func, field_item, NULL, inv)",
          "new_text": null,
          "old_line_content": "    ftree= get_full_func_mm_tree(param, cond_func, field_item, NULL, inv);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 7793,
          "old_api": "uint) (tmp_max_key - max_key)",
          "new_api": null,
          "old_text": "uint) (tmp_max_key - max_key)",
          "new_text": null,
          "old_line_content": "\t!memcmp(min_key, max_key, (uint) (tmp_max_key - max_key)) &&",
          "new_line_content": "      param->is_ror_scan= FALSE;",
          "content_same": false
        },
        {
          "line": 11901,
          "old_api": "print_key",
          "new_api": null,
          "old_text": "print_key(key_parts, range->max_key, range->max_length)",
          "new_text": null,
          "old_line_content": "        print_key(key_parts, range->max_key, range->max_length);",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 1663,
          "old_api": "init_ror_merged_scan",
          "new_api": null,
          "old_text": "quick->init_ror_merged_scan(FALSE)",
          "new_text": null,
          "old_line_content": "      if (quick->init_ror_merged_scan(FALSE))",
          "new_line_content": "      /*",
          "content_same": false
        },
        {
          "line": 1664,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(1)",
          "new_text": null,
          "old_line_content": "        DBUG_RETURN(1);",
          "new_line_content": "        Use mem_root of this \"QUICK\" as using the statement mem_root",
          "content_same": false
        },
        {
          "line": 11903,
          "old_api": "fputs",
          "new_api": null,
          "old_text": "fputs(\"\\n\",DBUG_FILE)",
          "new_text": null,
          "old_line_content": "      fputs(\"\\n\",DBUG_FILE);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 5759,
          "old_api": "get_const",
          "new_api": null,
          "old_text": "item_equal->get_const()",
          "new_text": null,
          "old_line_content": "    if (!(value= item_equal->get_const()))",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 5760,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(0);",
          "new_line_content": "    Item_func_in *func=(Item_func_in*) cond_func;",
          "content_same": false
        },
        {
          "line": 1668,
          "old_api": "queue_remove_all",
          "new_api": null,
          "old_text": "queue_remove_all(&queue)",
          "new_text": null,
          "old_line_content": "  queue_remove_all(&queue);",
          "new_line_content": "      */",
          "content_same": false
        },
        {
          "line": 3716,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"dbug_print_singlepoint_range\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"dbug_print_singlepoint_range\");",
          "new_line_content": "    dbug_print_singlepoint_range()",
          "content_same": false
        },
        {
          "line": 5766,
          "old_api": "cmp_type",
          "new_api": null,
          "old_text": "field->cmp_type()",
          "new_text": null,
          "old_line_content": "      Item_result cmp_type= field->cmp_type();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 7812,
          "old_api": "store_min_key",
          "new_api": null,
          "old_text": "key_tree->next_key_part->store_min_key(param->key[idx],\n                                             &tmp_min_key,\n                                             &tmp_min_flag,\n                                             MAX_KEY)",
          "new_text": null,
          "old_line_content": "      key_tree->next_key_part->store_min_key(param->key[idx],",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 5769,
          "old_api": "get_mm_parts",
          "new_api": null,
          "old_text": "get_mm_parts(param, cond, field, Item_func::EQ_FUNC,\n\t\t           value,cmp_type)",
          "new_text": null,
          "old_line_content": "        tree= get_mm_parts(param, cond, field, Item_func::EQ_FUNC,",
          "new_line_content": "    Item_equal *item_equal= (Item_equal *) cond;    ",
          "content_same": false
        },
        {
          "line": 7818,
          "old_api": "store_max_key",
          "new_api": null,
          "old_text": "key_tree->next_key_part->store_max_key(param->key[idx],\n                                             &tmp_max_key,\n                                             &tmp_max_flag,\n                                             MAX_KEY)",
          "new_text": null,
          "old_line_content": "      key_tree->next_key_part->store_max_key(param->key[idx],",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3723,
          "old_api": "fprintf",
          "new_api": null,
          "old_text": "fprintf(DBUG_FILE, \"%s%s=\", (arg==start)?\"\":\", \", field->field_name)",
          "new_text": null,
          "old_line_content": "    fprintf(DBUG_FILE, \"%s%s=\", (arg==start)?\"\":\", \", field->field_name);",
          "new_line_content": "*/",
          "content_same": false
        },
        {
          "line": 1676,
          "old_api": "reset",
          "new_api": null,
          "old_text": "quick->reset()",
          "new_text": null,
          "old_line_content": "    if ((error= quick->reset()))",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1677,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(error)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(error);",
          "new_line_content": "    scans_inited= TRUE;",
          "content_same": false
        },
        {
          "line": 1678,
          "old_api": "get_next",
          "new_api": null,
          "old_text": "quick->get_next()",
          "new_text": null,
          "old_line_content": "    if ((error= quick->get_next()))",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3724,
          "old_api": "dbug_print_field",
          "new_api": null,
          "old_text": "dbug_print_field(field)",
          "new_text": null,
          "old_line_content": "    dbug_print_field(field);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 11915,
          "old_api": "fprintf",
          "new_api": null,
          "old_text": "fprintf(DBUG_FILE, \"%*smerged scans {\\n\", indent, \"\")",
          "new_text": null,
          "old_line_content": "  fprintf(DBUG_FILE, \"%*smerged scans {\\n\", indent, \"\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3726,
          "old_api": "fputs",
          "new_api": null,
          "old_text": "fputs(\"\\n\", DBUG_FILE)",
          "new_text": null,
          "old_line_content": "  fputs(\"\\n\", DBUG_FILE);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1682,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(error)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(error);",
          "new_line_content": "    selects into the queue.",
          "content_same": false
        },
        {
          "line": 11917,
          "old_api": "dbug_dump",
          "new_api": null,
          "old_text": "quick->dbug_dump(indent+2, verbose)",
          "new_text": null,
          "old_line_content": "    quick->dbug_dump(indent+2, verbose);",
          "new_line_content": "  /* purecov: end */    ",
          "content_same": false
        },
        {
          "line": 1684,
          "old_api": "save_last_pos",
          "new_api": null,
          "old_text": "quick->save_last_pos()",
          "new_text": null,
          "old_line_content": "    quick->save_last_pos();",
          "new_line_content": "  List_iterator_fast<QUICK_SELECT_I> it(quick_selects);",
          "content_same": false
        },
        {
          "line": 1685,
          "old_api": "queue_insert",
          "new_api": null,
          "old_text": "queue_insert(&queue, (uchar*)quick)",
          "new_text": null,
          "old_line_content": "    queue_insert(&queue, (uchar*)quick);",
          "new_line_content": "  while ((quick= it++))",
          "content_same": false
        },
        {
          "line": 11920,
          "old_api": "fprintf",
          "new_api": null,
          "old_text": "fprintf(DBUG_FILE, \"%*sclustered PK quick:\\n\", indent, \"\")",
          "new_text": null,
          "old_line_content": "    fprintf(DBUG_FILE, \"%*sclustered PK quick:\\n\", indent, \"\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 11921,
          "old_api": "dbug_dump",
          "new_api": null,
          "old_text": "pk_quick_select->dbug_dump(indent+2, verbose)",
          "new_text": null,
          "old_line_content": "    pk_quick_select->dbug_dump(indent+2, verbose);",
          "new_line_content": "void QUICK_INDEX_MERGE_SELECT::dbug_dump(int indent, bool verbose)",
          "content_same": false
        },
        {
          "line": 9880,
          "old_api": "get_index_range_tree",
          "new_api": null,
          "old_text": "get_index_range_tree(cur_index, tree, param,\n                                                        &dummy)",
          "new_text": null,
          "old_line_content": "        SEL_ARG *index_range_tree= get_index_range_tree(cur_index, tree, param,",
          "new_line_content": "    first_non_infix_part= min_max_arg_part ?",
          "content_same": false
        },
        {
          "line": 11923,
          "old_api": "fprintf",
          "new_api": null,
          "old_text": "fprintf(DBUG_FILE, \"%*s}\\n\", indent, \"\")",
          "new_text": null,
          "old_line_content": "  fprintf(DBUG_FILE, \"%*s}\\n\", indent, \"\");",
          "new_line_content": "  List_iterator_fast<QUICK_RANGE_SELECT> it(quick_selects);",
          "content_same": false
        },
        {
          "line": 9882,
          "old_api": "get_constant_key_infix",
          "new_api": null,
          "old_text": "get_constant_key_infix(cur_index_info, index_range_tree,\n                                    first_non_group_part, min_max_arg_part,\n                                    last_part, thd, cur_key_infix, \n                                    &cur_key_infix_len,\n                                    &first_non_infix_part)",
          "new_text": null,
          "old_line_content": "        if (!get_constant_key_infix(cur_index_info, index_range_tree,",
          "new_line_content": "                             min_max_arg_part :",
          "content_same": false
        },
        {
          "line": 1690,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"error\", (\"ROR index_merge rnd_init call failed\"))",
          "new_text": null,
          "old_line_content": "    DBUG_PRINT(\"error\", (\"ROR index_merge rnd_init call failed\"));",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1691,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(error)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(error);",
          "new_line_content": "      if (error == HA_ERR_END_OF_FILE)",
          "content_same": false
        },
        {
          "line": 11930,
          "old_api": "fprintf",
          "new_api": null,
          "old_text": "fprintf(DBUG_FILE, \"%*squick ROR-intersect select, %scovering\\n\",\n          indent, \"\", need_to_fetch_row? \"\":\"non-\")",
          "new_text": null,
          "old_line_content": "  fprintf(DBUG_FILE, \"%*squick ROR-intersect select, %scovering\\n\",",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 1694,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(0);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 5783,
          "old_api": "have_rev_func",
          "new_api": null,
          "old_text": "cond_func->have_rev_func()",
          "new_text": null,
          "old_line_content": "    else if (cond_func->have_rev_func() &&",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 5784,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "cond_func->arguments()[1]->real_item()->type()",
          "new_text": null,
          "old_line_content": "             cond_func->arguments()[1]->real_item()->type() ==",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 11937,
          "old_api": "fprintf",
          "new_api": null,
          "old_text": "fprintf(DBUG_FILE, \"%*sclustered PK quick:\\n\", indent, \"\")",
          "new_text": null,
          "old_line_content": "    fprintf(DBUG_FILE, \"%*sclustered PK quick:\\n\", indent, \"\");",
          "new_line_content": "void QUICK_ROR_INTERSECT_SELECT::dbug_dump(int indent, bool verbose)",
          "content_same": false
        },
        {
          "line": 11938,
          "old_api": "dbug_dump",
          "new_api": null,
          "old_text": "cpk_quick->dbug_dump(indent+2, verbose)",
          "new_text": null,
          "old_line_content": "    cpk_quick->dbug_dump(indent+2, verbose);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 5787,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "cond_func->arguments()[1]->real_item()",
          "new_text": null,
          "old_line_content": "      field_item= (Item_field*) (cond_func->arguments()[1]->real_item());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 11940,
          "old_api": "fprintf",
          "new_api": null,
          "old_text": "fprintf(DBUG_FILE, \"%*s}\\n\", indent, \"\")",
          "new_text": null,
          "old_line_content": "  fprintf(DBUG_FILE, \"%*s}\\n\", indent, \"\");",
          "new_line_content": "  QUICK_RANGE_SELECT *quick;",
          "content_same": false
        },
        {
          "line": 5788,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "cond_func->arguments()",
          "new_text": null,
          "old_line_content": "      value= cond_func->arguments()[0];",
          "new_line_content": "  default:",
          "content_same": false
        },
        {
          "line": 7840,
          "old_api": "memcmp",
          "new_api": null,
          "old_text": "memcmp(param->min_key, param->max_key, min_key_length)",
          "new_text": null,
          "old_line_content": "      !memcmp(param->min_key, param->max_key, min_key_length) &&",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3751,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"get_sweep_read_cost\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"get_sweep_read_cost\");",
          "new_line_content": "  SYNOPSIS",
          "content_same": false
        },
        {
          "line": 3752,
          "old_api": "primary_key_is_clustered",
          "new_api": null,
          "old_text": "param->table->file->primary_key_is_clustered()",
          "new_text": null,
          "old_line_content": "  if (param->table->file->primary_key_is_clustered())",
          "new_line_content": "    get_sweep_read_cost()",
          "content_same": false
        },
        {
          "line": 1706,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"QUICK_ROR_UNION_SELECT::~QUICK_ROR_UNION_SELECT\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"QUICK_ROR_UNION_SELECT::~QUICK_ROR_UNION_SELECT\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1707,
          "old_api": "delete_queue",
          "new_api": null,
          "old_text": "delete_queue(&queue)",
          "new_text": null,
          "old_line_content": "  delete_queue(&queue);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": "delete_elements",
          "new_api": null,
          "old_text": "quick_selects.delete_elements()",
          "new_text": null,
          "old_line_content": "  quick_selects.delete_elements();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3754,
          "old_api": "read_time",
          "new_api": null,
          "old_text": "param->table->file->read_time(param->table->s->primary_key,\n                                          (uint)records, records)",
          "new_text": null,
          "old_line_content": "    result= param->table->file->read_time(param->table->s->primary_key,",
          "new_line_content": "      records          # of records to be retrieved",
          "content_same": false
        },
        {
          "line": 1710,
          "old_api": "ha_rnd_end",
          "new_api": null,
          "old_text": "head->file->ha_rnd_end()",
          "new_text": null,
          "old_line_content": "    head->file->ha_rnd_end();",
          "new_line_content": "QUICK_ROR_UNION_SELECT::push_quick_back(QUICK_SELECT_I *quick_sel_range)",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": "MYF",
          "new_api": null,
          "old_text": "MYF(0)",
          "new_text": null,
          "old_line_content": "  free_root(&alloc,MYF(0));",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 11947,
          "old_api": "fprintf",
          "new_api": null,
          "old_text": "fprintf(DBUG_FILE, \"%*squick ROR-union select\\n\", indent, \"\")",
          "new_text": null,
          "old_line_content": "  fprintf(DBUG_FILE, \"%*squick ROR-union select\\n\", indent, \"\");",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 11950,
          "old_api": "dbug_dump",
          "new_api": null,
          "old_text": "quick->dbug_dump(indent+2, verbose)",
          "new_text": null,
          "old_line_content": "    quick->dbug_dump(indent+2, verbose);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3760,
          "old_api": "ulonglong2double",
          "new_api": null,
          "old_text": "ulonglong2double(param->table->file->stats.data_file_length)",
          "new_text": null,
          "old_line_content": "      ceil(ulonglong2double(param->table->file->stats.data_file_length) /",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 5804,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"get_mm_parts\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"get_mm_parts\");",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 5812,
          "old_api": "used_tables",
          "new_api": null,
          "old_text": "value->used_tables()",
          "new_text": null,
          "old_line_content": "      value->used_tables() & ~(param->prev_tables | param->read_tables))",
          "new_line_content": "\t     Item_func::Functype type,",
          "content_same": false
        },
        {
          "line": 5813,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(0);",
          "new_line_content": "\t     Item *value, Item_result cmp_type)",
          "content_same": false
        },
        {
          "line": 3766,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\",(\"sweep: nblocks: %g, busy_blocks: %g\", n_blocks,\n                       busy_blocks))",
          "new_text": null,
          "old_line_content": "    DBUG_PRINT(\"info\",(\"sweep: nblocks: %g, busy_blocks: %g\", n_blocks,",
          "new_line_content": "                                          (uint)records, records);",
          "content_same": false
        },
        {
          "line": 7860,
          "old_api": "uint) (tmp_max_key - max_key)",
          "new_api": null,
          "old_text": "uint) (tmp_max_key - max_key)",
          "new_text": null,
          "old_line_content": "            !memcmp(min_key, max_key, (uint) (tmp_max_key - max_key)) &&",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 5816,
          "old_api": "eq",
          "new_api": null,
          "old_text": "field->eq(key_part->field)",
          "new_text": null,
          "old_line_content": "    if (field->eq(key_part->field))",
          "new_line_content": "  if (field->table != param->table)",
          "content_same": false
        },
        {
          "line": 7862,
          "old_api": "is_key_scan_ror",
          "new_api": null,
          "old_text": "is_key_scan_ror(param, keynr, key_tree->part + 1)",
          "new_text": null,
          "old_line_content": "            is_key_scan_ror(param, keynr, key_tree->part + 1)))",
          "new_line_content": "        If we get here, the condition on the key was converted to form",
          "content_same": false
        },
        {
          "line": 5820,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "\tDBUG_RETURN(0);\t\t\t\t// OOM",
          "new_line_content": "  KEY_PART *end = param->key_parts_end;",
          "content_same": false
        },
        {
          "line": 9917,
          "old_api": "walk",
          "new_api": null,
          "old_text": "join->conds->walk(&Item::find_item_in_field_list_processor, 0,\n                              (uchar*) key_part_range)",
          "new_text": null,
          "old_line_content": "        if (join->conds->walk(&Item::find_item_in_field_list_processor, 0,",
          "new_line_content": "          GROUP BY/DISTINCT.",
          "content_same": false
        },
        {
          "line": 5821,
          "old_api": "used_tables",
          "new_api": null,
          "old_text": "value->used_tables()",
          "new_text": null,
          "old_line_content": "      if (!value || !(value->used_tables() & ~param->read_tables))",
          "new_line_content": "  SEL_TREE *tree=0;",
          "content_same": false
        },
        {
          "line": 7872,
          "old_api": "make_keypart_map",
          "new_api": null,
          "old_text": "make_keypart_map(tmp_min_keypart)",
          "new_text": null,
          "old_line_content": "      min_range.keypart_map= make_keypart_map(tmp_min_keypart);",
          "new_line_content": "            !key_tree->min_flag && !key_tree->max_flag &&",
          "content_same": false
        },
        {
          "line": 7874,
          "old_api": "ha_rkey_function) (tmp_min_flag ^ GEOM_FLAG)",
          "new_api": null,
          "old_text": "ha_rkey_function) (tmp_min_flag ^ GEOM_FLAG)",
          "new_text": null,
          "old_line_content": "      min_range.flag=   (ha_rkey_function) (tmp_min_flag ^ GEOM_FLAG);",
          "new_line_content": "        param->is_ror_scan= FALSE;",
          "content_same": false
        },
        {
          "line": 7876,
          "old_api": "records_in_range",
          "new_api": null,
          "old_text": "param->table->file->records_in_range(keynr,\n                                                &min_range, (key_range*) 0)",
          "new_text": null,
          "old_line_content": "      tmp= param->table->file->records_in_range(keynr,",
          "new_line_content": "    param->n_ranges++;",
          "content_same": false
        },
        {
          "line": 5830,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(tree)",
          "new_text": null,
          "old_line_content": "\t  DBUG_RETURN(tree);",
          "new_line_content": "      if (!tree && !(tree=new SEL_TREE()))",
          "content_same": false
        },
        {
          "line": 8079,
          "old_api": "uint)(tmp_max_key - max_key)",
          "new_api": null,
          "old_text": "uint)(tmp_max_key - max_key)",
          "new_text": null,
          "old_line_content": "         memcmp(min_key, max_key, (uint)(tmp_max_key - max_key))==0 &&",
          "new_line_content": "  uchar *tmp_min_key=min_key,*tmp_max_key=max_key;",
          "content_same": false
        },
        {
          "line": 11977,
          "old_api": "fprintf",
          "new_api": null,
          "old_text": "fprintf(DBUG_FILE,\n          \"%*squick_group_min_max_select: index %s (%d), length: %d\\n\",\n\t  indent, \"\", index_info->name, index, max_used_key_length)",
          "new_text": null,
          "old_line_content": "  fprintf(DBUG_FILE,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 9933,
          "old_api": "bitmap_is_set",
          "new_api": null,
          "old_text": "bitmap_is_set(table->read_set, cur_part->field->field_index)",
          "new_text": null,
          "old_line_content": "        if (bitmap_is_set(table->read_set, cur_part->field->field_index))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3790,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"return\",(\"cost: %g\", result))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"return\",(\"cost: %g\", result));",
          "new_line_content": "                          DISK_SEEK_PROP_COST*n_blocks/busy_blocks);",
          "content_same": false
        },
        {
          "line": 3791,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(result)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(result);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 11982,
          "old_api": "fprintf",
          "new_api": null,
          "old_text": "fprintf(DBUG_FILE, \"%*susing key_infix with length %d:\\n\",\n            indent, \"\", key_infix_len)",
          "new_text": null,
          "old_line_content": "    fprintf(DBUG_FILE, \"%*susing key_infix with length %d:\\n\",",
          "new_line_content": "  RETURN",
          "content_same": false
        },
        {
          "line": 5837,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(0)",
          "new_text": null,
          "old_line_content": "\t  DBUG_RETURN(0);\t\t\t// OOM",
          "new_line_content": "\t  continue;",
          "content_same": false
        },
        {
          "line": 5840,
          "old_api": "sel_add",
          "new_api": null,
          "old_text": "sel_add(tree->keys[key_part->key],sel_arg)",
          "new_text": null,
          "old_line_content": "      tree->keys[key_part->key]=sel_add(tree->keys[key_part->key],sel_arg);",
          "new_line_content": "\t  tree->type=SEL_TREE::IMPOSSIBLE;",
          "content_same": false
        },
        {
          "line": 11987,
          "old_api": "fprintf",
          "new_api": null,
          "old_text": "fprintf(DBUG_FILE, \"%*susing quick_range_select:\\n\", indent, \"\")",
          "new_text": null,
          "old_line_content": "    fprintf(DBUG_FILE, \"%*susing quick_range_select:\\n\", indent, \"\");",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1748,
          "old_api": "real_maybe_null",
          "new_api": null,
          "old_text": "f->real_maybe_null()",
          "new_text": null,
          "old_line_content": "  :min_flag(0), max_flag(0), maybe_flag(0), maybe_null(f->real_maybe_null()),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5845,
          "old_api": "is_clear_all",
          "new_api": null,
          "old_text": "tree->keys_map.is_clear_all()",
          "new_text": null,
          "old_line_content": "  if (tree && tree->merges.is_empty() && tree->keys_map.is_clear_all())",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 7892,
          "old_api": "make_keypart_map",
          "new_api": null,
          "old_text": "make_keypart_map(tmp_max_keypart)",
          "new_text": null,
          "old_line_content": "      max_range.keypart_map= make_keypart_map(tmp_max_keypart);",
          "new_line_content": "      key_range min_range, max_range;",
          "content_same": false
        },
        {
          "line": 5847,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(tree)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(tree);",
          "new_line_content": "\tif (!(sel_arg= new SEL_ARG(SEL_ARG::MAYBE_KEY)))",
          "content_same": false
        },
        {
          "line": 11992,
          "old_api": "fprintf",
          "new_api": null,
          "old_text": "fprintf(DBUG_FILE, \"%*susing %d quick_ranges for MIN/MAX:\\n\",\n            indent, \"\", min_max_ranges.elements)",
          "new_text": null,
          "old_line_content": "    fprintf(DBUG_FILE, \"%*susing %d quick_ranges for MIN/MAX:\\n\",",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 7893,
          "old_api": "records_in_range",
          "new_api": null,
          "old_text": "param->table->file->records_in_range(keynr,\n                                               (min_key_length ? &min_range :\n                                                (key_range*) 0),\n                                               (max_key_length ? &max_range :\n                                                (key_range*) 0))",
          "new_text": null,
          "old_line_content": "      tmp=param->table->file->records_in_range(keynr,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 9946,
          "old_api": "get_index_range_tree",
          "new_api": null,
          "old_text": "get_index_range_tree(cur_index, tree, param,\n                                                      &dummy)",
          "new_text": null,
          "old_line_content": "      SEL_ARG *index_range_tree= get_index_range_tree(cur_index, tree, param,",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 9949,
          "old_api": "get_sel_arg_for_keypart",
          "new_api": null,
          "old_text": "get_sel_arg_for_keypart(min_max_arg_part->field,\n                                  index_range_tree, &cur_range)",
          "new_text": null,
          "old_line_content": "      if (get_sel_arg_for_keypart(min_max_arg_part->field,",
          "new_line_content": "    /**",
          "content_same": false
        },
        {
          "line": 5855,
          "old_api": "real_maybe_null",
          "new_api": null,
          "old_text": "field->real_maybe_null()",
          "new_text": null,
          "old_line_content": "  uint maybe_null=(uint) field->real_maybe_null();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1760,
          "old_api": "real_maybe_null",
          "new_api": null,
          "old_text": "field_->real_maybe_null()",
          "new_text": null,
          "old_line_content": "   part(part_),maybe_null(field_->real_maybe_null()), elements(1),use_count(1),",
          "new_line_content": "   elements(1), use_count(1), field(f), min_value((uchar*) min_value_arg),",
          "content_same": false
        },
        {
          "line": 9958,
          "old_api": "uint) \n                     (first_non_infix_part - first_non_group_part)",
          "new_api": null,
          "old_text": "uint) \n                     (first_non_infix_part - first_non_group_part)",
          "new_text": null,
          "old_line_content": "    key_infix_parts= cur_key_infix_len ? (uint) ",
          "new_line_content": "                                                      &dummy);",
          "content_same": false
        },
        {
          "line": 5862,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"get_mm_leaf\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"get_mm_leaf\");",
          "new_line_content": "static SEL_ARG *",
          "content_same": false
        },
        {
          "line": 7913,
          "old_api": "check_quick_keys",
          "new_api": null,
          "old_text": "check_quick_keys(param, idx, key_tree->right,\n                         min_key, min_key_flag, min_keypart,\n                         max_key, max_key_flag, max_keypart)",
          "new_text": null,
          "old_line_content": "    tmp=check_quick_keys(param, idx, key_tree->right,",
          "new_line_content": "    return tmp;",
          "content_same": false
        },
        {
          "line": 9966,
          "old_api": "get_index_range_tree",
          "new_api": null,
          "old_text": "get_index_range_tree(cur_index, tree, param,\n                                           &cur_param_idx)",
          "new_text": null,
          "old_line_content": "      cur_index_tree= get_index_range_tree(cur_index, tree, param,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 9972,
          "old_api": "cost_group_min_max",
          "new_api": null,
          "old_text": "cost_group_min_max(table, cur_index_info, cur_used_key_parts,\n                       cur_group_key_parts, tree, cur_index_tree,\n                       cur_quick_prefix_records, have_min, have_max,\n                       &cur_read_cost, &cur_records)",
          "new_text": null,
          "old_line_content": "    cost_group_min_max(table, cur_index_info, cur_used_key_parts,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1793,
          "old_api": "clone",
          "new_api": null,
          "old_text": "left->clone(param, tmp, next_arg)",
          "new_text": null,
          "old_line_content": "      if (!(tmp->left=left->clone(param, tmp, next_arg)))",
          "new_line_content": "    (*next_arg)= tmp;",
          "content_same": false
        },
        {
          "line": 1801,
          "old_api": "clone",
          "new_api": null,
          "old_text": "right->clone(param, tmp, next_arg)",
          "new_text": null,
          "old_line_content": "      if (!(tmp->right= right->clone(param, tmp, next_arg)))",
          "new_line_content": "    tmp->parent=new_parent;",
          "content_same": false
        },
        {
          "line": 9994,
          "old_api": "memcpy (key_infix, cur_key_infix, sizeof (key_infix))",
          "new_api": null,
          "old_text": "memcpy (key_infix, cur_key_infix, sizeof (key_infix))",
          "new_text": null,
          "old_line_content": "        memcpy (key_infix, cur_key_infix, sizeof (key_infix));",
          "new_line_content": "      index_info= cur_index_info;",
          "content_same": false
        },
        {
          "line": 10001,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "      group_key_parts= cur_group_key_parts;",
          "content_same": false
        },
        {
          "line": 5905,
          "old_api": "result_type",
          "new_api": null,
          "old_text": "field->result_type()",
          "new_text": null,
          "old_line_content": "  if (field->result_type() == STRING_RESULT &&",
          "new_line_content": "    1. Usually we can't use an index if the column collation",
          "content_same": false
        },
        {
          "line": 5906,
          "old_api": "match_collation_to_optimize_range",
          "new_api": null,
          "old_text": "(Field_str*) field)->match_collation_to_optimize_range()",
          "new_text": null,
          "old_line_content": "      ((Field_str*) field)->match_collation_to_optimize_range() &&",
          "new_line_content": "       differ from the operation collation.",
          "content_same": false
        },
        {
          "line": 5907,
          "old_api": "result_type",
          "new_api": null,
          "old_text": "value->result_type()",
          "new_text": null,
          "old_line_content": "      value->result_type() == STRING_RESULT &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5909,
          "old_api": "compare_collation",
          "new_api": null,
          "old_text": "conf_func->compare_collation()",
          "new_text": null,
          "old_line_content": "      ((Field_str*)field)->charset() != conf_func->compare_collation() &&",
          "new_line_content": "       the binary searches:",
          "content_same": false
        },
        {
          "line": 5910,
          "old_api": "compare_collation",
          "new_api": null,
          "old_text": "conf_func->compare_collation()",
          "new_text": null,
          "old_line_content": "      !(conf_func->compare_collation()->state & MY_CS_BINSORT &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 10008,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 10014,
          "old_api": "primary_key_is_clustered",
          "new_api": null,
          "old_text": "table->file->primary_key_is_clustered()",
          "new_text": null,
          "old_line_content": "      table->file->primary_key_is_clustered())",
          "new_line_content": "  /* Check (SA3) for the where clause. */",
          "content_same": false
        },
        {
          "line": 10015,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "  if (join->conds && min_max_arg_item &&",
          "content_same": false
        },
        {
          "line": 3874,
          "old_api": "primary_key_is_clustered",
          "new_api": null,
          "old_text": "param->table->file->primary_key_is_clustered()",
          "new_text": null,
          "old_line_content": "  bool pk_is_clustered= param->table->file->primary_key_is_clustered();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 7972,
          "old_api": "primary_key_is_clustered",
          "new_api": null,
          "old_text": "param->table->file->primary_key_is_clustered()",
          "new_text": null,
          "old_line_content": "  if (!param->table->file->primary_key_is_clustered() || pk_number == MAX_KEY)",
          "new_line_content": "static bool is_key_scan_ror(PARAM *param, uint keynr, uint8 nparts)",
          "content_same": false
        },
        {
          "line": 1829,
          "old_api": "first",
          "new_api": null,
          "old_text": "const_cast<SEL_ARG*>(this)->first()",
          "new_text": null,
          "old_line_content": "  return const_cast<SEL_ARG*>(this)->first();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3883,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"get_best_disjunct_quick\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"get_best_disjunct_quick\");",
          "new_line_content": "  ha_rows cpk_scan_records= 0;",
          "content_same": false
        },
        {
          "line": 3884,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"Full table scan cost: %g\", read_time))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\", (\"Full table scan cost: %g\", read_time));",
          "new_line_content": "  ha_rows non_cpk_scan_records= 0;",
          "content_same": false
        },
        {
          "line": 10030,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(NULL);",
          "new_line_content": "                 TRP_GROUP_MIN_MAX(have_min, have_max, is_agg_distinct,",
          "content_same": false
        },
        {
          "line": 3886,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(param->mem_root,\n                                             sizeof(TRP_RANGE*)*\n                                             n_child_scans)",
          "new_text": null,
          "old_line_content": "  if (!(range_scans= (TRP_RANGE**)alloc_root(param->mem_root,",
          "new_line_content": "  bool all_scans_ror_able= TRUE;",
          "content_same": false
        },
        {
          "line": 3889,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(NULL);",
          "new_line_content": "  TABLE_READ_PLAN **roru_read_plans;",
          "content_same": false
        },
        {
          "line": 5937,
          "old_api": "optimize_range",
          "new_api": null,
          "old_text": "field->optimize_range(param->real_keynr[key_part->key],\n                                          key_part->part)",
          "new_text": null,
          "old_line_content": "    optimize_range= field->optimize_range(param->real_keynr[key_part->key],",
          "new_line_content": "      break;",
          "content_same": false
        },
        {
          "line": 10037,
          "old_api": "use_index_scan",
          "new_api": null,
          "old_text": "read_plan->use_index_scan()",
          "new_text": null,
          "old_line_content": "      read_plan->use_index_scan();",
          "new_line_content": "                                   best_quick_prefix_records);",
          "content_same": false
        },
        {
          "line": 10040,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\",\n               (\"Returning group min/max plan: cost: %g, records: %lu\",\n                read_plan->read_cost, (ulong) read_plan->records))",
          "new_text": null,
          "old_line_content": "    DBUG_PRINT(\"info\",",
          "new_line_content": "    if (tree && read_plan->quick_prefix_records == 0)",
          "content_same": false
        },
        {
          "line": 3899,
          "old_api": "print_sel_tree",
          "new_api": null,
          "old_text": "print_sel_tree(param, *ptree, &(*ptree)->keys_map,\n                                        \"tree in SEL_IMERGE\")",
          "new_text": null,
          "old_line_content": "    DBUG_EXECUTE(\"info\", print_sel_tree(param, *ptree, &(*ptree)->keys_map,",
          "new_line_content": "                                             n_child_scans)))",
          "content_same": false
        },
        {
          "line": 10045,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(read_plan)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(read_plan);",
          "new_line_content": "    if (read_time < best_read_cost && is_agg_distinct)",
          "content_same": false
        },
        {
          "line": 3901,
          "old_api": "get_key_scans_params",
          "new_api": null,
          "old_text": "get_key_scans_params(param, *ptree, TRUE, FALSE, read_time)",
          "new_text": null,
          "old_line_content": "    if (!(*cur_child= get_key_scans_params(param, *ptree, TRUE, FALSE, read_time)))",
          "new_line_content": "  /*",
          "content_same": false
        },
        {
          "line": 5949,
          "old_api": "pack_length",
          "new_api": null,
          "old_text": "field->pack_length()",
          "new_text": null,
          "old_line_content": "    uint field_length= field->pack_length()+maybe_null;",
          "new_line_content": "                                          key_part->part);",
          "content_same": false
        },
        {
          "line": 5953,
          "old_api": "val_str",
          "new_api": null,
          "old_text": "value->val_str(&tmp)",
          "new_text": null,
          "old_line_content": "    if (!(res= value->val_str(&tmp)))",
          "new_line_content": "  if (type == Item_func::LIKE_FUNC)",
          "content_same": false
        },
        {
          "line": 1863,
          "old_api": "real_maybe_null",
          "new_api": null,
          "old_text": "field->real_maybe_null()",
          "new_text": null,
          "old_line_content": "  if (field->real_maybe_null())\t\t\t// If null is part of key",
          "new_line_content": "  /* First check if there was a compare to a min or max element */",
          "content_same": false
        },
        {
          "line": 5966,
          "old_api": "copy",
          "new_api": null,
          "old_text": "tmp.copy(*res)",
          "new_text": null,
          "old_line_content": "      tmp.copy(*res);\t\t\t\t// Get own copy",
          "new_line_content": "      tree= &null_element;",
          "content_same": false
        },
        {
          "line": 8015,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"get_quick_select\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"get_quick_select\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1873,
          "old_api": "key_cmp",
          "new_api": null,
          "old_text": "field->key_cmp(a , b)",
          "new_text": null,
          "old_line_content": "  cmp=field->key_cmp(a , b);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5969,
          "old_api": "cmp_type",
          "new_api": null,
          "old_text": "field->cmp_type()",
          "new_text": null,
          "old_line_content": "    if (field->cmp_type() != STRING_RESULT)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8020,
          "old_api": "test",
          "new_api": null,
          "old_text": "test(parent_alloc)",
          "new_text": null,
          "old_line_content": "                                      test(parent_alloc),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3928,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"index_merge scans cost %g\", imerge_cost))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\", (\"index_merge scans cost %g\", imerge_cost));",
          "new_line_content": "    if (pk_is_clustered &&",
          "content_same": false
        },
        {
          "line": 8025,
          "old_api": "test",
          "new_api": null,
          "old_text": "test(parent_alloc)",
          "new_text": null,
          "old_line_content": "                                 test(parent_alloc));",
          "new_line_content": "  QUICK_RANGE_SELECT *quick;",
          "content_same": false
        },
        {
          "line": 10075,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"check_group_min_max_predicates\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"check_group_min_max_predicates\");",
          "new_line_content": "    predicates: {=, !=, <, <=, >, >=, between, is null, is not null}.",
          "content_same": false
        },
        {
          "line": 10076,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(cond && min_max_arg_item)",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(cond && min_max_arg_item);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 10078,
          "old_api": "real_item",
          "new_api": null,
          "old_text": "cond->real_item()",
          "new_text": null,
          "old_line_content": "  cond= cond->real_item();",
          "new_line_content": "    TRUE  if cond passes the test",
          "content_same": false
        },
        {
          "line": 10079,
          "old_api": "type",
          "new_api": null,
          "old_text": "cond->type()",
          "new_text": null,
          "old_line_content": "  Item::Type cond_type= cond->type();",
          "new_line_content": "    FALSE o/w",
          "content_same": false
        },
        {
          "line": 5983,
          "old_api": "unlikely",
          "new_api": null,
          "old_text": "unlikely(length < field_length)",
          "new_text": null,
          "old_line_content": "      if (unlikely(length < field_length))",
          "new_line_content": "    offset=maybe_null;",
          "content_same": false
        },
        {
          "line": 3937,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"Sum of index_merge scans is more expensive than \"\n                        \"full table scan, bailing out\"))",
          "new_text": null,
          "old_line_content": "    DBUG_PRINT(\"info\", (\"Sum of index_merge scans is more expensive than \"",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 10082,
          "old_api": "func_name",
          "new_api": null,
          "old_text": "(Item_func*) cond)->func_name()",
          "new_text": null,
          "old_line_content": "    DBUG_PRINT(\"info\", (\"Analyzing: %s\", ((Item_func*) cond)->func_name()));",
          "new_line_content": "static bool",
          "content_same": false
        },
        {
          "line": 10083,
          "old_api": "argument_list",
          "new_api": null,
          "old_text": "(Item_cond*) cond)->argument_list()",
          "new_text": null,
          "old_line_content": "    List_iterator_fast<Item> li(*((Item_cond*) cond)->argument_list());",
          "new_line_content": "check_group_min_max_predicates(COND *cond, Item_field *min_max_arg_item,",
          "content_same": false
        },
        {
          "line": 8030,
          "old_api": "get_quick_keys",
          "new_api": null,
          "old_text": "get_quick_keys(param,quick,param->key[idx],key_tree,param->min_key,0,\n\t\t       param->max_key,0)",
          "new_text": null,
          "old_line_content": "\tget_quick_keys(param,quick,param->key[idx],key_tree,param->min_key,0,",
          "new_line_content": "                                      param->real_keynr[idx],",
          "content_same": false
        },
        {
          "line": 8039,
          "old_api": "memdup_root",
          "new_api": null,
          "old_text": "memdup_root(parent_alloc? parent_alloc : &quick->alloc,\n                    (char*) param->key[idx],\n                    sizeof(KEY_PART)*\n                    param->table->key_info[param->real_keynr[idx]].key_parts)",
          "new_text": null,
          "old_line_content": "        memdup_root(parent_alloc? parent_alloc : &quick->alloc,",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 1896,
          "old_api": "clone",
          "new_api": null,
          "old_text": "clone(param, (SEL_ARG *) 0, &next_arg)",
          "new_text": null,
          "old_line_content": "  if (!(root= clone(param, (SEL_ARG *) 0, &next_arg)))",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 10091,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(TRUE)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(TRUE);",
          "new_line_content": "  if (cond_type == Item::COND_ITEM) /* 'AND' or 'OR' */",
          "content_same": false
        },
        {
          "line": 5995,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(alloc, length*2)",
          "new_text": null,
          "old_line_content": "    if (!(min_str= (uchar*) alloc_root(alloc, length*2)))",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 8045,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(quick)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(quick);",
          "new_line_content": "      quick=0;",
          "content_same": false
        },
        {
          "line": 6003,
          "old_api": "charset",
          "new_api": null,
          "old_text": "field->charset()",
          "new_text": null,
          "old_line_content": "    like_error= my_like_range(field->charset(),",
          "new_line_content": "\tfield_length= length;",
          "content_same": false
        },
        {
          "line": 6004,
          "old_api": "length",
          "new_api": null,
          "old_text": "res->length()",
          "new_text": null,
          "old_line_content": "\t\t\t      res->ptr(), res->length(),",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 10104,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(FALSE)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(FALSE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3964,
          "old_api": "get_sweep_read_cost",
          "new_api": null,
          "old_text": "get_sweep_read_cost(param, non_cpk_scan_records)",
          "new_text": null,
          "old_line_content": "  imerge_cost += get_sweep_read_cost(param, non_cpk_scan_records);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3965,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\",(\"index_merge cost with rowid-to-row scan: %g\",\n                     imerge_cost))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\",(\"index_merge cost with rowid-to-row scan: %g\",",
          "new_line_content": "  if (cpk_scan)",
          "content_same": false
        },
        {
          "line": 10112,
          "old_api": "full_name",
          "new_api": null,
          "old_text": "cond->full_name()",
          "new_text": null,
          "old_line_content": "    DBUG_PRINT(\"info\", (\"Analyzing: %s\", cond->full_name()));",
          "new_line_content": "    so.",
          "content_same": false
        },
        {
          "line": 10113,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(TRUE)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(TRUE);",
          "new_line_content": "  */",
          "content_same": false
        },
        {
          "line": 3968,
          "old_api": "optimizer_flag",
          "new_api": null,
          "old_text": "optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_SORT_UNION)",
          "new_text": null,
          "old_line_content": "      !optimizer_flag(param->thd, OPTIMIZER_SWITCH_INDEX_MERGE_SORT_UNION))",
          "new_line_content": "      Add one ROWID comparison for each row retrieved on non-CPK scan.  (it",
          "content_same": false
        },
        {
          "line": 6016,
          "old_api": "int2store",
          "new_api": null,
          "old_text": "int2store(max_str+maybe_null,max_length)",
          "new_text": null,
          "old_line_content": "      int2store(max_str+maybe_null,max_length);",
          "new_line_content": "\t\t\t      ((Item_func_like*)(param->cond))->escape,",
          "content_same": false
        },
        {
          "line": 8064,
          "old_api": "get_quick_keys",
          "new_api": null,
          "old_text": "get_quick_keys(param,quick,key,key_tree->left,\n\t\t       min_key,min_key_flag, max_key, max_key_flag)",
          "new_text": null,
          "old_line_content": "    if (get_quick_keys(param,quick,key,key_tree->left,",
          "new_line_content": "get_quick_keys(PARAM *param,QUICK_RANGE_SELECT *quick,KEY_PART *key,",
          "content_same": false
        },
        {
          "line": 10117,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(cond_type == Item::FUNC_ITEM)",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(cond_type == Item::FUNC_ITEM);",
          "new_line_content": "  /*",
          "content_same": false
        },
        {
          "line": 8069,
          "old_api": "store_min",
          "new_api": null,
          "old_text": "key_tree->store_min(key[key_tree->part].store_length,\n                                 &tmp_min_key,min_key_flag)",
          "new_text": null,
          "old_line_content": "  min_part+= key_tree->store_min(key[key_tree->part].store_length,",
          "new_line_content": "  uint flag;",
          "content_same": false
        },
        {
          "line": 8071,
          "old_api": "store_max",
          "new_api": null,
          "old_text": "key_tree->store_max(key[key_tree->part].store_length,\n                                 &tmp_max_key,max_key_flag)",
          "new_text": null,
          "old_line_content": "  max_part+= key_tree->store_max(key[key_tree->part].store_length,",
          "new_line_content": "      max_part= key_tree->part-1; // # of keypart values in max_key buffer",
          "content_same": false
        },
        {
          "line": 10121,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "pred->arguments()",
          "new_text": null,
          "old_line_content": "  Item **arguments= pred->arguments();",
          "new_line_content": "  if (cond_type == Item::FIELD_ITEM)",
          "content_same": false
        },
        {
          "line": 3980,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(param->mem_root,\n                                                     unique_calc_buff_size)",
          "new_text": null,
          "old_line_content": "    if (!(param->imerge_cost_buff= (uint*)alloc_root(param->mem_root,",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 10126,
          "old_api": "real_item",
          "new_api": null,
          "old_text": "arguments[arg_idx]->real_item()",
          "new_text": null,
          "old_line_content": "    cur_arg= arguments[arg_idx]->real_item();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 10127,
          "old_api": "full_name",
          "new_api": null,
          "old_text": "cur_arg->full_name()",
          "new_text": null,
          "old_line_content": "    DBUG_PRINT(\"info\", (\"cur_arg: %s\", cur_arg->full_name()));",
          "new_line_content": "  /* We presume that at this point there are no other Items than functions. */",
          "content_same": false
        },
        {
          "line": 3982,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(NULL)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(NULL);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 6031,
          "old_api": "result_type",
          "new_api": null,
          "old_text": "field->result_type()",
          "new_text": null,
          "old_line_content": "  if (field->result_type() == STRING_RESULT &&",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 10130,
          "old_api": "eq",
          "new_api": null,
          "old_text": "min_max_arg_item->eq(cur_arg, 1)",
          "new_text": null,
          "old_line_content": "      if (min_max_arg_item->eq(cur_arg, 1)) ",
          "new_line_content": "  /* Test if cond references only group-by or non-group fields. */",
          "content_same": false
        },
        {
          "line": 3987,
          "old_api": "Unique::get_use_cost(param->imerge_cost_buff, (uint)non_cpk_scan_records,\n                         param->table->file->ref_length,\n                         param->thd->variables.sortbuff_size)",
          "new_api": null,
          "old_text": "Unique::get_use_cost(param->imerge_cost_buff, (uint)non_cpk_scan_records,\n                         param->table->file->ref_length,\n                         param->thd->variables.sortbuff_size)",
          "new_text": null,
          "old_line_content": "    Unique::get_use_cost(param->imerge_cost_buff, (uint)non_cpk_scan_records,",
          "new_line_content": "                                    param->table->file->ref_length,",
          "content_same": false
        },
        {
          "line": 6032,
          "old_api": "result_type",
          "new_api": null,
          "old_text": "value->result_type()",
          "new_text": null,
          "old_line_content": "      value->result_type() != STRING_RESULT &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 6033,
          "old_api": "result_type",
          "new_api": null,
          "old_text": "value->result_type()",
          "new_text": null,
          "old_line_content": "      field->cmp_type() != value->result_type())",
          "new_line_content": "  if (!optimize_range &&",
          "content_same": false
        },
        {
          "line": 3990,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\",(\"index_merge total cost: %g (wanted: less then %g)\",\n                     imerge_cost, read_time))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\",(\"index_merge total cost: %g (wanted: less then %g)\",",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 6037,
          "old_api": "real_item",
          "new_api": null,
          "old_text": "value->real_item()->type()",
          "new_text": null,
          "old_line_content": "  if (value->real_item()->type() == Item::STRING_ITEM &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 10136,
          "old_api": "functype",
          "new_api": null,
          "old_text": "pred->functype()",
          "new_text": null,
          "old_line_content": "        Item_func::Functype pred_type= pred->functype();",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 6038,
          "old_api": "type",
          "new_api": null,
          "old_text": "field->type()",
          "new_text": null,
          "old_line_content": "      (field->type() == MYSQL_TYPE_DATE ||",
          "new_line_content": "  /*",
          "content_same": false
        },
        {
          "line": 6039,
          "old_api": "type",
          "new_api": null,
          "old_text": "field->type()",
          "new_text": null,
          "old_line_content": "       field->type() == MYSQL_TYPE_DATETIME))",
          "new_line_content": "    We can't always use indexes when comparing a string index to a number",
          "content_same": false
        },
        {
          "line": 6041,
          "old_api": "save_in_field_no_warnings",
          "new_api": null,
          "old_text": "value->save_in_field_no_warnings(field, 1)",
          "new_text": null,
          "old_line_content": "  err= value->save_in_field_no_warnings(field, 1);",
          "new_line_content": "  */",
          "content_same": false
        },
        {
          "line": 1948,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(mem_root, (uint) size)",
          "new_text": null,
          "old_line_content": "  { return (void*) alloc_root(mem_root, (uint) size); }",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1949,
          "old_api": "TRASH",
          "new_api": null,
          "old_text": "TRASH(ptr, size)",
          "new_text": null,
          "old_line_content": "  static void operator delete(void *ptr,size_t size) { TRASH(ptr, size); }",
          "new_line_content": "    RETURN",
          "content_same": false
        },
        {
          "line": 8091,
          "old_api": "store_min_key",
          "new_api": null,
          "old_text": "key_tree->next_key_part->store_min_key(key,\n                                                          &tmp_min_key,\n                                                          &tmp_min_flag,\n                                                          MAX_KEY)",
          "new_text": null,
          "old_line_content": "        min_part+= key_tree->next_key_part->store_min_key(key,",
          "new_line_content": "\t key_tree->min_flag==0 && key_tree->max_flag==0)",
          "content_same": false
        },
        {
          "line": 6047,
          "old_api": "result_type",
          "new_api": null,
          "old_text": "field->result_type()",
          "new_text": null,
          "old_line_content": "          value->result_type() == item_cmp_type(field->result_type(),",
          "new_line_content": "  orig_sql_mode= field->table->in_use->variables.sql_mode;",
          "content_same": false
        },
        {
          "line": 8096,
          "old_api": "store_max_key",
          "new_api": null,
          "old_text": "key_tree->next_key_part->store_max_key(key,\n                                                          &tmp_max_key,\n                                                          &tmp_max_flag,\n                                                          MAX_KEY)",
          "new_text": null,
          "old_line_content": "        max_part+= key_tree->next_key_part->store_max_key(key,",
          "new_line_content": "\treturn 1;",
          "content_same": false
        },
        {
          "line": 10151,
          "old_api": "bzero",
          "new_api": null,
          "old_text": "bzero(args, 3 * sizeof(Item*))",
          "new_text": null,
          "old_line_content": "        bzero(args, 3 * sizeof(Item*));",
          "new_line_content": "            pred_type != Item_func::GT_FUNC        &&",
          "content_same": false
        },
        {
          "line": 10154,
          "old_api": "simple_pred",
          "new_api": null,
          "old_text": "simple_pred(pred, args, &inv)",
          "new_text": null,
          "old_line_content": "        if (!simple_pred(pred, args, &inv))",
          "new_line_content": "            pred_type != Item_func::ISNULL_FUNC    &&",
          "content_same": false
        },
        {
          "line": 10155,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(FALSE)",
          "new_text": null,
          "old_line_content": "          DBUG_RETURN(FALSE);",
          "new_line_content": "            pred_type != Item_func::ISNOTNULL_FUNC &&",
          "content_same": false
        },
        {
          "line": 4010,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(imerge_trp)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(imerge_trp);",
          "new_line_content": "                               param->table->file->stats.records);",
          "content_same": false
        },
        {
          "line": 6062,
          "old_api": "type",
          "new_api": null,
          "old_text": "field->type()",
          "new_text": null,
          "old_line_content": "        if (err == 3 && field->type() == FIELD_TYPE_DATE &&",
          "new_line_content": "        tree->type= SEL_ARG::IMPOSSIBLE;",
          "content_same": false
        },
        {
          "line": 10159,
          "old_api": "result_type",
          "new_api": null,
          "old_text": "min_max_arg_item->result_type()",
          "new_text": null,
          "old_line_content": "            min_max_arg_item->result_type() == STRING_RESULT &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4015,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(param->mem_root,\n                                        sizeof(TABLE_READ_PLAN*)*\n                                        n_child_scans)",
          "new_text": null,
          "old_line_content": "          (TABLE_READ_PLAN**)alloc_root(param->mem_root,",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 4018,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(imerge_trp)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(imerge_trp);",
          "new_line_content": "  if (!all_scans_ror_able || ",
          "content_same": false
        },
        {
          "line": 10163,
          "old_api": "result_type",
          "new_api": null,
          "old_text": "args[1]->result_type()",
          "new_text": null,
          "old_line_content": "            ((args[1]->result_type() == STRING_RESULT &&",
          "new_line_content": "        bool inv;",
          "content_same": false
        },
        {
          "line": 10172,
          "old_api": "result_type",
          "new_api": null,
          "old_text": "args[1]->result_type()",
          "new_text": null,
          "old_line_content": "             (args[1]->result_type() != STRING_RESULT &&",
          "new_line_content": "              Don't use an index when comparing strings of different collations.",
          "content_same": false
        },
        {
          "line": 1981,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"TRP_RANGE::make_quick\")",
          "new_text": null,
          "old_line_content": "    DBUG_ENTER(\"TRP_RANGE::make_quick\");",
          "new_line_content": "  SEL_ARG *key; /* set of intervals to be used in \"range\" method retrieval */",
          "content_same": false
        },
        {
          "line": 10173,
          "old_api": "result_type",
          "new_api": null,
          "old_text": "args[1]->result_type()",
          "new_text": null,
          "old_line_content": "              min_max_arg_item->field->cmp_type() != args[1]->result_type())))",
          "new_line_content": "            */",
          "content_same": false
        },
        {
          "line": 1983,
          "old_api": "get_quick_select",
          "new_api": null,
          "old_text": "get_quick_select(param, key_idx, key, parent_alloc)",
          "new_text": null,
          "old_line_content": "    if ((quick= get_quick_select(param, key_idx, key, parent_alloc)))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8126,
          "old_api": "uint) (tmp_min_key - param->min_key)",
          "new_api": null,
          "old_text": "uint) (tmp_min_key - param->min_key)",
          "new_text": null,
          "old_line_content": "    uint length= (uint) (tmp_min_key - param->min_key);",
          "new_line_content": "    if (tmp_min_key != param->min_key)",
          "content_same": false
        },
        {
          "line": 8127,
          "old_api": "uint) (tmp_max_key - param->max_key)",
          "new_api": null,
          "old_text": "uint) (tmp_max_key - param->max_key)",
          "new_text": null,
          "old_line_content": "    if (length == (uint) (tmp_max_key - param->max_key) &&",
          "new_line_content": "      flag&= ~NO_MIN_RANGE;",
          "content_same": false
        },
        {
          "line": 8128,
          "old_api": "memcmp",
          "new_api": null,
          "old_text": "memcmp(param->min_key,param->max_key,length)",
          "new_text": null,
          "old_line_content": "\t!memcmp(param->min_key,param->max_key,length))",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 10179,
          "old_api": "check_group_min_max_predicates",
          "new_api": null,
          "old_text": "check_group_min_max_predicates(cur_arg, min_max_arg_item,\n                                         image_type)",
          "new_text": null,
          "old_line_content": "      if (!check_group_min_max_predicates(cur_arg, min_max_arg_item,",
          "new_line_content": "             /*",
          "content_same": false
        },
        {
          "line": 1988,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(quick)",
          "new_text": null,
          "old_line_content": "    DBUG_RETURN(quick);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 10181,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(FALSE)",
          "new_text": null,
          "old_line_content": "        DBUG_RETURN(FALSE);",
          "new_line_content": "               number.",
          "content_same": false
        },
        {
          "line": 4039,
          "old_api": "param->table->file->\n              read_time(param->real_keynr[(*cur_child)->key_idx], 1,\n                        (*cur_child)->records)",
          "new_api": null,
          "old_text": "param->table->file->\n              read_time(param->real_keynr[(*cur_child)->key_idx], 1,\n                        (*cur_child)->records)",
          "new_text": null,
          "old_line_content": "      cost= param->table->file->",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 8136,
          "old_api": "null_part_in_key",
          "new_api": null,
          "old_text": "null_part_in_key(key,\n                             param->min_key,\n                             (uint) (tmp_min_key - param->min_key))",
          "new_text": null,
          "old_line_content": "            null_part_in_key(key,",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 4042,
          "old_api": "rows2double",
          "new_api": null,
          "old_text": "rows2double((*cur_child)->records)",
          "new_text": null,
          "old_line_content": "              rows2double((*cur_child)->records) / TIME_FOR_COMPARE;",
          "new_line_content": "      scan cost.",
          "content_same": false
        },
        {
          "line": 4048,
          "old_api": "get_best_ror_intersect",
          "new_api": null,
          "old_text": "get_best_ror_intersect(param, *ptree, cost,\n                                                 &dummy)",
          "new_text": null,
          "old_line_content": "    if (!(*cur_roru_plan= get_best_ror_intersect(param, *ptree, cost,",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 6098,
          "old_api": "result_type",
          "new_api": null,
          "old_text": "field->result_type()",
          "new_text": null,
          "old_line_content": "    else if (err == 1 && field->result_type() == INT_RESULT)",
          "new_line_content": "          field->table->in_use->variables.sql_mode= orig_sql_mode;",
          "content_same": false
        },
        {
          "line": 10195,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(TRUE)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(TRUE);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 6100,
          "old_api": "val_int",
          "new_api": null,
          "old_text": "value->val_int()",
          "new_text": null,
          "old_line_content": "      if (type == Item_func::LT_FUNC && (value->val_int() > 0))",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 8148,
          "old_api": "uint) (tmp_min_key - param->min_key)",
          "new_api": null,
          "old_text": "uint) (tmp_min_key - param->min_key)",
          "new_text": null,
          "old_line_content": "\t\t\t       (uint) (tmp_min_key - param->min_key),",
          "new_line_content": "                             param->min_key,",
          "content_same": false
        },
        {
          "line": 4054,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(imerge_trp)",
          "new_text": null,
          "old_line_content": "        DBUG_RETURN(imerge_trp);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 6103,
          "old_api": "type",
          "new_api": null,
          "old_text": "field->type()",
          "new_text": null,
          "old_line_content": "               (field->type() != FIELD_TYPE_BIT) &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8151,
          "old_api": "uint) (tmp_max_key - param->max_key)",
          "new_api": null,
          "old_text": "uint) (tmp_max_key - param->max_key)",
          "new_text": null,
          "old_line_content": "\t\t\t       (uint) (tmp_max_key - param->max_key),",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 8152,
          "old_api": "make_keypart_map",
          "new_api": null,
          "old_text": "make_keypart_map(max_part)",
          "new_text": null,
          "old_line_content": "                               max_part >=0 ? make_keypart_map(max_part) : 0,",
          "new_line_content": "          flag|= UNIQUE_RANGE;",
          "content_same": false
        },
        {
          "line": 6106,
          "old_api": "val_int",
          "new_api": null,
          "old_text": "value->val_int()",
          "new_text": null,
          "old_line_content": "               (value->val_int() < 0))",
          "new_line_content": "      If an integer got bounded (e.g. to within 0..255 / -128..127)",
          "content_same": false
        },
        {
          "line": 8156,
          "old_api": "set_if_bigger",
          "new_api": null,
          "old_text": "set_if_bigger(quick->max_used_key_length, range->min_length)",
          "new_text": null,
          "old_line_content": "  set_if_bigger(quick->max_used_key_length, range->min_length);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 8157,
          "old_api": "set_if_bigger",
          "new_api": null,
          "old_text": "set_if_bigger(quick->max_used_key_length, range->max_length)",
          "new_text": null,
          "old_line_content": "  set_if_bigger(quick->max_used_key_length, range->max_length);",
          "new_line_content": "  /* Get range for retrieving rows in QUICK_SELECT::get_next */",
          "content_same": false
        },
        {
          "line": 8158,
          "old_api": "set_if_bigger",
          "new_api": null,
          "old_text": "set_if_bigger(quick->used_key_parts, (uint) key_tree->part+1)",
          "new_text": null,
          "old_line_content": "  set_if_bigger(quick->used_key_parts, (uint) key_tree->part+1);",
          "new_line_content": "  if (!(range= new QUICK_RANGE(param->min_key,",
          "content_same": false
        },
        {
          "line": 8164,
          "old_api": "get_quick_keys",
          "new_api": null,
          "old_text": "get_quick_keys(param,quick,key,key_tree->right,\n\t\t\t  min_key,min_key_flag,\n\t\t\t  max_key,max_key_flag)",
          "new_text": null,
          "old_line_content": "    return get_quick_keys(param,quick,key,key_tree->right,",
          "new_line_content": "\t\t\t       flag)))",
          "content_same": false
        },
        {
          "line": 4071,
          "old_api": "ha_rows)(roru_intersect_part*\n                                  param->table->file->stats.records)",
          "new_api": null,
          "old_text": "ha_rows)(roru_intersect_part*\n                                  param->table->file->stats.records)",
          "new_text": null,
          "old_line_content": "  roru_total_records -= (ha_rows)(roru_intersect_part*",
          "new_line_content": "    roru_total_records += (*cur_roru_plan)->records;",
          "content_same": false
        },
        {
          "line": 6123,
          "old_api": "is_real_null",
          "new_api": null,
          "old_text": "field->is_real_null()",
          "new_text": null,
          "old_line_content": "  if (type != Item_func::EQUAL_FUNC && field->is_real_null())",
          "new_line_content": "    field->table->in_use->variables.sql_mode= orig_sql_mode;",
          "content_same": false
        },
        {
          "line": 6129,
          "old_api": "alloc_root",
          "new_api": null,
          "old_text": "alloc_root(alloc, key_part->store_length+1)",
          "new_text": null,
          "old_line_content": "  str= (uchar*) alloc_root(alloc, key_part->store_length+1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4084,
          "old_api": "log",
          "new_api": null,
          "old_text": "log((double)n_child_scans)",
          "new_text": null,
          "old_line_content": "                   rows2double(roru_total_records)*log((double)n_child_scans) /",
          "new_line_content": "  /* ok, got a ROR read plan for each of the disjuncts",
          "content_same": false
        },
        {
          "line": 6133,
          "old_api": "is_real_null",
          "new_api": null,
          "old_text": "field->is_real_null()",
          "new_text": null,
          "old_line_content": "    *str= (uchar) field->is_real_null();        // Set to 1 if null",
          "new_line_content": "  */",
          "content_same": false
        },
        {
          "line": 4086,
          "old_api": "get_sweep_read_cost",
          "new_api": null,
          "old_text": "get_sweep_read_cost(param, roru_total_records)",
          "new_text": null,
          "old_line_content": "                   get_sweep_read_cost(param, roru_total_records);",
          "new_line_content": "    cost(index_union_scan(scan_1, ... scan_n)) =",
          "content_same": false
        },
        {
          "line": 4088,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\", (\"ROR-union: cost %g, %d members\", roru_total_cost,\n                      n_child_scans))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\", (\"ROR-union: cost %g, %d members\", roru_total_cost,",
          "new_line_content": "      queue_use_cost(rowid_len, n) +",
          "content_same": false
        },
        {
          "line": 10237,
          "old_api": "eq",
          "new_api": null,
          "old_text": "keypart_tree->field->eq(field)",
          "new_text": null,
          "old_line_content": "  if (keypart_tree->field->eq(field))",
          "new_line_content": "                  is not conjunction to all predicates on earlier keyparts",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 202,
      "total_additions": 1104,
      "total_deletions": 1104,
      "total_api_changes": 2410
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 13,
        "api_related_lines": 2410,
        "non_api_lines": 9,
        "non_api_line_numbers": [
          1,
          1665,
          1667,
          1666,
          1669,
          1670,
          1671,
          1673,
          1674
        ]
      }
    },
    "api_calls_before": 1608,
    "api_calls_after": 1608,
    "diff_info": {
      "added_lines": 13,
      "removed_lines": 2,
      "total_diff_lines": 31
    }
  }
}