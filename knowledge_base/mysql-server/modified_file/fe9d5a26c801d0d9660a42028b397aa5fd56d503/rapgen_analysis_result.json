{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/mysql-server/modified_file/fe9d5a26c801d0d9660a42028b397aa5fd56d503",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/mysql-server/modified_file/fe9d5a26c801d0d9660a42028b397aa5fd56d503/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/mysql-server/modified_file/fe9d5a26c801d0d9660a42028b397aa5fd56d503/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/mysql-server/modified_file/fe9d5a26c801d0d9660a42028b397aa5fd56d503/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 897,
          "old_api": "get_commit_order_manager",
          "new_api": "diff_timespec",
          "old_text": "rli->get_commit_order_manager()",
          "new_text": "diff_timespec(&ts[1], &ts[0])",
          "old_line_content": "    if (rli->get_commit_order_manager() != NULL && worker != NULL)",
          "new_line_content": "      rli->mts_total_wait_worker_avail += diff_timespec(&ts[1], &ts[0]);",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": "static_cast<Query_log_event*>(ev)",
          "new_api": "get_commit_order_manager",
          "old_text": "static_cast<Query_log_event*>(ev)",
          "new_text": "rli->get_commit_order_manager()",
          "old_line_content": "    static_cast<Query_log_event*>(ev)->mts_accessed_dbs= 0;",
          "new_line_content": "    if (rli->get_commit_order_manager() != NULL && worker != NULL)",
          "content_same": false
        },
        {
          "line": 961,
          "old_api": "mts_checkpoint_routine",
          "new_api": "DBUG_PRINT",
          "old_text": "mts_checkpoint_routine(rli, 0, true, true /*need_data_lock=true*/)",
          "new_text": "DBUG_PRINT(\"info\",(\"delegated %d, jobs_done %d\", delegated_jobs,\n                          jobs_done))",
          "old_line_content": "    if (mts_checkpoint_routine(rli, 0, true, true /*need_data_lock=true*/))",
          "new_line_content": "  DBUG_PRINT(\"info\",(\"delegated %d, jobs_done %d\", delegated_jobs,",
          "content_same": false
        },
        {
          "line": 964,
          "old_api": "DBUG_EXECUTE_IF",
          "new_api": "enter_stage",
          "old_text": "DBUG_EXECUTE_IF(\"wait_for_workers_to_finish_after_wait\",\n                  {\n                    const char act[]= \"now WAIT_FOR coordinator_continue\";\n                    DBUG_ASSERT(!debug_sync_set_action(rli->info_thd,\n                                                       STRING_WITH_LEN(act)));\n                  })",
          "new_text": "thd->enter_stage(&stage_slave_waiting_for_workers_to_process_queue,\n                   old_stage,\n                    __func__, __FILE__, __LINE__)",
          "old_line_content": "  DBUG_EXECUTE_IF(\"wait_for_workers_to_finish_after_wait\",",
          "new_line_content": "  thd->enter_stage(&stage_slave_waiting_for_workers_to_process_queue,",
          "content_same": false
        },
        {
          "line": 974,
          "old_api": "THD_STAGE_INFO",
          "new_api": "DBUG_EXECUTE_IF",
          "old_text": "THD_STAGE_INFO(thd, *old_stage)",
          "new_text": "DBUG_EXECUTE_IF(\"wait_for_workers_to_finish_after_wait\",\n                  {\n                    const char act[]= \"now WAIT_FOR coordinator_continue\";\n                    DBUG_ASSERT(!debug_sync_set_action(rli->info_thd,\n                                                       STRING_WITH_LEN(act)));\n                  })",
          "old_line_content": "  THD_STAGE_INFO(thd, *old_stage);",
          "new_line_content": "  DBUG_EXECUTE_IF(\"wait_for_workers_to_finish_after_wait\",",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "DBUG_RETURN",
          "new_api": "STRING_WITH_LEN",
          "old_text": "DBUG_RETURN(0)",
          "new_text": "STRING_WITH_LEN(act)",
          "old_line_content": "  DBUG_RETURN(0);",
          "new_line_content": "                                                       STRING_WITH_LEN(act)));",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 896,
          "old_api": null,
          "new_api": "set_timespec_nsec",
          "old_text": null,
          "new_text": "set_timespec_nsec(&ts[1], 0)",
          "old_line_content": "    }",
          "new_line_content": "      set_timespec_nsec(&ts[1], 0);",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": null,
          "new_api": "get_commit_order_manager",
          "old_text": null,
          "new_text": "rli->get_commit_order_manager()->register_trx(worker)",
          "old_line_content": "",
          "new_line_content": "      rli->get_commit_order_manager()->register_trx(worker);",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(ptr_group)",
          "old_line_content": "",
          "new_line_content": "  DBUG_ASSERT(ptr_group);",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(worker != NULL || thd->killed)",
          "old_line_content": "  The method is supposed to be called by Coordinator, therefore",
          "new_line_content": "  DBUG_ASSERT(worker != NULL || thd->killed);",
          "content_same": false
        },
        {
          "line": 916,
          "old_api": null,
          "new_api": "get_type_code",
          "old_text": null,
          "new_text": "ev->get_type_code()",
          "old_line_content": "",
          "new_line_content": "  if (ev->get_type_code() == binary_log::QUERY_EVENT)",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": null,
          "new_api": "static_cast<Query_log_event*>(ev)",
          "old_text": null,
          "new_text": "static_cast<Query_log_event*>(ev)",
          "old_line_content": "  todo: consider to optimize scan that is getting more expensive with",
          "new_line_content": "    static_cast<Query_log_event*>(ev)->mts_accessed_dbs= 0;",
          "content_same": false
        },
        {
          "line": 919,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(worker)",
          "old_line_content": "",
          "new_line_content": "  DBUG_RETURN(worker);",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "rli->workers.end()",
          "old_line_content": "  Waits for slave workers to finish off the pending tasks before returning.",
          "new_line_content": "  for (Slave_worker **it= rli->workers.begin(); it != rli->workers.end(); ++it)",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": null,
          "new_api": "__attribute__",
          "old_text": null,
          "new_text": "__attribute__((unused))",
          "old_line_content": "                    __func__, __FILE__, __LINE__);",
          "new_line_content": "                              __attribute__((unused)) Slave_worker * ignore)",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"Mts_submode_logical_clock::wait_for_workers_to_finish\")",
          "old_line_content": "    // b. (better) pthread wait+signal similarly to DB type.",
          "new_line_content": "  DBUG_ENTER(\"Mts_submode_logical_clock::wait_for_workers_to_finish\");",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": null,
          "new_api": "mts_checkpoint_routine",
          "old_text": null,
          "new_text": "mts_checkpoint_routine(rli, 0, true, true /*need_data_lock=true*/)",
          "old_line_content": "  // The current commit point sequence may end here (e.g Rotate to new log)",
          "new_line_content": "    if (mts_checkpoint_routine(rli, 0, true, true /*need_data_lock=true*/))",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(-1)",
          "old_line_content": "  rli->gaq->lwm.sequence_number= SEQ_UNINIT;",
          "new_line_content": "      DBUG_RETURN(-1);",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": null,
          "new_api": "debug_sync_set_action",
          "old_text": null,
          "new_text": "debug_sync_set_action(rli->info_thd,\n                                                       STRING_WITH_LEN(act))",
          "old_line_content": "  rli->mts_group_status= Relay_log_info::MTS_NOT_IN_GROUP;",
          "new_line_content": "                    DBUG_ASSERT(!debug_sync_set_action(rli->info_thd,",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": null,
          "new_api": "THD_STAGE_INFO",
          "old_text": null,
          "new_text": "THD_STAGE_INFO(thd, *old_stage)",
          "old_line_content": "  @param  : instance pointer of TABLE structure.",
          "new_line_content": "  THD_STAGE_INFO(thd, *old_stage);",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": null,
          "new_api": "DBUG_PRINT",
          "old_text": null,
          "new_text": "DBUG_PRINT(\"info\",(\"delegated %d, jobs_done %d, Workers have finished their\"\n                     \" jobs\", delegated_jobs, jobs_done))",
          "old_line_content": "  @return : std:pair<uint, my_thread_id>",
          "new_line_content": "  DBUG_PRINT(\"info\",(\"delegated %d, jobs_done %d, Workers have finished their\"",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(0)",
          "old_line_content": " */",
          "new_line_content": "  DBUG_RETURN(0);",
          "content_same": false
        },
        {
          "line": 1002,
          "old_api": null,
          "new_api": "DBUG_ENTER",
          "old_text": null,
          "new_text": "DBUG_ENTER(\"get_server_and_thread_id\")",
          "old_line_content": "      /* next  4 bytes contains the pseudo_thread_id */",
          "new_line_content": "  DBUG_ENTER(\"get_server_and_thread_id\");",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": null,
          "new_api": "DBUG_ASSERT",
          "old_text": null,
          "new_text": "DBUG_ASSERT(table->s->table_cache_key.length > 0)",
          "old_line_content": "}",
          "new_line_content": "  DBUG_ASSERT(table->s->table_cache_key.length > 0);",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": null,
          "new_api": "std::make_pair\n    (\n      /* last 8  bytes contains the server_id + pseudo_thread_id */\n      // fetch first 4 bytes to get the server id.\n      uint4korr(extra_string + extra_string_len - 8),\n      /* next  4 bytes contains the pseudo_thread_id */\n      uint4korr(extra_string + extra_string_len - 4)\n    )",
          "old_text": null,
          "new_text": "std::make_pair\n    (\n      /* last 8  bytes contains the server_id + pseudo_thread_id */\n      // fetch first 4 bytes to get the server id.\n      uint4korr(extra_string + extra_string_len - 8),\n      /* next  4 bytes contains the pseudo_thread_id */\n      uint4korr(extra_string + extra_string_len - 4)\n    )",
          "old_line_content": "",
          "new_line_content": "  std::pair<uint, my_thread_id>ret_pair= std::make_pair",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": null,
          "new_api": "uint4korr",
          "old_text": null,
          "new_text": "uint4korr(extra_string + extra_string_len - 8)",
          "old_line_content": "",
          "new_line_content": "      uint4korr(extra_string + extra_string_len - 8),",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": null,
          "new_api": "uint4korr",
          "old_text": null,
          "new_text": "uint4korr(extra_string + extra_string_len - 4)",
          "old_line_content": "",
          "new_line_content": "      uint4korr(extra_string + extra_string_len - 4)",
          "content_same": false
        },
        {
          "line": 1015,
          "old_api": null,
          "new_api": "DBUG_RETURN",
          "old_text": null,
          "new_text": "DBUG_RETURN(ret_pair)",
          "old_line_content": "",
          "new_line_content": "  DBUG_RETURN(ret_pair);",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": null,
          "new_api": "sched_yield",
          "old_text": null,
          "new_text": "sched_yield()",
          "old_line_content": "      /*",
          "new_line_content": "        sched_yield();",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": null,
          "new_api": "my_sleep",
          "old_text": null,
          "new_text": "my_sleep(rli->mts_coordinator_basic_nap)",
          "old_line_content": "        any worker thread. So The flag is removed and Coordinator thread",
          "new_line_content": "        my_sleep(rli->mts_coordinator_basic_nap);",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": null,
          "new_api": "get_free_worker",
          "old_text": null,
          "new_text": "get_free_worker(rli)",
          "old_line_content": "      */",
          "new_line_content": "        worker= get_free_worker(rli);",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": null,
          "new_api": "THD_STAGE_INFO",
          "old_text": null,
          "new_text": "THD_STAGE_INFO(thd, *old_stage)",
          "old_line_content": "        rli->info_thd->variables.option_bits&= ~OPTION_BEGIN;",
          "new_line_content": "      THD_STAGE_INFO(thd, *old_stage);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 898,
          "old_api": "get_commit_order_manager",
          "new_api": null,
          "old_text": "rli->get_commit_order_manager()->register_trx(worker)",
          "new_text": null,
          "old_line_content": "      rli->get_commit_order_manager()->register_trx(worker);",
          "new_line_content": "      rli->mts_wq_no_underrun_cnt++;",
          "content_same": false
        },
        {
          "line": 901,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(ptr_group)",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(ptr_group);",
          "new_line_content": "        any worker thread. So The flag is removed and Coordinator thread",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(worker != NULL || thd->killed)",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(worker != NULL || thd->killed);",
          "new_line_content": "      if (worker == NULL)",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": "get_type_code",
          "new_api": null,
          "old_text": "ev->get_type_code()",
          "new_text": null,
          "old_line_content": "  if (ev->get_type_code() == binary_log::QUERY_EVENT)",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(worker)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(worker);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": "end",
          "new_api": null,
          "old_text": "rli->workers.end()",
          "new_text": null,
          "old_line_content": "  for (Slave_worker **it= rli->workers.begin(); it != rli->workers.end(); ++it)",
          "new_line_content": "  comparison like w_i->jobs.len == 0 must (eventually) succeed.",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": "__attribute__",
          "new_api": null,
          "old_text": "__attribute__((unused))",
          "new_text": null,
          "old_line_content": "                              __attribute__((unused)) Slave_worker * ignore)",
          "new_line_content": "  Used in this submode to make sure that all assigned jobs have been done.",
          "content_same": false
        },
        {
          "line": 950,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"Mts_submode_logical_clock::wait_for_workers_to_finish\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"Mts_submode_logical_clock::wait_for_workers_to_finish\");",
          "new_line_content": "  @return -1 for error.",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\",(\"delegated %d, jobs_done %d\", delegated_jobs,\n                          jobs_done))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\",(\"delegated %d, jobs_done %d\", delegated_jobs,",
          "new_line_content": "           0 no error.",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": "enter_stage",
          "new_api": null,
          "old_text": "thd->enter_stage(&stage_slave_waiting_for_workers_to_process_queue,\n                   old_stage,\n                    __func__, __FILE__, __LINE__)",
          "new_text": null,
          "old_line_content": "  thd->enter_stage(&stage_slave_waiting_for_workers_to_process_queue,",
          "new_line_content": "Mts_submode_logical_clock::",
          "content_same": false
        },
        {
          "line": 962,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(-1)",
          "new_text": null,
          "old_line_content": "      DBUG_RETURN(-1);",
          "new_line_content": "                          jobs_done));",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": "debug_sync_set_action",
          "new_api": null,
          "old_text": "debug_sync_set_action(rli->info_thd,\n                                                       STRING_WITH_LEN(act))",
          "new_text": null,
          "old_line_content": "                    DBUG_ASSERT(!debug_sync_set_action(rli->info_thd,",
          "new_line_content": "  while (delegated_jobs > jobs_done && !thd->killed && !is_error)",
          "content_same": false
        },
        {
          "line": 968,
          "old_api": "STRING_WITH_LEN",
          "new_api": null,
          "old_text": "STRING_WITH_LEN(act)",
          "new_text": null,
          "old_line_content": "                                                       STRING_WITH_LEN(act)));",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": "DBUG_PRINT",
          "new_api": null,
          "old_text": "DBUG_PRINT(\"info\",(\"delegated %d, jobs_done %d, Workers have finished their\"\n                     \" jobs\", delegated_jobs, jobs_done))",
          "new_text": null,
          "old_line_content": "  DBUG_PRINT(\"info\",(\"delegated %d, jobs_done %d, Workers have finished their\"",
          "new_line_content": "                  {",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": "DBUG_ENTER",
          "new_api": null,
          "old_text": "DBUG_ENTER(\"get_server_and_thread_id\")",
          "new_text": null,
          "old_line_content": "  DBUG_ENTER(\"get_server_and_thread_id\");",
          "new_line_content": "  Protected method to fetch the server_id and pseudo_thread_id from a",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": "DBUG_ASSERT",
          "new_api": null,
          "old_text": "DBUG_ASSERT(table->s->table_cache_key.length > 0)",
          "new_text": null,
          "old_line_content": "  DBUG_ASSERT(table->s->table_cache_key.length > 0);",
          "new_line_content": "  @Note   : It is the caller's responsibility to make sure we call this",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": "std::make_pair\n    (\n      /* last 8  bytes contains the server_id + pseudo_thread_id */\n      // fetch first 4 bytes to get the server id.\n      uint4korr(extra_string + extra_string_len - 8),\n      /* next  4 bytes contains the pseudo_thread_id */\n      uint4korr(extra_string + extra_string_len - 4)\n    )",
          "new_api": null,
          "old_text": "std::make_pair\n    (\n      /* last 8  bytes contains the server_id + pseudo_thread_id */\n      // fetch first 4 bytes to get the server id.\n      uint4korr(extra_string + extra_string_len - 8),\n      /* next  4 bytes contains the pseudo_thread_id */\n      uint4korr(extra_string + extra_string_len - 4)\n    )",
          "new_text": null,
          "old_line_content": "  std::pair<uint, my_thread_id>ret_pair= std::make_pair",
          "new_line_content": "            function only for temp tables.",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": "uint4korr",
          "new_api": null,
          "old_text": "uint4korr(extra_string + extra_string_len - 8)",
          "new_text": null,
          "old_line_content": "      uint4korr(extra_string + extra_string_len - 8),",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": "uint4korr",
          "new_api": null,
          "old_text": "uint4korr(extra_string + extra_string_len - 4)",
          "new_text": null,
          "old_line_content": "      uint4korr(extra_string + extra_string_len - 4)",
          "new_line_content": "  char* extra_string= table->s->table_cache_key.str;",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": "DBUG_RETURN",
          "new_api": null,
          "old_text": "DBUG_RETURN(ret_pair)",
          "new_text": null,
          "old_line_content": "  DBUG_RETURN(ret_pair);",
          "new_line_content": "  // assert will fail when called with non temporary tables.",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": "my_sleep",
          "new_api": null,
          "old_text": "my_sleep(rli->mts_coordinator_basic_nap)",
          "new_text": null,
          "old_line_content": "        my_sleep(rli->mts_coordinator_basic_nap);",
          "new_line_content": "          queue.",
          "content_same": false
        },
        {
          "line": 883,
          "old_api": "get_free_worker",
          "new_api": null,
          "old_text": "get_free_worker(rli)",
          "new_text": null,
          "old_line_content": "        worker= get_free_worker(rli);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": "THD_STAGE_INFO",
          "new_api": null,
          "old_text": "THD_STAGE_INFO(thd, *old_stage)",
          "new_text": null,
          "old_line_content": "      THD_STAGE_INFO(thd, *old_stage);",
          "new_line_content": "                First Available Worker as",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": "set_timespec_nsec",
          "new_api": null,
          "old_text": "set_timespec_nsec(&ts[1], 0)",
          "new_text": null,
          "old_line_content": "      set_timespec_nsec(&ts[1], 0);",
          "new_line_content": "                this method clearly can't be considered as optimal.",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": "diff_timespec",
          "new_api": null,
          "old_text": "diff_timespec(&ts[1], &ts[0])",
          "new_text": null,
          "old_line_content": "      rli->mts_total_wait_worker_avail += diff_timespec(&ts[1], &ts[0]);",
          "new_line_content": "        */",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 6,
      "total_additions": 26,
      "total_deletions": 25,
      "total_api_changes": 57
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 12,
        "api_related_lines": 57,
        "non_api_lines": 7,
        "non_api_line_numbers": [
          879,
          880,
          881,
          884,
          888,
          890,
          892
        ]
      }
    },
    "api_calls_before": 194,
    "api_calls_after": 195,
    "diff_info": {
      "added_lines": 12,
      "removed_lines": 2,
      "total_diff_lines": 28
    }
  }
}