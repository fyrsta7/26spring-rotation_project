{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/mysql-server/modified_file/515bb158763bf53c4bbac5472ccc3e30154bd6d6",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/mysql-server/modified_file/515bb158763bf53c4bbac5472ccc3e30154bd6d6/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/mysql-server/modified_file/515bb158763bf53c4bbac5472ccc3e30154bd6d6/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/mysql-server/modified_file/515bb158763bf53c4bbac5472ccc3e30154bd6d6/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 1533,
          "old_api": "dx = m_edges[state.outgoing",
          "new_api": "for (size_t j",
          "old_text": "dx = m_edges[state.outgoing",
          "new_text": "     for (size_t j",
          "old_line_content": "      for (size_t j = 0; j < state.outgoing_edges.size(); ++j) {",
          "new_line_content": "    for (size_t i = 1; i < m_orderings.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 1562,
          "old_api": "tgoing_edges[num",
          "new_api": "m_edges[state.outgoing_edg",
          "old_text": "tgoing_edges[num",
          "new_text": " m_edges[state.outgoing_edg",
          "old_line_content": "        if (edge.state(this)->type != NFSMState::DELETED) {",
          "new_line_content": "      for (size_t j = 0; j < state.outgoing_edges.size(); ++j) {",
          "content_same": false
        },
        {
          "line": 1663,
          "old_api": "push_back",
          "new_api": "ExpandThroughAlwaysActiveFDs(&initial",
          "old_text": "                  /*extra_allowed_fd_idx=*/0);\n  m_dfsm_states.push_back(move(initial));\n  FinalizeDFSMState(thd, /*state_",
          "new_text": "  ExpandThroughAlwaysActiveFDs(&initial",
          "old_line_content": "  ExpandThroughAlwaysActiveFDs(&initial.nfsm_states, &generation,",
          "new_line_content": "  initial.nfsm_states.init(thd->mem_root);",
          "content_same": false
        },
        {
          "line": 1665,
          "old_api": "information",
          "new_api": "push_back",
          "old_text": " information ",
          "new_text": "                  /*extra_allowed_fd_idx=*/0);\n  m_dfsm_states.push_back(move(initial));\n  FinalizeDFSMState(thd, /*state_",
          "old_line_content": "  m_dfsm_states.push_back(move(initial));",
          "new_line_content": "  ExpandThroughAlwaysActiveFDs(&initial.nfsm_states, &generation,",
          "content_same": false
        },
        {
          "line": 1706,
          "old_api": "quired_fd_idx, b.state_idx);\n           }",
          "new_api": "return ma",
          "old_text": "quired_fd_idx, b.state_idx);\n           }",
          "new_text": "       return ma",
          "old_line_content": "             return make_pair(a.required_fd_idx, a.state_idx) <",
          "new_line_content": "      sort(nfsm_edges.begin(), nfsm_edges.end(),",
          "content_same": false
        },
        {
          "line": 1712,
          "old_api": "ir",
          "new_api": "",
          "old_text": "ir(b.required_fd_idx, b.state_idx);\n     ",
          "new_text": "                ",
          "old_line_content": "                   return make_pair(a.required_fd_idx, a.state_idx) ==",
          "new_line_content": "          unique(nfsm_edges.begin(), nfsm_edges.end(),",
          "content_same": false
        },
        {
          "line": 1715,
          "old_api": "ich set of m_state",
          "new_api": "resize",
          "old_text": "ich set of m_state",
          "new_text": "es.resize(distance(nfsm_edges.begin(), ne",
          "old_line_content": "      nfsm_edges.resize(distance(nfsm_edges.begin(), new_end));",
          "new_line_content": "                          make_pair(b.required_fd_idx, b.state_idx);",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": "dx].state_idx);",
          "new_api": "clear",
          "old_text": "dx].state_idx);\n\n",
          "new_text": "tes.clear();\n    for (size_t edge_idx = 0; edge_idx < nfsm_edges",
          "old_line_content": "    for (size_t edge_idx = 0; edge_idx < nfsm_edges.size(); ++edge_idx) {",
          "new_line_content": "    m_dfsm_states[dfsm_state_idx].outgoing_edges.init(thd->mem_root);",
          "content_same": false
        },
        {
          "line": 1722,
          "old_api": "ast state in the group? If not, keep iterating.",
          "new_api": "); ++edge_idx) {",
          "old_text": "ast state in the group? If not, keep iterating.\n     ",
          "new_text": "); ++edge_idx) {\n  ",
          "old_line_content": "      nfsm_states.push_back(nfsm_edges[edge_idx].state_idx);",
          "new_line_content": "    nfsm_states.clear();",
          "content_same": false
        },
        {
          "line": 1747,
          "old_api": "e that matches the",
          "new_api": "end",
          "old_text": "e that matches the ",
          "new_text": "s.end());\n      n",
          "old_line_content": "      nfsm_states.resize(distance(nfsm_states.begin(), new_end));",
          "new_line_content": "      sort(nfsm_states.begin(), nfsm_states.end());",
          "content_same": false
        },
        {
          "line": 1755,
          "old_api": "break;\n        }\n      }",
          "new_api": "m_d",
          "old_text": "       break;\n        }\n      }\n  ",
          "new_text": "              m_d",
          "old_line_content": "                  m_dfsm_states[i].nfsm_states.end())) {",
          "new_line_content": "        if (equal(nfsm_states.begin(), nfsm_states.end(),",
          "content_same": false
        },
        {
          "line": 1766,
          "old_api": "- 1;\n      }",
          "new_api": "zeDFSMState",
          "old_text": " - 1;\n      }\n\n     ",
          "new_text": "zeDFSMState(thd, ",
          "old_line_content": "        FinalizeDFSMState(thd, m_dfsm_states.size() - 1);",
          "new_line_content": "        state.nfsm_states = move(nfsm_states);",
          "content_same": false
        },
        {
          "line": 1767,
          "old_api": "gnore self-edges; th",
          "new_api": "target_dfs",
          "old_text": "gnore self-edges; th",
          "new_text": " target_dfs",
          "old_line_content": "        target_dfsm_state_idx = m_dfsm_states.size() - 1;",
          "new_line_content": "        m_dfsm_states.push_back(move(state));",
          "content_same": false
        },
        {
          "line": 1809,
          "old_api": "items[ordering[",
          "new_api": "0; i < ordering.siz",
          "old_text": "items[ordering[",
          "new_text": " 0; i < ordering.siz",
          "old_line_content": "  for (size_t i = 0; i < ordering.size(); ++i) {",
          "new_line_content": "  const bool is_grouping = IsGrouping(ordering);",
          "content_same": false
        },
        {
          "line": 1811,
          "old_api": "ORDER_DESC) {\n      ret += \" DESC\";\n    }",
          "new_api": "items[ordering[",
          "old_text": "ORDER_DESC) {\n      ret += \" DESC\";\n    }\n  ",
          "new_text": "items[ordering[",
          "old_line_content": "    ret += ItemToString(m_items[ordering[i].item].item);",
          "new_line_content": "  for (size_t i = 0; i < ordering.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 1860,
          "old_api": "x].always_active) {\n        *trace += \" [always active]\"",
          "new_api": "ndency",
          "old_text": "x].always_active) {\n        *trace += \" [always active]\"",
          "new_text": "ndency(m_fds",
          "old_line_content": "          \" - \" + PrintFunctionalDependency(m_fds[fd_idx], /*html=*/false);",
          "new_line_content": "    for (size_t fd_idx = 1; fd_idx < m_fds.size(); ++fd_idx) {",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": "Element element : ordering.or",
          "new_api": "ordering.ordering)) {\n      *trace",
          "old_text": "Element element : ordering.or",
          "new_text": "ordering.ordering)) {\n      *trace ",
          "old_line_content": "    if (IsGrouping(ordering.ordering)) {",
          "new_line_content": "    *trace += StringPrintf(\" - %zu: \", order_idx);",
          "content_same": false
        },
        {
          "line": 1933,
          "old_api": "race += \"}\\n\";\n}\n\nvoid LogicalOrderings::PrintDFSMDot",
          "new_api": "c_str",
          "old_text": "race += \"}\\n\";\n}\n\nvoid LogicalOrderings::PrintDFSMDot",
          "new_text": "te_idx,\n            PrintFunctionalDependency(*fd, /*html=*/true).c_str());\n      }\n    }\n  }\n\n  *trace += \"}\\n\";\n}\n\nvoid LogicalOrderings::PrintDFSMDott",
          "old_line_content": "            PrintFunctionalDependency(*fd, /*html=*/true).c_str());",
          "new_line_content": "        *trace += StringPrintf(",
          "content_same": false
        },
        {
          "line": 1945,
          "old_api": "for (size_t i = 0; i < state.nfsm_stat",
          "new_api": "[state_idx];\n    *tr",
          "old_text": "\n    for (size_t i = 0; i < state.nfsm_stat",
          "new_text": "[state_idx];\n    *tr",
          "old_line_content": "    *trace += StringPrintf(\"  s%zu [label=< \", state_idx);",
          "new_line_content": "  for (size_t state_idx = 0; state_idx < m_dfsm_states.size(); ++state_idx) {",
          "content_same": false
        },
        {
          "line": 1979,
          "old_api": "race += \"}\\n\";\n}",
          "new_api": "c_str",
          "old_text": "race += \"}\\n\";\n}\n",
          "new_text": "te_idx,\n            PrintFunctionalDependency(*fd, /*html=*/true).c_str());\n      }\n    }\n  }\n\n  *trace += \"}\\n\";\n}\n",
          "old_line_content": "            PrintFunctionalDependency(*fd, /*html=*/true).c_str());",
          "new_line_content": "        *trace += StringPrintf(",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1664,
          "old_api": null,
          "new_api": "m_states, &generation,",
          "old_text": null,
          "new_text": "m_states, &generation,\n         ",
          "old_line_content": "                               /*extra_allowed_fd_idx=*/0);",
          "new_line_content": "  initial.nfsm_states.push_back(0);",
          "content_same": false
        },
        {
          "line": 1538,
          "old_api": null,
          "new_api": "e == NFSMState::IN",
          "old_text": null,
          "new_text": "e == NFSMState::IN",
          "old_line_content": "              reachable[next_state_idx * N + k]) {",
          "new_line_content": "        for (size_t k = 1; k < m_orderings.size(); ++k) {",
          "content_same": false
        },
        {
          "line": 1667,
          "old_api": null,
          "new_api": "information",
          "old_text": null,
          "new_text": " information ",
          "old_line_content": "",
          "new_line_content": "  m_dfsm_states.push_back(move(initial));",
          "content_same": false
        },
        {
          "line": 1668,
          "old_api": null,
          "new_api": "y FinalizeDFSMState() will include thos",
          "old_text": null,
          "new_text": "y FinalizeDFSMState() will include thos",
          "old_line_content": "  // Reachability information set by FinalizeDFSMState() will include those",
          "new_line_content": "  FinalizeDFSMState(thd, /*state_idx=*/0);",
          "content_same": false
        },
        {
          "line": 1929,
          "old_api": null,
          "new_api": "required_fd",
          "old_text": null,
          "new_text": "             edge.state_idx, edge.required_fd_idx - INT_MIN);\n      } else {\n        const FunctionalDependency *fd = edge.required_fd(this",
          "old_line_content": "      } else {",
          "new_line_content": "            StringPrintf(\"  s%zu -> s%d [label=\\\"ordering %d\\\"]\\n\", state_idx,",
          "content_same": false
        },
        {
          "line": 1674,
          "old_api": null,
          "new_api": "below.\n  Mem_root_array<int> nfsm_states(thd->mem_r",
          "old_text": null,
          "new_text": " below.\n  Mem_root_array<int> nfsm_states(thd->mem_r",
          "old_line_content": "  // Used in iteration below.",
          "new_line_content": "  m_dfsm_states[0].can_reach_interesting_order.reset();",
          "content_same": false
        },
        {
          "line": 1548,
          "old_api": null,
          "new_api": "esize",
          "old_text": null,
          "new_text": "esize(state.outgoing_edges.",
          "old_line_content": "          pruned_anything = true;",
          "new_line_content": "              state.outgoing_edges[state.outgoing_edges.size() - 1];",
          "content_same": false
        },
        {
          "line": 1549,
          "old_api": null,
          "new_api": ";\n        }\n      }\n    }",
          "old_text": null,
          "new_text": ";\n        }\n      }\n    }\n\n",
          "old_line_content": "        }",
          "new_line_content": "          state.outgoing_edges.resize(state.outgoing_edges.size() - 1);",
          "content_same": false
        },
        {
          "line": 1932,
          "old_api": null,
          "new_api": "s%d [label=\\\"%s\\\"]\\n\",",
          "old_text": null,
          "new_text": "s%d [label=\\\"%s\\\"]\\n\",",
          "old_line_content": "            \"  s%zu -> s%d [label=\\\"%s\\\"]\\n\", state_idx, edge.state_idx,",
          "new_line_content": "        const FunctionalDependency *fd = edge.required_fd(this);",
          "content_same": false
        },
        {
          "line": 1935,
          "old_api": null,
          "new_api": "race += \"}\\n\";\n}\n\nvoid LogicalOrderings::PrintDFSMDot",
          "old_text": null,
          "new_text": "race += \"}\\n\";\n}\n\nvoid LogicalOrderings::PrintDFSMDot",
          "old_line_content": "    }",
          "new_line_content": "            PrintFunctionalDependency(*fd, /*html=*/true).c_str());",
          "content_same": false
        },
        {
          "line": 1680,
          "old_api": null,
          "new_api": "outgoing edges from",
          "old_text": null,
          "new_text": " outgoing edges from",
          "old_line_content": "    // Take the union of all outgoing edges from the constituent NFSM m_states,",
          "new_line_content": "  for (size_t dfsm_state_idx = 0; dfsm_state_idx < m_dfsm_states.size();",
          "content_same": false
        },
        {
          "line": 1685,
          "old_api": null,
          "new_api": "].nfsm_states) {",
          "old_text": null,
          "new_text": "].nfsm_states) {\n ",
          "old_line_content": "      for (const int edge_idx : m_states[nfsm_state_idx].outgoing_edges) {",
          "new_line_content": "    nfsm_edges.clear();",
          "content_same": false
        },
        {
          "line": 1813,
          "old_api": null,
          "new_api": "ORDER_DESC) {\n      ret += \" DESC\";\n    }",
          "old_text": null,
          "new_text": "ORDER_DESC) {\n      ret += \" DESC\";\n    }\n  ",
          "old_line_content": "      ret += \" DESC\";",
          "new_line_content": "    ret += ItemToString(m_items[ordering[i].item].item);",
          "content_same": false
        },
        {
          "line": 1689,
          "old_api": null,
          "new_api": "}\n      }\n    }\n\n    if (m_d",
          "old_text": null,
          "new_text": "        }\n      }\n    }\n\n    if (m_d",
          "old_line_content": "        }",
          "new_line_content": "        if (!AlwaysActiveFD(edge.required_fd_idx)) {",
          "content_same": false
        },
        {
          "line": 1690,
          "old_api": null,
          "new_api": "e",
          "old_text": null,
          "new_text": "e() >= kMaxDFSMStates) {\n ",
          "old_line_content": "      }",
          "new_line_content": "          nfsm_edges.push_back(edge);",
          "content_same": false
        },
        {
          "line": 1947,
          "old_api": null,
          "new_api": "for (size_t i = 0; i < state.nfsm_stat",
          "old_text": null,
          "new_text": "\n    for (size_t i = 0; i < state.nfsm_stat",
          "old_line_content": "    bool any_interesting = false;",
          "new_line_content": "    *trace += StringPrintf(\"  s%zu [label=< \", state_idx);",
          "content_same": false
        },
        {
          "line": 1564,
          "old_api": null,
          "new_api": "tgoing_edges[num",
          "old_text": null,
          "new_text": "tgoing_edges[num",
          "old_line_content": "        }",
          "new_line_content": "        if (edge.state(this)->type != NFSMState::DELETED) {",
          "content_same": false
        },
        {
          "line": 1950,
          "old_api": null,
          "new_api": "tate.nfsm_states[i]];",
          "old_text": null,
          "new_text": "tate.nfsm_states[i]];\n  ",
          "old_line_content": "      if (i != 0) {",
          "new_line_content": "    for (size_t i = 0; i < state.nfsm_states.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 1695,
          "old_api": null,
          "new_api": "ausing us to end fai",
          "old_text": null,
          "new_text": "ausing us to end fai",
          "old_line_content": "      // cutoff in BuildNFSM()). Note that since the paths representing explicit",
          "new_line_content": "    if (m_dfsm_states.size() >= kMaxDFSMStates) {",
          "content_same": false
        },
        {
          "line": 1568,
          "old_api": null,
          "new_api": "thing);\n\n  // Set the bitmask of what",
          "old_text": null,
          "new_text": "thing);\n\n  // Set the bitmask of what",
          "old_line_content": "  } while (pruned_anything);",
          "new_line_content": "      state.outgoing_edges.resize(num_kept);",
          "content_same": false
        },
        {
          "line": 1573,
          "old_api": null,
          "new_api": "type != OrderingWi",
          "old_text": null,
          "new_text": "type != OrderingWi",
          "old_line_content": "        order_idx >= kMaxSupportedOrderings) {",
          "new_line_content": "  for (size_t order_idx = 0; order_idx < m_orderings.size(); ++order_idx) {",
          "content_same": false
        },
        {
          "line": 1959,
          "old_api": null,
          "new_api": "State::INTERESTING) {\n        *trace += \"</b",
          "old_text": null,
          "new_text": "State::INTERESTING) {\n        *trace += \"</b",
          "old_line_content": "        *trace += \"</b>\";",
          "new_line_content": "      *trace += PrintOrdering(nsfm_state.satisfied_ordering);",
          "content_same": false
        },
        {
          "line": 1832,
          "old_api": null,
          "new_api": "s[fd.tail].item);\n    case FunctionalD",
          "old_text": null,
          "new_text": "s[fd.tail].item);\n    case FunctionalD",
          "old_line_content": "    case FunctionalDependency::FD: {",
          "new_line_content": "      return ItemToString(m_items[fd.head[0]].item) + \"=\" +",
          "content_same": false
        },
        {
          "line": 1833,
          "old_api": null,
          "new_api": "string ret = \"{\";\n      for (size_",
          "old_text": null,
          "new_text": " string ret = \"{\";\n      for (size_",
          "old_line_content": "      string ret = \"{\";",
          "new_line_content": "             ItemToString(m_items[fd.tail].item);",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": null,
          "new_api": "quired_fd_idx, b.state_idx);\n           }",
          "old_text": null,
          "new_text": "quired_fd_idx, b.state_idx);\n           }",
          "old_line_content": "           });",
          "new_line_content": "             return make_pair(a.required_fd_idx, a.state_idx) <",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "\n          unique(nfsm_edges.begin(), nfs",
          "old_line_content": "      auto new_end =",
          "new_line_content": "                    make_pair(b.required_fd_idx, b.state_idx);",
          "content_same": false
        },
        {
          "line": 1836,
          "old_api": null,
          "new_api": "ret +=",
          "old_text": null,
          "new_text": "       ret += ",
          "old_line_content": "          ret += \", \";",
          "new_line_content": "      for (size_t i = 0; i < fd.head.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 1583,
          "old_api": null,
          "new_api": "}\n  }\n}\n\nbool LogicalOrderings::AlwaysActiveFD(int f",
          "old_text": null,
          "new_text": "  }\n  }\n}\n\nbool LogicalOrderings::AlwaysActiveFD(int f",
          "old_line_content": "    }",
          "new_line_content": "        m_states[i].can_reach_interesting_order.set(order_idx);",
          "content_same": false
        },
        {
          "line": 1840,
          "old_api": null,
          "new_api": "= \"} &rarr; \";\n      } else {",
          "old_text": null,
          "new_text": "= \"} &rarr; \";\n      } else {\n        ",
          "old_line_content": "      if (html) {",
          "new_line_content": "        ret += ItemToString(m_items[fd.head[i]].item);",
          "content_same": false
        },
        {
          "line": 1714,
          "old_api": null,
          "new_api": "ir",
          "old_text": null,
          "new_text": "ir(b.required_fd_idx, b.state_idx);\n     ",
          "old_line_content": "                 });",
          "new_line_content": "                   return make_pair(a.required_fd_idx, a.state_idx) ==",
          "content_same": false
        },
        {
          "line": 1791,
          "old_api": null,
          "new_api": "dering",
          "old_text": null,
          "new_text": "dering() {\n  // Fin",
          "old_line_content": "  }",
          "new_line_content": "      nfsm_states.clear();",
          "content_same": false
        },
        {
          "line": 1717,
          "old_api": null,
          "new_api": "ich set of m_state",
          "old_text": null,
          "new_text": "ich set of m_state",
          "old_line_content": "",
          "new_line_content": "      nfsm_edges.resize(distance(nfsm_edges.begin(), new_end));",
          "content_same": false
        },
        {
          "line": 1847,
          "old_api": null,
          "new_api": ");\n  return \"\";\n}\n\nvoid LogicalOrde",
          "old_text": null,
          "new_text": ");\n  return \"\";\n}\n\nvoid LogicalOrde",
          "old_line_content": "    }",
          "new_line_content": "      ret += ItemToString(m_items[fd.tail].item);",
          "content_same": false
        },
        {
          "line": 1975,
          "old_api": null,
          "new_api": "required_fd",
          "old_text": null,
          "new_text": "             edge.state_idx, edge.required_fd_idx - INT_MIN);\n      } else {\n        const FunctionalDependency *fd = edge.required_fd(this",
          "old_line_content": "      } else {",
          "new_line_content": "            StringPrintf(\"  s%zu -> s%d [label=\\\"ordering %d\\\"]\\n\", state_idx,",
          "content_same": false
        },
        {
          "line": 1978,
          "old_api": null,
          "new_api": "s%d [label=\\\"%s\\\"]\\n\",",
          "old_text": null,
          "new_text": "s%d [label=\\\"%s\\\"]\\n\",",
          "old_line_content": "            \"  s%zu -> s%d [label=\\\"%s\\\"]\\n\", state_idx, edge.state_idx,",
          "new_line_content": "        const FunctionalDependency *fd = edge.required_fd(this);",
          "content_same": false
        },
        {
          "line": 1723,
          "old_api": null,
          "new_api": "dx].state_idx);",
          "old_text": null,
          "new_text": "dx].state_idx);\n\n",
          "old_line_content": "",
          "new_line_content": "    for (size_t edge_idx = 0; edge_idx < nfsm_edges.size(); ++edge_idx) {",
          "content_same": false
        },
        {
          "line": 1724,
          "old_api": null,
          "new_api": "ast state in the group? If not, keep iterating.",
          "old_text": null,
          "new_text": "ast state in the group? If not, keep iterating.\n     ",
          "old_line_content": "      // Is this the last state in the group? If not, keep iterating.",
          "new_line_content": "      nfsm_states.push_back(nfsm_edges[edge_idx].state_idx);",
          "content_same": false
        },
        {
          "line": 1851,
          "old_api": null,
          "new_api": "es",
          "old_text": null,
          "new_text": "es(string *tr",
          "old_line_content": "}",
          "new_line_content": "  assert(false);",
          "content_same": false
        },
        {
          "line": 1981,
          "old_api": null,
          "new_api": "race += \"}\\n\";\n}",
          "old_text": null,
          "new_text": "race += \"}\\n\";\n}\n",
          "old_line_content": "    }",
          "new_line_content": "            PrintFunctionalDependency(*fd, /*html=*/true).c_str());",
          "content_same": false
        },
        {
          "line": 1727,
          "old_api": null,
          "new_api": "nfsm_e",
          "old_text": null,
          "new_text": "           nfsm_e",
          "old_line_content": "              nfsm_edges[edge_idx + 1].required_fd_idx) {",
          "new_line_content": "      if (edge_idx != nfsm_edges.size() - 1 &&",
          "content_same": false
        },
        {
          "line": 1856,
          "old_api": null,
          "new_api": ").\\n\\n\";\n  }",
          "old_text": null,
          "new_text": ").\\n\\n\";\n  }",
          "old_line_content": "  } else {",
          "new_line_content": "  if (m_fds.size() <= 1) {",
          "content_same": false
        },
        {
          "line": 1601,
          "old_api": null,
          "new_api": "can_reach_interesting_order |=\n        m_states[n",
          "old_text": null,
          "new_text": "can_reach_interesting_order |=\n        m_states[n",
          "old_line_content": "    state.can_reach_interesting_order |=",
          "new_line_content": "      state.follows_interesting_order.set(ordering_idx);",
          "content_same": false
        },
        {
          "line": 1862,
          "old_api": null,
          "new_api": "x].always_active) {\n        *trace += \" [always active]\"",
          "old_text": null,
          "new_text": "x].always_active) {\n        *trace += \" [always active]\"",
          "old_line_content": "        *trace += \" [always active]\";",
          "new_line_content": "          \" - \" + PrintFunctionalDependency(m_fds[fd_idx], /*html=*/false);",
          "content_same": false
        },
        {
          "line": 1607,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "d(), state_i",
          "old_line_content": "}",
          "new_line_content": "      Bounds_checked_array<int>::Alloc(thd->mem_root, m_fds.size());",
          "content_same": false
        },
        {
          "line": 1608,
          "old_api": null,
          "new_api": "dThroughAlwaysActiveFD",
          "old_text": null,
          "new_text": "dThroughAlwaysActiveFD",
          "old_line_content": "",
          "new_line_content": "  fill(state.next_state.begin(), state.next_state.end(), state_idx);",
          "content_same": false
        },
        {
          "line": 1736,
          "old_api": null,
          "new_api": "set to contain any ϵ-edges and always",
          "old_text": null,
          "new_text": "set to contain any ϵ-edges and always",
          "old_line_content": "      }",
          "new_line_content": "          nfsm_states.push_back(nfsm_state_idx);",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": null,
          "new_api": "m_states)[i]];",
          "old_text": null,
          "new_text": "m_states)[i]];\n    ",
          "old_line_content": "    for (int outgoing_edge_idx : state.outgoing_edges) {",
          "new_line_content": "  for (size_t i = 0; i < nfsm_states->size(); ++i) {",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "            nfsm_edges[edge_idx].required_fd_idx);\n\n      // Canonicalize: Sort and deduplicate.\n      sort(nfsm_states.begin(),",
          "old_line_content": "",
          "new_line_content": "      ExpandThroughAlwaysActiveFDs(&nfsm_states, &generation,",
          "content_same": false
        },
        {
          "line": 1874,
          "old_api": null,
          "new_api": "erings[order_idx];",
          "old_text": null,
          "new_text": "erings[order_idx];",
          "old_line_content": "    if (order_idx == 0 && ordering.type == OrderingWithInfo::UNINTERESTING) {",
          "new_line_content": "  for (size_t order_idx = 0; order_idx < m_orderings.size(); ++order_idx) {",
          "content_same": false
        },
        {
          "line": 1619,
          "old_api": null,
          "new_api": "== extra_allowed_fd_idx) &&",
          "old_text": null,
          "new_text": " == extra_allowed_fd_idx) &&\n       ",
          "old_line_content": "          m_states[edge.state_idx].seen != *generation) {",
          "new_line_content": "      if ((AlwaysActiveFD(edge.required_fd_idx) ||",
          "content_same": false
        },
        {
          "line": 1748,
          "old_api": null,
          "new_api": "end));\n\n      //",
          "old_text": null,
          "new_text": "end));\n\n      // ",
          "old_line_content": "",
          "new_line_content": "      auto new_end = unique(nfsm_states.begin(), nfsm_states.end());",
          "content_same": false
        },
        {
          "line": 1749,
          "old_api": null,
          "new_api": "e that matches the",
          "old_text": null,
          "new_text": "e that matches the ",
          "old_line_content": "      // See if there is an existing DFSM state that matches the set of",
          "new_line_content": "      nfsm_states.resize(distance(nfsm_states.begin(), new_end));",
          "content_same": false
        },
        {
          "line": 1622,
          "old_api": null,
          "new_api": "].seen = *generation;\n      }\n    }",
          "old_text": null,
          "new_text": "].seen = *generation;\n      }\n    }\n  ",
          "old_line_content": "      }",
          "new_line_content": "        nfsm_states->push_back(edge.state_idx);",
          "content_same": false
        },
        {
          "line": 1882,
          "old_api": null,
          "new_api": "Element element : ordering.or",
          "old_text": null,
          "new_text": "Element element : ordering.or",
          "old_line_content": "    }",
          "new_line_content": "    if (IsGrouping(ordering.ordering)) {",
          "content_same": false
        },
        {
          "line": 1756,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "tates.end())) {\n          target_dfs",
          "old_line_content": "          target_dfsm_state_idx = i;",
          "new_line_content": "                  m_dfsm_states[i].nfsm_states.begin(),",
          "content_same": false
        },
        {
          "line": 1757,
          "old_api": null,
          "new_api": "break;\n        }\n      }",
          "old_text": null,
          "new_text": "       break;\n        }\n      }\n  ",
          "old_line_content": "          break;",
          "new_line_content": "                  m_dfsm_states[i].nfsm_states.end())) {",
          "content_same": false
        },
        {
          "line": 1890,
          "old_api": null,
          "new_api": "DESC) {\n        *trace += \" DESC\";",
          "old_text": null,
          "new_text": "DESC) {\n        *trace += \" DESC\";\n     ",
          "old_line_content": "        *trace += \" DESC\";",
          "new_line_content": "      *trace += ItemToString(m_items[element.item].item);",
          "content_same": false
        },
        {
          "line": 1895,
          "old_api": null,
          "new_api": "== OrderingWithInfo::HOMO",
          "old_text": null,
          "new_text": "== OrderingWithInfo::HOMO",
          "old_line_content": "    }",
          "new_line_content": "    if (ordering.ordering.empty()) {",
          "content_same": false
        },
        {
          "line": 1768,
          "old_api": null,
          "new_api": "- 1;\n      }",
          "old_text": null,
          "new_text": " - 1;\n      }\n\n     ",
          "old_line_content": "      }",
          "new_line_content": "        FinalizeDFSMState(thd, m_dfsm_states.size() - 1);",
          "content_same": false
        },
        {
          "line": 1769,
          "old_api": null,
          "new_api": "gnore self-edges; th",
          "old_text": null,
          "new_text": "gnore self-edges; th",
          "old_line_content": "",
          "new_line_content": "        target_dfsm_state_idx = m_dfsm_states.size() - 1;",
          "content_same": false
        },
        {
          "line": 1516,
          "old_api": null,
          "new_api": "m_states",
          "old_text": null,
          "new_text": "          m_states",
          "old_line_content": "            m_states[j].type == NFSMState::INTERESTING) {",
          "new_line_content": "      for (int j = 1; j < static_cast<int>(m_orderings.size()); ++j) {",
          "content_same": false
        },
        {
          "line": 1773,
          "old_api": null,
          "new_api": "e edge;\n        edge.required_fd_idx = nfs",
          "old_text": null,
          "new_text": "e edge;\n        edge.required_fd_idx = nfs",
          "old_line_content": "        edge.required_fd_idx = nfsm_edges[edge_idx].required_fd_idx;",
          "new_line_content": "      if (static_cast<size_t>(target_dfsm_state_idx) != dfsm_state_idx) {",
          "content_same": false
        },
        {
          "line": 1777,
          "old_api": null,
          "new_api": "sm_state_idx];\n        dfsm_",
          "old_text": null,
          "new_text": "sm_state_idx];\n        dfsm_",
          "old_line_content": "        DFSMState &dfsm_state = m_dfsm_states[dfsm_state_idx];",
          "new_line_content": "        m_dfsm_edges.push_back(edge);",
          "content_same": false
        },
        {
          "line": 1780,
          "old_api": null,
          "new_api": "sm_state.next_state",
          "old_text": null,
          "new_text": "sm_state.next_state",
          "old_line_content": "          dfsm_state.next_state[edge.required_fd_idx] = target_dfsm_state_idx;",
          "new_line_content": "        dfsm_state.outgoing_edges.push_back(m_dfsm_edges.size() - 1);",
          "content_same": false
        },
        {
          "line": 1910,
          "old_api": null,
          "new_api": "];\n    if (stat",
          "old_text": null,
          "new_text": "];\n    if (stat",
          "old_line_content": "    if (state.type == NFSMState::DELETED) {",
          "new_line_content": "  for (size_t state_idx = 0; state_idx < m_states.size(); ++state_idx) {",
          "content_same": false
        },
        {
          "line": 1785,
          "old_api": null,
          "new_api": "}\n\n      // Prepare for the next group.\n      nfs",
          "old_text": null,
          "new_text": "  }\n\n      // Prepare for the next group.\n      nfs",
          "old_line_content": "        }",
          "new_line_content": "            dfsm_state.can_use_fd.set(edge.required_fd_idx - 1);",
          "content_same": false
        },
        {
          "line": 1917,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "tOrdering(state.satisfied_ordering).c_str());\n    if (state.type == NFSMState::INTERESTING) {\n      *trace += \", peripherie",
          "old_line_content": "    if (state.type == NFSMState::INTERESTING) {",
          "new_line_content": "    *trace += StringPrintf(\"  s%zu [label=\\\"%s\\\"\", state_idx,",
          "content_same": false
        },
        {
          "line": 1918,
          "old_api": null,
          "new_api": "te::INTERESTING) {\n      *trace += \", peripheri",
          "old_text": null,
          "new_text": "te::INTERESTING) {\n      *trace += \", peripheri",
          "old_line_content": "      *trace += \", peripheries=2\";",
          "new_line_content": "                           PrintOrdering(state.satisfied_ordering).c_str());",
          "content_same": false
        },
        {
          "line": 1535,
          "old_api": null,
          "new_api": "dx = m_edges[state.outgoing",
          "old_text": null,
          "new_text": "dx = m_edges[state.outgoing",
          "old_line_content": "        bool can_reach_other_interesting = false;",
          "new_line_content": "      for (size_t j = 0; j < state.outgoing_edges.size(); ++j) {",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1536,
          "old_api": "e == NFSMState::IN",
          "new_api": null,
          "old_text": "e == NFSMState::IN",
          "new_text": null,
          "old_line_content": "        for (size_t k = 1; k < m_orderings.size(); ++k) {",
          "new_line_content": "        const int next_state_idx = m_edges[state.outgoing_edges[j]].state_idx;",
          "content_same": false
        },
        {
          "line": 1666,
          "old_api": "y FinalizeDFSMState() will include thos",
          "new_api": null,
          "old_text": "y FinalizeDFSMState() will include thos",
          "new_text": null,
          "old_line_content": "  FinalizeDFSMState(thd, /*state_idx=*/0);",
          "new_line_content": "                               /*extra_allowed_fd_idx=*/0);",
          "content_same": false
        },
        {
          "line": 1927,
          "old_api": "required_fd",
          "new_api": null,
          "old_text": "             edge.state_idx, edge.required_fd_idx - INT_MIN);\n      } else {\n        const FunctionalDependency *fd = edge.required_fd(this",
          "new_text": null,
          "old_line_content": "            StringPrintf(\"  s%zu -> s%d [label=\\\"ordering %d\\\"]\\n\", state_idx,",
          "new_line_content": "        // Pseudo-edge without a FD (from initial state only).",
          "content_same": false
        },
        {
          "line": 1672,
          "old_api": "below.\n  Mem_root_array<int> nfsm_states(thd->mem_r",
          "new_api": null,
          "old_text": " below.\n  Mem_root_array<int> nfsm_states(thd->mem_r",
          "new_text": null,
          "old_line_content": "  m_dfsm_states[0].can_reach_interesting_order.reset();",
          "new_line_content": "  // Clear it; this isn't 100% active if interesting orderings can be reached",
          "content_same": false
        },
        {
          "line": 1546,
          "old_api": "esize",
          "new_api": null,
          "old_text": "esize(state.outgoing_edges.",
          "new_text": null,
          "old_line_content": "              state.outgoing_edges[state.outgoing_edges.size() - 1];",
          "new_line_content": "          // Remove this edge.",
          "content_same": false
        },
        {
          "line": 1547,
          "old_api": ";\n        }\n      }\n    }",
          "new_api": null,
          "old_text": ";\n        }\n      }\n    }\n\n",
          "new_text": null,
          "old_line_content": "          state.outgoing_edges.resize(state.outgoing_edges.size() - 1);",
          "new_line_content": "          state.outgoing_edges[j] =",
          "content_same": false
        },
        {
          "line": 1930,
          "old_api": "s%d [label=\\\"%s\\\"]\\n\",",
          "new_api": null,
          "old_text": "s%d [label=\\\"%s\\\"]\\n\",",
          "new_text": null,
          "old_line_content": "        const FunctionalDependency *fd = edge.required_fd(this);",
          "new_line_content": "                         edge.state_idx, edge.required_fd_idx - INT_MIN);",
          "content_same": false
        },
        {
          "line": 1931,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "te_idx,\n            PrintFunctionalDependency(*fd, /*html=*/true).c_str());\n      }\n    }\n  }\n\n  *trace += \"}\\n\";\n}\n\nvoid LogicalOrderings::PrintDFSMDott",
          "new_text": null,
          "old_line_content": "        *trace += StringPrintf(",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 1678,
          "old_api": "outgoing edges from",
          "new_api": null,
          "old_text": " outgoing edges from",
          "new_text": null,
          "old_line_content": "  for (size_t dfsm_state_idx = 0; dfsm_state_idx < m_dfsm_states.size();",
          "new_line_content": "  Mem_root_array<NFSMEdge> nfsm_edges(thd->mem_root);",
          "content_same": false
        },
        {
          "line": 1807,
          "old_api": "0; i < ordering.siz",
          "new_api": null,
          "old_text": " 0; i < ordering.siz",
          "new_text": null,
          "old_line_content": "  const bool is_grouping = IsGrouping(ordering);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1683,
          "old_api": "].nfsm_states) {",
          "new_api": null,
          "old_text": "].nfsm_states) {\n ",
          "new_text": null,
          "old_line_content": "    nfsm_edges.clear();",
          "new_line_content": "    // ignoring ϵ-edges and always active FDs, since we have special handling of",
          "content_same": false
        },
        {
          "line": 1687,
          "old_api": "}\n      }\n    }\n\n    if (m_d",
          "new_api": null,
          "old_text": "        }\n      }\n    }\n\n    if (m_d",
          "new_text": null,
          "old_line_content": "        if (!AlwaysActiveFD(edge.required_fd_idx)) {",
          "new_line_content": "      for (const int edge_idx : m_states[nfsm_state_idx].outgoing_edges) {",
          "content_same": false
        },
        {
          "line": 1560,
          "old_api": "m_edges[state.outgoing_edg",
          "new_api": null,
          "old_text": " m_edges[state.outgoing_edg",
          "new_text": null,
          "old_line_content": "      for (size_t j = 0; j < state.outgoing_edges.size(); ++j) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1688,
          "old_api": "e",
          "new_api": null,
          "old_text": "e() >= kMaxDFSMStates) {\n ",
          "new_text": null,
          "old_line_content": "          nfsm_edges.push_back(edge);",
          "new_line_content": "        const NFSMEdge &edge = m_edges[edge_idx];",
          "content_same": false
        },
        {
          "line": 1943,
          "old_api": "[state_idx];\n    *tr",
          "new_api": null,
          "old_text": "[state_idx];\n    *tr",
          "new_text": null,
          "old_line_content": "  for (size_t state_idx = 0; state_idx < m_dfsm_states.size(); ++state_idx) {",
          "new_line_content": "void LogicalOrderings::PrintDFSMDottyGraph(string *trace) const {",
          "content_same": false
        },
        {
          "line": 1948,
          "old_api": "tate.nfsm_states[i]];",
          "new_api": null,
          "old_text": "tate.nfsm_states[i]];\n  ",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i < state.nfsm_states.size(); ++i) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1693,
          "old_api": "ausing us to end fai",
          "new_api": null,
          "old_text": "ausing us to end fai",
          "new_text": null,
          "old_line_content": "    if (m_dfsm_states.size() >= kMaxDFSMStates) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1566,
          "old_api": "thing);\n\n  // Set the bitmask of what",
          "new_api": null,
          "old_text": "thing);\n\n  // Set the bitmask of what",
          "new_text": null,
          "old_line_content": "      state.outgoing_edges.resize(num_kept);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1571,
          "old_api": "type != OrderingWi",
          "new_api": null,
          "old_text": "type != OrderingWi",
          "new_text": null,
          "old_line_content": "  for (size_t order_idx = 0; order_idx < m_orderings.size(); ++order_idx) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1915,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "tOrdering(state.satisfied_ordering).c_str());\n    if (state.type == NFSMState::INTERESTING) {\n      *trace += \", peripherie",
          "new_text": null,
          "old_line_content": "    *trace += StringPrintf(\"  s%zu [label=\\\"%s\\\"\", state_idx,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1957,
          "old_api": "State::INTERESTING) {\n        *trace += \"</b",
          "new_api": null,
          "old_text": "State::INTERESTING) {\n        *trace += \"</b",
          "new_text": null,
          "old_line_content": "      *trace += PrintOrdering(nsfm_state.satisfied_ordering);",
          "new_line_content": "        *trace += \"<b>\";",
          "content_same": false
        },
        {
          "line": 1830,
          "old_api": "s[fd.tail].item);\n    case FunctionalD",
          "new_api": null,
          "old_text": "s[fd.tail].item);\n    case FunctionalD",
          "new_text": null,
          "old_line_content": "      return ItemToString(m_items[fd.head[0]].item) + \"=\" +",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1831,
          "old_api": "string ret = \"{\";\n      for (size_",
          "new_api": null,
          "old_text": " string ret = \"{\";\n      for (size_",
          "new_text": null,
          "old_line_content": "             ItemToString(m_items[fd.tail].item);",
          "new_line_content": "    case FunctionalDependency::EQUIVALENCE:",
          "content_same": false
        },
        {
          "line": 1704,
          "old_api": "return ma",
          "new_api": null,
          "old_text": "       return ma",
          "new_text": null,
          "old_line_content": "      sort(nfsm_edges.begin(), nfsm_edges.end(),",
          "new_line_content": "      // Sort and deduplicate the edges. Note that we sort on FD first,",
          "content_same": false
        },
        {
          "line": 1789,
          "old_api": "dering",
          "new_api": null,
          "old_text": "dering() {\n  // Fin",
          "new_text": null,
          "old_line_content": "      nfsm_states.clear();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1834,
          "old_api": "ret +=",
          "new_api": null,
          "old_text": "       ret += ",
          "new_text": null,
          "old_line_content": "      for (size_t i = 0; i < fd.head.size(); ++i) {",
          "new_line_content": "    case FunctionalDependency::FD: {",
          "content_same": false
        },
        {
          "line": 1707,
          "old_api": "begin",
          "new_api": null,
          "old_text": "\n          unique(nfsm_edges.begin(), nfs",
          "new_text": null,
          "old_line_content": "                    make_pair(b.required_fd_idx, b.state_idx);",
          "new_line_content": "           [](const NFSMEdge &a, const NFSMEdge &b) {",
          "content_same": false
        },
        {
          "line": 1581,
          "old_api": "}\n  }\n}\n\nbool LogicalOrderings::AlwaysActiveFD(int f",
          "new_api": null,
          "old_text": "  }\n  }\n}\n\nbool LogicalOrderings::AlwaysActiveFD(int f",
          "new_text": null,
          "old_line_content": "        m_states[i].can_reach_interesting_order.set(order_idx);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1710,
          "old_api": "",
          "new_api": null,
          "old_text": "                ",
          "new_text": null,
          "old_line_content": "          unique(nfsm_edges.begin(), nfsm_edges.end(),",
          "new_line_content": "           });",
          "content_same": false
        },
        {
          "line": 1838,
          "old_api": "= \"} &rarr; \";\n      } else {",
          "new_api": null,
          "old_text": "= \"} &rarr; \";\n      } else {\n        ",
          "new_text": null,
          "old_line_content": "        ret += ItemToString(m_items[fd.head[i]].item);",
          "new_line_content": "          ret += \", \";",
          "content_same": false
        },
        {
          "line": 1713,
          "old_api": "resize",
          "new_api": null,
          "old_text": "es.resize(distance(nfsm_edges.begin(), ne",
          "new_text": null,
          "old_line_content": "                          make_pair(b.required_fd_idx, b.state_idx);",
          "new_line_content": "                 [](const NFSMEdge &a, const NFSMEdge &b) {",
          "content_same": false
        },
        {
          "line": 1845,
          "old_api": ");\n  return \"\";\n}\n\nvoid LogicalOrde",
          "new_api": null,
          "old_text": ");\n  return \"\";\n}\n\nvoid LogicalOrde",
          "new_text": null,
          "old_line_content": "      ret += ItemToString(m_items[fd.tail].item);",
          "new_line_content": "        ret += \"} -> \";",
          "content_same": false
        },
        {
          "line": 1973,
          "old_api": "required_fd",
          "new_api": null,
          "old_text": "             edge.state_idx, edge.required_fd_idx - INT_MIN);\n      } else {\n        const FunctionalDependency *fd = edge.required_fd(this",
          "new_text": null,
          "old_line_content": "            StringPrintf(\"  s%zu -> s%d [label=\\\"ordering %d\\\"]\\n\", state_idx,",
          "new_line_content": "        // Pseudo-edge without a FD (from initial state only).",
          "content_same": false
        },
        {
          "line": 1719,
          "old_api": "clear",
          "new_api": null,
          "old_text": "tes.clear();\n    for (size_t edge_idx = 0; edge_idx < nfsm_edges",
          "new_text": null,
          "old_line_content": "    m_dfsm_states[dfsm_state_idx].outgoing_edges.init(thd->mem_root);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1720,
          "old_api": "); ++edge_idx) {",
          "new_api": null,
          "old_text": "); ++edge_idx) {\n  ",
          "new_text": null,
          "old_line_content": "    nfsm_states.clear();",
          "new_line_content": "    // For each relevant FD, find out which set of m_states we could reach.",
          "content_same": false
        },
        {
          "line": 1849,
          "old_api": "es",
          "new_api": null,
          "old_text": "es(string *tr",
          "new_text": null,
          "old_line_content": "  assert(false);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1976,
          "old_api": "s%d [label=\\\"%s\\\"]\\n\",",
          "new_api": null,
          "old_text": "s%d [label=\\\"%s\\\"]\\n\",",
          "new_text": null,
          "old_line_content": "        const FunctionalDependency *fd = edge.required_fd(this);",
          "new_line_content": "                         edge.state_idx, edge.required_fd_idx - INT_MIN);",
          "content_same": false
        },
        {
          "line": 1977,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "te_idx,\n            PrintFunctionalDependency(*fd, /*html=*/true).c_str());\n      }\n    }\n  }\n\n  *trace += \"}\\n\";\n}\n",
          "new_text": null,
          "old_line_content": "        *trace += StringPrintf(",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 1725,
          "old_api": "nfsm_e",
          "new_api": null,
          "old_text": "           nfsm_e",
          "new_text": null,
          "old_line_content": "      if (edge_idx != nfsm_edges.size() - 1 &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1854,
          "old_api": ").\\n\\n\";\n  }",
          "new_api": null,
          "old_text": ").\\n\\n\";\n  }",
          "new_text": null,
          "old_line_content": "  if (m_fds.size() <= 1) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": "can_reach_interesting_order |=\n        m_states[n",
          "new_api": null,
          "old_text": "can_reach_interesting_order |=\n        m_states[n",
          "new_text": null,
          "old_line_content": "      state.follows_interesting_order.set(ordering_idx);",
          "new_line_content": "        ordering_idx < kMaxSupportedOrderings &&",
          "content_same": false
        },
        {
          "line": 1858,
          "old_api": "ndency",
          "new_api": null,
          "old_text": "ndency(m_fds",
          "new_text": null,
          "old_line_content": "    for (size_t fd_idx = 1; fd_idx < m_fds.size(); ++fd_idx) {",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 1605,
          "old_api": "d",
          "new_api": null,
          "old_text": "d(), state_i",
          "new_text": null,
          "old_line_content": "      Bounds_checked_array<int>::Alloc(thd->mem_root, m_fds.size());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1606,
          "old_api": "dThroughAlwaysActiveFD",
          "new_api": null,
          "old_text": "dThroughAlwaysActiveFD",
          "new_text": null,
          "old_line_content": "  fill(state.next_state.begin(), state.next_state.end(), state_idx);",
          "new_line_content": "  state.next_state =",
          "content_same": false
        },
        {
          "line": 1734,
          "old_api": "set to contain any ϵ-edges and always",
          "new_api": null,
          "old_text": "set to contain any ϵ-edges and always",
          "new_text": null,
          "old_line_content": "          nfsm_states.push_back(nfsm_state_idx);",
          "new_line_content": "      for (int nfsm_state_idx : m_dfsm_states[dfsm_state_idx].nfsm_states) {",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": "m_states)[i]];",
          "new_api": null,
          "old_text": "m_states)[i]];\n    ",
          "new_text": null,
          "old_line_content": "  for (size_t i = 0; i < nfsm_states->size(); ++i) {",
          "new_line_content": "    int extra_allowed_fd_idx) {",
          "content_same": false
        },
        {
          "line": 1741,
          "old_api": "begin",
          "new_api": null,
          "old_text": "            nfsm_edges[edge_idx].required_fd_idx);\n\n      // Canonicalize: Sort and deduplicate.\n      sort(nfsm_states.begin(),",
          "new_text": null,
          "old_line_content": "      ExpandThroughAlwaysActiveFDs(&nfsm_states, &generation,",
          "new_line_content": "      // in a breadth-first manner. Note that now, we might see new",
          "content_same": false
        },
        {
          "line": 1872,
          "old_api": "erings[order_idx];",
          "new_api": null,
          "old_text": "erings[order_idx];",
          "new_text": null,
          "old_line_content": "  for (size_t order_idx = 0; order_idx < m_orderings.size(); ++order_idx) {",
          "new_line_content": "void LogicalOrderings::PrintInterestingOrders(string *trace) {",
          "content_same": false
        },
        {
          "line": 1617,
          "old_api": "== extra_allowed_fd_idx) &&",
          "new_api": null,
          "old_text": " == extra_allowed_fd_idx) &&\n       ",
          "new_text": null,
          "old_line_content": "      if ((AlwaysActiveFD(edge.required_fd_idx) ||",
          "new_line_content": "    for (int outgoing_edge_idx : state.outgoing_edges) {",
          "content_same": false
        },
        {
          "line": 1745,
          "old_api": "end",
          "new_api": null,
          "old_text": "s.end());\n      n",
          "new_text": null,
          "old_line_content": "      sort(nfsm_states.begin(), nfsm_states.end());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1746,
          "old_api": "end));\n\n      //",
          "new_api": null,
          "old_text": "end));\n\n      // ",
          "new_text": null,
          "old_line_content": "      auto new_end = unique(nfsm_states.begin(), nfsm_states.end());",
          "new_line_content": "      // Canonicalize: Sort and deduplicate.",
          "content_same": false
        },
        {
          "line": 1620,
          "old_api": "].seen = *generation;\n      }\n    }",
          "new_api": null,
          "old_text": "].seen = *generation;\n      }\n    }\n  ",
          "new_text": null,
          "old_line_content": "        nfsm_states->push_back(edge.state_idx);",
          "new_line_content": "           edge.required_fd_idx == extra_allowed_fd_idx) &&",
          "content_same": false
        },
        {
          "line": 1878,
          "old_api": "ordering.ordering)) {\n      *trace",
          "new_api": null,
          "old_text": "ordering.ordering)) {\n      *trace ",
          "new_text": null,
          "old_line_content": "    *trace += StringPrintf(\" - %zu: \", order_idx);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1752,
          "old_api": "end",
          "new_api": null,
          "old_text": ".end(),\n            ",
          "new_text": null,
          "old_line_content": "      for (size_t i = 0; i < m_dfsm_states.size(); ++i) {",
          "new_line_content": "      // NFSM m_states we've collected.",
          "content_same": false
        },
        {
          "line": 1753,
          "old_api": "m_d",
          "new_api": null,
          "old_text": "              m_d",
          "new_text": null,
          "old_line_content": "        if (equal(nfsm_states.begin(), nfsm_states.end(),",
          "new_line_content": "      int target_dfsm_state_idx = -1;",
          "content_same": false
        },
        {
          "line": 1888,
          "old_api": "DESC) {\n        *trace += \" DESC\";",
          "new_api": null,
          "old_text": "DESC) {\n        *trace += \" DESC\";\n     ",
          "new_text": null,
          "old_line_content": "      *trace += ItemToString(m_items[element.item].item);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1764,
          "old_api": "zeDFSMState",
          "new_api": null,
          "old_text": "zeDFSMState(thd, ",
          "new_text": null,
          "old_line_content": "        state.nfsm_states = move(nfsm_states);",
          "new_line_content": "        // except for printing out the graph.",
          "content_same": false
        },
        {
          "line": 1765,
          "old_api": "target_dfs",
          "new_api": null,
          "old_text": " target_dfs",
          "new_text": null,
          "old_line_content": "        m_dfsm_states.push_back(move(state));",
          "new_line_content": "        DFSMState state;",
          "content_same": false
        },
        {
          "line": 1893,
          "old_api": "== OrderingWithInfo::HOMO",
          "new_api": null,
          "old_text": "== OrderingWithInfo::HOMO",
          "new_text": null,
          "old_line_content": "    if (ordering.ordering.empty()) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1514,
          "old_api": "m_states",
          "new_api": null,
          "old_text": "          m_states",
          "new_text": null,
          "old_line_content": "      for (int j = 1; j < static_cast<int>(m_orderings.size()); ++j) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1771,
          "old_api": "e edge;\n        edge.required_fd_idx = nfs",
          "new_api": null,
          "old_text": "e edge;\n        edge.required_fd_idx = nfs",
          "new_text": null,
          "old_line_content": "      if (static_cast<size_t>(target_dfsm_state_idx) != dfsm_state_idx) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1775,
          "old_api": "sm_state_idx];\n        dfsm_",
          "new_api": null,
          "old_text": "sm_state_idx];\n        dfsm_",
          "new_text": null,
          "old_line_content": "        m_dfsm_edges.push_back(edge);",
          "new_line_content": "        edge.required_fd_idx = nfsm_edges[edge_idx].required_fd_idx;",
          "content_same": false
        },
        {
          "line": 1778,
          "old_api": "sm_state.next_state",
          "new_api": null,
          "old_text": "sm_state.next_state",
          "new_text": null,
          "old_line_content": "        dfsm_state.outgoing_edges.push_back(m_dfsm_edges.size() - 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1908,
          "old_api": "];\n    if (stat",
          "new_api": null,
          "old_text": "];\n    if (stat",
          "new_text": null,
          "old_line_content": "  for (size_t state_idx = 0; state_idx < m_states.size(); ++state_idx) {",
          "new_line_content": "void LogicalOrderings::PrintNFSMDottyGraph(string *trace) const {",
          "content_same": false
        },
        {
          "line": 1783,
          "old_api": "}\n\n      // Prepare for the next group.\n      nfs",
          "new_api": null,
          "old_text": "  }\n\n      // Prepare for the next group.\n      nfs",
          "new_text": null,
          "old_line_content": "            dfsm_state.can_use_fd.set(edge.required_fd_idx - 1);",
          "new_line_content": "          if (edge.required_fd_idx >= 1 &&",
          "content_same": false
        },
        {
          "line": 1531,
          "old_api": "for (size_t j",
          "new_api": null,
          "old_text": "     for (size_t j",
          "new_text": null,
          "old_line_content": "    for (size_t i = 1; i < m_orderings.size(); ++i) {",
          "new_line_content": "    // such m_states from the graph as a whole, removing them in some later",
          "content_same": false
        },
        {
          "line": 1916,
          "old_api": "te::INTERESTING) {\n      *trace += \", peripheri",
          "new_api": null,
          "old_text": "te::INTERESTING) {\n      *trace += \", peripheri",
          "new_text": null,
          "old_line_content": "                           PrintOrdering(state.satisfied_ordering).c_str());",
          "new_line_content": "    // We're printing the NFSM.",
          "content_same": false
        },
        {
          "line": 1661,
          "old_api": "ExpandThroughAlwaysActiveFDs(&initial",
          "new_api": null,
          "old_text": "  ExpandThroughAlwaysActiveFDs(&initial",
          "new_text": null,
          "old_line_content": "  initial.nfsm_states.init(thd->mem_root);",
          "new_line_content": "  // NFSM state, and everything reachable from it with only always-active FDs.",
          "content_same": false
        },
        {
          "line": 1662,
          "old_api": "m_states, &generation,",
          "new_api": null,
          "old_text": "m_states, &generation,\n         ",
          "new_text": null,
          "old_line_content": "  initial.nfsm_states.push_back(0);",
          "new_line_content": "  DFSMState initial;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 20,
      "total_additions": 69,
      "total_deletions": 69,
      "total_api_changes": 158
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 6,
        "api_related_lines": 158,
        "non_api_lines": 6,
        "non_api_line_numbers": [
          1,
          1491,
          1492,
          1493,
          1494,
          1495
        ]
      }
    },
    "api_calls_before": 420,
    "api_calls_after": 420,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 4,
      "total_diff_lines": 26
    }
  }
}