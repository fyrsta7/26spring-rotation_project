{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/229a87e5527a471995a8ab4fd45c6d3e9816956f",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/229a87e5527a471995a8ab4fd45c6d3e9816956f/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/229a87e5527a471995a8ab4fd45c6d3e9816956f/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/229a87e5527a471995a8ab4fd45c6d3e9816956f/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 213,
          "old_api": "std::move(h)",
          "new_api": "direction",
          "old_text": "std::move(h)",
          "new_text": "H::combine(\n            std::move(h),\n            Cast<HloCompareInstruction>(instruction)->direction())",
          "old_line_content": "        return std::move(h);",
          "new_line_content": "        return H::combine(",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": "opcode",
          "new_api": "MakeInstructionPostOrder",
          "old_text": "instruction->opcode()",
          "new_text": "computation->MakeInstructionPostOrder()",
          "old_line_content": "          instruction->opcode() != HloOpcode::kPartitionId &&",
          "new_line_content": "    for (auto instruction : computation->MakeInstructionPostOrder()) {",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": "HasSideEffect",
          "new_api": "opcode",
          "old_text": "instruction->HasSideEffect()",
          "new_text": "instruction->opcode()",
          "old_line_content": "      if (instruction->HasSideEffect()) {",
          "new_line_content": "          instruction->opcode() != HloOpcode::kReplicaId) {",
          "content_same": false
        },
        {
          "line": 280,
          "old_api": "insert",
          "new_api": "HasSideEffect",
          "old_text": "representatives.insert(CseKey{instruction})",
          "new_text": "instruction->HasSideEffect()",
          "old_line_content": "      auto pair = representatives.insert(CseKey{instruction});",
          "new_line_content": "      if (instruction->HasSideEffect()) {",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": "ReplaceAllUsesWith",
          "new_api": "insert",
          "old_text": "instruction->ReplaceAllUsesWith(equivalent_instruction)",
          "new_text": "representatives.insert(CseKey{instruction})",
          "old_line_content": "            instruction->ReplaceAllUsesWith(equivalent_instruction));",
          "new_line_content": "      auto pair = representatives.insert(CseKey{instruction});",
          "content_same": false
        },
        {
          "line": 290,
          "old_api": "operand_count",
          "new_api": "RemoveInstructionAndUnusedOperands",
          "old_text": "instruction->operand_count()",
          "new_text": "computation->RemoveInstructionAndUnusedOperands(instruction)",
          "old_line_content": "      for (int64_t i = 0; i < instruction->operand_count(); ++i) {",
          "new_line_content": "            computation->RemoveInstructionAndUnusedOperands(instruction));",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": "operand_count",
          "new_api": "mutable_operand",
          "old_text": "instruction->operand_count()",
          "new_text": "instruction->mutable_operand(i)",
          "old_line_content": "        for (int64_t j = i + 1; j < instruction->operand_count(); ++j) {",
          "new_line_content": "        HloInstruction* a = instruction->mutable_operand(i);",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": "mutable_operand",
          "new_api": "opcode",
          "old_text": "instruction->mutable_operand(j)",
          "new_text": "a->opcode()",
          "old_line_content": "          HloInstruction* b = instruction->mutable_operand(j);",
          "new_line_content": "        if (a->opcode() != HloOpcode::kIota) {",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": "ReplaceOperandWith",
          "new_api": "mutable_operand",
          "old_text": "instruction->ReplaceOperandWith(j, a)",
          "new_text": "instruction->mutable_operand(j)",
          "old_line_content": "          TF_RETURN_IF_ERROR(instruction->ReplaceOperandWith(j, a));",
          "new_line_content": "          HloInstruction* b = instruction->mutable_operand(j);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 269,
          "old_api": null,
          "new_api": "instruction_count",
          "old_text": null,
          "new_text": "computation->instruction_count()",
          "old_line_content": "      // over it.",
          "new_line_content": "        representatives(/*N=*/computation->instruction_count() + 1,",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": null,
          "new_api": "operand_count",
          "old_text": null,
          "new_text": "instruction->operand_count()",
          "old_line_content": "      }",
          "new_line_content": "      if (instruction->operand_count() == 0 &&",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "      // Skip instructions which have side effects.",
          "new_line_content": "          instruction->opcode() != HloOpcode::kPartitionId &&",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": null,
          "new_api": "ReplaceAllUsesWith",
          "old_text": null,
          "new_text": "TF_RETURN_IF_ERROR(\n            instruction->ReplaceAllUsesWith(equivalent_instruction))",
          "old_line_content": "        changed = true;",
          "new_line_content": "        TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": null,
          "new_api": "ReplaceAllUsesWith",
          "old_text": null,
          "new_text": "instruction->ReplaceAllUsesWith(equivalent_instruction)",
          "old_line_content": "        continue;",
          "new_line_content": "            instruction->ReplaceAllUsesWith(equivalent_instruction));",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": null,
          "new_api": "RemoveInstructionAndUnusedOperands",
          "old_text": null,
          "new_text": "TF_RETURN_IF_ERROR(\n            computation->RemoveInstructionAndUnusedOperands(instruction))",
          "old_line_content": "      }",
          "new_line_content": "        TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": null,
          "new_api": "operand_count",
          "old_text": null,
          "new_text": "instruction->operand_count()",
          "old_line_content": "        }",
          "new_line_content": "      for (int64_t i = 0; i < instruction->operand_count(); ++i) {",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": null,
          "new_api": "operand_count",
          "old_text": null,
          "new_text": "instruction->operand_count()",
          "old_line_content": "          }",
          "new_line_content": "        for (int64_t j = i + 1; j < instruction->operand_count(); ++j) {",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": null,
          "new_api": "eq_instructions",
          "old_text": null,
          "new_text": "eq_instructions(a, b)",
          "old_line_content": "          changed = true;",
          "new_line_content": "          if (a == b || !eq_instructions(a, b)) {",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": null,
          "new_api": "ReplaceOperandWith",
          "old_text": null,
          "new_text": "instruction->ReplaceOperandWith(j, a)",
          "old_line_content": "          }",
          "new_line_content": "          TF_RETURN_IF_ERROR(instruction->ReplaceOperandWith(j, a));",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": null,
          "new_api": "IsDead",
          "old_text": null,
          "new_text": "b->IsDead()",
          "old_line_content": "      }",
          "new_line_content": "          if (b->IsDead()) {",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": null,
          "new_api": "RemoveInstruction",
          "old_text": null,
          "new_text": "computation->RemoveInstruction(b)",
          "old_line_content": "    }",
          "new_line_content": "            TF_RETURN_IF_ERROR(computation->RemoveInstruction(b));",
          "content_same": false
        },
        {
          "line": 214,
          "old_api": null,
          "new_api": "std::move(h)",
          "old_text": null,
          "new_text": "std::move(h)",
          "old_line_content": "    }",
          "new_line_content": "            std::move(h),",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": null,
          "new_api": "direction",
          "old_text": null,
          "new_text": "Cast<HloCompareInstruction>(instruction)->direction()",
          "old_line_content": "  }",
          "new_line_content": "            Cast<HloCompareInstruction>(instruction)->direction());",
          "content_same": false
        },
        {
          "line": 217,
          "old_api": null,
          "new_api": "std::move(h)",
          "old_text": null,
          "new_text": "std::move(h)",
          "old_line_content": "};",
          "new_line_content": "        return std::move(h);",
          "content_same": false
        },
        {
          "line": 235,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "a->opcode()",
          "old_line_content": "           (is_layout_sensitive_",
          "new_line_content": "    if (a->opcode() != b->opcode() || a->opcode() != HloOpcode::kIota) {",
          "content_same": false
        },
        {
          "line": 238,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "b->dimensions(0)",
          "old_line_content": "  };",
          "new_line_content": "    return a->dimensions(0) == b->dimensions(0) &&",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "b->shape()",
          "old_line_content": "                                  const HloComputation* rhs) {",
          "new_line_content": "                ? ShapeUtil::Equal(a->shape(), b->shape())",
          "content_same": false
        },
        {
          "line": 241,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "b->shape()",
          "old_line_content": "    return *lhs == *rhs;",
          "new_line_content": "                : ShapeUtil::Compatible(a->shape(), b->shape()));",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": null,
          "new_api": "IdenticalIgnoringCommutativeOperandOrder",
          "old_text": null,
          "new_text": "lhs.hlo->IdenticalIgnoringCommutativeOperandOrder(\n        *rhs.hlo, eq_instructions, eq_computations, is_layout_sensitive_,\n        /*sharding_sensitive=*/true)",
          "old_line_content": "",
          "new_line_content": "    return lhs.hlo->IdenticalIgnoringCommutativeOperandOrder(",
          "content_same": false
        },
        {
          "line": 254,
          "old_api": null,
          "new_api": "computations",
          "old_text": null,
          "new_text": "module->computations(execution_threads)",
          "old_line_content": "",
          "new_line_content": "  for (auto* computation : module->computations(execution_threads)) {",
          "content_same": false
        },
        {
          "line": 255,
          "old_api": null,
          "new_api": "IsFusionComputation",
          "old_text": null,
          "new_text": "computation->IsFusionComputation()",
          "old_line_content": "    TF_ASSIGN_OR_RETURN(bool combined,",
          "new_line_content": "    if (only_fusion_computations_ && !computation->IsFusionComputation()) {",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 265,
          "old_api": "instruction_count",
          "new_api": null,
          "old_text": "computation->instruction_count()",
          "new_text": null,
          "old_line_content": "        representatives(/*N=*/computation->instruction_count() + 1,",
          "new_line_content": "    // HLO instructions are grouped into equivalency classes by using the",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": "MakeInstructionPostOrder",
          "new_api": null,
          "old_text": "computation->MakeInstructionPostOrder()",
          "new_text": null,
          "old_line_content": "    for (auto instruction : computation->MakeInstructionPostOrder()) {",
          "new_line_content": "    // instruction for each class.",
          "content_same": false
        },
        {
          "line": 270,
          "old_api": "operand_count",
          "new_api": null,
          "old_text": "instruction->operand_count()",
          "new_text": null,
          "old_line_content": "      if (instruction->operand_count() == 0 &&",
          "new_line_content": "                        absl::Hash<CseKey>{}, cse_equal);",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "instruction->opcode()",
          "new_text": null,
          "old_line_content": "          instruction->opcode() != HloOpcode::kReplicaId) {",
          "new_line_content": "      // If the instruction has zero operands (constants, parameters, etc.) skip",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": "ReplaceAllUsesWith",
          "new_api": null,
          "old_text": "TF_RETURN_IF_ERROR(\n            instruction->ReplaceAllUsesWith(equivalent_instruction))",
          "new_text": null,
          "old_line_content": "        TF_RETURN_IF_ERROR(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": "RemoveInstructionAndUnusedOperands",
          "new_api": null,
          "old_text": "TF_RETURN_IF_ERROR(\n            computation->RemoveInstructionAndUnusedOperands(instruction))",
          "new_text": null,
          "old_line_content": "        TF_RETURN_IF_ERROR(",
          "new_line_content": "      if (!pair.second) {",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": "RemoveInstructionAndUnusedOperands",
          "new_api": null,
          "old_text": "computation->RemoveInstructionAndUnusedOperands(instruction)",
          "new_text": null,
          "old_line_content": "            computation->RemoveInstructionAndUnusedOperands(instruction));",
          "new_line_content": "        HloInstruction* equivalent_instruction = pair.first->hlo;",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "instruction->mutable_operand(i)",
          "new_text": null,
          "old_line_content": "        HloInstruction* a = instruction->mutable_operand(i);",
          "new_line_content": "        changed = true;",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "a->opcode()",
          "new_text": null,
          "old_line_content": "        if (a->opcode() != HloOpcode::kIota) {",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 297,
          "old_api": "eq_instructions",
          "new_api": null,
          "old_text": "eq_instructions(a, b)",
          "new_text": null,
          "old_line_content": "          if (a == b || !eq_instructions(a, b)) {",
          "new_line_content": "          continue;",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": "IsDead",
          "new_api": null,
          "old_text": "b->IsDead()",
          "new_text": null,
          "old_line_content": "          if (b->IsDead()) {",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 303,
          "old_api": "RemoveInstruction",
          "new_api": null,
          "old_text": "computation->RemoveInstruction(b)",
          "new_text": null,
          "old_line_content": "            TF_RETURN_IF_ERROR(computation->RemoveInstruction(b));",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "a->opcode()",
          "new_text": null,
          "old_line_content": "    if (a->opcode() != b->opcode() || a->opcode() != HloOpcode::kIota) {",
          "new_line_content": "                                   const HloInstruction* b) {",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "b->dimensions(0)",
          "new_text": null,
          "old_line_content": "    return a->dimensions(0) == b->dimensions(0) &&",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": "shape",
          "new_api": null,
          "old_text": "b->shape()",
          "new_text": null,
          "old_line_content": "                ? ShapeUtil::Equal(a->shape(), b->shape())",
          "new_line_content": "      return false;",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": "shape",
          "new_api": null,
          "old_text": "b->shape()",
          "new_text": null,
          "old_line_content": "                : ShapeUtil::Compatible(a->shape(), b->shape()));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": "IdenticalIgnoringCommutativeOperandOrder",
          "new_api": null,
          "old_text": "lhs.hlo->IdenticalIgnoringCommutativeOperandOrder(\n        *rhs.hlo, eq_instructions, eq_computations, is_layout_sensitive_,\n        /*sharding_sensitive=*/true)",
          "new_text": null,
          "old_line_content": "    return lhs.hlo->IdenticalIgnoringCommutativeOperandOrder(",
          "new_line_content": "    return *lhs == *rhs;",
          "content_same": false
        },
        {
          "line": 250,
          "old_api": "computations",
          "new_api": null,
          "old_text": "module->computations(execution_threads)",
          "new_text": null,
          "old_line_content": "  for (auto* computation : module->computations(execution_threads)) {",
          "new_line_content": "        *rhs.hlo, eq_instructions, eq_computations, is_layout_sensitive_,",
          "content_same": false
        },
        {
          "line": 251,
          "old_api": "IsFusionComputation",
          "new_api": null,
          "old_text": "computation->IsFusionComputation()",
          "new_text": null,
          "old_line_content": "    if (only_fusion_computations_ && !computation->IsFusionComputation()) {",
          "new_line_content": "        /*sharding_sensitive=*/true);",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 9,
      "total_additions": 22,
      "total_deletions": 19,
      "total_api_changes": 50
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 4,
        "api_related_lines": 50,
        "non_api_lines": 1,
        "non_api_line_numbers": [
          212
        ]
      }
    },
    "api_calls_before": 166,
    "api_calls_after": 170,
    "diff_info": {
      "added_lines": 4,
      "removed_lines": 0,
      "total_diff_lines": 16
    }
  }
}