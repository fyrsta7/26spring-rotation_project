{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/dfeffb599abc2a84408db94fb1445d4fc0fe2aa6",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/dfeffb599abc2a84408db94fb1445d4fc0fe2aa6/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/dfeffb599abc2a84408db94fb1445d4fc0fe2aa6/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/dfeffb599abc2a84408db94fb1445d4fc0fe2aa6/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 1449,
          "old_api": "getType",
          "new_api": "debug_options",
          "old_text": "llvm_ir::EmitCallToIntrinsic(llvm::Intrinsic::maxnum,\n                                              {lhs, rhs}, {lhs->getType()}, b)",
          "new_text": "llvm_ir::EmitFloatMax(\n              lhs, rhs, b,\n              hlo_module_config_.debug_options().xla_cpu_enable_fast_min_max())",
          "old_line_content": "          return llvm_ir::EmitCallToIntrinsic(llvm::Intrinsic::maxnum,",
          "new_line_content": "          return llvm_ir::EmitFloatMax(",
          "content_same": false
        },
        {
          "line": 1454,
          "old_api": "CreateICmp",
          "new_api": "CreateSelect",
          "old_text": "b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SGE\n                                         : llvm::ICmpInst::ICMP_UGE,\n                          lhs, rhs)",
          "new_text": "b->CreateSelect(\n            b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SGE\n                                         : llvm::ICmpInst::ICMP_UGE,\n                          lhs, rhs),\n            lhs, rhs)",
          "old_line_content": "            b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SGE",
          "new_line_content": "        return b->CreateSelect(",
          "content_same": false
        },
        {
          "line": 1466,
          "old_api": "getType",
          "new_api": "debug_options",
          "old_text": "lhs->getType()",
          "new_text": "llvm_ir::EmitFloatMin(\n              lhs, rhs, b,\n              hlo_module_config_.debug_options().xla_cpu_enable_fast_min_max())",
          "old_line_content": "                                              {lhs, rhs}, {lhs->getType()}, b);",
          "new_line_content": "          return llvm_ir::EmitFloatMin(",
          "content_same": false
        },
        {
          "line": 1483,
          "old_api": "ShapeUtil::ByteSizeOfPrimitiveType(element_type)",
          "new_api": "vector_register_byte_size",
          "old_text": "ShapeUtil::ByteSizeOfPrimitiveType(element_type)",
          "new_text": "target_machine_features_.vector_register_byte_size(\n          *compute_function_->function())",
          "old_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(element_type);",
          "new_line_content": "      target_machine_features_.vector_register_byte_size(",
          "content_same": false
        },
        {
          "line": 1489,
          "old_api": "tensorflow::Log2Ceiling(element_count)",
          "new_api": "llvm_ir::PrimitiveTypeToIrType(element_type, module_)",
          "old_text": "tensorflow::Log2Ceiling(element_count)",
          "new_text": "llvm_ir::PrimitiveTypeToIrType(element_type, module_)",
          "old_line_content": "  for (int i = 0, e = 1 + tensorflow::Log2Ceiling(element_count); i < e; i++) {",
          "new_line_content": "      llvm_ir::PrimitiveTypeToIrType(element_type, module_);",
          "content_same": false
        },
        {
          "line": 1510,
          "old_api": "insert",
          "new_api": "llvm::VectorType::get(\n          element_ir_type, vector_register_size_in_elements, false)",
          "old_text": "sharded_vector_type.insert(\n          sharded_vector_type.end(),\n          current_size_fragment / vector_register_size_in_elements,\n          vector_type)",
          "new_text": "llvm::VectorType::get(\n          element_ir_type, vector_register_size_in_elements, false)",
          "old_line_content": "      sharded_vector_type.insert(",
          "new_line_content": "      auto vector_type = llvm::VectorType::get(",
          "content_same": false
        },
        {
          "line": 1540,
          "old_api": "llvm_ir::EmitAllocaAtFunctionEntry(\n        accumulator_shard_type, \"accumulator\", &b_, 0)",
          "new_api": "size",
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n        accumulator_shard_type, \"accumulator\", &b_, 0)",
          "new_text": "accumulator_type.size()",
          "old_line_content": "    accumulator.push_back(llvm_ir::EmitAllocaAtFunctionEntry(",
          "new_line_content": "  accumulator.reserve(accumulator_type.size());",
          "content_same": false
        },
        {
          "line": 1551,
          "old_api": "getElementCount",
          "new_api": "llvm::dyn_cast<llvm::VectorType>(shard_type)",
          "old_text": "vector_type->getElementCount()",
          "new_text": "llvm::dyn_cast<llvm::VectorType>(shard_type)",
          "old_line_content": "          VectorSplat(vector_type->getElementCount(), init_value_ssa);",
          "new_line_content": "    if (auto vector_type = llvm::dyn_cast<llvm::VectorType>(shard_type)) {",
          "content_same": false
        },
        {
          "line": 1577,
          "old_api": "getInt64Ty",
          "new_api": "end",
          "old_text": "b_.getInt64Ty()",
          "new_text": "output_index.end()",
          "old_line_content": "                                      b_.getInt64Ty());",
          "new_line_content": "  CHECK(output_index.end() == it);",
          "content_same": false
        },
        {
          "line": 1579,
          "old_api": "EmitArrayElementAddress",
          "new_api": "getInt64Ty",
          "old_text": "BitCast(\n      arg_array.EmitArrayElementAddress(input_index, &b_), b_.getInt8PtrTy())",
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "  llvm::Value* input_address = BitCast(",
          "new_line_content": "                                      b_.getInt64Ty());",
          "content_same": false
        },
        {
          "line": 1582,
          "old_api": "size",
          "new_api": "getInt8PtrTy",
          "old_text": "accumulator.size()",
          "new_text": "b_.getInt8PtrTy()",
          "old_line_content": "  for (int i = 0; i < accumulator.size(); i++) {",
          "new_line_content": "      arg_array.EmitArrayElementAddress(input_index, &b_), b_.getInt8PtrTy());",
          "content_same": false
        },
        {
          "line": 1584,
          "old_api": "getType",
          "new_api": "size",
          "old_text": "accumulator[i]->getType()",
          "new_text": "accumulator.size()",
          "old_line_content": "        BitCast(input_address, accumulator[i]->getType());",
          "new_line_content": "  for (int i = 0; i < accumulator.size(); i++) {",
          "content_same": false
        },
        {
          "line": 1586,
          "old_api": "AlignedLoad",
          "new_api": "getType",
          "old_text": "AlignedLoad(accumulator[i], element_alignment)",
          "new_text": "accumulator[i]->getType()",
          "old_line_content": "        AlignedLoad(accumulator[i], element_alignment);",
          "new_line_content": "        BitCast(input_address, accumulator[i]->getType());",
          "content_same": false
        },
        {
          "line": 1588,
          "old_api": "AnnotateLoadStoreInstructionWithMetadata",
          "new_api": "AlignedLoad",
          "old_text": "arg_array.AnnotateLoadStoreInstructionWithMetadata(addend)",
          "new_text": "AlignedLoad(accumulator[i], element_alignment)",
          "old_line_content": "    arg_array.AnnotateLoadStoreInstructionWithMetadata(addend);",
          "new_line_content": "        AlignedLoad(accumulator[i], element_alignment);",
          "content_same": false
        },
        {
          "line": 1594,
          "old_api": "size",
          "new_api": "AlignedStore",
          "old_text": "accumulator.size()",
          "new_text": "AlignedStore(reduced_result, accumulator[i], element_alignment)",
          "old_line_content": "    if (i != (accumulator.size() - 1)) {",
          "new_line_content": "    AlignedStore(reduced_result, accumulator[i], element_alignment);",
          "content_same": false
        },
        {
          "line": 1605,
          "old_api": "AlignedLoad",
          "new_api": "size",
          "old_text": "AlignedLoad(accumulator_shard, element_alignment)",
          "new_text": "accumulator.size()",
          "old_line_content": "    result_ssa.push_back(AlignedLoad(accumulator_shard, element_alignment));",
          "new_line_content": "  result_ssa.reserve(accumulator.size());",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": "getType",
          "new_api": "size",
          "old_text": "BitCast(store_address,\n                llvm::PointerType::getUnqual(value_to_store[i]->getType()))",
          "new_text": "value_to_store.size()",
          "old_line_content": "        BitCast(store_address,",
          "new_line_content": "  for (int i = 0; i < value_to_store.size(); i++) {",
          "content_same": false
        },
        {
          "line": 1652,
          "old_api": "element_type",
          "new_api": "vector_register_byte_size",
          "old_text": "reduce->shape().element_type()",
          "new_text": "target_machine_features_.vector_register_byte_size(\n          *compute_function_->function())",
          "old_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(reduce->shape().element_type());",
          "new_line_content": "      target_machine_features_.vector_register_byte_size(",
          "content_same": false
        },
        {
          "line": 1667,
          "old_api": "layout",
          "new_api": "element_type",
          "old_text": "absl::c_linear_search(\n      dimensions, LayoutUtil::Minor(arg->shape().layout(), 0))",
          "new_text": "reduce->shape().element_type()",
          "old_line_content": "  bool is_reduction_over_minor_dimension = absl::c_linear_search(",
          "new_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(reduce->shape().element_type());",
          "content_same": false
        },
        {
          "line": 1670,
          "old_api": "element_type",
          "new_api": "layout",
          "old_text": "tensorflow::MathUtil::GCD<unsigned>(\n      ShapeUtil::ByteSizeOfPrimitiveType(reduce->shape().element_type()),\n      MinimumAlignmentForPrimitiveType(reduce->shape().element_type()))",
          "new_text": "arg->shape().layout()",
          "old_line_content": "  llvm::Align element_alignment(tensorflow::MathUtil::GCD<unsigned>(",
          "new_line_content": "      dimensions, LayoutUtil::Minor(arg->shape().layout(), 0));",
          "content_same": false
        },
        {
          "line": 1705,
          "old_api": "dimensions_size",
          "new_api": "IrName",
          "old_text": "reduce->shape().dimensions_size()",
          "new_text": "IrName(reduce)",
          "old_line_content": "      reduce->shape().dimensions_size());",
          "new_line_content": "  llvm_ir::ForLoopNest loop_nest(IrName(reduce), &b_);",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": "layout",
          "new_api": "shape",
          "old_text": "reduce->shape().layout()",
          "new_text": "reduce->shape()",
          "old_line_content": "    int64 dimension = LayoutUtil::Minor(reduce->shape().layout(), i);",
          "new_line_content": "  for (int i = LayoutUtil::MinorToMajor(reduce->shape()).size() - 1; i > 0;",
          "content_same": false
        },
        {
          "line": 1710,
          "old_api": "dimensions",
          "new_api": "layout",
          "old_text": "reduce->shape().dimensions(dimension)",
          "new_text": "reduce->shape().layout()",
          "old_line_content": "    int64 end_index = reduce->shape().dimensions(dimension);",
          "new_line_content": "    int64 dimension = LayoutUtil::Minor(reduce->shape().layout(), i);",
          "content_same": false
        },
        {
          "line": 1712,
          "old_api": "absl::StrFormat(\"dim.%d\", dimension)",
          "new_api": "dimensions",
          "old_text": "absl::StrFormat(\"dim.%d\", dimension)",
          "new_text": "reduce->shape().dimensions(dimension)",
          "old_line_content": "        start_index, end_index, absl::StrFormat(\"dim.%d\", dimension));",
          "new_line_content": "    int64 end_index = reduce->shape().dimensions(dimension);",
          "content_same": false
        },
        {
          "line": 1713,
          "old_api": "GetIndVarValue",
          "new_api": "AddLoop",
          "old_text": "loop->GetIndVarValue()",
          "new_text": "loop_nest.AddLoop(\n        start_index, end_index, absl::StrFormat(\"dim.%d\", dimension))",
          "old_line_content": "    array_multi_index[dimension] = loop->GetIndVarValue();",
          "new_line_content": "    std::unique_ptr<llvm_ir::ForLoop> loop = loop_nest.AddLoop(",
          "content_same": false
        },
        {
          "line": 1718,
          "old_api": "dimensions",
          "new_api": "layout",
          "old_text": "reduce->shape().dimensions(innermost_dimension)",
          "new_text": "reduce->shape().layout()",
          "old_line_content": "      reduce->shape().dimensions(innermost_dimension);",
          "new_line_content": "  int64 innermost_dimension = LayoutUtil::Minor(reduce->shape().layout(), 0);",
          "content_same": false
        },
        {
          "line": 1734,
          "old_api": "GetIndVarValue",
          "new_api": "AddLoop",
          "old_text": "loop->GetIndVarValue()",
          "new_text": "loop_nest.AddLoop(start_index, end_index, vectorization_factor,\n                          absl::StrFormat(\"dim.%d\", innermost_dimension))",
          "old_line_content": "    array_multi_index[innermost_dimension] = loop->GetIndVarValue();",
          "new_line_content": "        loop_nest.AddLoop(start_index, end_index, vectorization_factor,",
          "content_same": false
        },
        {
          "line": 1736,
          "old_api": "GetBodyBasicBlock",
          "new_api": "GetIndVarValue",
          "old_text": "loop->GetBodyBasicBlock()",
          "new_text": "loop->GetIndVarValue()",
          "old_line_content": "    SetToFirstInsertPoint(loop->GetBodyBasicBlock(), &b_);",
          "new_line_content": "    array_multi_index[innermost_dimension] = loop->GetIndVarValue();",
          "content_same": false
        },
        {
          "line": 1738,
          "old_api": "element_type",
          "new_api": "GetBodyBasicBlock",
          "old_text": "CreateShardedVectorType(\n        reduce->shape().element_type(), vectorization_factor)",
          "new_text": "loop->GetBodyBasicBlock()",
          "old_line_content": "    ShardedVectorType vector_type = CreateShardedVectorType(",
          "new_line_content": "    SetToFirstInsertPoint(loop->GetBodyBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 1740,
          "old_api": "shape",
          "new_api": "element_type",
          "old_text": "reduce->shape()",
          "new_text": "CreateShardedVectorType(\n        reduce->shape().element_type(), vectorization_factor)",
          "old_line_content": "    llvm_ir::IrArray::Index array_index(array_multi_index, reduce->shape(),",
          "new_line_content": "    ShardedVectorType vector_type = CreateShardedVectorType(",
          "content_same": false
        },
        {
          "line": 1741,
          "old_api": "getInt64Ty",
          "new_api": "element_type",
          "old_text": "b_.getInt64Ty()",
          "new_text": "reduce->shape().element_type()",
          "old_line_content": "                                        b_.getInt64Ty());",
          "new_line_content": "        reduce->shape().element_type(), vectorization_factor);",
          "content_same": false
        },
        {
          "line": 1749,
          "old_api": "EmitArrayElementAddress",
          "new_api": "GetIrArrayFor",
          "old_text": "target_array.EmitArrayElementAddress(array_index, &b_)",
          "new_text": "GetIrArrayFor(reduce)",
          "old_line_content": "        target_array.EmitArrayElementAddress(array_index, &b_);",
          "new_line_content": "    llvm_ir::IrArray target_array = GetIrArrayFor(reduce);",
          "content_same": false
        },
        {
          "line": 1755,
          "old_api": "SetInsertPoint",
          "new_api": "GetExitBasicBlock",
          "old_text": "b_.SetInsertPoint(exit_terminator)",
          "new_text": "loop->GetExitBasicBlock()->getTerminator()",
          "old_line_content": "      b_.SetInsertPoint(exit_terminator);",
          "new_line_content": "    if (auto exit_terminator = loop->GetExitBasicBlock()->getTerminator()) {",
          "content_same": false
        },
        {
          "line": 1757,
          "old_api": "shape",
          "new_api": "SetInsertPoint",
          "old_text": "reduce->shape()",
          "new_text": "b_.SetInsertPoint(exit_terminator)",
          "old_line_content": "      CHECK_EQ(LayoutUtil::MinorToMajor(reduce->shape()).size(), 1);",
          "new_line_content": "      b_.SetInsertPoint(exit_terminator);",
          "content_same": false
        },
        {
          "line": 1774,
          "old_api": "shape",
          "new_api": "element_type",
          "old_text": "reduce->shape()",
          "new_text": "reduce->shape().element_type()",
          "old_line_content": "    llvm_ir::IrArray::Index array_index(array_multi_index, reduce->shape(),",
          "new_line_content": "        reduce->shape().element_type(),",
          "content_same": false
        },
        {
          "line": 1783,
          "old_api": "EmitArrayElementAddress",
          "new_api": "GetIrArrayFor",
          "old_text": "target_array.EmitArrayElementAddress(array_index, &b_)",
          "new_text": "GetIrArrayFor(reduce)",
          "old_line_content": "        target_array.EmitArrayElementAddress(array_index, &b_);",
          "new_line_content": "    llvm_ir::IrArray target_array = GetIrArrayFor(reduce);",
          "content_same": false
        },
        {
          "line": 1798,
          "old_api": "dimensions",
          "new_api": "mutable_operand",
          "old_text": "reduce->dimensions()",
          "new_text": "reduce->mutable_operand(0)",
          "old_line_content": "  absl::Span<const int64> dimensions(reduce->dimensions());",
          "new_line_content": "  auto arg = reduce->mutable_operand(0);",
          "content_same": false
        },
        {
          "line": 1799,
          "old_api": "to_apply",
          "new_api": "mutable_operand",
          "old_text": "reduce->to_apply()",
          "new_text": "reduce->mutable_operand(1)",
          "old_line_content": "  HloComputation* function = reduce->to_apply();",
          "new_line_content": "  auto init_value = reduce->mutable_operand(1);",
          "content_same": false
        },
        {
          "line": 1800,
          "old_api": "options::VectorizedReduceDisabled(hlo_module_config_)",
          "new_api": "dimensions",
          "old_text": "options::VectorizedReduceDisabled(hlo_module_config_)",
          "new_text": "reduce->dimensions()",
          "old_line_content": "  if (!options::VectorizedReduceDisabled(hlo_module_config_)) {",
          "new_line_content": "  absl::Span<const int64> dimensions(reduce->dimensions());",
          "content_same": false
        },
        {
          "line": 1809,
          "old_api": "Status::OK()",
          "new_api": "ToString",
          "old_text": "Status::OK()",
          "new_text": "reduce->ToString()",
          "old_line_content": "      return Status::OK();",
          "new_line_content": "      VLOG(1) << \"Successfully vectorized reduction \" << reduce->ToString()",
          "content_same": false
        },
        {
          "line": 1811,
          "old_api": "ToString",
          "new_api": "Status::OK()",
          "old_text": "reduce->ToString()",
          "new_text": "Status::OK()",
          "old_line_content": "      VLOG(1) << \"Could not vectorize reduction \" << reduce->ToString() << \": \"",
          "new_line_content": "      return Status::OK();",
          "content_same": false
        },
        {
          "line": 1849,
          "old_api": "shape",
          "new_api": "EmitTargetAddressForOp",
          "old_text": "slice->shape()",
          "new_text": "EmitTargetAddressForOp(slice)",
          "old_line_content": "  if (ShapeUtil::IsZeroElementArray(slice->shape())) {",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(slice));",
          "content_same": false
        },
        {
          "line": 1878,
          "old_api": "shape",
          "new_api": "size",
          "old_text": "slice->shape()",
          "new_text": "inner_dims.size()",
          "old_line_content": "    if (ShapeUtil::IsEffectiveScalar(slice->shape())) {",
          "new_line_content": "  const bool is_trivial_copy = (inner_dims.size() == num_dims);",
          "content_same": false
        },
        {
          "line": 1881,
          "old_api": "EmitMemcpy",
          "new_api": "DefaultAction",
          "old_text": "EmitMemcpy(*slice, *operand)",
          "new_text": "DefaultAction(slice)",
          "old_line_content": "      return EmitMemcpy(*slice, *operand);",
          "new_line_content": "      return DefaultAction(slice);",
          "content_same": false
        },
        {
          "line": 1889,
          "old_api": "shape",
          "new_api": "contains",
          "old_text": "operand->shape()",
          "new_text": "ShapeUtil::FilterDimensions(\n      [&inner_dims](int64 dim) { return inner_dims.contains(dim); },\n      operand->shape())",
          "old_line_content": "      operand->shape());",
          "new_line_content": "  const Shape logical_element_shape = ShapeUtil::FilterDimensions(",
          "content_same": false
        },
        {
          "line": 1898,
          "old_api": "slice_strides",
          "new_api": "size",
          "old_text": "slice->slice_strides(memcpy_dim)",
          "new_text": "inner_dims.size()",
          "old_line_content": "  const bool memcpy_is_contiguous = slice->slice_strides(memcpy_dim) == 1;",
          "new_line_content": "  const int64 memcpy_dim = LayoutUtil::Minor(layout, inner_dims.size());",
          "content_same": false
        },
        {
          "line": 1921,
          "old_api": "size",
          "new_api": "GetIrArrayFor",
          "old_text": "outer_dims.size()",
          "new_text": "GetIrArrayFor(slice)",
          "old_line_content": "  const int64 num_outer_loops = outer_dims.size();",
          "new_line_content": "  llvm_ir::IrArray target_array = GetIrArrayFor(slice);",
          "content_same": false
        },
        {
          "line": 1924,
          "old_api": "shape",
          "new_api": "IrName",
          "old_text": "slice->shape()",
          "new_text": "IrName(slice)",
          "old_line_content": "      loops.AddLoopsForShapeOnDimensions(slice->shape(), outer_dims, \"slice\");",
          "new_line_content": "  llvm_ir::ForLoopNest loops(IrName(slice), &b_);",
          "content_same": false
        },
        {
          "line": 1931,
          "old_api": "getInt64",
          "new_api": "end",
          "old_text": "b_.getInt64(0)",
          "new_text": "target_multi_index.end()",
          "old_line_content": "               static_cast<llvm::Value*>(b_.getInt64(0)));",
          "new_line_content": "  std::replace(target_multi_index.begin(), target_multi_index.end(),",
          "content_same": false
        },
        {
          "line": 1932,
          "old_api": "shape",
          "new_api": "static_cast<llvm::Value*>(nullptr)",
          "old_text": "slice->shape()",
          "new_text": "static_cast<llvm::Value*>(nullptr)",
          "old_line_content": "  llvm_ir::IrArray::Index target_index(target_multi_index, slice->shape(),",
          "new_line_content": "               static_cast<llvm::Value*>(nullptr),",
          "content_same": false
        },
        {
          "line": 1933,
          "old_api": "getInt64Ty",
          "new_api": "getInt64",
          "old_text": "b_.getInt64Ty()",
          "new_text": "b_.getInt64(0)",
          "old_line_content": "                                       b_.getInt64Ty());",
          "new_line_content": "               static_cast<llvm::Value*>(b_.getInt64(0)));",
          "content_same": false
        },
        {
          "line": 1941,
          "old_api": "slice_starts",
          "new_api": "GetIrArrayFor",
          "old_text": "slice->slice_starts()",
          "new_text": "GetIrArrayFor(operand)",
          "old_line_content": "      /*operand_shape=*/operand->shape(), /*starts=*/slice->slice_starts(),",
          "new_line_content": "  llvm_ir::IrArray source_array = GetIrArrayFor(operand);",
          "content_same": false
        },
        {
          "line": 1942,
          "old_api": "slice_strides",
          "new_api": "SourceIndexOfSlice",
          "old_text": "slice->slice_strides()",
          "new_text": "target_index.SourceIndexOfSlice(\n      /*operand_shape=*/operand->shape(), /*starts=*/slice->slice_starts(),\n      /*strides=*/slice->slice_strides(), /*builder=*/&b_)",
          "old_line_content": "      /*strides=*/slice->slice_strides(), /*builder=*/&b_);",
          "new_line_content": "  const llvm_ir::IrArray::Index source_index = target_index.SourceIndexOfSlice(",
          "content_same": false
        },
        {
          "line": 1958,
          "old_api": "ShapeUtil::ByteSizeOf(logical_element_shape)",
          "new_api": "VLOG_IS_ON",
          "old_text": "ShapeUtil::ByteSizeOf(logical_element_shape)",
          "new_text": "VLOG_IS_ON(2)",
          "old_line_content": "        ShapeUtil::ByteSizeOf(logical_element_shape) * memcpy_elements;",
          "new_line_content": "  if (VLOG_IS_ON(2)) {",
          "content_same": false
        },
        {
          "line": 1973,
          "old_api": "operand",
          "new_api": "shape",
          "old_text": "dynamic_slice->operand(0)",
          "new_text": "dynamic_slice->shape()",
          "old_line_content": "    return EmitMemcpy(*dynamic_slice->operand(0), *dynamic_slice);",
          "new_line_content": "  if (ShapeUtil::IsScalar(dynamic_slice->shape())) {",
          "content_same": false
        },
        {
          "line": 1975,
          "old_api": "DefaultAction",
          "new_api": "operand",
          "old_text": "DefaultAction(dynamic_slice)",
          "new_text": "dynamic_slice->operand(0)",
          "old_line_content": "  return DefaultAction(dynamic_slice);",
          "new_line_content": "    return EmitMemcpy(*dynamic_slice->operand(0), *dynamic_slice);",
          "content_same": false
        },
        {
          "line": 1982,
          "old_api": "EmitTargetAddressForOp",
          "new_api": "operand",
          "old_text": "EmitTargetAddressForOp(dynamic_update_slice)",
          "new_text": "dynamic_update_slice->operand(1)",
          "old_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(dynamic_update_slice));",
          "new_line_content": "  auto update = dynamic_update_slice->operand(1);",
          "content_same": false
        },
        {
          "line": 1983,
          "old_api": "EmitMemcpy",
          "new_api": "shape",
          "old_text": "EmitMemcpy(*update, *dynamic_update_slice)",
          "new_text": "dynamic_update_slice->shape()",
          "old_line_content": "    return EmitMemcpy(*update, *dynamic_update_slice);",
          "new_line_content": "  if (ShapeUtil::IsScalar(dynamic_update_slice->shape())) {",
          "content_same": false
        },
        {
          "line": 1984,
          "old_api": "llvm_ir::CanUpdateDynamicSliceInPlace(dynamic_update_slice,\n                                                   assignment_)",
          "new_api": "EmitTargetAddressForOp",
          "old_text": "llvm_ir::CanUpdateDynamicSliceInPlace(dynamic_update_slice,\n                                                   assignment_)",
          "new_text": "EmitTargetAddressForOp(dynamic_update_slice)",
          "old_line_content": "  } else if (llvm_ir::CanUpdateDynamicSliceInPlace(dynamic_update_slice,",
          "new_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(dynamic_update_slice));",
          "content_same": false
        },
        {
          "line": 1986,
          "old_api": "EmitTargetAddressForOp",
          "new_api": "llvm_ir::CanUpdateDynamicSliceInPlace(dynamic_update_slice,\n                                                   assignment_)",
          "old_text": "EmitTargetAddressForOp(dynamic_update_slice)",
          "new_text": "llvm_ir::CanUpdateDynamicSliceInPlace(dynamic_update_slice,\n                                                   assignment_)",
          "old_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(dynamic_update_slice));",
          "new_line_content": "  } else if (llvm_ir::CanUpdateDynamicSliceInPlace(dynamic_update_slice,",
          "content_same": false
        },
        {
          "line": 1988,
          "old_api": "llvm_ir::EmitDynamicUpdateSliceInPlace(\n        operands, GetIrArrayFor(dynamic_update_slice),\n        IrName(dynamic_update_slice, \"in_place\"), &b_)",
          "new_api": "EmitTargetAddressForOp",
          "old_text": "llvm_ir::EmitDynamicUpdateSliceInPlace(\n        operands, GetIrArrayFor(dynamic_update_slice),\n        IrName(dynamic_update_slice, \"in_place\"), &b_)",
          "new_text": "EmitTargetAddressForOp(dynamic_update_slice)",
          "old_line_content": "    return llvm_ir::EmitDynamicUpdateSliceInPlace(",
          "new_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(dynamic_update_slice));",
          "content_same": false
        },
        {
          "line": 1989,
          "old_api": "GetIrArrayFor",
          "new_api": "GetIrArraysForOperandsOf",
          "old_text": "GetIrArrayFor(dynamic_update_slice)",
          "new_text": "GetIrArraysForOperandsOf(dynamic_update_slice)",
          "old_line_content": "        operands, GetIrArrayFor(dynamic_update_slice),",
          "new_line_content": "    auto operands = GetIrArraysForOperandsOf(dynamic_update_slice);",
          "content_same": false
        },
        {
          "line": 1990,
          "old_api": "IrName",
          "new_api": "llvm_ir::EmitDynamicUpdateSliceInPlace(\n        operands, GetIrArrayFor(dynamic_update_slice),\n        IrName(dynamic_update_slice, \"in_place\"), &b_)",
          "old_text": "IrName(dynamic_update_slice, \"in_place\")",
          "new_text": "llvm_ir::EmitDynamicUpdateSliceInPlace(\n        operands, GetIrArrayFor(dynamic_update_slice),\n        IrName(dynamic_update_slice, \"in_place\"), &b_)",
          "old_line_content": "        IrName(dynamic_update_slice, \"in_place\"), &b_);",
          "new_line_content": "    return llvm_ir::EmitDynamicUpdateSliceInPlace(",
          "content_same": false
        },
        {
          "line": 1992,
          "old_api": "DefaultAction",
          "new_api": "IrName",
          "old_text": "DefaultAction(dynamic_update_slice)",
          "new_text": "IrName(dynamic_update_slice, \"in_place\")",
          "old_line_content": "  return DefaultAction(dynamic_update_slice);",
          "new_line_content": "        IrName(dynamic_update_slice, \"in_place\"), &b_);",
          "content_same": false
        },
        {
          "line": 2010,
          "old_api": "edge_padding_high",
          "new_api": "dimensions",
          "old_text": "padding_dimension.edge_padding_high()",
          "new_text": "pad->padding_config().dimensions()",
          "old_line_content": "        padding_dimension.edge_padding_high() < 0) {",
          "new_line_content": "  for (auto& padding_dimension : pad->padding_config().dimensions()) {",
          "content_same": false
        },
        {
          "line": 2011,
          "old_api": "ToString",
          "new_api": "edge_padding_low",
          "old_text": "InternalErrorStrCat(\n          \"Encountered negative padding in IrEmitter on CPU. \"\n          \"This should have been eliminated at the HLO level. \",\n          pad->ToString())",
          "new_text": "padding_dimension.edge_padding_low()",
          "old_line_content": "      return InternalErrorStrCat(",
          "new_line_content": "    if (padding_dimension.edge_padding_low() < 0 ||",
          "content_same": false
        },
        {
          "line": 2024,
          "old_api": "Load",
          "new_api": "operand",
          "old_text": "Load(padding_value_addr)",
          "new_text": "pad->operand(1)",
          "old_line_content": "        return Load(padding_value_addr);",
          "new_line_content": "        const HloInstruction* padding_value = pad->operand(1);",
          "content_same": false
        },
        {
          "line": 2032,
          "old_api": "shape",
          "new_api": "operand",
          "old_text": "operand->shape()",
          "new_text": "pad->operand(0)",
          "old_line_content": "      loops.AddLoopsForShape(operand->shape(), \"operand\");",
          "new_line_content": "  const HloInstruction* operand = pad->operand(0);",
          "content_same": false
        },
        {
          "line": 2034,
          "old_api": "GetInnerLoopBodyBasicBlock",
          "new_api": "shape",
          "old_text": "loops.GetInnerLoopBodyBasicBlock()",
          "new_text": "operand->shape()",
          "old_line_content": "  SetToFirstInsertPoint(loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "new_line_content": "      loops.AddLoopsForShape(operand->shape(), \"operand\");",
          "content_same": false
        },
        {
          "line": 2045,
          "old_api": "size",
          "new_api": "padding_config",
          "old_text": "operand_index.size()",
          "new_text": "pad->padding_config()",
          "old_line_content": "  for (size_t i = 0; i < operand_index.size(); ++i) {",
          "new_line_content": "  const PaddingConfig& padding_config = pad->padding_config();",
          "content_same": false
        },
        {
          "line": 2047,
          "old_api": "getInt64",
          "new_api": "size",
          "old_text": "Mul(operand_index[i],\n            b_.getInt64(padding_config.dimensions(i).interior_padding() + 1))",
          "new_text": "operand_index.size()",
          "old_line_content": "        Mul(operand_index[i],",
          "new_line_content": "  for (size_t i = 0; i < operand_index.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2051,
          "old_api": "push_back",
          "new_api": "getInt64",
          "old_text": "output_multi_index.push_back(index)",
          "new_text": "Add(\n        offset, b_.getInt64(padding_config.dimensions(i).edge_padding_low()))",
          "old_line_content": "    output_multi_index.push_back(index);",
          "new_line_content": "    llvm::Value* index = Add(",
          "content_same": false
        },
        {
          "line": 2060,
          "old_api": "GetOuterLoopExitBasicBlock",
          "new_api": "EmitWriteArrayElement",
          "old_text": "loops.GetOuterLoopExitBasicBlock()",
          "new_text": "output_array.EmitWriteArrayElement(output_index, operand_data, &b_)",
          "old_line_content": "  SetToFirstInsertPoint(loops.GetOuterLoopExitBasicBlock(), &b_);",
          "new_line_content": "  output_array.EmitWriteArrayElement(output_index, operand_data, &b_);",
          "content_same": false
        },
        {
          "line": 2067,
          "old_api": "VLOG",
          "new_api": "fused_expression_root",
          "old_text": "VLOG(3)",
          "new_text": "fusion->fused_expression_root()",
          "old_line_content": "    VLOG(3) << \"HandleFusion FusedDynamicUpdateSliceInPlace\";",
          "new_line_content": "  auto* root = fusion->fused_expression_root();",
          "content_same": false
        },
        {
          "line": 2072,
          "old_api": "EmitTargetAddressForOp",
          "new_api": "BindFusionArguments",
          "old_text": "EmitTargetAddressForOp(fusion)",
          "new_text": "BindFusionArguments(fusion, &fused_emitter)",
          "old_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(fusion));",
          "new_line_content": "    BindFusionArguments(fusion, &fused_emitter);",
          "content_same": false
        },
        {
          "line": 2074,
          "old_api": "llvm_ir::EmitFusedDynamicUpdateSliceInPlace(\n        fusion, GetIrArrayFor(fusion), &fused_emitter, &b_)",
          "new_api": "EmitTargetAddressForOp",
          "old_text": "llvm_ir::EmitFusedDynamicUpdateSliceInPlace(\n        fusion, GetIrArrayFor(fusion), &fused_emitter, &b_)",
          "new_text": "EmitTargetAddressForOp(fusion)",
          "old_line_content": "    return llvm_ir::EmitFusedDynamicUpdateSliceInPlace(",
          "new_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(fusion));",
          "content_same": false
        },
        {
          "line": 2076,
          "old_api": "IsLoopFusion",
          "new_api": "llvm_ir::EmitFusedDynamicUpdateSliceInPlace(\n        fusion, GetIrArrayFor(fusion), &fused_emitter, &b_)",
          "old_text": "fusion->IsLoopFusion()",
          "new_text": "llvm_ir::EmitFusedDynamicUpdateSliceInPlace(\n        fusion, GetIrArrayFor(fusion), &fused_emitter, &b_)",
          "old_line_content": "  } else if (fusion->IsLoopFusion()) {",
          "new_line_content": "    return llvm_ir::EmitFusedDynamicUpdateSliceInPlace(",
          "content_same": false
        },
        {
          "line": 2077,
          "old_api": "VLOG",
          "new_api": "GetIrArrayFor",
          "old_text": "VLOG(3)",
          "new_text": "GetIrArrayFor(fusion)",
          "old_line_content": "    VLOG(3) << \"HandleFusion kLoop\";",
          "new_line_content": "        fusion, GetIrArrayFor(fusion), &fused_emitter, &b_);",
          "content_same": false
        },
        {
          "line": 2085,
          "old_api": "VLOG",
          "new_api": "EmitTargetElementLoop",
          "old_text": "VLOG(3)",
          "new_text": "EmitTargetElementLoop(fusion, generator)",
          "old_line_content": "    VLOG(3) << \"HandleFusion kOutput\";",
          "new_line_content": "    return EmitTargetElementLoop(fusion, generator);",
          "content_same": false
        },
        {
          "line": 2086,
          "old_api": "operand",
          "new_api": "IsOutputFusion",
          "old_text": "root->operand(0)->opcode()",
          "new_text": "fusion->IsOutputFusion()",
          "old_line_content": "    int64 dot_op_index = root->operand(0)->opcode() == HloOpcode::kDot ? 0 : 1;",
          "new_line_content": "  } else if (fusion->IsOutputFusion()) {",
          "content_same": false
        },
        {
          "line": 2087,
          "old_api": "operand",
          "new_api": "VLOG",
          "old_text": "root->operand(dot_op_index)",
          "new_text": "VLOG(3)",
          "old_line_content": "    const HloInstruction* dot = root->operand(dot_op_index);",
          "new_line_content": "    VLOG(3) << \"HandleFusion kOutput\";",
          "content_same": false
        },
        {
          "line": 2088,
          "old_api": "opcode",
          "new_api": "operand",
          "old_text": "dot->opcode()",
          "new_text": "root->operand(0)->opcode()",
          "old_line_content": "    CHECK_EQ(dot->opcode(), HloOpcode::kDot)",
          "new_line_content": "    int64 dot_op_index = root->operand(0)->opcode() == HloOpcode::kDot ? 0 : 1;",
          "content_same": false
        },
        {
          "line": 2089,
          "old_api": "ToString",
          "new_api": "operand",
          "old_text": "dot->ToString()",
          "new_text": "root->operand(dot_op_index)",
          "old_line_content": "        << dot->ToString() << \"  \"",
          "new_line_content": "    const HloInstruction* dot = root->operand(dot_op_index);",
          "content_same": false
        },
        {
          "line": 2090,
          "old_api": "fused_instructions_computation",
          "new_api": "opcode",
          "old_text": "fusion->fused_instructions_computation()->ToString()",
          "new_text": "dot->opcode()",
          "old_line_content": "        << fusion->fused_instructions_computation()->ToString();",
          "new_line_content": "    CHECK_EQ(dot->opcode(), HloOpcode::kDot)",
          "content_same": false
        },
        {
          "line": 2092,
          "old_api": "operand",
          "new_api": "fused_instructions_computation",
          "old_text": "dot->operand(0)->parameter_number()",
          "new_text": "fusion->fused_instructions_computation()->ToString()",
          "old_line_content": "    int64 dot_lhs_param_number = dot->operand(0)->parameter_number();",
          "new_line_content": "        << fusion->fused_instructions_computation()->ToString();",
          "content_same": false
        },
        {
          "line": 2097,
          "old_api": "shape",
          "new_api": "operand",
          "old_text": "fusion->shape()",
          "new_text": "root->operand(1 - dot_op_index)->parameter_number()",
          "old_line_content": "    Shape target_shape = fusion->shape();",
          "new_line_content": "        root->operand(1 - dot_op_index)->parameter_number();",
          "content_same": false
        },
        {
          "line": 2099,
          "old_api": "GetIrArrayFor",
          "new_api": "shape",
          "old_text": "GetIrArrayFor(fusion)",
          "new_text": "fusion->shape()",
          "old_line_content": "    llvm_ir::IrArray target_array = GetIrArrayFor(fusion);",
          "new_line_content": "    Shape target_shape = fusion->shape();",
          "content_same": false
        },
        {
          "line": 2108,
          "old_api": "EmitDotOperation",
          "new_api": "operand",
          "old_text": "EmitDotOperation(\n        *dot, target_array, lhs_array, rhs_array, &addend_array,\n        GetExecutableRunOptionsArgument(), &b_, mlir_context_,\n        hlo_module_config_, target_machine_features_)",
          "new_text": "fusion->operand(addend_param_number)",
          "old_line_content": "    TF_RETURN_IF_ERROR(EmitDotOperation(",
          "new_line_content": "        GetIrArrayFor(fusion->operand(addend_param_number)));",
          "content_same": false
        },
        {
          "line": 2110,
          "old_api": "GetExecutableRunOptionsArgument",
          "new_api": "EmitDotOperation",
          "old_text": "GetExecutableRunOptionsArgument()",
          "new_text": "EmitDotOperation(\n        *dot, target_array, lhs_array, rhs_array, &addend_array,\n        GetExecutableRunOptionsArgument(), &b_, mlir_context_,\n        hlo_module_config_, target_machine_features_)",
          "old_line_content": "        GetExecutableRunOptionsArgument(), &b_, mlir_context_,",
          "new_line_content": "    TF_RETURN_IF_ERROR(EmitDotOperation(",
          "content_same": false
        },
        {
          "line": 2112,
          "old_api": "Status::OK()",
          "new_api": "GetExecutableRunOptionsArgument",
          "old_text": "Status::OK()",
          "new_text": "GetExecutableRunOptionsArgument()",
          "old_line_content": "    return Status::OK();",
          "new_line_content": "        GetExecutableRunOptionsArgument(), &b_, mlir_context_,",
          "content_same": false
        },
        {
          "line": 2114,
          "old_api": "Unimplemented",
          "new_api": "Status::OK()",
          "old_text": "Unimplemented(\"Fusion kind not implemented on CPU\")",
          "new_text": "Status::OK()",
          "old_line_content": "    return Unimplemented(\"Fusion kind not implemented on CPU\");",
          "new_line_content": "    return Status::OK();",
          "content_same": false
        },
        {
          "line": 2122,
          "old_api": "EmitTargetAddressForOp",
          "new_api": "FindOrDie",
          "old_text": "EmitTargetAddressForOp(call)",
          "new_text": "FindOrDie(emitted_functions_, computation)",
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(call));",
          "new_line_content": "  llvm::Function* call_ir_function = FindOrDie(emitted_functions_, computation);",
          "content_same": false
        },
        {
          "line": 2124,
          "old_api": "empty",
          "new_api": "EmitTargetAddressForOp",
          "old_text": "computation->root_instruction()->outer_dimension_partitions().empty()",
          "new_text": "EmitTargetAddressForOp(call)",
          "old_line_content": "  if (!computation->root_instruction()->outer_dimension_partitions().empty()) {",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(call));",
          "content_same": false
        },
        {
          "line": 2130,
          "old_api": "GetExecutableRunOptionsArgument",
          "new_api": "name",
          "old_text": "GetExecutableRunOptionsArgument()",
          "new_text": "computation->name()",
          "old_line_content": "        /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),",
          "new_line_content": "        {}, &b_, computation->name(),",
          "content_same": false
        },
        {
          "line": 2132,
          "old_api": "GetProfileCountersArgument",
          "new_api": "GetExecutableRunOptionsArgument",
          "old_text": "GetProfileCountersArgument()",
          "new_text": "GetExecutableRunOptionsArgument()",
          "old_line_content": "        /*profile_counters_arg=*/GetProfileCountersArgument());",
          "new_line_content": "        /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),",
          "content_same": false
        },
        {
          "line": 2134,
          "old_api": "root_instruction",
          "new_api": "GetProfileCountersArgument",
          "old_text": "computation->root_instruction()",
          "new_text": "GetProfileCountersArgument()",
          "old_line_content": "    HloInstruction* root = computation->root_instruction();",
          "new_line_content": "        /*profile_counters_arg=*/GetProfileCountersArgument());",
          "content_same": false
        },
        {
          "line": 2136,
          "old_api": "outer_dimension_partitions",
          "new_api": "root_instruction",
          "old_text": "root->outer_dimension_partitions()",
          "new_text": "computation->root_instruction()",
          "old_line_content": "        call_args, root->shape(), root->outer_dimension_partitions(), &b_,",
          "new_line_content": "    HloInstruction* root = computation->root_instruction();",
          "content_same": false
        },
        {
          "line": 2137,
          "old_api": "name",
          "new_api": "shape",
          "old_text": "computation->name()",
          "new_text": "EmitCallToParallelForkJoin(\n        call_args, root->shape(), root->outer_dimension_partitions(), &b_,\n        call_ir_function, computation->name())",
          "old_line_content": "        call_ir_function, computation->name()));",
          "new_line_content": "    TF_RETURN_IF_ERROR(EmitCallToParallelForkJoin(",
          "content_same": false
        },
        {
          "line": 2152,
          "old_api": "getInt8Ty",
          "new_api": "GetEmittedValueFor",
          "old_text": "b_.getInt8Ty()->getPointerTo()",
          "new_text": "GetEmittedValueFor(hlo)",
          "old_line_content": "      b_.CreateBitCast(dest_buffer, b_.getInt8Ty()->getPointerTo());",
          "new_line_content": "  llvm::Value* dest_buffer = GetEmittedValueFor(hlo);",
          "content_same": false
        },
        {
          "line": 2155,
          "old_api": "operand",
          "new_api": "operand_count",
          "old_text": "hlo->operand(i)",
          "new_text": "hlo->operand_count()",
          "old_line_content": "    llvm::Value* source_buffer = GetEmittedValueFor(hlo->operand(i));",
          "new_line_content": "  for (int64 i = 1; i < hlo->operand_count(); ++i) {",
          "content_same": false
        },
        {
          "line": 2158,
          "old_api": "CreateConstInBoundsGEP1_32",
          "new_api": "CreateLoad",
          "old_text": "b_.CreateConstInBoundsGEP1_32(\n        b_.getInt8Ty(), raw_buffer, raw_data_size + dim_index * sizeof(int32))",
          "new_text": "b_.CreateLoad(source_buffer, \"dyn_dim_size\")",
          "old_line_content": "    llvm::Value* metadata = b_.CreateConstInBoundsGEP1_32(",
          "new_line_content": "    llvm::LoadInst* dyn_dim_size = b_.CreateLoad(source_buffer, \"dyn_dim_size\");",
          "content_same": false
        },
        {
          "line": 2160,
          "old_api": "CreateStore",
          "new_api": "CreateConstInBoundsGEP1_32",
          "old_text": "b_.CreateStore(dyn_dim_size,\n                   b_.CreateBitCast(metadata, b_.getInt32Ty()->getPointerTo()))",
          "new_text": "b_.CreateConstInBoundsGEP1_32(\n        b_.getInt8Ty(), raw_buffer, raw_data_size + dim_index * sizeof(int32))",
          "old_line_content": "    b_.CreateStore(dyn_dim_size,",
          "new_line_content": "    llvm::Value* metadata = b_.CreateConstInBoundsGEP1_32(",
          "content_same": false
        },
        {
          "line": 2161,
          "old_api": "getInt32Ty",
          "new_api": "getInt8Ty",
          "old_text": "b_.getInt32Ty()->getPointerTo()",
          "new_text": "b_.getInt8Ty()",
          "old_line_content": "                   b_.CreateBitCast(metadata, b_.getInt32Ty()->getPointerTo()));",
          "new_line_content": "        b_.getInt8Ty(), raw_buffer, raw_data_size + dim_index * sizeof(int32));",
          "content_same": false
        },
        {
          "line": 2162,
          "old_api": "getInt64Ty",
          "new_api": "CreateStore",
          "old_text": "b_.getInt64Ty()",
          "new_text": "b_.CreateStore(dyn_dim_size,\n                   b_.CreateBitCast(metadata, b_.getInt32Ty()->getPointerTo()))",
          "old_line_content": "    dynamic_dims.push_back(b_.CreateIntCast(dyn_dim_size, b_.getInt64Ty(),",
          "new_line_content": "    b_.CreateStore(dyn_dim_size,",
          "content_same": false
        },
        {
          "line": 2179,
          "old_api": "GetShape",
          "new_api": "Linearize",
          "old_text": "data_array.GetShape()",
          "new_text": "array_index.Linearize(dynamic_dims, &b_)",
          "old_line_content": "    llvm_ir::IrArray::Index dest_index(linear_index, data_array.GetShape(),",
          "new_line_content": "    llvm::Value* linear_index = array_index.Linearize(dynamic_dims, &b_);",
          "content_same": false
        },
        {
          "line": 2181,
          "old_api": "EmitWriteArrayElement",
          "new_api": "GetShape",
          "old_text": "data_array.EmitWriteArrayElement(dest_index, source_element, &b_)",
          "new_text": "data_array.GetShape()",
          "old_line_content": "    data_array.EmitWriteArrayElement(dest_index, source_element, &b_);",
          "new_line_content": "    llvm_ir::IrArray::Index dest_index(linear_index, data_array.GetShape(),",
          "content_same": false
        },
        {
          "line": 2184,
          "old_api": "GetShape",
          "new_api": "Status::OK()",
          "old_text": "data_array.GetShape()",
          "new_text": "Status::OK()",
          "old_line_content": "  return llvm_ir::LoopEmitter(loop_body_emitter, data_array.GetShape(),",
          "new_line_content": "    return Status::OK();",
          "content_same": false
        },
        {
          "line": 2186,
          "old_api": "IrName",
          "new_api": "GetShape",
          "old_text": "IrName(hlo)",
          "new_text": "data_array.GetShape()",
          "old_line_content": "      .EmitLoop(IrName(hlo));",
          "new_line_content": "  return llvm_ir::LoopEmitter(loop_body_emitter, data_array.GetShape(),",
          "content_same": false
        },
        {
          "line": 2198,
          "old_api": "EmitBufferPointer",
          "new_api": "shape",
          "old_text": "EmitBufferPointer(data_slice, data_shape)",
          "new_text": "hlo->shape()",
          "old_line_content": "  llvm::Value* data_address = EmitBufferPointer(data_slice, data_shape);",
          "new_line_content": "  const Shape& data_shape = ShapeUtil::GetSubshape(hlo->shape(), {0});",
          "content_same": false
        },
        {
          "line": 2200,
          "old_api": "operand",
          "new_api": "EmitBufferPointer",
          "old_text": "hlo->operand(0)",
          "new_text": "EmitBufferPointer(data_slice, data_shape)",
          "old_line_content": "  llvm::Value* source_buffer = GetEmittedValueFor(hlo->operand(0));",
          "new_line_content": "  llvm::Value* data_address = EmitBufferPointer(data_slice, data_shape);",
          "content_same": false
        },
        {
          "line": 2202,
          "old_api": "getInt8Ty",
          "new_api": "operand",
          "old_text": "b_.getInt8Ty()->getPointerTo()",
          "new_text": "hlo->operand(0)",
          "old_line_content": "      b_.CreateBitCast(source_buffer, b_.getInt8Ty()->getPointerTo());",
          "new_line_content": "  llvm::Value* source_buffer = GetEmittedValueFor(hlo->operand(0));",
          "content_same": false
        },
        {
          "line": 2204,
          "old_api": "ShapeUtil::MakeStaticShape(input_shape)",
          "new_api": "getInt8Ty",
          "old_text": "ShapeUtil::MakeStaticShape(input_shape)",
          "new_text": "b_.getInt8Ty()->getPointerTo()",
          "old_line_content": "      ShapeUtil::ByteSizeOf(ShapeUtil::MakeStaticShape(input_shape));",
          "new_line_content": "      b_.CreateBitCast(source_buffer, b_.getInt8Ty()->getPointerTo());",
          "content_same": false
        },
        {
          "line": 2213,
          "old_api": "shape",
          "new_api": "tuple_shapes_size",
          "old_text": "hlo->shape()",
          "new_text": "hlo->shape().tuple_shapes_size()",
          "old_line_content": "    const Shape& dim_shape = ShapeUtil::GetSubshape(hlo->shape(), {i});",
          "new_line_content": "  for (int64 i = 1; i < hlo->shape().tuple_shapes_size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2220,
          "old_api": "CreateConstInBoundsGEP1_32",
          "new_api": "EmitBufferPointer",
          "old_text": "b_.CreateConstInBoundsGEP1_32(\n        b_.getInt8Ty(), raw_buffer, raw_data_size + dim_index * sizeof(int32))",
          "new_text": "EmitBufferPointer(dim_size_slice, data_shape)",
          "old_line_content": "    llvm::Value* metadata = b_.CreateConstInBoundsGEP1_32(",
          "new_line_content": "        EmitBufferPointer(dim_size_slice, data_shape);",
          "content_same": false
        },
        {
          "line": 2222,
          "old_api": "CreateLoad",
          "new_api": "CreateConstInBoundsGEP1_32",
          "old_text": "b_.CreateLoad(\n        b_.CreateBitCast(metadata, b_.getInt32Ty()->getPointerTo()),\n        \"dyn_dim_size\")",
          "new_text": "b_.CreateConstInBoundsGEP1_32(\n        b_.getInt8Ty(), raw_buffer, raw_data_size + dim_index * sizeof(int32))",
          "old_line_content": "    llvm::Value* dyn_dim_size = b_.CreateLoad(",
          "new_line_content": "    llvm::Value* metadata = b_.CreateConstInBoundsGEP1_32(",
          "content_same": false
        },
        {
          "line": 2223,
          "old_api": "getInt32Ty",
          "new_api": "getInt8Ty",
          "old_text": "b_.getInt32Ty()->getPointerTo()",
          "new_text": "b_.getInt8Ty()",
          "old_line_content": "        b_.CreateBitCast(metadata, b_.getInt32Ty()->getPointerTo()),",
          "new_line_content": "        b_.getInt8Ty(), raw_buffer, raw_data_size + dim_index * sizeof(int32));",
          "content_same": false
        },
        {
          "line": 2225,
          "old_api": "CreateStore",
          "new_api": "getInt32Ty",
          "old_text": "b_.CreateStore(dyn_dim_size,\n                   b_.CreateBitCast(dest_dim_size_address,\n                                    b_.getInt32Ty()->getPointerTo()))",
          "new_text": "b_.getInt32Ty()->getPointerTo()",
          "old_line_content": "    b_.CreateStore(dyn_dim_size,",
          "new_line_content": "        b_.CreateBitCast(metadata, b_.getInt32Ty()->getPointerTo()),",
          "content_same": false
        },
        {
          "line": 2227,
          "old_api": "getInt32Ty",
          "new_api": "CreateStore",
          "old_text": "b_.getInt32Ty()->getPointerTo()",
          "new_text": "b_.CreateStore(dyn_dim_size,\n                   b_.CreateBitCast(dest_dim_size_address,\n                                    b_.getInt32Ty()->getPointerTo()))",
          "old_line_content": "                                    b_.getInt32Ty()->getPointerTo()));",
          "new_line_content": "    b_.CreateStore(dyn_dim_size,",
          "content_same": false
        },
        {
          "line": 2228,
          "old_api": "getInt64Ty",
          "new_api": "CreateBitCast",
          "old_text": "b_.getInt64Ty()",
          "new_text": "b_.CreateBitCast(dest_dim_size_address,\n                                    b_.getInt32Ty()->getPointerTo())",
          "old_line_content": "    dynamic_dims.push_back(b_.CreateIntCast(dyn_dim_size, b_.getInt64Ty(),",
          "new_line_content": "                   b_.CreateBitCast(dest_dim_size_address,",
          "content_same": false
        },
        {
          "line": 2246,
          "old_api": "Status::OK()",
          "new_api": "operand",
          "old_text": "Status::OK()",
          "new_text": "hlo->operand(0)",
          "old_line_content": "    return Status::OK();",
          "new_line_content": "        GetIrArrayFor(hlo->operand(0)).EmitReadArrayElement(source_index, &b_);",
          "content_same": false
        },
        {
          "line": 2248,
          "old_api": "EmitLoop",
          "new_api": "Status::OK()",
          "old_text": "TF_RETURN_IF_ERROR(\n      llvm_ir::LoopEmitter(loop_body_emitter, input_shape, dynamic_dims, &b_)\n          .EmitLoop(IrName(hlo)))",
          "new_text": "Status::OK()",
          "old_line_content": "  TF_RETURN_IF_ERROR(",
          "new_line_content": "    return Status::OK();",
          "content_same": false
        },
        {
          "line": 2250,
          "old_api": "IrName",
          "new_api": "EmitLoop",
          "old_text": "IrName(hlo)",
          "new_text": "TF_RETURN_IF_ERROR(\n      llvm_ir::LoopEmitter(loop_body_emitter, input_shape, dynamic_dims, &b_)\n          .EmitLoop(IrName(hlo)))",
          "old_line_content": "          .EmitLoop(IrName(hlo)));",
          "new_line_content": "  TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 2260,
          "old_api": "tuple_shapes",
          "new_api": "EmitTargetAddressForOp",
          "old_text": "hlo->shape().tuple_shapes(0).dimensions().back()",
          "new_text": "EmitTargetAddressForOp(hlo)",
          "old_line_content": "  const int64 k = hlo->shape().tuple_shapes(0).dimensions().back();",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(hlo));",
          "content_same": false
        },
        {
          "line": 2261,
          "old_api": "tuple_shapes",
          "new_api": "operand",
          "old_text": "hlo->shape().tuple_shapes(0).dimensions_size()",
          "new_text": "hlo->operand(0)",
          "old_line_content": "  const bool has_batch = hlo->shape().tuple_shapes(0).dimensions_size() == 2;",
          "new_line_content": "  const HloInstruction* input = hlo->operand(0);",
          "content_same": false
        },
        {
          "line": 2262,
          "old_api": "element_type",
          "new_api": "tuple_shapes",
          "old_text": "input->shape().element_type()",
          "new_text": "hlo->shape().tuple_shapes(0).dimensions().back()",
          "old_line_content": "  TF_RET_CHECK(input->shape().element_type() == F32);",
          "new_line_content": "  const int64 k = hlo->shape().tuple_shapes(0).dimensions().back();",
          "content_same": false
        },
        {
          "line": 2264,
          "old_api": "tuple_shapes",
          "new_api": "element_type",
          "old_text": "hlo->shape().tuple_shapes(0).layout()",
          "new_text": "input->shape().element_type()",
          "old_line_content": "      hlo->shape().tuple_shapes(0).layout()));",
          "new_line_content": "  TF_RET_CHECK(input->shape().element_type() == F32);",
          "content_same": false
        },
        {
          "line": 2267,
          "old_api": "layout",
          "new_api": "tuple_shapes",
          "old_text": "TF_RET_CHECK(\n      LayoutUtil::IsMonotonicWithDim0Major(hlo->operand(0)->shape().layout()))",
          "new_text": "LayoutUtil::IsMonotonicWithDim0Major(\n      hlo->shape().tuple_shapes(1).layout())",
          "old_line_content": "  TF_RET_CHECK(",
          "new_line_content": "  TF_RET_CHECK(LayoutUtil::IsMonotonicWithDim0Major(",
          "content_same": false
        },
        {
          "line": 2268,
          "old_api": "layout",
          "new_api": "tuple_shapes",
          "old_text": "hlo->operand(0)->shape().layout()",
          "new_text": "hlo->shape().tuple_shapes(1).layout()",
          "old_line_content": "      LayoutUtil::IsMonotonicWithDim0Major(hlo->operand(0)->shape().layout()));",
          "new_line_content": "      hlo->shape().tuple_shapes(1).layout()));",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": "tuple_shapes",
          "new_api": "operand",
          "old_text": "hlo->shape().tuple_shapes(0)",
          "new_text": "hlo->operand(0)->shape()",
          "old_line_content": "      EmitBufferPointer(out_values_slice, hlo->shape().tuple_shapes(0));",
          "new_line_content": "      EmitBufferPointer(values_slice, hlo->operand(0)->shape());",
          "content_same": false
        },
        {
          "line": 2284,
          "old_api": "dimensions",
          "new_api": "getInt64",
          "old_text": "input->shape().dimensions(0)",
          "new_text": "EmitCallToFunc(\n      runtime::kTopKF32SymbolName,\n      {b_.getInt64(has_batch ? input->shape().dimensions(0) : 1),\n       b_.getInt64(input->shape().dimensions().back()), b_.getInt64(k),\n       BitCast(values_ptr, b_.getFloatTy()->getPointerTo()),\n       BitCast(out_values_ptr, b_.getFloatTy()->getPointerTo()),\n       BitCast(out_indices_ptr, b_.getInt32Ty()->getPointerTo())},\n      b_.getVoidTy())",
          "old_line_content": "      {b_.getInt64(has_batch ? input->shape().dimensions(0) : 1),",
          "new_line_content": "  EmitCallToFunc(",
          "content_same": false
        },
        {
          "line": 2286,
          "old_api": "getFloatTy",
          "new_api": "dimensions",
          "old_text": "b_.getFloatTy()->getPointerTo()",
          "new_text": "input->shape().dimensions(0)",
          "old_line_content": "       BitCast(values_ptr, b_.getFloatTy()->getPointerTo()),",
          "new_line_content": "      {b_.getInt64(has_batch ? input->shape().dimensions(0) : 1),",
          "content_same": false
        },
        {
          "line": 2287,
          "old_api": "getFloatTy",
          "new_api": "getInt64",
          "old_text": "b_.getFloatTy()->getPointerTo()",
          "new_text": "b_.getInt64(k)",
          "old_line_content": "       BitCast(out_values_ptr, b_.getFloatTy()->getPointerTo()),",
          "new_line_content": "       b_.getInt64(input->shape().dimensions().back()), b_.getInt64(k),",
          "content_same": false
        },
        {
          "line": 2288,
          "old_api": "getInt32Ty",
          "new_api": "getFloatTy",
          "old_text": "b_.getInt32Ty()->getPointerTo()",
          "new_text": "b_.getFloatTy()->getPointerTo()",
          "old_line_content": "       BitCast(out_indices_ptr, b_.getInt32Ty()->getPointerTo())},",
          "new_line_content": "       BitCast(values_ptr, b_.getFloatTy()->getPointerTo()),",
          "content_same": false
        },
        {
          "line": 2289,
          "old_api": "getVoidTy",
          "new_api": "getFloatTy",
          "old_text": "b_.getVoidTy()",
          "new_text": "b_.getFloatTy()->getPointerTo()",
          "old_line_content": "      b_.getVoidTy());",
          "new_line_content": "       BitCast(out_values_ptr, b_.getFloatTy()->getPointerTo()),",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": "GetIrArrayFor",
          "new_api": "getVoidTy",
          "old_text": "GetIrArrayFor(hlo)",
          "new_text": "b_.getVoidTy()",
          "old_line_content": "  llvm_ir::EmitTuple(GetIrArrayFor(hlo), {out_values_ptr, out_indices_ptr},",
          "new_line_content": "      b_.getVoidTy());",
          "content_same": false
        },
        {
          "line": 2293,
          "old_api": "Status::OK()",
          "new_api": "GetIrArrayFor",
          "old_text": "Status::OK()",
          "new_text": "GetIrArrayFor(hlo)",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  llvm_ir::EmitTuple(GetIrArrayFor(hlo), {out_values_ptr, out_indices_ptr},",
          "content_same": false
        },
        {
          "line": 2300,
          "old_api": "custom_call_target",
          "new_api": "HandlePadToStatic",
          "old_text": "custom_call->custom_call_target()",
          "new_text": "HandlePadToStatic(custom_call)",
          "old_line_content": "  if (custom_call->custom_call_target() == \"SliceToDynamic\") {",
          "new_line_content": "    return HandlePadToStatic(custom_call);",
          "content_same": false
        },
        {
          "line": 2303,
          "old_api": "custom_call_target",
          "new_api": "HandleSliceToDynamic",
          "old_text": "custom_call->custom_call_target()",
          "new_text": "HandleSliceToDynamic(custom_call)",
          "old_line_content": "  if (custom_call->custom_call_target() == \"TopK\") {",
          "new_line_content": "    return HandleSliceToDynamic(custom_call);",
          "content_same": false
        },
        {
          "line": 2306,
          "old_api": "operands",
          "new_api": "HandleTopK",
          "old_text": "custom_call->operands()",
          "new_text": "HandleTopK(custom_call)",
          "old_line_content": "  absl::Span<HloInstruction* const> operands(custom_call->operands());",
          "new_line_content": "    return HandleTopK(custom_call);",
          "content_same": false
        },
        {
          "line": 2309,
          "old_api": "getInt32",
          "new_api": "getInt8PtrTy",
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntryWithCount(\n          i8_ptr_type, b_.getInt32(operands.size()), \"cc_operands_alloca\", &b_)",
          "new_text": "b_.getInt8PtrTy()",
          "old_line_content": "      llvm_ir::EmitAllocaAtFunctionEntryWithCount(",
          "new_line_content": "  llvm::Type* i8_ptr_type = b_.getInt8PtrTy();",
          "content_same": false
        },
        {
          "line": 2311,
          "old_api": "size",
          "new_api": "getInt32",
          "old_text": "operands.size()",
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntryWithCount(\n          i8_ptr_type, b_.getInt32(operands.size()), \"cc_operands_alloca\", &b_)",
          "old_line_content": "  for (size_t i = 0; i < operands.size(); ++i) {",
          "new_line_content": "      llvm_ir::EmitAllocaAtFunctionEntryWithCount(",
          "content_same": false
        },
        {
          "line": 2316,
          "old_api": "getInt64",
          "new_api": "GetEmittedValueFor",
          "old_text": "b_.getInt64(i)",
          "new_text": "GetEmittedValueFor(operand)",
          "old_line_content": "        InBoundsGEP(operands_alloca, {b_.getInt64(i)});",
          "new_line_content": "        PointerCast(GetEmittedValueFor(operand), i8_ptr_type);",
          "content_same": false
        },
        {
          "line": 2325,
          "old_api": "getVoidTy",
          "new_api": "getDataLayout",
          "old_text": "EmitCallToFunc(\n        \"__msan_unpoison\",\n        {PointerCast(operands_alloca, i8_ptr_type),\n         llvm::ConstantInt::get(\n             intptr_type, *operands_alloca->getAllocationSizeInBits(dl) / 8)},\n        b_.getVoidTy())",
          "new_text": "module_->getDataLayout()",
          "old_line_content": "    EmitCallToFunc(",
          "new_line_content": "    const llvm::DataLayout& dl = module_->getDataLayout();",
          "content_same": false
        },
        {
          "line": 2327,
          "old_api": "PointerCast",
          "new_api": "getVoidTy",
          "old_text": "PointerCast(operands_alloca, i8_ptr_type)",
          "new_text": "EmitCallToFunc(\n        \"__msan_unpoison\",\n        {PointerCast(operands_alloca, i8_ptr_type),\n         llvm::ConstantInt::get(\n             intptr_type, *operands_alloca->getAllocationSizeInBits(dl) / 8)},\n        b_.getVoidTy())",
          "old_line_content": "        {PointerCast(operands_alloca, i8_ptr_type),",
          "new_line_content": "    EmitCallToFunc(",
          "content_same": false
        },
        {
          "line": 2329,
          "old_api": "getAllocationSizeInBits",
          "new_api": "PointerCast",
          "old_text": "operands_alloca->getAllocationSizeInBits(dl)",
          "new_text": "PointerCast(operands_alloca, i8_ptr_type)",
          "old_line_content": "             intptr_type, *operands_alloca->getAllocationSizeInBits(dl) / 8)},",
          "new_line_content": "        {PointerCast(operands_alloca, i8_ptr_type),",
          "content_same": false
        },
        {
          "line": 2330,
          "old_api": "getVoidTy",
          "new_api": "getAllocationSizeInBits",
          "old_text": "b_.getVoidTy()",
          "new_text": "llvm::ConstantInt::get(\n             intptr_type, *operands_alloca->getAllocationSizeInBits(dl) / 8)",
          "old_line_content": "        b_.getVoidTy());",
          "new_line_content": "         llvm::ConstantInt::get(",
          "content_same": false
        },
        {
          "line": 2335,
          "old_api": "IsTuple",
          "new_api": "EmitTargetAddressForOp",
          "old_text": "custom_call->shape().IsTuple()",
          "new_text": "EmitTargetAddressForOp(custom_call)",
          "old_line_content": "  if (custom_call->shape().IsTuple()) {",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(custom_call));",
          "content_same": false
        },
        {
          "line": 2337,
          "old_api": "shape",
          "new_api": "IsTuple",
          "old_text": "custom_call->shape()",
          "new_text": "custom_call->shape().IsTuple()",
          "old_line_content": "    for (int i = 0; i < ShapeUtil::TupleElementCount(custom_call->shape());",
          "new_line_content": "  if (custom_call->shape().IsTuple()) {",
          "content_same": false
        },
        {
          "line": 2347,
          "old_api": "GetIrArrayFor",
          "new_api": "push_back",
          "old_text": "GetIrArrayFor(custom_call)",
          "new_text": "base_ptrs.push_back(addr)",
          "old_line_content": "    llvm_ir::EmitTuple(GetIrArrayFor(custom_call), base_ptrs, &b_);",
          "new_line_content": "      base_ptrs.push_back(addr);",
          "content_same": false
        },
        {
          "line": 2352,
          "old_api": "custom_call_target",
          "new_api": "GetEmittedValueFor",
          "old_text": "custom_call->custom_call_target()",
          "new_text": "GetEmittedValueFor(custom_call)",
          "old_line_content": "  EmitCallToFunc(custom_call->custom_call_target(),",
          "new_line_content": "      PointerCast(GetEmittedValueFor(custom_call), i8_ptr_type);",
          "content_same": false
        },
        {
          "line": 2355,
          "old_api": "Status::OK()",
          "new_api": "getVoidTy",
          "old_text": "Status::OK()",
          "new_text": "b_.getVoidTy()",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "                 {output_address_arg, operands_alloca}, b_.getVoidTy());",
          "content_same": false
        },
        {
          "line": 2362,
          "old_api": "element_type",
          "new_api": "while_condition",
          "old_text": "condition->root_instruction()->shape().element_type()",
          "new_text": "xla_while->while_condition()",
          "old_line_content": "               condition->root_instruction()->shape().element_type() == PRED)",
          "new_line_content": "  HloComputation* condition = xla_while->while_condition();",
          "content_same": false
        },
        {
          "line": 2364,
          "old_api": "root_instruction",
          "new_api": "element_type",
          "old_text": "condition->root_instruction()->shape()",
          "new_text": "condition->root_instruction()->shape().element_type()",
          "old_line_content": "      << ShapeUtil::HumanString(condition->root_instruction()->shape());",
          "new_line_content": "               condition->root_instruction()->shape().element_type() == PRED)",
          "content_same": false
        },
        {
          "line": 2366,
          "old_api": "GetUniqueSlice",
          "new_api": "root_instruction",
          "old_text": "ShapeUtil::ForEachSubshapeWithStatus(\n      xla_while->shape(),\n      [this, &xla_while](const Shape& /*subshape*/,\n                         const ShapeIndex& index) -> Status {\n        auto check = [this](const HloInstruction* a, const HloInstruction* b,\n                            const ShapeIndex& index) {\n          const BufferAllocation::Slice slice_a =\n              assignment_.GetUniqueSlice(a, index).ConsumeValueOrDie();\n          const BufferAllocation::Slice slice_b =\n              assignment_.GetUniqueSlice(b, index).ConsumeValueOrDie();\n          if (slice_a != slice_b) {\n            return InternalError(\n                \"instruction %s %s does not share slice with \"\n                \"instruction %s %s\",\n                a->ToString(), slice_a.ToString(), b->ToString(),\n                slice_b.ToString());\n          }\n          return Status::OK();\n        };\n        TF_RETURN_IF_ERROR(check(xla_while, xla_while->operand(0), index));\n        TF_RETURN_IF_ERROR(check(\n            xla_while, xla_while->while_condition()->parameter_instruction(0),\n            index));\n        TF_RETURN_IF_ERROR(\n            check(xla_while, xla_while->while_body()->parameter_instruction(0),\n                  index));\n        TF_RETURN_IF_ERROR(check(\n            xla_while, xla_while->while_body()->root_instruction(), index));\n        return Status::OK();\n      })",
          "new_text": "condition->root_instruction()->shape()",
          "old_line_content": "  TF_RETURN_IF_ERROR(ShapeUtil::ForEachSubshapeWithStatus(",
          "new_line_content": "      << ShapeUtil::HumanString(condition->root_instruction()->shape());",
          "content_same": false
        },
        {
          "line": 2377,
          "old_api": "ToString",
          "new_api": "GetUniqueSlice",
          "old_text": "InternalError(\n                \"instruction %s %s does not share slice with \"\n                \"instruction %s %s\",\n                a->ToString(), slice_a.ToString(), b->ToString(),\n                slice_b.ToString())",
          "new_text": "assignment_.GetUniqueSlice(b, index).ConsumeValueOrDie()",
          "old_line_content": "            return InternalError(",
          "new_line_content": "              assignment_.GetUniqueSlice(b, index).ConsumeValueOrDie();",
          "content_same": false
        },
        {
          "line": 2383,
          "old_api": "Status::OK()",
          "new_api": "ToString",
          "old_text": "Status::OK()",
          "new_text": "slice_b.ToString()",
          "old_line_content": "          return Status::OK();",
          "new_line_content": "                slice_b.ToString());",
          "content_same": false
        },
        {
          "line": 2385,
          "old_api": "operand",
          "new_api": "Status::OK()",
          "old_text": "xla_while->operand(0)",
          "new_text": "Status::OK()",
          "old_line_content": "        TF_RETURN_IF_ERROR(check(xla_while, xla_while->operand(0), index));",
          "new_line_content": "          return Status::OK();",
          "content_same": false
        },
        {
          "line": 2387,
          "old_api": "while_condition",
          "new_api": "operand",
          "old_text": "xla_while->while_condition()->parameter_instruction(0)",
          "new_text": "xla_while->operand(0)",
          "old_line_content": "            xla_while, xla_while->while_condition()->parameter_instruction(0),",
          "new_line_content": "        TF_RETURN_IF_ERROR(check(xla_while, xla_while->operand(0), index));",
          "content_same": false
        },
        {
          "line": 2389,
          "old_api": "while_body",
          "new_api": "while_condition",
          "old_text": "TF_RETURN_IF_ERROR(\n            check(xla_while, xla_while->while_body()->parameter_instruction(0),\n                  index))",
          "new_text": "xla_while->while_condition()->parameter_instruction(0)",
          "old_line_content": "        TF_RETURN_IF_ERROR(",
          "new_line_content": "            xla_while, xla_while->while_condition()->parameter_instruction(0),",
          "content_same": false
        },
        {
          "line": 2394,
          "old_api": "Status::OK()",
          "new_api": "while_body",
          "old_text": "Status::OK()",
          "new_text": "check(\n            xla_while, xla_while->while_body()->root_instruction(), index)",
          "old_line_content": "        return Status::OK();",
          "new_line_content": "        TF_RETURN_IF_ERROR(check(",
          "content_same": false
        },
        {
          "line": 2411,
          "old_api": "function",
          "new_api": "getContext",
          "old_text": "compute_function_->function()",
          "new_text": "llvm::BasicBlock::Create(\n      module_->getContext(), IrName(xla_while, \"header\"),\n      compute_function_->function())",
          "old_line_content": "      compute_function_->function());",
          "new_line_content": "  llvm::BasicBlock* header_bb = llvm::BasicBlock::Create(",
          "content_same": false
        },
        {
          "line": 2412,
          "old_api": "Br",
          "new_api": "IrName",
          "old_text": "Br(header_bb)",
          "new_text": "IrName(xla_while, \"header\")",
          "old_line_content": "  Br(header_bb);",
          "new_line_content": "      module_->getContext(), IrName(xla_while, \"header\"),",
          "content_same": false
        },
        {
          "line": 2413,
          "old_api": "SetInsertPoint",
          "new_api": "function",
          "old_text": "b_.SetInsertPoint(header_bb)",
          "new_text": "compute_function_->function()",
          "old_line_content": "  b_.SetInsertPoint(header_bb);",
          "new_line_content": "      compute_function_->function());",
          "content_same": false
        },
        {
          "line": 2419,
          "old_api": "while_condition",
          "new_api": "IrName",
          "old_text": "xla_while->while_condition()",
          "new_text": "IrName(xla_while, \"cond\")",
          "old_line_content": "      Load(GetBufferForGlobalCallReturnValue(*xla_while->while_condition())),",
          "new_line_content": "  EmitGlobalCall(*xla_while->while_condition(), IrName(xla_while, \"cond\"));",
          "content_same": false
        },
        {
          "line": 2420,
          "old_api": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "new_api": "while_condition",
          "old_text": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "new_text": "ICmpNE(\n      Load(GetBufferForGlobalCallReturnValue(*xla_while->while_condition())),\n      llvm::ConstantInt::get(llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0))",
          "old_line_content": "      llvm::ConstantInt::get(llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0));",
          "new_line_content": "  llvm::Value* while_predicate = ICmpNE(",
          "content_same": false
        },
        {
          "line": 2426,
          "old_api": "getContext",
          "new_api": "IrName",
          "old_text": "llvm::BasicBlock::Create(\n      module_->getContext(), IrName(xla_while, \"exit\"))",
          "new_text": "IrName(xla_while, \"body\")",
          "old_line_content": "  llvm::BasicBlock* exit_bb = llvm::BasicBlock::Create(",
          "new_line_content": "      llvm::BasicBlock::Create(module_->getContext(), IrName(xla_while, \"body\"),",
          "content_same": false
        },
        {
          "line": 2427,
          "old_api": "IrName",
          "new_api": "function",
          "old_text": "IrName(xla_while, \"exit\")",
          "new_text": "compute_function_->function()",
          "old_line_content": "      module_->getContext(), IrName(xla_while, \"exit\"));",
          "new_line_content": "                               compute_function_->function());",
          "content_same": false
        },
        {
          "line": 2428,
          "old_api": "CondBr",
          "new_api": "getContext",
          "old_text": "CondBr(while_predicate, body_bb, exit_bb)",
          "new_text": "llvm::BasicBlock::Create(\n      module_->getContext(), IrName(xla_while, \"exit\"))",
          "old_line_content": "  CondBr(while_predicate, body_bb, exit_bb);",
          "new_line_content": "  llvm::BasicBlock* exit_bb = llvm::BasicBlock::Create(",
          "content_same": false
        },
        {
          "line": 2443,
          "old_api": "Status::OK()",
          "new_api": "SetInsertPoint",
          "old_text": "Status::OK()",
          "new_text": "b_.SetInsertPoint(exit_bb)",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  b_.SetInsertPoint(exit_bb);",
          "content_same": false
        },
        {
          "line": 2457,
          "old_api": "layout",
          "new_api": "shape",
          "old_text": "output_shape.layout()",
          "new_text": "concatenate->shape()",
          "old_line_content": "    if (!LayoutUtil::Equal(op->shape().layout(), output_shape.layout())) {",
          "new_line_content": "  const Shape& output_shape = concatenate->shape();",
          "content_same": false
        },
        {
          "line": 2469,
          "old_api": "LayoutUtil::MinorToMajor(output_layout)",
          "new_api": "dimensions",
          "old_text": "LayoutUtil::MinorToMajor(output_layout)",
          "new_text": "concatenate->dimensions(0)",
          "old_line_content": "  auto output_min2maj = LayoutUtil::MinorToMajor(output_layout);",
          "new_line_content": "  int64 concat_dim = concatenate->dimensions(0);",
          "content_same": false
        },
        {
          "line": 2470,
          "old_api": "absl::c_find(output_min2maj, concat_dim)",
          "new_api": "layout",
          "old_text": "absl::c_find(output_min2maj, concat_dim)",
          "new_text": "output_shape.layout()",
          "old_line_content": "  auto concat_dim_layout_itr = absl::c_find(output_min2maj, concat_dim);",
          "new_line_content": "  const Layout& output_layout = output_shape.layout();",
          "content_same": false
        },
        {
          "line": 2472,
          "old_api": "begin",
          "new_api": "absl::c_find(output_min2maj, concat_dim)",
          "old_text": "output_min2maj.begin()",
          "new_text": "absl::c_find(output_min2maj, concat_dim)",
          "old_line_content": "  std::vector<int64> inner_dims(output_min2maj.begin(), concat_dim_layout_itr);",
          "new_line_content": "  auto concat_dim_layout_itr = absl::c_find(output_min2maj, concat_dim);",
          "content_same": false
        },
        {
          "line": 2474,
          "old_api": "end",
          "new_api": "begin",
          "old_text": "output_min2maj.end()",
          "new_text": "output_min2maj.begin()",
          "old_line_content": "                                output_min2maj.end());",
          "new_line_content": "  std::vector<int64> inner_dims(output_min2maj.begin(), concat_dim_layout_itr);",
          "content_same": false
        },
        {
          "line": 2476,
          "old_api": "getInt8PtrTy",
          "new_api": "end",
          "old_text": "b_.getInt8PtrTy()",
          "new_text": "output_min2maj.end()",
          "old_line_content": "  llvm::Type* i8_ptr_type = b_.getInt8PtrTy();",
          "new_line_content": "                                output_min2maj.end());",
          "content_same": false
        },
        {
          "line": 2478,
          "old_api": "EmitTargetAddressForOp",
          "new_api": "getInt8PtrTy",
          "old_text": "EmitTargetAddressForOp(concatenate)",
          "new_text": "b_.getInt8PtrTy()",
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(concatenate));",
          "new_line_content": "  llvm::Type* i8_ptr_type = b_.getInt8PtrTy();",
          "content_same": false
        },
        {
          "line": 2481,
          "old_api": "IrName",
          "new_api": "GetIrArrayFor",
          "old_text": "IrName(concatenate)",
          "new_text": "GetIrArrayFor(concatenate)",
          "old_line_content": "  llvm_ir::ForLoopNest loops(IrName(concatenate), &b_);",
          "new_line_content": "  llvm_ir::IrArray target_array = GetIrArrayFor(concatenate);",
          "content_same": false
        },
        {
          "line": 2483,
          "old_api": "AddLoopsForShapeOnDimensions",
          "new_api": "IrName",
          "old_text": "loops.AddLoopsForShapeOnDimensions(output_shape, outer_dims, \"concat\")",
          "new_text": "IrName(concatenate)",
          "old_line_content": "      loops.AddLoopsForShapeOnDimensions(output_shape, outer_dims, \"concat\");",
          "new_line_content": "  llvm_ir::ForLoopNest loops(IrName(concatenate), &b_);",
          "content_same": false
        },
        {
          "line": 2485,
          "old_api": "static_cast<llvm::Value*>(nullptr)",
          "new_api": "AddLoopsForShapeOnDimensions",
          "old_text": "static_cast<llvm::Value*>(nullptr)",
          "new_text": "loops.AddLoopsForShapeOnDimensions(output_shape, outer_dims, \"concat\")",
          "old_line_content": "               static_cast<llvm::Value*>(nullptr),",
          "new_line_content": "      loops.AddLoopsForShapeOnDimensions(output_shape, outer_dims, \"concat\");",
          "content_same": false
        },
        {
          "line": 2486,
          "old_api": "getInt64",
          "new_api": "end",
          "old_text": "b_.getInt64(0)",
          "new_text": "target_multi_index.end()",
          "old_line_content": "               static_cast<llvm::Value*>(b_.getInt64(0)));",
          "new_line_content": "  std::replace(target_multi_index.begin(), target_multi_index.end(),",
          "content_same": false
        },
        {
          "line": 2488,
          "old_api": "getInt64Ty",
          "new_api": "getInt64",
          "old_text": "b_.getInt64Ty()",
          "new_text": "b_.getInt64(0)",
          "old_line_content": "                                       b_.getInt64Ty());",
          "new_line_content": "               static_cast<llvm::Value*>(b_.getInt64(0)));",
          "content_same": false
        },
        {
          "line": 2490,
          "old_api": "empty",
          "new_api": "getInt64Ty",
          "old_text": "outer_dims.empty()",
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "  if (!outer_dims.empty()) {",
          "new_line_content": "                                       b_.getInt64Ty());",
          "content_same": false
        },
        {
          "line": 2496,
          "old_api": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "new_api": "element_type",
          "old_text": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "new_text": "output_shape.element_type()",
          "old_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(primitive_type);",
          "new_line_content": "  PrimitiveType primitive_type = output_shape.element_type();",
          "content_same": false
        },
        {
          "line": 2508,
          "old_api": "dimensions",
          "new_api": "end",
          "old_text": "output_shape.dimensions(inner_dim)",
          "new_text": "inner_dims.end()",
          "old_line_content": "                        return product * output_shape.dimensions(inner_dim);",
          "new_line_content": "      std::accumulate(inner_dims.begin(), inner_dims.end(), 1l,",
          "content_same": false
        },
        {
          "line": 2517,
          "old_api": "getInt64Ty",
          "new_api": "GetIrArrayFor",
          "old_text": "b_.getInt64Ty()",
          "new_text": "GetIrArrayFor(operand)",
          "old_line_content": "                                         b_.getInt64Ty());",
          "new_line_content": "    llvm_ir::IrArray source_array = GetIrArrayFor(operand);",
          "content_same": false
        },
        {
          "line": 2518,
          "old_api": "EmitArrayElementAddress",
          "new_api": "shape",
          "old_text": "BitCast(\n        source_array.EmitArrayElementAddress(source_index, &b_, \"src_addr\"),\n        i8_ptr_type)",
          "new_text": "operand->shape()",
          "old_line_content": "    llvm::Value* copy_source_address = BitCast(",
          "new_line_content": "    llvm_ir::IrArray::Index source_index(target_multi_index, operand->shape(),",
          "content_same": false
        },
        {
          "line": 2519,
          "old_api": "EmitArrayElementAddress",
          "new_api": "getInt64Ty",
          "old_text": "source_array.EmitArrayElementAddress(source_index, &b_, \"src_addr\")",
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "        source_array.EmitArrayElementAddress(source_index, &b_, \"src_addr\"),",
          "new_line_content": "                                         b_.getInt64Ty());",
          "content_same": false
        },
        {
          "line": 2525,
          "old_api": "dimensions",
          "new_api": "getInt64",
          "old_text": "EmitTransferElements(\n        copy_target_address, copy_source_address,\n        inner_dims_product * input_shape.dimensions(concat_dim), primitive_type,\n        target_array, source_array)",
          "new_text": "b_.getInt64(byte_offset_into_target_region)",
          "old_line_content": "    EmitTransferElements(",
          "new_line_content": "        GEP(target_region_begin, b_.getInt64(byte_offset_into_target_region));",
          "content_same": false
        },
        {
          "line": 2546,
          "old_api": "llvm_ir::AsStringRef(fmt)",
          "new_api": "getInt8Ty",
          "old_text": "llvm_ir::AsStringRef(fmt)",
          "new_text": "b_.getInt8Ty()->getPointerTo()",
          "old_line_content": "  call_args.push_back(b_.CreateGlobalStringPtr(llvm_ir::AsStringRef(fmt)));",
          "new_line_content": "  llvm::Type* ptr_ty = b_.getInt8Ty()->getPointerTo();",
          "content_same": false
        },
        {
          "line": 2548,
          "old_api": "CreateCall",
          "new_api": "llvm_ir::AsStringRef(fmt)",
          "old_text": "b_.CreateCall(\n      b_.GetInsertBlock()->getParent()->getParent()->getOrInsertFunction(\n          \"printf\", llvm::FunctionType::get(b_.getInt32Ty(), {ptr_ty},\n                                            /*isVarArg=*/true)),\n      call_args)",
          "new_text": "llvm_ir::AsStringRef(fmt)",
          "old_line_content": "  return b_.CreateCall(",
          "new_line_content": "  call_args.push_back(b_.CreateGlobalStringPtr(llvm_ir::AsStringRef(fmt)));",
          "content_same": false
        },
        {
          "line": 2549,
          "old_api": "GetInsertBlock",
          "new_api": "std::back_inserter(call_args)",
          "old_text": "b_.GetInsertBlock()->getParent()->getParent()->getOrInsertFunction(\n          \"printf\", llvm::FunctionType::get(b_.getInt32Ty(), {ptr_ty},\n                                            /*isVarArg=*/true))",
          "new_text": "std::back_inserter(call_args)",
          "old_line_content": "      b_.GetInsertBlock()->getParent()->getParent()->getOrInsertFunction(",
          "new_line_content": "  absl::c_copy(arguments, std::back_inserter(call_args));",
          "content_same": false
        },
        {
          "line": 2550,
          "old_api": "getInt32Ty",
          "new_api": "CreateCall",
          "old_text": "b_.getInt32Ty()",
          "new_text": "b_.CreateCall(\n      b_.GetInsertBlock()->getParent()->getParent()->getOrInsertFunction(\n          \"printf\", llvm::FunctionType::get(b_.getInt32Ty(), {ptr_ty},\n                                            /*isVarArg=*/true)),\n      call_args)",
          "old_line_content": "          \"printf\", llvm::FunctionType::get(b_.getInt32Ty(), {ptr_ty},",
          "new_line_content": "  return b_.CreateCall(",
          "content_same": false
        },
        {
          "line": 2559,
          "old_api": "llvm_ir::AsStringRef(fmt)",
          "new_api": "getInt8Ty",
          "old_text": "llvm_ir::AsStringRef(fmt)",
          "new_text": "b_.getInt8Ty()->getPointerTo()",
          "old_line_content": "  call_args.push_back(b_.CreateGlobalStringPtr(llvm_ir::AsStringRef(fmt)));",
          "new_line_content": "  llvm::Type* ptr_ty = b_.getInt8Ty()->getPointerTo();",
          "content_same": false
        },
        {
          "line": 2561,
          "old_api": "CreateCall",
          "new_api": "llvm_ir::AsStringRef(fmt)",
          "old_text": "b_.CreateCall(\n      b_.GetInsertBlock()->getParent()->getParent()->getOrInsertFunction(\n          runtime::kPrintfToStderrSymbolName,\n          llvm::FunctionType::get(b_.getInt32Ty(), {ptr_ty},\n                                  /*isVarArg=*/true)),\n      call_args)",
          "new_text": "llvm_ir::AsStringRef(fmt)",
          "old_line_content": "  return b_.CreateCall(",
          "new_line_content": "  call_args.push_back(b_.CreateGlobalStringPtr(llvm_ir::AsStringRef(fmt)));",
          "content_same": false
        },
        {
          "line": 2562,
          "old_api": "GetInsertBlock",
          "new_api": "std::back_inserter(call_args)",
          "old_text": "b_.GetInsertBlock()->getParent()->getParent()->getOrInsertFunction(\n          runtime::kPrintfToStderrSymbolName,\n          llvm::FunctionType::get(b_.getInt32Ty(), {ptr_ty},\n                                  /*isVarArg=*/true))",
          "new_text": "std::back_inserter(call_args)",
          "old_line_content": "      b_.GetInsertBlock()->getParent()->getParent()->getOrInsertFunction(",
          "new_line_content": "  absl::c_copy(arguments, std::back_inserter(call_args));",
          "content_same": false
        },
        {
          "line": 2564,
          "old_api": "getInt32Ty",
          "new_api": "GetInsertBlock",
          "old_text": "b_.getInt32Ty()",
          "new_text": "b_.GetInsertBlock()->getParent()->getParent()->getOrInsertFunction(\n          runtime::kPrintfToStderrSymbolName,\n          llvm::FunctionType::get(b_.getInt32Ty(), {ptr_ty},\n                                  /*isVarArg=*/true))",
          "old_line_content": "          llvm::FunctionType::get(b_.getInt32Ty(), {ptr_ty},",
          "new_line_content": "      b_.GetInsertBlock()->getParent()->getParent()->getOrInsertFunction(",
          "content_same": false
        },
        {
          "line": 2576,
          "old_api": "getType",
          "new_api": "size",
          "old_text": "val->getType()",
          "new_text": "arguments.size()",
          "old_line_content": "                    [&](llvm::Value* val) { return val->getType(); });",
          "new_line_content": "  types.reserve(arguments.size());",
          "content_same": false
        },
        {
          "line": 2578,
          "old_api": "llvm::FunctionType::get(return_type, types, /*isVarArg=*/false)",
          "new_api": "getType",
          "old_text": "llvm::FunctionType::get(return_type, types, /*isVarArg=*/false)",
          "new_text": "val->getType()",
          "old_line_content": "      llvm::FunctionType::get(return_type, types, /*isVarArg=*/false);",
          "new_line_content": "                    [&](llvm::Value* val) { return val->getType(); });",
          "content_same": false
        },
        {
          "line": 2580,
          "old_api": "getCallee",
          "new_api": "llvm::FunctionType::get(return_type, types, /*isVarArg=*/false)",
          "old_text": "module_->getOrInsertFunction(func_name, func_type).getCallee()",
          "new_text": "llvm::FunctionType::get(return_type, types, /*isVarArg=*/false)",
          "old_line_content": "      module_->getOrInsertFunction(func_name, func_type).getCallee());",
          "new_line_content": "      llvm::FunctionType::get(return_type, types, /*isVarArg=*/false);",
          "content_same": false
        },
        {
          "line": 2581,
          "old_api": "setCallingConv",
          "new_api": "getCallee",
          "old_text": "func->setCallingConv(llvm::CallingConv::C)",
          "new_text": "llvm::dyn_cast<llvm::Function>(\n      module_->getOrInsertFunction(func_name, func_type).getCallee())",
          "old_line_content": "  func->setCallingConv(llvm::CallingConv::C);",
          "new_line_content": "  auto func = llvm::dyn_cast<llvm::Function>(",
          "content_same": false
        },
        {
          "line": 2583,
          "old_api": "setDoesNotThrow",
          "new_api": "setCallingConv",
          "old_text": "func->setDoesNotThrow()",
          "new_text": "func->setCallingConv(llvm::CallingConv::C)",
          "old_line_content": "    func->setDoesNotThrow();",
          "new_line_content": "  func->setCallingConv(llvm::CallingConv::C);",
          "content_same": false
        },
        {
          "line": 2591,
          "old_api": "CreateCall",
          "new_api": "setOnlyAccessesInaccessibleMemOrArgMem",
          "old_text": "b_.CreateCall(func, arguments)",
          "new_text": "func->setOnlyAccessesInaccessibleMemOrArgMem()",
          "old_line_content": "  return b_.CreateCall(func, arguments);",
          "new_line_content": "    func->setOnlyAccessesInaccessibleMemOrArgMem();",
          "content_same": false
        },
        {
          "line": 2611,
          "old_api": "BitCast",
          "new_api": "AnnotateLoadStoreInstructionWithMetadata",
          "old_text": "BitCast(target, primitive_ptr_type)",
          "new_text": "source_array.AnnotateLoadStoreInstructionWithMetadata(load_instruction)",
          "old_line_content": "        AlignedStore(load_instruction, BitCast(target, primitive_ptr_type),",
          "new_line_content": "    source_array.AnnotateLoadStoreInstructionWithMetadata(load_instruction);",
          "content_same": false
        },
        {
          "line": 2613,
          "old_api": "AnnotateLoadStoreInstructionWithMetadata",
          "new_api": "BitCast",
          "old_text": "target_array.AnnotateLoadStoreInstructionWithMetadata(store_instruction)",
          "new_text": "BitCast(target, primitive_ptr_type)",
          "old_line_content": "    target_array.AnnotateLoadStoreInstructionWithMetadata(store_instruction);",
          "new_line_content": "        AlignedStore(load_instruction, BitCast(target, primitive_ptr_type),",
          "content_same": false
        },
        {
          "line": 2615,
          "old_api": "CreateMemCpy",
          "new_api": "AnnotateLoadStoreInstructionWithMetadata",
          "old_text": "b_.CreateMemCpy(\n        target, /*DstAlign=*/llvm::Align(element_alignment), source,\n        /*SrcAlign=*/llvm::Align(element_alignment),\n        element_count * primitive_type_size)",
          "new_text": "target_array.AnnotateLoadStoreInstructionWithMetadata(store_instruction)",
          "old_line_content": "    auto* memcpy_instruction = b_.CreateMemCpy(",
          "new_line_content": "    target_array.AnnotateLoadStoreInstructionWithMetadata(store_instruction);",
          "content_same": false
        },
        {
          "line": 2617,
          "old_api": "llvm::Align(element_alignment)",
          "new_api": "CreateMemCpy",
          "old_text": "llvm::Align(element_alignment)",
          "new_text": "b_.CreateMemCpy(\n        target, /*DstAlign=*/llvm::Align(element_alignment), source,\n        /*SrcAlign=*/llvm::Align(element_alignment),\n        element_count * primitive_type_size)",
          "old_line_content": "        /*SrcAlign=*/llvm::Align(element_alignment),",
          "new_line_content": "    auto* memcpy_instruction = b_.CreateMemCpy(",
          "content_same": false
        },
        {
          "line": 2626,
          "old_api": "setMetadata",
          "new_api": "metadata",
          "old_text": "memcpy_instruction->setMetadata(kind_md_pair.first, kind_md_pair.second)",
          "new_text": "target_array.metadata()",
          "old_line_content": "      memcpy_instruction->setMetadata(kind_md_pair.first, kind_md_pair.second);",
          "new_line_content": "                               target_array.metadata());",
          "content_same": false
        },
        {
          "line": 2651,
          "old_api": "shape",
          "new_api": "operand",
          "old_text": "branch_index->shape()",
          "new_text": "conditional->operand(0)",
          "old_line_content": "  TF_RET_CHECK(ShapeUtil::IsScalar(branch_index->shape()) &&",
          "new_line_content": "  auto branch_index = conditional->operand(0);",
          "content_same": false
        },
        {
          "line": 2652,
          "old_api": "element_type",
          "new_api": "branch_count",
          "old_text": "branch_index->shape().element_type()",
          "new_text": "conditional->branch_count()",
          "old_line_content": "               (branch_index->shape().element_type() == PRED ||",
          "new_line_content": "  int num_branches = conditional->branch_count();",
          "content_same": false
        },
        {
          "line": 2653,
          "old_api": "element_type",
          "new_api": "shape",
          "old_text": "branch_index->shape().element_type()",
          "new_text": "branch_index->shape()",
          "old_line_content": "                branch_index->shape().element_type() == S32))",
          "new_line_content": "  TF_RET_CHECK(ShapeUtil::IsScalar(branch_index->shape()) &&",
          "content_same": false
        },
        {
          "line": 2655,
          "old_api": "shape",
          "new_api": "element_type",
          "old_text": "branch_index->shape()",
          "new_text": "branch_index->shape().element_type()",
          "old_line_content": "      << ShapeUtil::HumanString(branch_index->shape());",
          "new_line_content": "                branch_index->shape().element_type() == S32))",
          "content_same": false
        },
        {
          "line": 2660,
          "old_api": "root_instruction",
          "new_api": "branch_computation",
          "old_text": "br_computation->root_instruction()->shape()",
          "new_text": "conditional->branch_computation(b)",
          "old_line_content": "                                  br_computation->root_instruction()->shape()))",
          "new_line_content": "    HloComputation* br_computation = conditional->branch_computation(b);",
          "content_same": false
        },
        {
          "line": 2669,
          "old_api": "element_type",
          "new_api": "EmitTargetAddressForOp",
          "old_text": "branch_index->shape().element_type()",
          "new_text": "EmitTargetAddressForOp(conditional)",
          "old_line_content": "  if (branch_index->shape().element_type() == PRED) {",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(conditional));",
          "content_same": false
        },
        {
          "line": 2678,
          "old_api": "ICmpNE",
          "new_api": "GetBasePointer",
          "old_text": "ICmpNE(pred_value,\n               llvm::ConstantInt::get(\n                   llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0),\n               \"boolean_predicate\")",
          "new_text": "GetIrArrayFor(branch_index).GetBasePointer()",
          "old_line_content": "        ICmpNE(pred_value,",
          "new_line_content": "        GetIrArrayFor(branch_index).GetBasePointer(), \"load_predicate_value\");",
          "content_same": false
        },
        {
          "line": 2680,
          "old_api": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "new_api": "ICmpNE",
          "old_text": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "new_text": "ICmpNE(pred_value,\n               llvm::ConstantInt::get(\n                   llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0),\n               \"boolean_predicate\")",
          "old_line_content": "                   llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0),",
          "new_line_content": "        ICmpNE(pred_value,",
          "content_same": false
        },
        {
          "line": 2685,
          "old_api": "SetToFirstInsertPoint",
          "new_api": "llvm_ir::EmitIfThenElse(pred_cond, \"conditional\", &b_)",
          "old_text": "SetToFirstInsertPoint(if_data.true_block, &b_)",
          "new_text": "llvm_ir::EmitIfThenElse(pred_cond, \"conditional\", &b_)",
          "old_line_content": "    SetToFirstInsertPoint(if_data.true_block, &b_);",
          "new_line_content": "        llvm_ir::EmitIfThenElse(pred_cond, \"conditional\", &b_);",
          "content_same": false
        },
        {
          "line": 2687,
          "old_api": "IrName",
          "new_api": "SetToFirstInsertPoint",
          "old_text": "IrName(conditional, \"_true\")",
          "new_text": "SetToFirstInsertPoint(if_data.true_block, &b_)",
          "old_line_content": "                   IrName(conditional, \"_true\"));",
          "new_line_content": "    SetToFirstInsertPoint(if_data.true_block, &b_);",
          "content_same": false
        },
        {
          "line": 2689,
          "old_api": "SetToFirstInsertPoint",
          "new_api": "IrName",
          "old_text": "SetToFirstInsertPoint(if_data.false_block, &b_)",
          "new_text": "IrName(conditional, \"_true\")",
          "old_line_content": "    SetToFirstInsertPoint(if_data.false_block, &b_);",
          "new_line_content": "                   IrName(conditional, \"_true\"));",
          "content_same": false
        },
        {
          "line": 2691,
          "old_api": "IrName",
          "new_api": "SetToFirstInsertPoint",
          "old_text": "IrName(conditional, \"_false\")",
          "new_text": "SetToFirstInsertPoint(if_data.false_block, &b_)",
          "old_line_content": "                   IrName(conditional, \"_false\"));",
          "new_line_content": "    SetToFirstInsertPoint(if_data.false_block, &b_);",
          "content_same": false
        },
        {
          "line": 2693,
          "old_api": "SetToFirstInsertPoint",
          "new_api": "IrName",
          "old_text": "SetToFirstInsertPoint(if_data.after_block, &b_)",
          "new_text": "IrName(conditional, \"_false\")",
          "old_line_content": "    SetToFirstInsertPoint(if_data.after_block, &b_);",
          "new_line_content": "                   IrName(conditional, \"_false\"));",
          "content_same": false
        },
        {
          "line": 2713,
          "old_api": "GetInsertBlock",
          "new_api": "GetBasePointer",
          "old_text": "b_.GetInsertBlock()",
          "new_text": "GetIrArrayFor(branch_index).GetBasePointer()",
          "old_line_content": "  auto case_block = b_.GetInsertBlock();",
          "new_line_content": "      GetIrArrayFor(branch_index).GetBasePointer(), \"load_branch_index_value\");",
          "content_same": false
        },
        {
          "line": 2718,
          "old_api": "SetInsertPoint",
          "new_api": "getTerminator",
          "old_text": "b_.SetInsertPoint(case_block)",
          "new_text": "case_block->getTerminator()",
          "old_line_content": "    b_.SetInsertPoint(case_block);",
          "new_line_content": "  if (case_block->getTerminator() == nullptr) {",
          "content_same": false
        },
        {
          "line": 2719,
          "old_api": "CreateBr",
          "new_api": "llvm_ir::CreateBasicBlock(nullptr, \"case-after\", &b_)",
          "old_text": "b_.CreateBr(after_block)",
          "new_text": "llvm_ir::CreateBasicBlock(nullptr, \"case-after\", &b_)",
          "old_line_content": "    b_.CreateBr(after_block);",
          "new_line_content": "    after_block = llvm_ir::CreateBasicBlock(nullptr, \"case-after\", &b_);",
          "content_same": false
        },
        {
          "line": 2731,
          "old_api": "branch_computation",
          "new_api": "llvm_ir::CreateBasicBlock(nullptr, \"case-default\", &b_)",
          "old_text": "conditional->branch_computation(num_branches - 1)",
          "new_text": "llvm_ir::CreateBasicBlock(nullptr, \"case-default\", &b_)",
          "old_line_content": "  EmitGlobalCall(*conditional->branch_computation(num_branches - 1),",
          "new_line_content": "  auto default_block = llvm_ir::CreateBasicBlock(nullptr, \"case-default\", &b_);",
          "content_same": false
        },
        {
          "line": 2732,
          "old_api": "IrName",
          "new_api": "SetInsertPoint",
          "old_text": "IrName(conditional, \"_default\")",
          "new_text": "b_.SetInsertPoint(default_block)",
          "old_line_content": "                 IrName(conditional, \"_default\"));",
          "new_line_content": "  b_.SetInsertPoint(default_block);",
          "content_same": false
        },
        {
          "line": 2733,
          "old_api": "CreateBr",
          "new_api": "branch_computation",
          "old_text": "b_.CreateBr(after_block)",
          "new_text": "conditional->branch_computation(num_branches - 1)",
          "old_line_content": "  b_.CreateBr(after_block);",
          "new_line_content": "  EmitGlobalCall(*conditional->branch_computation(num_branches - 1),",
          "content_same": false
        },
        {
          "line": 2738,
          "old_api": "CreateSwitch",
          "new_api": "SetInsertPoint",
          "old_text": "b_.CreateSwitch(branch_index_value, default_block, num_branches - 1)",
          "new_text": "b_.SetInsertPoint(case_block)",
          "old_line_content": "      b_.CreateSwitch(branch_index_value, default_block, num_branches - 1);",
          "new_line_content": "  b_.SetInsertPoint(case_block);",
          "content_same": false
        },
        {
          "line": 2745,
          "old_api": "branch_computation",
          "new_api": "absl::StrCat(\"case-branch\", b)",
          "old_text": "conditional->branch_computation(b)",
          "new_text": "absl::StrCat(\"case-branch\", b)",
          "old_line_content": "    EmitGlobalCall(*conditional->branch_computation(b),",
          "new_line_content": "        llvm_ir::CreateBasicBlock(nullptr, absl::StrCat(\"case-branch\", b), &b_);",
          "content_same": false
        },
        {
          "line": 2746,
          "old_api": "absl::StrCat(\"_branch\", b)",
          "new_api": "SetInsertPoint",
          "old_text": "absl::StrCat(\"_branch\", b)",
          "new_text": "b_.SetInsertPoint(branch_block)",
          "old_line_content": "                   IrName(conditional, absl::StrCat(\"_branch\", b)));",
          "new_line_content": "    b_.SetInsertPoint(branch_block);",
          "content_same": false
        },
        {
          "line": 2747,
          "old_api": "CreateBr",
          "new_api": "branch_computation",
          "old_text": "b_.CreateBr(after_block)",
          "new_text": "conditional->branch_computation(b)",
          "old_line_content": "    b_.CreateBr(after_block);",
          "new_line_content": "    EmitGlobalCall(*conditional->branch_computation(b),",
          "content_same": false
        },
        {
          "line": 2748,
          "old_api": "getInt32",
          "new_api": "absl::StrCat(\"_branch\", b)",
          "old_text": "b_.getInt32(b)",
          "new_text": "absl::StrCat(\"_branch\", b)",
          "old_line_content": "    case_inst->addCase(b_.getInt32(b), branch_block);",
          "new_line_content": "                   IrName(conditional, absl::StrCat(\"_branch\", b)));",
          "content_same": false
        },
        {
          "line": 2758,
          "old_api": "EmitTargetAddressForOp",
          "new_api": "shape",
          "old_text": "EmitTargetAddressForOp(after_all)",
          "new_text": "after_all->shape()",
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(after_all));",
          "new_line_content": "  TF_RET_CHECK(ByteSizeOf(after_all->shape()) == 0);",
          "content_same": false
        },
        {
          "line": 2776,
          "old_api": "delta",
          "new_api": "ToString",
          "old_text": "Cast<HloRngGetAndUpdateStateInstruction>(rng_state)->delta()",
          "new_text": "rng_state->ToString()",
          "old_line_content": "      Cast<HloRngGetAndUpdateStateInstruction>(rng_state)->delta(), module_,",
          "new_line_content": "  VLOG(2) << \"RngGetAndUpdateState: \" << rng_state->ToString();",
          "content_same": false
        },
        {
          "line": 2787,
          "old_api": "Store",
          "new_api": "getType",
          "old_text": "Store(old_state, address)",
          "new_text": "old_state->getType()->getScalarType()",
          "old_line_content": "  llvm::StoreInst* store = Store(old_state, address);",
          "new_line_content": "                                 old_state->getType()->getScalarType(),",
          "content_same": false
        },
        {
          "line": 2788,
          "old_api": "element_type",
          "new_api": "getType",
          "old_text": "IrEmitter::MinimumAlignmentForPrimitiveType(\n      rng_state->shape().element_type())",
          "new_text": "address->getType()->getPointerAddressSpace()",
          "old_line_content": "  store->setAlignment(llvm::Align(IrEmitter::MinimumAlignmentForPrimitiveType(",
          "new_line_content": "                                 address->getType()->getPointerAddressSpace()));",
          "content_same": false
        },
        {
          "line": 2789,
          "old_api": "element_type",
          "new_api": "Store",
          "old_text": "rng_state->shape().element_type()",
          "new_text": "Store(old_state, address)",
          "old_line_content": "      rng_state->shape().element_type())));",
          "new_line_content": "  llvm::StoreInst* store = Store(old_state, address);",
          "content_same": false
        },
        {
          "line": 2791,
          "old_api": "Status::OK()",
          "new_api": "element_type",
          "old_text": "Status::OK()",
          "new_text": "rng_state->shape().element_type()",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "      rng_state->shape().element_type())));",
          "content_same": false
        },
        {
          "line": 2803,
          "old_api": "VLOG",
          "new_api": "ToString",
          "old_text": "VLOG(2)",
          "new_text": "root->ToString()",
          "old_line_content": "    VLOG(2) << \"  outfeed with value: \"",
          "new_line_content": "  VLOG(2) << \"FinishVisit root: \" << root->ToString();",
          "content_same": false
        },
        {
          "line": 2804,
          "old_api": "operand",
          "new_api": "opcode",
          "old_text": "root->operand(0)",
          "new_text": "root->opcode()",
          "old_line_content": "            << llvm_ir::DumpToString(*GetEmittedValueFor(root->operand(0)));",
          "new_line_content": "  if (root->opcode() == HloOpcode::kOutfeed) {",
          "content_same": false
        },
        {
          "line": 2806,
          "old_api": "GetEmittedValueFor",
          "new_api": "operand",
          "old_text": "GetEmittedValueFor(root)",
          "new_text": "root->operand(0)",
          "old_line_content": "    VLOG(2) << \"  value: \" << llvm_ir::DumpToString(*GetEmittedValueFor(root));",
          "new_line_content": "            << llvm_ir::DumpToString(*GetEmittedValueFor(root->operand(0)));",
          "content_same": false
        },
        {
          "line": 2855,
          "old_api": "CreateLoad",
          "new_api": "CreateSub",
          "old_text": "b->CreateLoad(prof_counter, \"old_cycle_count\")",
          "new_text": "b->CreateSub(cycle_end, cycle_start)",
          "old_line_content": "      b->CreateLoad(prof_counter, \"old_cycle_count\");",
          "new_line_content": "  auto* cycle_diff = b->CreateSub(cycle_end, cycle_start);",
          "content_same": false
        },
        {
          "line": 2857,
          "old_api": "CreateAdd",
          "new_api": "CreateLoad",
          "old_text": "b->CreateAdd(cycle_diff, old_cycle_count, \"new_cycle_count\")",
          "new_text": "b->CreateLoad(prof_counter, \"old_cycle_count\")",
          "old_line_content": "      b->CreateAdd(cycle_diff, old_cycle_count, \"new_cycle_count\");",
          "new_line_content": "      b->CreateLoad(prof_counter, \"old_cycle_count\");",
          "content_same": false
        },
        {
          "line": 2867,
          "old_api": "CreateCall",
          "new_api": "llvm::Intrinsic::getDeclaration(module,\n                                        llvm::Intrinsic::readcyclecounter)",
          "old_text": "b->CreateCall(func_llvm_readcyclecounter)",
          "new_text": "llvm::Intrinsic::getDeclaration(module,\n                                        llvm::Intrinsic::readcyclecounter)",
          "old_line_content": "    return b->CreateCall(func_llvm_readcyclecounter);",
          "new_line_content": "        llvm::Intrinsic::getDeclaration(module,",
          "content_same": false
        },
        {
          "line": 2872,
          "old_api": "CreateExtractValue",
          "new_api": "llvm::Intrinsic::getDeclaration(module, llvm::Intrinsic::x86_rdtscp)",
          "old_text": "b->CreateExtractValue(rdtscp_call, {0})",
          "new_text": "llvm::Intrinsic::getDeclaration(module, llvm::Intrinsic::x86_rdtscp)",
          "old_line_content": "  return b->CreateExtractValue(rdtscp_call, {0});",
          "new_line_content": "      llvm::Intrinsic::getDeclaration(module, llvm::Intrinsic::x86_rdtscp);",
          "content_same": false
        },
        {
          "line": 2891,
          "old_api": "UpdateProfileCounter",
          "new_api": "IrName",
          "old_text": "UpdateProfileCounter(b, prof_counter, cycle_end, cycle_start)",
          "new_text": "IrName(hlo, \"cycle_end\")",
          "old_line_content": "  UpdateProfileCounter(b, prof_counter, cycle_end, cycle_start);",
          "new_line_content": "  cycle_end->setName(IrName(hlo, \"cycle_end\"));",
          "content_same": false
        },
        {
          "line": 2923,
          "old_api": "setCallingConv",
          "new_api": "getOrInsertFunction",
          "old_text": "fn->setCallingConv(llvm::CallingConv::C)",
          "new_text": "module->getOrInsertFunction(fn_name, fn_type)",
          "old_line_content": "    fn->setCallingConv(llvm::CallingConv::C);",
          "new_line_content": "      module->getOrInsertFunction(fn_name, fn_type);",
          "content_same": false
        },
        {
          "line": 2924,
          "old_api": "setDoesNotThrow",
          "new_api": "getCallee",
          "old_text": "fn->setDoesNotThrow()",
          "new_text": "trace_func.getCallee()",
          "old_line_content": "    fn->setDoesNotThrow();",
          "new_line_content": "  if (auto* fn = llvm::dyn_cast<llvm::Function>(trace_func.getCallee())) {",
          "content_same": false
        },
        {
          "line": 2925,
          "old_api": "setOnlyAccessesArgMemory",
          "new_api": "setCallingConv",
          "old_text": "fn->setOnlyAccessesArgMemory()",
          "new_text": "fn->setCallingConv(llvm::CallingConv::C)",
          "old_line_content": "    fn->setOnlyAccessesArgMemory();",
          "new_line_content": "    fn->setCallingConv(llvm::CallingConv::C);",
          "content_same": false
        },
        {
          "line": 2927,
          "old_api": "name",
          "new_api": "setOnlyAccessesArgMemory",
          "old_text": "hlo->name()",
          "new_text": "fn->setOnlyAccessesArgMemory()",
          "old_line_content": "  auto* hlo_name = b->CreateGlobalStringPtr(hlo->name());",
          "new_line_content": "    fn->setOnlyAccessesArgMemory();",
          "content_same": false
        },
        {
          "line": 2929,
          "old_api": "CreateBitCast",
          "new_api": "name",
          "old_text": "b->CreateBitCast(run_options, void_ptr_type)",
          "new_text": "hlo->name()",
          "old_line_content": "      b->CreateCall(trace_func, {b->CreateBitCast(run_options, void_ptr_type),",
          "new_line_content": "  auto* hlo_name = b->CreateGlobalStringPtr(hlo->name());",
          "content_same": false
        },
        {
          "line": 2931,
          "old_api": "IrName",
          "new_api": "CreateBitCast",
          "old_text": "IrName(hlo, \"activity_id\")",
          "new_text": "b->CreateBitCast(run_options, void_ptr_type)",
          "old_line_content": "  activity_id->setName(IrName(hlo, \"activity_id\"));",
          "new_line_content": "      b->CreateCall(trace_func, {b->CreateBitCast(run_options, void_ptr_type),",
          "content_same": false
        },
        {
          "line": 2955,
          "old_api": "setCallingConv",
          "new_api": "getOrInsertFunction",
          "old_text": "fn->setCallingConv(llvm::CallingConv::C)",
          "new_text": "module->getOrInsertFunction(fn_name, fn_type)",
          "old_line_content": "    fn->setCallingConv(llvm::CallingConv::C);",
          "new_line_content": "      module->getOrInsertFunction(fn_name, fn_type);",
          "content_same": false
        },
        {
          "line": 2956,
          "old_api": "setDoesNotThrow",
          "new_api": "getCallee",
          "old_text": "fn->setDoesNotThrow()",
          "new_text": "trace_func.getCallee()",
          "old_line_content": "    fn->setDoesNotThrow();",
          "new_line_content": "  if (auto* fn = llvm::dyn_cast<llvm::Function>(trace_func.getCallee())) {",
          "content_same": false
        },
        {
          "line": 2957,
          "old_api": "setOnlyAccessesArgMemory",
          "new_api": "setCallingConv",
          "old_text": "fn->setOnlyAccessesArgMemory()",
          "new_text": "fn->setCallingConv(llvm::CallingConv::C)",
          "old_line_content": "    fn->setOnlyAccessesArgMemory();",
          "new_line_content": "    fn->setCallingConv(llvm::CallingConv::C);",
          "content_same": false
        },
        {
          "line": 2959,
          "old_api": "at",
          "new_api": "setOnlyAccessesArgMemory",
          "old_text": "activity_ids_.at(hlo)",
          "new_text": "fn->setOnlyAccessesArgMemory()",
          "old_line_content": "  auto* activity_id = activity_ids_.at(hlo);",
          "new_line_content": "    fn->setOnlyAccessesArgMemory();",
          "content_same": false
        },
        {
          "line": 2961,
          "old_api": "CreateBitCast",
          "new_api": "at",
          "old_text": "b->CreateBitCast(run_options, void_ptr_type)",
          "new_text": "activity_ids_.at(hlo)",
          "old_line_content": "                {b->CreateBitCast(run_options, void_ptr_type), activity_id});",
          "new_line_content": "  auto* activity_id = activity_ids_.at(hlo);",
          "content_same": false
        },
        {
          "line": 2977,
          "old_api": "count",
          "new_api": "ToString",
          "old_text": "instruction_to_profile_idx_.count(hlo)",
          "new_text": "hlo->ToString()",
          "old_line_content": "  if (instruction_to_profile_idx_.count(hlo) ||",
          "new_line_content": "  VLOG(3) << \"Visiting: \" << hlo->ToString();",
          "content_same": false
        },
        {
          "line": 2979,
          "old_api": "EmitTracingStart",
          "new_api": "count",
          "old_text": "tracing_state_.EmitTracingStart(&b_, hlo,\n                                    GetExecutableRunOptionsArgument())",
          "new_text": "instruction_to_profile_idx_.count(hlo)",
          "old_line_content": "    tracing_state_.EmitTracingStart(&b_, hlo,",
          "new_line_content": "  if (instruction_to_profile_idx_.count(hlo) ||",
          "content_same": false
        },
        {
          "line": 2980,
          "old_api": "GetExecutableRunOptionsArgument",
          "new_api": "IsHloVeryCheap",
          "old_text": "GetExecutableRunOptionsArgument()",
          "new_text": "IsHloVeryCheap(hlo)",
          "old_line_content": "                                    GetExecutableRunOptionsArgument());",
          "new_line_content": "      (hlo_module_config_.cpu_traceme_enabled() && !IsHloVeryCheap(hlo))) {",
          "content_same": false
        },
        {
          "line": 2981,
          "old_api": "RecordCycleStart",
          "new_api": "EmitTracingStart",
          "old_text": "profiling_state_.RecordCycleStart(&b_, hlo)",
          "new_text": "tracing_state_.EmitTracingStart(&b_, hlo,\n                                    GetExecutableRunOptionsArgument())",
          "old_line_content": "    profiling_state_.RecordCycleStart(&b_, hlo);",
          "new_line_content": "    tracing_state_.EmitTracingStart(&b_, hlo,",
          "content_same": false
        },
        {
          "line": 2983,
          "old_api": "Status::OK()",
          "new_api": "RecordCycleStart",
          "old_text": "Status::OK()",
          "new_text": "profiling_state_.RecordCycleStart(&b_, hlo)",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "    profiling_state_.RecordCycleStart(&b_, hlo);",
          "content_same": false
        },
        {
          "line": 2993,
          "old_api": "GetExecutableRunOptionsArgument",
          "new_api": "count",
          "old_text": "GetExecutableRunOptionsArgument()",
          "new_text": "instruction_to_profile_idx_.count(hlo)",
          "old_line_content": "    tracing_state_.EmitTracingEnd(&b_, hlo, GetExecutableRunOptionsArgument());",
          "new_line_content": "  if (instruction_to_profile_idx_.count(hlo) ||",
          "content_same": false
        },
        {
          "line": 2995,
          "old_api": "Status::OK()",
          "new_api": "GetExecutableRunOptionsArgument",
          "old_text": "Status::OK()",
          "new_text": "GetExecutableRunOptionsArgument()",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "    tracing_state_.EmitTracingEnd(&b_, hlo, GetExecutableRunOptionsArgument());",
          "content_same": false
        },
        {
          "line": 3001,
          "old_api": "shape",
          "new_api": "GetEmittedValueFor",
          "old_text": "hlo->shape()",
          "new_text": "GetEmittedValueFor(hlo)",
          "old_line_content": "  llvm_ir::IrArray array(value_for_op, hlo->shape());",
          "new_line_content": "  llvm::Value* value_for_op = GetEmittedValueFor(hlo);",
          "content_same": false
        },
        {
          "line": 3011,
          "old_api": "std::back_inserter(arrays)",
          "new_api": "begin",
          "old_text": "std::back_inserter(arrays)",
          "new_text": "std::transform(\n      hlo->operands().begin(), hlo->operands().end(),\n      std::back_inserter(arrays),\n      [&](const HloInstruction* operand) { return GetIrArrayFor(operand); })",
          "old_line_content": "      std::back_inserter(arrays),",
          "new_line_content": "  std::transform(",
          "content_same": false
        },
        {
          "line": 3012,
          "old_api": "GetIrArrayFor",
          "new_api": "end",
          "old_text": "GetIrArrayFor(operand)",
          "new_text": "hlo->operands().end()",
          "old_line_content": "      [&](const HloInstruction* operand) { return GetIrArrayFor(operand); });",
          "new_line_content": "      hlo->operands().begin(), hlo->operands().end(),",
          "content_same": false
        },
        {
          "line": 3019,
          "old_api": "ToString",
          "new_api": "find",
          "old_text": "hlo->ToString()",
          "new_text": "emitted_value_.find(hlo)",
          "old_line_content": "    LOG(FATAL) << \"could not find emitted value for: \" << hlo->ToString();",
          "new_line_content": "  auto it = emitted_value_.find(hlo);",
          "content_same": false
        },
        {
          "line": 3045,
          "old_api": "allocation",
          "new_api": "find",
          "old_text": "slice.allocation()->index()",
          "new_text": "() -> llvm::Value* {\n    auto param_it =\n        computation_parameter_allocations_.find(slice.allocation()->index());\n    if (param_it != computation_parameter_allocations_.end()) {\n      int64 param_number = param_it->second;\n      // We have to access the parameter at offset param_number in the params\n      // array. The code generated here is equivalent to this C code:\n      //\n      //   i8* param_address_untyped = params[param_number];\n      //   Param* param_address_typed = (Param*)param_address_untyped;\n      //\n      // Where Param is the actual element type of the underlying buffer (for\n      // example, float for an XLA F32 element type).\n      llvm::Value* params = compute_function_->parameters_arg();\n      llvm::Value* param_address_offset =\n          llvm_ir::EmitBufferIndexingGEP(params, param_number, &b_);\n      llvm::LoadInst* param_address_untyped = Load(param_address_offset);\n\n      if (!target_shape.IsOpaque()) {\n        AttachAlignmentMetadataForLoad(param_address_untyped, target_shape);\n        AttachDereferenceableMetadataForLoad(param_address_untyped,\n                                             target_shape);\n      }\n      return param_address_untyped;\n    }\n\n    // Thread-local allocations should only be assigned a single buffer.\n    const auto& assigned_buffers = allocation.assigned_buffers();\n    CHECK_EQ(1, assigned_buffers.size());\n    const Shape& shape = assigned_buffers.begin()->first->shape();\n\n    std::pair<llvm::Function*, BufferAllocation::Slice> key = {\n        compute_function_->function(), slice};\n    auto buf_it = thread_local_buffers_.find(key);\n    if (buf_it == thread_local_buffers_.end()) {\n      llvm::Value* buffer = llvm_ir::EmitAllocaAtFunctionEntry(\n          IrShapeType(shape), absl::StrCat(\"thread_local\", slice.ToString()),\n          &b_, MinimumAlignmentForShape(target_shape));\n      auto it_inserted_pair = thread_local_buffers_.insert({key, buffer});\n      CHECK(it_inserted_pair.second);\n      buf_it = it_inserted_pair.first;\n    }\n    return buf_it->second;\n  }()",
          "old_line_content": "        computation_parameter_allocations_.find(slice.allocation()->index());",
          "new_line_content": "  llvm::Value* tempbuf_address = [&]() -> llvm::Value* {",
          "content_same": false
        },
        {
          "line": 3058,
          "old_api": "llvm_ir::EmitBufferIndexingGEP(params, param_number, &b_)",
          "new_api": "parameters_arg",
          "old_text": "llvm_ir::EmitBufferIndexingGEP(params, param_number, &b_)",
          "new_text": "compute_function_->parameters_arg()",
          "old_line_content": "          llvm_ir::EmitBufferIndexingGEP(params, param_number, &b_);",
          "new_line_content": "      llvm::Value* params = compute_function_->parameters_arg();",
          "content_same": false
        },
        {
          "line": 3061,
          "old_api": "IsOpaque",
          "new_api": "Load",
          "old_text": "target_shape.IsOpaque()",
          "new_text": "Load(param_address_offset)",
          "old_line_content": "      if (!target_shape.IsOpaque()) {",
          "new_line_content": "      llvm::LoadInst* param_address_untyped = Load(param_address_offset);",
          "content_same": false
        },
        {
          "line": 3063,
          "old_api": "AttachDereferenceableMetadataForLoad",
          "new_api": "IsOpaque",
          "old_text": "AttachDereferenceableMetadataForLoad(param_address_untyped,\n                                             target_shape)",
          "new_text": "target_shape.IsOpaque()",
          "old_line_content": "        AttachDereferenceableMetadataForLoad(param_address_untyped,",
          "new_line_content": "      if (!target_shape.IsOpaque()) {",
          "content_same": false
        },
        {
          "line": 3072,
          "old_api": "begin",
          "new_api": "assigned_buffers",
          "old_text": "assigned_buffers.begin()->first->shape()",
          "new_text": "allocation.assigned_buffers()",
          "old_line_content": "    const Shape& shape = assigned_buffers.begin()->first->shape();",
          "new_line_content": "    const auto& assigned_buffers = allocation.assigned_buffers();",
          "content_same": false
        },
        {
          "line": 3077,
          "old_api": "end",
          "new_api": "function",
          "old_text": "thread_local_buffers_.end()",
          "new_text": "compute_function_->function()",
          "old_line_content": "    if (buf_it == thread_local_buffers_.end()) {",
          "new_line_content": "        compute_function_->function(), slice};",
          "content_same": false
        },
        {
          "line": 3078,
          "old_api": "ToString",
          "new_api": "find",
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n          IrShapeType(shape), absl::StrCat(\"thread_local\", slice.ToString()),\n          &b_, MinimumAlignmentForShape(target_shape))",
          "new_text": "thread_local_buffers_.find(key)",
          "old_line_content": "      llvm::Value* buffer = llvm_ir::EmitAllocaAtFunctionEntry(",
          "new_line_content": "    auto buf_it = thread_local_buffers_.find(key);",
          "content_same": false
        },
        {
          "line": 3079,
          "old_api": "ToString",
          "new_api": "end",
          "old_text": "slice.ToString()",
          "new_text": "thread_local_buffers_.end()",
          "old_line_content": "          IrShapeType(shape), absl::StrCat(\"thread_local\", slice.ToString()),",
          "new_line_content": "    if (buf_it == thread_local_buffers_.end()) {",
          "content_same": false
        },
        {
          "line": 3080,
          "old_api": "MinimumAlignmentForShape",
          "new_api": "ToString",
          "old_text": "MinimumAlignmentForShape(target_shape)",
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n          IrShapeType(shape), absl::StrCat(\"thread_local\", slice.ToString()),\n          &b_, MinimumAlignmentForShape(target_shape))",
          "old_line_content": "          &b_, MinimumAlignmentForShape(target_shape));",
          "new_line_content": "      llvm::Value* buffer = llvm_ir::EmitAllocaAtFunctionEntry(",
          "content_same": false
        },
        {
          "line": 3081,
          "old_api": "insert",
          "new_api": "ToString",
          "old_text": "thread_local_buffers_.insert({key, buffer})",
          "new_text": "slice.ToString()",
          "old_line_content": "      auto it_inserted_pair = thread_local_buffers_.insert({key, buffer});",
          "new_line_content": "          IrShapeType(shape), absl::StrCat(\"thread_local\", slice.ToString()),",
          "content_same": false
        },
        {
          "line": 3082,
          "old_api": "CHECK",
          "new_api": "MinimumAlignmentForShape",
          "old_text": "CHECK(it_inserted_pair.second)",
          "new_text": "MinimumAlignmentForShape(target_shape)",
          "old_line_content": "      CHECK(it_inserted_pair.second);",
          "new_line_content": "          &b_, MinimumAlignmentForShape(target_shape));",
          "content_same": false
        },
        {
          "line": 3094,
          "old_api": "index",
          "new_api": "allocation",
          "old_text": "slice.index()",
          "new_text": "slice.allocation()",
          "old_line_content": "      GetBufferTableArgument(), slice.index(), &b_);",
          "new_line_content": "  const BufferAllocation& allocation = *slice.allocation();",
          "content_same": false
        },
        {
          "line": 3095,
          "old_api": "Load",
          "new_api": "index",
          "old_text": "Load(tempbuf_address_ptr)",
          "new_text": "llvm_ir::EmitBufferIndexingGEP(\n      GetBufferTableArgument(), slice.index(), &b_)",
          "old_line_content": "  llvm::LoadInst* tempbuf_address_base = Load(tempbuf_address_ptr);",
          "new_line_content": "  llvm::Value* tempbuf_address_ptr = llvm_ir::EmitBufferIndexingGEP(",
          "content_same": false
        },
        {
          "line": 3096,
          "old_api": "debug_options",
          "new_api": "index",
          "old_text": "hlo_module_config_.debug_options()\n          .xla_llvm_enable_invariant_load_metadata()",
          "new_text": "slice.index()",
          "old_line_content": "  if (hlo_module_config_.debug_options()",
          "new_line_content": "      GetBufferTableArgument(), slice.index(), &b_);",
          "content_same": false
        },
        {
          "line": 3098,
          "old_api": "setMetadata",
          "new_api": "debug_options",
          "old_text": "tempbuf_address_base->setMetadata(\n        llvm::LLVMContext::MD_invariant_load,\n        llvm::MDNode::get(tempbuf_address_base->getContext(), /*MDs=*/{}))",
          "new_text": "hlo_module_config_.debug_options()\n          .xla_llvm_enable_invariant_load_metadata()",
          "old_line_content": "    tempbuf_address_base->setMetadata(",
          "new_line_content": "  if (hlo_module_config_.debug_options()",
          "content_same": false
        },
        {
          "line": 3100,
          "old_api": "getContext",
          "new_api": "setMetadata",
          "old_text": "tempbuf_address_base->getContext()",
          "new_text": "tempbuf_address_base->setMetadata(\n        llvm::LLVMContext::MD_invariant_load,\n        llvm::MDNode::get(tempbuf_address_base->getContext(), /*MDs=*/{}))",
          "old_line_content": "        llvm::MDNode::get(tempbuf_address_base->getContext(), /*MDs=*/{}));",
          "new_line_content": "    tempbuf_address_base->setMetadata(",
          "content_same": false
        },
        {
          "line": 3102,
          "old_api": "size",
          "new_api": "getContext",
          "old_text": "allocation.size()",
          "new_text": "tempbuf_address_base->getContext()",
          "old_line_content": "  AttachAlignmentMetadataForLoad(tempbuf_address_base, allocation.size());",
          "new_line_content": "        llvm::MDNode::get(tempbuf_address_base->getContext(), /*MDs=*/{}));",
          "content_same": false
        },
        {
          "line": 3111,
          "old_api": "getPointerTo",
          "new_api": "offset",
          "old_text": "BitCast(tempbuf_address_untyped,\n                 IrShapeType(target_shape)->getPointerTo())",
          "new_text": "slice.offset()",
          "old_line_content": "  return BitCast(tempbuf_address_untyped,",
          "new_line_content": "        InBoundsGEP(tempbuf_address_base, b_.getInt64(slice.offset()));",
          "content_same": false
        },
        {
          "line": 3120,
          "old_api": "allocation",
          "new_api": "EmitThreadLocalBufferPointer",
          "old_text": "BitCast(\n        FindOrDie(constant_buffer_to_global_, slice.allocation()->index()),\n        IrShapeType(target_shape)->getPointerTo())",
          "new_text": "EmitThreadLocalBufferPointer(slice, target_shape)",
          "old_line_content": "    return BitCast(",
          "new_line_content": "    return EmitThreadLocalBufferPointer(slice, target_shape);",
          "content_same": false
        },
        {
          "line": 3122,
          "old_api": "getPointerTo",
          "new_api": "allocation",
          "old_text": "IrShapeType(target_shape)->getPointerTo()",
          "new_text": "BitCast(\n        FindOrDie(constant_buffer_to_global_, slice.allocation()->index()),\n        IrShapeType(target_shape)->getPointerTo())",
          "old_line_content": "        IrShapeType(target_shape)->getPointerTo());",
          "new_line_content": "    return BitCast(",
          "content_same": false
        },
        {
          "line": 3124,
          "old_api": "EmitGlobalBufferPointer",
          "new_api": "getPointerTo",
          "old_text": "EmitGlobalBufferPointer(slice, target_shape)",
          "new_text": "IrShapeType(target_shape)->getPointerTo()",
          "old_line_content": "    return EmitGlobalBufferPointer(slice, target_shape);",
          "new_line_content": "        IrShapeType(target_shape)->getPointerTo());",
          "content_same": false
        },
        {
          "line": 3135,
          "old_api": "Status::OK()",
          "new_api": "IrName",
          "old_text": "Status::OK()",
          "new_text": "IrName(op)",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  addr->setName(IrName(op));",
          "content_same": false
        },
        {
          "line": 3149,
          "old_api": "shape",
          "new_api": "ToString",
          "old_text": "target_op->shape()",
          "new_text": "target_op->ToString()",
          "old_line_content": "  const Shape& target_shape = target_op->shape();",
          "new_line_content": "  VLOG(2) << \"EmitTargetElementLoop: \" << target_op->ToString();",
          "content_same": false
        },
        {
          "line": 3151,
          "old_api": "GetIrArrayFor",
          "new_api": "shape",
          "old_text": "GetIrArrayFor(target_op)",
          "new_text": "target_op->shape()",
          "old_line_content": "  llvm_ir::IrArray target_array = GetIrArrayFor(target_op);",
          "new_line_content": "  const Shape& target_shape = target_op->shape();",
          "content_same": false
        },
        {
          "line": 3153,
          "old_api": "IsTuple",
          "new_api": "GetIrArrayFor",
          "old_text": "target_shape.IsTuple()",
          "new_text": "GetIrArrayFor(target_op)",
          "old_line_content": "  if (target_shape.IsTuple() &&",
          "new_line_content": "  llvm_ir::IrArray target_array = GetIrArrayFor(target_op);",
          "content_same": false
        },
        {
          "line": 3155,
          "old_api": "opcode",
          "new_api": "IsTuple",
          "old_text": "target_op->opcode()",
          "new_text": "target_shape.IsTuple()",
          "old_line_content": "       target_op->opcode() == HloOpcode::kReduce ||",
          "new_line_content": "  if (target_shape.IsTuple() &&",
          "content_same": false
        },
        {
          "line": 3158,
          "old_api": "TF_RET_CHECK",
          "new_api": "opcode",
          "old_text": "TF_RET_CHECK(num_dynamic_loop_bounds_ == 0)",
          "new_text": "target_op->opcode()",
          "old_line_content": "    TF_RET_CHECK(num_dynamic_loop_bounds_ == 0);",
          "new_line_content": "       target_op->opcode() == HloOpcode::kReduceWindow)) {",
          "content_same": false
        },
        {
          "line": 3160,
          "old_api": "ShapeUtil::TupleElementCount(target_shape)",
          "new_api": "TF_RET_CHECK",
          "old_text": "ShapeUtil::TupleElementCount(target_shape)",
          "new_text": "TF_RET_CHECK(num_dynamic_loop_bounds_ == 0)",
          "old_line_content": "    for (int64 i = 0; i < ShapeUtil::TupleElementCount(target_shape); ++i) {",
          "new_line_content": "    TF_RET_CHECK(num_dynamic_loop_bounds_ == 0);",
          "content_same": false
        },
        {
          "line": 3165,
          "old_api": "push_back",
          "new_api": "ShapeUtil::GetSubshape(target_shape, {i})",
          "old_text": "output_arrays.push_back(\n          llvm_ir::IrArray(op_target_address, element_shape))",
          "new_text": "ShapeUtil::GetSubshape(target_shape, {i})",
          "old_line_content": "      output_arrays.push_back(",
          "new_line_content": "      const Shape& element_shape = ShapeUtil::GetSubshape(target_shape, {i});",
          "content_same": false
        },
        {
          "line": 3166,
          "old_api": "llvm_ir::IrArray(op_target_address, element_shape)",
          "new_api": "EmitBufferPointer",
          "old_text": "llvm_ir::IrArray(op_target_address, element_shape)",
          "new_text": "EmitBufferPointer(slice, element_shape)",
          "old_line_content": "          llvm_ir::IrArray(op_target_address, element_shape));",
          "new_line_content": "      llvm::Value* op_target_address = EmitBufferPointer(slice, element_shape);",
          "content_same": false
        },
        {
          "line": 3168,
          "old_api": "EmitLoop",
          "new_api": "llvm_ir::IrArray(op_target_address, element_shape)",
          "old_text": "TF_RETURN_IF_ERROR(\n        llvm_ir::LoopEmitter(element_generator, output_arrays, &b_)\n            .EmitLoop(IrName(target_op)))",
          "new_text": "llvm_ir::IrArray(op_target_address, element_shape)",
          "old_line_content": "    TF_RETURN_IF_ERROR(",
          "new_line_content": "          llvm_ir::IrArray(op_target_address, element_shape));",
          "content_same": false
        },
        {
          "line": 3170,
          "old_api": "IrName",
          "new_api": "EmitLoop",
          "old_text": "IrName(target_op)",
          "new_text": "TF_RETURN_IF_ERROR(\n        llvm_ir::LoopEmitter(element_generator, output_arrays, &b_)\n            .EmitLoop(IrName(target_op)))",
          "old_line_content": "            .EmitLoop(IrName(target_op)));",
          "new_line_content": "    TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 3176,
          "old_api": "llvm_ir::EmitTuple(target_array, tuple_operand_ptrs, &b_)",
          "new_api": "GetBasePointer",
          "old_text": "llvm_ir::EmitTuple(target_array, tuple_operand_ptrs, &b_)",
          "new_text": "output_arrays[i].GetBasePointer()",
          "old_line_content": "    llvm_ir::EmitTuple(target_array, tuple_operand_ptrs, &b_);",
          "new_line_content": "      tuple_operand_ptrs.push_back(output_arrays[i].GetBasePointer());",
          "content_same": false
        },
        {
          "line": 3184,
          "old_api": "EmitLoop",
          "new_api": "GetDynamicLoopBounds",
          "old_text": "ParallelLoopEmitter(element_generator, target_array,\n                                             &dynamic_loop_bounds, &b_)\n                             .EmitLoop(IrName(target_op))",
          "new_text": "compute_function_->GetDynamicLoopBounds()",
          "old_line_content": "      TF_RETURN_IF_ERROR(ParallelLoopEmitter(element_generator, target_array,",
          "new_line_content": "          compute_function_->GetDynamicLoopBounds();",
          "content_same": false
        },
        {
          "line": 3186,
          "old_api": "IrName",
          "new_api": "EmitLoop",
          "old_text": "IrName(target_op)",
          "new_text": "ParallelLoopEmitter(element_generator, target_array,\n                                             &dynamic_loop_bounds, &b_)\n                             .EmitLoop(IrName(target_op))",
          "old_line_content": "                             .EmitLoop(IrName(target_op)));",
          "new_line_content": "      TF_RETURN_IF_ERROR(ParallelLoopEmitter(element_generator, target_array,",
          "content_same": false
        },
        {
          "line": 3188,
          "old_api": "EmitLoop",
          "new_api": "IrName",
          "old_text": "TF_RETURN_IF_ERROR(\n          llvm_ir::LoopEmitter(element_generator, target_array, &b_)\n              .EmitLoop(IrName(target_op)))",
          "new_text": "IrName(target_op)",
          "old_line_content": "      TF_RETURN_IF_ERROR(",
          "new_line_content": "                             .EmitLoop(IrName(target_op)));",
          "content_same": false
        },
        {
          "line": 3190,
          "old_api": "IrName",
          "new_api": "EmitLoop",
          "old_text": "IrName(target_op)",
          "new_text": "TF_RETURN_IF_ERROR(\n          llvm_ir::LoopEmitter(element_generator, target_array, &b_)\n              .EmitLoop(IrName(target_op)))",
          "old_line_content": "              .EmitLoop(IrName(target_op)));",
          "new_line_content": "      TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 3200,
          "old_api": "shape",
          "new_api": "GetEmittedValueFor",
          "old_text": "source.shape()",
          "new_text": "GetEmittedValueFor(&source)",
          "old_line_content": "  int64 source_size = ByteSizeOf(source.shape());",
          "new_line_content": "  llvm::Value* source_value = GetEmittedValueFor(&source);",
          "content_same": false
        },
        {
          "line": 3202,
          "old_api": "llvm::Align(1)",
          "new_api": "shape",
          "old_text": "llvm::Align(1)",
          "new_text": "source.shape()",
          "old_line_content": "  MemCpy(destination_value, /*DstAlign=*/llvm::Align(1), source_value,",
          "new_line_content": "  int64 source_size = ByteSizeOf(source.shape());",
          "content_same": false
        },
        {
          "line": 3204,
          "old_api": "Status::OK()",
          "new_api": "llvm::Align(1)",
          "old_text": "Status::OK()",
          "new_text": "llvm::Align(1)",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  MemCpy(destination_value, /*DstAlign=*/llvm::Align(1), source_value,",
          "content_same": false
        },
        {
          "line": 3218,
          "old_api": "absl::c_linear_search(supported_types, primitive_type)",
          "new_api": "empty",
          "old_text": "absl::c_linear_search(supported_types, primitive_type)",
          "new_text": "operands.empty()",
          "old_line_content": "  if (!absl::c_linear_search(supported_types, primitive_type)) {",
          "new_line_content": "  TF_RET_CHECK(!operands.empty());",
          "content_same": false
        },
        {
          "line": 3219,
          "old_api": "opcode",
          "new_api": "element_type",
          "old_text": "Unimplemented(\"unsupported operand type %s in op %s\",\n                         PrimitiveType_Name(primitive_type),\n                         HloOpcodeString(instruction.opcode()))",
          "new_text": "operands[0]->shape().element_type()",
          "old_line_content": "    return Unimplemented(\"unsupported operand type %s in op %s\",",
          "new_line_content": "  PrimitiveType primitive_type = operands[0]->shape().element_type();",
          "content_same": false
        },
        {
          "line": 3220,
          "old_api": "PrimitiveType_Name",
          "new_api": "absl::c_linear_search(supported_types, primitive_type)",
          "old_text": "PrimitiveType_Name(primitive_type)",
          "new_text": "absl::c_linear_search(supported_types, primitive_type)",
          "old_line_content": "                         PrimitiveType_Name(primitive_type),",
          "new_line_content": "  if (!absl::c_linear_search(supported_types, primitive_type)) {",
          "content_same": false
        },
        {
          "line": 3223,
          "old_api": "Status::OK()",
          "new_api": "opcode",
          "old_text": "Status::OK()",
          "new_text": "instruction.opcode()",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "                         HloOpcodeString(instruction.opcode()));",
          "content_same": false
        },
        {
          "line": 3230,
          "old_api": "EmitReadArrayElement",
          "new_api": "operands",
          "old_text": "GetIrArrayFor(operand).EmitReadArrayElement(index, &b_)",
          "new_text": "hlo->operands()",
          "old_line_content": "      return GetIrArrayFor(operand).EmitReadArrayElement(index, &b_);",
          "new_line_content": "  for (const HloInstruction* operand : hlo->operands()) {",
          "content_same": false
        },
        {
          "line": 3252,
          "old_api": "ShapeUtil::IsScalar(return_shape)",
          "new_api": "absl::c_binary_search(thread_local_computations_, &callee)",
          "old_text": "ShapeUtil::IsScalar(return_shape)",
          "new_text": "absl::c_binary_search(thread_local_computations_, &callee)",
          "old_line_content": "  bool is_scalar_return = ShapeUtil::IsScalar(return_shape);",
          "new_line_content": "  CHECK(absl::c_binary_search(thread_local_computations_, &callee));",
          "content_same": false
        },
        {
          "line": 3254,
          "old_api": "IsTuple",
          "new_api": "ShapeUtil::IsScalar(return_shape)",
          "old_text": "return_shape.IsTuple()",
          "new_text": "ShapeUtil::IsScalar(return_shape)",
          "old_line_content": "      return_shape.IsTuple() &&",
          "new_line_content": "  bool is_scalar_return = ShapeUtil::IsScalar(return_shape);",
          "content_same": false
        },
        {
          "line": 3256,
          "old_api": "ShapeUtil::IsScalar(shape)",
          "new_api": "IsTuple",
          "old_text": "ShapeUtil::IsScalar(shape)",
          "new_text": "return_shape.IsTuple()",
          "old_line_content": "        return ShapeUtil::IsScalar(shape);",
          "new_line_content": "      return_shape.IsTuple() &&",
          "content_same": false
        },
        {
          "line": 3258,
          "old_api": "CHECK",
          "new_api": "ShapeUtil::IsScalar(shape)",
          "old_text": "CHECK(is_scalar_return || is_tuple_of_scalars_return)",
          "new_text": "ShapeUtil::IsScalar(shape)",
          "old_line_content": "  CHECK(is_scalar_return || is_tuple_of_scalars_return);",
          "new_line_content": "        return ShapeUtil::IsScalar(shape);",
          "content_same": false
        },
        {
          "line": 3265,
          "old_api": "Store",
          "new_api": "getType",
          "old_text": "Store(parameter, parameter_addr)",
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n        parameter->getType(), \"arg_addr\", &b_)",
          "old_line_content": "    Store(parameter, parameter_addr);",
          "new_line_content": "    llvm::Value* parameter_addr = llvm_ir::EmitAllocaAtFunctionEntry(",
          "content_same": false
        },
        {
          "line": 3266,
          "old_api": "push_back",
          "new_api": "getType",
          "old_text": "parameter_addrs.push_back(parameter_addr)",
          "new_text": "parameter->getType()",
          "old_line_content": "    parameter_addrs.push_back(parameter_addr);",
          "new_line_content": "        parameter->getType(), \"arg_addr\", &b_);",
          "content_same": false
        },
        {
          "line": 3276,
          "old_api": "llvm_ir::EmitAllocaAtFunctionEntry(\n      return_value_buffer_type, retval_alloca_name, &b_, retval_alignment)",
          "new_api": "element_type",
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n      return_value_buffer_type, retval_alloca_name, &b_, retval_alignment)",
          "new_text": "return_shape.element_type()",
          "old_line_content": "  llvm::Value* return_value_buffer = llvm_ir::EmitAllocaAtFunctionEntry(",
          "new_line_content": "          ? MinimumAlignmentForPrimitiveType(return_shape.element_type())",
          "content_same": false
        },
        {
          "line": 3283,
          "old_api": "constexpr",
          "new_api": "push_back",
          "old_text": "constexpr",
          "new_text": "allocas_for_returned_scalars.push_back(return_value_buffer)",
          "old_line_content": "    constexpr int max_tuple_size = 1000;",
          "new_line_content": "    allocas_for_returned_scalars.push_back(return_value_buffer);",
          "content_same": false
        },
        {
          "line": 3300,
          "old_api": "getInt8PtrTy",
          "new_api": "GetExecutableRunOptionsArgument",
          "old_text": "b_.getInt8PtrTy()->getPointerTo()",
          "new_text": "GetExecutableRunOptionsArgument()",
          "old_line_content": "           llvm::Constant::getNullValue(b_.getInt8PtrTy()->getPointerTo()),",
          "new_line_content": "           /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),",
          "content_same": false
        },
        {
          "line": 3306,
          "old_api": "Load",
          "new_api": "size",
          "old_text": "Load(addr)",
          "new_text": "allocas_for_returned_scalars.size()",
          "old_line_content": "    returned_scalars.push_back(Load(addr));",
          "new_line_content": "  returned_scalars.reserve(allocas_for_returned_scalars.size());",
          "content_same": false
        },
        {
          "line": 3315,
          "old_api": "FindOrDie",
          "new_api": "absl::c_binary_search(global_computations_, &callee)",
          "old_text": "FindOrDie(emitted_functions_, &callee)",
          "new_text": "absl::c_binary_search(global_computations_, &callee)",
          "old_line_content": "  Call(FindOrDie(emitted_functions_, &callee),",
          "new_line_content": "  CHECK(absl::c_binary_search(global_computations_, &callee));",
          "content_same": false
        },
        {
          "line": 3321,
          "old_api": "GetBufferTableArgument",
          "new_api": "getInt8PtrTy",
          "old_text": "GetBufferTableArgument()",
          "new_text": "b_.getInt8PtrTy()",
          "old_line_content": "           /*buffer_table_arg=*/GetBufferTableArgument(),",
          "new_line_content": "           llvm::Constant::getNullValue(b_.getInt8PtrTy()),",
          "content_same": false
        },
        {
          "line": 3322,
          "old_api": "GetProfileCountersArgument",
          "new_api": "GetExecutableRunOptionsArgument",
          "old_text": "GetProfileCountersArgument()",
          "new_text": "GetExecutableRunOptionsArgument()",
          "old_line_content": "           /*profile_counters_arg=*/GetProfileCountersArgument()));",
          "new_line_content": "           /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),",
          "content_same": false
        },
        {
          "line": 3329,
          "old_api": "getInt8PtrTy",
          "new_api": "root_instruction",
          "old_text": "b_.getInt8PtrTy()",
          "new_text": "callee.root_instruction()",
          "old_line_content": "    return llvm::Constant::getNullValue(b_.getInt8PtrTy());",
          "new_line_content": "  const HloInstruction* root_inst = callee.root_instruction();",
          "content_same": false
        },
        {
          "line": 3341,
          "old_api": "EmitReadArrayElement",
          "new_api": "operand_count",
          "old_text": "fused_emitter->BindGenerator(\n        fusion->fused_parameter(i),\n        [this, operand](llvm_ir::IrArray::Index index) {\n          return GetIrArrayFor(operand).EmitReadArrayElement(index, &b_);\n        })",
          "new_text": "fusion->operand_count()",
          "old_line_content": "    fused_emitter->BindGenerator(",
          "new_line_content": "  for (int i = 0; i < fusion->operand_count(); i++) {",
          "content_same": false
        },
        {
          "line": 3342,
          "old_api": "fused_parameter",
          "new_api": "operand",
          "old_text": "fusion->fused_parameter(i)",
          "new_text": "fusion->operand(i)",
          "old_line_content": "        fusion->fused_parameter(i),",
          "new_line_content": "    const HloInstruction* operand = fusion->operand(i);",
          "content_same": false
        },
        {
          "line": 3344,
          "old_api": "EmitReadArrayElement",
          "new_api": "fused_parameter",
          "old_text": "GetIrArrayFor(operand).EmitReadArrayElement(index, &b_)",
          "new_text": "fusion->fused_parameter(i)",
          "old_line_content": "          return GetIrArrayFor(operand).EmitReadArrayElement(index, &b_);",
          "new_line_content": "        fusion->fused_parameter(i),",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2052,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "padding_config.dimensions(i).edge_padding_low()",
          "old_line_content": "  }",
          "new_line_content": "        offset, b_.getInt64(padding_config.dimensions(i).edge_padding_low()));",
          "content_same": false
        },
        {
          "line": 2053,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "output_multi_index.push_back(index)",
          "old_line_content": "",
          "new_line_content": "    output_multi_index.push_back(index);",
          "content_same": false
        },
        {
          "line": 2059,
          "old_api": null,
          "new_api": "GetType",
          "old_text": null,
          "new_text": "operand_index.GetType()",
          "old_line_content": "",
          "new_line_content": "      output_multi_index, output_array.GetShape(), operand_index.GetType());",
          "content_same": false
        },
        {
          "line": 2062,
          "old_api": null,
          "new_api": "GetOuterLoopExitBasicBlock",
          "old_text": null,
          "new_text": "loops.GetOuterLoopExitBasicBlock()",
          "old_line_content": "}",
          "new_line_content": "  SetToFirstInsertPoint(loops.GetOuterLoopExitBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 2063,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2068,
          "old_api": null,
          "new_api": "llvm_ir::CanEmitFusedDynamicUpdateSliceInPlace(fusion, assignment_)",
          "old_text": null,
          "new_text": "llvm_ir::CanEmitFusedDynamicUpdateSliceInPlace(fusion, assignment_)",
          "old_line_content": "    CpuElementalIrEmitter elemental_emitter(hlo_module_config_, this, module_);",
          "new_line_content": "  if (llvm_ir::CanEmitFusedDynamicUpdateSliceInPlace(fusion, assignment_)) {",
          "content_same": false
        },
        {
          "line": 2069,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "    FusedIrEmitter fused_emitter(&elemental_emitter);",
          "new_line_content": "    VLOG(3) << \"HandleFusion FusedDynamicUpdateSliceInPlace\";",
          "content_same": false
        },
        {
          "line": 2078,
          "old_api": null,
          "new_api": "IsLoopFusion",
          "old_text": null,
          "new_text": "fusion->IsLoopFusion()",
          "old_line_content": "    CpuElementalIrEmitter elemental_emitter(hlo_module_config_, this, module_);",
          "new_line_content": "  } else if (fusion->IsLoopFusion()) {",
          "content_same": false
        },
        {
          "line": 2079,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "    FusedIrEmitter fused_emitter(&elemental_emitter);",
          "new_line_content": "    VLOG(3) << \"HandleFusion kLoop\";",
          "content_same": false
        },
        {
          "line": 2082,
          "old_api": null,
          "new_api": "BindFusionArguments",
          "old_text": null,
          "new_text": "BindFusionArguments(fusion, &fused_emitter)",
          "old_line_content": "                                            fusion->fused_expression_root()));",
          "new_line_content": "    BindFusionArguments(fusion, &fused_emitter);",
          "content_same": false
        },
        {
          "line": 2091,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "dot->ToString()",
          "old_line_content": "",
          "new_line_content": "        << dot->ToString() << \"  \"",
          "content_same": false
        },
        {
          "line": 2094,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "dot->operand(0)->parameter_number()",
          "old_line_content": "    int64 addend_param_number =",
          "new_line_content": "    int64 dot_lhs_param_number = dot->operand(0)->parameter_number();",
          "content_same": false
        },
        {
          "line": 2100,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(fusion)",
          "old_line_content": "",
          "new_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(fusion));",
          "content_same": false
        },
        {
          "line": 2101,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(fusion)",
          "old_line_content": "    llvm_ir::IrArray lhs_array(",
          "new_line_content": "    llvm_ir::IrArray target_array = GetIrArrayFor(fusion);",
          "content_same": false
        },
        {
          "line": 2116,
          "old_api": null,
          "new_api": "Unimplemented",
          "old_text": null,
          "new_text": "Unimplemented(\"Fusion kind not implemented on CPU\")",
          "old_line_content": "}",
          "new_line_content": "    return Unimplemented(\"Fusion kind not implemented on CPU\");",
          "content_same": false
        },
        {
          "line": 2121,
          "old_api": null,
          "new_api": "to_apply",
          "old_text": null,
          "new_text": "call->to_apply()",
          "old_line_content": "",
          "new_line_content": "  HloComputation* computation = call->to_apply();",
          "content_same": false
        },
        {
          "line": 2126,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "computation->root_instruction()->outer_dimension_partitions().empty()",
          "old_line_content": "    // ParallelForkJoin.",
          "new_line_content": "  if (!computation->root_instruction()->outer_dimension_partitions().empty()) {",
          "content_same": false
        },
        {
          "line": 2129,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "GetArrayFunctionCallArguments(\n        {}, &b_, computation->name(),\n        /*return_value_buffer=*/emitted_value_[call],\n        /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),\n        /*buffer_table_arg=*/GetBufferTableArgument(),\n        /*profile_counters_arg=*/GetProfileCountersArgument())",
          "old_line_content": "        /*return_value_buffer=*/emitted_value_[call],",
          "new_line_content": "    std::vector<llvm::Value*> call_args = GetArrayFunctionCallArguments(",
          "content_same": false
        },
        {
          "line": 2133,
          "old_api": null,
          "new_api": "GetBufferTableArgument",
          "old_text": null,
          "new_text": "GetBufferTableArgument()",
          "old_line_content": "",
          "new_line_content": "        /*buffer_table_arg=*/GetBufferTableArgument(),",
          "content_same": false
        },
        {
          "line": 2138,
          "old_api": null,
          "new_api": "outer_dimension_partitions",
          "old_text": null,
          "new_text": "root->outer_dimension_partitions()",
          "old_line_content": "  } else {",
          "new_line_content": "        call_args, root->shape(), root->outer_dimension_partitions(), &b_,",
          "content_same": false
        },
        {
          "line": 2141,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "computation->name()",
          "old_line_content": "",
          "new_line_content": "    EmitGlobalCall(*computation, computation->name());",
          "content_same": false
        },
        {
          "line": 2144,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2148,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(hlo)",
          "old_line_content": "  int32 raw_data_size =",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(hlo));",
          "content_same": false
        },
        {
          "line": 2151,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "hlo->shape()",
          "old_line_content": "  llvm::Value* raw_buffer =",
          "new_line_content": "      ShapeUtil::ByteSizeOf(ShapeUtil::MakeStaticShape(hlo->shape()));",
          "content_same": false
        },
        {
          "line": 2154,
          "old_api": null,
          "new_api": "getInt8Ty",
          "old_text": null,
          "new_text": "b_.getInt8Ty()->getPointerTo()",
          "old_line_content": "    const int64 dim_index = i - 1;",
          "new_line_content": "      b_.CreateBitCast(dest_buffer, b_.getInt8Ty()->getPointerTo());",
          "content_same": false
        },
        {
          "line": 2157,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "hlo->operand(i)",
          "old_line_content": "",
          "new_line_content": "    llvm::Value* source_buffer = GetEmittedValueFor(hlo->operand(i));",
          "content_same": false
        },
        {
          "line": 2163,
          "old_api": null,
          "new_api": "getInt32Ty",
          "old_text": null,
          "new_text": "b_.getInt32Ty()->getPointerTo()",
          "old_line_content": "                                            /*isSigned=*/true,",
          "new_line_content": "                   b_.CreateBitCast(metadata, b_.getInt32Ty()->getPointerTo()));",
          "content_same": false
        },
        {
          "line": 2164,
          "old_api": null,
          "new_api": "getInt64Ty",
          "old_text": null,
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "                                            \"i64_dyn_dim_size\"));",
          "new_line_content": "    dynamic_dims.push_back(b_.CreateIntCast(dyn_dim_size, b_.getInt64Ty(),",
          "content_same": false
        },
        {
          "line": 2169,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(hlo)",
          "old_line_content": "  //",
          "new_line_content": "  llvm_ir::IrArray data_array = GetIrArrayFor(hlo);",
          "content_same": false
        },
        {
          "line": 2178,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "hlo->operand(0)",
          "old_line_content": "    // Delinearize the index based on the static shape.",
          "new_line_content": "        GetIrArrayFor(hlo->operand(0)).EmitReadArrayElement(array_index, &b_);",
          "content_same": false
        },
        {
          "line": 2183,
          "old_api": null,
          "new_api": "EmitWriteArrayElement",
          "old_text": null,
          "new_text": "data_array.EmitWriteArrayElement(dest_index, source_element, &b_)",
          "old_line_content": "  };",
          "new_line_content": "    data_array.EmitWriteArrayElement(dest_index, source_element, &b_);",
          "content_same": false
        },
        {
          "line": 2188,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(hlo)",
          "old_line_content": "",
          "new_line_content": "      .EmitLoop(IrName(hlo));",
          "content_same": false
        },
        {
          "line": 2192,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(hlo)",
          "old_line_content": "  TF_ASSIGN_OR_RETURN(BufferAllocation::Slice data_slice,",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(hlo));",
          "content_same": false
        },
        {
          "line": 2199,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "hlo->operand(0)->shape()",
          "old_line_content": "  llvm_ir::IrArray data_array(data_address, data_shape);",
          "new_line_content": "  const Shape& input_shape = hlo->operand(0)->shape();",
          "content_same": false
        },
        {
          "line": 2206,
          "old_api": null,
          "new_api": "ShapeUtil::MakeStaticShape(input_shape)",
          "old_text": null,
          "new_text": "ShapeUtil::MakeStaticShape(input_shape)",
          "old_line_content": "  // Put a placeholder for the data array's pointer",
          "new_line_content": "      ShapeUtil::ByteSizeOf(ShapeUtil::MakeStaticShape(input_shape));",
          "content_same": false
        },
        {
          "line": 2209,
          "old_api": null,
          "new_api": "GetBasePointer",
          "old_text": null,
          "new_text": "data_array.GetBasePointer()",
          "old_line_content": "  // (static_tensor, dynamic_dim_0, dynamic_dim_1, ... )",
          "new_line_content": "  tuple_operand_ptrs.push_back(data_array.GetBasePointer());",
          "content_same": false
        },
        {
          "line": 2215,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "hlo->shape()",
          "old_line_content": "    TF_ASSIGN_OR_RETURN(BufferAllocation::Slice dim_size_slice,",
          "new_line_content": "    const Shape& dim_shape = ShapeUtil::GetSubshape(hlo->shape(), {i});",
          "content_same": false
        },
        {
          "line": 2216,
          "old_api": null,
          "new_api": "ShapeUtil::MakeScalarShape(S32)",
          "old_text": null,
          "new_text": "ShapeUtil::MakeScalarShape(S32)",
          "old_line_content": "                        assignment_.GetUniqueSlice(hlo, {i}));",
          "new_line_content": "    TF_RET_CHECK(Shape::Equal()(dim_shape, ShapeUtil::MakeScalarShape(S32)));",
          "content_same": false
        },
        {
          "line": 2224,
          "old_api": null,
          "new_api": "CreateLoad",
          "old_text": null,
          "new_text": "b_.CreateLoad(\n        b_.CreateBitCast(metadata, b_.getInt32Ty()->getPointerTo()),\n        \"dyn_dim_size\")",
          "old_line_content": "        \"dyn_dim_size\");",
          "new_line_content": "    llvm::Value* dyn_dim_size = b_.CreateLoad(",
          "content_same": false
        },
        {
          "line": 2229,
          "old_api": null,
          "new_api": "getInt32Ty",
          "old_text": null,
          "new_text": "b_.getInt32Ty()->getPointerTo()",
          "old_line_content": "                                            /*isSigned=*/true,",
          "new_line_content": "                                    b_.getInt32Ty()->getPointerTo()));",
          "content_same": false
        },
        {
          "line": 2230,
          "old_api": null,
          "new_api": "getInt64Ty",
          "old_text": null,
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "                                            \"i64_dyn_dim_size\"));",
          "new_line_content": "    dynamic_dims.push_back(b_.CreateIntCast(dyn_dim_size, b_.getInt64Ty(),",
          "content_same": false
        },
        {
          "line": 2233,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "tuple_operand_ptrs.push_back(dest_dim_size_address)",
          "old_line_content": "",
          "new_line_content": "    tuple_operand_ptrs.push_back(dest_dim_size_address);",
          "content_same": false
        },
        {
          "line": 2243,
          "old_api": null,
          "new_api": "Linearize",
          "old_text": null,
          "new_text": "array_index.Linearize(dynamic_dims, &b_)",
          "old_line_content": "    llvm::Value* source_element =",
          "new_line_content": "    llvm::Value* linear_index = array_index.Linearize(dynamic_dims, &b_);",
          "content_same": false
        },
        {
          "line": 2247,
          "old_api": null,
          "new_api": "EmitWriteArrayElement",
          "old_text": null,
          "new_text": "data_array.EmitWriteArrayElement(array_index, source_element, &b_)",
          "old_line_content": "  };",
          "new_line_content": "    data_array.EmitWriteArrayElement(array_index, source_element, &b_);",
          "content_same": false
        },
        {
          "line": 2251,
          "old_api": null,
          "new_api": "EmitLoop",
          "old_text": null,
          "new_text": "llvm_ir::LoopEmitter(loop_body_emitter, input_shape, dynamic_dims, &b_)\n          .EmitLoop(IrName(hlo))",
          "old_line_content": "",
          "new_line_content": "      llvm_ir::LoopEmitter(loop_body_emitter, input_shape, dynamic_dims, &b_)",
          "content_same": false
        },
        {
          "line": 2252,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(hlo)",
          "old_line_content": "  // Emit static tensor and dynamic sizes as one tuple.",
          "new_line_content": "          .EmitLoop(IrName(hlo)));",
          "content_same": false
        },
        {
          "line": 2255,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(hlo)",
          "old_line_content": "}",
          "new_line_content": "  llvm_ir::EmitTuple(GetIrArrayFor(hlo), tuple_operand_ptrs, &b_);",
          "content_same": false
        },
        {
          "line": 2256,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2269,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "TF_RET_CHECK(\n      LayoutUtil::IsMonotonicWithDim0Major(hlo->operand(0)->shape().layout()))",
          "old_line_content": "",
          "new_line_content": "  TF_RET_CHECK(",
          "content_same": false
        },
        {
          "line": 2270,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "hlo->operand(0)->shape().layout()",
          "old_line_content": "  TF_ASSIGN_OR_RETURN(const BufferAllocation::Slice values_slice,",
          "new_line_content": "      LayoutUtil::IsMonotonicWithDim0Major(hlo->operand(0)->shape().layout()));",
          "content_same": false
        },
        {
          "line": 2283,
          "old_api": null,
          "new_api": "tuple_shapes",
          "old_text": null,
          "new_text": "hlo->shape().tuple_shapes(1)",
          "old_line_content": "      runtime::kTopKF32SymbolName,",
          "new_line_content": "      EmitBufferPointer(out_indices_slice, hlo->shape().tuple_shapes(1));",
          "content_same": false
        },
        {
          "line": 2290,
          "old_api": null,
          "new_api": "getInt32Ty",
          "old_text": null,
          "new_text": "b_.getInt32Ty()->getPointerTo()",
          "old_line_content": "",
          "new_line_content": "       BitCast(out_indices_ptr, b_.getInt32Ty()->getPointerTo())},",
          "content_same": false
        },
        {
          "line": 2295,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2299,
          "old_api": null,
          "new_api": "custom_call_target",
          "old_text": null,
          "new_text": "custom_call->custom_call_target()",
          "old_line_content": "  }",
          "new_line_content": "  if (custom_call->custom_call_target() == \"PadToStatic\") {",
          "content_same": false
        },
        {
          "line": 2302,
          "old_api": null,
          "new_api": "custom_call_target",
          "old_text": null,
          "new_text": "custom_call->custom_call_target()",
          "old_line_content": "  }",
          "new_line_content": "  if (custom_call->custom_call_target() == \"SliceToDynamic\") {",
          "content_same": false
        },
        {
          "line": 2305,
          "old_api": null,
          "new_api": "custom_call_target",
          "old_text": null,
          "new_text": "custom_call->custom_call_target()",
          "old_line_content": "  }",
          "new_line_content": "  if (custom_call->custom_call_target() == \"TopK\") {",
          "content_same": false
        },
        {
          "line": 2308,
          "old_api": null,
          "new_api": "operands",
          "old_text": null,
          "new_text": "custom_call->operands()",
          "old_line_content": "  llvm::AllocaInst* operands_alloca =",
          "new_line_content": "  absl::Span<HloInstruction* const> operands(custom_call->operands());",
          "content_same": false
        },
        {
          "line": 2312,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "operands.size()",
          "old_line_content": "    const HloInstruction* operand = operands[i];",
          "new_line_content": "          i8_ptr_type, b_.getInt32(operands.size()), \"cc_operands_alloca\", &b_);",
          "content_same": false
        },
        {
          "line": 2313,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "operands.size()",
          "old_line_content": "    llvm::Value* operand_as_i8ptr =",
          "new_line_content": "  for (size_t i = 0; i < operands.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2318,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "b_.getInt64(i)",
          "old_line_content": "  }",
          "new_line_content": "        InBoundsGEP(operands_alloca, {b_.getInt64(i)});",
          "content_same": false
        },
        {
          "line": 2319,
          "old_api": null,
          "new_api": "Store",
          "old_text": null,
          "new_text": "Store(operand_as_i8ptr, slot_in_operands_alloca)",
          "old_line_content": "  if (emit_code_for_msan_) {",
          "new_line_content": "    Store(operand_as_i8ptr, slot_in_operands_alloca);",
          "content_same": false
        },
        {
          "line": 2326,
          "old_api": null,
          "new_api": "getIntPtrTy",
          "old_text": null,
          "new_text": "b_.getIntPtrTy(dl)",
          "old_line_content": "        \"__msan_unpoison\",",
          "new_line_content": "    llvm::Type* intptr_type = b_.getIntPtrTy(dl);",
          "content_same": false
        },
        {
          "line": 2331,
          "old_api": null,
          "new_api": "getAllocationSizeInBits",
          "old_text": null,
          "new_text": "operands_alloca->getAllocationSizeInBits(dl)",
          "old_line_content": "  }",
          "new_line_content": "             intptr_type, *operands_alloca->getAllocationSizeInBits(dl) / 8)},",
          "content_same": false
        },
        {
          "line": 2332,
          "old_api": null,
          "new_api": "getVoidTy",
          "old_text": null,
          "new_text": "b_.getVoidTy()",
          "old_line_content": "",
          "new_line_content": "        b_.getVoidTy());",
          "content_same": false
        },
        {
          "line": 2339,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "custom_call->shape()",
          "old_line_content": "      const Shape& elem_shape =",
          "new_line_content": "    for (int i = 0; i < ShapeUtil::TupleElementCount(custom_call->shape());",
          "content_same": false
        },
        {
          "line": 2342,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "custom_call->shape()",
          "old_line_content": "      TF_ASSIGN_OR_RETURN(const BufferAllocation::Slice slice,",
          "new_line_content": "          ShapeUtil::GetTupleElementShape(custom_call->shape(), i);",
          "content_same": false
        },
        {
          "line": 2343,
          "old_api": null,
          "new_api": "IsTuple",
          "old_text": null,
          "new_text": "elem_shape.IsTuple()",
          "old_line_content": "                          assignment_.GetUniqueSlice(custom_call, {i}));",
          "new_line_content": "      TF_RET_CHECK(!elem_shape.IsTuple()) << \"Nested tuples not implemented\";",
          "content_same": false
        },
        {
          "line": 2346,
          "old_api": null,
          "new_api": "EmitBufferPointer",
          "old_text": null,
          "new_text": "EmitBufferPointer(slice, elem_shape)",
          "old_line_content": "    }",
          "new_line_content": "      llvm::Value* addr = EmitBufferPointer(slice, elem_shape);",
          "content_same": false
        },
        {
          "line": 2349,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(custom_call)",
          "old_line_content": "  auto* output_address_arg =",
          "new_line_content": "    llvm_ir::EmitTuple(GetIrArrayFor(custom_call), base_ptrs, &b_);",
          "content_same": false
        },
        {
          "line": 2354,
          "old_api": null,
          "new_api": "custom_call_target",
          "old_text": null,
          "new_text": "custom_call->custom_call_target()",
          "old_line_content": "",
          "new_line_content": "  EmitCallToFunc(custom_call->custom_call_target(),",
          "content_same": false
        },
        {
          "line": 2357,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2363,
          "old_api": null,
          "new_api": "root_instruction",
          "old_text": null,
          "new_text": "condition->root_instruction()->shape()",
          "old_line_content": "      << \"While condition computation must return bool; got: \"",
          "new_line_content": "  TF_RET_CHECK(ShapeUtil::IsScalar(condition->root_instruction()->shape()) &&",
          "content_same": false
        },
        {
          "line": 2368,
          "old_api": null,
          "new_api": "GetUniqueSlice",
          "old_text": null,
          "new_text": "ShapeUtil::ForEachSubshapeWithStatus(\n      xla_while->shape(),\n      [this, &xla_while](const Shape& /*subshape*/,\n                         const ShapeIndex& index) -> Status {\n        auto check = [this](const HloInstruction* a, const HloInstruction* b,\n                            const ShapeIndex& index) {\n          const BufferAllocation::Slice slice_a =\n              assignment_.GetUniqueSlice(a, index).ConsumeValueOrDie();\n          const BufferAllocation::Slice slice_b =\n              assignment_.GetUniqueSlice(b, index).ConsumeValueOrDie();\n          if (slice_a != slice_b) {\n            return InternalError(\n                \"instruction %s %s does not share slice with \"\n                \"instruction %s %s\",\n                a->ToString(), slice_a.ToString(), b->ToString(),\n                slice_b.ToString());\n          }\n          return Status::OK();\n        };\n        TF_RETURN_IF_ERROR(check(xla_while, xla_while->operand(0), index));\n        TF_RETURN_IF_ERROR(check(\n            xla_while, xla_while->while_condition()->parameter_instruction(0),\n            index));\n        TF_RETURN_IF_ERROR(\n            check(xla_while, xla_while->while_body()->parameter_instruction(0),\n                  index));\n        TF_RETURN_IF_ERROR(check(\n            xla_while, xla_while->while_body()->root_instruction(), index));\n        return Status::OK();\n      })",
          "old_line_content": "      [this, &xla_while](const Shape& /*subshape*/,",
          "new_line_content": "  TF_RETURN_IF_ERROR(ShapeUtil::ForEachSubshapeWithStatus(",
          "content_same": false
        },
        {
          "line": 2369,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "xla_while->shape()",
          "old_line_content": "                         const ShapeIndex& index) -> Status {",
          "new_line_content": "      xla_while->shape(),",
          "content_same": false
        },
        {
          "line": 2379,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "InternalError(\n                \"instruction %s %s does not share slice with \"\n                \"instruction %s %s\",\n                a->ToString(), slice_a.ToString(), b->ToString(),\n                slice_b.ToString())",
          "old_line_content": "                \"instruction %s %s\",",
          "new_line_content": "            return InternalError(",
          "content_same": false
        },
        {
          "line": 2382,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "b->ToString()",
          "old_line_content": "          }",
          "new_line_content": "                a->ToString(), slice_a.ToString(), b->ToString(),",
          "content_same": false
        },
        {
          "line": 2388,
          "old_api": null,
          "new_api": "while_condition",
          "old_text": null,
          "new_text": "check(\n            xla_while, xla_while->while_condition()->parameter_instruction(0),\n            index)",
          "old_line_content": "            index));",
          "new_line_content": "        TF_RETURN_IF_ERROR(check(",
          "content_same": false
        },
        {
          "line": 2391,
          "old_api": null,
          "new_api": "while_body",
          "old_text": null,
          "new_text": "TF_RETURN_IF_ERROR(\n            check(xla_while, xla_while->while_body()->parameter_instruction(0),\n                  index))",
          "old_line_content": "                  index));",
          "new_line_content": "        TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 2395,
          "old_api": null,
          "new_api": "while_body",
          "old_text": null,
          "new_text": "xla_while->while_body()->root_instruction()",
          "old_line_content": "      }));",
          "new_line_content": "            xla_while, xla_while->while_body()->root_instruction(), index));",
          "content_same": false
        },
        {
          "line": 2396,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "        return Status::OK();",
          "content_same": false
        },
        {
          "line": 2400,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "xla_while->operand(0)",
          "old_line_content": "",
          "new_line_content": "  const HloInstruction* init = xla_while->operand(0);",
          "content_same": false
        },
        {
          "line": 2401,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(init)",
          "old_line_content": "  // Generating:",
          "new_line_content": "  emitted_value_[xla_while] = GetEmittedValueFor(init);",
          "content_same": false
        },
        {
          "line": 2414,
          "old_api": null,
          "new_api": "Br",
          "old_text": null,
          "new_text": "Br(header_bb)",
          "old_line_content": "",
          "new_line_content": "  Br(header_bb);",
          "content_same": false
        },
        {
          "line": 2415,
          "old_api": null,
          "new_api": "SetInsertPoint",
          "old_text": null,
          "new_text": "b_.SetInsertPoint(header_bb)",
          "old_line_content": "  // Calls the condition function to determine whether to proceed with the",
          "new_line_content": "  b_.SetInsertPoint(header_bb);",
          "content_same": false
        },
        {
          "line": 2421,
          "old_api": null,
          "new_api": "while_condition",
          "old_text": null,
          "new_text": "xla_while->while_condition()",
          "old_line_content": "",
          "new_line_content": "      Load(GetBufferForGlobalCallReturnValue(*xla_while->while_condition())),",
          "content_same": false
        },
        {
          "line": 2422,
          "old_api": null,
          "new_api": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "old_text": null,
          "new_text": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "old_line_content": "  // Branches to the body or to the while exit depending on the condition.",
          "new_line_content": "      llvm::ConstantInt::get(llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0));",
          "content_same": false
        },
        {
          "line": 2429,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(xla_while, \"exit\")",
          "old_line_content": "",
          "new_line_content": "      module_->getContext(), IrName(xla_while, \"exit\"));",
          "content_same": false
        },
        {
          "line": 2430,
          "old_api": null,
          "new_api": "CondBr",
          "old_text": null,
          "new_text": "CondBr(while_predicate, body_bb, exit_bb)",
          "old_line_content": "  // Calls the body function from the body block.",
          "new_line_content": "  CondBr(while_predicate, body_bb, exit_bb);",
          "content_same": false
        },
        {
          "line": 2433,
          "old_api": null,
          "new_api": "SetInsertPoint",
          "old_text": null,
          "new_text": "b_.SetInsertPoint(body_bb)",
          "old_line_content": "  // Calls the body function.",
          "new_line_content": "  b_.SetInsertPoint(body_bb);",
          "content_same": false
        },
        {
          "line": 2436,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(xla_while, \"body\")",
          "old_line_content": "  // Finishes with a branch back to the header.",
          "new_line_content": "  EmitGlobalCall(*xla_while->while_body(), IrName(xla_while, \"body\"));",
          "content_same": false
        },
        {
          "line": 2439,
          "old_api": null,
          "new_api": "Br",
          "old_text": null,
          "new_text": "Br(header_bb)",
          "old_line_content": "  // Adds the exit block to the function and sets the insert point there.",
          "new_line_content": "  Br(header_bb);",
          "content_same": false
        },
        {
          "line": 2442,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "compute_function_->function()->getBasicBlockList().push_back(exit_bb)",
          "old_line_content": "",
          "new_line_content": "  compute_function_->function()->getBasicBlockList().push_back(exit_bb);",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2451,
          "old_api": null,
          "new_api": "ShouldEmitParallelLoopFor",
          "old_text": null,
          "new_text": "ShouldEmitParallelLoopFor(*concatenate)",
          "old_line_content": "        \"cannot generate memcpy-based concat for the parallel CPU backend\";",
          "new_line_content": "  if (ShouldEmitParallelLoopFor(*concatenate)) {",
          "content_same": false
        },
        {
          "line": 2459,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "output_shape.layout()",
          "old_line_content": "      return false;",
          "new_line_content": "    if (!LayoutUtil::Equal(op->shape().layout(), output_shape.layout())) {",
          "content_same": false
        },
        {
          "line": 2471,
          "old_api": null,
          "new_api": "LayoutUtil::MinorToMajor(output_layout)",
          "old_text": null,
          "new_text": "LayoutUtil::MinorToMajor(output_layout)",
          "old_line_content": "",
          "new_line_content": "  auto output_min2maj = LayoutUtil::MinorToMajor(output_layout);",
          "content_same": false
        },
        {
          "line": 2475,
          "old_api": null,
          "new_api": "std::next(concat_dim_layout_itr)",
          "old_text": null,
          "new_text": "std::next(concat_dim_layout_itr)",
          "old_line_content": "",
          "new_line_content": "  std::vector<int64> outer_dims(std::next(concat_dim_layout_itr),",
          "content_same": false
        },
        {
          "line": 2480,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(concatenate)",
          "old_line_content": "",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(concatenate));",
          "content_same": false
        },
        {
          "line": 2487,
          "old_api": null,
          "new_api": "static_cast<llvm::Value*>(nullptr)",
          "old_text": null,
          "new_text": "static_cast<llvm::Value*>(nullptr)",
          "old_line_content": "  llvm_ir::IrArray::Index target_index(target_multi_index, output_shape,",
          "new_line_content": "               static_cast<llvm::Value*>(nullptr),",
          "content_same": false
        },
        {
          "line": 2492,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "outer_dims.empty()",
          "old_line_content": "  }",
          "new_line_content": "  if (!outer_dims.empty()) {",
          "content_same": false
        },
        {
          "line": 2493,
          "old_api": null,
          "new_api": "GetInnerLoopBodyBasicBlock",
          "old_text": null,
          "new_text": "loops.GetInnerLoopBodyBasicBlock()",
          "old_line_content": "",
          "new_line_content": "    SetToFirstInsertPoint(loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 2498,
          "old_api": null,
          "new_api": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "old_text": null,
          "new_text": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "old_line_content": "  // Contiguous subregions from each operand to the concatenate contribute to a",
          "new_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(primitive_type);",
          "content_same": false
        },
        {
          "line": 2502,
          "old_api": null,
          "new_api": "EmitArrayElementAddress",
          "old_text": null,
          "new_text": "BitCast(\n      target_array.EmitArrayElementAddress(target_index, &b_, \"target_region\"),\n      i8_ptr_type)",
          "old_line_content": "      i8_ptr_type);",
          "new_line_content": "  llvm::Value* target_region_begin = BitCast(",
          "content_same": false
        },
        {
          "line": 2503,
          "old_api": null,
          "new_api": "EmitArrayElementAddress",
          "old_text": null,
          "new_text": "target_array.EmitArrayElementAddress(target_index, &b_, \"target_region\")",
          "old_line_content": "  int64 byte_offset_into_target_region = 0;",
          "new_line_content": "      target_array.EmitArrayElementAddress(target_index, &b_, \"target_region\"),",
          "content_same": false
        },
        {
          "line": 2510,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "output_shape.dimensions(inner_dim)",
          "old_line_content": "",
          "new_line_content": "                        return product * output_shape.dimensions(inner_dim);",
          "content_same": false
        },
        {
          "line": 2520,
          "old_api": null,
          "new_api": "EmitArrayElementAddress",
          "old_text": null,
          "new_text": "BitCast(\n        source_array.EmitArrayElementAddress(source_index, &b_, \"src_addr\"),\n        i8_ptr_type)",
          "old_line_content": "        i8_ptr_type);",
          "new_line_content": "    llvm::Value* copy_source_address = BitCast(",
          "content_same": false
        },
        {
          "line": 2521,
          "old_api": null,
          "new_api": "EmitArrayElementAddress",
          "old_text": null,
          "new_text": "source_array.EmitArrayElementAddress(source_index, &b_, \"src_addr\")",
          "old_line_content": "",
          "new_line_content": "        source_array.EmitArrayElementAddress(source_index, &b_, \"src_addr\"),",
          "content_same": false
        },
        {
          "line": 2529,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "input_shape.dimensions(concat_dim)",
          "old_line_content": "",
          "new_line_content": "        inner_dims_product * input_shape.dimensions(concat_dim), primitive_type,",
          "content_same": false
        },
        {
          "line": 2533,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "input_shape.dimensions(concat_dim)",
          "old_line_content": "  }",
          "new_line_content": "                                      input_shape.dimensions(concat_dim) *",
          "content_same": false
        },
        {
          "line": 2537,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "outer_dims.empty()",
          "old_line_content": "  }",
          "new_line_content": "  if (!outer_dims.empty()) {",
          "content_same": false
        },
        {
          "line": 2538,
          "old_api": null,
          "new_api": "GetOuterLoopExitBasicBlock",
          "old_text": null,
          "new_text": "loops.GetOuterLoopExitBasicBlock()",
          "old_line_content": "",
          "new_line_content": "    SetToFirstInsertPoint(loops.GetOuterLoopExitBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 2551,
          "old_api": null,
          "new_api": "GetInsertBlock",
          "old_text": null,
          "new_text": "b_.GetInsertBlock()->getParent()->getParent()->getOrInsertFunction(\n          \"printf\", llvm::FunctionType::get(b_.getInt32Ty(), {ptr_ty},\n                                            /*isVarArg=*/true))",
          "old_line_content": "                                            /*isVarArg=*/true)),",
          "new_line_content": "      b_.GetInsertBlock()->getParent()->getParent()->getOrInsertFunction(",
          "content_same": false
        },
        {
          "line": 2552,
          "old_api": null,
          "new_api": "getInt32Ty",
          "old_text": null,
          "new_text": "b_.getInt32Ty()",
          "old_line_content": "      call_args);",
          "new_line_content": "          \"printf\", llvm::FunctionType::get(b_.getInt32Ty(), {ptr_ty},",
          "content_same": false
        },
        {
          "line": 2563,
          "old_api": null,
          "new_api": "CreateCall",
          "old_text": null,
          "new_text": "b_.CreateCall(\n      b_.GetInsertBlock()->getParent()->getParent()->getOrInsertFunction(\n          runtime::kPrintfToStderrSymbolName,\n          llvm::FunctionType::get(b_.getInt32Ty(), {ptr_ty},\n                                  /*isVarArg=*/true)),\n      call_args)",
          "old_line_content": "          runtime::kPrintfToStderrSymbolName,",
          "new_line_content": "  return b_.CreateCall(",
          "content_same": false
        },
        {
          "line": 2566,
          "old_api": null,
          "new_api": "getInt32Ty",
          "old_text": null,
          "new_text": "b_.getInt32Ty()",
          "old_line_content": "      call_args);",
          "new_line_content": "          llvm::FunctionType::get(b_.getInt32Ty(), {ptr_ty},",
          "content_same": false
        },
        {
          "line": 2577,
          "old_api": null,
          "new_api": "std::back_inserter(types)",
          "old_text": null,
          "new_text": "std::back_inserter(types)",
          "old_line_content": "  llvm::FunctionType* func_type =",
          "new_line_content": "  absl::c_transform(arguments, std::back_inserter(types),",
          "content_same": false
        },
        {
          "line": 2582,
          "old_api": null,
          "new_api": "getCallee",
          "old_text": null,
          "new_text": "module_->getOrInsertFunction(func_name, func_type).getCallee()",
          "old_line_content": "  if (does_not_throw) {",
          "new_line_content": "      module_->getOrInsertFunction(func_name, func_type).getCallee());",
          "content_same": false
        },
        {
          "line": 2585,
          "old_api": null,
          "new_api": "setDoesNotThrow",
          "old_text": null,
          "new_text": "func->setDoesNotThrow()",
          "old_line_content": "  if (only_accesses_arg_memory) {",
          "new_line_content": "    func->setDoesNotThrow();",
          "content_same": false
        },
        {
          "line": 2588,
          "old_api": null,
          "new_api": "setOnlyAccessesArgMemory",
          "old_text": null,
          "new_text": "func->setOnlyAccessesArgMemory()",
          "old_line_content": "  if (only_accesses_inaccessible_mem_or_arg_mem) {",
          "new_line_content": "    func->setOnlyAccessesArgMemory();",
          "content_same": false
        },
        {
          "line": 2593,
          "old_api": null,
          "new_api": "CreateCall",
          "old_text": null,
          "new_text": "b_.CreateCall(func, arguments)",
          "old_line_content": "",
          "new_line_content": "  return b_.CreateCall(func, arguments);",
          "content_same": false
        },
        {
          "line": 2602,
          "old_api": null,
          "new_api": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "old_text": null,
          "new_text": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "old_line_content": "      primitive_type_size, MinimumAlignmentForPrimitiveType(primitive_type)));",
          "new_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(primitive_type);",
          "content_same": false
        },
        {
          "line": 2605,
          "old_api": null,
          "new_api": "llvm::PointerType::getUnqual(\n      llvm_ir::PrimitiveTypeToIrType(primitive_type, module_))",
          "old_text": null,
          "new_text": "llvm::PointerType::getUnqual(\n      llvm_ir::PrimitiveTypeToIrType(primitive_type, module_))",
          "old_line_content": "",
          "new_line_content": "  llvm::Type* primitive_ptr_type = llvm::PointerType::getUnqual(",
          "content_same": false
        },
        {
          "line": 2606,
          "old_api": null,
          "new_api": "llvm_ir::PrimitiveTypeToIrType(primitive_type, module_)",
          "old_text": null,
          "new_text": "llvm_ir::PrimitiveTypeToIrType(primitive_type, module_)",
          "old_line_content": "  if (element_count == 1) {",
          "new_line_content": "      llvm_ir::PrimitiveTypeToIrType(primitive_type, module_));",
          "content_same": false
        },
        {
          "line": 2610,
          "old_api": null,
          "new_api": "BitCast",
          "old_text": null,
          "new_text": "BitCast(source, primitive_ptr_type)",
          "old_line_content": "    auto* store_instruction =",
          "new_line_content": "        AlignedLoad(BitCast(source, primitive_ptr_type), element_alignment);",
          "content_same": false
        },
        {
          "line": 2618,
          "old_api": null,
          "new_api": "llvm::Align(element_alignment)",
          "old_text": null,
          "new_text": "llvm::Align(element_alignment)",
          "old_line_content": "        element_count * primitive_type_size);",
          "new_line_content": "        target, /*DstAlign=*/llvm::Align(element_alignment), source,",
          "content_same": false
        },
        {
          "line": 2619,
          "old_api": null,
          "new_api": "llvm::Align(element_alignment)",
          "old_text": null,
          "new_text": "llvm::Align(element_alignment)",
          "old_line_content": "",
          "new_line_content": "        /*SrcAlign=*/llvm::Align(element_alignment),",
          "content_same": false
        },
        {
          "line": 2625,
          "old_api": null,
          "new_api": "metadata",
          "old_text": null,
          "new_text": "source_array.metadata()",
          "old_line_content": "    for (const auto& kind_md_pair : merged_metadata) {",
          "new_line_content": "        llvm_ir::MergeMetadata(&module_->getContext(), source_array.metadata(),",
          "content_same": false
        },
        {
          "line": 2628,
          "old_api": null,
          "new_api": "setMetadata",
          "old_text": null,
          "new_text": "memcpy_instruction->setMetadata(kind_md_pair.first, kind_md_pair.second)",
          "old_line_content": "  }",
          "new_line_content": "      memcpy_instruction->setMetadata(kind_md_pair.first, kind_md_pair.second);",
          "content_same": false
        },
        {
          "line": 2634,
          "old_api": null,
          "new_api": "operands",
          "old_text": null,
          "new_text": "concatenate->operands()",
          "old_line_content": "  TF_ASSIGN_OR_RETURN(",
          "new_line_content": "  absl::Span<HloInstruction* const> operands(concatenate->operands());",
          "content_same": false
        },
        {
          "line": 2640,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "concatenate->ToString()",
          "old_line_content": "  }",
          "new_line_content": "    VLOG(1) << \"Emitted fast concatenate for \" << concatenate->ToString();",
          "content_same": false
        },
        {
          "line": 2641,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "    return Status::OK();",
          "content_same": false
        },
        {
          "line": 2644,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "concatenate->ToString()",
          "old_line_content": "",
          "new_line_content": "  VLOG(1) << \"Could not emit fast concatenate for \" << concatenate->ToString()",
          "content_same": false
        },
        {
          "line": 2647,
          "old_api": null,
          "new_api": "DefaultAction",
          "old_text": null,
          "new_text": "DefaultAction(concatenate)",
          "old_line_content": "",
          "new_line_content": "  return DefaultAction(concatenate);",
          "content_same": false
        },
        {
          "line": 2654,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "branch_index->shape().element_type()",
          "old_line_content": "      << \"Branch index on a conditional must be scalar bool or int32; got: \"",
          "new_line_content": "               (branch_index->shape().element_type() == PRED ||",
          "content_same": false
        },
        {
          "line": 2657,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "branch_index->shape()",
          "old_line_content": "  for (int b = 0; b < num_branches; ++b) {",
          "new_line_content": "      << ShapeUtil::HumanString(branch_index->shape());",
          "content_same": false
        },
        {
          "line": 2661,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "conditional->shape()",
          "old_line_content": "        << \"Shape of conditional should be same as the shape of the \" << b",
          "new_line_content": "    TF_RET_CHECK(ShapeUtil::Equal(conditional->shape(),",
          "content_same": false
        },
        {
          "line": 2662,
          "old_api": null,
          "new_api": "root_instruction",
          "old_text": null,
          "new_text": "br_computation->root_instruction()->shape()",
          "old_line_content": "        << \"th branch computation; got: \"",
          "new_line_content": "                                  br_computation->root_instruction()->shape()))",
          "content_same": false
        },
        {
          "line": 2665,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "conditional->shape()",
          "old_line_content": "  }",
          "new_line_content": "        << ShapeUtil::HumanString(conditional->shape()) << \" and \"",
          "content_same": false
        },
        {
          "line": 2666,
          "old_api": null,
          "new_api": "root_instruction",
          "old_text": null,
          "new_text": "br_computation->root_instruction()->shape()",
          "old_line_content": "",
          "new_line_content": "        << ShapeUtil::HumanString(br_computation->root_instruction()->shape());",
          "content_same": false
        },
        {
          "line": 2671,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "branch_index->shape().element_type()",
          "old_line_content": "    //   if (pred)",
          "new_line_content": "  if (branch_index->shape().element_type() == PRED) {",
          "content_same": false
        },
        {
          "line": 2677,
          "old_api": null,
          "new_api": "GetBasePointer",
          "old_text": null,
          "new_text": "Load(\n        GetIrArrayFor(branch_index).GetBasePointer(), \"load_predicate_value\")",
          "old_line_content": "    llvm::Value* pred_cond =",
          "new_line_content": "    llvm::LoadInst* pred_value = Load(",
          "content_same": false
        },
        {
          "line": 2681,
          "old_api": null,
          "new_api": "llvm::ConstantInt::get(\n                   llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0)",
          "old_text": null,
          "new_text": "llvm::ConstantInt::get(\n                   llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0)",
          "old_line_content": "               \"boolean_predicate\");",
          "new_line_content": "               llvm::ConstantInt::get(",
          "content_same": false
        },
        {
          "line": 2682,
          "old_api": null,
          "new_api": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "old_text": null,
          "new_text": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "old_line_content": "    llvm_ir::LlvmIfData if_data =",
          "new_line_content": "                   llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0),",
          "content_same": false
        },
        {
          "line": 2688,
          "old_api": null,
          "new_api": "branch_computation",
          "old_text": null,
          "new_text": "conditional->branch_computation(0)",
          "old_line_content": "",
          "new_line_content": "    EmitGlobalCall(*conditional->branch_computation(0),",
          "content_same": false
        },
        {
          "line": 2692,
          "old_api": null,
          "new_api": "branch_computation",
          "old_text": null,
          "new_text": "conditional->branch_computation(1)",
          "old_line_content": "",
          "new_line_content": "    EmitGlobalCall(*conditional->branch_computation(1),",
          "content_same": false
        },
        {
          "line": 2695,
          "old_api": null,
          "new_api": "SetToFirstInsertPoint",
          "old_text": null,
          "new_text": "SetToFirstInsertPoint(if_data.after_block, &b_)",
          "old_line_content": "  }",
          "new_line_content": "    SetToFirstInsertPoint(if_data.after_block, &b_);",
          "content_same": false
        },
        {
          "line": 2696,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "  // We emit a switch statement to LLVM:",
          "new_line_content": "    return Status::OK();",
          "content_same": false
        },
        {
          "line": 2712,
          "old_api": null,
          "new_api": "GetBasePointer",
          "old_text": null,
          "new_text": "Load(\n      GetIrArrayFor(branch_index).GetBasePointer(), \"load_branch_index_value\")",
          "old_line_content": "",
          "new_line_content": "  llvm::LoadInst* branch_index_value = Load(",
          "content_same": false
        },
        {
          "line": 2715,
          "old_api": null,
          "new_api": "GetInsertBlock",
          "old_text": null,
          "new_text": "b_.GetInsertBlock()",
          "old_line_content": "  // Add a terminator to the case block, if necessary.",
          "new_line_content": "  auto case_block = b_.GetInsertBlock();",
          "content_same": false
        },
        {
          "line": 2720,
          "old_api": null,
          "new_api": "SetInsertPoint",
          "old_text": null,
          "new_text": "b_.SetInsertPoint(case_block)",
          "old_line_content": "  } else {",
          "new_line_content": "    b_.SetInsertPoint(case_block);",
          "content_same": false
        },
        {
          "line": 2721,
          "old_api": null,
          "new_api": "CreateBr",
          "old_text": null,
          "new_text": "b_.CreateBr(after_block)",
          "old_line_content": "    after_block =",
          "new_line_content": "    b_.CreateBr(after_block);",
          "content_same": false
        },
        {
          "line": 2724,
          "old_api": null,
          "new_api": "GetInsertPoint",
          "old_text": null,
          "new_text": "b_.GetInsertPoint()",
          "old_line_content": "  // Our basic block should now end with an unconditional branch.  Remove it;",
          "new_line_content": "        case_block->splitBasicBlock(b_.GetInsertPoint(), \"case-after\");",
          "content_same": false
        },
        {
          "line": 2728,
          "old_api": null,
          "new_api": "getTerminator",
          "old_text": null,
          "new_text": "case_block->getTerminator()->eraseFromParent()",
          "old_line_content": "  // Lower the default branch computation.",
          "new_line_content": "  case_block->getTerminator()->eraseFromParent();",
          "content_same": false
        },
        {
          "line": 2734,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(conditional, \"_default\")",
          "old_line_content": "",
          "new_line_content": "                 IrName(conditional, \"_default\"));",
          "content_same": false
        },
        {
          "line": 2735,
          "old_api": null,
          "new_api": "CreateBr",
          "old_text": null,
          "new_text": "b_.CreateBr(after_block)",
          "old_line_content": "  // Prepare the switch (branch_index) { ... } instruction.",
          "new_line_content": "  b_.CreateBr(after_block);",
          "content_same": false
        },
        {
          "line": 2740,
          "old_api": null,
          "new_api": "CreateSwitch",
          "old_text": null,
          "new_text": "b_.CreateSwitch(branch_index_value, default_block, num_branches - 1)",
          "old_line_content": "  for (int b = 0; b < num_branches - 1; ++b) {  // last branch is default",
          "new_line_content": "      b_.CreateSwitch(branch_index_value, default_block, num_branches - 1);",
          "content_same": false
        },
        {
          "line": 2749,
          "old_api": null,
          "new_api": "CreateBr",
          "old_text": null,
          "new_text": "b_.CreateBr(after_block)",
          "old_line_content": "  }",
          "new_line_content": "    b_.CreateBr(after_block);",
          "content_same": false
        },
        {
          "line": 2750,
          "old_api": null,
          "new_api": "getInt32",
          "old_text": null,
          "new_text": "b_.getInt32(b)",
          "old_line_content": "",
          "new_line_content": "    case_inst->addCase(b_.getInt32(b), branch_block);",
          "content_same": false
        },
        {
          "line": 2753,
          "old_api": null,
          "new_api": "SetToFirstInsertPoint",
          "old_text": null,
          "new_text": "SetToFirstInsertPoint(after_block, &b_)",
          "old_line_content": "}",
          "new_line_content": "  SetToFirstInsertPoint(after_block, &b_);",
          "content_same": false
        },
        {
          "line": 2754,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2760,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(after_all)",
          "old_line_content": "}",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(after_all));",
          "content_same": false
        },
        {
          "line": 2761,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2767,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "add_dependency->operand(0)",
          "old_line_content": "}",
          "new_line_content": "      GetEmittedValueFor(add_dependency->operand(0));",
          "content_same": false
        },
        {
          "line": 2768,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2772,
          "old_api": null,
          "new_api": "Unimplemented",
          "old_text": null,
          "new_text": "Unimplemented(\"Rng should be expanded for CPU.\")",
          "old_line_content": "",
          "new_line_content": "  return Unimplemented(\"Rng should be expanded for CPU.\");",
          "content_same": false
        },
        {
          "line": 2777,
          "old_api": null,
          "new_api": "delta",
          "old_text": null,
          "new_text": "llvm_ir::RngGetAndUpdateState(\n      Cast<HloRngGetAndUpdateStateInstruction>(rng_state)->delta(), module_,\n      &b_)",
          "old_line_content": "      &b_);",
          "new_line_content": "  llvm::Value* old_state = llvm_ir::RngGetAndUpdateState(",
          "content_same": false
        },
        {
          "line": 2778,
          "old_api": null,
          "new_api": "delta",
          "old_text": null,
          "new_text": "Cast<HloRngGetAndUpdateStateInstruction>(rng_state)->delta()",
          "old_line_content": "",
          "new_line_content": "      Cast<HloRngGetAndUpdateStateInstruction>(rng_state)->delta(), module_,",
          "content_same": false
        },
        {
          "line": 2781,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(rng_state)",
          "old_line_content": "",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(rng_state));",
          "content_same": false
        },
        {
          "line": 2782,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(rng_state)",
          "old_line_content": "  // The buffer has an array type while the value has a i128. Cast the",
          "new_line_content": "  llvm::Value* address = GetEmittedValueFor(rng_state);",
          "content_same": false
        },
        {
          "line": 2790,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "IrEmitter::MinimumAlignmentForPrimitiveType(\n      rng_state->shape().element_type())",
          "old_line_content": "",
          "new_line_content": "  store->setAlignment(llvm::Align(IrEmitter::MinimumAlignmentForPrimitiveType(",
          "content_same": false
        },
        {
          "line": 2793,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2805,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(2)",
          "old_line_content": "  } else {",
          "new_line_content": "    VLOG(2) << \"  outfeed with value: \"",
          "content_same": false
        },
        {
          "line": 2808,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(root)",
          "old_line_content": "",
          "new_line_content": "    VLOG(2) << \"  value: \" << llvm_ir::DumpToString(*GetEmittedValueFor(root));",
          "content_same": false
        },
        {
          "line": 2813,
          "old_api": null,
          "new_api": "RecordCompleteComputation",
          "old_text": null,
          "new_text": "profiling_state_.RecordCompleteComputation(&b_, prof_counter)",
          "old_line_content": "  };",
          "new_line_content": "      profiling_state_.RecordCompleteComputation(&b_, prof_counter);",
          "content_same": false
        },
        {
          "line": 2820,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "root->parent()",
          "old_line_content": "}",
          "new_line_content": "  record_complete_computation(GetProfileCounterFor(*root->parent()));",
          "content_same": false
        },
        {
          "line": 2821,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2828,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "profile_index_map.find(&hlo)",
          "old_line_content": "    return nullptr;",
          "new_line_content": "  auto it = profile_index_map.find(&hlo);",
          "content_same": false
        },
        {
          "line": 2829,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "profile_index_map.end()",
          "old_line_content": "  }",
          "new_line_content": "  if (it == profile_index_map.end()) {",
          "content_same": false
        },
        {
          "line": 2834,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "hlo.name()",
          "old_line_content": "             counter_name);",
          "new_line_content": "  string counter_name = IrName(\"prof_counter\", hlo.name());",
          "content_same": false
        },
        {
          "line": 2835,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "b_.getInt64(prof_counter_idx)",
          "old_line_content": "}",
          "new_line_content": "  return GEP(GetProfileCountersArgument(), b_.getInt64(prof_counter_idx),",
          "content_same": false
        },
        {
          "line": 2841,
          "old_api": null,
          "new_api": "GetProfileCounterCommon<HloInstruction>(instruction,\n                                                 instruction_to_profile_idx_)",
          "old_text": null,
          "new_text": "GetProfileCounterCommon<HloInstruction>(instruction,\n                                                 instruction_to_profile_idx_)",
          "old_line_content": "}",
          "new_line_content": "  return GetProfileCounterCommon<HloInstruction>(instruction,",
          "content_same": false
        },
        {
          "line": 2847,
          "old_api": null,
          "new_api": "GetProfileCounterCommon<HloComputation>(computation,\n                                                 computation_to_profile_idx_)",
          "old_text": null,
          "new_text": "GetProfileCounterCommon<HloComputation>(computation,\n                                                 computation_to_profile_idx_)",
          "old_line_content": "}",
          "new_line_content": "  return GetProfileCounterCommon<HloComputation>(computation,",
          "content_same": false
        },
        {
          "line": 2859,
          "old_api": null,
          "new_api": "CreateAdd",
          "old_text": null,
          "new_text": "b->CreateAdd(cycle_diff, old_cycle_count, \"new_cycle_count\")",
          "old_line_content": "}",
          "new_line_content": "      b->CreateAdd(cycle_diff, old_cycle_count, \"new_cycle_count\");",
          "content_same": false
        },
        {
          "line": 2860,
          "old_api": null,
          "new_api": "CreateStore",
          "old_text": null,
          "new_text": "b->CreateStore(new_cycle_count, prof_counter)",
          "old_line_content": "",
          "new_line_content": "  b->CreateStore(new_cycle_count, prof_counter);",
          "content_same": false
        },
        {
          "line": 2864,
          "old_api": null,
          "new_api": "GetInsertBlock",
          "old_text": null,
          "new_text": "b->GetInsertBlock()->getModule()",
          "old_line_content": "    llvm::Function* func_llvm_readcyclecounter =",
          "new_line_content": "  llvm::Module* module = b->GetInsertBlock()->getModule();",
          "content_same": false
        },
        {
          "line": 2869,
          "old_api": null,
          "new_api": "CreateCall",
          "old_text": null,
          "new_text": "b->CreateCall(func_llvm_readcyclecounter)",
          "old_line_content": "  llvm::Function* func_llvm_x86_rdtscp =",
          "new_line_content": "    return b->CreateCall(func_llvm_readcyclecounter);",
          "content_same": false
        },
        {
          "line": 2873,
          "old_api": null,
          "new_api": "CreateCall",
          "old_text": null,
          "new_text": "b->CreateCall(func_llvm_x86_rdtscp)",
          "old_line_content": "}",
          "new_line_content": "  llvm::Value* rdtscp_call = b->CreateCall(func_llvm_x86_rdtscp);",
          "content_same": false
        },
        {
          "line": 2874,
          "old_api": null,
          "new_api": "CreateExtractValue",
          "old_text": null,
          "new_text": "b->CreateExtractValue(rdtscp_call, {0})",
          "old_line_content": "",
          "new_line_content": "  return b->CreateExtractValue(rdtscp_call, {0});",
          "content_same": false
        },
        {
          "line": 2879,
          "old_api": null,
          "new_api": "ReadCycleCounter",
          "old_text": null,
          "new_text": "ReadCycleCounter(b)",
          "old_line_content": "  cycle_starts_[hlo] = cycle_start;",
          "new_line_content": "  auto* cycle_start = ReadCycleCounter(b);",
          "content_same": false
        },
        {
          "line": 2880,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(hlo, \"cycle_start\")",
          "old_line_content": "  if (first_read_cycle_start_ == nullptr) {",
          "new_line_content": "  cycle_start->setName(IrName(hlo, \"cycle_start\"));",
          "content_same": false
        },
        {
          "line": 2890,
          "old_api": null,
          "new_api": "ReadCycleCounter",
          "old_text": null,
          "new_text": "ReadCycleCounter(b)",
          "old_line_content": "  auto* cycle_start = cycle_starts_[hlo];",
          "new_line_content": "  auto* cycle_end = ReadCycleCounter(b);",
          "content_same": false
        },
        {
          "line": 2893,
          "old_api": null,
          "new_api": "UpdateProfileCounter",
          "old_text": null,
          "new_text": "UpdateProfileCounter(b, prof_counter, cycle_end, cycle_start)",
          "old_line_content": "}",
          "new_line_content": "  UpdateProfileCounter(b, prof_counter, cycle_end, cycle_start);",
          "content_same": false
        },
        {
          "line": 2900,
          "old_api": null,
          "new_api": "UpdateProfileCounter",
          "old_text": null,
          "new_text": "UpdateProfileCounter(b, prof_counter, last_read_cycle_end_,\n                         first_read_cycle_start_)",
          "old_line_content": "  }",
          "new_line_content": "    UpdateProfileCounter(b, prof_counter, last_read_cycle_end_,",
          "content_same": false
        },
        {
          "line": 2912,
          "old_api": null,
          "new_api": "getInt8Ty",
          "old_text": null,
          "new_text": "b->getInt8Ty()->getPointerTo()",
          "old_line_content": "      int8_ptr_type;  // LLVM does not have a void*, we use an int8* instead.",
          "new_line_content": "  llvm::Type* int8_ptr_type = b->getInt8Ty()->getPointerTo();",
          "content_same": false
        },
        {
          "line": 2916,
          "old_api": null,
          "new_api": "getInt64Ty",
          "old_text": null,
          "new_text": "b->getInt64Ty()",
          "old_line_content": "",
          "new_line_content": "      llvm::FunctionType::get(b->getInt64Ty(), {void_ptr_type, int8_ptr_type},",
          "content_same": false
        },
        {
          "line": 2919,
          "old_api": null,
          "new_api": "GetInsertBlock",
          "old_text": null,
          "new_text": "b->GetInsertBlock()->getParent()",
          "old_line_content": "  const char* fn_name = runtime::kTracingStartSymbolName;",
          "new_line_content": "  llvm::Function* function = b->GetInsertBlock()->getParent();",
          "content_same": false
        },
        {
          "line": 2920,
          "old_api": null,
          "new_api": "getParent",
          "old_text": null,
          "new_text": "function->getParent()",
          "old_line_content": "  llvm::FunctionCallee trace_func =",
          "new_line_content": "  llvm::Module* module = function->getParent();",
          "content_same": false
        },
        {
          "line": 2926,
          "old_api": null,
          "new_api": "setDoesNotThrow",
          "old_text": null,
          "new_text": "fn->setDoesNotThrow()",
          "old_line_content": "  }",
          "new_line_content": "    fn->setDoesNotThrow();",
          "content_same": false
        },
        {
          "line": 2932,
          "old_api": null,
          "new_api": "CreateBitCast",
          "old_text": null,
          "new_text": "b->CreateBitCast(hlo_name, int8_ptr_type)",
          "old_line_content": "  activity_ids_[hlo] = activity_id;",
          "new_line_content": "                                 b->CreateBitCast(hlo_name, int8_ptr_type)});",
          "content_same": false
        },
        {
          "line": 2933,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(hlo, \"activity_id\")",
          "old_line_content": "}",
          "new_line_content": "  activity_id->setName(IrName(hlo, \"activity_id\"));",
          "content_same": false
        },
        {
          "line": 2945,
          "old_api": null,
          "new_api": "getInt8Ty",
          "old_text": null,
          "new_text": "b->getInt8Ty()->getPointerTo()",
          "old_line_content": "  llvm::FunctionType* fn_type =",
          "new_line_content": "      b->getInt8Ty()->getPointerTo();  // LLVM does not have a void*, we use an",
          "content_same": false
        },
        {
          "line": 2948,
          "old_api": null,
          "new_api": "getInt64Ty",
          "old_text": null,
          "new_text": "b->getInt64Ty()",
          "old_line_content": "",
          "new_line_content": "      llvm::FunctionType::get(b->getVoidTy(), {void_ptr_type, b->getInt64Ty()},",
          "content_same": false
        },
        {
          "line": 2951,
          "old_api": null,
          "new_api": "GetInsertBlock",
          "old_text": null,
          "new_text": "b->GetInsertBlock()->getParent()",
          "old_line_content": "  const char* fn_name = runtime::kTracingEndSymbolName;",
          "new_line_content": "  llvm::Function* function = b->GetInsertBlock()->getParent();",
          "content_same": false
        },
        {
          "line": 2952,
          "old_api": null,
          "new_api": "getParent",
          "old_text": null,
          "new_text": "function->getParent()",
          "old_line_content": "  llvm::FunctionCallee trace_func =",
          "new_line_content": "  llvm::Module* module = function->getParent();",
          "content_same": false
        },
        {
          "line": 2958,
          "old_api": null,
          "new_api": "setDoesNotThrow",
          "old_text": null,
          "new_text": "fn->setDoesNotThrow()",
          "old_line_content": "  }",
          "new_line_content": "    fn->setDoesNotThrow();",
          "content_same": false
        },
        {
          "line": 2962,
          "old_api": null,
          "new_api": "CreateCall",
          "old_text": null,
          "new_text": "b->CreateCall(trace_func,\n                {b->CreateBitCast(run_options, void_ptr_type), activity_id})",
          "old_line_content": "}",
          "new_line_content": "  b->CreateCall(trace_func,",
          "content_same": false
        },
        {
          "line": 2963,
          "old_api": null,
          "new_api": "CreateBitCast",
          "old_text": null,
          "new_text": "b->CreateBitCast(run_options, void_ptr_type)",
          "old_line_content": "",
          "new_line_content": "                {b->CreateBitCast(run_options, void_ptr_type), activity_id});",
          "content_same": false
        },
        {
          "line": 2971,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "hlo->opcode()",
          "old_line_content": "}",
          "new_line_content": "         hlo->opcode() == HloOpcode::kParameter ||",
          "content_same": false
        },
        {
          "line": 2972,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "hlo->opcode()",
          "old_line_content": "}  // namespace",
          "new_line_content": "         hlo->opcode() == HloOpcode::kConstant;",
          "content_same": false
        },
        {
          "line": 2982,
          "old_api": null,
          "new_api": "GetExecutableRunOptionsArgument",
          "old_text": null,
          "new_text": "GetExecutableRunOptionsArgument()",
          "old_line_content": "  }",
          "new_line_content": "                                    GetExecutableRunOptionsArgument());",
          "content_same": false
        },
        {
          "line": 2985,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2989,
          "old_api": null,
          "new_api": "GetProfileCounterFor",
          "old_text": null,
          "new_text": "GetProfileCounterFor(*hlo)",
          "old_line_content": "  }",
          "new_line_content": "  if (auto* prof_counter = GetProfileCounterFor(*hlo)) {",
          "content_same": false
        },
        {
          "line": 2990,
          "old_api": null,
          "new_api": "RecordCycleDelta",
          "old_text": null,
          "new_text": "profiling_state_.RecordCycleDelta(&b_, hlo, prof_counter)",
          "old_line_content": "  // When profiling is enabled, trace the same HLOs that the profiler does.",
          "new_line_content": "    profiling_state_.RecordCycleDelta(&b_, hlo, prof_counter);",
          "content_same": false
        },
        {
          "line": 2994,
          "old_api": null,
          "new_api": "IsHloVeryCheap",
          "old_text": null,
          "new_text": "IsHloVeryCheap(hlo)",
          "old_line_content": "  }",
          "new_line_content": "      (hlo_module_config_.cpu_traceme_enabled() && !IsHloVeryCheap(hlo))) {",
          "content_same": false
        },
        {
          "line": 2997,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3003,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "hlo->shape()",
          "old_line_content": "  return array;",
          "new_line_content": "  llvm_ir::IrArray array(value_for_op, hlo->shape());",
          "content_same": false
        },
        {
          "line": 3004,
          "old_api": null,
          "new_api": "AddAliasingInformationToIrArray",
          "old_text": null,
          "new_text": "AddAliasingInformationToIrArray(*hlo, &array)",
          "old_line_content": "}",
          "new_line_content": "  AddAliasingInformationToIrArray(*hlo, &array);",
          "content_same": false
        },
        {
          "line": 3013,
          "old_api": null,
          "new_api": "std::back_inserter(arrays)",
          "old_text": null,
          "new_text": "std::back_inserter(arrays)",
          "old_line_content": "  return arrays;",
          "new_line_content": "      std::back_inserter(arrays),",
          "content_same": false
        },
        {
          "line": 3014,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(operand)",
          "old_line_content": "}",
          "new_line_content": "      [&](const HloInstruction* operand) { return GetIrArrayFor(operand); });",
          "content_same": false
        },
        {
          "line": 3020,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "emitted_value_.end()",
          "old_line_content": "  }",
          "new_line_content": "  if (it == emitted_value_.end()) {",
          "content_same": false
        },
        {
          "line": 3021,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "hlo->ToString()",
          "old_line_content": "  return it->second;",
          "new_line_content": "    LOG(FATAL) << \"could not find emitted value for: \" << hlo->ToString();",
          "content_same": false
        },
        {
          "line": 3027,
          "old_api": null,
          "new_api": "llvm_ir::ShapeToIrType(shape, module_)",
          "old_text": null,
          "new_text": "llvm_ir::ShapeToIrType(shape, module_)",
          "old_line_content": "",
          "new_line_content": "  return llvm_ir::ShapeToIrType(shape, module_);",
          "content_same": false
        },
        {
          "line": 3031,
          "old_api": null,
          "new_api": "profile_counters_arg",
          "old_text": null,
          "new_text": "compute_function_->profile_counters_arg()",
          "old_line_content": "",
          "new_line_content": "  return compute_function_->profile_counters_arg();",
          "content_same": false
        },
        {
          "line": 3035,
          "old_api": null,
          "new_api": "buffer_table_arg",
          "old_text": null,
          "new_text": "compute_function_->buffer_table_arg()",
          "old_line_content": "",
          "new_line_content": "  return compute_function_->buffer_table_arg();",
          "content_same": false
        },
        {
          "line": 3039,
          "old_api": null,
          "new_api": "exec_run_options_arg",
          "old_text": null,
          "new_text": "compute_function_->exec_run_options_arg()",
          "old_line_content": "",
          "new_line_content": "  return compute_function_->exec_run_options_arg();",
          "content_same": false
        },
        {
          "line": 3044,
          "old_api": null,
          "new_api": "allocation",
          "old_text": null,
          "new_text": "slice.allocation()",
          "old_line_content": "    auto param_it =",
          "new_line_content": "  const BufferAllocation& allocation = *slice.allocation();",
          "content_same": false
        },
        {
          "line": 3047,
          "old_api": null,
          "new_api": "allocation",
          "old_text": null,
          "new_text": "slice.allocation()->index()",
          "old_line_content": "      int64 param_number = param_it->second;",
          "new_line_content": "        computation_parameter_allocations_.find(slice.allocation()->index());",
          "content_same": false
        },
        {
          "line": 3048,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "computation_parameter_allocations_.end()",
          "old_line_content": "      // We have to access the parameter at offset param_number in the params",
          "new_line_content": "    if (param_it != computation_parameter_allocations_.end()) {",
          "content_same": false
        },
        {
          "line": 3060,
          "old_api": null,
          "new_api": "llvm_ir::EmitBufferIndexingGEP(params, param_number, &b_)",
          "old_text": null,
          "new_text": "llvm_ir::EmitBufferIndexingGEP(params, param_number, &b_)",
          "old_line_content": "",
          "new_line_content": "          llvm_ir::EmitBufferIndexingGEP(params, param_number, &b_);",
          "content_same": false
        },
        {
          "line": 3064,
          "old_api": null,
          "new_api": "AttachAlignmentMetadataForLoad",
          "old_text": null,
          "new_text": "AttachAlignmentMetadataForLoad(param_address_untyped, target_shape)",
          "old_line_content": "                                             target_shape);",
          "new_line_content": "        AttachAlignmentMetadataForLoad(param_address_untyped, target_shape);",
          "content_same": false
        },
        {
          "line": 3065,
          "old_api": null,
          "new_api": "AttachDereferenceableMetadataForLoad",
          "old_text": null,
          "new_text": "AttachDereferenceableMetadataForLoad(param_address_untyped,\n                                             target_shape)",
          "old_line_content": "      }",
          "new_line_content": "        AttachDereferenceableMetadataForLoad(param_address_untyped,",
          "content_same": false
        },
        {
          "line": 3073,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "assigned_buffers.size()",
          "old_line_content": "",
          "new_line_content": "    CHECK_EQ(1, assigned_buffers.size());",
          "content_same": false
        },
        {
          "line": 3074,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "assigned_buffers.begin()->first->shape()",
          "old_line_content": "    std::pair<llvm::Function*, BufferAllocation::Slice> key = {",
          "new_line_content": "    const Shape& shape = assigned_buffers.begin()->first->shape();",
          "content_same": false
        },
        {
          "line": 3083,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "thread_local_buffers_.insert({key, buffer})",
          "old_line_content": "      buf_it = it_inserted_pair.first;",
          "new_line_content": "      auto it_inserted_pair = thread_local_buffers_.insert({key, buffer});",
          "content_same": false
        },
        {
          "line": 3084,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(it_inserted_pair.second)",
          "old_line_content": "    }",
          "new_line_content": "      CHECK(it_inserted_pair.second);",
          "content_same": false
        },
        {
          "line": 3089,
          "old_api": null,
          "new_api": "getPointerTo",
          "old_text": null,
          "new_text": "IrShapeType(target_shape)->getPointerTo()",
          "old_line_content": "",
          "new_line_content": "  return BitCast(tempbuf_address, IrShapeType(target_shape)->getPointerTo());",
          "content_same": false
        },
        {
          "line": 3097,
          "old_api": null,
          "new_api": "Load",
          "old_text": null,
          "new_text": "Load(tempbuf_address_ptr)",
          "old_line_content": "          .xla_llvm_enable_invariant_load_metadata()) {",
          "new_line_content": "  llvm::LoadInst* tempbuf_address_base = Load(tempbuf_address_ptr);",
          "content_same": false
        },
        {
          "line": 3104,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "allocation.size()",
          "old_line_content": "",
          "new_line_content": "  AttachAlignmentMetadataForLoad(tempbuf_address_base, allocation.size());",
          "content_same": false
        },
        {
          "line": 3105,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "allocation.size()",
          "old_line_content": "  llvm::Value* tempbuf_address_untyped = tempbuf_address_base;",
          "new_line_content": "  AttachDereferenceableMetadataForLoad(tempbuf_address_base, allocation.size());",
          "content_same": false
        },
        {
          "line": 3108,
          "old_api": null,
          "new_api": "offset",
          "old_text": null,
          "new_text": "slice.offset()",
          "old_line_content": "    tempbuf_address_untyped =",
          "new_line_content": "  if (slice.offset() > 0) {",
          "content_same": false
        },
        {
          "line": 3113,
          "old_api": null,
          "new_api": "getPointerTo",
          "old_text": null,
          "new_text": "BitCast(tempbuf_address_untyped,\n                 IrShapeType(target_shape)->getPointerTo())",
          "old_line_content": "}",
          "new_line_content": "  return BitCast(tempbuf_address_untyped,",
          "content_same": false
        },
        {
          "line": 3114,
          "old_api": null,
          "new_api": "getPointerTo",
          "old_text": null,
          "new_text": "IrShapeType(target_shape)->getPointerTo()",
          "old_line_content": "",
          "new_line_content": "                 IrShapeType(target_shape)->getPointerTo());",
          "content_same": false
        },
        {
          "line": 3123,
          "old_api": null,
          "new_api": "allocation",
          "old_text": null,
          "new_text": "slice.allocation()->index()",
          "old_line_content": "  } else {",
          "new_line_content": "        FindOrDie(constant_buffer_to_global_, slice.allocation()->index()),",
          "content_same": false
        },
        {
          "line": 3126,
          "old_api": null,
          "new_api": "EmitGlobalBufferPointer",
          "old_text": null,
          "new_text": "EmitGlobalBufferPointer(slice, target_shape)",
          "old_line_content": "}",
          "new_line_content": "    return EmitGlobalBufferPointer(slice, target_shape);",
          "content_same": false
        },
        {
          "line": 3131,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "op->shape()",
          "old_line_content": "                      assignment_.GetUniqueTopLevelSlice(op));",
          "new_line_content": "  const Shape& target_shape = op->shape();",
          "content_same": false
        },
        {
          "line": 3134,
          "old_api": null,
          "new_api": "EmitBufferPointer",
          "old_text": null,
          "new_text": "EmitBufferPointer(slice, target_shape)",
          "old_line_content": "  emitted_value_[op] = addr;",
          "new_line_content": "  llvm::Value* addr = EmitBufferPointer(slice, target_shape);",
          "content_same": false
        },
        {
          "line": 3137,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3143,
          "old_api": null,
          "new_api": "EmitTargetElementLoop",
          "old_text": null,
          "new_text": "EmitTargetElementLoop(target_op, /*desc=*/\"\", element_generator)",
          "old_line_content": "",
          "new_line_content": "  return EmitTargetElementLoop(target_op, /*desc=*/\"\", element_generator);",
          "content_same": false
        },
        {
          "line": 3152,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(target_op)",
          "old_line_content": "",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(target_op));",
          "content_same": false
        },
        {
          "line": 3157,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "target_op->opcode()",
          "old_line_content": "    // For multiple outputs fusion, we need to emit each operand and the root.",
          "new_line_content": "       target_op->opcode() == HloOpcode::kReduce ||",
          "content_same": false
        },
        {
          "line": 3162,
          "old_api": null,
          "new_api": "ShapeUtil::TupleElementCount(target_shape)",
          "old_text": null,
          "new_text": "ShapeUtil::TupleElementCount(target_shape)",
          "old_line_content": "                          assignment_.GetUniqueSlice(target_op, {i}));",
          "new_line_content": "    for (int64 i = 0; i < ShapeUtil::TupleElementCount(target_shape); ++i) {",
          "content_same": false
        },
        {
          "line": 3167,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "output_arrays.push_back(\n          llvm_ir::IrArray(op_target_address, element_shape))",
          "old_line_content": "    }",
          "new_line_content": "      output_arrays.push_back(",
          "content_same": false
        },
        {
          "line": 3171,
          "old_api": null,
          "new_api": "EmitLoop",
          "old_text": null,
          "new_text": "llvm_ir::LoopEmitter(element_generator, output_arrays, &b_)\n            .EmitLoop(IrName(target_op))",
          "old_line_content": "",
          "new_line_content": "        llvm_ir::LoopEmitter(element_generator, output_arrays, &b_)",
          "content_same": false
        },
        {
          "line": 3172,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(target_op)",
          "old_line_content": "    std::vector<llvm::Value*> tuple_operand_ptrs;",
          "new_line_content": "            .EmitLoop(IrName(target_op)));",
          "content_same": false
        },
        {
          "line": 3175,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "output_arrays.size()",
          "old_line_content": "    }",
          "new_line_content": "    for (int64 i = 0; i < output_arrays.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 3178,
          "old_api": null,
          "new_api": "llvm_ir::EmitTuple(target_array, tuple_operand_ptrs, &b_)",
          "old_text": null,
          "new_text": "llvm_ir::EmitTuple(target_array, tuple_operand_ptrs, &b_)",
          "old_line_content": "  } else {",
          "new_line_content": "    llvm_ir::EmitTuple(target_array, tuple_operand_ptrs, &b_);",
          "content_same": false
        },
        {
          "line": 3181,
          "old_api": null,
          "new_api": "ShouldEmitParallelLoopFor",
          "old_text": null,
          "new_text": "ShouldEmitParallelLoopFor(*target_op)",
          "old_line_content": "      std::vector<std::pair<llvm::Value*, llvm::Value*>> dynamic_loop_bounds =",
          "new_line_content": "    if (ShouldEmitParallelLoopFor(*target_op)) {",
          "content_same": false
        },
        {
          "line": 3191,
          "old_api": null,
          "new_api": "EmitLoop",
          "old_text": null,
          "new_text": "llvm_ir::LoopEmitter(element_generator, target_array, &b_)\n              .EmitLoop(IrName(target_op))",
          "old_line_content": "    }",
          "new_line_content": "          llvm_ir::LoopEmitter(element_generator, target_array, &b_)",
          "content_same": false
        },
        {
          "line": 3192,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(target_op)",
          "old_line_content": "  }",
          "new_line_content": "              .EmitLoop(IrName(target_op)));",
          "content_same": false
        },
        {
          "line": 3195,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3201,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(&destination)",
          "old_line_content": "  // TODO(b/63762267): Be more aggressive about specifying alignment.",
          "new_line_content": "  llvm::Value* destination_value = GetEmittedValueFor(&destination);",
          "content_same": false
        },
        {
          "line": 3205,
          "old_api": null,
          "new_api": "llvm::Align(1)",
          "old_text": null,
          "new_text": "llvm::Align(1)",
          "old_line_content": "}",
          "new_line_content": "         /*SrcAlign=*/llvm::Align(1), source_size);",
          "content_same": false
        },
        {
          "line": 3206,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3214,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "TF_RET_CHECK(\n        ShapeUtil::SameElementType(operands[0]->shape(), operand->shape()))",
          "old_line_content": "  }",
          "new_line_content": "    TF_RET_CHECK(",
          "content_same": false
        },
        {
          "line": 3215,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "operand->shape()",
          "old_line_content": "",
          "new_line_content": "        ShapeUtil::SameElementType(operands[0]->shape(), operand->shape()));",
          "content_same": false
        },
        {
          "line": 3222,
          "old_api": null,
          "new_api": "PrimitiveType_Name",
          "old_text": null,
          "new_text": "PrimitiveType_Name(primitive_type)",
          "old_line_content": "  }",
          "new_line_content": "                         PrimitiveType_Name(primitive_type),",
          "content_same": false
        },
        {
          "line": 3225,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3232,
          "old_api": null,
          "new_api": "EmitReadArrayElement",
          "old_text": null,
          "new_text": "GetIrArrayFor(operand).EmitReadArrayElement(index, &b_)",
          "old_line_content": "  }",
          "new_line_content": "      return GetIrArrayFor(operand).EmitReadArrayElement(index, &b_);",
          "content_same": false
        },
        {
          "line": 3236,
          "old_api": null,
          "new_api": "MakeElementGenerator",
          "old_text": null,
          "new_text": "EmitTargetElementLoop(\n      hlo, elemental_emitter.MakeElementGenerator(hlo, operand_to_generator))",
          "old_line_content": "}",
          "new_line_content": "  return EmitTargetElementLoop(",
          "content_same": false
        },
        {
          "line": 3237,
          "old_api": null,
          "new_api": "MakeElementGenerator",
          "old_text": null,
          "new_text": "elemental_emitter.MakeElementGenerator(hlo, operand_to_generator)",
          "old_line_content": "",
          "new_line_content": "      hlo, elemental_emitter.MakeElementGenerator(hlo, operand_to_generator));",
          "content_same": false
        },
        {
          "line": 3244,
          "old_api": null,
          "new_api": "EmitThreadLocalCall",
          "old_text": null,
          "new_text": "EmitThreadLocalCall(callee, parameters, name)",
          "old_line_content": "  return return_value[0];",
          "new_line_content": "      EmitThreadLocalCall(callee, parameters, name);",
          "content_same": false
        },
        {
          "line": 3245,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "return_value.size()",
          "old_line_content": "}",
          "new_line_content": "  CHECK_EQ(return_value.size(), 1);",
          "content_same": false
        },
        {
          "line": 3253,
          "old_api": null,
          "new_api": "root_instruction",
          "old_text": null,
          "new_text": "callee.root_instruction()->shape()",
          "old_line_content": "  bool is_tuple_of_scalars_return =",
          "new_line_content": "  const Shape& return_shape = callee.root_instruction()->shape();",
          "content_same": false
        },
        {
          "line": 3257,
          "old_api": null,
          "new_api": "tuple_shapes",
          "old_text": null,
          "new_text": "return_shape.tuple_shapes()",
          "old_line_content": "      });",
          "new_line_content": "      absl::c_all_of(return_shape.tuple_shapes(), [&](const Shape& shape) {",
          "content_same": false
        },
        {
          "line": 3260,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(is_scalar_return || is_tuple_of_scalars_return)",
          "old_line_content": "  std::vector<llvm::Value*> parameter_addrs;",
          "new_line_content": "  CHECK(is_scalar_return || is_tuple_of_scalars_return);",
          "content_same": false
        },
        {
          "line": 3267,
          "old_api": null,
          "new_api": "Store",
          "old_text": null,
          "new_text": "Store(parameter, parameter_addr)",
          "old_line_content": "  }",
          "new_line_content": "    Store(parameter, parameter_addr);",
          "content_same": false
        },
        {
          "line": 3268,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "parameter_addrs.push_back(parameter_addr)",
          "old_line_content": "",
          "new_line_content": "    parameter_addrs.push_back(parameter_addr);",
          "content_same": false
        },
        {
          "line": 3272,
          "old_api": null,
          "new_api": "llvm_ir::ShapeToIrType(return_shape, module_)",
          "old_text": null,
          "new_text": "llvm_ir::ShapeToIrType(return_shape, module_)",
          "old_line_content": "  int retval_alignment =",
          "new_line_content": "      llvm_ir::ShapeToIrType(return_shape, module_);",
          "content_same": false
        },
        {
          "line": 3273,
          "old_api": null,
          "new_api": "absl::StrCat(name, \"_return_value_addr\")",
          "old_text": null,
          "new_text": "absl::StrCat(name, \"_return_value_addr\")",
          "old_line_content": "      is_scalar_return",
          "new_line_content": "  std::string retval_alloca_name = absl::StrCat(name, \"_return_value_addr\");",
          "content_same": false
        },
        {
          "line": 3278,
          "old_api": null,
          "new_api": "llvm_ir::EmitAllocaAtFunctionEntry(\n      return_value_buffer_type, retval_alloca_name, &b_, retval_alignment)",
          "old_text": null,
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n      return_value_buffer_type, retval_alloca_name, &b_, retval_alignment)",
          "old_line_content": "",
          "new_line_content": "  llvm::Value* return_value_buffer = llvm_ir::EmitAllocaAtFunctionEntry(",
          "content_same": false
        },
        {
          "line": 3285,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "        << \"Multivalue function can not return more than 1000 elements to avoid\"",
          "new_line_content": "    constexpr int max_tuple_size = 1000;",
          "content_same": false
        },
        {
          "line": 3286,
          "old_api": null,
          "new_api": "tuple_shapes_size",
          "old_text": null,
          "new_text": "return_shape.tuple_shapes_size()",
          "old_line_content": "        << \" stack smashing\";",
          "new_line_content": "    CHECK_LT(return_shape.tuple_shapes_size(), max_tuple_size)",
          "content_same": false
        },
        {
          "line": 3290,
          "old_api": null,
          "new_api": "llvm_ir::EmitTupleAllocasAtFunctionEntry(return_shape, &b_)",
          "old_text": null,
          "new_text": "llvm_ir::EmitTupleAllocasAtFunctionEntry(return_shape, &b_)",
          "old_line_content": "",
          "new_line_content": "        llvm_ir::EmitTupleAllocasAtFunctionEntry(return_shape, &b_);",
          "content_same": false
        },
        {
          "line": 3293,
          "old_api": null,
          "new_api": "EmitTuple",
          "old_text": null,
          "new_text": "EmitTuple(tuple_array, allocas_for_returned_scalars, &b_)",
          "old_line_content": "",
          "new_line_content": "    EmitTuple(tuple_array, allocas_for_returned_scalars, &b_);",
          "content_same": false
        },
        {
          "line": 3296,
          "old_api": null,
          "new_api": "FindOrDie",
          "old_text": null,
          "new_text": "FindOrDie(emitted_functions_, &callee)",
          "old_line_content": "           parameter_addrs, &b_, name,",
          "new_line_content": "  Call(FindOrDie(emitted_functions_, &callee),",
          "content_same": false
        },
        {
          "line": 3297,
          "old_api": null,
          "new_api": "getInt8PtrTy",
          "old_text": null,
          "new_text": "GetArrayFunctionCallArguments(\n           parameter_addrs, &b_, name,\n           /*return_value_buffer=*/return_value_buffer,\n           /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),\n           /*buffer_table_arg=*/\n           llvm::Constant::getNullValue(b_.getInt8PtrTy()->getPointerTo()),\n           /*profile_counters_arg=*/GetProfileCountersArgument())",
          "old_line_content": "           /*return_value_buffer=*/return_value_buffer,",
          "new_line_content": "       GetArrayFunctionCallArguments(",
          "content_same": false
        },
        {
          "line": 3302,
          "old_api": null,
          "new_api": "getInt8PtrTy",
          "old_text": null,
          "new_text": "b_.getInt8PtrTy()->getPointerTo()",
          "old_line_content": "",
          "new_line_content": "           llvm::Constant::getNullValue(b_.getInt8PtrTy()->getPointerTo()),",
          "content_same": false
        },
        {
          "line": 3303,
          "old_api": null,
          "new_api": "GetProfileCountersArgument",
          "old_text": null,
          "new_text": "GetProfileCountersArgument()",
          "old_line_content": "  std::vector<llvm::Value*> returned_scalars;",
          "new_line_content": "           /*profile_counters_arg=*/GetProfileCountersArgument()));",
          "content_same": false
        },
        {
          "line": 3308,
          "old_api": null,
          "new_api": "Load",
          "old_text": null,
          "new_text": "Load(addr)",
          "old_line_content": "  return returned_scalars;",
          "new_line_content": "    returned_scalars.push_back(Load(addr));",
          "content_same": false
        },
        {
          "line": 3317,
          "old_api": null,
          "new_api": "FindOrDie",
          "old_text": null,
          "new_text": "FindOrDie(emitted_functions_, &callee)",
          "old_line_content": "           /*parameter_addresses=*/{}, &b_, name,",
          "new_line_content": "  Call(FindOrDie(emitted_functions_, &callee),",
          "content_same": false
        },
        {
          "line": 3318,
          "old_api": null,
          "new_api": "getInt8PtrTy",
          "old_text": null,
          "new_text": "GetArrayFunctionCallArguments(\n           /*parameter_addresses=*/{}, &b_, name,\n           /*return_value_buffer=*/\n           llvm::Constant::getNullValue(b_.getInt8PtrTy()),\n           /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),\n           /*buffer_table_arg=*/GetBufferTableArgument(),\n           /*profile_counters_arg=*/GetProfileCountersArgument())",
          "old_line_content": "           /*return_value_buffer=*/",
          "new_line_content": "       GetArrayFunctionCallArguments(",
          "content_same": false
        },
        {
          "line": 3323,
          "old_api": null,
          "new_api": "GetBufferTableArgument",
          "old_text": null,
          "new_text": "GetBufferTableArgument()",
          "old_line_content": "}",
          "new_line_content": "           /*buffer_table_arg=*/GetBufferTableArgument(),",
          "content_same": false
        },
        {
          "line": 3324,
          "old_api": null,
          "new_api": "GetProfileCountersArgument",
          "old_text": null,
          "new_text": "GetProfileCountersArgument()",
          "old_line_content": "",
          "new_line_content": "           /*profile_counters_arg=*/GetProfileCountersArgument()));",
          "content_same": false
        },
        {
          "line": 3330,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "root_inst->opcode()",
          "old_line_content": "  }",
          "new_line_content": "  if (root_inst->opcode() == HloOpcode::kOutfeed) {",
          "content_same": false
        },
        {
          "line": 3331,
          "old_api": null,
          "new_api": "getInt8PtrTy",
          "old_text": null,
          "new_text": "b_.getInt8PtrTy()",
          "old_line_content": "",
          "new_line_content": "    return llvm::Constant::getNullValue(b_.getInt8PtrTy());",
          "content_same": false
        },
        {
          "line": 3335,
          "old_api": null,
          "new_api": "GetUniqueTopLevelSlice",
          "old_text": null,
          "new_text": "assignment_.GetUniqueTopLevelSlice(root_inst).ValueOrDie()",
          "old_line_content": "}",
          "new_line_content": "      assignment_.GetUniqueTopLevelSlice(root_inst).ValueOrDie();",
          "content_same": false
        },
        {
          "line": 3336,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "root_inst->shape()",
          "old_line_content": "",
          "new_line_content": "  return EmitBufferPointer(root_buffer, root_inst->shape());",
          "content_same": false
        },
        {
          "line": 3343,
          "old_api": null,
          "new_api": "EmitReadArrayElement",
          "old_text": null,
          "new_text": "fused_emitter->BindGenerator(\n        fusion->fused_parameter(i),\n        [this, operand](llvm_ir::IrArray::Index index) {\n          return GetIrArrayFor(operand).EmitReadArrayElement(index, &b_);\n        })",
          "old_line_content": "        [this, operand](llvm_ir::IrArray::Index index) {",
          "new_line_content": "    fused_emitter->BindGenerator(",
          "content_same": false
        },
        {
          "line": 3346,
          "old_api": null,
          "new_api": "EmitReadArrayElement",
          "old_text": null,
          "new_text": "GetIrArrayFor(operand).EmitReadArrayElement(index, &b_)",
          "old_line_content": "  }",
          "new_line_content": "          return GetIrArrayFor(operand).EmitReadArrayElement(index, &b_);",
          "content_same": false
        },
        {
          "line": 1451,
          "old_api": null,
          "new_api": "debug_options",
          "old_text": null,
          "new_text": "hlo_module_config_.debug_options().xla_cpu_enable_fast_min_max()",
          "old_line_content": "        }",
          "new_line_content": "              hlo_module_config_.debug_options().xla_cpu_enable_fast_min_max());",
          "content_same": false
        },
        {
          "line": 1455,
          "old_api": null,
          "new_api": "CreateICmp",
          "old_text": null,
          "new_text": "b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SGE\n                                         : llvm::ICmpInst::ICMP_UGE,\n                          lhs, rhs)",
          "old_line_content": "                                         : llvm::ICmpInst::ICMP_UGE,",
          "new_line_content": "            b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SGE",
          "content_same": false
        },
        {
          "line": 1468,
          "old_api": null,
          "new_api": "debug_options",
          "old_text": null,
          "new_text": "hlo_module_config_.debug_options().xla_cpu_enable_fast_min_max()",
          "old_line_content": "",
          "new_line_content": "              hlo_module_config_.debug_options().xla_cpu_enable_fast_min_max());",
          "content_same": false
        },
        {
          "line": 1471,
          "old_api": null,
          "new_api": "CreateSelect",
          "old_text": null,
          "new_text": "b->CreateSelect(\n            b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SLE\n                                         : llvm::ICmpInst::ICMP_ULE,\n                          lhs, rhs),\n            lhs, rhs)",
          "old_line_content": "                                         : llvm::ICmpInst::ICMP_ULE,",
          "new_line_content": "        return b->CreateSelect(",
          "content_same": false
        },
        {
          "line": 1472,
          "old_api": null,
          "new_api": "CreateICmp",
          "old_text": null,
          "new_text": "b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SLE\n                                         : llvm::ICmpInst::ICMP_ULE,\n                          lhs, rhs)",
          "old_line_content": "                          lhs, rhs),",
          "new_line_content": "            b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SLE",
          "content_same": false
        },
        {
          "line": 1484,
          "old_api": null,
          "new_api": "function",
          "old_text": null,
          "new_text": "compute_function_->function()",
          "old_line_content": "",
          "new_line_content": "          *compute_function_->function()) /",
          "content_same": false
        },
        {
          "line": 1485,
          "old_api": null,
          "new_api": "ShapeUtil::ByteSizeOfPrimitiveType(element_type)",
          "old_text": null,
          "new_text": "ShapeUtil::ByteSizeOfPrimitiveType(element_type)",
          "old_line_content": "  ShardedVectorType sharded_vector_type;",
          "new_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(element_type);",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": null,
          "new_api": "tensorflow::Log2Ceiling(element_count)",
          "old_text": null,
          "new_text": "tensorflow::Log2Ceiling(element_count)",
          "old_line_content": "    // vector or scalar types.",
          "new_line_content": "  for (int i = 0, e = 1 + tensorflow::Log2Ceiling(element_count); i < e; i++) {",
          "content_same": false
        },
        {
          "line": 1502,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "sharded_vector_type.push_back(element_ir_type)",
          "old_line_content": "    }",
          "new_line_content": "      sharded_vector_type.push_back(element_ir_type);",
          "content_same": false
        },
        {
          "line": 1512,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "sharded_vector_type.insert(\n          sharded_vector_type.end(),\n          current_size_fragment / vector_register_size_in_elements,\n          vector_type)",
          "old_line_content": "          current_size_fragment / vector_register_size_in_elements,",
          "new_line_content": "      sharded_vector_type.insert(",
          "content_same": false
        },
        {
          "line": 1513,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "sharded_vector_type.end()",
          "old_line_content": "          vector_type);",
          "new_line_content": "          sharded_vector_type.end(),",
          "content_same": false
        },
        {
          "line": 1519,
          "old_api": null,
          "new_api": "CHECK_EQ",
          "old_text": null,
          "new_text": "CHECK_EQ(current_size_fragment % vector_register_size_in_elements, 0)",
          "old_line_content": "    }",
          "new_line_content": "      CHECK_EQ(current_size_fragment % vector_register_size_in_elements, 0);",
          "content_same": false
        },
        {
          "line": 1526,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "sharded_vector_type.push_back(\n        llvm::VectorType::get(element_ir_type, current_size_fragment, false))",
          "old_line_content": "  }",
          "new_line_content": "    sharded_vector_type.push_back(",
          "content_same": false
        },
        {
          "line": 1527,
          "old_api": null,
          "new_api": "llvm::VectorType::get(element_ir_type, current_size_fragment, false)",
          "old_text": null,
          "new_text": "llvm::VectorType::get(element_ir_type, current_size_fragment, false)",
          "old_line_content": "  return sharded_vector_type;",
          "new_line_content": "        llvm::VectorType::get(element_ir_type, current_size_fragment, false));",
          "content_same": false
        },
        {
          "line": 1542,
          "old_api": null,
          "new_api": "llvm_ir::EmitAllocaAtFunctionEntry(\n        accumulator_shard_type, \"accumulator\", &b_, 0)",
          "old_text": null,
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n        accumulator_shard_type, \"accumulator\", &b_, 0)",
          "old_line_content": "  }",
          "new_line_content": "    accumulator.push_back(llvm_ir::EmitAllocaAtFunctionEntry(",
          "content_same": false
        },
        {
          "line": 1546,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(init_value)",
          "old_line_content": "  for (llvm::Value* accumulator_shard : accumulator) {",
          "new_line_content": "  llvm::Value* init_value_ssa = Load(GetEmittedValueFor(init_value));",
          "content_same": false
        },
        {
          "line": 1550,
          "old_api": null,
          "new_api": "getType",
          "old_text": null,
          "new_text": "accumulator_shard->getType()->getPointerElementType()",
          "old_line_content": "      initial_value =",
          "new_line_content": "    auto shard_type = accumulator_shard->getType()->getPointerElementType();",
          "content_same": false
        },
        {
          "line": 1553,
          "old_api": null,
          "new_api": "getElementCount",
          "old_text": null,
          "new_text": "vector_type->getElementCount()",
          "old_line_content": "      initial_value = init_value_ssa;",
          "new_line_content": "          VectorSplat(vector_type->getElementCount(), init_value_ssa);",
          "content_same": false
        },
        {
          "line": 1558,
          "old_api": null,
          "new_api": "AlignedStore",
          "old_text": null,
          "new_text": "AlignedStore(initial_value, accumulator_shard, element_alignment)",
          "old_line_content": "",
          "new_line_content": "    AlignedStore(initial_value, accumulator_shard, element_alignment);",
          "content_same": false
        },
        {
          "line": 1561,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(arg, \"vectorized_inner\")",
          "old_line_content": "  std::vector<llvm::Value*> input_multi_index =",
          "new_line_content": "  llvm_ir::ForLoopNest reduction_loop_nest(IrName(arg, \"vectorized_inner\"),",
          "content_same": false
        },
        {
          "line": 1564,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "arg->shape()",
          "old_line_content": "",
          "new_line_content": "      reduction_loop_nest.AddLoopsForShapeOnDimensions(arg->shape(), dimensions,",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": null,
          "new_api": "GetInnerLoopBodyBasicBlock",
          "old_text": null,
          "new_text": "reduction_loop_nest.GetInnerLoopBodyBasicBlock()",
          "old_line_content": "  llvm_ir::IrArray arg_array(GetIrArrayFor(arg));",
          "new_line_content": "  SetToFirstInsertPoint(reduction_loop_nest.GetInnerLoopBodyBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 1570,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "output_index.begin()",
          "old_line_content": "  for (auto& i : input_multi_index) {",
          "new_line_content": "  llvm_ir::IrArray::Index::const_iterator it = output_index.begin();",
          "content_same": false
        },
        {
          "line": 1578,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "arg->shape()",
          "old_line_content": "",
          "new_line_content": "  llvm_ir::IrArray::Index input_index(input_multi_index, arg->shape(),",
          "content_same": false
        },
        {
          "line": 1581,
          "old_api": null,
          "new_api": "EmitArrayElementAddress",
          "old_text": null,
          "new_text": "BitCast(\n      arg_array.EmitArrayElementAddress(input_index, &b_), b_.getInt8PtrTy())",
          "old_line_content": "",
          "new_line_content": "  llvm::Value* input_address = BitCast(",
          "content_same": false
        },
        {
          "line": 1589,
          "old_api": null,
          "new_api": "AlignedLoad",
          "old_text": null,
          "new_text": "AlignedLoad(input_address_typed, element_alignment)",
          "old_line_content": "",
          "new_line_content": "    auto addend = AlignedLoad(input_address_typed, element_alignment);",
          "content_same": false
        },
        {
          "line": 1590,
          "old_api": null,
          "new_api": "AnnotateLoadStoreInstructionWithMetadata",
          "old_text": null,
          "new_text": "arg_array.AnnotateLoadStoreInstructionWithMetadata(addend)",
          "old_line_content": "    auto reduced_result =",
          "new_line_content": "    arg_array.AnnotateLoadStoreInstructionWithMetadata(addend);",
          "content_same": false
        },
        {
          "line": 1593,
          "old_api": null,
          "new_api": "reduction_generator",
          "old_text": null,
          "new_text": "reduction_generator(&b_, current_accumulator_value, addend)",
          "old_line_content": "",
          "new_line_content": "        reduction_generator(&b_, current_accumulator_value, addend);",
          "content_same": false
        },
        {
          "line": 1596,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "accumulator.size()",
          "old_line_content": "                                           input_address_typed, 1);",
          "new_line_content": "    if (i != (accumulator.size() - 1)) {",
          "content_same": false
        },
        {
          "line": 1597,
          "old_api": null,
          "new_api": "getType",
          "old_text": null,
          "new_text": "reduced_result->getType()",
          "old_line_content": "    }",
          "new_line_content": "      input_address = ConstInBoundsGEP1_32(reduced_result->getType(),",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": null,
          "new_api": "GetOuterLoopExitBasicBlock",
          "old_text": null,
          "new_text": "reduction_loop_nest.GetOuterLoopExitBasicBlock()",
          "old_line_content": "  ShardedVector result_ssa;",
          "new_line_content": "  SetToFirstInsertPoint(reduction_loop_nest.GetOuterLoopExitBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 1607,
          "old_api": null,
          "new_api": "AlignedLoad",
          "old_text": null,
          "new_text": "AlignedLoad(accumulator_shard, element_alignment)",
          "old_line_content": "  return result_ssa;",
          "new_line_content": "    result_ssa.push_back(AlignedLoad(accumulator_shard, element_alignment));",
          "content_same": false
        },
        {
          "line": 1617,
          "old_api": null,
          "new_api": "getType",
          "old_text": null,
          "new_text": "BitCast(store_address,\n                llvm::PointerType::getUnqual(value_to_store[i]->getType()))",
          "old_line_content": "",
          "new_line_content": "        BitCast(store_address,",
          "content_same": false
        },
        {
          "line": 1618,
          "old_api": null,
          "new_api": "getType",
          "old_text": null,
          "new_text": "value_to_store[i]->getType()",
          "old_line_content": "    auto store_instruction =",
          "new_line_content": "                llvm::PointerType::getUnqual(value_to_store[i]->getType()));",
          "content_same": false
        },
        {
          "line": 1621,
          "old_api": null,
          "new_api": "AlignedStore",
          "old_text": null,
          "new_text": "AlignedStore(value_to_store[i], store_address_typed, alignment)",
          "old_line_content": "        store_instruction);",
          "new_line_content": "        AlignedStore(value_to_store[i], store_address_typed, alignment);",
          "content_same": false
        },
        {
          "line": 1622,
          "old_api": null,
          "new_api": "AnnotateLoadStoreInstructionWithMetadata",
          "old_text": null,
          "new_text": "containing_array.AnnotateLoadStoreInstructionWithMetadata(\n        store_instruction)",
          "old_line_content": "",
          "new_line_content": "    containing_array.AnnotateLoadStoreInstructionWithMetadata(",
          "content_same": false
        },
        {
          "line": 1625,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "value_to_store.size()",
          "old_line_content": "                                           store_address_typed, 1);",
          "new_line_content": "    if (i != (value_to_store.size() - 1)) {",
          "content_same": false
        },
        {
          "line": 1626,
          "old_api": null,
          "new_api": "getType",
          "old_text": null,
          "new_text": "value_to_store[i]->getType()",
          "old_line_content": "    }",
          "new_line_content": "      store_address = ConstInBoundsGEP1_32(value_to_store[i]->getType(),",
          "content_same": false
        },
        {
          "line": 1636,
          "old_api": null,
          "new_api": "IsArray",
          "old_text": null,
          "new_text": "reduce->shape().IsArray()",
          "old_line_content": "    return false;",
          "new_line_content": "  if (!reduce->shape().IsArray()) {",
          "content_same": false
        },
        {
          "line": 1641,
          "old_api": null,
          "new_api": "ReductionPreservesLayout",
          "old_text": null,
          "new_text": "ReductionPreservesLayout(*reduce)",
          "old_line_content": "  }",
          "new_line_content": "  if (!ReductionPreservesLayout(*reduce)) {",
          "content_same": false
        },
        {
          "line": 1646,
          "old_api": null,
          "new_api": "MatchReductionGenerator",
          "old_text": null,
          "new_text": "MatchReductionGenerator(function, failure_reason)",
          "old_line_content": "    return false;",
          "new_line_content": "      MatchReductionGenerator(function, failure_reason);",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": null,
          "new_api": "function",
          "old_text": null,
          "new_text": "compute_function_->function()",
          "old_line_content": "  if (vector_register_size_in_elements == 0) {",
          "new_line_content": "          *compute_function_->function()) /",
          "content_same": false
        },
        {
          "line": 1654,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "reduce->shape().element_type()",
          "old_line_content": "    // Either we don't know the vector register width for the target or the",
          "new_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(reduce->shape().element_type());",
          "content_same": false
        },
        {
          "line": 1662,
          "old_api": null,
          "new_api": "vectorization_factor_in_bytes",
          "old_text": null,
          "new_text": "target_machine_features_.vectorization_factor_in_bytes()",
          "old_line_content": "  // We try to process vectorization_factor elements at the same time.",
          "new_line_content": "      target_machine_features_.vectorization_factor_in_bytes();",
          "content_same": false
        },
        {
          "line": 1669,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "absl::c_linear_search(\n      dimensions, LayoutUtil::Minor(arg->shape().layout(), 0))",
          "old_line_content": "",
          "new_line_content": "  bool is_reduction_over_minor_dimension = absl::c_linear_search(",
          "content_same": false
        },
        {
          "line": 1673,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "reduce->shape().element_type()",
          "old_line_content": "",
          "new_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(reduce->shape().element_type()),",
          "content_same": false
        },
        {
          "line": 1674,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "reduce->shape().element_type()",
          "old_line_content": "  if (is_reduction_over_minor_dimension) {",
          "new_line_content": "      MinimumAlignmentForPrimitiveType(reduce->shape().element_type())));",
          "content_same": false
        },
        {
          "line": 1682,
          "old_api": null,
          "new_api": "IsTuple",
          "old_text": null,
          "new_text": "reduce->shape().IsTuple()",
          "old_line_content": "",
          "new_line_content": "  CHECK(!reduce->shape().IsTuple());",
          "content_same": false
        },
        {
          "line": 1683,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(reduce)",
          "old_line_content": "  // We know we're not reducing over the most minor dimension, which means we",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(reduce));",
          "content_same": false
        },
        {
          "line": 1707,
          "old_api": null,
          "new_api": "dimensions_size",
          "old_text": null,
          "new_text": "reduce->shape().dimensions_size()",
          "old_line_content": "       --i) {",
          "new_line_content": "      reduce->shape().dimensions_size());",
          "content_same": false
        },
        {
          "line": 1714,
          "old_api": null,
          "new_api": "absl::StrFormat(\"dim.%d\", dimension)",
          "old_text": null,
          "new_text": "absl::StrFormat(\"dim.%d\", dimension)",
          "old_line_content": "  }",
          "new_line_content": "        start_index, end_index, absl::StrFormat(\"dim.%d\", dimension));",
          "content_same": false
        },
        {
          "line": 1715,
          "old_api": null,
          "new_api": "GetIndVarValue",
          "old_text": null,
          "new_text": "loop->GetIndVarValue()",
          "old_line_content": "",
          "new_line_content": "    array_multi_index[dimension] = loop->GetIndVarValue();",
          "content_same": false
        },
        {
          "line": 1720,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "reduce->shape().dimensions(innermost_dimension)",
          "old_line_content": "  if (llvm::BasicBlock* innermost_body_bb =",
          "new_line_content": "      reduce->shape().dimensions(innermost_dimension);",
          "content_same": false
        },
        {
          "line": 1723,
          "old_api": null,
          "new_api": "GetInnerLoopBodyBasicBlock",
          "old_text": null,
          "new_text": "loop_nest.GetInnerLoopBodyBasicBlock()",
          "old_line_content": "  }",
          "new_line_content": "          loop_nest.GetInnerLoopBodyBasicBlock()) {",
          "content_same": false
        },
        {
          "line": 1724,
          "old_api": null,
          "new_api": "SetToFirstInsertPoint",
          "old_text": null,
          "new_text": "SetToFirstInsertPoint(innermost_body_bb, &b_)",
          "old_line_content": "",
          "new_line_content": "    SetToFirstInsertPoint(innermost_body_bb, &b_);",
          "content_same": false
        },
        {
          "line": 1727,
          "old_api": null,
          "new_api": "GetOuterLoopExitBasicBlock",
          "old_text": null,
          "new_text": "loop_nest.GetOuterLoopExitBasicBlock()",
          "old_line_content": "  if (innermost_dimension_size >= vectorization_factor) {",
          "new_line_content": "  auto outermost_loop_exit_block = loop_nest.GetOuterLoopExitBasicBlock();",
          "content_same": false
        },
        {
          "line": 1735,
          "old_api": null,
          "new_api": "absl::StrFormat(\"dim.%d\", innermost_dimension)",
          "old_text": null,
          "new_text": "absl::StrFormat(\"dim.%d\", innermost_dimension)",
          "old_line_content": "",
          "new_line_content": "                          absl::StrFormat(\"dim.%d\", innermost_dimension));",
          "content_same": false
        },
        {
          "line": 1742,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "reduce->shape()",
          "old_line_content": "    TF_ASSIGN_OR_RETURN(std::vector<llvm::Value*> accumulator,",
          "new_line_content": "    llvm_ir::IrArray::Index array_index(array_multi_index, reduce->shape(),",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": null,
          "new_api": "getInt64Ty",
          "old_text": null,
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "                        EmitInnerLoopForVectorizedReduction(",
          "new_line_content": "                                        b_.getInt64Ty());",
          "content_same": false
        },
        {
          "line": 1751,
          "old_api": null,
          "new_api": "EmitArrayElementAddress",
          "old_text": null,
          "new_text": "target_array.EmitArrayElementAddress(array_index, &b_)",
          "old_line_content": "                           target_array);",
          "new_line_content": "        target_array.EmitArrayElementAddress(array_index, &b_);",
          "content_same": false
        },
        {
          "line": 1752,
          "old_api": null,
          "new_api": "EmitShardedVectorStore",
          "old_text": null,
          "new_text": "EmitShardedVectorStore(output_address, accumulator, element_alignment,\n                           target_array)",
          "old_line_content": "",
          "new_line_content": "    EmitShardedVectorStore(output_address, accumulator, element_alignment,",
          "content_same": false
        },
        {
          "line": 1756,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "reduce->shape()",
          "old_line_content": "    } else {",
          "new_line_content": "      CHECK_GT(LayoutUtil::MinorToMajor(reduce->shape()).size(), 1);",
          "content_same": false
        },
        {
          "line": 1759,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "reduce->shape()",
          "old_line_content": "    }",
          "new_line_content": "      CHECK_EQ(LayoutUtil::MinorToMajor(reduce->shape()).size(), 1);",
          "content_same": false
        },
        {
          "line": 1760,
          "old_api": null,
          "new_api": "GetExitBasicBlock",
          "old_text": null,
          "new_text": "loop->GetExitBasicBlock()",
          "old_line_content": "  }",
          "new_line_content": "      b_.SetInsertPoint(loop->GetExitBasicBlock());",
          "content_same": false
        },
        {
          "line": 1770,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "b_.getInt64(innermost_dimension_size -\n                    (innermost_dimension_size % vectorization_factor))",
          "old_line_content": "",
          "new_line_content": "        b_.getInt64(innermost_dimension_size -",
          "content_same": false
        },
        {
          "line": 1773,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "CreateShardedVectorType(\n        reduce->shape().element_type(),\n        innermost_dimension_size % vectorization_factor)",
          "old_line_content": "        innermost_dimension_size % vectorization_factor);",
          "new_line_content": "    ShardedVectorType vector_type = CreateShardedVectorType(",
          "content_same": false
        },
        {
          "line": 1776,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "reduce->shape()",
          "old_line_content": "    TF_ASSIGN_OR_RETURN(std::vector<llvm::Value*> accumulator,",
          "new_line_content": "    llvm_ir::IrArray::Index array_index(array_multi_index, reduce->shape(),",
          "content_same": false
        },
        {
          "line": 1777,
          "old_api": null,
          "new_api": "getInt64Ty",
          "old_text": null,
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "                        EmitInnerLoopForVectorizedReduction(",
          "new_line_content": "                                        b_.getInt64Ty());",
          "content_same": false
        },
        {
          "line": 1785,
          "old_api": null,
          "new_api": "EmitArrayElementAddress",
          "old_text": null,
          "new_text": "target_array.EmitArrayElementAddress(array_index, &b_)",
          "old_line_content": "                           target_array);",
          "new_line_content": "        target_array.EmitArrayElementAddress(array_index, &b_);",
          "content_same": false
        },
        {
          "line": 1786,
          "old_api": null,
          "new_api": "EmitShardedVectorStore",
          "old_text": null,
          "new_text": "EmitShardedVectorStore(output_address, accumulator, element_alignment,\n                           target_array)",
          "old_line_content": "  }",
          "new_line_content": "    EmitShardedVectorStore(output_address, accumulator, element_alignment,",
          "content_same": false
        },
        {
          "line": 1791,
          "old_api": null,
          "new_api": "SetInsertPoint",
          "old_text": null,
          "new_text": "b_.SetInsertPoint(outermost_loop_exit_block)",
          "old_line_content": "",
          "new_line_content": "    b_.SetInsertPoint(outermost_loop_exit_block);",
          "content_same": false
        },
        {
          "line": 1801,
          "old_api": null,
          "new_api": "to_apply",
          "old_text": null,
          "new_text": "reduce->to_apply()",
          "old_line_content": "    string vectorization_failure_reason;",
          "new_line_content": "  HloComputation* function = reduce->to_apply();",
          "content_same": false
        },
        {
          "line": 1802,
          "old_api": null,
          "new_api": "options::VectorizedReduceDisabled(hlo_module_config_)",
          "old_text": null,
          "new_text": "options::VectorizedReduceDisabled(hlo_module_config_)",
          "old_line_content": "    TF_ASSIGN_OR_RETURN(",
          "new_line_content": "  if (!options::VectorizedReduceDisabled(hlo_module_config_)) {",
          "content_same": false
        },
        {
          "line": 1813,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "reduce->ToString()",
          "old_line_content": "    }",
          "new_line_content": "      VLOG(1) << \"Could not vectorize reduction \" << reduce->ToString() << \": \"",
          "content_same": false
        },
        {
          "line": 1818,
          "old_api": null,
          "new_api": "DefaultAction",
          "old_text": null,
          "new_text": "DefaultAction(reduce)",
          "old_line_content": "",
          "new_line_content": "  return DefaultAction(reduce);",
          "content_same": false
        },
        {
          "line": 1823,
          "old_api": null,
          "new_api": "Unimplemented",
          "old_text": null,
          "new_text": "Unimplemented(\"Send is not implemented on CPU.\")",
          "old_line_content": "",
          "new_line_content": "  return Unimplemented(\"Send is not implemented on CPU.\");",
          "content_same": false
        },
        {
          "line": 1828,
          "old_api": null,
          "new_api": "Unimplemented",
          "old_text": null,
          "new_text": "Unimplemented(\"Send-done is not implemented on CPU.\")",
          "old_line_content": "",
          "new_line_content": "  return Unimplemented(\"Send-done is not implemented on CPU.\");",
          "content_same": false
        },
        {
          "line": 1832,
          "old_api": null,
          "new_api": "Unimplemented",
          "old_text": null,
          "new_text": "Unimplemented(\"Scatter is not implemented on CPUs.\")",
          "old_line_content": "",
          "new_line_content": "  return Unimplemented(\"Scatter is not implemented on CPUs.\");",
          "content_same": false
        },
        {
          "line": 1836,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "slice->ToString()",
          "old_line_content": "  // The code below emits a sequential loop nest. For the parallel backend, use",
          "new_line_content": "  VLOG(2) << \"HandleSlice: \" << slice->ToString();",
          "content_same": false
        },
        {
          "line": 1837,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "slice->operand(0)",
          "old_line_content": "  // ParallelLoopEmitter which respects dynamic loop bounds.",
          "new_line_content": "  auto operand = slice->operand(0);",
          "content_same": false
        },
        {
          "line": 1840,
          "old_api": null,
          "new_api": "ShouldEmitParallelLoopFor",
          "old_text": null,
          "new_text": "ShouldEmitParallelLoopFor(*slice)",
          "old_line_content": "  }",
          "new_line_content": "  if (ShouldEmitParallelLoopFor(*slice)) {",
          "content_same": false
        },
        {
          "line": 1841,
          "old_api": null,
          "new_api": "DefaultAction",
          "old_text": null,
          "new_text": "DefaultAction(slice)",
          "old_line_content": "",
          "new_line_content": "    return DefaultAction(slice);",
          "content_same": false
        },
        {
          "line": 1845,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "slice->shape().layout()",
          "old_line_content": "  }",
          "new_line_content": "  if (!LayoutUtil::Equal(operand->shape().layout(), slice->shape().layout())) {",
          "content_same": false
        },
        {
          "line": 1846,
          "old_api": null,
          "new_api": "DefaultAction",
          "old_text": null,
          "new_text": "DefaultAction(slice)",
          "old_line_content": "",
          "new_line_content": "    return DefaultAction(slice);",
          "content_same": false
        },
        {
          "line": 1851,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "slice->shape()",
          "old_line_content": "  }",
          "new_line_content": "  if (ShapeUtil::IsZeroElementArray(slice->shape())) {",
          "content_same": false
        },
        {
          "line": 1852,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "    return Status::OK();",
          "content_same": false
        },
        {
          "line": 1855,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "operand->shape().layout()",
          "old_line_content": "",
          "new_line_content": "  const Layout& layout = operand->shape().layout();",
          "content_same": false
        },
        {
          "line": 1856,
          "old_api": null,
          "new_api": "dimensions_size",
          "old_text": null,
          "new_text": "operand->shape().dimensions_size()",
          "old_line_content": "  // The slice lowering finds maximal contiguous blocks of memory that can be",
          "new_line_content": "  const int64 num_dims = operand->shape().dimensions_size();",
          "content_same": false
        },
        {
          "line": 1871,
          "old_api": null,
          "new_api": "LayoutUtil::MinorToMajor(layout)",
          "old_text": null,
          "new_text": "LayoutUtil::MinorToMajor(layout)",
          "old_line_content": "      break;",
          "new_line_content": "  for (int64 dim : LayoutUtil::MinorToMajor(layout)) {",
          "content_same": false
        },
        {
          "line": 1872,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "slice->shape().dimensions(dim)",
          "old_line_content": "    }",
          "new_line_content": "    if (operand->shape().dimensions(dim) != slice->shape().dimensions(dim)) {",
          "content_same": false
        },
        {
          "line": 1875,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "inner_dims.insert(dim)",
          "old_line_content": "",
          "new_line_content": "    inner_dims.insert(dim);",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "slice->shape()",
          "old_line_content": "    } else {",
          "new_line_content": "    if (ShapeUtil::IsEffectiveScalar(slice->shape())) {",
          "content_same": false
        },
        {
          "line": 1883,
          "old_api": null,
          "new_api": "EmitMemcpy",
          "old_text": null,
          "new_text": "EmitMemcpy(*slice, *operand)",
          "old_line_content": "  }",
          "new_line_content": "      return EmitMemcpy(*slice, *operand);",
          "content_same": false
        },
        {
          "line": 1890,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "inner_dims.contains(dim)",
          "old_line_content": "",
          "new_line_content": "      [&inner_dims](int64 dim) { return inner_dims.contains(dim); },",
          "content_same": false
        },
        {
          "line": 1891,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "operand->shape()",
          "old_line_content": "  const int64 primitive_elements_per_logical_element =",
          "new_line_content": "      operand->shape());",
          "content_same": false
        },
        {
          "line": 1894,
          "old_api": null,
          "new_api": "ShapeUtil::ElementsIn(logical_element_shape)",
          "old_text": null,
          "new_text": "ShapeUtil::ElementsIn(logical_element_shape)",
          "old_line_content": "  // memcpy_dim is the innermost (in terms of layout) dimension for which the",
          "new_line_content": "      ShapeUtil::ElementsIn(logical_element_shape);",
          "content_same": false
        },
        {
          "line": 1900,
          "old_api": null,
          "new_api": "slice_strides",
          "old_text": null,
          "new_text": "slice->slice_strides(memcpy_dim)",
          "old_line_content": "  // to memcpy. We can only copy 1 element at a time if there is a non-trivial",
          "new_line_content": "  const bool memcpy_is_contiguous = slice->slice_strides(memcpy_dim) == 1;",
          "content_same": false
        },
        {
          "line": 1906,
          "old_api": null,
          "new_api": "slice_starts",
          "old_text": null,
          "new_text": "slice->slice_starts(memcpy_dim)",
          "old_line_content": "",
          "new_line_content": "          ? slice->slice_limits(memcpy_dim) - slice->slice_starts(memcpy_dim)",
          "content_same": false
        },
        {
          "line": 1911,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "inner_dims.size()",
          "old_line_content": "  }",
          "new_line_content": "  for (int64 i = 0; i < num_dims - inner_dims.size() - 1; ++i) {",
          "content_same": false
        },
        {
          "line": 1912,
          "old_api": null,
          "new_api": "LayoutUtil::Major(layout, i)",
          "old_text": null,
          "new_text": "LayoutUtil::Major(layout, i)",
          "old_line_content": "",
          "new_line_content": "    outer_dims.push_back(LayoutUtil::Major(layout, i));",
          "content_same": false
        },
        {
          "line": 1918,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "outer_dims.push_back(memcpy_dim)",
          "old_line_content": "",
          "new_line_content": "    outer_dims.push_back(memcpy_dim);",
          "content_same": false
        },
        {
          "line": 1923,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "outer_dims.size()",
          "old_line_content": "  std::vector<llvm::Value*> target_multi_index =",
          "new_line_content": "  const int64 num_outer_loops = outer_dims.size();",
          "content_same": false
        },
        {
          "line": 1926,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "slice->shape()",
          "old_line_content": "  // Only the indices for the outer dimensions have been initialized in",
          "new_line_content": "      loops.AddLoopsForShapeOnDimensions(slice->shape(), outer_dims, \"slice\");",
          "content_same": false
        },
        {
          "line": 1934,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "slice->shape()",
          "old_line_content": "",
          "new_line_content": "  llvm_ir::IrArray::Index target_index(target_multi_index, slice->shape(),",
          "content_same": false
        },
        {
          "line": 1935,
          "old_api": null,
          "new_api": "getInt64Ty",
          "old_text": null,
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "  if (num_outer_loops > 0) {",
          "new_line_content": "                                       b_.getInt64Ty());",
          "content_same": false
        },
        {
          "line": 1938,
          "old_api": null,
          "new_api": "GetInnerLoopBodyBasicBlock",
          "old_text": null,
          "new_text": "loops.GetInnerLoopBodyBasicBlock()",
          "old_line_content": "",
          "new_line_content": "    SetToFirstInsertPoint(loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 1943,
          "old_api": null,
          "new_api": "slice_starts",
          "old_text": null,
          "new_text": "slice->slice_starts()",
          "old_line_content": "",
          "new_line_content": "      /*operand_shape=*/operand->shape(), /*starts=*/slice->slice_starts(),",
          "content_same": false
        },
        {
          "line": 1944,
          "old_api": null,
          "new_api": "slice_strides",
          "old_text": null,
          "new_text": "slice->slice_strides()",
          "old_line_content": "  llvm::Value* memcpy_dest =",
          "new_line_content": "      /*strides=*/slice->slice_strides(), /*builder=*/&b_);",
          "content_same": false
        },
        {
          "line": 1949,
          "old_api": null,
          "new_api": "EmitArrayElementAddress",
          "old_text": null,
          "new_text": "source_array.EmitArrayElementAddress(source_index, &b_, \"slice.source\")",
          "old_line_content": "  const int64 memcpy_elements =",
          "new_line_content": "      source_array.EmitArrayElementAddress(source_index, &b_, \"slice.source\");",
          "content_same": false
        },
        {
          "line": 1954,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "EmitTransferElements(memcpy_dest, memcpy_source, memcpy_elements,\n                       slice->shape().element_type(), target_array,\n                       source_array)",
          "old_line_content": "                       source_array);",
          "new_line_content": "  EmitTransferElements(memcpy_dest, memcpy_source, memcpy_elements,",
          "content_same": false
        },
        {
          "line": 1955,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "slice->shape().element_type()",
          "old_line_content": "",
          "new_line_content": "                       slice->shape().element_type(), target_array,",
          "content_same": false
        },
        {
          "line": 1960,
          "old_api": null,
          "new_api": "ShapeUtil::ByteSizeOf(logical_element_shape)",
          "old_text": null,
          "new_text": "ShapeUtil::ByteSizeOf(logical_element_shape)",
          "old_line_content": "            << num_outer_loops << \" loops\";",
          "new_line_content": "        ShapeUtil::ByteSizeOf(logical_element_shape) * memcpy_elements;",
          "content_same": false
        },
        {
          "line": 1961,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(2)",
          "old_line_content": "  }",
          "new_line_content": "    VLOG(2) << \"  emitted copy of \" << memcpy_bytes << \" bytes inside \"",
          "content_same": false
        },
        {
          "line": 1966,
          "old_api": null,
          "new_api": "GetOuterLoopExitBasicBlock",
          "old_text": null,
          "new_text": "loops.GetOuterLoopExitBasicBlock()",
          "old_line_content": "",
          "new_line_content": "    SetToFirstInsertPoint(loops.GetOuterLoopExitBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 1969,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 1974,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(dynamic_slice)",
          "old_line_content": "  }",
          "new_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(dynamic_slice));",
          "content_same": false
        },
        {
          "line": 1977,
          "old_api": null,
          "new_api": "DefaultAction",
          "old_text": null,
          "new_text": "DefaultAction(dynamic_slice)",
          "old_line_content": "",
          "new_line_content": "  return DefaultAction(dynamic_slice);",
          "content_same": false
        },
        {
          "line": 1985,
          "old_api": null,
          "new_api": "EmitMemcpy",
          "old_text": null,
          "new_text": "EmitMemcpy(*update, *dynamic_update_slice)",
          "old_line_content": "                                                   assignment_)) {",
          "new_line_content": "    return EmitMemcpy(*update, *dynamic_update_slice);",
          "content_same": false
        },
        {
          "line": 1991,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(dynamic_update_slice)",
          "old_line_content": "  }",
          "new_line_content": "        operands, GetIrArrayFor(dynamic_update_slice),",
          "content_same": false
        },
        {
          "line": 1994,
          "old_api": null,
          "new_api": "DefaultAction",
          "old_text": null,
          "new_text": "DefaultAction(dynamic_update_slice)",
          "old_line_content": "",
          "new_line_content": "  return DefaultAction(dynamic_update_slice);",
          "content_same": false
        },
        {
          "line": 1999,
          "old_api": null,
          "new_api": "Unimplemented",
          "old_text": null,
          "new_text": "Unimplemented(\"Recv is not implemented on CPU.\")",
          "old_line_content": "",
          "new_line_content": "  return Unimplemented(\"Recv is not implemented on CPU.\");",
          "content_same": false
        },
        {
          "line": 2004,
          "old_api": null,
          "new_api": "Unimplemented",
          "old_text": null,
          "new_text": "Unimplemented(\"Recv-done is not implemented on CPU.\")",
          "old_line_content": "",
          "new_line_content": "  return Unimplemented(\"Recv-done is not implemented on CPU.\");",
          "content_same": false
        },
        {
          "line": 2012,
          "old_api": null,
          "new_api": "edge_padding_high",
          "old_text": null,
          "new_text": "padding_dimension.edge_padding_high()",
          "old_line_content": "          \"Encountered negative padding in IrEmitter on CPU. \"",
          "new_line_content": "        padding_dimension.edge_padding_high() < 0) {",
          "content_same": false
        },
        {
          "line": 2013,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "InternalErrorStrCat(\n          \"Encountered negative padding in IrEmitter on CPU. \"\n          \"This should have been eliminated at the HLO level. \",\n          pad->ToString())",
          "old_line_content": "          \"This should have been eliminated at the HLO level. \",",
          "new_line_content": "      return InternalErrorStrCat(",
          "content_same": false
        },
        {
          "line": 2016,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pad->ToString()",
          "old_line_content": "  }",
          "new_line_content": "          pad->ToString());",
          "content_same": false
        },
        {
          "line": 2021,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "EmitTargetElementLoop(\n      pad, \"initialize\",\n      [this, pad](const llvm_ir::IrArray::Index& target_index) {\n        const HloInstruction* padding_value = pad->operand(1);\n        llvm::Value* padding_value_addr = GetEmittedValueFor(padding_value);\n        return Load(padding_value_addr);\n      })",
          "old_line_content": "      [this, pad](const llvm_ir::IrArray::Index& target_index) {",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetElementLoop(",
          "content_same": false
        },
        {
          "line": 2025,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(padding_value)",
          "old_line_content": "      }));",
          "new_line_content": "        llvm::Value* padding_value_addr = GetEmittedValueFor(padding_value);",
          "content_same": false
        },
        {
          "line": 2026,
          "old_api": null,
          "new_api": "Load",
          "old_text": null,
          "new_text": "Load(padding_value_addr)",
          "old_line_content": "",
          "new_line_content": "        return Load(padding_value_addr);",
          "content_same": false
        },
        {
          "line": 2031,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(pad, \"assign\")",
          "old_line_content": "  const llvm_ir::IrArray::Index operand_index =",
          "new_line_content": "  llvm_ir::ForLoopNest loops(IrName(pad, \"assign\"), &b_);",
          "content_same": false
        },
        {
          "line": 2036,
          "old_api": null,
          "new_api": "GetInnerLoopBodyBasicBlock",
          "old_text": null,
          "new_text": "loops.GetInnerLoopBodyBasicBlock()",
          "old_line_content": "  // Load an element from the operand.",
          "new_line_content": "  SetToFirstInsertPoint(loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 2041,
          "old_api": null,
          "new_api": "EmitReadArrayElement",
          "old_text": null,
          "new_text": "operand_array.EmitReadArrayElement(operand_index, &b_)",
          "old_line_content": "  // Compute the output index the operand element should be assigned to.",
          "new_line_content": "      operand_array.EmitReadArrayElement(operand_index, &b_);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2048,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "padding_config.dimensions(i).interior_padding()",
          "new_text": null,
          "old_line_content": "            b_.getInt64(padding_config.dimensions(i).interior_padding() + 1));",
          "new_line_content": "    llvm::Value* offset =",
          "content_same": false
        },
        {
          "line": 2057,
          "old_api": "GetType",
          "new_api": null,
          "old_text": "operand_index.GetType()",
          "new_text": null,
          "old_line_content": "      output_multi_index, output_array.GetShape(), operand_index.GetType());",
          "new_line_content": "  llvm_ir::IrArray output_array(GetIrArrayFor(pad));",
          "content_same": false
        },
        {
          "line": 2058,
          "old_api": "EmitWriteArrayElement",
          "new_api": null,
          "old_text": "output_array.EmitWriteArrayElement(output_index, operand_data, &b_)",
          "new_text": null,
          "old_line_content": "  output_array.EmitWriteArrayElement(output_index, operand_data, &b_);",
          "new_line_content": "  llvm_ir::IrArray::Index output_index(",
          "content_same": false
        },
        {
          "line": 2061,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2065,
          "old_api": "fused_expression_root",
          "new_api": null,
          "old_text": "fusion->fused_expression_root()",
          "new_text": null,
          "old_line_content": "  auto* root = fusion->fused_expression_root();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2066,
          "old_api": "llvm_ir::CanEmitFusedDynamicUpdateSliceInPlace(fusion, assignment_)",
          "new_api": null,
          "old_text": "llvm_ir::CanEmitFusedDynamicUpdateSliceInPlace(fusion, assignment_)",
          "new_text": null,
          "old_line_content": "  if (llvm_ir::CanEmitFusedDynamicUpdateSliceInPlace(fusion, assignment_)) {",
          "new_line_content": "Status IrEmitter::HandleFusion(HloInstruction* fusion) {",
          "content_same": false
        },
        {
          "line": 2070,
          "old_api": "BindFusionArguments",
          "new_api": null,
          "old_text": "BindFusionArguments(fusion, &fused_emitter)",
          "new_text": null,
          "old_line_content": "    BindFusionArguments(fusion, &fused_emitter);",
          "new_line_content": "    CpuElementalIrEmitter elemental_emitter(hlo_module_config_, this, module_);",
          "content_same": false
        },
        {
          "line": 2075,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(fusion)",
          "new_text": null,
          "old_line_content": "        fusion, GetIrArrayFor(fusion), &fused_emitter, &b_);",
          "new_line_content": "    // Delegate to common implementation of fused in-place dynamic-update-slice.",
          "content_same": false
        },
        {
          "line": 2080,
          "old_api": "BindFusionArguments",
          "new_api": null,
          "old_text": "BindFusionArguments(fusion, &fused_emitter)",
          "new_text": null,
          "old_line_content": "    BindFusionArguments(fusion, &fused_emitter);",
          "new_line_content": "    CpuElementalIrEmitter elemental_emitter(hlo_module_config_, this, module_);",
          "content_same": false
        },
        {
          "line": 2083,
          "old_api": "EmitTargetElementLoop",
          "new_api": null,
          "old_text": "EmitTargetElementLoop(fusion, generator)",
          "new_text": null,
          "old_line_content": "    return EmitTargetElementLoop(fusion, generator);",
          "new_line_content": "    TF_ASSIGN_OR_RETURN(auto generator, fused_emitter.GetGenerator(",
          "content_same": false
        },
        {
          "line": 2084,
          "old_api": "IsOutputFusion",
          "new_api": null,
          "old_text": "fusion->IsOutputFusion()",
          "new_text": null,
          "old_line_content": "  } else if (fusion->IsOutputFusion()) {",
          "new_line_content": "                                            fusion->fused_expression_root()));",
          "content_same": false
        },
        {
          "line": 2093,
          "old_api": "operand",
          "new_api": null,
          "old_text": "dot->operand(1)->parameter_number()",
          "new_text": null,
          "old_line_content": "    int64 dot_rhs_param_number = dot->operand(1)->parameter_number();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2098,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(fusion)",
          "new_text": null,
          "old_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(fusion));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2102,
          "old_api": "operand",
          "new_api": null,
          "old_text": "fusion->operand(dot_lhs_param_number)",
          "new_text": null,
          "old_line_content": "        GetIrArrayFor(fusion->operand(dot_lhs_param_number)));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2119,
          "old_api": "to_apply",
          "new_api": null,
          "old_text": "call->to_apply()",
          "new_text": null,
          "old_line_content": "  HloComputation* computation = call->to_apply();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2120,
          "old_api": "FindOrDie",
          "new_api": null,
          "old_text": "FindOrDie(emitted_functions_, computation)",
          "new_text": null,
          "old_line_content": "  llvm::Function* call_ir_function = FindOrDie(emitted_functions_, computation);",
          "new_line_content": "Status IrEmitter::HandleCall(HloInstruction* call) {",
          "content_same": false
        },
        {
          "line": 2127,
          "old_api": "name",
          "new_api": null,
          "old_text": "GetArrayFunctionCallArguments(\n        {}, &b_, computation->name(),\n        /*return_value_buffer=*/emitted_value_[call],\n        /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),\n        /*buffer_table_arg=*/GetBufferTableArgument(),\n        /*profile_counters_arg=*/GetProfileCountersArgument())",
          "new_text": null,
          "old_line_content": "    std::vector<llvm::Value*> call_args = GetArrayFunctionCallArguments(",
          "new_line_content": "    // ParallelTaskAssignment assigned partitions, emit call to",
          "content_same": false
        },
        {
          "line": 2128,
          "old_api": "name",
          "new_api": null,
          "old_text": "computation->name()",
          "new_text": null,
          "old_line_content": "        {}, &b_, computation->name(),",
          "new_line_content": "    // ParallelForkJoin.",
          "content_same": false
        },
        {
          "line": 2131,
          "old_api": "GetBufferTableArgument",
          "new_api": null,
          "old_text": "GetBufferTableArgument()",
          "new_text": null,
          "old_line_content": "        /*buffer_table_arg=*/GetBufferTableArgument(),",
          "new_line_content": "        /*return_value_buffer=*/emitted_value_[call],",
          "content_same": false
        },
        {
          "line": 2135,
          "old_api": "shape",
          "new_api": null,
          "old_text": "EmitCallToParallelForkJoin(\n        call_args, root->shape(), root->outer_dimension_partitions(), &b_,\n        call_ir_function, computation->name())",
          "new_text": null,
          "old_line_content": "    TF_RETURN_IF_ERROR(EmitCallToParallelForkJoin(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2142,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2146,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(hlo)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(hlo));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2149,
          "old_api": "shape",
          "new_api": null,
          "old_text": "hlo->shape()",
          "new_text": null,
          "old_line_content": "      ShapeUtil::ByteSizeOf(ShapeUtil::MakeStaticShape(hlo->shape()));",
          "new_line_content": "  std::vector<llvm::Value*> dynamic_dims;",
          "content_same": false
        },
        {
          "line": 2150,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(hlo)",
          "new_text": null,
          "old_line_content": "  llvm::Value* dest_buffer = GetEmittedValueFor(hlo);",
          "new_line_content": "  int32 raw_data_size =",
          "content_same": false
        },
        {
          "line": 2153,
          "old_api": "operand_count",
          "new_api": null,
          "old_text": "hlo->operand_count()",
          "new_text": null,
          "old_line_content": "  for (int64 i = 1; i < hlo->operand_count(); ++i) {",
          "new_line_content": "  llvm::Value* raw_buffer =",
          "content_same": false
        },
        {
          "line": 2156,
          "old_api": "CreateLoad",
          "new_api": null,
          "old_text": "b_.CreateLoad(source_buffer, \"dyn_dim_size\")",
          "new_text": null,
          "old_line_content": "    llvm::LoadInst* dyn_dim_size = b_.CreateLoad(source_buffer, \"dyn_dim_size\");",
          "new_line_content": "    const int64 dim_index = i - 1;",
          "content_same": false
        },
        {
          "line": 2159,
          "old_api": "getInt8Ty",
          "new_api": null,
          "old_text": "b_.getInt8Ty()",
          "new_text": null,
          "old_line_content": "        b_.getInt8Ty(), raw_buffer, raw_data_size + dim_index * sizeof(int32));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2167,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(hlo)",
          "new_text": null,
          "old_line_content": "  llvm_ir::IrArray data_array = GetIrArrayFor(hlo);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2176,
          "old_api": "operand",
          "new_api": null,
          "old_text": "hlo->operand(0)",
          "new_text": null,
          "old_line_content": "        GetIrArrayFor(hlo->operand(0)).EmitReadArrayElement(array_index, &b_);",
          "new_line_content": "      [&](const llvm_ir::IrArray::Index& array_index) -> Status {",
          "content_same": false
        },
        {
          "line": 2177,
          "old_api": "Linearize",
          "new_api": null,
          "old_text": "array_index.Linearize(dynamic_dims, &b_)",
          "new_text": null,
          "old_line_content": "    llvm::Value* linear_index = array_index.Linearize(dynamic_dims, &b_);",
          "new_line_content": "    llvm::Value* source_element =",
          "content_same": false
        },
        {
          "line": 2182,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "    return Status::OK();",
          "new_line_content": "                                       &b_);",
          "content_same": false
        },
        {
          "line": 2190,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(hlo)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(hlo));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2196,
          "old_api": "shape",
          "new_api": null,
          "old_text": "hlo->shape()",
          "new_text": null,
          "old_line_content": "  const Shape& data_shape = ShapeUtil::GetSubshape(hlo->shape(), {0});",
          "new_line_content": "  std::vector<llvm::Value*> dynamic_dims;",
          "content_same": false
        },
        {
          "line": 2197,
          "old_api": "operand",
          "new_api": null,
          "old_text": "hlo->operand(0)->shape()",
          "new_text": null,
          "old_line_content": "  const Shape& input_shape = hlo->operand(0)->shape();",
          "new_line_content": "  std::vector<llvm::Value*> tuple_operand_ptrs;",
          "content_same": false
        },
        {
          "line": 2207,
          "old_api": "GetBasePointer",
          "new_api": null,
          "old_text": "data_array.GetBasePointer()",
          "new_text": null,
          "old_line_content": "  tuple_operand_ptrs.push_back(data_array.GetBasePointer());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2211,
          "old_api": "tuple_shapes_size",
          "new_api": null,
          "old_text": "hlo->shape().tuple_shapes_size()",
          "new_text": null,
          "old_line_content": "  for (int64 i = 1; i < hlo->shape().tuple_shapes_size(); ++i) {",
          "new_line_content": "  // (static_tensor, dynamic_dim_0, dynamic_dim_1, ... )",
          "content_same": false
        },
        {
          "line": 2214,
          "old_api": "ShapeUtil::MakeScalarShape(S32)",
          "new_api": null,
          "old_text": "ShapeUtil::MakeScalarShape(S32)",
          "new_text": null,
          "old_line_content": "    TF_RET_CHECK(Shape::Equal()(dim_shape, ShapeUtil::MakeScalarShape(S32)));",
          "new_line_content": "    // Read from the metadata section of the dynamic input (operand 0).",
          "content_same": false
        },
        {
          "line": 2218,
          "old_api": "EmitBufferPointer",
          "new_api": null,
          "old_text": "EmitBufferPointer(dim_size_slice, data_shape)",
          "new_text": null,
          "old_line_content": "        EmitBufferPointer(dim_size_slice, data_shape);",
          "new_line_content": "                        assignment_.GetUniqueSlice(hlo, {i}));",
          "content_same": false
        },
        {
          "line": 2221,
          "old_api": "getInt8Ty",
          "new_api": null,
          "old_text": "b_.getInt8Ty()",
          "new_text": null,
          "old_line_content": "        b_.getInt8Ty(), raw_buffer, raw_data_size + dim_index * sizeof(int32));",
          "new_line_content": "    const int64 dim_index = i - 1;",
          "content_same": false
        },
        {
          "line": 2226,
          "old_api": "CreateBitCast",
          "new_api": null,
          "old_text": "b_.CreateBitCast(dest_dim_size_address,\n                                    b_.getInt32Ty()->getPointerTo())",
          "new_text": null,
          "old_line_content": "                   b_.CreateBitCast(dest_dim_size_address,",
          "new_line_content": "        \"dyn_dim_size\");",
          "content_same": false
        },
        {
          "line": 2231,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "tuple_operand_ptrs.push_back(dest_dim_size_address)",
          "new_text": null,
          "old_line_content": "    tuple_operand_ptrs.push_back(dest_dim_size_address);",
          "new_line_content": "                                            /*isSigned=*/true,",
          "content_same": false
        },
        {
          "line": 2241,
          "old_api": "Linearize",
          "new_api": null,
          "old_text": "array_index.Linearize(dynamic_dims, &b_)",
          "new_text": null,
          "old_line_content": "    llvm::Value* linear_index = array_index.Linearize(dynamic_dims, &b_);",
          "new_line_content": "  auto loop_body_emitter =",
          "content_same": false
        },
        {
          "line": 2244,
          "old_api": "operand",
          "new_api": null,
          "old_text": "hlo->operand(0)",
          "new_text": null,
          "old_line_content": "        GetIrArrayFor(hlo->operand(0)).EmitReadArrayElement(source_index, &b_);",
          "new_line_content": "    llvm_ir::IrArray::Index source_index(linear_index, input_shape, &b_);",
          "content_same": false
        },
        {
          "line": 2245,
          "old_api": "EmitWriteArrayElement",
          "new_api": null,
          "old_text": "data_array.EmitWriteArrayElement(array_index, source_element, &b_)",
          "new_text": null,
          "old_line_content": "    data_array.EmitWriteArrayElement(array_index, source_element, &b_);",
          "new_line_content": "    llvm::Value* source_element =",
          "content_same": false
        },
        {
          "line": 2249,
          "old_api": "EmitLoop",
          "new_api": null,
          "old_text": "llvm_ir::LoopEmitter(loop_body_emitter, input_shape, dynamic_dims, &b_)\n          .EmitLoop(IrName(hlo))",
          "new_text": null,
          "old_line_content": "      llvm_ir::LoopEmitter(loop_body_emitter, input_shape, dynamic_dims, &b_)",
          "new_line_content": "  };",
          "content_same": false
        },
        {
          "line": 2253,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(hlo)",
          "new_text": null,
          "old_line_content": "  llvm_ir::EmitTuple(GetIrArrayFor(hlo), tuple_operand_ptrs, &b_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2254,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  // Emit static tensor and dynamic sizes as one tuple.",
          "content_same": false
        },
        {
          "line": 2258,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(hlo)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(hlo));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2259,
          "old_api": "operand",
          "new_api": null,
          "old_text": "hlo->operand(0)",
          "new_text": null,
          "old_line_content": "  const HloInstruction* input = hlo->operand(0);",
          "new_line_content": "Status IrEmitter::HandleTopK(HloInstruction* hlo) {",
          "content_same": false
        },
        {
          "line": 2277,
          "old_api": "operand",
          "new_api": null,
          "old_text": "hlo->operand(0)->shape()",
          "new_text": null,
          "old_line_content": "      EmitBufferPointer(values_slice, hlo->operand(0)->shape());",
          "new_line_content": "                      assignment_.GetUniqueSlice(hlo, {1}));",
          "content_same": false
        },
        {
          "line": 2282,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "EmitCallToFunc(\n      runtime::kTopKF32SymbolName,\n      {b_.getInt64(has_batch ? input->shape().dimensions(0) : 1),\n       b_.getInt64(input->shape().dimensions().back()), b_.getInt64(k),\n       BitCast(values_ptr, b_.getFloatTy()->getPointerTo()),\n       BitCast(out_values_ptr, b_.getFloatTy()->getPointerTo()),\n       BitCast(out_indices_ptr, b_.getInt32Ty()->getPointerTo())},\n      b_.getVoidTy())",
          "new_text": null,
          "old_line_content": "  EmitCallToFunc(",
          "new_line_content": "  llvm::Value* out_indices_ptr =",
          "content_same": false
        },
        {
          "line": 2285,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "b_.getInt64(k)",
          "new_text": null,
          "old_line_content": "       b_.getInt64(input->shape().dimensions().back()), b_.getInt64(k),",
          "new_line_content": "      runtime::kTopKF32SymbolName,",
          "content_same": false
        },
        {
          "line": 2297,
          "old_api": "custom_call_target",
          "new_api": null,
          "old_text": "custom_call->custom_call_target()",
          "new_text": null,
          "old_line_content": "  if (custom_call->custom_call_target() == \"PadToStatic\") {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2298,
          "old_api": "HandlePadToStatic",
          "new_api": null,
          "old_text": "HandlePadToStatic(custom_call)",
          "new_text": null,
          "old_line_content": "    return HandlePadToStatic(custom_call);",
          "new_line_content": "Status IrEmitter::HandleCustomCall(HloInstruction* custom_call) {",
          "content_same": false
        },
        {
          "line": 2301,
          "old_api": "HandleSliceToDynamic",
          "new_api": null,
          "old_text": "HandleSliceToDynamic(custom_call)",
          "new_text": null,
          "old_line_content": "    return HandleSliceToDynamic(custom_call);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2304,
          "old_api": "HandleTopK",
          "new_api": null,
          "old_text": "HandleTopK(custom_call)",
          "new_text": null,
          "old_line_content": "    return HandleTopK(custom_call);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2307,
          "old_api": "getInt8PtrTy",
          "new_api": null,
          "old_text": "b_.getInt8PtrTy()",
          "new_text": null,
          "old_line_content": "  llvm::Type* i8_ptr_type = b_.getInt8PtrTy();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2310,
          "old_api": "size",
          "new_api": null,
          "old_text": "operands.size()",
          "new_text": null,
          "old_line_content": "          i8_ptr_type, b_.getInt32(operands.size()), \"cc_operands_alloca\", &b_);",
          "new_line_content": "  llvm::AllocaInst* operands_alloca =",
          "content_same": false
        },
        {
          "line": 2314,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(operand)",
          "new_text": null,
          "old_line_content": "        PointerCast(GetEmittedValueFor(operand), i8_ptr_type);",
          "new_line_content": "    const HloInstruction* operand = operands[i];",
          "content_same": false
        },
        {
          "line": 2317,
          "old_api": "Store",
          "new_api": null,
          "old_text": "Store(operand_as_i8ptr, slot_in_operands_alloca)",
          "new_text": null,
          "old_line_content": "    Store(operand_as_i8ptr, slot_in_operands_alloca);",
          "new_line_content": "    llvm::Value* slot_in_operands_alloca =",
          "content_same": false
        },
        {
          "line": 2323,
          "old_api": "getDataLayout",
          "new_api": null,
          "old_text": "module_->getDataLayout()",
          "new_text": null,
          "old_line_content": "    const llvm::DataLayout& dl = module_->getDataLayout();",
          "new_line_content": "    // custom callee, which might be msan-instrumented.",
          "content_same": false
        },
        {
          "line": 2324,
          "old_api": "getIntPtrTy",
          "new_api": null,
          "old_text": "b_.getIntPtrTy(dl)",
          "new_text": null,
          "old_line_content": "    llvm::Type* intptr_type = b_.getIntPtrTy(dl);",
          "new_line_content": "    // TODO(b/66051036): Run the msan instrumentation pass instead.",
          "content_same": false
        },
        {
          "line": 2328,
          "old_api": "getAllocationSizeInBits",
          "new_api": null,
          "old_text": "llvm::ConstantInt::get(\n             intptr_type, *operands_alloca->getAllocationSizeInBits(dl) / 8)",
          "new_text": null,
          "old_line_content": "         llvm::ConstantInt::get(",
          "new_line_content": "        \"__msan_unpoison\",",
          "content_same": false
        },
        {
          "line": 2333,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(custom_call)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(custom_call));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2340,
          "old_api": "shape",
          "new_api": null,
          "old_text": "custom_call->shape()",
          "new_text": null,
          "old_line_content": "          ShapeUtil::GetTupleElementShape(custom_call->shape(), i);",
          "new_line_content": "         ++i) {",
          "content_same": false
        },
        {
          "line": 2341,
          "old_api": "IsTuple",
          "new_api": null,
          "old_text": "elem_shape.IsTuple()",
          "new_text": null,
          "old_line_content": "      TF_RET_CHECK(!elem_shape.IsTuple()) << \"Nested tuples not implemented\";",
          "new_line_content": "      const Shape& elem_shape =",
          "content_same": false
        },
        {
          "line": 2344,
          "old_api": "EmitBufferPointer",
          "new_api": null,
          "old_text": "EmitBufferPointer(slice, elem_shape)",
          "new_text": null,
          "old_line_content": "      llvm::Value* addr = EmitBufferPointer(slice, elem_shape);",
          "new_line_content": "      TF_ASSIGN_OR_RETURN(const BufferAllocation::Slice slice,",
          "content_same": false
        },
        {
          "line": 2345,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "base_ptrs.push_back(addr)",
          "new_text": null,
          "old_line_content": "      base_ptrs.push_back(addr);",
          "new_line_content": "                          assignment_.GetUniqueSlice(custom_call, {i}));",
          "content_same": false
        },
        {
          "line": 2350,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(custom_call)",
          "new_text": null,
          "old_line_content": "      PointerCast(GetEmittedValueFor(custom_call), i8_ptr_type);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2353,
          "old_api": "getVoidTy",
          "new_api": null,
          "old_text": "b_.getVoidTy()",
          "new_text": null,
          "old_line_content": "                 {output_address_arg, operands_alloca}, b_.getVoidTy());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2360,
          "old_api": "while_condition",
          "new_api": null,
          "old_text": "xla_while->while_condition()",
          "new_text": null,
          "old_line_content": "  HloComputation* condition = xla_while->while_condition();",
          "new_line_content": "Status IrEmitter::HandleWhile(HloInstruction* xla_while) {",
          "content_same": false
        },
        {
          "line": 2361,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "condition->root_instruction()->shape()",
          "new_text": null,
          "old_line_content": "  TF_RET_CHECK(ShapeUtil::IsScalar(condition->root_instruction()->shape()) &&",
          "new_line_content": "  // Precondition: Condition computation must return a scalar bool.",
          "content_same": false
        },
        {
          "line": 2367,
          "old_api": "shape",
          "new_api": null,
          "old_text": "xla_while->shape()",
          "new_text": null,
          "old_line_content": "      xla_while->shape(),",
          "new_line_content": "  // Check that all while-related buffers share an allocation slice.",
          "content_same": false
        },
        {
          "line": 2373,
          "old_api": "GetUniqueSlice",
          "new_api": null,
          "old_text": "assignment_.GetUniqueSlice(a, index).ConsumeValueOrDie()",
          "new_text": null,
          "old_line_content": "              assignment_.GetUniqueSlice(a, index).ConsumeValueOrDie();",
          "new_line_content": "                            const ShapeIndex& index) {",
          "content_same": false
        },
        {
          "line": 2380,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "b->ToString()",
          "new_text": null,
          "old_line_content": "                a->ToString(), slice_a.ToString(), b->ToString(),",
          "new_line_content": "                \"instruction %s %s does not share slice with \"",
          "content_same": false
        },
        {
          "line": 2381,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "slice_b.ToString()",
          "new_text": null,
          "old_line_content": "                slice_b.ToString());",
          "new_line_content": "                \"instruction %s %s\",",
          "content_same": false
        },
        {
          "line": 2386,
          "old_api": "while_condition",
          "new_api": null,
          "old_text": "check(\n            xla_while, xla_while->while_condition()->parameter_instruction(0),\n            index)",
          "new_text": null,
          "old_line_content": "        TF_RETURN_IF_ERROR(check(",
          "new_line_content": "        };",
          "content_same": false
        },
        {
          "line": 2390,
          "old_api": "while_body",
          "new_api": null,
          "old_text": "xla_while->while_body()->parameter_instruction(0)",
          "new_text": null,
          "old_line_content": "            check(xla_while, xla_while->while_body()->parameter_instruction(0),",
          "new_line_content": "            index));",
          "content_same": false
        },
        {
          "line": 2393,
          "old_api": "while_body",
          "new_api": null,
          "old_text": "xla_while->while_body()->root_instruction()",
          "new_text": null,
          "old_line_content": "            xla_while, xla_while->while_body()->root_instruction(), index));",
          "new_line_content": "                  index));",
          "content_same": false
        },
        {
          "line": 2398,
          "old_api": "operand",
          "new_api": null,
          "old_text": "xla_while->operand(0)",
          "new_text": null,
          "old_line_content": "  const HloInstruction* init = xla_while->operand(0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2399,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(init)",
          "new_text": null,
          "old_line_content": "  emitted_value_[xla_while] = GetEmittedValueFor(init);",
          "new_line_content": "  // Set emitted value to that of 'init' with which it shares an allocation.",
          "content_same": false
        },
        {
          "line": 2409,
          "old_api": "getContext",
          "new_api": null,
          "old_text": "llvm::BasicBlock::Create(\n      module_->getContext(), IrName(xla_while, \"header\"),\n      compute_function_->function())",
          "new_text": null,
          "old_line_content": "  llvm::BasicBlock* header_bb = llvm::BasicBlock::Create(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2410,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(xla_while, \"header\")",
          "new_text": null,
          "old_line_content": "      module_->getContext(), IrName(xla_while, \"header\"),",
          "new_line_content": "  // Terminates the current block with a branch to a while header.",
          "content_same": false
        },
        {
          "line": 2417,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(xla_while, \"cond\")",
          "new_text": null,
          "old_line_content": "  EmitGlobalCall(*xla_while->while_condition(), IrName(xla_while, \"cond\"));",
          "new_line_content": "  // Calls the condition function to determine whether to proceed with the",
          "content_same": false
        },
        {
          "line": 2418,
          "old_api": "while_condition",
          "new_api": null,
          "old_text": "ICmpNE(\n      Load(GetBufferForGlobalCallReturnValue(*xla_while->while_condition())),\n      llvm::ConstantInt::get(llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0))",
          "new_text": null,
          "old_line_content": "  llvm::Value* while_predicate = ICmpNE(",
          "new_line_content": "  // body.  It must return a bool, so use the scalar call form.",
          "content_same": false
        },
        {
          "line": 2424,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(xla_while, \"body\")",
          "new_text": null,
          "old_line_content": "      llvm::BasicBlock::Create(module_->getContext(), IrName(xla_while, \"body\"),",
          "new_line_content": "  // Branches to the body or to the while exit depending on the condition.",
          "content_same": false
        },
        {
          "line": 2425,
          "old_api": "function",
          "new_api": null,
          "old_text": "compute_function_->function()",
          "new_text": null,
          "old_line_content": "                               compute_function_->function());",
          "new_line_content": "  llvm::BasicBlock* body_bb =",
          "content_same": false
        },
        {
          "line": 2431,
          "old_api": "SetInsertPoint",
          "new_api": null,
          "old_text": "b_.SetInsertPoint(body_bb)",
          "new_text": null,
          "old_line_content": "  b_.SetInsertPoint(body_bb);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2434,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(xla_while, \"body\")",
          "new_text": null,
          "old_line_content": "  EmitGlobalCall(*xla_while->while_body(), IrName(xla_while, \"body\"));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2437,
          "old_api": "Br",
          "new_api": null,
          "old_text": "Br(header_bb)",
          "new_text": null,
          "old_line_content": "  Br(header_bb);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2440,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "compute_function_->function()->getBasicBlockList().push_back(exit_bb)",
          "new_text": null,
          "old_line_content": "  compute_function_->function()->getBasicBlockList().push_back(exit_bb);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2441,
          "old_api": "SetInsertPoint",
          "new_api": null,
          "old_text": "b_.SetInsertPoint(exit_bb)",
          "new_text": null,
          "old_line_content": "  b_.SetInsertPoint(exit_bb);",
          "new_line_content": "  // Adds the exit block to the function and sets the insert point there.",
          "content_same": false
        },
        {
          "line": 2449,
          "old_api": "ShouldEmitParallelLoopFor",
          "new_api": null,
          "old_text": "ShouldEmitParallelLoopFor(*concatenate)",
          "new_text": null,
          "old_line_content": "  if (ShouldEmitParallelLoopFor(*concatenate)) {",
          "new_line_content": "    HloInstruction* concatenate, absl::Span<HloInstruction* const> operands,",
          "content_same": false
        },
        {
          "line": 2455,
          "old_api": "shape",
          "new_api": null,
          "old_text": "concatenate->shape()",
          "new_text": null,
          "old_line_content": "  const Shape& output_shape = concatenate->shape();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2467,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "concatenate->dimensions(0)",
          "new_text": null,
          "old_line_content": "  int64 concat_dim = concatenate->dimensions(0);",
          "new_line_content": "  // (inner_dims) and the dimensions that are major to it (outer_dims).",
          "content_same": false
        },
        {
          "line": 2468,
          "old_api": "layout",
          "new_api": null,
          "old_text": "output_shape.layout()",
          "new_text": null,
          "old_line_content": "  const Layout& output_layout = output_shape.layout();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2473,
          "old_api": "std::next(concat_dim_layout_itr)",
          "new_api": null,
          "old_text": "std::next(concat_dim_layout_itr)",
          "new_text": null,
          "old_line_content": "  std::vector<int64> outer_dims(std::next(concat_dim_layout_itr),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2479,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(concatenate)",
          "new_text": null,
          "old_line_content": "  llvm_ir::IrArray target_array = GetIrArrayFor(concatenate);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2484,
          "old_api": "end",
          "new_api": null,
          "old_text": "target_multi_index.end()",
          "new_text": null,
          "old_line_content": "  std::replace(target_multi_index.begin(), target_multi_index.end(),",
          "new_line_content": "  std::vector<llvm::Value*> target_multi_index =",
          "content_same": false
        },
        {
          "line": 2491,
          "old_api": "GetInnerLoopBodyBasicBlock",
          "new_api": null,
          "old_text": "loops.GetInnerLoopBodyBasicBlock()",
          "new_text": null,
          "old_line_content": "    SetToFirstInsertPoint(loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2494,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "output_shape.element_type()",
          "new_text": null,
          "old_line_content": "  PrimitiveType primitive_type = output_shape.element_type();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2500,
          "old_api": "EmitArrayElementAddress",
          "new_api": null,
          "old_text": "BitCast(\n      target_array.EmitArrayElementAddress(target_index, &b_, \"target_region\"),\n      i8_ptr_type)",
          "new_text": null,
          "old_line_content": "  llvm::Value* target_region_begin = BitCast(",
          "new_line_content": "  // Contiguous subregions from each operand to the concatenate contribute to a",
          "content_same": false
        },
        {
          "line": 2501,
          "old_api": "EmitArrayElementAddress",
          "new_api": null,
          "old_text": "target_array.EmitArrayElementAddress(target_index, &b_, \"target_region\")",
          "new_text": null,
          "old_line_content": "      target_array.EmitArrayElementAddress(target_index, &b_, \"target_region\"),",
          "new_line_content": "  // contiguous subregion in the target buffer starting at target_region_begin.",
          "content_same": false
        },
        {
          "line": 2506,
          "old_api": "end",
          "new_api": null,
          "old_text": "inner_dims.end()",
          "new_text": null,
          "old_line_content": "      std::accumulate(inner_dims.begin(), inner_dims.end(), 1l,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2514,
          "old_api": "shape",
          "new_api": null,
          "old_text": "operand->shape()",
          "new_text": null,
          "old_line_content": "    const Shape& input_shape = operand->shape();",
          "new_line_content": "  // equal to the product of inner dimensions.",
          "content_same": false
        },
        {
          "line": 2515,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(operand)",
          "new_text": null,
          "old_line_content": "    llvm_ir::IrArray source_array = GetIrArrayFor(operand);",
          "new_line_content": "  for (HloInstruction* operand : operands) {",
          "content_same": false
        },
        {
          "line": 2523,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "b_.getInt64(byte_offset_into_target_region)",
          "new_text": null,
          "old_line_content": "        GEP(target_region_begin, b_.getInt64(byte_offset_into_target_region));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2531,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "input_shape.dimensions(concat_dim)",
          "new_text": null,
          "old_line_content": "                                      input_shape.dimensions(concat_dim) *",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2535,
          "old_api": "empty",
          "new_api": null,
          "old_text": "outer_dims.empty()",
          "new_text": null,
          "old_line_content": "  if (!outer_dims.empty()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2536,
          "old_api": "GetOuterLoopExitBasicBlock",
          "new_api": null,
          "old_text": "loops.GetOuterLoopExitBasicBlock()",
          "new_text": null,
          "old_line_content": "    SetToFirstInsertPoint(loops.GetOuterLoopExitBasicBlock(), &b_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2544,
          "old_api": "getInt8Ty",
          "new_api": null,
          "old_text": "b_.getInt8Ty()->getPointerTo()",
          "new_text": null,
          "old_line_content": "  llvm::Type* ptr_ty = b_.getInt8Ty()->getPointerTo();",
          "new_line_content": "llvm::Value* IrEmitter::EmitPrintf(absl::string_view fmt,",
          "content_same": false
        },
        {
          "line": 2547,
          "old_api": "std::back_inserter(call_args)",
          "new_api": null,
          "old_text": "std::back_inserter(call_args)",
          "new_text": null,
          "old_line_content": "  absl::c_copy(arguments, std::back_inserter(call_args));",
          "new_line_content": "  std::vector<llvm::Value*> call_args;",
          "content_same": false
        },
        {
          "line": 2557,
          "old_api": "getInt8Ty",
          "new_api": null,
          "old_text": "b_.getInt8Ty()->getPointerTo()",
          "new_text": null,
          "old_line_content": "  llvm::Type* ptr_ty = b_.getInt8Ty()->getPointerTo();",
          "new_line_content": "llvm::Value* IrEmitter::EmitPrintfToStderr(",
          "content_same": false
        },
        {
          "line": 2560,
          "old_api": "std::back_inserter(call_args)",
          "new_api": null,
          "old_text": "std::back_inserter(call_args)",
          "new_text": null,
          "old_line_content": "  absl::c_copy(arguments, std::back_inserter(call_args));",
          "new_line_content": "  std::vector<llvm::Value*> call_args;",
          "content_same": false
        },
        {
          "line": 2574,
          "old_api": "size",
          "new_api": null,
          "old_text": "arguments.size()",
          "new_text": null,
          "old_line_content": "  types.reserve(arguments.size());",
          "new_line_content": "    bool only_accesses_inaccessible_mem_or_arg_mem) {",
          "content_same": false
        },
        {
          "line": 2575,
          "old_api": "std::back_inserter(types)",
          "new_api": null,
          "old_text": "std::back_inserter(types)",
          "new_text": null,
          "old_line_content": "  absl::c_transform(arguments, std::back_inserter(types),",
          "new_line_content": "  std::vector<llvm::Type*> types;",
          "content_same": false
        },
        {
          "line": 2579,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "llvm::dyn_cast<llvm::Function>(\n      module_->getOrInsertFunction(func_name, func_type).getCallee())",
          "new_text": null,
          "old_line_content": "  auto func = llvm::dyn_cast<llvm::Function>(",
          "new_line_content": "  llvm::FunctionType* func_type =",
          "content_same": false
        },
        {
          "line": 2586,
          "old_api": "setOnlyAccessesArgMemory",
          "new_api": null,
          "old_text": "func->setOnlyAccessesArgMemory()",
          "new_text": null,
          "old_line_content": "    func->setOnlyAccessesArgMemory();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2589,
          "old_api": "setOnlyAccessesInaccessibleMemOrArgMem",
          "new_api": null,
          "old_text": "func->setOnlyAccessesInaccessibleMemOrArgMem()",
          "new_text": null,
          "old_line_content": "    func->setOnlyAccessesInaccessibleMemOrArgMem();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2600,
          "old_api": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "new_api": null,
          "old_text": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "new_text": null,
          "old_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(primitive_type);",
          "new_line_content": "                                     const llvm_ir::IrArray& source_array) {",
          "content_same": false
        },
        {
          "line": 2603,
          "old_api": "llvm::PointerType::getUnqual(\n      llvm_ir::PrimitiveTypeToIrType(primitive_type, module_))",
          "new_api": null,
          "old_text": "llvm::PointerType::getUnqual(\n      llvm_ir::PrimitiveTypeToIrType(primitive_type, module_))",
          "new_text": null,
          "old_line_content": "  llvm::Type* primitive_ptr_type = llvm::PointerType::getUnqual(",
          "new_line_content": "  llvm::Align element_alignment(tensorflow::MathUtil::GCD<unsigned>(",
          "content_same": false
        },
        {
          "line": 2604,
          "old_api": "llvm_ir::PrimitiveTypeToIrType(primitive_type, module_)",
          "new_api": null,
          "old_text": "llvm_ir::PrimitiveTypeToIrType(primitive_type, module_)",
          "new_text": null,
          "old_line_content": "      llvm_ir::PrimitiveTypeToIrType(primitive_type, module_));",
          "new_line_content": "      primitive_type_size, MinimumAlignmentForPrimitiveType(primitive_type)));",
          "content_same": false
        },
        {
          "line": 2608,
          "old_api": "BitCast",
          "new_api": null,
          "old_text": "BitCast(source, primitive_ptr_type)",
          "new_text": null,
          "old_line_content": "        AlignedLoad(BitCast(source, primitive_ptr_type), element_alignment);",
          "new_line_content": "  if (element_count == 1) {",
          "content_same": false
        },
        {
          "line": 2609,
          "old_api": "AnnotateLoadStoreInstructionWithMetadata",
          "new_api": null,
          "old_text": "source_array.AnnotateLoadStoreInstructionWithMetadata(load_instruction)",
          "new_text": null,
          "old_line_content": "    source_array.AnnotateLoadStoreInstructionWithMetadata(load_instruction);",
          "new_line_content": "    auto* load_instruction =",
          "content_same": false
        },
        {
          "line": 2616,
          "old_api": "llvm::Align(element_alignment)",
          "new_api": null,
          "old_text": "llvm::Align(element_alignment)",
          "new_text": null,
          "old_line_content": "        target, /*DstAlign=*/llvm::Align(element_alignment), source,",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 2623,
          "old_api": "metadata",
          "new_api": null,
          "old_text": "source_array.metadata()",
          "new_text": null,
          "old_line_content": "        llvm_ir::MergeMetadata(&module_->getContext(), source_array.metadata(),",
          "new_line_content": "    // metadata has to reflect that.",
          "content_same": false
        },
        {
          "line": 2624,
          "old_api": "metadata",
          "new_api": null,
          "old_text": "target_array.metadata()",
          "new_text": null,
          "old_line_content": "                               target_array.metadata());",
          "new_line_content": "    std::map<int, llvm::MDNode*> merged_metadata =",
          "content_same": false
        },
        {
          "line": 2632,
          "old_api": "operands",
          "new_api": null,
          "old_text": "concatenate->operands()",
          "new_text": null,
          "old_line_content": "  absl::Span<HloInstruction* const> operands(concatenate->operands());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2638,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "concatenate->ToString()",
          "new_text": null,
          "old_line_content": "    VLOG(1) << \"Emitted fast concatenate for \" << concatenate->ToString();",
          "new_line_content": "      EmitFastConcatenate(concatenate, operands, &failure_reason));",
          "content_same": false
        },
        {
          "line": 2639,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "    return Status::OK();",
          "new_line_content": "  if (successful) {",
          "content_same": false
        },
        {
          "line": 2642,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "concatenate->ToString()",
          "new_text": null,
          "old_line_content": "  VLOG(1) << \"Could not emit fast concatenate for \" << concatenate->ToString()",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2645,
          "old_api": "DefaultAction",
          "new_api": null,
          "old_text": "DefaultAction(concatenate)",
          "new_text": null,
          "old_line_content": "  return DefaultAction(concatenate);",
          "new_line_content": "          << \": \" << failure_reason;",
          "content_same": false
        },
        {
          "line": 2649,
          "old_api": "operand",
          "new_api": null,
          "old_text": "conditional->operand(0)",
          "new_text": null,
          "old_line_content": "  auto branch_index = conditional->operand(0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2650,
          "old_api": "branch_count",
          "new_api": null,
          "old_text": "conditional->branch_count()",
          "new_text": null,
          "old_line_content": "  int num_branches = conditional->branch_count();",
          "new_line_content": "Status IrEmitter::HandleConditional(HloInstruction* conditional) {",
          "content_same": false
        },
        {
          "line": 2658,
          "old_api": "branch_computation",
          "new_api": null,
          "old_text": "conditional->branch_computation(b)",
          "new_text": null,
          "old_line_content": "    HloComputation* br_computation = conditional->branch_computation(b);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2659,
          "old_api": "shape",
          "new_api": null,
          "old_text": "conditional->shape()",
          "new_text": null,
          "old_line_content": "    TF_RET_CHECK(ShapeUtil::Equal(conditional->shape(),",
          "new_line_content": "  for (int b = 0; b < num_branches; ++b) {",
          "content_same": false
        },
        {
          "line": 2663,
          "old_api": "shape",
          "new_api": null,
          "old_text": "conditional->shape()",
          "new_text": null,
          "old_line_content": "        << ShapeUtil::HumanString(conditional->shape()) << \" and \"",
          "new_line_content": "        << \"Shape of conditional should be same as the shape of the \" << b",
          "content_same": false
        },
        {
          "line": 2664,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "br_computation->root_instruction()->shape()",
          "new_text": null,
          "old_line_content": "        << ShapeUtil::HumanString(br_computation->root_instruction()->shape());",
          "new_line_content": "        << \"th branch computation; got: \"",
          "content_same": false
        },
        {
          "line": 2667,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(conditional)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(conditional));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2675,
          "old_api": "GetBasePointer",
          "new_api": null,
          "old_text": "Load(\n        GetIrArrayFor(branch_index).GetBasePointer(), \"load_predicate_value\")",
          "new_text": null,
          "old_line_content": "    llvm::LoadInst* pred_value = Load(",
          "new_line_content": "    //   else",
          "content_same": false
        },
        {
          "line": 2676,
          "old_api": "GetBasePointer",
          "new_api": null,
          "old_text": "GetIrArrayFor(branch_index).GetBasePointer()",
          "new_text": null,
          "old_line_content": "        GetIrArrayFor(branch_index).GetBasePointer(), \"load_predicate_value\");",
          "new_line_content": "    //     cond_result = false_computation(false_operand)",
          "content_same": false
        },
        {
          "line": 2679,
          "old_api": "llvm::ConstantInt::get(\n                   llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0)",
          "new_api": null,
          "old_text": "llvm::ConstantInt::get(\n                   llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0)",
          "new_text": null,
          "old_line_content": "               llvm::ConstantInt::get(",
          "new_line_content": "    llvm::Value* pred_cond =",
          "content_same": false
        },
        {
          "line": 2683,
          "old_api": "llvm_ir::EmitIfThenElse(pred_cond, \"conditional\", &b_)",
          "new_api": null,
          "old_text": "llvm_ir::EmitIfThenElse(pred_cond, \"conditional\", &b_)",
          "new_text": null,
          "old_line_content": "        llvm_ir::EmitIfThenElse(pred_cond, \"conditional\", &b_);",
          "new_line_content": "               \"boolean_predicate\");",
          "content_same": false
        },
        {
          "line": 2686,
          "old_api": "branch_computation",
          "new_api": null,
          "old_text": "conditional->branch_computation(0)",
          "new_text": null,
          "old_line_content": "    EmitGlobalCall(*conditional->branch_computation(0),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2690,
          "old_api": "branch_computation",
          "new_api": null,
          "old_text": "conditional->branch_computation(1)",
          "new_text": null,
          "old_line_content": "    EmitGlobalCall(*conditional->branch_computation(1),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2694,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "    return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2710,
          "old_api": "GetBasePointer",
          "new_api": null,
          "old_text": "Load(\n      GetIrArrayFor(branch_index).GetBasePointer(), \"load_branch_index_value\")",
          "new_text": null,
          "old_line_content": "  llvm::LoadInst* branch_index_value = Load(",
          "new_line_content": "  //     break;",
          "content_same": false
        },
        {
          "line": 2711,
          "old_api": "GetBasePointer",
          "new_api": null,
          "old_text": "GetIrArrayFor(branch_index).GetBasePointer()",
          "new_text": null,
          "old_line_content": "      GetIrArrayFor(branch_index).GetBasePointer(), \"load_branch_index_value\");",
          "new_line_content": "  // }",
          "content_same": false
        },
        {
          "line": 2716,
          "old_api": "getTerminator",
          "new_api": null,
          "old_text": "case_block->getTerminator()",
          "new_text": null,
          "old_line_content": "  if (case_block->getTerminator() == nullptr) {",
          "new_line_content": "  llvm::BasicBlock* after_block;",
          "content_same": false
        },
        {
          "line": 2717,
          "old_api": "llvm_ir::CreateBasicBlock(nullptr, \"case-after\", &b_)",
          "new_api": null,
          "old_text": "llvm_ir::CreateBasicBlock(nullptr, \"case-after\", &b_)",
          "new_text": null,
          "old_line_content": "    after_block = llvm_ir::CreateBasicBlock(nullptr, \"case-after\", &b_);",
          "new_line_content": "  // Add a terminator to the case block, if necessary.",
          "content_same": false
        },
        {
          "line": 2722,
          "old_api": "GetInsertPoint",
          "new_api": null,
          "old_text": "b_.GetInsertPoint()",
          "new_text": null,
          "old_line_content": "        case_block->splitBasicBlock(b_.GetInsertPoint(), \"case-after\");",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 2726,
          "old_api": "getTerminator",
          "new_api": null,
          "old_text": "case_block->getTerminator()->eraseFromParent()",
          "new_text": null,
          "old_line_content": "  case_block->getTerminator()->eraseFromParent();",
          "new_line_content": "  // Our basic block should now end with an unconditional branch.  Remove it;",
          "content_same": false
        },
        {
          "line": 2729,
          "old_api": "llvm_ir::CreateBasicBlock(nullptr, \"case-default\", &b_)",
          "new_api": null,
          "old_text": "llvm_ir::CreateBasicBlock(nullptr, \"case-default\", &b_)",
          "new_text": null,
          "old_line_content": "  auto default_block = llvm_ir::CreateBasicBlock(nullptr, \"case-default\", &b_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2730,
          "old_api": "SetInsertPoint",
          "new_api": null,
          "old_text": "b_.SetInsertPoint(default_block)",
          "new_text": null,
          "old_line_content": "  b_.SetInsertPoint(default_block);",
          "new_line_content": "  // Lower the default branch computation.",
          "content_same": false
        },
        {
          "line": 2736,
          "old_api": "SetInsertPoint",
          "new_api": null,
          "old_text": "b_.SetInsertPoint(case_block)",
          "new_text": null,
          "old_line_content": "  b_.SetInsertPoint(case_block);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2743,
          "old_api": "absl::StrCat(\"case-branch\", b)",
          "new_api": null,
          "old_text": "absl::StrCat(\"case-branch\", b)",
          "new_text": null,
          "old_line_content": "        llvm_ir::CreateBasicBlock(nullptr, absl::StrCat(\"case-branch\", b), &b_);",
          "new_line_content": "    // Lower the case b: { ... ; break; } computation.",
          "content_same": false
        },
        {
          "line": 2744,
          "old_api": "SetInsertPoint",
          "new_api": null,
          "old_text": "b_.SetInsertPoint(branch_block)",
          "new_text": null,
          "old_line_content": "    b_.SetInsertPoint(branch_block);",
          "new_line_content": "    auto branch_block =",
          "content_same": false
        },
        {
          "line": 2751,
          "old_api": "SetToFirstInsertPoint",
          "new_api": null,
          "old_text": "SetToFirstInsertPoint(after_block, &b_)",
          "new_text": null,
          "old_line_content": "  SetToFirstInsertPoint(after_block, &b_);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2752,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2756,
          "old_api": "shape",
          "new_api": null,
          "old_text": "after_all->shape()",
          "new_text": null,
          "old_line_content": "  TF_RET_CHECK(ByteSizeOf(after_all->shape()) == 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2759,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  // No code to generate, but we need to emit an address for book-keeping.",
          "content_same": false
        },
        {
          "line": 2765,
          "old_api": "operand",
          "new_api": null,
          "old_text": "add_dependency->operand(0)",
          "new_text": null,
          "old_line_content": "      GetEmittedValueFor(add_dependency->operand(0));",
          "new_line_content": "  // AddDedendency just forwards its zero-th operand.",
          "content_same": false
        },
        {
          "line": 2766,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  emitted_value_[add_dependency] =",
          "content_same": false
        },
        {
          "line": 2770,
          "old_api": "Unimplemented",
          "new_api": null,
          "old_text": "Unimplemented(\"Rng should be expanded for CPU.\")",
          "new_text": null,
          "old_line_content": "  return Unimplemented(\"Rng should be expanded for CPU.\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2774,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "rng_state->ToString()",
          "new_text": null,
          "old_line_content": "  VLOG(2) << \"RngGetAndUpdateState: \" << rng_state->ToString();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2775,
          "old_api": "delta",
          "new_api": null,
          "old_text": "llvm_ir::RngGetAndUpdateState(\n      Cast<HloRngGetAndUpdateStateInstruction>(rng_state)->delta(), module_,\n      &b_)",
          "new_text": null,
          "old_line_content": "  llvm::Value* old_state = llvm_ir::RngGetAndUpdateState(",
          "new_line_content": "Status IrEmitter::HandleRngGetAndUpdateState(HloInstruction* rng_state) {",
          "content_same": false
        },
        {
          "line": 2779,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(rng_state)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(rng_state));",
          "new_line_content": "      &b_);",
          "content_same": false
        },
        {
          "line": 2780,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(rng_state)",
          "new_text": null,
          "old_line_content": "  llvm::Value* address = GetEmittedValueFor(rng_state);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2784,
          "old_api": "getType",
          "new_api": null,
          "old_text": "llvm::PointerType::get(\n                                 old_state->getType()->getScalarType(),\n                                 address->getType()->getPointerAddressSpace())",
          "new_text": null,
          "old_line_content": "  address = BitCast(address, llvm::PointerType::get(",
          "new_line_content": "  // The buffer has an array type while the value has a i128. Cast the",
          "content_same": false
        },
        {
          "line": 2785,
          "old_api": "getType",
          "new_api": null,
          "old_text": "old_state->getType()->getScalarType()",
          "new_text": null,
          "old_line_content": "                                 old_state->getType()->getScalarType(),",
          "new_line_content": "  // buffer to i128 type to store the value.",
          "content_same": false
        },
        {
          "line": 2801,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "root->ToString()",
          "new_text": null,
          "old_line_content": "  VLOG(2) << \"FinishVisit root: \" << root->ToString();",
          "new_line_content": "  // nothing to do since the result was already written directly into the output",
          "content_same": false
        },
        {
          "line": 2802,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "root->opcode()",
          "new_text": null,
          "old_line_content": "  if (root->opcode() == HloOpcode::kOutfeed) {",
          "new_line_content": "  // buffer.",
          "content_same": false
        },
        {
          "line": 2811,
          "old_api": "RecordCompleteComputation",
          "new_api": null,
          "old_text": "profiling_state_.RecordCompleteComputation(&b_, prof_counter)",
          "new_text": null,
          "old_line_content": "      profiling_state_.RecordCompleteComputation(&b_, prof_counter);",
          "new_line_content": "  auto record_complete_computation = [&](llvm::Value* prof_counter) {",
          "content_same": false
        },
        {
          "line": 2818,
          "old_api": "parent",
          "new_api": null,
          "old_text": "root->parent()",
          "new_text": null,
          "old_line_content": "  record_complete_computation(GetProfileCounterFor(*root->parent()));",
          "new_line_content": "  // computations since it includes cycles spent in computations invoked by",
          "content_same": false
        },
        {
          "line": 2819,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  // While, Call etc.",
          "content_same": false
        },
        {
          "line": 2826,
          "old_api": "find",
          "new_api": null,
          "old_text": "profile_index_map.find(&hlo)",
          "new_text": null,
          "old_line_content": "  auto it = profile_index_map.find(&hlo);",
          "new_line_content": "    const T& hlo,",
          "content_same": false
        },
        {
          "line": 2827,
          "old_api": "end",
          "new_api": null,
          "old_text": "profile_index_map.end()",
          "new_text": null,
          "old_line_content": "  if (it == profile_index_map.end()) {",
          "new_line_content": "    const std::unordered_map<const T*, int64>& profile_index_map) {",
          "content_same": false
        },
        {
          "line": 2832,
          "old_api": "name",
          "new_api": null,
          "old_text": "hlo.name()",
          "new_text": null,
          "old_line_content": "  string counter_name = IrName(\"prof_counter\", hlo.name());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2833,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "b_.getInt64(prof_counter_idx)",
          "new_text": null,
          "old_line_content": "  return GEP(GetProfileCountersArgument(), b_.getInt64(prof_counter_idx),",
          "new_line_content": "  int64 prof_counter_idx = it->second;",
          "content_same": false
        },
        {
          "line": 2839,
          "old_api": "GetProfileCounterCommon<HloInstruction>(instruction,\n                                                 instruction_to_profile_idx_)",
          "new_api": null,
          "old_text": "GetProfileCounterCommon<HloInstruction>(instruction,\n                                                 instruction_to_profile_idx_)",
          "new_text": null,
          "old_line_content": "  return GetProfileCounterCommon<HloInstruction>(instruction,",
          "new_line_content": "llvm::Value* IrEmitter::GetProfileCounterFor(",
          "content_same": false
        },
        {
          "line": 2845,
          "old_api": "GetProfileCounterCommon<HloComputation>(computation,\n                                                 computation_to_profile_idx_)",
          "new_api": null,
          "old_text": "GetProfileCounterCommon<HloComputation>(computation,\n                                                 computation_to_profile_idx_)",
          "new_text": null,
          "old_line_content": "  return GetProfileCounterCommon<HloComputation>(computation,",
          "new_line_content": "llvm::Value* IrEmitter::GetProfileCounterFor(",
          "content_same": false
        },
        {
          "line": 2853,
          "old_api": "CreateSub",
          "new_api": null,
          "old_text": "b->CreateSub(cycle_end, cycle_start)",
          "new_text": null,
          "old_line_content": "  auto* cycle_diff = b->CreateSub(cycle_end, cycle_start);",
          "new_line_content": "                                                     llvm::Value* cycle_end,",
          "content_same": false
        },
        {
          "line": 2858,
          "old_api": "CreateStore",
          "new_api": null,
          "old_text": "b->CreateStore(new_cycle_count, prof_counter)",
          "new_text": null,
          "old_line_content": "  b->CreateStore(new_cycle_count, prof_counter);",
          "new_line_content": "  auto* new_cycle_count =",
          "content_same": false
        },
        {
          "line": 2862,
          "old_api": "GetInsertBlock",
          "new_api": null,
          "old_text": "b->GetInsertBlock()->getModule()",
          "new_text": null,
          "old_line_content": "  llvm::Module* module = b->GetInsertBlock()->getModule();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2865,
          "old_api": "llvm::Intrinsic::getDeclaration(module,\n                                        llvm::Intrinsic::readcyclecounter)",
          "new_api": null,
          "old_text": "llvm::Intrinsic::getDeclaration(module,\n                                        llvm::Intrinsic::readcyclecounter)",
          "new_text": null,
          "old_line_content": "        llvm::Intrinsic::getDeclaration(module,",
          "new_line_content": "  if (!use_rdtscp_) {",
          "content_same": false
        },
        {
          "line": 2870,
          "old_api": "llvm::Intrinsic::getDeclaration(module, llvm::Intrinsic::x86_rdtscp)",
          "new_api": null,
          "old_text": "llvm::Intrinsic::getDeclaration(module, llvm::Intrinsic::x86_rdtscp)",
          "new_text": null,
          "old_line_content": "      llvm::Intrinsic::getDeclaration(module, llvm::Intrinsic::x86_rdtscp);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2871,
          "old_api": "CreateCall",
          "new_api": null,
          "old_text": "b->CreateCall(func_llvm_x86_rdtscp)",
          "new_text": null,
          "old_line_content": "  llvm::Value* rdtscp_call = b->CreateCall(func_llvm_x86_rdtscp);",
          "new_line_content": "  llvm::Function* func_llvm_x86_rdtscp =",
          "content_same": false
        },
        {
          "line": 2877,
          "old_api": "ReadCycleCounter",
          "new_api": null,
          "old_text": "ReadCycleCounter(b)",
          "new_text": null,
          "old_line_content": "  auto* cycle_start = ReadCycleCounter(b);",
          "new_line_content": "void IrEmitter::ProfilingState::RecordCycleStart(llvm::IRBuilder<>* b,",
          "content_same": false
        },
        {
          "line": 2878,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(hlo, \"cycle_start\")",
          "new_text": null,
          "old_line_content": "  cycle_start->setName(IrName(hlo, \"cycle_start\"));",
          "new_line_content": "                                                 HloInstruction* hlo) {",
          "content_same": false
        },
        {
          "line": 2888,
          "old_api": "ReadCycleCounter",
          "new_api": null,
          "old_text": "ReadCycleCounter(b)",
          "new_text": null,
          "old_line_content": "  auto* cycle_end = ReadCycleCounter(b);",
          "new_line_content": "                                                 HloInstruction* hlo,",
          "content_same": false
        },
        {
          "line": 2889,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(hlo, \"cycle_end\")",
          "new_text": null,
          "old_line_content": "  cycle_end->setName(IrName(hlo, \"cycle_end\"));",
          "new_line_content": "                                                 llvm::Value* prof_counter) {",
          "content_same": false
        },
        {
          "line": 2898,
          "old_api": "UpdateProfileCounter",
          "new_api": null,
          "old_text": "UpdateProfileCounter(b, prof_counter, last_read_cycle_end_,\n                         first_read_cycle_start_)",
          "new_text": null,
          "old_line_content": "    UpdateProfileCounter(b, prof_counter, last_read_cycle_end_,",
          "new_line_content": "    llvm::IRBuilder<>* b, llvm::Value* prof_counter) {",
          "content_same": false
        },
        {
          "line": 2910,
          "old_api": "getInt8Ty",
          "new_api": null,
          "old_text": "b->getInt8Ty()->getPointerTo()",
          "new_text": null,
          "old_line_content": "  llvm::Type* int8_ptr_type = b->getInt8Ty()->getPointerTo();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2914,
          "old_api": "getInt64Ty",
          "new_api": null,
          "old_text": "b->getInt64Ty()",
          "new_text": null,
          "old_line_content": "      llvm::FunctionType::get(b->getInt64Ty(), {void_ptr_type, int8_ptr_type},",
          "new_line_content": "      int8_ptr_type;  // LLVM does not have a void*, we use an int8* instead.",
          "content_same": false
        },
        {
          "line": 2917,
          "old_api": "GetInsertBlock",
          "new_api": null,
          "old_text": "b->GetInsertBlock()->getParent()",
          "new_text": null,
          "old_line_content": "  llvm::Function* function = b->GetInsertBlock()->getParent();",
          "new_line_content": "                              /*isVarArg=*/false);",
          "content_same": false
        },
        {
          "line": 2918,
          "old_api": "getParent",
          "new_api": null,
          "old_text": "function->getParent()",
          "new_text": null,
          "old_line_content": "  llvm::Module* module = function->getParent();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2921,
          "old_api": "getOrInsertFunction",
          "new_api": null,
          "old_text": "module->getOrInsertFunction(fn_name, fn_type)",
          "new_text": null,
          "old_line_content": "      module->getOrInsertFunction(fn_name, fn_type);",
          "new_line_content": "  const char* fn_name = runtime::kTracingStartSymbolName;",
          "content_same": false
        },
        {
          "line": 2922,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "trace_func.getCallee()",
          "new_text": null,
          "old_line_content": "  if (auto* fn = llvm::dyn_cast<llvm::Function>(trace_func.getCallee())) {",
          "new_line_content": "  llvm::FunctionCallee trace_func =",
          "content_same": false
        },
        {
          "line": 2930,
          "old_api": "CreateBitCast",
          "new_api": null,
          "old_text": "b->CreateBitCast(hlo_name, int8_ptr_type)",
          "new_text": null,
          "old_line_content": "                                 b->CreateBitCast(hlo_name, int8_ptr_type)});",
          "new_line_content": "  auto* activity_id =",
          "content_same": false
        },
        {
          "line": 2943,
          "old_api": "getInt8Ty",
          "new_api": null,
          "old_text": "b->getInt8Ty()->getPointerTo()",
          "new_text": null,
          "old_line_content": "      b->getInt8Ty()->getPointerTo();  // LLVM does not have a void*, we use an",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2946,
          "old_api": "getInt64Ty",
          "new_api": null,
          "old_text": "b->getInt64Ty()",
          "new_text": null,
          "old_line_content": "      llvm::FunctionType::get(b->getVoidTy(), {void_ptr_type, b->getInt64Ty()},",
          "new_line_content": "                                       // int8* instead.",
          "content_same": false
        },
        {
          "line": 2949,
          "old_api": "GetInsertBlock",
          "new_api": null,
          "old_text": "b->GetInsertBlock()->getParent()",
          "new_text": null,
          "old_line_content": "  llvm::Function* function = b->GetInsertBlock()->getParent();",
          "new_line_content": "                              /*isVarArg=*/false);",
          "content_same": false
        },
        {
          "line": 2950,
          "old_api": "getParent",
          "new_api": null,
          "old_text": "function->getParent()",
          "new_text": null,
          "old_line_content": "  llvm::Module* module = function->getParent();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2953,
          "old_api": "getOrInsertFunction",
          "new_api": null,
          "old_text": "module->getOrInsertFunction(fn_name, fn_type)",
          "new_text": null,
          "old_line_content": "      module->getOrInsertFunction(fn_name, fn_type);",
          "new_line_content": "  const char* fn_name = runtime::kTracingEndSymbolName;",
          "content_same": false
        },
        {
          "line": 2954,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "trace_func.getCallee()",
          "new_text": null,
          "old_line_content": "  if (auto* fn = llvm::dyn_cast<llvm::Function>(trace_func.getCallee())) {",
          "new_line_content": "  llvm::FunctionCallee trace_func =",
          "content_same": false
        },
        {
          "line": 2960,
          "old_api": "CreateCall",
          "new_api": null,
          "old_text": "b->CreateCall(trace_func,\n                {b->CreateBitCast(run_options, void_ptr_type), activity_id})",
          "new_text": null,
          "old_line_content": "  b->CreateCall(trace_func,",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2966,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "hlo->opcode()",
          "new_text": null,
          "old_line_content": "  return hlo->opcode() == HloOpcode::kBitcast ||",
          "new_line_content": "namespace {",
          "content_same": false
        },
        {
          "line": 2967,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "hlo->opcode()",
          "new_text": null,
          "old_line_content": "         hlo->opcode() == HloOpcode::kTuple ||",
          "new_line_content": "bool IsHloVeryCheap(const HloInstruction* hlo) {",
          "content_same": false
        },
        {
          "line": 2975,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "hlo->ToString()",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"Visiting: \" << hlo->ToString();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2978,
          "old_api": "IsHloVeryCheap",
          "new_api": null,
          "old_text": "IsHloVeryCheap(hlo)",
          "new_text": null,
          "old_line_content": "      (hlo_module_config_.cpu_traceme_enabled() && !IsHloVeryCheap(hlo))) {",
          "new_line_content": "  // When profiling is enabled, trace the same HLOs that the profiler does.",
          "content_same": false
        },
        {
          "line": 2987,
          "old_api": "GetProfileCounterFor",
          "new_api": null,
          "old_text": "GetProfileCounterFor(*hlo)",
          "new_text": null,
          "old_line_content": "  if (auto* prof_counter = GetProfileCounterFor(*hlo)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2988,
          "old_api": "RecordCycleDelta",
          "new_api": null,
          "old_text": "profiling_state_.RecordCycleDelta(&b_, hlo, prof_counter)",
          "new_text": null,
          "old_line_content": "    profiling_state_.RecordCycleDelta(&b_, hlo, prof_counter);",
          "new_line_content": "Status IrEmitter::Postprocess(HloInstruction* hlo) {",
          "content_same": false
        },
        {
          "line": 2991,
          "old_api": "count",
          "new_api": null,
          "old_text": "instruction_to_profile_idx_.count(hlo)",
          "new_text": null,
          "old_line_content": "  if (instruction_to_profile_idx_.count(hlo) ||",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2992,
          "old_api": "IsHloVeryCheap",
          "new_api": null,
          "old_text": "IsHloVeryCheap(hlo)",
          "new_text": null,
          "old_line_content": "      (hlo_module_config_.cpu_traceme_enabled() && !IsHloVeryCheap(hlo))) {",
          "new_line_content": "  // When profiling is enabled, trace the same HLOs that the profiler does.",
          "content_same": false
        },
        {
          "line": 2999,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(hlo)",
          "new_text": null,
          "old_line_content": "  llvm::Value* value_for_op = GetEmittedValueFor(hlo);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3002,
          "old_api": "AddAliasingInformationToIrArray",
          "new_api": null,
          "old_text": "AddAliasingInformationToIrArray(*hlo, &array)",
          "new_text": null,
          "old_line_content": "  AddAliasingInformationToIrArray(*hlo, &array);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3009,
          "old_api": "begin",
          "new_api": null,
          "old_text": "std::transform(\n      hlo->operands().begin(), hlo->operands().end(),\n      std::back_inserter(arrays),\n      [&](const HloInstruction* operand) { return GetIrArrayFor(operand); })",
          "new_text": null,
          "old_line_content": "  std::transform(",
          "new_line_content": "    const HloInstruction* hlo) {",
          "content_same": false
        },
        {
          "line": 3010,
          "old_api": "end",
          "new_api": null,
          "old_text": "hlo->operands().end()",
          "new_text": null,
          "old_line_content": "      hlo->operands().begin(), hlo->operands().end(),",
          "new_line_content": "  std::vector<llvm_ir::IrArray> arrays;",
          "content_same": false
        },
        {
          "line": 3017,
          "old_api": "find",
          "new_api": null,
          "old_text": "emitted_value_.find(hlo)",
          "new_text": null,
          "old_line_content": "  auto it = emitted_value_.find(hlo);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3018,
          "old_api": "end",
          "new_api": null,
          "old_text": "emitted_value_.end()",
          "new_text": null,
          "old_line_content": "  if (it == emitted_value_.end()) {",
          "new_line_content": "llvm::Value* IrEmitter::GetEmittedValueFor(const HloInstruction* hlo) {",
          "content_same": false
        },
        {
          "line": 3025,
          "old_api": "llvm_ir::ShapeToIrType(shape, module_)",
          "new_api": null,
          "old_text": "llvm_ir::ShapeToIrType(shape, module_)",
          "new_text": null,
          "old_line_content": "  return llvm_ir::ShapeToIrType(shape, module_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3029,
          "old_api": "profile_counters_arg",
          "new_api": null,
          "old_text": "compute_function_->profile_counters_arg()",
          "new_text": null,
          "old_line_content": "  return compute_function_->profile_counters_arg();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3033,
          "old_api": "buffer_table_arg",
          "new_api": null,
          "old_text": "compute_function_->buffer_table_arg()",
          "new_text": null,
          "old_line_content": "  return compute_function_->buffer_table_arg();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3037,
          "old_api": "exec_run_options_arg",
          "new_api": null,
          "old_text": "compute_function_->exec_run_options_arg()",
          "new_text": null,
          "old_line_content": "  return compute_function_->exec_run_options_arg();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3042,
          "old_api": "allocation",
          "new_api": null,
          "old_text": "slice.allocation()",
          "new_text": null,
          "old_line_content": "  const BufferAllocation& allocation = *slice.allocation();",
          "new_line_content": "llvm::Value* IrEmitter::EmitThreadLocalBufferPointer(",
          "content_same": false
        },
        {
          "line": 3043,
          "old_api": "find",
          "new_api": null,
          "old_text": "() -> llvm::Value* {\n    auto param_it =\n        computation_parameter_allocations_.find(slice.allocation()->index());\n    if (param_it != computation_parameter_allocations_.end()) {\n      int64 param_number = param_it->second;\n      // We have to access the parameter at offset param_number in the params\n      // array. The code generated here is equivalent to this C code:\n      //\n      //   i8* param_address_untyped = params[param_number];\n      //   Param* param_address_typed = (Param*)param_address_untyped;\n      //\n      // Where Param is the actual element type of the underlying buffer (for\n      // example, float for an XLA F32 element type).\n      llvm::Value* params = compute_function_->parameters_arg();\n      llvm::Value* param_address_offset =\n          llvm_ir::EmitBufferIndexingGEP(params, param_number, &b_);\n      llvm::LoadInst* param_address_untyped = Load(param_address_offset);\n\n      if (!target_shape.IsOpaque()) {\n        AttachAlignmentMetadataForLoad(param_address_untyped, target_shape);\n        AttachDereferenceableMetadataForLoad(param_address_untyped,\n                                             target_shape);\n      }\n      return param_address_untyped;\n    }\n\n    // Thread-local allocations should only be assigned a single buffer.\n    const auto& assigned_buffers = allocation.assigned_buffers();\n    CHECK_EQ(1, assigned_buffers.size());\n    const Shape& shape = assigned_buffers.begin()->first->shape();\n\n    std::pair<llvm::Function*, BufferAllocation::Slice> key = {\n        compute_function_->function(), slice};\n    auto buf_it = thread_local_buffers_.find(key);\n    if (buf_it == thread_local_buffers_.end()) {\n      llvm::Value* buffer = llvm_ir::EmitAllocaAtFunctionEntry(\n          IrShapeType(shape), absl::StrCat(\"thread_local\", slice.ToString()),\n          &b_, MinimumAlignmentForShape(target_shape));\n      auto it_inserted_pair = thread_local_buffers_.insert({key, buffer});\n      CHECK(it_inserted_pair.second);\n      buf_it = it_inserted_pair.first;\n    }\n    return buf_it->second;\n  }()",
          "new_text": null,
          "old_line_content": "  llvm::Value* tempbuf_address = [&]() -> llvm::Value* {",
          "new_line_content": "    const BufferAllocation::Slice& slice, const Shape& target_shape) {",
          "content_same": false
        },
        {
          "line": 3046,
          "old_api": "end",
          "new_api": null,
          "old_text": "computation_parameter_allocations_.end()",
          "new_text": null,
          "old_line_content": "    if (param_it != computation_parameter_allocations_.end()) {",
          "new_line_content": "    auto param_it =",
          "content_same": false
        },
        {
          "line": 3056,
          "old_api": "parameters_arg",
          "new_api": null,
          "old_text": "compute_function_->parameters_arg()",
          "new_text": null,
          "old_line_content": "      llvm::Value* params = compute_function_->parameters_arg();",
          "new_line_content": "      // Where Param is the actual element type of the underlying buffer (for",
          "content_same": false
        },
        {
          "line": 3059,
          "old_api": "Load",
          "new_api": null,
          "old_text": "Load(param_address_offset)",
          "new_text": null,
          "old_line_content": "      llvm::LoadInst* param_address_untyped = Load(param_address_offset);",
          "new_line_content": "      llvm::Value* param_address_offset =",
          "content_same": false
        },
        {
          "line": 3062,
          "old_api": "AttachAlignmentMetadataForLoad",
          "new_api": null,
          "old_text": "AttachAlignmentMetadataForLoad(param_address_untyped, target_shape)",
          "new_text": null,
          "old_line_content": "        AttachAlignmentMetadataForLoad(param_address_untyped, target_shape);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3070,
          "old_api": "assigned_buffers",
          "new_api": null,
          "old_text": "allocation.assigned_buffers()",
          "new_text": null,
          "old_line_content": "    const auto& assigned_buffers = allocation.assigned_buffers();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3071,
          "old_api": "size",
          "new_api": null,
          "old_text": "assigned_buffers.size()",
          "new_text": null,
          "old_line_content": "    CHECK_EQ(1, assigned_buffers.size());",
          "new_line_content": "    // Thread-local allocations should only be assigned a single buffer.",
          "content_same": false
        },
        {
          "line": 3075,
          "old_api": "function",
          "new_api": null,
          "old_text": "compute_function_->function()",
          "new_text": null,
          "old_line_content": "        compute_function_->function(), slice};",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3076,
          "old_api": "find",
          "new_api": null,
          "old_text": "thread_local_buffers_.find(key)",
          "new_text": null,
          "old_line_content": "    auto buf_it = thread_local_buffers_.find(key);",
          "new_line_content": "    std::pair<llvm::Function*, BufferAllocation::Slice> key = {",
          "content_same": false
        },
        {
          "line": 3087,
          "old_api": "getPointerTo",
          "new_api": null,
          "old_text": "IrShapeType(target_shape)->getPointerTo()",
          "new_text": null,
          "old_line_content": "  return BitCast(tempbuf_address, IrShapeType(target_shape)->getPointerTo());",
          "new_line_content": "    return buf_it->second;",
          "content_same": false
        },
        {
          "line": 3092,
          "old_api": "allocation",
          "new_api": null,
          "old_text": "slice.allocation()",
          "new_text": null,
          "old_line_content": "  const BufferAllocation& allocation = *slice.allocation();",
          "new_line_content": "llvm::Value* IrEmitter::EmitGlobalBufferPointer(",
          "content_same": false
        },
        {
          "line": 3093,
          "old_api": "index",
          "new_api": null,
          "old_text": "llvm_ir::EmitBufferIndexingGEP(\n      GetBufferTableArgument(), slice.index(), &b_)",
          "new_text": null,
          "old_line_content": "  llvm::Value* tempbuf_address_ptr = llvm_ir::EmitBufferIndexingGEP(",
          "new_line_content": "    const BufferAllocation::Slice& slice, const Shape& target_shape) {",
          "content_same": false
        },
        {
          "line": 3103,
          "old_api": "size",
          "new_api": null,
          "old_text": "allocation.size()",
          "new_text": null,
          "old_line_content": "  AttachDereferenceableMetadataForLoad(tempbuf_address_base, allocation.size());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3106,
          "old_api": "offset",
          "new_api": null,
          "old_text": "slice.offset()",
          "new_text": null,
          "old_line_content": "  if (slice.offset() > 0) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3109,
          "old_api": "offset",
          "new_api": null,
          "old_text": "slice.offset()",
          "new_text": null,
          "old_line_content": "        InBoundsGEP(tempbuf_address_base, b_.getInt64(slice.offset()));",
          "new_line_content": "    // Adjust the address to account for the slice offset.",
          "content_same": false
        },
        {
          "line": 3112,
          "old_api": "getPointerTo",
          "new_api": null,
          "old_text": "IrShapeType(target_shape)->getPointerTo()",
          "new_text": null,
          "old_line_content": "                 IrShapeType(target_shape)->getPointerTo());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3117,
          "old_api": "allocation",
          "new_api": null,
          "old_text": "slice.allocation()->is_thread_local()",
          "new_text": null,
          "old_line_content": "  if (slice.allocation()->is_thread_local()) {",
          "new_line_content": "llvm::Value* IrEmitter::EmitBufferPointer(const BufferAllocation::Slice& slice,",
          "content_same": false
        },
        {
          "line": 3118,
          "old_api": "EmitThreadLocalBufferPointer",
          "new_api": null,
          "old_text": "EmitThreadLocalBufferPointer(slice, target_shape)",
          "new_text": null,
          "old_line_content": "    return EmitThreadLocalBufferPointer(slice, target_shape);",
          "new_line_content": "                                          const Shape& target_shape) {",
          "content_same": false
        },
        {
          "line": 3129,
          "old_api": "shape",
          "new_api": null,
          "old_text": "op->shape()",
          "new_text": null,
          "old_line_content": "  const Shape& target_shape = op->shape();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3132,
          "old_api": "EmitBufferPointer",
          "new_api": null,
          "old_text": "EmitBufferPointer(slice, target_shape)",
          "new_text": null,
          "old_line_content": "  llvm::Value* addr = EmitBufferPointer(slice, target_shape);",
          "new_line_content": "  TF_ASSIGN_OR_RETURN(const BufferAllocation::Slice slice,",
          "content_same": false
        },
        {
          "line": 3133,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(op)",
          "new_text": null,
          "old_line_content": "  addr->setName(IrName(op));",
          "new_line_content": "                      assignment_.GetUniqueTopLevelSlice(op));",
          "content_same": false
        },
        {
          "line": 3141,
          "old_api": "EmitTargetElementLoop",
          "new_api": null,
          "old_text": "EmitTargetElementLoop(target_op, /*desc=*/\"\", element_generator)",
          "new_text": null,
          "old_line_content": "  return EmitTargetElementLoop(target_op, /*desc=*/\"\", element_generator);",
          "new_line_content": "    HloInstruction* target_op,",
          "content_same": false
        },
        {
          "line": 3147,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "target_op->ToString()",
          "new_text": null,
          "old_line_content": "  VLOG(2) << \"EmitTargetElementLoop: \" << target_op->ToString();",
          "new_line_content": "    HloInstruction* target_op, absl::string_view desc,",
          "content_same": false
        },
        {
          "line": 3150,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(target_op)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(target_op));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3154,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "target_op->opcode()",
          "new_text": null,
          "old_line_content": "      (target_op->opcode() == HloOpcode::kFusion ||",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3163,
          "old_api": "ShapeUtil::GetSubshape(target_shape, {i})",
          "new_api": null,
          "old_text": "ShapeUtil::GetSubshape(target_shape, {i})",
          "new_text": null,
          "old_line_content": "      const Shape& element_shape = ShapeUtil::GetSubshape(target_shape, {i});",
          "new_line_content": "      TF_ASSIGN_OR_RETURN(BufferAllocation::Slice slice,",
          "content_same": false
        },
        {
          "line": 3164,
          "old_api": "EmitBufferPointer",
          "new_api": null,
          "old_text": "EmitBufferPointer(slice, element_shape)",
          "new_text": null,
          "old_line_content": "      llvm::Value* op_target_address = EmitBufferPointer(slice, element_shape);",
          "new_line_content": "                          assignment_.GetUniqueSlice(target_op, {i}));",
          "content_same": false
        },
        {
          "line": 3169,
          "old_api": "EmitLoop",
          "new_api": null,
          "old_text": "llvm_ir::LoopEmitter(element_generator, output_arrays, &b_)\n            .EmitLoop(IrName(target_op))",
          "new_text": null,
          "old_line_content": "        llvm_ir::LoopEmitter(element_generator, output_arrays, &b_)",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3173,
          "old_api": "size",
          "new_api": null,
          "old_text": "output_arrays.size()",
          "new_text": null,
          "old_line_content": "    for (int64 i = 0; i < output_arrays.size(); ++i) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3174,
          "old_api": "GetBasePointer",
          "new_api": null,
          "old_text": "output_arrays[i].GetBasePointer()",
          "new_text": null,
          "old_line_content": "      tuple_operand_ptrs.push_back(output_arrays[i].GetBasePointer());",
          "new_line_content": "    std::vector<llvm::Value*> tuple_operand_ptrs;",
          "content_same": false
        },
        {
          "line": 3179,
          "old_api": "ShouldEmitParallelLoopFor",
          "new_api": null,
          "old_text": "ShouldEmitParallelLoopFor(*target_op)",
          "new_text": null,
          "old_line_content": "    if (ShouldEmitParallelLoopFor(*target_op)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3182,
          "old_api": "GetDynamicLoopBounds",
          "new_api": null,
          "old_text": "compute_function_->GetDynamicLoopBounds()",
          "new_text": null,
          "old_line_content": "          compute_function_->GetDynamicLoopBounds();",
          "new_line_content": "      // Emit code to read dynamic loop bounds from compute function argument.",
          "content_same": false
        },
        {
          "line": 3189,
          "old_api": "EmitLoop",
          "new_api": null,
          "old_text": "llvm_ir::LoopEmitter(element_generator, target_array, &b_)\n              .EmitLoop(IrName(target_op))",
          "new_text": null,
          "old_line_content": "          llvm_ir::LoopEmitter(element_generator, target_array, &b_)",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 3193,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3198,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(&source)",
          "new_text": null,
          "old_line_content": "  llvm::Value* source_value = GetEmittedValueFor(&source);",
          "new_line_content": "Status IrEmitter::EmitMemcpy(const HloInstruction& source,",
          "content_same": false
        },
        {
          "line": 3199,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(&destination)",
          "new_text": null,
          "old_line_content": "  llvm::Value* destination_value = GetEmittedValueFor(&destination);",
          "new_line_content": "                             const HloInstruction& destination) {",
          "content_same": false
        },
        {
          "line": 3203,
          "old_api": "llvm::Align(1)",
          "new_api": null,
          "old_text": "llvm::Align(1)",
          "new_text": null,
          "old_line_content": "         /*SrcAlign=*/llvm::Align(1), source_size);",
          "new_line_content": "  // TODO(b/63762267): Be more aggressive about specifying alignment.",
          "content_same": false
        },
        {
          "line": 3212,
          "old_api": "shape",
          "new_api": null,
          "old_text": "TF_RET_CHECK(\n        ShapeUtil::SameElementType(operands[0]->shape(), operand->shape()))",
          "new_text": null,
          "old_line_content": "    TF_RET_CHECK(",
          "new_line_content": "    absl::Span<const PrimitiveType> supported_types) {",
          "content_same": false
        },
        {
          "line": 3213,
          "old_api": "shape",
          "new_api": null,
          "old_text": "operand->shape()",
          "new_text": null,
          "old_line_content": "        ShapeUtil::SameElementType(operands[0]->shape(), operand->shape()));",
          "new_line_content": "  for (auto operand : operands) {",
          "content_same": false
        },
        {
          "line": 3216,
          "old_api": "empty",
          "new_api": null,
          "old_text": "operands.empty()",
          "new_text": null,
          "old_line_content": "  TF_RET_CHECK(!operands.empty());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3217,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "operands[0]->shape().element_type()",
          "new_text": null,
          "old_line_content": "  PrimitiveType primitive_type = operands[0]->shape().element_type();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3228,
          "old_api": "operands",
          "new_api": null,
          "old_text": "hlo->operands()",
          "new_text": null,
          "old_line_content": "  for (const HloInstruction* operand : hlo->operands()) {",
          "new_line_content": "Status IrEmitter::DefaultAction(HloInstruction* hlo) {",
          "content_same": false
        },
        {
          "line": 3234,
          "old_api": "MakeElementGenerator",
          "new_api": null,
          "old_text": "EmitTargetElementLoop(\n      hlo, elemental_emitter.MakeElementGenerator(hlo, operand_to_generator))",
          "new_text": null,
          "old_line_content": "  return EmitTargetElementLoop(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3235,
          "old_api": "MakeElementGenerator",
          "new_api": null,
          "old_text": "elemental_emitter.MakeElementGenerator(hlo, operand_to_generator)",
          "new_text": null,
          "old_line_content": "      hlo, elemental_emitter.MakeElementGenerator(hlo, operand_to_generator));",
          "new_line_content": "  CpuElementalIrEmitter elemental_emitter(hlo_module_config_, this, module_);",
          "content_same": false
        },
        {
          "line": 3242,
          "old_api": "EmitThreadLocalCall",
          "new_api": null,
          "old_text": "EmitThreadLocalCall(callee, parameters, name)",
          "new_text": null,
          "old_line_content": "      EmitThreadLocalCall(callee, parameters, name);",
          "new_line_content": "    absl::string_view name) {",
          "content_same": false
        },
        {
          "line": 3243,
          "old_api": "size",
          "new_api": null,
          "old_text": "return_value.size()",
          "new_text": null,
          "old_line_content": "  CHECK_EQ(return_value.size(), 1);",
          "new_line_content": "  std::vector<llvm::Value*> return_value =",
          "content_same": false
        },
        {
          "line": 3250,
          "old_api": "absl::c_binary_search(thread_local_computations_, &callee)",
          "new_api": null,
          "old_text": "absl::c_binary_search(thread_local_computations_, &callee)",
          "new_text": null,
          "old_line_content": "  CHECK(absl::c_binary_search(thread_local_computations_, &callee));",
          "new_line_content": "    const HloComputation& callee, absl::Span<llvm::Value* const> parameters,",
          "content_same": false
        },
        {
          "line": 3251,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "callee.root_instruction()->shape()",
          "new_text": null,
          "old_line_content": "  const Shape& return_shape = callee.root_instruction()->shape();",
          "new_line_content": "    absl::string_view name) {",
          "content_same": false
        },
        {
          "line": 3255,
          "old_api": "tuple_shapes",
          "new_api": null,
          "old_text": "return_shape.tuple_shapes()",
          "new_text": null,
          "old_line_content": "      absl::c_all_of(return_shape.tuple_shapes(), [&](const Shape& shape) {",
          "new_line_content": "  bool is_tuple_of_scalars_return =",
          "content_same": false
        },
        {
          "line": 3262,
          "old_api": "getType",
          "new_api": null,
          "old_text": "parameter->getType()->isPointerTy()",
          "new_text": null,
          "old_line_content": "    CHECK(!parameter->getType()->isPointerTy());",
          "new_line_content": "  std::vector<llvm::Value*> parameter_addrs;",
          "content_same": false
        },
        {
          "line": 3263,
          "old_api": "getType",
          "new_api": null,
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n        parameter->getType(), \"arg_addr\", &b_)",
          "new_text": null,
          "old_line_content": "    llvm::Value* parameter_addr = llvm_ir::EmitAllocaAtFunctionEntry(",
          "new_line_content": "  for (llvm::Value* parameter : parameters) {",
          "content_same": false
        },
        {
          "line": 3270,
          "old_api": "llvm_ir::ShapeToIrType(return_shape, module_)",
          "new_api": null,
          "old_text": "llvm_ir::ShapeToIrType(return_shape, module_)",
          "new_text": null,
          "old_line_content": "      llvm_ir::ShapeToIrType(return_shape, module_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3271,
          "old_api": "absl::StrCat(name, \"_return_value_addr\")",
          "new_api": null,
          "old_text": "absl::StrCat(name, \"_return_value_addr\")",
          "new_text": null,
          "old_line_content": "  std::string retval_alloca_name = absl::StrCat(name, \"_return_value_addr\");",
          "new_line_content": "  llvm::Type* return_value_buffer_type =",
          "content_same": false
        },
        {
          "line": 3274,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "return_shape.element_type()",
          "new_text": null,
          "old_line_content": "          ? MinimumAlignmentForPrimitiveType(return_shape.element_type())",
          "new_line_content": "  int retval_alignment =",
          "content_same": false
        },
        {
          "line": 3281,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "allocas_for_returned_scalars.push_back(return_value_buffer)",
          "new_text": null,
          "old_line_content": "    allocas_for_returned_scalars.push_back(return_value_buffer);",
          "new_line_content": "  std::vector<llvm::Value*> allocas_for_returned_scalars;",
          "content_same": false
        },
        {
          "line": 3284,
          "old_api": "tuple_shapes_size",
          "new_api": null,
          "old_text": "return_shape.tuple_shapes_size()",
          "new_text": null,
          "old_line_content": "    CHECK_LT(return_shape.tuple_shapes_size(), max_tuple_size)",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 3288,
          "old_api": "llvm_ir::EmitTupleAllocasAtFunctionEntry(return_shape, &b_)",
          "new_api": null,
          "old_text": "llvm_ir::EmitTupleAllocasAtFunctionEntry(return_shape, &b_)",
          "new_text": null,
          "old_line_content": "        llvm_ir::EmitTupleAllocasAtFunctionEntry(return_shape, &b_);",
          "new_line_content": "        << \" stack smashing\";",
          "content_same": false
        },
        {
          "line": 3291,
          "old_api": "EmitTuple",
          "new_api": null,
          "old_text": "EmitTuple(tuple_array, allocas_for_returned_scalars, &b_)",
          "new_text": null,
          "old_line_content": "    EmitTuple(tuple_array, allocas_for_returned_scalars, &b_);",
          "new_line_content": "    llvm_ir::IrArray tuple_array(return_value_buffer, return_shape);",
          "content_same": false
        },
        {
          "line": 3294,
          "old_api": "FindOrDie",
          "new_api": null,
          "old_text": "FindOrDie(emitted_functions_, &callee)",
          "new_text": null,
          "old_line_content": "  Call(FindOrDie(emitted_functions_, &callee),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3295,
          "old_api": "getInt8PtrTy",
          "new_api": null,
          "old_text": "GetArrayFunctionCallArguments(\n           parameter_addrs, &b_, name,\n           /*return_value_buffer=*/return_value_buffer,\n           /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),\n           /*buffer_table_arg=*/\n           llvm::Constant::getNullValue(b_.getInt8PtrTy()->getPointerTo()),\n           /*profile_counters_arg=*/GetProfileCountersArgument())",
          "new_text": null,
          "old_line_content": "       GetArrayFunctionCallArguments(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3298,
          "old_api": "GetExecutableRunOptionsArgument",
          "new_api": null,
          "old_text": "GetExecutableRunOptionsArgument()",
          "new_text": null,
          "old_line_content": "           /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),",
          "new_line_content": "           parameter_addrs, &b_, name,",
          "content_same": false
        },
        {
          "line": 3301,
          "old_api": "GetProfileCountersArgument",
          "new_api": null,
          "old_text": "GetProfileCountersArgument()",
          "new_text": null,
          "old_line_content": "           /*profile_counters_arg=*/GetProfileCountersArgument()));",
          "new_line_content": "           /*buffer_table_arg=*/",
          "content_same": false
        },
        {
          "line": 3304,
          "old_api": "size",
          "new_api": null,
          "old_text": "allocas_for_returned_scalars.size()",
          "new_text": null,
          "old_line_content": "  returned_scalars.reserve(allocas_for_returned_scalars.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3313,
          "old_api": "absl::c_binary_search(global_computations_, &callee)",
          "new_api": null,
          "old_text": "absl::c_binary_search(global_computations_, &callee)",
          "new_text": null,
          "old_line_content": "  CHECK(absl::c_binary_search(global_computations_, &callee));",
          "new_line_content": "void IrEmitter::EmitGlobalCall(const HloComputation& callee,",
          "content_same": false
        },
        {
          "line": 3316,
          "old_api": "getInt8PtrTy",
          "new_api": null,
          "old_text": "GetArrayFunctionCallArguments(\n           /*parameter_addresses=*/{}, &b_, name,\n           /*return_value_buffer=*/\n           llvm::Constant::getNullValue(b_.getInt8PtrTy()),\n           /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),\n           /*buffer_table_arg=*/GetBufferTableArgument(),\n           /*profile_counters_arg=*/GetProfileCountersArgument())",
          "new_text": null,
          "old_line_content": "       GetArrayFunctionCallArguments(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3319,
          "old_api": "getInt8PtrTy",
          "new_api": null,
          "old_text": "b_.getInt8PtrTy()",
          "new_text": null,
          "old_line_content": "           llvm::Constant::getNullValue(b_.getInt8PtrTy()),",
          "new_line_content": "           /*parameter_addresses=*/{}, &b_, name,",
          "content_same": false
        },
        {
          "line": 3320,
          "old_api": "GetExecutableRunOptionsArgument",
          "new_api": null,
          "old_text": "GetExecutableRunOptionsArgument()",
          "new_text": null,
          "old_line_content": "           /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),",
          "new_line_content": "           /*return_value_buffer=*/",
          "content_same": false
        },
        {
          "line": 3327,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "callee.root_instruction()",
          "new_text": null,
          "old_line_content": "  const HloInstruction* root_inst = callee.root_instruction();",
          "new_line_content": "llvm::Value* IrEmitter::GetBufferForGlobalCallReturnValue(",
          "content_same": false
        },
        {
          "line": 3328,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "root_inst->opcode()",
          "new_text": null,
          "old_line_content": "  if (root_inst->opcode() == HloOpcode::kOutfeed) {",
          "new_line_content": "    const HloComputation& callee) {",
          "content_same": false
        },
        {
          "line": 3333,
          "old_api": "GetUniqueTopLevelSlice",
          "new_api": null,
          "old_text": "assignment_.GetUniqueTopLevelSlice(root_inst).ValueOrDie()",
          "new_text": null,
          "old_line_content": "      assignment_.GetUniqueTopLevelSlice(root_inst).ValueOrDie();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3334,
          "old_api": "shape",
          "new_api": null,
          "old_text": "root_inst->shape()",
          "new_text": null,
          "old_line_content": "  return EmitBufferPointer(root_buffer, root_inst->shape());",
          "new_line_content": "  const BufferAllocation::Slice root_buffer =",
          "content_same": false
        },
        {
          "line": 3339,
          "old_api": "operand_count",
          "new_api": null,
          "old_text": "fusion->operand_count()",
          "new_text": null,
          "old_line_content": "  for (int i = 0; i < fusion->operand_count(); i++) {",
          "new_line_content": "void IrEmitter::BindFusionArguments(const HloInstruction* fusion,",
          "content_same": false
        },
        {
          "line": 3340,
          "old_api": "operand",
          "new_api": null,
          "old_text": "fusion->operand(i)",
          "new_text": null,
          "old_line_content": "    const HloInstruction* operand = fusion->operand(i);",
          "new_line_content": "                                    FusedIrEmitter* fused_emitter) {",
          "content_same": false
        },
        {
          "line": 1450,
          "old_api": "getType",
          "new_api": null,
          "old_text": "lhs->getType()",
          "new_text": null,
          "old_line_content": "                                              {lhs, rhs}, {lhs->getType()}, b);",
          "new_line_content": "              lhs, rhs, b,",
          "content_same": false
        },
        {
          "line": 1453,
          "old_api": "CreateSelect",
          "new_api": null,
          "old_text": "b->CreateSelect(\n            b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SGE\n                                         : llvm::ICmpInst::ICMP_UGE,\n                          lhs, rhs),\n            lhs, rhs)",
          "new_text": null,
          "old_line_content": "        return b->CreateSelect(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1465,
          "old_api": "getType",
          "new_api": null,
          "old_text": "llvm_ir::EmitCallToIntrinsic(llvm::Intrinsic::minnum,\n                                              {lhs, rhs}, {lhs->getType()}, b)",
          "new_text": null,
          "old_line_content": "          return llvm_ir::EmitCallToIntrinsic(llvm::Intrinsic::minnum,",
          "new_line_content": "        if (root_is_floating_point) {",
          "content_same": false
        },
        {
          "line": 1469,
          "old_api": "CreateSelect",
          "new_api": null,
          "old_text": "b->CreateSelect(\n            b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SLE\n                                         : llvm::ICmpInst::ICMP_ULE,\n                          lhs, rhs),\n            lhs, rhs)",
          "new_text": null,
          "old_line_content": "        return b->CreateSelect(",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1470,
          "old_api": "CreateICmp",
          "new_api": null,
          "old_text": "b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SLE\n                                         : llvm::ICmpInst::ICMP_ULE,\n                          lhs, rhs)",
          "new_text": null,
          "old_line_content": "            b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SLE",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1481,
          "old_api": "vector_register_byte_size",
          "new_api": null,
          "old_text": "target_machine_features_.vector_register_byte_size(\n          *compute_function_->function())",
          "new_text": null,
          "old_line_content": "      target_machine_features_.vector_register_byte_size(",
          "new_line_content": "    PrimitiveType element_type, unsigned element_count) {",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": "function",
          "new_api": null,
          "old_text": "compute_function_->function()",
          "new_text": null,
          "old_line_content": "          *compute_function_->function()) /",
          "new_line_content": "  int vector_register_size_in_elements =",
          "content_same": false
        },
        {
          "line": 1487,
          "old_api": "llvm_ir::PrimitiveTypeToIrType(element_type, module_)",
          "new_api": null,
          "old_text": "llvm_ir::PrimitiveTypeToIrType(element_type, module_)",
          "new_text": null,
          "old_line_content": "      llvm_ir::PrimitiveTypeToIrType(element_type, module_);",
          "new_line_content": "  ShardedVectorType sharded_vector_type;",
          "content_same": false
        },
        {
          "line": 1500,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "sharded_vector_type.push_back(element_ir_type)",
          "new_text": null,
          "old_line_content": "      sharded_vector_type.push_back(element_ir_type);",
          "new_line_content": "    if (current_size_fragment == 1) {",
          "content_same": false
        },
        {
          "line": 1508,
          "old_api": "llvm::VectorType::get(\n          element_ir_type, vector_register_size_in_elements, false)",
          "new_api": null,
          "old_text": "llvm::VectorType::get(\n          element_ir_type, vector_register_size_in_elements, false)",
          "new_text": null,
          "old_line_content": "      auto vector_type = llvm::VectorType::get(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1511,
          "old_api": "end",
          "new_api": null,
          "old_text": "sharded_vector_type.end()",
          "new_text": null,
          "old_line_content": "          sharded_vector_type.end(),",
          "new_line_content": "          element_ir_type, vector_register_size_in_elements, false);",
          "content_same": false
        },
        {
          "line": 1517,
          "old_api": "CHECK_EQ",
          "new_api": null,
          "old_text": "CHECK_EQ(current_size_fragment % vector_register_size_in_elements, 0)",
          "new_text": null,
          "old_line_content": "      CHECK_EQ(current_size_fragment % vector_register_size_in_elements, 0);",
          "new_line_content": "      // Both current_size_fragment and vector_register_size_in_elements are",
          "content_same": false
        },
        {
          "line": 1524,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "sharded_vector_type.push_back(\n        llvm::VectorType::get(element_ir_type, current_size_fragment, false))",
          "new_text": null,
          "old_line_content": "    sharded_vector_type.push_back(",
          "new_line_content": "    // of two are all legal vector sizes (or at least can be lowered easily by",
          "content_same": false
        },
        {
          "line": 1525,
          "old_api": "llvm::VectorType::get(element_ir_type, current_size_fragment, false)",
          "new_api": null,
          "old_text": "llvm::VectorType::get(element_ir_type, current_size_fragment, false)",
          "new_text": null,
          "old_line_content": "        llvm::VectorType::get(element_ir_type, current_size_fragment, false));",
          "new_line_content": "    // LLVM).",
          "content_same": false
        },
        {
          "line": 1538,
          "old_api": "size",
          "new_api": null,
          "old_text": "accumulator_type.size()",
          "new_text": null,
          "old_line_content": "  accumulator.reserve(accumulator_type.size());",
          "new_line_content": "    llvm::Align element_alignment) {",
          "content_same": false
        },
        {
          "line": 1544,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(init_value)",
          "new_text": null,
          "old_line_content": "  llvm::Value* init_value_ssa = Load(GetEmittedValueFor(init_value));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1548,
          "old_api": "getType",
          "new_api": null,
          "old_text": "accumulator_shard->getType()->getPointerElementType()",
          "new_text": null,
          "old_line_content": "    auto shard_type = accumulator_shard->getType()->getPointerElementType();",
          "new_line_content": "  for (llvm::Value* accumulator_shard : accumulator) {",
          "content_same": false
        },
        {
          "line": 1549,
          "old_api": "llvm::dyn_cast<llvm::VectorType>(shard_type)",
          "new_api": null,
          "old_text": "llvm::dyn_cast<llvm::VectorType>(shard_type)",
          "new_text": null,
          "old_line_content": "    if (auto vector_type = llvm::dyn_cast<llvm::VectorType>(shard_type)) {",
          "new_line_content": "    llvm::Value* initial_value;",
          "content_same": false
        },
        {
          "line": 1556,
          "old_api": "AlignedStore",
          "new_api": null,
          "old_text": "AlignedStore(initial_value, accumulator_shard, element_alignment)",
          "new_text": null,
          "old_line_content": "    AlignedStore(initial_value, accumulator_shard, element_alignment);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1559,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(arg, \"vectorized_inner\")",
          "new_text": null,
          "old_line_content": "  llvm_ir::ForLoopNest reduction_loop_nest(IrName(arg, \"vectorized_inner\"),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1562,
          "old_api": "shape",
          "new_api": null,
          "old_text": "arg->shape()",
          "new_text": null,
          "old_line_content": "      reduction_loop_nest.AddLoopsForShapeOnDimensions(arg->shape(), dimensions,",
          "new_line_content": "                                           &b_);",
          "content_same": false
        },
        {
          "line": 1565,
          "old_api": "GetInnerLoopBodyBasicBlock",
          "new_api": null,
          "old_text": "reduction_loop_nest.GetInnerLoopBodyBasicBlock()",
          "new_text": null,
          "old_line_content": "  SetToFirstInsertPoint(reduction_loop_nest.GetInnerLoopBodyBasicBlock(), &b_);",
          "new_line_content": "                                                       \"reduction_dim\");",
          "content_same": false
        },
        {
          "line": 1568,
          "old_api": "begin",
          "new_api": null,
          "old_text": "output_index.begin()",
          "new_text": null,
          "old_line_content": "  llvm_ir::IrArray::Index::const_iterator it = output_index.begin();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1575,
          "old_api": "end",
          "new_api": null,
          "old_text": "output_index.end()",
          "new_text": null,
          "old_line_content": "  CHECK(output_index.end() == it);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1576,
          "old_api": "shape",
          "new_api": null,
          "old_text": "arg->shape()",
          "new_text": null,
          "old_line_content": "  llvm_ir::IrArray::Index input_index(input_multi_index, arg->shape(),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1580,
          "old_api": "getInt8PtrTy",
          "new_api": null,
          "old_text": "b_.getInt8PtrTy()",
          "new_text": null,
          "old_line_content": "      arg_array.EmitArrayElementAddress(input_index, &b_), b_.getInt8PtrTy());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1587,
          "old_api": "AlignedLoad",
          "new_api": null,
          "old_text": "AlignedLoad(input_address_typed, element_alignment)",
          "new_text": null,
          "old_line_content": "    auto addend = AlignedLoad(input_address_typed, element_alignment);",
          "new_line_content": "    auto current_accumulator_value =",
          "content_same": false
        },
        {
          "line": 1591,
          "old_api": "reduction_generator",
          "new_api": null,
          "old_text": "reduction_generator(&b_, current_accumulator_value, addend)",
          "new_text": null,
          "old_line_content": "        reduction_generator(&b_, current_accumulator_value, addend);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1592,
          "old_api": "AlignedStore",
          "new_api": null,
          "old_text": "AlignedStore(reduced_result, accumulator[i], element_alignment)",
          "new_text": null,
          "old_line_content": "    AlignedStore(reduced_result, accumulator[i], element_alignment);",
          "new_line_content": "    auto reduced_result =",
          "content_same": false
        },
        {
          "line": 1595,
          "old_api": "getType",
          "new_api": null,
          "old_text": "reduced_result->getType()",
          "new_text": null,
          "old_line_content": "      input_address = ConstInBoundsGEP1_32(reduced_result->getType(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1600,
          "old_api": "GetOuterLoopExitBasicBlock",
          "new_api": null,
          "old_text": "reduction_loop_nest.GetOuterLoopExitBasicBlock()",
          "new_text": null,
          "old_line_content": "  SetToFirstInsertPoint(reduction_loop_nest.GetOuterLoopExitBasicBlock(), &b_);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1603,
          "old_api": "size",
          "new_api": null,
          "old_text": "accumulator.size()",
          "new_text": null,
          "old_line_content": "  result_ssa.reserve(accumulator.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": "size",
          "new_api": null,
          "old_text": "value_to_store.size()",
          "new_text": null,
          "old_line_content": "  for (int i = 0; i < value_to_store.size(); i++) {",
          "new_line_content": "    llvm::Value* store_address, const std::vector<llvm::Value*>& value_to_store,",
          "content_same": false
        },
        {
          "line": 1616,
          "old_api": "getType",
          "new_api": null,
          "old_text": "value_to_store[i]->getType()",
          "new_text": null,
          "old_line_content": "                llvm::PointerType::getUnqual(value_to_store[i]->getType()));",
          "new_line_content": "    auto store_address_typed =",
          "content_same": false
        },
        {
          "line": 1619,
          "old_api": "AlignedStore",
          "new_api": null,
          "old_text": "AlignedStore(value_to_store[i], store_address_typed, alignment)",
          "new_text": null,
          "old_line_content": "        AlignedStore(value_to_store[i], store_address_typed, alignment);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1620,
          "old_api": "AnnotateLoadStoreInstructionWithMetadata",
          "new_api": null,
          "old_text": "containing_array.AnnotateLoadStoreInstructionWithMetadata(\n        store_instruction)",
          "new_text": null,
          "old_line_content": "    containing_array.AnnotateLoadStoreInstructionWithMetadata(",
          "new_line_content": "    auto store_instruction =",
          "content_same": false
        },
        {
          "line": 1623,
          "old_api": "size",
          "new_api": null,
          "old_text": "value_to_store.size()",
          "new_text": null,
          "old_line_content": "    if (i != (value_to_store.size() - 1)) {",
          "new_line_content": "        store_instruction);",
          "content_same": false
        },
        {
          "line": 1624,
          "old_api": "getType",
          "new_api": null,
          "old_text": "value_to_store[i]->getType()",
          "new_text": null,
          "old_line_content": "      store_address = ConstInBoundsGEP1_32(value_to_store[i]->getType(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1634,
          "old_api": "IsArray",
          "new_api": null,
          "old_text": "reduce->shape().IsArray()",
          "new_text": null,
          "old_line_content": "  if (!reduce->shape().IsArray()) {",
          "new_line_content": "    absl::Span<const int64> dimensions, HloComputation* function,",
          "content_same": false
        },
        {
          "line": 1639,
          "old_api": "ReductionPreservesLayout",
          "new_api": null,
          "old_text": "ReductionPreservesLayout(*reduce)",
          "new_text": null,
          "old_line_content": "  if (!ReductionPreservesLayout(*reduce)) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1644,
          "old_api": "MatchReductionGenerator",
          "new_api": null,
          "old_text": "MatchReductionGenerator(function, failure_reason)",
          "new_text": null,
          "old_line_content": "      MatchReductionGenerator(function, failure_reason);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1650,
          "old_api": "vector_register_byte_size",
          "new_api": null,
          "old_text": "target_machine_features_.vector_register_byte_size(\n          *compute_function_->function())",
          "new_text": null,
          "old_line_content": "      target_machine_features_.vector_register_byte_size(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1651,
          "old_api": "function",
          "new_api": null,
          "old_text": "compute_function_->function()",
          "new_text": null,
          "old_line_content": "          *compute_function_->function()) /",
          "new_line_content": "  int vector_register_size_in_elements =",
          "content_same": false
        },
        {
          "line": 1660,
          "old_api": "vectorization_factor_in_bytes",
          "new_api": null,
          "old_text": "target_machine_features_.vectorization_factor_in_bytes()",
          "new_text": null,
          "old_line_content": "      target_machine_features_.vectorization_factor_in_bytes();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1665,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "reduce->shape().element_type()",
          "new_text": null,
          "old_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(reduce->shape().element_type());",
          "new_line_content": "  const int vectorization_factor =",
          "content_same": false
        },
        {
          "line": 1668,
          "old_api": "layout",
          "new_api": null,
          "old_text": "arg->shape().layout()",
          "new_text": null,
          "old_line_content": "      dimensions, LayoutUtil::Minor(arg->shape().layout(), 0));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1671,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "reduce->shape().element_type()",
          "new_text": null,
          "old_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(reduce->shape().element_type()),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1680,
          "old_api": "IsTuple",
          "new_api": null,
          "old_text": "reduce->shape().IsTuple()",
          "new_text": null,
          "old_line_content": "  CHECK(!reduce->shape().IsTuple());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1681,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(reduce)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(reduce));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1703,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(reduce)",
          "new_text": null,
          "old_line_content": "  llvm_ir::ForLoopNest loop_nest(IrName(reduce), &b_);",
          "new_line_content": "  //  }",
          "content_same": false
        },
        {
          "line": 1706,
          "old_api": "shape",
          "new_api": null,
          "old_text": "reduce->shape()",
          "new_text": null,
          "old_line_content": "  for (int i = LayoutUtil::MinorToMajor(reduce->shape()).size() - 1; i > 0;",
          "new_line_content": "  std::vector<llvm::Value*> array_multi_index(",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": "AddLoop",
          "new_api": null,
          "old_text": "loop_nest.AddLoop(\n        start_index, end_index, absl::StrFormat(\"dim.%d\", dimension))",
          "new_text": null,
          "old_line_content": "    std::unique_ptr<llvm_ir::ForLoop> loop = loop_nest.AddLoop(",
          "new_line_content": "    int64 start_index = 0;",
          "content_same": false
        },
        {
          "line": 1716,
          "old_api": "layout",
          "new_api": null,
          "old_text": "reduce->shape().layout()",
          "new_text": null,
          "old_line_content": "  int64 innermost_dimension = LayoutUtil::Minor(reduce->shape().layout(), 0);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": "GetInnerLoopBodyBasicBlock",
          "new_api": null,
          "old_text": "loop_nest.GetInnerLoopBodyBasicBlock()",
          "new_text": null,
          "old_line_content": "          loop_nest.GetInnerLoopBodyBasicBlock()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1722,
          "old_api": "SetToFirstInsertPoint",
          "new_api": null,
          "old_text": "SetToFirstInsertPoint(innermost_body_bb, &b_)",
          "new_text": null,
          "old_line_content": "    SetToFirstInsertPoint(innermost_body_bb, &b_);",
          "new_line_content": "  if (llvm::BasicBlock* innermost_body_bb =",
          "content_same": false
        },
        {
          "line": 1725,
          "old_api": "GetOuterLoopExitBasicBlock",
          "new_api": null,
          "old_text": "loop_nest.GetOuterLoopExitBasicBlock()",
          "new_text": null,
          "old_line_content": "  auto outermost_loop_exit_block = loop_nest.GetOuterLoopExitBasicBlock();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1732,
          "old_api": "AddLoop",
          "new_api": null,
          "old_text": "loop_nest.AddLoop(start_index, end_index, vectorization_factor,\n                          absl::StrFormat(\"dim.%d\", innermost_dimension))",
          "new_text": null,
          "old_line_content": "        loop_nest.AddLoop(start_index, end_index, vectorization_factor,",
          "new_line_content": "                      vectorization_factor;",
          "content_same": false
        },
        {
          "line": 1733,
          "old_api": "absl::StrFormat(\"dim.%d\", innermost_dimension)",
          "new_api": null,
          "old_text": "absl::StrFormat(\"dim.%d\", innermost_dimension)",
          "new_text": null,
          "old_line_content": "                          absl::StrFormat(\"dim.%d\", innermost_dimension));",
          "new_line_content": "    std::unique_ptr<llvm_ir::ForLoop> loop =",
          "content_same": false
        },
        {
          "line": 1739,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "reduce->shape().element_type()",
          "new_text": null,
          "old_line_content": "        reduce->shape().element_type(), vectorization_factor);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1747,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(reduce)",
          "new_text": null,
          "old_line_content": "    llvm_ir::IrArray target_array = GetIrArrayFor(reduce);",
          "new_line_content": "                            init_value, arg, dimensions, element_alignment));",
          "content_same": false
        },
        {
          "line": 1750,
          "old_api": "EmitShardedVectorStore",
          "new_api": null,
          "old_text": "EmitShardedVectorStore(output_address, accumulator, element_alignment,\n                           target_array)",
          "new_text": null,
          "old_line_content": "    EmitShardedVectorStore(output_address, accumulator, element_alignment,",
          "new_line_content": "    llvm::Value* output_address =",
          "content_same": false
        },
        {
          "line": 1753,
          "old_api": "GetExitBasicBlock",
          "new_api": null,
          "old_text": "loop->GetExitBasicBlock()->getTerminator()",
          "new_text": null,
          "old_line_content": "    if (auto exit_terminator = loop->GetExitBasicBlock()->getTerminator()) {",
          "new_line_content": "                           target_array);",
          "content_same": false
        },
        {
          "line": 1754,
          "old_api": "shape",
          "new_api": null,
          "old_text": "reduce->shape()",
          "new_text": null,
          "old_line_content": "      CHECK_GT(LayoutUtil::MinorToMajor(reduce->shape()).size(), 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1758,
          "old_api": "GetExitBasicBlock",
          "new_api": null,
          "old_text": "loop->GetExitBasicBlock()",
          "new_text": null,
          "old_line_content": "      b_.SetInsertPoint(loop->GetExitBasicBlock());",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1768,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "b_.getInt64(innermost_dimension_size -\n                    (innermost_dimension_size % vectorization_factor))",
          "new_text": null,
          "old_line_content": "        b_.getInt64(innermost_dimension_size -",
          "new_line_content": "    // TODO(b/63775531): Consider using a scalar loop here to save on code size.",
          "content_same": false
        },
        {
          "line": 1771,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "CreateShardedVectorType(\n        reduce->shape().element_type(),\n        innermost_dimension_size % vectorization_factor)",
          "new_text": null,
          "old_line_content": "    ShardedVectorType vector_type = CreateShardedVectorType(",
          "new_line_content": "                    (innermost_dimension_size % vectorization_factor));",
          "content_same": false
        },
        {
          "line": 1772,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "reduce->shape().element_type()",
          "new_text": null,
          "old_line_content": "        reduce->shape().element_type(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1775,
          "old_api": "getInt64Ty",
          "new_api": null,
          "old_text": "b_.getInt64Ty()",
          "new_text": null,
          "old_line_content": "                                        b_.getInt64Ty());",
          "new_line_content": "        innermost_dimension_size % vectorization_factor);",
          "content_same": false
        },
        {
          "line": 1781,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(reduce)",
          "new_text": null,
          "old_line_content": "    llvm_ir::IrArray target_array = GetIrArrayFor(reduce);",
          "new_line_content": "                            init_value, arg, dimensions, element_alignment));",
          "content_same": false
        },
        {
          "line": 1784,
          "old_api": "EmitShardedVectorStore",
          "new_api": null,
          "old_text": "EmitShardedVectorStore(output_address, accumulator, element_alignment,\n                           target_array)",
          "new_text": null,
          "old_line_content": "    EmitShardedVectorStore(output_address, accumulator, element_alignment,",
          "new_line_content": "    llvm::Value* output_address =",
          "content_same": false
        },
        {
          "line": 1789,
          "old_api": "SetInsertPoint",
          "new_api": null,
          "old_text": "b_.SetInsertPoint(outermost_loop_exit_block)",
          "new_text": null,
          "old_line_content": "    b_.SetInsertPoint(outermost_loop_exit_block);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1796,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "reduce->mutable_operand(0)",
          "new_text": null,
          "old_line_content": "  auto arg = reduce->mutable_operand(0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1797,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "reduce->mutable_operand(1)",
          "new_text": null,
          "old_line_content": "  auto init_value = reduce->mutable_operand(1);",
          "new_line_content": "Status IrEmitter::HandleReduce(HloInstruction* reduce) {",
          "content_same": false
        },
        {
          "line": 1807,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "reduce->ToString()",
          "new_text": null,
          "old_line_content": "      VLOG(1) << \"Successfully vectorized reduction \" << reduce->ToString()",
          "new_line_content": "                             &vectorization_failure_reason));",
          "content_same": false
        },
        {
          "line": 1816,
          "old_api": "DefaultAction",
          "new_api": null,
          "old_text": "DefaultAction(reduce)",
          "new_text": null,
          "old_line_content": "  return DefaultAction(reduce);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1821,
          "old_api": "Unimplemented",
          "new_api": null,
          "old_text": "Unimplemented(\"Send is not implemented on CPU.\")",
          "new_text": null,
          "old_line_content": "  return Unimplemented(\"Send is not implemented on CPU.\");",
          "new_line_content": "Status IrEmitter::HandleSend(HloInstruction* send) {",
          "content_same": false
        },
        {
          "line": 1826,
          "old_api": "Unimplemented",
          "new_api": null,
          "old_text": "Unimplemented(\"Send-done is not implemented on CPU.\")",
          "new_text": null,
          "old_line_content": "  return Unimplemented(\"Send-done is not implemented on CPU.\");",
          "new_line_content": "Status IrEmitter::HandleSendDone(HloInstruction* send_done) {",
          "content_same": false
        },
        {
          "line": 1830,
          "old_api": "Unimplemented",
          "new_api": null,
          "old_text": "Unimplemented(\"Scatter is not implemented on CPUs.\")",
          "new_text": null,
          "old_line_content": "  return Unimplemented(\"Scatter is not implemented on CPUs.\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1834,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "slice->ToString()",
          "new_text": null,
          "old_line_content": "  VLOG(2) << \"HandleSlice: \" << slice->ToString();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1835,
          "old_api": "operand",
          "new_api": null,
          "old_text": "slice->operand(0)",
          "new_text": null,
          "old_line_content": "  auto operand = slice->operand(0);",
          "new_line_content": "Status IrEmitter::HandleSlice(HloInstruction* slice) {",
          "content_same": false
        },
        {
          "line": 1838,
          "old_api": "ShouldEmitParallelLoopFor",
          "new_api": null,
          "old_text": "ShouldEmitParallelLoopFor(*slice)",
          "new_text": null,
          "old_line_content": "  if (ShouldEmitParallelLoopFor(*slice)) {",
          "new_line_content": "  // The code below emits a sequential loop nest. For the parallel backend, use",
          "content_same": false
        },
        {
          "line": 1839,
          "old_api": "DefaultAction",
          "new_api": null,
          "old_text": "DefaultAction(slice)",
          "new_text": null,
          "old_line_content": "    return DefaultAction(slice);",
          "new_line_content": "  // ParallelLoopEmitter which respects dynamic loop bounds.",
          "content_same": false
        },
        {
          "line": 1843,
          "old_api": "layout",
          "new_api": null,
          "old_text": "slice->shape().layout()",
          "new_text": null,
          "old_line_content": "  if (!LayoutUtil::Equal(operand->shape().layout(), slice->shape().layout())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1844,
          "old_api": "DefaultAction",
          "new_api": null,
          "old_text": "DefaultAction(slice)",
          "new_text": null,
          "old_line_content": "    return DefaultAction(slice);",
          "new_line_content": "  // The code below assumes the layouts are equal.",
          "content_same": false
        },
        {
          "line": 1847,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(slice)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(slice));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1850,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "    return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1853,
          "old_api": "layout",
          "new_api": null,
          "old_text": "operand->shape().layout()",
          "new_text": null,
          "old_line_content": "  const Layout& layout = operand->shape().layout();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1854,
          "old_api": "dimensions_size",
          "new_api": null,
          "old_text": "operand->shape().dimensions_size()",
          "new_text": null,
          "old_line_content": "  const int64 num_dims = operand->shape().dimensions_size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1869,
          "old_api": "LayoutUtil::MinorToMajor(layout)",
          "new_api": null,
          "old_text": "LayoutUtil::MinorToMajor(layout)",
          "new_text": null,
          "old_line_content": "  for (int64 dim : LayoutUtil::MinorToMajor(layout)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1870,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "slice->shape().dimensions(dim)",
          "new_text": null,
          "old_line_content": "    if (operand->shape().dimensions(dim) != slice->shape().dimensions(dim)) {",
          "new_line_content": "  absl::flat_hash_set<int64> inner_dims;",
          "content_same": false
        },
        {
          "line": 1873,
          "old_api": "insert",
          "new_api": null,
          "old_text": "inner_dims.insert(dim)",
          "new_text": null,
          "old_line_content": "    inner_dims.insert(dim);",
          "new_line_content": "      break;",
          "content_same": false
        },
        {
          "line": 1876,
          "old_api": "size",
          "new_api": null,
          "old_text": "inner_dims.size()",
          "new_text": null,
          "old_line_content": "  const bool is_trivial_copy = (inner_dims.size() == num_dims);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1879,
          "old_api": "DefaultAction",
          "new_api": null,
          "old_text": "DefaultAction(slice)",
          "new_text": null,
          "old_line_content": "      return DefaultAction(slice);",
          "new_line_content": "  if (is_trivial_copy) {",
          "content_same": false
        },
        {
          "line": 1887,
          "old_api": "contains",
          "new_api": null,
          "old_text": "ShapeUtil::FilterDimensions(\n      [&inner_dims](int64 dim) { return inner_dims.contains(dim); },\n      operand->shape())",
          "new_text": null,
          "old_line_content": "  const Shape logical_element_shape = ShapeUtil::FilterDimensions(",
          "new_line_content": "  // The memcpy will copy elements that are logically this shape (allowed to be",
          "content_same": false
        },
        {
          "line": 1888,
          "old_api": "contains",
          "new_api": null,
          "old_text": "inner_dims.contains(dim)",
          "new_text": null,
          "old_line_content": "      [&inner_dims](int64 dim) { return inner_dims.contains(dim); },",
          "new_line_content": "  // scalar).",
          "content_same": false
        },
        {
          "line": 1892,
          "old_api": "ShapeUtil::ElementsIn(logical_element_shape)",
          "new_api": null,
          "old_text": "ShapeUtil::ElementsIn(logical_element_shape)",
          "new_text": null,
          "old_line_content": "      ShapeUtil::ElementsIn(logical_element_shape);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1896,
          "old_api": "size",
          "new_api": null,
          "old_text": "inner_dims.size()",
          "new_text": null,
          "old_line_content": "  const int64 memcpy_dim = LayoutUtil::Minor(layout, inner_dims.size());",
          "new_line_content": "  // memcpy_dim is the innermost (in terms of layout) dimension for which the",
          "content_same": false
        },
        {
          "line": 1904,
          "old_api": "slice_starts",
          "new_api": null,
          "old_text": "slice->slice_starts(memcpy_dim)",
          "new_text": null,
          "old_line_content": "          ? slice->slice_limits(memcpy_dim) - slice->slice_starts(memcpy_dim)",
          "new_line_content": "  const int64 memcpy_logical_elements =",
          "content_same": false
        },
        {
          "line": 1909,
          "old_api": "size",
          "new_api": null,
          "old_text": "inner_dims.size()",
          "new_text": null,
          "old_line_content": "  for (int64 i = 0; i < num_dims - inner_dims.size() - 1; ++i) {",
          "new_line_content": "  // Determine the dimensions that get lowered as loops.",
          "content_same": false
        },
        {
          "line": 1910,
          "old_api": "LayoutUtil::Major(layout, i)",
          "new_api": null,
          "old_text": "LayoutUtil::Major(layout, i)",
          "new_text": null,
          "old_line_content": "    outer_dims.push_back(LayoutUtil::Major(layout, i));",
          "new_line_content": "  std::vector<int64> outer_dims;",
          "content_same": false
        },
        {
          "line": 1916,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "outer_dims.push_back(memcpy_dim)",
          "new_text": null,
          "old_line_content": "    outer_dims.push_back(memcpy_dim);",
          "new_line_content": "  // needs to be wrapped around a loop as well.",
          "content_same": false
        },
        {
          "line": 1919,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(slice)",
          "new_text": null,
          "old_line_content": "  llvm_ir::IrArray target_array = GetIrArrayFor(slice);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1922,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(slice)",
          "new_text": null,
          "old_line_content": "  llvm_ir::ForLoopNest loops(IrName(slice), &b_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1929,
          "old_api": "end",
          "new_api": null,
          "old_text": "target_multi_index.end()",
          "new_text": null,
          "old_line_content": "  std::replace(target_multi_index.begin(), target_multi_index.end(),",
          "new_line_content": "  // target_index. The rest of the indices should get initialized to 0, since",
          "content_same": false
        },
        {
          "line": 1930,
          "old_api": "static_cast<llvm::Value*>(nullptr)",
          "new_api": null,
          "old_text": "static_cast<llvm::Value*>(nullptr)",
          "new_text": null,
          "old_line_content": "               static_cast<llvm::Value*>(nullptr),",
          "new_line_content": "  // for the rest of the dimensions the copy writes to the full dimension.",
          "content_same": false
        },
        {
          "line": 1936,
          "old_api": "GetInnerLoopBodyBasicBlock",
          "new_api": null,
          "old_text": "loops.GetInnerLoopBodyBasicBlock()",
          "new_text": null,
          "old_line_content": "    SetToFirstInsertPoint(loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1939,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(operand)",
          "new_text": null,
          "old_line_content": "  llvm_ir::IrArray source_array = GetIrArrayFor(operand);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1940,
          "old_api": "SourceIndexOfSlice",
          "new_api": null,
          "old_text": "target_index.SourceIndexOfSlice(\n      /*operand_shape=*/operand->shape(), /*starts=*/slice->slice_starts(),\n      /*strides=*/slice->slice_strides(), /*builder=*/&b_)",
          "new_text": null,
          "old_line_content": "  const llvm_ir::IrArray::Index source_index = target_index.SourceIndexOfSlice(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1945,
          "old_api": "EmitArrayElementAddress",
          "new_api": null,
          "old_text": "target_array.EmitArrayElementAddress(target_index, &b_, \"slice.dest\")",
          "new_text": null,
          "old_line_content": "      target_array.EmitArrayElementAddress(target_index, &b_, \"slice.dest\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1952,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "EmitTransferElements(memcpy_dest, memcpy_source, memcpy_elements,\n                       slice->shape().element_type(), target_array,\n                       source_array)",
          "new_text": null,
          "old_line_content": "  EmitTransferElements(memcpy_dest, memcpy_source, memcpy_elements,",
          "new_line_content": "      primitive_elements_per_logical_element * memcpy_logical_elements;",
          "content_same": false
        },
        {
          "line": 1953,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "slice->shape().element_type()",
          "new_text": null,
          "old_line_content": "                       slice->shape().element_type(), target_array,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1956,
          "old_api": "VLOG_IS_ON",
          "new_api": null,
          "old_text": "VLOG_IS_ON(2)",
          "new_text": null,
          "old_line_content": "  if (VLOG_IS_ON(2)) {",
          "new_line_content": "                       source_array);",
          "content_same": false
        },
        {
          "line": 1959,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(2)",
          "new_text": null,
          "old_line_content": "    VLOG(2) << \"  emitted copy of \" << memcpy_bytes << \" bytes inside \"",
          "new_line_content": "    const int64 memcpy_bytes =",
          "content_same": false
        },
        {
          "line": 1964,
          "old_api": "GetOuterLoopExitBasicBlock",
          "new_api": null,
          "old_text": "loops.GetOuterLoopExitBasicBlock()",
          "new_text": null,
          "old_line_content": "    SetToFirstInsertPoint(loops.GetOuterLoopExitBasicBlock(), &b_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1967,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1971,
          "old_api": "shape",
          "new_api": null,
          "old_text": "dynamic_slice->shape()",
          "new_text": null,
          "old_line_content": "  if (ShapeUtil::IsScalar(dynamic_slice->shape())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1972,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(dynamic_slice)",
          "new_text": null,
          "old_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(dynamic_slice));",
          "new_line_content": "Status IrEmitter::HandleDynamicSlice(HloInstruction* dynamic_slice) {",
          "content_same": false
        },
        {
          "line": 1980,
          "old_api": "operand",
          "new_api": null,
          "old_text": "dynamic_update_slice->operand(1)",
          "new_text": null,
          "old_line_content": "  auto update = dynamic_update_slice->operand(1);",
          "new_line_content": "Status IrEmitter::HandleDynamicUpdateSlice(",
          "content_same": false
        },
        {
          "line": 1981,
          "old_api": "shape",
          "new_api": null,
          "old_text": "dynamic_update_slice->shape()",
          "new_text": null,
          "old_line_content": "  if (ShapeUtil::IsScalar(dynamic_update_slice->shape())) {",
          "new_line_content": "    HloInstruction* dynamic_update_slice) {",
          "content_same": false
        },
        {
          "line": 1987,
          "old_api": "GetIrArraysForOperandsOf",
          "new_api": null,
          "old_text": "GetIrArraysForOperandsOf(dynamic_update_slice)",
          "new_text": null,
          "old_line_content": "    auto operands = GetIrArraysForOperandsOf(dynamic_update_slice);",
          "new_line_content": "                                                   assignment_)) {",
          "content_same": false
        },
        {
          "line": 1997,
          "old_api": "Unimplemented",
          "new_api": null,
          "old_text": "Unimplemented(\"Recv is not implemented on CPU.\")",
          "new_text": null,
          "old_line_content": "  return Unimplemented(\"Recv is not implemented on CPU.\");",
          "new_line_content": "Status IrEmitter::HandleRecv(HloInstruction* recv) {",
          "content_same": false
        },
        {
          "line": 2002,
          "old_api": "Unimplemented",
          "new_api": null,
          "old_text": "Unimplemented(\"Recv-done is not implemented on CPU.\")",
          "new_text": null,
          "old_line_content": "  return Unimplemented(\"Recv-done is not implemented on CPU.\");",
          "new_line_content": "Status IrEmitter::HandleRecvDone(HloInstruction* recv_done) {",
          "content_same": false
        },
        {
          "line": 2008,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "pad->padding_config().dimensions()",
          "new_text": null,
          "old_line_content": "  for (auto& padding_dimension : pad->padding_config().dimensions()) {",
          "new_line_content": "  // CPU backend does not properly handle negative padding but this is ok",
          "content_same": false
        },
        {
          "line": 2009,
          "old_api": "edge_padding_low",
          "new_api": null,
          "old_text": "padding_dimension.edge_padding_low()",
          "new_text": null,
          "old_line_content": "    if (padding_dimension.edge_padding_low() < 0 ||",
          "new_line_content": "  // because negative padding should be removed by the algebraic simplifier.",
          "content_same": false
        },
        {
          "line": 2014,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "pad->ToString()",
          "new_text": null,
          "old_line_content": "          pad->ToString());",
          "new_line_content": "          \"Encountered negative padding in IrEmitter on CPU. \"",
          "content_same": false
        },
        {
          "line": 2019,
          "old_api": "operand",
          "new_api": null,
          "old_text": "EmitTargetElementLoop(\n      pad, \"initialize\",\n      [this, pad](const llvm_ir::IrArray::Index& target_index) {\n        const HloInstruction* padding_value = pad->operand(1);\n        llvm::Value* padding_value_addr = GetEmittedValueFor(padding_value);\n        return Load(padding_value_addr);\n      })",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetElementLoop(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2022,
          "old_api": "operand",
          "new_api": null,
          "old_text": "pad->operand(1)",
          "new_text": null,
          "old_line_content": "        const HloInstruction* padding_value = pad->operand(1);",
          "new_line_content": "      pad, \"initialize\",",
          "content_same": false
        },
        {
          "line": 2023,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(padding_value)",
          "new_text": null,
          "old_line_content": "        llvm::Value* padding_value_addr = GetEmittedValueFor(padding_value);",
          "new_line_content": "      [this, pad](const llvm_ir::IrArray::Index& target_index) {",
          "content_same": false
        },
        {
          "line": 2029,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(pad, \"assign\")",
          "new_text": null,
          "old_line_content": "  llvm_ir::ForLoopNest loops(IrName(pad, \"assign\"), &b_);",
          "new_line_content": "  // Create a loop to iterate over the operand elements and update the output",
          "content_same": false
        },
        {
          "line": 2030,
          "old_api": "operand",
          "new_api": null,
          "old_text": "pad->operand(0)",
          "new_text": null,
          "old_line_content": "  const HloInstruction* operand = pad->operand(0);",
          "new_line_content": "  // locations where the operand elements should be stored.",
          "content_same": false
        },
        {
          "line": 2039,
          "old_api": "EmitReadArrayElement",
          "new_api": null,
          "old_text": "operand_array.EmitReadArrayElement(operand_index, &b_)",
          "new_text": null,
          "old_line_content": "      operand_array.EmitReadArrayElement(operand_index, &b_);",
          "new_line_content": "  llvm_ir::IrArray operand_array(GetIrArrayFor(operand));",
          "content_same": false
        },
        {
          "line": 2043,
          "old_api": "padding_config",
          "new_api": null,
          "old_text": "pad->padding_config()",
          "new_text": null,
          "old_line_content": "  const PaddingConfig& padding_config = pad->padding_config();",
          "new_line_content": "  // Compute the output index the operand element should be assigned to.",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 329,
      "total_additions": 430,
      "total_deletions": 430,
      "total_api_changes": 1189
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 10,
        "api_related_lines": 1189,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          1467,
          1445,
          1462,
          1461
        ]
      }
    },
    "api_calls_before": 2046,
    "api_calls_after": 2048,
    "diff_info": {
      "added_lines": 8,
      "removed_lines": 6,
      "total_diff_lines": 39
    }
  }
}