{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/348ef9008fa609bc9d4755ac787b88751e04f70f",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/348ef9008fa609bc9d4755ac787b88751e04f70f/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/348ef9008fa609bc9d4755ac787b88751e04f70f/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/348ef9008fa609bc9d4755ac787b88751e04f70f/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": true,
    "api_changes": {
      "replacements": [
        {
          "line": 1539,
          "old_api": "size",
          "new_api": "add_feed",
          "old_text": "inputs_sorted.size()",
          "new_text": "callable_options.add_feed(input)",
          "old_line_content": "  callable_options.mutable_feed()->Reserve(inputs_sorted.size());",
          "new_line_content": "    callable_options.add_feed(input);",
          "content_same": false
        },
        {
          "line": 1541,
          "old_api": "add_feed",
          "new_api": "size",
          "old_text": "callable_options.add_feed(input)",
          "new_text": "outputs_sorted.size()",
          "old_line_content": "    callable_options.add_feed(input);",
          "new_line_content": "  callable_options.mutable_fetch()->Reserve(outputs_sorted.size());",
          "content_same": false
        },
        {
          "line": 1543,
          "old_api": "size",
          "new_api": "add_fetch",
          "old_text": "outputs_sorted.size()",
          "new_text": "callable_options.add_fetch(output)",
          "old_line_content": "  callable_options.mutable_fetch()->Reserve(outputs_sorted.size());",
          "new_line_content": "    callable_options.add_fetch(output);",
          "content_same": false
        },
        {
          "line": 1545,
          "old_api": "add_fetch",
          "new_api": "size",
          "old_text": "callable_options.add_fetch(output)",
          "new_text": "tn_sorted.size()",
          "old_line_content": "    callable_options.add_fetch(output);",
          "new_line_content": "  callable_options.mutable_target()->Reserve(tn_sorted.size());",
          "content_same": false
        },
        {
          "line": 1547,
          "old_api": "size",
          "new_api": "add_target",
          "old_text": "tn_sorted.size()",
          "new_text": "callable_options.add_target(target)",
          "old_line_content": "  callable_options.mutable_target()->Reserve(tn_sorted.size());",
          "new_line_content": "    callable_options.add_target(target);",
          "content_same": false
        },
        {
          "line": 1549,
          "old_api": "add_target",
          "new_api": "mutable_run_options",
          "old_text": "callable_options.add_target(target)",
          "new_text": "callable_options.mutable_run_options()->mutable_debug_options()",
          "old_line_content": "    callable_options.add_target(target);",
          "new_line_content": "  *callable_options.mutable_run_options()->mutable_debug_options() =",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": "std::move(ek)",
          "new_api": "std::move(func_info)",
          "old_text": "std::move(ek)",
          "new_text": "std::move(func_info)",
          "old_line_content": "      sorted_key, std::shared_ptr<ExecutorsAndKeys>(std::move(ek)));",
          "new_line_content": "    functions_.push_back(std::move(func_info));",
          "content_same": false
        },
        {
          "line": 1575,
          "old_api": "get",
          "new_api": "Status::OK()",
          "old_text": "insert_result.first->second.get()",
          "new_text": "Status::OK()",
          "old_line_content": "  *executors_and_keys = insert_result.first->second.get();",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 1609,
          "old_api": "get",
          "new_api": "BuildGraph",
          "old_text": "execution_state_.get()",
          "new_text": "execution_state->BuildGraph(subgraph_options, &client_graph)",
          "old_line_content": "    execution_state = execution_state_.get();",
          "new_line_content": "        execution_state->BuildGraph(subgraph_options, &client_graph));",
          "content_same": false
        },
        {
          "line": 1619,
          "old_api": "feed_size",
          "new_api": "size",
          "old_text": "subgraph_options.callable_options.feed_size()",
          "new_text": "client_graph->feed_types.size()",
          "old_line_content": "        subgraph_options.callable_options.feed_size(),",
          "new_line_content": "        client_graph->feed_types.size());",
          "content_same": false
        },
        {
          "line": 1621,
          "old_api": "size",
          "new_api": "fetch_size",
          "old_text": "client_graph->feed_types.size()",
          "new_text": "subgraph_options.callable_options.fetch_size()",
          "old_line_content": "        client_graph->feed_types.size());",
          "new_line_content": "  if (subgraph_options.callable_options.fetch_size() !=",
          "content_same": false
        },
        {
          "line": 1627,
          "old_api": "fetch_size",
          "new_api": "size",
          "old_text": "subgraph_options.callable_options.fetch_size()",
          "new_text": "client_graph->fetch_types.size()",
          "old_line_content": "        subgraph_options.callable_options.fetch_size(),",
          "new_line_content": "        client_graph->fetch_types.size());",
          "content_same": false
        },
        {
          "line": 1639,
          "old_api": "find",
          "new_api": "std::make_pair(node_name, placement)",
          "old_text": "stateful_placements_.find(node_name)",
          "new_text": "std::make_pair(node_name, placement)",
          "old_line_content": "    auto iter = stateful_placements_.find(node_name);",
          "new_line_content": "      stateful_placements_.insert(std::make_pair(node_name, placement));",
          "content_same": false
        },
        {
          "line": 1641,
          "old_api": "std::make_pair(node_name, placement)",
          "new_api": "errors::Internal(\n          \"Stateful placement mismatch. \"\n          \"Current assignment of \",\n          node_name, \" to \", iter->second, \" does not match \", placement)",
          "old_text": "std::make_pair(node_name, placement)",
          "new_text": "errors::Internal(\n          \"Stateful placement mismatch. \"\n          \"Current assignment of \",\n          node_name, \" to \", iter->second, \" does not match \", placement)",
          "old_line_content": "      stateful_placements_.insert(std::make_pair(node_name, placement));",
          "new_line_content": "      return errors::Internal(",
          "content_same": false
        },
        {
          "line": 1687,
          "old_api": "end",
          "new_api": "errors::InvalidArgument(\n          \"Creating a partition for \", local_partition_name,\n          \" which doesn't exist in the list of available devices. Available \"\n          \"devices: \",\n          absl::StrJoin(device_names, \",\"))",
          "old_text": "device_names.end()",
          "new_text": "errors::InvalidArgument(\n          \"Creating a partition for \", local_partition_name,\n          \" which doesn't exist in the list of available devices. Available \"\n          \"devices: \",\n          absl::StrJoin(device_names, \",\"))",
          "old_line_content": "    if (std::count(device_names.begin(), device_names.end(),",
          "new_line_content": "      return errors::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 1704,
          "old_api": "get",
          "new_api": "std::move(device_graph)",
          "old_text": "ConvertGraphDefToGraph(\n        device_opts, std::move(partition.second), device_graph.get())",
          "new_text": "std::move(device_graph)",
          "old_line_content": "    TF_RETURN_IF_ERROR(ConvertGraphDefToGraph(",
          "new_line_content": "    outputs->emplace(partition.first, std::move(device_graph));",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": "get",
          "new_api": "RunGrouping",
          "old_text": "client_graph->flib_def.get()",
          "new_text": "OptimizationPassRegistry::Global()->RunGrouping(\n      OptimizationPassRegistry::POST_PARTITIONING, optimization_options)",
          "old_line_content": "  optimization_options.flib_def = client_graph->flib_def.get();",
          "new_line_content": "  TF_RETURN_IF_ERROR(OptimizationPassRegistry::Global()->RunGrouping(",
          "content_same": false
        },
        {
          "line": 1726,
          "old_api": "LookupDevice",
          "new_api": "MaybeRewriteGraph",
          "old_text": "device_mgr_->LookupDevice(partition_name, &d)",
          "new_text": "d->MaybeRewriteGraph(graph)",
          "old_line_content": "    s = device_mgr_->LookupDevice(partition_name, &d);",
          "new_line_content": "    s = d->MaybeRewriteGraph(graph);",
          "content_same": false
        },
        {
          "line": 1733,
          "old_api": "std::move(client_graph->flib_def)",
          "new_api": "std::swap(*output_types, client_graph->fetch_types)",
          "old_text": "std::move(client_graph->flib_def)",
          "new_text": "std::swap(*output_types, client_graph->fetch_types)",
          "old_line_content": "  *flib_def = std::move(client_graph->flib_def);",
          "new_line_content": "  std::swap(*output_types, client_graph->fetch_types);",
          "content_same": false
        },
        {
          "line": 1742,
          "old_api": "size",
          "new_api": "attributes",
          "old_text": "devices_.size()",
          "new_text": "d->attributes()",
          "old_line_content": "  response->reserve(devices_.size());",
          "new_line_content": "    const DeviceAttributes& attrs = d->attributes();",
          "content_same": false
        },
        {
          "line": 1745,
          "old_api": "emplace_back",
          "new_api": "::tensorflow::Status::OK()",
          "old_text": "response->emplace_back(attrs)",
          "new_text": "::tensorflow::Status::OK()",
          "old_line_content": "    response->emplace_back(attrs);",
          "new_line_content": "  return ::tensorflow::Status::OK();",
          "content_same": false
        },
        {
          "line": 1817,
          "old_api": "Update",
          "new_api": "StartCancel",
          "old_text": "run_state->status.Update(status)",
          "new_text": "cm->StartCancel()",
          "old_line_content": "      run_state->status.Update(status);",
          "new_line_content": "    cm->StartCancel();",
          "content_same": false
        },
        {
          "line": 1832,
          "old_api": "WaitForNotificationWithTimeout",
          "new_api": "Status",
          "old_text": "WaitForNotificationWithTimeout(notification, timeout_in_us)",
          "new_text": "Status(error::DEADLINE_EXCEEDED,\n                    \"Timed out waiting for notification\")",
          "old_line_content": "        WaitForNotificationWithTimeout(notification, timeout_in_us);",
          "new_line_content": "      return Status(error::DEADLINE_EXCEEDED,",
          "content_same": false
        },
        {
          "line": 1838,
          "old_api": "WaitForNotification",
          "new_api": "Status::OK()",
          "old_text": "notification->WaitForNotification()",
          "new_text": "Status::OK()",
          "old_line_content": "    notification->WaitForNotification();",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 1850,
          "old_api": "run_options",
          "new_api": "CreateExecutors",
          "old_text": "callable_options.run_options().debug_options()",
          "new_text": "CreateExecutors(callable_options, &ek, &func_info, &run_state_args)",
          "old_line_content": "  RunStateArgs run_state_args(callable_options.run_options().debug_options());",
          "new_line_content": "      CreateExecutors(callable_options, &ek, &func_info, &run_state_args));",
          "content_same": false
        },
        {
          "line": 1856,
          "old_api": "std::move(func_info)",
          "new_api": "Status::OK()",
          "old_text": "std::move(func_info)",
          "new_text": "Status::OK()",
          "old_line_content": "    callables_[*out_handle] = {std::move(ek), std::move(func_info)};",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 1914,
          "old_api": "CheckNotClosed",
          "new_api": "GetCell",
          "old_text": "CheckNotClosed()",
          "new_text": "direct_session_runs->GetCell()->IncrementBy(1)",
          "old_line_content": "  TF_RETURN_IF_ERROR(CheckNotClosed());",
          "new_line_content": "  direct_session_runs->GetCell()->IncrementBy(1);",
          "content_same": false
        },
        {
          "line": 1948,
          "old_api": "size",
          "new_api": "errors::InvalidArgument(\n        \"`fetch_tensors` must be provided when the callable has one or more \"\n        \"outputs.\")",
          "old_text": "executors_and_keys->output_types.size()",
          "new_text": "errors::InvalidArgument(\n        \"`fetch_tensors` must be provided when the callable has one or more \"\n        \"outputs.\")",
          "old_line_content": "    fetch_tensors->resize(executors_and_keys->output_types.size());",
          "new_line_content": "    return errors::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 1959,
          "old_api": "dtype",
          "new_api": "metrics::RecordGraphInputTensors(input_size)",
          "old_text": "tensor.dtype()",
          "new_text": "metrics::RecordGraphInputTensors(input_size)",
          "old_line_content": "    any_resource_feeds = any_resource_feeds || tensor.dtype() == DT_RESOURCE;",
          "new_line_content": "  metrics::RecordGraphInputTensors(input_size);",
          "content_same": false
        },
        {
          "line": 1966,
          "old_api": "TF_PREDICT_FALSE",
          "new_api": "size",
          "old_text": "TF_PREDICT_FALSE(any_resource_feeds)",
          "new_text": "feed_tensors.size()",
          "old_line_content": "  if (TF_PREDICT_FALSE(any_resource_feeds)) {",
          "new_line_content": "    converted_feed_tensors->reserve(feed_tensors.size());",
          "content_same": false
        },
        {
          "line": 1968,
          "old_api": "size",
          "new_api": "dtype",
          "old_text": "feed_tensors.size()",
          "new_text": "t.dtype()",
          "old_line_content": "    converted_feed_tensors->reserve(feed_tensors.size());",
          "new_line_content": "      if (t.dtype() == DT_RESOURCE) {",
          "content_same": false
        },
        {
          "line": 1970,
          "old_api": "dtype",
          "new_api": "back",
          "old_text": "t.dtype()",
          "new_text": "converted_feed_tensors->back()",
          "old_line_content": "      if (t.dtype() == DT_RESOURCE) {",
          "new_line_content": "        Tensor* tensor_from_handle = &converted_feed_tensors->back();",
          "content_same": false
        },
        {
          "line": 1971,
          "old_api": "emplace_back",
          "new_api": "ResourceHandleToInputTensor",
          "old_text": "converted_feed_tensors->emplace_back()",
          "new_text": "ResourceHandleToInputTensor(t, tensor_from_handle)",
          "old_line_content": "        converted_feed_tensors->emplace_back();",
          "new_line_content": "        TF_RETURN_IF_ERROR(ResourceHandleToInputTensor(t, tensor_from_handle));",
          "content_same": false
        },
        {
          "line": 1973,
          "old_api": "ResourceHandleToInputTensor",
          "new_api": "emplace_back",
          "old_text": "ResourceHandleToInputTensor(t, tensor_from_handle)",
          "new_text": "converted_feed_tensors->emplace_back(t)",
          "old_line_content": "        TF_RETURN_IF_ERROR(ResourceHandleToInputTensor(t, tensor_from_handle));",
          "new_line_content": "        converted_feed_tensors->emplace_back(t);",
          "content_same": false
        },
        {
          "line": 1992,
          "old_api": "run_options",
          "new_api": "get",
          "old_text": "RunInternal(\n      step_id, executors_and_keys->callable_options.run_options(), &call_frame,\n      executors_and_keys.get(), run_metadata, threadpool_options)",
          "new_text": "executors_and_keys.get()",
          "old_line_content": "  TF_RETURN_IF_ERROR(RunInternal(",
          "new_line_content": "      executors_and_keys.get(), run_metadata, threadpool_options));",
          "content_same": false
        },
        {
          "line": 1999,
          "old_api": "AllocatedBytes",
          "new_api": "metrics::RecordGraphOutputTensors(output_size)",
          "old_text": "tensor.AllocatedBytes()",
          "new_text": "metrics::RecordGraphOutputTensors(output_size)",
          "old_line_content": "      output_size += tensor.AllocatedBytes();",
          "new_line_content": "    metrics::RecordGraphOutputTensors(output_size);",
          "content_same": false
        },
        {
          "line": 2010,
          "old_api": "errors::InvalidArgument(\"No such callable handle: \", handle)",
          "new_api": "erase",
          "old_text": "errors::InvalidArgument(\"No such callable handle: \", handle)",
          "new_text": "callables_.erase(handle)",
          "old_line_content": "    return errors::InvalidArgument(\"No such callable handle: \", handle);",
          "new_line_content": "  callables_.erase(handle);",
          "content_same": false
        },
        {
          "line": 2022,
          "old_api": "errors::FailedPrecondition(\"Session not yet created.\")",
          "new_api": "reset",
          "old_text": "errors::FailedPrecondition(\"Session not yet created.\")",
          "new_text": "execution_state_.reset()",
          "old_line_content": "    return errors::FailedPrecondition(\"Session not yet created.\");",
          "new_line_content": "  execution_state_.reset();",
          "content_same": false
        },
        {
          "line": 2025,
          "old_api": "reset",
          "new_api": "Status::OK()",
          "old_text": "flib_def_.reset()",
          "new_text": "Status::OK()",
          "old_line_content": "  flib_def_.reset();",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1537,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "inputs_sorted.size()",
          "old_line_content": "  // being created.",
          "new_line_content": "  callable_options.mutable_feed()->Reserve(inputs_sorted.size());",
          "content_same": false
        },
        {
          "line": 1556,
          "old_api": null,
          "new_api": "TF_RETURN_IF_ERROR",
          "old_text": null,
          "new_text": "TF_RETURN_IF_ERROR(\n      CreateExecutors(callable_options, &ek, &func_info, run_state_args))",
          "old_line_content": "  std::unique_ptr<ExecutorsAndKeys> ek;",
          "new_line_content": "  TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 1557,
          "old_api": null,
          "new_api": "CreateExecutors",
          "old_text": null,
          "new_text": "CreateExecutors(callable_options, &ek, &func_info, run_state_args)",
          "old_line_content": "  std::unique_ptr<FunctionInfo> func_info;",
          "new_line_content": "      CreateExecutors(callable_options, &ek, &func_info, run_state_args));",
          "content_same": false
        },
        {
          "line": 1564,
          "old_api": null,
          "new_api": "emplace",
          "old_text": null,
          "new_text": "executors_.emplace(\n      sorted_key, std::shared_ptr<ExecutorsAndKeys>(std::move(ek)))",
          "old_line_content": "  // Another thread may have created the entry before us, in which case we will",
          "new_line_content": "  auto insert_result = executors_.emplace(",
          "content_same": false
        },
        {
          "line": 1565,
          "old_api": null,
          "new_api": "std::move(ek)",
          "old_text": null,
          "new_text": "std::move(ek)",
          "old_line_content": "  // reuse the already created one.",
          "new_line_content": "      sorted_key, std::shared_ptr<ExecutorsAndKeys>(std::move(ek)));",
          "content_same": false
        },
        {
          "line": 1572,
          "old_api": null,
          "new_api": "emplace",
          "old_text": null,
          "new_text": "executors_.emplace(key, insert_result.first->second)",
          "old_line_content": "  // Insert the value under the original key, so the fast path lookup will work",
          "new_line_content": "  executors_.emplace(key, insert_result.first->second);",
          "content_same": false
        },
        {
          "line": 1573,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "insert_result.first->second.get()",
          "old_line_content": "  // if the user uses the same order of inputs, outputs, and targets again.",
          "new_line_content": "  *executors_and_keys = insert_result.first->second.get();",
          "content_same": false
        },
        {
          "line": 1586,
          "old_api": null,
          "new_api": "errors::FailedPrecondition(\"Session has been finalized.\")",
          "old_text": null,
          "new_text": "errors::FailedPrecondition(\"Session has been finalized.\")",
          "old_line_content": "  mutex_lock l(graph_state_lock_);",
          "new_line_content": "    return errors::FailedPrecondition(\"Session has been finalized.\");",
          "content_same": false
        },
        {
          "line": 1593,
          "old_api": null,
          "new_api": "graph_options",
          "old_text": null,
          "new_text": "options_.config.graph_options().place_pruned_graph()",
          "old_line_content": "  std::unique_ptr<GraphExecutionState> temp_exec_state_holder;",
          "new_line_content": "  if (options_.config.graph_options().place_pruned_graph()) {",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": null,
          "new_api": "GraphExecutionState::MakeForPrunedGraph(\n        *execution_state_, prune_options, subgraph_options,\n        &temp_exec_state_holder, &client_graph)",
          "old_text": null,
          "new_text": "GraphExecutionState::MakeForPrunedGraph(\n        *execution_state_, prune_options, subgraph_options,\n        &temp_exec_state_holder, &client_graph)",
          "old_line_content": "    prune_options.stateful_placements = stateful_placements_;",
          "new_line_content": "    TF_RETURN_IF_ERROR(GraphExecutionState::MakeForPrunedGraph(",
          "content_same": false
        },
        {
          "line": 1605,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "temp_exec_state_holder.get()",
          "old_line_content": "        *execution_state_, prune_options, subgraph_options,",
          "new_line_content": "    execution_state = temp_exec_state_holder.get();",
          "content_same": false
        },
        {
          "line": 1608,
          "old_api": null,
          "new_api": "BuildGraph",
          "old_text": null,
          "new_text": "TF_RETURN_IF_ERROR(\n        execution_state->BuildGraph(subgraph_options, &client_graph))",
          "old_line_content": "  } else {",
          "new_line_content": "    TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": null,
          "new_api": "feed_size",
          "old_text": null,
          "new_text": "subgraph_options.callable_options.feed_size()",
          "old_line_content": "  *collective_graph_key = client_graph->collective_graph_key;",
          "new_line_content": "  if (subgraph_options.callable_options.feed_size() !=",
          "content_same": false
        },
        {
          "line": 1614,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "client_graph->feed_types.size()",
          "old_line_content": "",
          "new_line_content": "      client_graph->feed_types.size()) {",
          "content_same": false
        },
        {
          "line": 1622,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "client_graph->fetch_types.size()",
          "old_line_content": "  }",
          "new_line_content": "      client_graph->fetch_types.size()) {",
          "content_same": false
        },
        {
          "line": 1630,
          "old_api": null,
          "new_api": "GetStatefulPlacements",
          "old_text": null,
          "new_text": "execution_state->GetStatefulPlacements()",
          "old_line_content": "  }",
          "new_line_content": "  auto current_stateful_placements = execution_state->GetStatefulPlacements();",
          "content_same": false
        },
        {
          "line": 1637,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "stateful_placements_.find(node_name)",
          "old_line_content": "    const string& node_name = placement_pair.first;",
          "new_line_content": "    auto iter = stateful_placements_.find(node_name);",
          "content_same": false
        },
        {
          "line": 1638,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "stateful_placements_.end()",
          "old_line_content": "    const string& placement = placement_pair.second;",
          "new_line_content": "    if (iter == stateful_placements_.end()) {",
          "content_same": false
        },
        {
          "line": 1648,
          "old_api": null,
          "new_api": "GetStatefulPlacements",
          "old_text": null,
          "new_text": "execution_state->GetStatefulPlacements()",
          "old_line_content": "  }",
          "new_line_content": "  stateful_placements_ = execution_state->GetStatefulPlacements();",
          "content_same": false
        },
        {
          "line": 1652,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "flib_def_.get()",
          "old_line_content": "  // Remember the graph in run state if this is a partial run.",
          "new_line_content": "    run_state_args->graph.reset(new Graph(flib_def_.get()));",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "run_state_args->graph.get()",
          "old_line_content": "  if (run_state_args->is_partial_run) {",
          "new_line_content": "    CopyGraph(*execution_state->full_graph(), run_state_args->graph.get());",
          "content_same": false
        },
        {
          "line": 1659,
          "old_api": null,
          "new_api": "assigned_device_name",
          "old_text": null,
          "new_text": "node->assigned_device_name()",
          "old_line_content": "  PartitionOptions popts;",
          "new_line_content": "    return node->assigned_device_name();",
          "content_same": false
        },
        {
          "line": 1662,
          "old_api": null,
          "new_api": "fetch_add",
          "old_text": null,
          "new_text": "edge_name_counter_.fetch_add(1)",
          "old_line_content": "  };",
          "new_line_content": "    return strings::StrCat(prefix, \"/_\", edge_name_counter_.fetch_add(1));",
          "content_same": false
        },
        {
          "line": 1669,
          "old_api": null,
          "new_api": "flib_def",
          "old_text": null,
          "new_text": "client_graph->graph.flib_def()",
          "old_line_content": "    return 1;",
          "new_line_content": "  popts.flib_def = &client_graph->graph.flib_def();",
          "content_same": false
        },
        {
          "line": 1673,
          "old_api": null,
          "new_api": "Partition",
          "old_text": null,
          "new_text": "Partition(popts, &client_graph->graph, &partitions)",
          "old_line_content": "",
          "new_line_content": "  TF_RETURN_IF_ERROR(Partition(popts, &client_graph->graph, &partitions));",
          "content_same": false
        },
        {
          "line": 1678,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "device->name()",
          "old_line_content": "  for (auto device : devices_) {",
          "new_line_content": "    device_names.push_back(DeviceNameUtils::LocalName(device->name()));",
          "content_same": false
        },
        {
          "line": 1684,
          "old_api": null,
          "new_api": "DeviceNameUtils::LocalName(partition.first)",
          "old_text": null,
          "new_text": "DeviceNameUtils::LocalName(partition.first)",
          "old_line_content": "  for (const auto& partition : partitions) {",
          "new_line_content": "        DeviceNameUtils::LocalName(partition.first);",
          "content_same": false
        },
        {
          "line": 1685,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "device_names.end()",
          "old_line_content": "    const string local_partition_name =",
          "new_line_content": "    if (std::count(device_names.begin(), device_names.end(),",
          "content_same": false
        },
        {
          "line": 1691,
          "old_api": null,
          "new_api": "absl::StrJoin(device_names, \",\")",
          "old_text": null,
          "new_text": "absl::StrJoin(device_names, \",\")",
          "old_line_content": "          \" which doesn't exist in the list of available devices. Available \"",
          "new_line_content": "          absl::StrJoin(device_names, \",\"));",
          "content_same": false
        },
        {
          "line": 1697,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "client_graph->flib_def.get()",
          "old_line_content": "  for (auto& partition : partitions) {",
          "new_line_content": "        new Graph(client_graph->flib_def.get()));",
          "content_same": false
        },
        {
          "line": 1702,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "ConvertGraphDefToGraph(\n        device_opts, std::move(partition.second), device_graph.get())",
          "old_line_content": "    device_opts.allow_internal_ops = true;",
          "new_line_content": "    TF_RETURN_IF_ERROR(ConvertGraphDefToGraph(",
          "content_same": false
        },
        {
          "line": 1703,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "device_graph.get()",
          "old_line_content": "    device_opts.expect_device_spec = true;",
          "new_line_content": "        device_opts, std::move(partition.second), device_graph.get()));",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "client_graph->flib_def.get()",
          "old_line_content": "  GraphOptimizationPassOptions optimization_options;",
          "new_line_content": "  optimization_options.flib_def = client_graph->flib_def.get();",
          "content_same": false
        },
        {
          "line": 1719,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "graph->get()",
          "old_line_content": "    std::unique_ptr<Graph>* graph = &partition.second;",
          "new_line_content": "    VLOG(2) << \"Created \" << DebugString(graph->get()) << \" for \"",
          "content_same": false
        },
        {
          "line": 1724,
          "old_api": null,
          "new_api": "LookupDevice",
          "old_text": null,
          "new_text": "device_mgr_->LookupDevice(partition_name, &d)",
          "old_line_content": "    // Give the device an opportunity to rewrite its subgraph.",
          "new_line_content": "    s = device_mgr_->LookupDevice(partition_name, &d);",
          "content_same": false
        },
        {
          "line": 1725,
          "old_api": null,
          "new_api": "ok",
          "old_text": null,
          "new_text": "s.ok()",
          "old_line_content": "    Device* d;",
          "new_line_content": "    if (!s.ok()) break;",
          "content_same": false
        },
        {
          "line": 1731,
          "old_api": null,
          "new_api": "std::move(client_graph->flib_def)",
          "old_text": null,
          "new_text": "std::move(client_graph->flib_def)",
          "old_line_content": "    }",
          "new_line_content": "  *flib_def = std::move(client_graph->flib_def);",
          "content_same": false
        },
        {
          "line": 1732,
          "old_api": null,
          "new_api": "std::swap(*input_types, client_graph->feed_types)",
          "old_text": null,
          "new_text": "std::swap(*input_types, client_graph->feed_types)",
          "old_line_content": "  }",
          "new_line_content": "  std::swap(*input_types, client_graph->feed_types);",
          "content_same": false
        },
        {
          "line": 1739,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "response->clear()",
          "old_line_content": "::tensorflow::Status DirectSession::ListDevices(",
          "new_line_content": "  response->clear();",
          "content_same": false
        },
        {
          "line": 1740,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "devices_.size()",
          "old_line_content": "    std::vector<DeviceAttributes>* response) {",
          "new_line_content": "  response->reserve(devices_.size());",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "response->emplace_back(attrs)",
          "old_line_content": "  for (Device* d : devices_) {",
          "new_line_content": "    response->emplace_back(attrs);",
          "content_same": false
        },
        {
          "line": 1750,
          "old_api": null,
          "new_api": "ClearContainers",
          "old_text": null,
          "new_text": "device_mgr_->ClearContainers(containers)",
          "old_line_content": "::tensorflow::Status DirectSession::Reset(",
          "new_line_content": "  device_mgr_->ClearContainers(containers);",
          "content_same": false
        },
        {
          "line": 1751,
          "old_api": null,
          "new_api": "::tensorflow::Status::OK()",
          "old_text": null,
          "new_text": "::tensorflow::Status::OK()",
          "old_line_content": "    const std::vector<string>& containers) {",
          "new_line_content": "  return ::tensorflow::Status::OK();",
          "content_same": false
        },
        {
          "line": 1755,
          "old_api": null,
          "new_api": "StartCancel",
          "old_text": null,
          "new_text": "cancellation_manager_->StartCancel()",
          "old_line_content": "",
          "new_line_content": "  cancellation_manager_->StartCancel();",
          "content_same": false
        },
        {
          "line": 1758,
          "old_api": null,
          "new_api": "::tensorflow::Status::OK()",
          "old_text": null,
          "new_text": "::tensorflow::Status::OK()",
          "old_line_content": "  {",
          "new_line_content": "    if (closed_) return ::tensorflow::Status::OK();",
          "content_same": false
        },
        {
          "line": 1761,
          "old_api": null,
          "new_api": "Deregister",
          "old_text": null,
          "new_text": "factory_->Deregister(this)",
          "old_line_content": "    closed_ = true;",
          "new_line_content": "  if (factory_ != nullptr) factory_->Deregister(this);",
          "content_same": false
        },
        {
          "line": 1762,
          "old_api": null,
          "new_api": "::tensorflow::Status::OK()",
          "old_text": null,
          "new_text": "::tensorflow::Status::OK()",
          "old_line_content": "  }",
          "new_line_content": "  return ::tensorflow::Status::OK();",
          "content_same": false
        },
        {
          "line": 1769,
          "old_api": null,
          "new_api": "ok",
          "old_text": null,
          "new_text": "d->resource_manager()->Cleanup(name).ok()",
          "old_line_content": "    : step_container(step_id, [devices, step_id](const string& name) {",
          "new_line_content": "          if (!d->resource_manager()->Cleanup(name).ok()) {",
          "content_same": false
        },
        {
          "line": 1772,
          "old_api": null,
          "new_api": "GetScopedAllocatorMgr",
          "old_text": null,
          "new_text": "d->GetScopedAllocatorMgr()",
          "old_line_content": "            // Do nothing...",
          "new_line_content": "          ScopedAllocatorMgr* sam = d->GetScopedAllocatorMgr();",
          "content_same": false
        },
        {
          "line": 1773,
          "old_api": null,
          "new_api": "Cleanup",
          "old_text": null,
          "new_text": "sam->Cleanup(step_id)",
          "old_line_content": "          }",
          "new_line_content": "          if (sam) sam->Cleanup(step_id);",
          "content_same": false
        },
        {
          "line": 1793,
          "old_api": null,
          "new_api": "errors::Cancelled(\"PRun cancellation\")",
          "old_text": null,
          "new_text": "errors::Cancelled(\"PRun cancellation\")",
          "old_line_content": "DirectSession::PartialRunState::~PartialRunState() {",
          "new_line_content": "    rendez->StartAbort(errors::Cancelled(\"PRun cancellation\"));",
          "content_same": false
        },
        {
          "line": 1794,
          "old_api": null,
          "new_api": "WaitForNotification",
          "old_text": null,
          "new_text": "executors_done.WaitForNotification()",
          "old_line_content": "  if (rendez != nullptr) {",
          "new_line_content": "    executors_done.WaitForNotification();",
          "content_same": false
        },
        {
          "line": 1811,
          "old_api": null,
          "new_api": "WaitForNotification",
          "old_text": null,
          "new_text": "WaitForNotification(n, timeout_in_ms)",
          "old_line_content": "                                        CancellationManager* cm,",
          "new_line_content": "  const Status status = WaitForNotification(n, timeout_in_ms);",
          "content_same": false
        },
        {
          "line": 1812,
          "old_api": null,
          "new_api": "ok",
          "old_text": null,
          "new_text": "status.ok()",
          "old_line_content": "                                        int64 timeout_in_ms) {",
          "new_line_content": "  if (!status.ok()) {",
          "content_same": false
        },
        {
          "line": 1815,
          "old_api": null,
          "new_api": "Update",
          "old_text": null,
          "new_text": "run_state->status.Update(status)",
          "old_line_content": "    {",
          "new_line_content": "      run_state->status.Update(status);",
          "content_same": false
        },
        {
          "line": 1821,
          "old_api": null,
          "new_api": "WaitForNotification",
          "old_text": null,
          "new_text": "n->WaitForNotification()",
          "old_line_content": "    // references to `cm` and other per-step state. After this notification, it",
          "new_line_content": "    n->WaitForNotification();",
          "content_same": false
        },
        {
          "line": 1830,
          "old_api": null,
          "new_api": "WaitForNotificationWithTimeout",
          "old_text": null,
          "new_text": "WaitForNotificationWithTimeout(notification, timeout_in_us)",
          "old_line_content": "    const int64 timeout_in_us = timeout_in_ms * 1000;",
          "new_line_content": "        WaitForNotificationWithTimeout(notification, timeout_in_us);",
          "content_same": false
        },
        {
          "line": 1836,
          "old_api": null,
          "new_api": "WaitForNotification",
          "old_text": null,
          "new_text": "notification->WaitForNotification()",
          "old_line_content": "    }",
          "new_line_content": "    notification->WaitForNotification();",
          "content_same": false
        },
        {
          "line": 1843,
          "old_api": null,
          "new_api": "CheckNotClosed",
          "old_text": null,
          "new_text": "CheckNotClosed()",
          "old_line_content": "Status DirectSession::MakeCallable(const CallableOptions& callable_options,",
          "new_line_content": "  TF_RETURN_IF_ERROR(CheckNotClosed());",
          "content_same": false
        },
        {
          "line": 1844,
          "old_api": null,
          "new_api": "CheckGraphCreated",
          "old_text": null,
          "new_text": "CheckGraphCreated(\"MakeCallable()\")",
          "old_line_content": "                                   CallableHandle* out_handle) {",
          "new_line_content": "  TF_RETURN_IF_ERROR(CheckGraphCreated(\"MakeCallable()\"));",
          "content_same": false
        },
        {
          "line": 1848,
          "old_api": null,
          "new_api": "run_options",
          "old_text": null,
          "new_text": "callable_options.run_options().debug_options()",
          "old_line_content": "  std::unique_ptr<ExecutorsAndKeys> ek;",
          "new_line_content": "  RunStateArgs run_state_args(callable_options.run_options().debug_options());",
          "content_same": false
        },
        {
          "line": 1849,
          "old_api": null,
          "new_api": "TF_RETURN_IF_ERROR",
          "old_text": null,
          "new_text": "TF_RETURN_IF_ERROR(\n      CreateExecutors(callable_options, &ek, &func_info, &run_state_args))",
          "old_line_content": "  std::unique_ptr<FunctionInfo> func_info;",
          "new_line_content": "  TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 1854,
          "old_api": null,
          "new_api": "std::move(func_info)",
          "old_text": null,
          "new_text": "std::move(func_info)",
          "old_line_content": "    mutex_lock l(callables_lock_);",
          "new_line_content": "    callables_[*out_handle] = {std::move(ek), std::move(func_info)};",
          "content_same": false
        },
        {
          "line": 1871,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "executors_and_keys_->input_types.size()",
          "old_line_content": "",
          "new_line_content": "    return executors_and_keys_->input_types.size();",
          "content_same": false
        },
        {
          "line": 1874,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "executors_and_keys_->output_types.size()",
          "old_line_content": "  }",
          "new_line_content": "    return executors_and_keys_->output_types.size();",
          "content_same": false
        },
        {
          "line": 1878,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "feed_tensors_->size()",
          "old_line_content": "",
          "new_line_content": "    if (TF_PREDICT_FALSE(index > feed_tensors_->size())) {",
          "content_same": false
        },
        {
          "line": 1879,
          "old_api": null,
          "new_api": "errors::Internal(\"Args index out of bounds: \", index)",
          "old_text": null,
          "new_text": "errors::Internal(\"Args index out of bounds: \", index)",
          "old_line_content": "  Status GetArg(int index, const Tensor** val) override {",
          "new_line_content": "      return errors::Internal(\"Args index out of bounds: \", index);",
          "content_same": false
        },
        {
          "line": 1883,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "      *val = &(*feed_tensors_)[index];",
          "new_line_content": "    return Status::OK();",
          "content_same": false
        },
        {
          "line": 1887,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "fetch_tensors_->size()",
          "old_line_content": "",
          "new_line_content": "    if (index > fetch_tensors_->size()) {",
          "content_same": false
        },
        {
          "line": 1888,
          "old_api": null,
          "new_api": "errors::Internal(\"RetVal index out of bounds: \", index)",
          "old_text": null,
          "new_text": "errors::Internal(\"RetVal index out of bounds: \", index)",
          "old_line_content": "  Status SetRetval(int index, const Tensor& val) override {",
          "new_line_content": "      return errors::Internal(\"RetVal index out of bounds: \", index);",
          "content_same": false
        },
        {
          "line": 1891,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "    }",
          "new_line_content": "    return Status::OK();",
          "content_same": false
        },
        {
          "line": 1904,
          "old_api": null,
          "new_api": "RunCallable",
          "old_text": null,
          "new_text": "RunCallable(handle, feed_tensors, fetch_tensors, run_metadata,\n                     thread::ThreadPoolOptions())",
          "old_line_content": "    CallableHandle handle, const std::vector<Tensor>& feed_tensors,",
          "new_line_content": "  return RunCallable(handle, feed_tensors, fetch_tensors, run_metadata,",
          "content_same": false
        },
        {
          "line": 1905,
          "old_api": null,
          "new_api": "thread::ThreadPoolOptions()",
          "old_text": null,
          "new_text": "thread::ThreadPoolOptions()",
          "old_line_content": "    std::vector<Tensor>* fetch_tensors, RunMetadata* run_metadata) {",
          "new_line_content": "                     thread::ThreadPoolOptions());",
          "content_same": false
        },
        {
          "line": 1912,
          "old_api": null,
          "new_api": "CheckNotClosed",
          "old_text": null,
          "new_text": "CheckNotClosed()",
          "old_line_content": "    std::vector<Tensor>* fetch_tensors, RunMetadata* run_metadata,",
          "new_line_content": "  TF_RETURN_IF_ERROR(CheckNotClosed());",
          "content_same": false
        },
        {
          "line": 1913,
          "old_api": null,
          "new_api": "CheckGraphCreated",
          "old_text": null,
          "new_text": "CheckGraphCreated(\"RunCallable()\")",
          "old_line_content": "    const thread::ThreadPoolOptions& threadpool_options) {",
          "new_line_content": "  TF_RETURN_IF_ERROR(CheckGraphCreated(\"RunCallable()\"));",
          "content_same": false
        },
        {
          "line": 1918,
          "old_api": null,
          "new_api": "fetch_add",
          "old_text": null,
          "new_text": "step_id_counter_.fetch_add(1)",
          "old_line_content": "  // Check if we already have an executor for these arguments.",
          "new_line_content": "  const int64 step_id = step_id_counter_.fetch_add(1);",
          "content_same": false
        },
        {
          "line": 1923,
          "old_api": null,
          "new_api": "errors::InvalidArgument(\"No such callable handle: \", handle)",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\"No such callable handle: \", handle)",
          "old_line_content": "    tf_shared_lock l(callables_lock_);",
          "new_line_content": "      return errors::InvalidArgument(\"No such callable handle: \", handle);",
          "content_same": false
        },
        {
          "line": 1929,
          "old_api": null,
          "new_api": "errors::InvalidArgument(\n        \"Attempted to run callable after handle was released: \", handle)",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\n        \"Attempted to run callable after handle was released: \", handle)",
          "old_line_content": "",
          "new_line_content": "    return errors::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 1940,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "executors_and_keys->input_types.size()",
          "old_line_content": "  // Configure a call frame for the step, which we use to feed and",
          "new_line_content": "  if (feed_tensors.size() != executors_and_keys->input_types.size()) {",
          "content_same": false
        },
        {
          "line": 1941,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\n        \"Expected \", executors_and_keys->input_types.size(),\n        \" feed tensors, but got \", feed_tensors.size())",
          "old_line_content": "  // fetch values to and from the executors.",
          "new_line_content": "    return errors::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 1946,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "executors_and_keys->output_types.size()",
          "old_line_content": "  }",
          "new_line_content": "    fetch_tensors->resize(executors_and_keys->output_types.size());",
          "content_same": false
        },
        {
          "line": 1947,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "executors_and_keys->output_types.empty()",
          "old_line_content": "  if (fetch_tensors != nullptr) {",
          "new_line_content": "  } else if (!executors_and_keys->output_types.empty()) {",
          "content_same": false
        },
        {
          "line": 1956,
          "old_api": null,
          "new_api": "AllocatedBytes",
          "old_text": null,
          "new_text": "tensor.AllocatedBytes()",
          "old_line_content": "  bool any_resource_feeds = false;",
          "new_line_content": "    input_size += tensor.AllocatedBytes();",
          "content_same": false
        },
        {
          "line": 1957,
          "old_api": null,
          "new_api": "dtype",
          "old_text": null,
          "new_text": "tensor.dtype()",
          "old_line_content": "  for (auto& tensor : feed_tensors) {",
          "new_line_content": "    any_resource_feeds = any_resource_feeds || tensor.dtype() == DT_RESOURCE;",
          "content_same": false
        },
        {
          "line": 1964,
          "old_api": null,
          "new_api": "TF_PREDICT_FALSE",
          "old_text": null,
          "new_text": "TF_PREDICT_FALSE(any_resource_feeds)",
          "old_line_content": "  const std::vector<Tensor>* actual_feed_tensors;",
          "new_line_content": "  if (TF_PREDICT_FALSE(any_resource_feeds)) {",
          "content_same": false
        },
        {
          "line": 1965,
          "old_api": null,
          "new_api": "absl::make_unique<std::vector<Tensor>>()",
          "old_text": null,
          "new_text": "absl::make_unique<std::vector<Tensor>>()",
          "old_line_content": "",
          "new_line_content": "    converted_feed_tensors = absl::make_unique<std::vector<Tensor>>();",
          "content_same": false
        },
        {
          "line": 1969,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "converted_feed_tensors->emplace_back()",
          "old_line_content": "    for (const Tensor& t : feed_tensors) {",
          "new_line_content": "        converted_feed_tensors->emplace_back();",
          "content_same": false
        },
        {
          "line": 1976,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "converted_feed_tensors.get()",
          "old_line_content": "      }",
          "new_line_content": "    actual_feed_tensors = converted_feed_tensors.get();",
          "content_same": false
        },
        {
          "line": 1983,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "executors_and_keys.get()",
          "old_line_content": "  // A specialized CallFrame implementation that takes advantage of the",
          "new_line_content": "  RunCallableCallFrame call_frame(this, executors_and_keys.get(),",
          "content_same": false
        },
        {
          "line": 1986,
          "old_api": null,
          "new_api": "LogMemory::IsEnabled()",
          "old_text": null,
          "new_text": "LogMemory::IsEnabled()",
          "old_line_content": "                                  actual_feed_tensors, fetch_tensors);",
          "new_line_content": "  if (LogMemory::IsEnabled()) {",
          "content_same": false
        },
        {
          "line": 1987,
          "old_api": null,
          "new_api": "LogMemory::RecordStep(step_id, run_state_args.handle)",
          "old_text": null,
          "new_text": "LogMemory::RecordStep(step_id, run_state_args.handle)",
          "old_line_content": "",
          "new_line_content": "    LogMemory::RecordStep(step_id, run_state_args.handle);",
          "content_same": false
        },
        {
          "line": 1990,
          "old_api": null,
          "new_api": "run_options",
          "old_text": null,
          "new_text": "RunInternal(\n      step_id, executors_and_keys->callable_options.run_options(), &call_frame,\n      executors_and_keys.get(), run_metadata, threadpool_options)",
          "old_line_content": "  }",
          "new_line_content": "  TF_RETURN_IF_ERROR(RunInternal(",
          "content_same": false
        },
        {
          "line": 1991,
          "old_api": null,
          "new_api": "run_options",
          "old_text": null,
          "new_text": "executors_and_keys->callable_options.run_options()",
          "old_line_content": "",
          "new_line_content": "      step_id, executors_and_keys->callable_options.run_options(), &call_frame,",
          "content_same": false
        },
        {
          "line": 1997,
          "old_api": null,
          "new_api": "AllocatedBytes",
          "old_text": null,
          "new_text": "tensor.AllocatedBytes()",
          "old_line_content": "    size_t output_size = 0;",
          "new_line_content": "      output_size += tensor.AllocatedBytes();",
          "content_same": false
        },
        {
          "line": 2002,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "  }",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2008,
          "old_api": null,
          "new_api": "errors::InvalidArgument(\"No such callable handle: \", handle)",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\"No such callable handle: \", handle)",
          "old_line_content": "  mutex_lock l(callables_lock_);",
          "new_line_content": "    return errors::InvalidArgument(\"No such callable handle: \", handle);",
          "content_same": false
        },
        {
          "line": 2011,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "  }",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2017,
          "old_api": null,
          "new_api": "errors::FailedPrecondition(\"Session already finalized.\")",
          "old_text": null,
          "new_text": "errors::FailedPrecondition(\"Session already finalized.\")",
          "old_line_content": "  mutex_lock l(graph_state_lock_);",
          "new_line_content": "    return errors::FailedPrecondition(\"Session already finalized.\");",
          "content_same": false
        },
        {
          "line": 2020,
          "old_api": null,
          "new_api": "errors::FailedPrecondition(\"Session not yet created.\")",
          "old_text": null,
          "new_text": "errors::FailedPrecondition(\"Session not yet created.\")",
          "old_line_content": "  }",
          "new_line_content": "    return errors::FailedPrecondition(\"Session not yet created.\");",
          "content_same": false
        },
        {
          "line": 2023,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "flib_def_.reset()",
          "old_line_content": "  }",
          "new_line_content": "  flib_def_.reset();",
          "content_same": false
        },
        {
          "line": 2034,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "executors_and_keys.reset()",
          "old_line_content": "  // on the `FunctionLibraryRuntime` to know if the kernel is stateful",
          "new_line_content": "  executors_and_keys.reset();",
          "content_same": false
        },
        {
          "line": 2035,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "function_info.reset()",
          "old_line_content": "  // or not).",
          "new_line_content": "  function_info.reset();",
          "content_same": false
        },
        {
          "line": 1529,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "      // Insert this under the original key.",
          "new_line_content": "      return Status::OK();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1553,
          "old_api": "mutable_run_options",
          "new_api": null,
          "old_text": "callable_options.mutable_run_options()\n      ->mutable_experimental()\n      ->set_collective_graph_key(run_state_args->collective_graph_key)",
          "new_text": null,
          "old_line_content": "  callable_options.mutable_run_options()",
          "new_line_content": "      ->set_collective_graph_key(run_state_args->collective_graph_key);",
          "content_same": false
        },
        {
          "line": 1558,
          "old_api": "TF_RETURN_IF_ERROR",
          "new_api": null,
          "old_text": "TF_RETURN_IF_ERROR(\n      CreateExecutors(callable_options, &ek, &func_info, run_state_args))",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1559,
          "old_api": "CreateExecutors",
          "new_api": null,
          "old_text": "CreateExecutors(callable_options, &ek, &func_info, run_state_args)",
          "new_text": null,
          "old_line_content": "      CreateExecutors(callable_options, &ek, &func_info, run_state_args));",
          "new_line_content": "  // Reacquire the lock, try to insert into the map.",
          "content_same": false
        },
        {
          "line": 1566,
          "old_api": "emplace",
          "new_api": null,
          "old_text": "executors_.emplace(\n      sorted_key, std::shared_ptr<ExecutorsAndKeys>(std::move(ek)))",
          "new_text": null,
          "old_line_content": "  auto insert_result = executors_.emplace(",
          "new_line_content": "  if (insert_result.second) {",
          "content_same": false
        },
        {
          "line": 1569,
          "old_api": "std::move(func_info)",
          "new_api": null,
          "old_text": "std::move(func_info)",
          "new_text": null,
          "old_line_content": "    functions_.push_back(std::move(func_info));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1574,
          "old_api": "emplace",
          "new_api": null,
          "old_text": "executors_.emplace(key, insert_result.first->second)",
          "new_text": null,
          "old_line_content": "  executors_.emplace(key, insert_result.first->second);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1577,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1588,
          "old_api": "errors::FailedPrecondition(\"Session has been finalized.\")",
          "new_api": null,
          "old_text": "errors::FailedPrecondition(\"Session has been finalized.\")",
          "new_text": null,
          "old_line_content": "    return errors::FailedPrecondition(\"Session has been finalized.\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1595,
          "old_api": "graph_options",
          "new_api": null,
          "old_text": "options_.config.graph_options().place_pruned_graph()",
          "new_text": null,
          "old_line_content": "  if (options_.config.graph_options().place_pruned_graph()) {",
          "new_line_content": "    // new GraphExecutionState for every new unseen graph,",
          "content_same": false
        },
        {
          "line": 1604,
          "old_api": "GraphExecutionState::MakeForPrunedGraph(\n        *execution_state_, prune_options, subgraph_options,\n        &temp_exec_state_holder, &client_graph)",
          "new_api": null,
          "old_text": "GraphExecutionState::MakeForPrunedGraph(\n        *execution_state_, prune_options, subgraph_options,\n        &temp_exec_state_holder, &client_graph)",
          "new_text": null,
          "old_line_content": "    TF_RETURN_IF_ERROR(GraphExecutionState::MakeForPrunedGraph(",
          "new_line_content": "        &temp_exec_state_holder, &client_graph));",
          "content_same": false
        },
        {
          "line": 1610,
          "old_api": "BuildGraph",
          "new_api": null,
          "old_text": "TF_RETURN_IF_ERROR(\n        execution_state->BuildGraph(subgraph_options, &client_graph))",
          "new_text": null,
          "old_line_content": "    TF_RETURN_IF_ERROR(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1611,
          "old_api": "BuildGraph",
          "new_api": null,
          "old_text": "execution_state->BuildGraph(subgraph_options, &client_graph)",
          "new_text": null,
          "old_line_content": "        execution_state->BuildGraph(subgraph_options, &client_graph));",
          "new_line_content": "  *collective_graph_key = client_graph->collective_graph_key;",
          "content_same": false
        },
        {
          "line": 1616,
          "old_api": "size",
          "new_api": null,
          "old_text": "client_graph->feed_types.size()",
          "new_text": null,
          "old_line_content": "      client_graph->feed_types.size()) {",
          "new_line_content": "        \"Graph pruning failed: requested number of feed endpoints = \",",
          "content_same": false
        },
        {
          "line": 1624,
          "old_api": "size",
          "new_api": null,
          "old_text": "client_graph->fetch_types.size()",
          "new_text": null,
          "old_line_content": "      client_graph->fetch_types.size()) {",
          "new_line_content": "        \"Graph pruning failed: requested number of fetch endpoints = \",",
          "content_same": false
        },
        {
          "line": 1629,
          "old_api": "size",
          "new_api": null,
          "old_text": "client_graph->fetch_types.size()",
          "new_text": null,
          "old_line_content": "        client_graph->fetch_types.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1632,
          "old_api": "GetStatefulPlacements",
          "new_api": null,
          "old_text": "execution_state->GetStatefulPlacements()",
          "new_text": null,
          "old_line_content": "  auto current_stateful_placements = execution_state->GetStatefulPlacements();",
          "new_line_content": "  // placements.  If there are any mismatches for a node,",
          "content_same": false
        },
        {
          "line": 1640,
          "old_api": "end",
          "new_api": null,
          "old_text": "stateful_placements_.end()",
          "new_text": null,
          "old_line_content": "    if (iter == stateful_placements_.end()) {",
          "new_line_content": "    } else if (iter->second != placement) {",
          "content_same": false
        },
        {
          "line": 1643,
          "old_api": "errors::Internal(\n          \"Stateful placement mismatch. \"\n          \"Current assignment of \",\n          node_name, \" to \", iter->second, \" does not match \", placement)",
          "new_api": null,
          "old_text": "errors::Internal(\n          \"Stateful placement mismatch. \"\n          \"Current assignment of \",\n          node_name, \" to \", iter->second, \" does not match \", placement)",
          "new_text": null,
          "old_line_content": "      return errors::Internal(",
          "new_line_content": "          \"Current assignment of \",",
          "content_same": false
        },
        {
          "line": 1650,
          "old_api": "GetStatefulPlacements",
          "new_api": null,
          "old_text": "execution_state->GetStatefulPlacements()",
          "new_text": null,
          "old_line_content": "  stateful_placements_ = execution_state->GetStatefulPlacements();",
          "new_line_content": "  // Remember the graph in run state if this is a partial run.",
          "content_same": false
        },
        {
          "line": 1654,
          "old_api": "get",
          "new_api": null,
          "old_text": "flib_def_.get()",
          "new_text": null,
          "old_line_content": "    run_state_args->graph.reset(new Graph(flib_def_.get()));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1655,
          "old_api": "get",
          "new_api": null,
          "old_text": "run_state_args->graph.get()",
          "new_text": null,
          "old_line_content": "    CopyGraph(*execution_state->full_graph(), run_state_args->graph.get());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1661,
          "old_api": "assigned_device_name",
          "new_api": null,
          "old_text": "node->assigned_device_name()",
          "new_text": null,
          "old_line_content": "    return node->assigned_device_name();",
          "new_line_content": "  popts.new_name = [this](const string& prefix) {",
          "content_same": false
        },
        {
          "line": 1664,
          "old_api": "fetch_add",
          "new_api": null,
          "old_text": "edge_name_counter_.fetch_add(1)",
          "new_text": null,
          "old_line_content": "    return strings::StrCat(prefix, \"/_\", edge_name_counter_.fetch_add(1));",
          "new_line_content": "  popts.get_incarnation = [](const string& name) {",
          "content_same": false
        },
        {
          "line": 1671,
          "old_api": "flib_def",
          "new_api": null,
          "old_text": "client_graph->graph.flib_def()",
          "new_text": null,
          "old_line_content": "  popts.flib_def = &client_graph->graph.flib_def();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": "Partition",
          "new_api": null,
          "old_text": "Partition(popts, &client_graph->graph, &partitions)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(Partition(popts, &client_graph->graph, &partitions));",
          "new_line_content": "  std::vector<string> device_names;",
          "content_same": false
        },
        {
          "line": 1680,
          "old_api": "name",
          "new_api": null,
          "old_text": "device->name()",
          "new_text": null,
          "old_line_content": "    device_names.push_back(DeviceNameUtils::LocalName(device->name()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1686,
          "old_api": "DeviceNameUtils::LocalName(partition.first)",
          "new_api": null,
          "old_text": "DeviceNameUtils::LocalName(partition.first)",
          "new_text": null,
          "old_line_content": "        DeviceNameUtils::LocalName(partition.first);",
          "new_line_content": "                   local_partition_name) == 0) {",
          "content_same": false
        },
        {
          "line": 1689,
          "old_api": "errors::InvalidArgument(\n          \"Creating a partition for \", local_partition_name,\n          \" which doesn't exist in the list of available devices. Available \"\n          \"devices: \",\n          absl::StrJoin(device_names, \",\"))",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\n          \"Creating a partition for \", local_partition_name,\n          \" which doesn't exist in the list of available devices. Available \"\n          \"devices: \",\n          absl::StrJoin(device_names, \",\"))",
          "new_text": null,
          "old_line_content": "      return errors::InvalidArgument(",
          "new_line_content": "          \" which doesn't exist in the list of available devices. Available \"",
          "content_same": false
        },
        {
          "line": 1693,
          "old_api": "absl::StrJoin(device_names, \",\")",
          "new_api": null,
          "old_text": "absl::StrJoin(device_names, \",\")",
          "new_text": null,
          "old_line_content": "          absl::StrJoin(device_names, \",\"));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1699,
          "old_api": "get",
          "new_api": null,
          "old_text": "client_graph->flib_def.get()",
          "new_text": null,
          "old_line_content": "        new Graph(client_graph->flib_def.get()));",
          "new_line_content": "    // There are internal operations (e.g., send/recv) that we now allow.",
          "content_same": false
        },
        {
          "line": 1705,
          "old_api": "get",
          "new_api": null,
          "old_text": "device_graph.get()",
          "new_text": null,
          "old_line_content": "        device_opts, std::move(partition.second), device_graph.get()));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1706,
          "old_api": "std::move(device_graph)",
          "new_api": null,
          "old_text": "std::move(device_graph)",
          "new_text": null,
          "old_line_content": "    outputs->emplace(partition.first, std::move(device_graph));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1713,
          "old_api": "RunGrouping",
          "new_api": null,
          "old_text": "OptimizationPassRegistry::Global()->RunGrouping(\n      OptimizationPassRegistry::POST_PARTITIONING, optimization_options)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(OptimizationPassRegistry::Global()->RunGrouping(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": "get",
          "new_api": null,
          "old_text": "graph->get()",
          "new_text": null,
          "old_line_content": "    VLOG(2) << \"Created \" << DebugString(graph->get()) << \" for \"",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1728,
          "old_api": "MaybeRewriteGraph",
          "new_api": null,
          "old_text": "d->MaybeRewriteGraph(graph)",
          "new_text": null,
          "old_line_content": "    s = d->MaybeRewriteGraph(graph);",
          "new_line_content": "      break;",
          "content_same": false
        },
        {
          "line": 1729,
          "old_api": "ok",
          "new_api": null,
          "old_text": "s.ok()",
          "new_text": null,
          "old_line_content": "    if (!s.ok()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1734,
          "old_api": "std::swap(*input_types, client_graph->feed_types)",
          "new_api": null,
          "old_text": "std::swap(*input_types, client_graph->feed_types)",
          "new_text": null,
          "old_line_content": "  std::swap(*input_types, client_graph->feed_types);",
          "new_line_content": "  return s;",
          "content_same": false
        },
        {
          "line": 1735,
          "old_api": "std::swap(*output_types, client_graph->fetch_types)",
          "new_api": null,
          "old_text": "std::swap(*output_types, client_graph->fetch_types)",
          "new_text": null,
          "old_line_content": "  std::swap(*output_types, client_graph->fetch_types);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1741,
          "old_api": "clear",
          "new_api": null,
          "old_text": "response->clear()",
          "new_text": null,
          "old_line_content": "  response->clear();",
          "new_line_content": "  for (Device* d : devices_) {",
          "content_same": false
        },
        {
          "line": 1744,
          "old_api": "attributes",
          "new_api": null,
          "old_text": "d->attributes()",
          "new_text": null,
          "old_line_content": "    const DeviceAttributes& attrs = d->attributes();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1747,
          "old_api": "::tensorflow::Status::OK()",
          "new_api": null,
          "old_text": "::tensorflow::Status::OK()",
          "new_text": null,
          "old_line_content": "  return ::tensorflow::Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1752,
          "old_api": "ClearContainers",
          "new_api": null,
          "old_text": "device_mgr_->ClearContainers(containers)",
          "new_text": null,
          "old_line_content": "  device_mgr_->ClearContainers(containers);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1753,
          "old_api": "::tensorflow::Status::OK()",
          "new_api": null,
          "old_text": "::tensorflow::Status::OK()",
          "new_text": null,
          "old_line_content": "  return ::tensorflow::Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1757,
          "old_api": "StartCancel",
          "new_api": null,
          "old_text": "cancellation_manager_->StartCancel()",
          "new_text": null,
          "old_line_content": "  cancellation_manager_->StartCancel();",
          "new_line_content": "    mutex_lock l(closed_lock_);",
          "content_same": false
        },
        {
          "line": 1760,
          "old_api": "::tensorflow::Status::OK()",
          "new_api": null,
          "old_text": "::tensorflow::Status::OK()",
          "new_text": null,
          "old_line_content": "    if (closed_) return ::tensorflow::Status::OK();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1763,
          "old_api": "Deregister",
          "new_api": null,
          "old_text": "factory_->Deregister(this)",
          "new_text": null,
          "old_line_content": "  if (factory_ != nullptr) factory_->Deregister(this);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1764,
          "old_api": "::tensorflow::Status::OK()",
          "new_api": null,
          "old_text": "::tensorflow::Status::OK()",
          "new_text": null,
          "old_line_content": "  return ::tensorflow::Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1771,
          "old_api": "ok",
          "new_api": null,
          "old_text": "d->resource_manager()->Cleanup(name).ok()",
          "new_text": null,
          "old_line_content": "          if (!d->resource_manager()->Cleanup(name).ok()) {",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 1774,
          "old_api": "GetScopedAllocatorMgr",
          "new_api": null,
          "old_text": "d->GetScopedAllocatorMgr()",
          "new_text": null,
          "old_line_content": "          ScopedAllocatorMgr* sam = d->GetScopedAllocatorMgr();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1775,
          "old_api": "Cleanup",
          "new_api": null,
          "old_text": "sam->Cleanup(step_id)",
          "new_text": null,
          "old_line_content": "          if (sam) sam->Cleanup(step_id);",
          "new_line_content": "      }) {}",
          "content_same": false
        },
        {
          "line": 1795,
          "old_api": "errors::Cancelled(\"PRun cancellation\")",
          "new_api": null,
          "old_text": "errors::Cancelled(\"PRun cancellation\")",
          "new_text": null,
          "old_line_content": "    rendez->StartAbort(errors::Cancelled(\"PRun cancellation\"));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1796,
          "old_api": "WaitForNotification",
          "new_api": null,
          "old_text": "executors_done.WaitForNotification()",
          "new_text": null,
          "old_line_content": "    executors_done.WaitForNotification();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1813,
          "old_api": "WaitForNotification",
          "new_api": null,
          "old_text": "WaitForNotification(n, timeout_in_ms)",
          "new_text": null,
          "old_line_content": "  const Status status = WaitForNotification(n, timeout_in_ms);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1814,
          "old_api": "ok",
          "new_api": null,
          "old_text": "status.ok()",
          "new_text": null,
          "old_line_content": "  if (!status.ok()) {",
          "new_line_content": "      mutex_lock l(run_state->mu);",
          "content_same": false
        },
        {
          "line": 1819,
          "old_api": "StartCancel",
          "new_api": null,
          "old_text": "cm->StartCancel()",
          "new_text": null,
          "old_line_content": "    cm->StartCancel();",
          "new_line_content": "    // references to `cm` and other per-step state. After this notification, it",
          "content_same": false
        },
        {
          "line": 1823,
          "old_api": "WaitForNotification",
          "new_api": null,
          "old_text": "n->WaitForNotification()",
          "new_text": null,
          "old_line_content": "    n->WaitForNotification();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1834,
          "old_api": "Status",
          "new_api": null,
          "old_text": "Status(error::DEADLINE_EXCEEDED,\n                    \"Timed out waiting for notification\")",
          "new_text": null,
          "old_line_content": "      return Status(error::DEADLINE_EXCEEDED,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1840,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1845,
          "old_api": "CheckNotClosed",
          "new_api": null,
          "old_text": "CheckNotClosed()",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(CheckNotClosed());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1846,
          "old_api": "CheckGraphCreated",
          "new_api": null,
          "old_text": "CheckGraphCreated(\"MakeCallable()\")",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(CheckGraphCreated(\"MakeCallable()\"));",
          "new_line_content": "  std::unique_ptr<ExecutorsAndKeys> ek;",
          "content_same": false
        },
        {
          "line": 1851,
          "old_api": "TF_RETURN_IF_ERROR",
          "new_api": null,
          "old_text": "TF_RETURN_IF_ERROR(\n      CreateExecutors(callable_options, &ek, &func_info, &run_state_args))",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 1852,
          "old_api": "CreateExecutors",
          "new_api": null,
          "old_text": "CreateExecutors(callable_options, &ek, &func_info, &run_state_args)",
          "new_text": null,
          "old_line_content": "      CreateExecutors(callable_options, &ek, &func_info, &run_state_args));",
          "new_line_content": "    mutex_lock l(callables_lock_);",
          "content_same": false
        },
        {
          "line": 1858,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1873,
          "old_api": "size",
          "new_api": null,
          "old_text": "executors_and_keys_->input_types.size()",
          "new_text": null,
          "old_line_content": "    return executors_and_keys_->input_types.size();",
          "new_line_content": "  size_t num_retvals() const override {",
          "content_same": false
        },
        {
          "line": 1876,
          "old_api": "size",
          "new_api": null,
          "old_text": "executors_and_keys_->output_types.size()",
          "new_text": null,
          "old_line_content": "    return executors_and_keys_->output_types.size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": "size",
          "new_api": null,
          "old_text": "feed_tensors_->size()",
          "new_text": null,
          "old_line_content": "    if (TF_PREDICT_FALSE(index > feed_tensors_->size())) {",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1881,
          "old_api": "errors::Internal(\"Args index out of bounds: \", index)",
          "new_api": null,
          "old_text": "errors::Internal(\"Args index out of bounds: \", index)",
          "new_text": null,
          "old_line_content": "      return errors::Internal(\"Args index out of bounds: \", index);",
          "new_line_content": "      *val = &(*feed_tensors_)[index];",
          "content_same": false
        },
        {
          "line": 1885,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "    return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1889,
          "old_api": "size",
          "new_api": null,
          "old_text": "fetch_tensors_->size()",
          "new_text": null,
          "old_line_content": "    if (index > fetch_tensors_->size()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1890,
          "old_api": "errors::Internal(\"RetVal index out of bounds: \", index)",
          "new_api": null,
          "old_text": "errors::Internal(\"RetVal index out of bounds: \", index)",
          "new_text": null,
          "old_line_content": "      return errors::Internal(\"RetVal index out of bounds: \", index);",
          "new_line_content": "    (*fetch_tensors_)[index] = val;",
          "content_same": false
        },
        {
          "line": 1893,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "    return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1906,
          "old_api": "RunCallable",
          "new_api": null,
          "old_text": "RunCallable(handle, feed_tensors, fetch_tensors, run_metadata,\n                     thread::ThreadPoolOptions())",
          "new_text": null,
          "old_line_content": "  return RunCallable(handle, feed_tensors, fetch_tensors, run_metadata,",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1907,
          "old_api": "thread::ThreadPoolOptions()",
          "new_api": null,
          "old_text": "thread::ThreadPoolOptions()",
          "new_text": null,
          "old_line_content": "                     thread::ThreadPoolOptions());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1915,
          "old_api": "CheckGraphCreated",
          "new_api": null,
          "old_text": "CheckGraphCreated(\"RunCallable()\")",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(CheckGraphCreated(\"RunCallable()\"));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1916,
          "old_api": "GetCell",
          "new_api": null,
          "old_text": "direct_session_runs->GetCell()->IncrementBy(1)",
          "new_text": null,
          "old_line_content": "  direct_session_runs->GetCell()->IncrementBy(1);",
          "new_line_content": "  // Check if we already have an executor for these arguments.",
          "content_same": false
        },
        {
          "line": 1920,
          "old_api": "fetch_add",
          "new_api": null,
          "old_text": "step_id_counter_.fetch_add(1)",
          "new_text": null,
          "old_line_content": "  const int64 step_id = step_id_counter_.fetch_add(1);",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 1925,
          "old_api": "errors::InvalidArgument(\"No such callable handle: \", handle)",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\"No such callable handle: \", handle)",
          "new_text": null,
          "old_line_content": "      return errors::InvalidArgument(\"No such callable handle: \", handle);",
          "new_line_content": "    executors_and_keys = callables_[handle].executors_and_keys;",
          "content_same": false
        },
        {
          "line": 1931,
          "old_api": "errors::InvalidArgument(\n        \"Attempted to run callable after handle was released: \", handle)",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\n        \"Attempted to run callable after handle was released: \", handle)",
          "new_text": null,
          "old_line_content": "    return errors::InvalidArgument(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1944,
          "old_api": "size",
          "new_api": null,
          "old_text": "executors_and_keys->input_types.size()",
          "new_text": null,
          "old_line_content": "        \"Expected \", executors_and_keys->input_types.size(),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1945,
          "old_api": "size",
          "new_api": null,
          "old_text": "feed_tensors.size()",
          "new_text": null,
          "old_line_content": "        \" feed tensors, but got \", feed_tensors.size());",
          "new_line_content": "  if (fetch_tensors != nullptr) {",
          "content_same": false
        },
        {
          "line": 1949,
          "old_api": "empty",
          "new_api": null,
          "old_text": "executors_and_keys->output_types.empty()",
          "new_text": null,
          "old_line_content": "  } else if (!executors_and_keys->output_types.empty()) {",
          "new_line_content": "        \"`fetch_tensors` must be provided when the callable has one or more \"",
          "content_same": false
        },
        {
          "line": 1950,
          "old_api": "errors::InvalidArgument(\n        \"`fetch_tensors` must be provided when the callable has one or more \"\n        \"outputs.\")",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\n        \"`fetch_tensors` must be provided when the callable has one or more \"\n        \"outputs.\")",
          "new_text": null,
          "old_line_content": "    return errors::InvalidArgument(",
          "new_line_content": "        \"outputs.\");",
          "content_same": false
        },
        {
          "line": 1958,
          "old_api": "AllocatedBytes",
          "new_api": null,
          "old_text": "tensor.AllocatedBytes()",
          "new_text": null,
          "old_line_content": "    input_size += tensor.AllocatedBytes();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1961,
          "old_api": "metrics::RecordGraphInputTensors(input_size)",
          "new_api": null,
          "old_text": "metrics::RecordGraphInputTensors(input_size)",
          "new_text": null,
          "old_line_content": "  metrics::RecordGraphInputTensors(input_size);",
          "new_line_content": "  std::unique_ptr<std::vector<Tensor>> converted_feed_tensors;",
          "content_same": false
        },
        {
          "line": 1967,
          "old_api": "absl::make_unique<std::vector<Tensor>>()",
          "new_api": null,
          "old_text": "absl::make_unique<std::vector<Tensor>>()",
          "new_text": null,
          "old_line_content": "    converted_feed_tensors = absl::make_unique<std::vector<Tensor>>();",
          "new_line_content": "    for (const Tensor& t : feed_tensors) {",
          "content_same": false
        },
        {
          "line": 1972,
          "old_api": "back",
          "new_api": null,
          "old_text": "converted_feed_tensors->back()",
          "new_text": null,
          "old_line_content": "        Tensor* tensor_from_handle = &converted_feed_tensors->back();",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 1975,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "converted_feed_tensors->emplace_back(t)",
          "new_text": null,
          "old_line_content": "        converted_feed_tensors->emplace_back(t);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1978,
          "old_api": "get",
          "new_api": null,
          "old_text": "converted_feed_tensors.get()",
          "new_text": null,
          "old_line_content": "    actual_feed_tensors = converted_feed_tensors.get();",
          "new_line_content": "    actual_feed_tensors = &feed_tensors;",
          "content_same": false
        },
        {
          "line": 1985,
          "old_api": "get",
          "new_api": null,
          "old_text": "executors_and_keys.get()",
          "new_text": null,
          "old_line_content": "  RunCallableCallFrame call_frame(this, executors_and_keys.get(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1988,
          "old_api": "LogMemory::IsEnabled()",
          "new_api": null,
          "old_text": "LogMemory::IsEnabled()",
          "new_text": null,
          "old_line_content": "  if (LogMemory::IsEnabled()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1989,
          "old_api": "LogMemory::RecordStep(step_id, run_state_args.handle)",
          "new_api": null,
          "old_text": "LogMemory::RecordStep(step_id, run_state_args.handle)",
          "new_text": null,
          "old_line_content": "    LogMemory::RecordStep(step_id, run_state_args.handle);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1993,
          "old_api": "run_options",
          "new_api": null,
          "old_text": "executors_and_keys->callable_options.run_options()",
          "new_text": null,
          "old_line_content": "      step_id, executors_and_keys->callable_options.run_options(), &call_frame,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1994,
          "old_api": "get",
          "new_api": null,
          "old_text": "executors_and_keys.get()",
          "new_text": null,
          "old_line_content": "      executors_and_keys.get(), run_metadata, threadpool_options));",
          "new_line_content": "  if (fetch_tensors != nullptr) {",
          "content_same": false
        },
        {
          "line": 2001,
          "old_api": "metrics::RecordGraphOutputTensors(output_size)",
          "new_api": null,
          "old_text": "metrics::RecordGraphOutputTensors(output_size)",
          "new_text": null,
          "old_line_content": "    metrics::RecordGraphOutputTensors(output_size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2004,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2012,
          "old_api": "erase",
          "new_api": null,
          "old_text": "callables_.erase(handle)",
          "new_text": null,
          "old_line_content": "  callables_.erase(handle);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2013,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2019,
          "old_api": "errors::FailedPrecondition(\"Session already finalized.\")",
          "new_api": null,
          "old_text": "errors::FailedPrecondition(\"Session already finalized.\")",
          "new_text": null,
          "old_line_content": "    return errors::FailedPrecondition(\"Session already finalized.\");",
          "new_line_content": "  if (!graph_created_) {",
          "content_same": false
        },
        {
          "line": 2024,
          "old_api": "reset",
          "new_api": null,
          "old_text": "execution_state_.reset()",
          "new_text": null,
          "old_line_content": "  execution_state_.reset();",
          "new_line_content": "  finalized_ = true;",
          "content_same": false
        },
        {
          "line": 2027,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2036,
          "old_api": "reset",
          "new_api": null,
          "old_text": "executors_and_keys.reset()",
          "new_text": null,
          "old_line_content": "  executors_and_keys.reset();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2037,
          "old_api": "reset",
          "new_api": null,
          "old_text": "function_info.reset()",
          "new_text": null,
          "old_line_content": "  function_info.reset();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1530,
          "old_api": "emplace",
          "new_api": null,
          "old_text": "executors_.emplace(key, it->second)",
          "new_text": null,
          "old_line_content": "      executors_.emplace(key, it->second);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1531,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "      return Status::OK();",
          "new_line_content": "  }",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 39,
      "total_additions": 103,
      "total_deletions": 104,
      "total_api_changes": 246
    },
    "non_api_changes": {
      "has_non_api_changes": false,
      "evidence": {
        "total_diff_lines": 2,
        "api_related_lines": 246,
        "non_api_lines": 0,
        "non_api_line_numbers": []
      }
    },
    "api_calls_before": 847,
    "api_calls_after": 846,
    "diff_info": {
      "added_lines": 0,
      "removed_lines": 2,
      "total_diff_lines": 14
    }
  }
}