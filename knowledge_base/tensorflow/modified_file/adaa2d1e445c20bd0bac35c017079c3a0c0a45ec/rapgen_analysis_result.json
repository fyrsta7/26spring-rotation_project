{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/adaa2d1e445c20bd0bac35c017079c3a0c0a45ec",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/adaa2d1e445c20bd0bac35c017079c3a0c0a45ec/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/adaa2d1e445c20bd0bac35c017079c3a0c0a45ec/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/adaa2d1e445c20bd0bac35c017079c3a0c0a45ec/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 142,
          "old_api": "FindClustersInTheBlock",
          "new_api": "getContext",
          "old_text": "FindClustersInTheBlock(block, policies, filter)",
          "new_text": "getContext()",
          "old_line_content": "      for (Cluster& cluster : FindClustersInTheBlock(block, policies, filter)) {",
          "new_line_content": "    auto policy = mlir::StringAttr::get(&getContext(), \"tfrt.auto-fusion\");",
          "content_same": false
        },
        {
          "line": 144,
          "old_api": "size",
          "new_api": "walk",
          "old_text": "cluster.operations.size()",
          "new_text": "getOperation().walk([&](mlir::Block* block) {\n      for (Cluster& cluster : FindClustersInTheBlock(block, policies, filter)) {\n        // Do not create too small clusters.\n        if (cluster.operations.size() < min_cluster_size) continue;\n        // Verify that JIT runtime can compile the cluster.\n        if (failed(VerifyCluster(cluster))) continue;\n\n        CreateClusterOp(cluster, policy);\n      }\n    })",
          "old_line_content": "        if (cluster.operations.size() < min_cluster_size) continue;",
          "new_line_content": "    getOperation().walk([&](mlir::Block* block) {",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 128,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "hoisted_ops.insert(op)",
          "old_line_content": "",
          "new_line_content": "      hoisted_ops.insert(op);",
          "content_same": false
        },
        {
          "line": 129,
          "old_api": null,
          "new_api": "user_end",
          "old_text": null,
          "new_text": "op->user_end()",
          "old_line_content": "    auto hoist_filter = [&](mlir::Operation* op) {",
          "new_line_content": "      work_list.append(op->user_begin(), op->user_end());",
          "content_same": false
        },
        {
          "line": 161,
          "old_api": null,
          "new_api": "std::make_unique<ClusteringPass>()",
          "old_text": null,
          "new_text": "std::make_unique<ClusteringPass>()",
          "old_line_content": "std::unique_ptr<mlir::OperationPass<mlir::FuncOp>> CreateTfJitRtClusteringPass(",
          "new_line_content": "  return std::make_unique<ClusteringPass>();",
          "content_same": false
        },
        {
          "line": 133,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "hoisted_ops.contains(op)",
          "old_line_content": "    // Combine together opset and hoist filters.",
          "new_line_content": "      return !hoisted_ops.contains(op);",
          "content_same": false
        },
        {
          "line": 166,
          "old_api": null,
          "new_api": "std::make_unique<ClusteringPass>(oplist, min_cluster_size)",
          "old_text": null,
          "new_text": "std::make_unique<ClusteringPass>(oplist, min_cluster_size)",
          "old_line_content": "}  // namespace tensorflow",
          "new_line_content": "  return std::make_unique<ClusteringPass>(oplist, min_cluster_size);",
          "content_same": false
        },
        {
          "line": 138,
          "old_api": null,
          "new_api": "hoist_filter",
          "old_text": null,
          "new_text": "hoist_filter(op)",
          "old_line_content": "    // Annotate all formed clusters with an attribute.",
          "new_line_content": "      return opset_filter(op) && hoist_filter(op);",
          "content_same": false
        },
        {
          "line": 145,
          "old_api": null,
          "new_api": "FindClustersInTheBlock",
          "old_text": null,
          "new_text": "FindClustersInTheBlock(block, policies, filter)",
          "old_line_content": "        // Verify that JIT runtime can compile the cluster.",
          "new_line_content": "      for (Cluster& cluster : FindClustersInTheBlock(block, policies, filter)) {",
          "content_same": false
        },
        {
          "line": 147,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "cluster.operations.size()",
          "old_line_content": "",
          "new_line_content": "        if (cluster.operations.size() < min_cluster_size) continue;",
          "content_same": false
        },
        {
          "line": 119,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "hoisted_ops.contains(op)",
          "old_line_content": "      bool all_operands_hoisted =",
          "new_line_content": "      if (hoisted_ops.contains(op)) continue;",
          "content_same": false
        },
        {
          "line": 149,
          "old_api": null,
          "new_api": "VerifyCluster",
          "old_text": null,
          "new_text": "VerifyCluster(cluster)",
          "old_line_content": "      }",
          "new_line_content": "        if (failed(VerifyCluster(cluster))) continue;",
          "content_same": false
        },
        {
          "line": 151,
          "old_api": null,
          "new_api": "CreateClusterOp",
          "old_text": null,
          "new_text": "CreateClusterOp(cluster, policy)",
          "old_line_content": "  }",
          "new_line_content": "        CreateClusterOp(cluster, policy);",
          "content_same": false
        },
        {
          "line": 123,
          "old_api": null,
          "new_api": "getOperands",
          "old_text": null,
          "new_text": "op->getOperands()",
          "old_line_content": "      if (!all_operands_hoisted) continue;",
          "new_line_content": "          llvm::all_of(op->getOperands(), [&](mlir::Value value) {",
          "content_same": false
        },
        {
          "line": 124,
          "old_api": null,
          "new_api": "getDefiningOp",
          "old_text": null,
          "new_text": "value.getDefiningOp()",
          "old_line_content": "",
          "new_line_content": "            return hoisted_ops.contains(value.getDefiningOp());",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 130,
          "old_api": "contains",
          "new_api": null,
          "old_text": "hoisted_ops.contains(op)",
          "new_text": null,
          "old_line_content": "      return !hoisted_ops.contains(op);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 163,
          "old_api": "std::make_unique<ClusteringPass>(oplist, min_cluster_size)",
          "new_api": null,
          "old_text": "std::make_unique<ClusteringPass>(oplist, min_cluster_size)",
          "new_text": null,
          "old_line_content": "  return std::make_unique<ClusteringPass>(oplist, min_cluster_size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 135,
          "old_api": "hoist_filter",
          "new_api": null,
          "old_text": "hoist_filter(op)",
          "new_text": null,
          "old_line_content": "      return opset_filter(op) && hoist_filter(op);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 139,
          "old_api": "getContext",
          "new_api": null,
          "old_text": "getContext()",
          "new_text": null,
          "old_line_content": "    auto policy = mlir::StringAttr::get(&getContext(), \"tfrt.auto-fusion\");",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 141,
          "old_api": "walk",
          "new_api": null,
          "old_text": "getOperation().walk([&](mlir::Block* block) {\n      for (Cluster& cluster : FindClustersInTheBlock(block, policies, filter)) {\n        // Do not create too small clusters.\n        if (cluster.operations.size() < min_cluster_size) continue;\n        // Verify that JIT runtime can compile the cluster.\n        if (failed(VerifyCluster(cluster))) continue;\n\n        CreateClusterOp(cluster, policy);\n      }\n    })",
          "new_text": null,
          "old_line_content": "    getOperation().walk([&](mlir::Block* block) {",
          "new_line_content": "    // Annotate all formed clusters with an attribute.",
          "content_same": false
        },
        {
          "line": 146,
          "old_api": "VerifyCluster",
          "new_api": null,
          "old_text": "VerifyCluster(cluster)",
          "new_text": null,
          "old_line_content": "        if (failed(VerifyCluster(cluster))) continue;",
          "new_line_content": "        // Do not create too small clusters.",
          "content_same": false
        },
        {
          "line": 148,
          "old_api": "CreateClusterOp",
          "new_api": null,
          "old_text": "CreateClusterOp(cluster, policy)",
          "new_text": null,
          "old_line_content": "        CreateClusterOp(cluster, policy);",
          "new_line_content": "        // Verify that JIT runtime can compile the cluster.",
          "content_same": false
        },
        {
          "line": 120,
          "old_api": "getOperands",
          "new_api": null,
          "old_text": "op->getOperands()",
          "new_text": null,
          "old_line_content": "          llvm::all_of(op->getOperands(), [&](mlir::Value value) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 121,
          "old_api": "getDefiningOp",
          "new_api": null,
          "old_text": "value.getDefiningOp()",
          "new_text": null,
          "old_line_content": "            return hoisted_ops.contains(value.getDefiningOp());",
          "new_line_content": "      // Add operation to hoisted ops set if all operands can be hoisted.",
          "content_same": false
        },
        {
          "line": 126,
          "old_api": "user_end",
          "new_api": null,
          "old_text": "op->user_end()",
          "new_text": null,
          "old_line_content": "      work_list.append(op->user_begin(), op->user_end());",
          "new_line_content": "      if (!all_operands_hoisted) continue;",
          "content_same": false
        },
        {
          "line": 125,
          "old_api": "insert",
          "new_api": null,
          "old_text": "hoisted_ops.insert(op)",
          "new_text": null,
          "old_line_content": "      hoisted_ops.insert(op);",
          "new_line_content": "          });",
          "content_same": false
        },
        {
          "line": 158,
          "old_api": "std::make_unique<ClusteringPass>()",
          "new_api": null,
          "old_text": "std::make_unique<ClusteringPass>()",
          "new_text": null,
          "old_line_content": "  return std::make_unique<ClusteringPass>();",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 2,
      "total_additions": 13,
      "total_deletions": 12,
      "total_api_changes": 27
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 3,
        "api_related_lines": 27,
        "non_api_lines": 1,
        "non_api_line_numbers": [
          118
        ]
      }
    },
    "api_calls_before": 40,
    "api_calls_after": 41,
    "diff_info": {
      "added_lines": 3,
      "removed_lines": 0,
      "total_diff_lines": 15
    }
  }
}