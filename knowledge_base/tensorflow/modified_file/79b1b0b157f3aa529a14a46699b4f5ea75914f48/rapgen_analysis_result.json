{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/79b1b0b157f3aa529a14a46699b4f5ea75914f48",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/79b1b0b157f3aa529a14a46699b4f5ea75914f48/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/79b1b0b157f3aa529a14a46699b4f5ea75914f48/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/79b1b0b157f3aa529a14a46699b4f5ea75914f48/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 281,
          "old_api": "sparse_handles.vec<int64>()",
          "new_api": "TensorShape",
          "old_text": "sparse_handles.vec<int64>()",
          "new_text": "TensorShape({N})",
          "old_line_content": "    auto sparse_handles_t = sparse_handles.vec<int64>();",
          "new_line_content": "    Tensor sparse_handles(DT_INT64, TensorShape({N}));",
          "content_same": false
        },
        {
          "line": 290,
          "old_api": "NumElements",
          "new_api": "data",
          "old_text": "input_shape->NumElements()",
          "new_text": "input_shape_vec.data()",
          "old_line_content": "                                input_shape->NumElements() - 1, &output_shape));",
          "new_line_content": "                                input_shape_vec.data() + 1,",
          "content_same": false
        },
        {
          "line": 297,
          "old_api": "insert",
          "new_api": "group",
          "old_text": "visited.insert(b)",
          "new_text": "subset.group()",
          "old_line_content": "      visited.insert(b);",
          "new_line_content": "      const int64 b = subset.group()[0];",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": "OP_REQUIRES",
          "new_api": "insert",
          "old_text": "OP_REQUIRES(\n          context, b > -1 && b < N,\n          errors::InvalidArgument(\n              \"Received unexpected column 0 value in input SparseTensor: \", b,\n              \" < 0 or >= N (= \", N, \")\"))",
          "new_text": "visited.insert(b)",
          "old_line_content": "      OP_REQUIRES(",
          "new_line_content": "      visited.insert(b);",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": "subset.values<T>()",
          "new_api": "indices",
          "old_text": "subset.values<T>()",
          "new_text": "subset.indices()",
          "old_line_content": "      const auto values = subset.values<T>();",
          "new_line_content": "      const auto indices = subset.indices();",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": "size",
          "new_api": "subset.values<T>()",
          "old_text": "values.size()",
          "new_text": "subset.values<T>()",
          "old_line_content": "      const int64 num_entries = values.size();",
          "new_line_content": "      const auto values = subset.values<T>();",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": "output_values.vec<T>()",
          "new_api": "output_indices.matrix<int64>()",
          "old_text": "output_values.vec<T>()",
          "new_text": "output_indices.matrix<int64>()",
          "old_line_content": "      auto output_values_t = output_values.vec<T>();",
          "new_line_content": "      auto output_indices_t = output_indices.matrix<int64>();",
          "content_same": false
        },
        {
          "line": 323,
          "old_api": "SparseTensor::Create(output_indices, output_values,\n                                          output_shape, &st_i)",
          "new_api": "OP_REQUIRES_OK",
          "old_text": "SparseTensor::Create(output_indices, output_values,\n                                          output_shape, &st_i)",
          "new_text": "OP_REQUIRES_OK(context,\n                     SparseTensor::Create(output_indices, output_values,\n                                          output_shape, &st_i))",
          "old_line_content": "                     SparseTensor::Create(output_indices, output_values,",
          "new_line_content": "      OP_REQUIRES_OK(context,",
          "content_same": false
        },
        {
          "line": 327,
          "old_api": "sparse_handles_t",
          "new_api": "AddSparseTensor",
          "old_text": "sparse_handles_t(b)",
          "new_text": "map->AddSparseTensor(context, st_i, &handle)",
          "old_line_content": "      sparse_handles_t(b) = handle;",
          "new_line_content": "      OP_REQUIRES_OK(context, map->AddSparseTensor(context, st_i, &handle));",
          "content_same": false
        },
        {
          "line": 345,
          "old_api": "sparse_handles_t",
          "new_api": "AddSparseTensor",
          "old_text": "sparse_handles_t(b)",
          "new_text": "map->AddSparseTensor(context, empty_st, &handle)",
          "old_line_content": "          sparse_handles_t(b) = handle;",
          "new_line_content": "                         map->AddSparseTensor(context, empty_st, &handle));",
          "content_same": false
        },
        {
          "line": 401,
          "old_api": "values",
          "new_api": "indices",
          "old_text": "st.values()",
          "new_text": "st.indices()",
          "old_line_content": "      const Tensor& output_values = st.values();",
          "new_line_content": "      const Tensor& output_indices = st.indices();",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": "shape",
          "new_api": "values",
          "old_text": "st.shape()",
          "new_text": "st.values()",
          "old_line_content": "      const auto output_shape = st.shape();",
          "new_line_content": "      const Tensor& output_values = st.values();",
          "content_same": false
        },
        {
          "line": 414,
          "old_api": "dtype",
          "new_api": "shape",
          "old_text": "OP_REQUIRES(\n          context, DataTypeToEnum<T>::value == output_values.dtype(),\n          errors::InvalidArgument(\n              \"Requested SparseTensor of type \",\n              DataTypeString(DataTypeToEnum<T>::value), \" but SparseTensor[\", i,\n              \"].values.dtype() == \", DataTypeString(output_values.dtype())))",
          "new_text": "output_values.shape().DebugString()",
          "old_line_content": "      OP_REQUIRES(",
          "new_line_content": "                      output_values.shape().DebugString()));",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": "dtype",
          "new_api": "DataTypeString",
          "old_text": "output_values.dtype()",
          "new_text": "DataTypeString(DataTypeToEnum<T>::value)",
          "old_line_content": "              \"].values.dtype() == \", DataTypeString(output_values.dtype())));",
          "new_line_content": "              DataTypeString(DataTypeToEnum<T>::value), \" but SparseTensor[\", i,",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": "size",
          "new_api": "dim_size",
          "old_text": "OP_REQUIRES(\n          context, rank == output_shape.size(),\n          errors::InvalidArgument(\"Expected column counts of SparseTensor[\", i,\n                                  \"].indices to match size of SparseTensor[\", i,\n                                  \"].shape \"\n                                  \"but they do not: \",\n                                  rank, \" vs. \", output_shape.size()))",
          "new_text": "output_indices.dim_size(1)",
          "old_line_content": "      OP_REQUIRES(",
          "new_line_content": "      int rank = output_indices.dim_size(1);",
          "content_same": false
        },
        {
          "line": 441,
          "old_api": "TensorShape",
          "new_api": "dim_size",
          "old_text": "TensorShape({1 + rank})",
          "new_text": "output_indices.dim_size(1)",
          "old_line_content": "      Tensor expanded_shape(DT_INT64, TensorShape({1 + rank}));",
          "new_line_content": "          DT_INT64, TensorShape({num_entries, 1 + output_indices.dim_size(1)}));",
          "content_same": false
        },
        {
          "line": 442,
          "old_api": "output_indices.matrix<int64>()",
          "new_api": "TensorShape",
          "old_text": "output_indices.matrix<int64>()",
          "new_text": "TensorShape({1 + rank})",
          "old_line_content": "      const auto& output_indices_t = output_indices.matrix<int64>();",
          "new_line_content": "      Tensor expanded_shape(DT_INT64, TensorShape({1 + rank}));",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": "expanded_indices.matrix<int64>()",
          "new_api": "output_indices.matrix<int64>()",
          "old_text": "expanded_indices.matrix<int64>()",
          "new_text": "output_indices.matrix<int64>()",
          "old_line_content": "      auto expanded_indices_t = expanded_indices.matrix<int64>();",
          "new_line_content": "      const auto& output_indices_t = output_indices.matrix<int64>();",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": "expanded_shape.vec<int64>()",
          "new_api": "expanded_indices.matrix<int64>()",
          "old_text": "expanded_shape.vec<int64>()",
          "new_text": "expanded_indices.matrix<int64>()",
          "old_line_content": "      auto expanded_shape_t = expanded_shape.vec<int64>();",
          "new_line_content": "      auto expanded_indices_t = expanded_indices.matrix<int64>();",
          "content_same": false
        },
        {
          "line": 445,
          "old_api": "setZero",
          "new_api": "expanded_shape.vec<int64>()",
          "old_text": "expanded_indices_t.chip<1>(0).setZero()",
          "new_text": "expanded_shape.vec<int64>()",
          "old_line_content": "      expanded_indices_t.chip<1>(0).setZero();",
          "new_line_content": "      auto expanded_shape_t = expanded_shape.vec<int64>();",
          "content_same": false
        },
        {
          "line": 449,
          "old_api": "expanded_shape_t",
          "new_api": "slice",
          "old_text": "expanded_shape_t(0)",
          "new_text": "expanded_indices_t.slice(indices_start, indices_sizes)",
          "old_line_content": "      expanded_shape_t(0) = 1;",
          "new_line_content": "      expanded_indices_t.slice(indices_start, indices_sizes) = output_indices_t;",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": "push_back",
          "new_api": "std::move(expanded_indices)",
          "old_text": "values_to_concat.push_back(output_values)",
          "new_text": "std::move(expanded_indices)",
          "old_line_content": "      values_to_concat.push_back(output_values);",
          "new_line_content": "      indices_to_concat.push_back(std::move(expanded_indices));",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": "std::move(expanded_tensor_shape)",
          "new_api": "push_back",
          "old_text": "std::move(expanded_tensor_shape)",
          "new_text": "values_to_concat.push_back(output_values)",
          "old_line_content": "      shapes_to_concat.push_back(std::move(expanded_tensor_shape));",
          "new_line_content": "      values_to_concat.push_back(output_values);",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": "std::move(indices_to_concat[i])",
          "new_api": "OP_REQUIRES_OK",
          "old_text": "std::move(indices_to_concat[i])",
          "new_text": "OP_REQUIRES_OK(context,\n                     SparseTensor::Create(std::move(indices_to_concat[i]),\n                                          std::move(values_to_concat[i]),\n                                          preconcat_shape, std_order, &tensor))",
          "old_line_content": "                     SparseTensor::Create(std::move(indices_to_concat[i]),",
          "new_line_content": "      OP_REQUIRES_OK(context,",
          "content_same": false
        },
        {
          "line": 495,
          "old_api": "std::move(values_to_concat[i])",
          "new_api": "std::move(indices_to_concat[i])",
          "old_text": "std::move(values_to_concat[i])",
          "new_text": "std::move(indices_to_concat[i])",
          "old_line_content": "                                          std::move(values_to_concat[i]),",
          "new_line_content": "                     SparseTensor::Create(std::move(indices_to_concat[i]),",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": "dims",
          "new_api": "SparseTensor::Concat<T>(tensors_to_concat)",
          "old_text": "output.dims()",
          "new_text": "SparseTensor::Concat<T>(tensors_to_concat)",
          "old_line_content": "    Tensor final_output_shape(DT_INT64, TensorShape({output.dims()}));",
          "new_line_content": "    auto output = SparseTensor::Concat<T>(tensors_to_concat);",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": "data",
          "new_api": "dims",
          "old_text": "final_output_shape.vec<int64>().data()",
          "new_text": "output.dims()",
          "old_line_content": "                final_output_shape.vec<int64>().data());",
          "new_line_content": "    std::copy_n(output.shape().data(), output.dims(),",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": "values",
          "new_api": "indices",
          "old_text": "output.values()",
          "new_text": "output.indices()",
          "old_line_content": "    context->set_output(1, output.values());",
          "new_line_content": "    context->set_output(0, output.indices());",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": "set_output",
          "new_api": "values",
          "old_text": "context->set_output(2, final_output_shape)",
          "new_text": "output.values()",
          "old_line_content": "    context->set_output(2, final_output_shape);",
          "new_line_content": "    context->set_output(1, output.values());",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 385,
          "old_api": null,
          "new_api": "errors::InvalidArgument(\"Must have at least 1 serialized SparseTensor, \"\n                                \"but input matrix has 0 rows\")",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\"Must have at least 1 serialized SparseTensor, \"\n                                \"but input matrix has 0 rows\")",
          "old_line_content": "                                \"but input matrix has 0 rows\"));",
          "new_line_content": "        errors::InvalidArgument(\"Must have at least 1 serialized SparseTensor, \"",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": null,
          "new_api": "set_output",
          "old_text": null,
          "new_text": "context->set_output(2, final_output_shape)",
          "old_line_content": "  }",
          "new_line_content": "    context->set_output(2, final_output_shape);",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": null,
          "new_api": "TF_CALL_ALL_TYPES",
          "old_text": null,
          "new_text": "TF_CALL_ALL_TYPES(REGISTER_KERNELS)",
          "old_line_content": "#undef REGISTER_KERNELS",
          "new_line_content": "TF_CALL_ALL_TYPES(REGISTER_KERNELS);",
          "content_same": false
        },
        {
          "line": 392,
          "old_api": null,
          "new_api": "sparse_handles.vec<int64>()",
          "old_text": null,
          "new_text": "sparse_handles.vec<int64>()",
          "old_line_content": "",
          "new_line_content": "    const auto& sparse_handles_t = sparse_handles.vec<int64>();",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": null,
          "new_api": "OP_REQUIRES",
          "old_text": null,
          "new_text": "OP_REQUIRES(\n        context, !overflow_ocurred,\n        errors::Internal(\"Encountered overflow from large input shape.\"))",
          "old_line_content": "        context, !overflow_ocurred,",
          "new_line_content": "    OP_REQUIRES(",
          "content_same": false
        },
        {
          "line": 396,
          "old_api": null,
          "new_api": "RetrieveAndClearSparseTensors",
          "old_text": null,
          "new_text": "map->RetrieveAndClearSparseTensors(\n                                context, sparse_handles_t, &sparse_tensors)",
          "old_line_content": "                                context, sparse_handles_t, &sparse_tensors));",
          "new_line_content": "    OP_REQUIRES_OK(context, map->RetrieveAndClearSparseTensors(",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": null,
          "new_api": "errors::Internal(\"Encountered overflow from large input shape.\")",
          "old_text": null,
          "new_text": "errors::Internal(\"Encountered overflow from large input shape.\")",
          "old_line_content": "",
          "new_line_content": "        errors::Internal(\"Encountered overflow from large input shape.\"));",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "std_order.end()",
          "old_line_content": "    SparseTensor input_st;",
          "new_line_content": "    std::iota(std_order.begin(), std_order.end(), 0);",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": null,
          "new_api": "SparseTensor::Create(*input_indices, *input_values,\n                                                 tensor_input_shape, std_order,\n                                                 &input_st)",
          "old_text": null,
          "new_text": "SparseTensor::Create(*input_indices, *input_values,\n                                                 tensor_input_shape, std_order,\n                                                 &input_st)",
          "old_line_content": "                                                 tensor_input_shape, std_order,",
          "new_line_content": "    OP_REQUIRES_OK(context, SparseTensor::Create(*input_indices, *input_values,",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "st.shape()",
          "old_line_content": "",
          "new_line_content": "      const auto output_shape = st.shape();",
          "content_same": false
        },
        {
          "line": 406,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\n                      \"Expected sparse_handles[\", i,\n                      \"] to represent an index matrix but received shape \",\n                      output_indices.shape().DebugString())",
          "old_line_content": "                      \"Expected sparse_handles[\", i,",
          "new_line_content": "                  errors::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": null,
          "new_api": "input_shape_vec",
          "old_text": null,
          "new_text": "input_shape_vec(0)",
          "old_line_content": "",
          "new_line_content": "    const int64 N = input_shape_vec(0);",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": null,
          "new_api": "sparse_handles.vec<int64>()",
          "old_text": null,
          "new_text": "sparse_handles.vec<int64>()",
          "old_line_content": "",
          "new_line_content": "    auto sparse_handles_t = sparse_handles.vec<int64>();",
          "content_same": false
        },
        {
          "line": 411,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\n                      \"Expected sparse_handles[\", i,\n                      \"] to represent a values vector but received shape \",\n                      output_values.shape().DebugString())",
          "old_line_content": "                      \"Expected sparse_handles[\", i,",
          "new_line_content": "                  errors::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": null,
          "new_api": "IndicesValid",
          "old_text": null,
          "new_text": "input_st.IndicesValid()",
          "old_line_content": "",
          "new_line_content": "    OP_REQUIRES_OK(context, input_st.IndicesValid());",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": null,
          "new_api": "dtype",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\n              \"Requested SparseTensor of type \",\n              DataTypeString(DataTypeToEnum<T>::value), \" but SparseTensor[\", i,\n              \"].values.dtype() == \", DataTypeString(output_values.dtype()))",
          "old_line_content": "              \"Requested SparseTensor of type \",",
          "new_line_content": "          errors::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": null,
          "new_api": "NumElements",
          "old_text": null,
          "new_text": "input_shape->NumElements()",
          "old_line_content": "",
          "new_line_content": "                                input_shape->NumElements() - 1, &output_shape));",
          "content_same": false
        },
        {
          "line": 420,
          "old_api": null,
          "new_api": "dtype",
          "old_text": null,
          "new_text": "output_values.dtype()",
          "old_line_content": "",
          "new_line_content": "              \"].values.dtype() == \", DataTypeString(output_values.dtype())));",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": null,
          "new_api": "group",
          "old_text": null,
          "new_text": "input_st.group({0})",
          "old_line_content": "    for (const auto& subset : minibatch) {",
          "new_line_content": "    sparse::GroupIterable minibatch = input_st.group({0});",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": null,
          "new_api": "dim_size",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\n                      \"Expected row counts of SparseTensor[\", i,\n                      \"].indices and SparseTensor[\", i,\n                      \"].values to match but they do not: \", num_entries,\n                      \" vs. \", output_values.dim_size(0))",
          "old_line_content": "                      \"Expected row counts of SparseTensor[\", i,",
          "new_line_content": "                  errors::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": null,
          "new_api": "OP_REQUIRES",
          "old_text": null,
          "new_text": "OP_REQUIRES(\n          context, b > -1 && b < N,\n          errors::InvalidArgument(\n              \"Received unexpected column 0 value in input SparseTensor: \", b,\n              \" < 0 or >= N (= \", N, \")\"))",
          "old_line_content": "          context, b > -1 && b < N,",
          "new_line_content": "      OP_REQUIRES(",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": null,
          "new_api": "errors::InvalidArgument(\n              \"Received unexpected column 0 value in input SparseTensor: \", b,\n              \" < 0 or >= N (= \", N, \")\")",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\n              \"Received unexpected column 0 value in input SparseTensor: \", b,\n              \" < 0 or >= N (= \", N, \")\")",
          "old_line_content": "              \"Received unexpected column 0 value in input SparseTensor: \", b,",
          "new_line_content": "          errors::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 432,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\"Expected column counts of SparseTensor[\", i,\n                                  \"].indices to match size of SparseTensor[\", i,\n                                  \"].shape \"\n                                  \"but they do not: \",\n                                  rank, \" vs. \", output_shape.size())",
          "old_line_content": "                                  \"].indices to match size of SparseTensor[\", i,",
          "new_line_content": "          errors::InvalidArgument(\"Expected column counts of SparseTensor[\", i,",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "values.size()",
          "old_line_content": "",
          "new_line_content": "      const int64 num_entries = values.size();",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "output_shape.size()",
          "old_line_content": "",
          "new_line_content": "                                  rank, \" vs. \", output_shape.size()));",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": null,
          "new_api": "Tensor",
          "old_text": null,
          "new_text": "Tensor(DataTypeToEnum<T>::value, {num_entries})",
          "old_line_content": "",
          "new_line_content": "      Tensor output_values = Tensor(DataTypeToEnum<T>::value, {num_entries});",
          "content_same": false
        },
        {
          "line": 313,
          "old_api": null,
          "new_api": "output_values.vec<T>()",
          "old_text": null,
          "new_text": "output_values.vec<T>()",
          "old_line_content": "",
          "new_line_content": "      auto output_values_t = output_values.vec<T>();",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": null,
          "new_api": "indices",
          "old_text": null,
          "new_text": "indices(i, d)",
          "old_line_content": "        }",
          "new_line_content": "          output_indices_t(i, d - 1) = indices(i, d);",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": null,
          "new_api": "setZero",
          "old_text": null,
          "new_text": "expanded_indices_t.chip<1>(0).setZero()",
          "old_line_content": "      Eigen::DSizes<Eigen::DenseIndex, 2> indices_start(0, 1);",
          "new_line_content": "      expanded_indices_t.chip<1>(0).setZero();",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": null,
          "new_api": "values",
          "old_text": null,
          "new_text": "values(i)",
          "old_line_content": "      }",
          "new_line_content": "        output_values_t(i) = values(i);",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": null,
          "new_api": "expanded_shape_t",
          "old_text": null,
          "new_text": "expanded_shape_t(0)",
          "old_line_content": "      // TODO: copy shape from TensorShape to &expanded_shape_t(1)",
          "new_line_content": "      expanded_shape_t(0) = 1;",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": null,
          "new_api": "SparseTensor::Create(output_indices, output_values,\n                                          output_shape, &st_i)",
          "old_text": null,
          "new_text": "SparseTensor::Create(output_indices, output_values,\n                                          output_shape, &st_i)",
          "old_line_content": "                                          output_shape, &st_i));",
          "new_line_content": "                     SparseTensor::Create(output_indices, output_values,",
          "content_same": false
        },
        {
          "line": 454,
          "old_api": null,
          "new_api": "expanded_shape_t",
          "old_text": null,
          "new_text": "expanded_shape_t(i + 1)",
          "old_line_content": "      }",
          "new_line_content": "        expanded_shape_t(i + 1) = output_shape[i];",
          "content_same": false
        },
        {
          "line": 328,
          "old_api": null,
          "new_api": "sparse_handles_t",
          "old_text": null,
          "new_text": "sparse_handles_t(b)",
          "old_line_content": "    }",
          "new_line_content": "      sparse_handles_t(b) = handle;",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": null,
          "new_api": "std::move(expanded_tensor_shape)",
          "old_text": null,
          "new_text": "std::move(expanded_tensor_shape)",
          "old_line_content": "    }",
          "new_line_content": "      shapes_to_concat.push_back(std::move(expanded_tensor_shape));",
          "content_same": false
        },
        {
          "line": 333,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "visited.size()",
          "old_line_content": "      Tensor empty_indices(DT_INT64, {0, rank - 1});",
          "new_line_content": "    if (visited.size() < N) {",
          "content_same": false
        },
        {
          "line": 337,
          "old_api": null,
          "new_api": "SparseTensor::Create(empty_indices, empty_values,\n                                                   output_shape, &empty_st)",
          "old_text": null,
          "new_text": "SparseTensor::Create(empty_indices, empty_values,\n                                                   output_shape, &empty_st)",
          "old_line_content": "                                                   output_shape, &empty_st));",
          "new_line_content": "      OP_REQUIRES_OK(context, SparseTensor::Create(empty_indices, empty_values,",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": null,
          "new_api": "dims",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\n                      \"Inconsistent rank across SparseTensors: rank prior to \"\n                      \"SparseTensor[\",\n                      i, \"] was: \", rank, \" but rank of SparseTensor[\", i,\n                      \"] is: \", shapes_to_concat[i].dims())",
          "old_line_content": "                      \"Inconsistent rank across SparseTensors: rank prior to \"",
          "new_line_content": "                  errors::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "visited.end()",
          "old_line_content": "          int64 handle;",
          "new_line_content": "        if (visited.find(b) == visited.end()) {",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": null,
          "new_api": "dims",
          "old_text": null,
          "new_text": "shapes_to_concat[i].dims()",
          "old_line_content": "    }",
          "new_line_content": "                      \"] is: \", shapes_to_concat[i].dims()));",
          "content_same": false
        },
        {
          "line": 346,
          "old_api": null,
          "new_api": "sparse_handles_t",
          "old_text": null,
          "new_text": "sparse_handles_t(b)",
          "old_line_content": "        }",
          "new_line_content": "          sparse_handles_t(b) = handle;",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": null,
          "new_api": "set_output",
          "old_text": null,
          "new_text": "context->set_output(0, sparse_handles)",
          "old_line_content": "  }",
          "new_line_content": "    context->set_output(0, sparse_handles);",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": null,
          "new_api": "dim_size",
          "old_text": null,
          "new_text": "shapes_to_concat[i].dim_size(d)",
          "old_line_content": "      }",
          "new_line_content": "                                            shapes_to_concat[i].dim_size(d)));",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "std_order.end()",
          "old_line_content": "",
          "new_line_content": "    std::iota(std_order.begin(), std_order.end(), 0);",
          "content_same": false
        },
        {
          "line": 361,
          "old_api": null,
          "new_api": "TF_CALL_ALL_TYPES",
          "old_text": null,
          "new_text": "TF_CALL_ALL_TYPES(REGISTER_KERNELS)",
          "old_line_content": "#undef REGISTER_KERNELS",
          "new_line_content": "TF_CALL_ALL_TYPES(REGISTER_KERNELS);",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "tensors_to_concat.reserve(N)",
          "old_line_content": "    for (int i = 0; i < N; ++i) {",
          "new_line_content": "    tensors_to_concat.reserve(N);",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "final_output_shape.vec<int64>().data()",
          "old_line_content": "",
          "new_line_content": "                final_output_shape.vec<int64>().data());",
          "content_same": false
        },
        {
          "line": 367,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "      : SparseTensorAccessingOp(context) {}",
          "new_line_content": "  explicit TakeManySparseFromTensorsMapOp(OpKernelConstruction* context)",
          "content_same": false
        },
        {
          "line": 496,
          "old_api": null,
          "new_api": "std::move(values_to_concat[i])",
          "old_text": null,
          "new_text": "std::move(values_to_concat[i])",
          "old_line_content": "                                          preconcat_shape, std_order, &tensor));",
          "new_line_content": "                                          std::move(values_to_concat[i]),",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": null,
          "new_api": "std::move(tensor)",
          "old_text": null,
          "new_text": "std::move(tensor)",
          "old_line_content": "    }",
          "new_line_content": "      tensors_to_concat.push_back(std::move(tensor));",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": null,
          "new_api": "GetMap",
          "old_text": null,
          "new_text": "GetMap(context, false /* is_writing */, &map)",
          "old_line_content": "",
          "new_line_content": "    OP_REQUIRES_OK(context, GetMap(context, false /* is_writing */, &map));",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": null,
          "new_api": "input",
          "old_text": null,
          "new_text": "context->input(0)",
          "old_line_content": "",
          "new_line_content": "    const Tensor& sparse_handles = context->input(0);",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": null,
          "new_api": "dims",
          "old_text": null,
          "new_text": "output.dims()",
          "old_line_content": "",
          "new_line_content": "    Tensor final_output_shape(DT_INT64, TensorShape({output.dims()}));",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\n                    \"sparse_handles should be a vector but received shape \",\n                    sparse_handles.shape().DebugString())",
          "old_line_content": "                    \"sparse_handles should be a vector but received shape \",",
          "new_line_content": "                errors::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "sparse_handles.shape().DebugString()",
          "old_line_content": "",
          "new_line_content": "                    sparse_handles.shape().DebugString()));",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "sparse_handles.shape().dim_size(0)",
          "old_line_content": "",
          "new_line_content": "    int64 N = sparse_handles.shape().dim_size(0);",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": null,
          "new_api": "OP_REQUIRES",
          "old_text": null,
          "new_text": "OP_REQUIRES(\n        context, N > 0,\n        errors::InvalidArgument(\"Must have at least 1 serialized SparseTensor, \"\n                                \"but input matrix has 0 rows\"))",
          "old_line_content": "        context, N > 0,",
          "new_line_content": "    OP_REQUIRES(",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 384,
          "old_api": "errors::InvalidArgument(\"Must have at least 1 serialized SparseTensor, \"\n                                \"but input matrix has 0 rows\")",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\"Must have at least 1 serialized SparseTensor, \"\n                                \"but input matrix has 0 rows\")",
          "new_text": null,
          "old_line_content": "        errors::InvalidArgument(\"Must have at least 1 serialized SparseTensor, \"",
          "new_line_content": "        context, N > 0,",
          "content_same": false
        },
        {
          "line": 518,
          "old_api": "TF_CALL_ALL_TYPES",
          "new_api": null,
          "old_text": "TF_CALL_ALL_TYPES(REGISTER_KERNELS)",
          "new_text": null,
          "old_line_content": "TF_CALL_ALL_TYPES(REGISTER_KERNELS);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 391,
          "old_api": "sparse_handles.vec<int64>()",
          "new_api": null,
          "old_text": "sparse_handles.vec<int64>()",
          "new_text": null,
          "old_line_content": "    const auto& sparse_handles_t = sparse_handles.vec<int64>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 266,
          "old_api": "OP_REQUIRES",
          "new_api": null,
          "old_text": "OP_REQUIRES(\n        context, !overflow_ocurred,\n        errors::Internal(\"Encountered overflow from large input shape.\"))",
          "new_text": null,
          "old_line_content": "    OP_REQUIRES(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": "RetrieveAndClearSparseTensors",
          "new_api": null,
          "old_text": "map->RetrieveAndClearSparseTensors(\n                                context, sparse_handles_t, &sparse_tensors)",
          "new_text": null,
          "old_line_content": "    OP_REQUIRES_OK(context, map->RetrieveAndClearSparseTensors(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 268,
          "old_api": "errors::Internal(\"Encountered overflow from large input shape.\")",
          "new_api": null,
          "old_text": "errors::Internal(\"Encountered overflow from large input shape.\")",
          "new_text": null,
          "old_line_content": "        errors::Internal(\"Encountered overflow from large input shape.\"));",
          "new_line_content": "        context, !overflow_ocurred,",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": "end",
          "new_api": null,
          "old_text": "std_order.end()",
          "new_text": null,
          "old_line_content": "    std::iota(std_order.begin(), std_order.end(), 0);",
          "new_line_content": "    gtl::InlinedVector<int64, 8> std_order(rank);",
          "content_same": false
        },
        {
          "line": 400,
          "old_api": "indices",
          "new_api": null,
          "old_text": "st.indices()",
          "new_text": null,
          "old_line_content": "      const Tensor& output_indices = st.indices();",
          "new_line_content": "      const SparseTensor& st = sparse_tensors[i];",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": "SparseTensor::Create(*input_indices, *input_values,\n                                                 tensor_input_shape, std_order,\n                                                 &input_st)",
          "new_api": null,
          "old_text": "SparseTensor::Create(*input_indices, *input_values,\n                                                 tensor_input_shape, std_order,\n                                                 &input_st)",
          "new_text": null,
          "old_line_content": "    OP_REQUIRES_OK(context, SparseTensor::Create(*input_indices, *input_values,",
          "new_line_content": "    SparseTensor input_st;",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": "shape",
          "new_api": null,
          "old_text": "output_indices.shape()",
          "new_text": null,
          "old_line_content": "      OP_REQUIRES(context, TensorShapeUtils::IsMatrix(output_indices.shape()),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": "input_shape_vec",
          "new_api": null,
          "old_text": "input_shape_vec(0)",
          "new_text": null,
          "old_line_content": "    const int64 N = input_shape_vec(0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 280,
          "old_api": "TensorShape",
          "new_api": null,
          "old_text": "TensorShape({N})",
          "new_text": null,
          "old_line_content": "    Tensor sparse_handles(DT_INT64, TensorShape({N}));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": "shape",
          "new_api": null,
          "old_text": "output_indices.shape().DebugString()",
          "new_text": null,
          "old_line_content": "                      output_indices.shape().DebugString()));",
          "new_line_content": "                      \"] to represent an index matrix but received shape \",",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": "IndicesValid",
          "new_api": null,
          "old_text": "input_st.IndicesValid()",
          "new_text": null,
          "old_line_content": "    OP_REQUIRES_OK(context, input_st.IndicesValid());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": "shape",
          "new_api": null,
          "old_text": "output_values.shape().DebugString()",
          "new_text": null,
          "old_line_content": "                      output_values.shape().DebugString()));",
          "new_line_content": "                      \"] to represent a values vector but received shape \",",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": "data",
          "new_api": null,
          "old_text": "TensorShapeUtils::MakeShape(\n                                input_shape_vec.data() + 1,\n                                input_shape->NumElements() - 1, &output_shape)",
          "new_text": null,
          "old_line_content": "    OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(",
          "new_line_content": "    TensorShape output_shape;",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": "DataTypeString",
          "new_api": null,
          "old_text": "DataTypeString(DataTypeToEnum<T>::value)",
          "new_text": null,
          "old_line_content": "              DataTypeString(DataTypeToEnum<T>::value), \" but SparseTensor[\", i,",
          "new_line_content": "              \"Requested SparseTensor of type \",",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": "dim_size",
          "new_api": null,
          "old_text": "output_indices.dim_size(0)",
          "new_text": null,
          "old_line_content": "      int64 num_entries = output_indices.dim_size(0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": "group",
          "new_api": null,
          "old_text": "input_st.group({0})",
          "new_text": null,
          "old_line_content": "    sparse::GroupIterable minibatch = input_st.group({0});",
          "new_line_content": "    std::unordered_set<int64> visited;",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": "group",
          "new_api": null,
          "old_text": "subset.group()",
          "new_text": null,
          "old_line_content": "      const int64 b = subset.group()[0];",
          "new_line_content": "    for (const auto& subset : minibatch) {",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": "dim_size",
          "new_api": null,
          "old_text": "output_values.dim_size(0)",
          "new_text": null,
          "old_line_content": "                      \" vs. \", output_values.dim_size(0)));",
          "new_line_content": "                      \"].values to match but they do not: \", num_entries,",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": "errors::InvalidArgument(\n              \"Received unexpected column 0 value in input SparseTensor: \", b,\n              \" < 0 or >= N (= \", N, \")\")",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\n              \"Received unexpected column 0 value in input SparseTensor: \", b,\n              \" < 0 or >= N (= \", N, \")\")",
          "new_text": null,
          "old_line_content": "          errors::InvalidArgument(",
          "new_line_content": "          context, b > -1 && b < N,",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": "indices",
          "new_api": null,
          "old_text": "subset.indices()",
          "new_text": null,
          "old_line_content": "      const auto indices = subset.indices();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 435,
          "old_api": "size",
          "new_api": null,
          "old_text": "output_shape.size()",
          "new_text": null,
          "old_line_content": "                                  rank, \" vs. \", output_shape.size()));",
          "new_line_content": "                                  \"but they do not: \",",
          "content_same": false
        },
        {
          "line": 308,
          "old_api": "Tensor",
          "new_api": null,
          "old_text": "Tensor(DT_INT64, {num_entries, rank - 1})",
          "new_text": null,
          "old_line_content": "      Tensor output_indices = Tensor(DT_INT64, {num_entries, rank - 1});",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 311,
          "old_api": "output_indices.matrix<int64>()",
          "new_api": null,
          "old_text": "output_indices.matrix<int64>()",
          "new_text": null,
          "old_line_content": "      auto output_indices_t = output_indices.matrix<int64>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": "dim_size",
          "new_api": null,
          "old_text": "output_indices.dim_size(1)",
          "new_text": null,
          "old_line_content": "          DT_INT64, TensorShape({num_entries, 1 + output_indices.dim_size(1)}));",
          "new_line_content": "      Tensor expanded_indices(",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": "indices",
          "new_api": null,
          "old_text": "indices(i, d)",
          "new_text": null,
          "old_line_content": "          output_indices_t(i, d - 1) = indices(i, d);",
          "new_line_content": "        for (int d = 1; d < rank; ++d) {",
          "content_same": false
        },
        {
          "line": 318,
          "old_api": "values",
          "new_api": null,
          "old_text": "values(i)",
          "new_text": null,
          "old_line_content": "        output_values_t(i) = values(i);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 448,
          "old_api": "slice",
          "new_api": null,
          "old_text": "expanded_indices_t.slice(indices_start, indices_sizes)",
          "new_text": null,
          "old_line_content": "      expanded_indices_t.slice(indices_start, indices_sizes) = output_indices_t;",
          "new_line_content": "      Eigen::DSizes<Eigen::DenseIndex, 2> indices_sizes(num_entries, rank);",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": "OP_REQUIRES_OK",
          "new_api": null,
          "old_text": "OP_REQUIRES_OK(context,\n                     SparseTensor::Create(output_indices, output_values,\n                                          output_shape, &st_i))",
          "new_text": null,
          "old_line_content": "      OP_REQUIRES_OK(context,",
          "new_line_content": "      SparseTensor st_i;",
          "content_same": false
        },
        {
          "line": 453,
          "old_api": "expanded_shape_t",
          "new_api": null,
          "old_text": "expanded_shape_t(i + 1)",
          "new_text": null,
          "old_line_content": "        expanded_shape_t(i + 1) = output_shape[i];",
          "new_line_content": "      for (int i = 0; i < rank; ++i) {",
          "content_same": false
        },
        {
          "line": 326,
          "old_api": "AddSparseTensor",
          "new_api": null,
          "old_text": "map->AddSparseTensor(context, st_i, &handle)",
          "new_text": null,
          "old_line_content": "      OP_REQUIRES_OK(context, map->AddSparseTensor(context, st_i, &handle));",
          "new_line_content": "      int64 handle;",
          "content_same": false
        },
        {
          "line": 457,
          "old_api": "std::move(expanded_indices)",
          "new_api": null,
          "old_text": "std::move(expanded_indices)",
          "new_text": null,
          "old_line_content": "      indices_to_concat.push_back(std::move(expanded_indices));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 332,
          "old_api": "size",
          "new_api": null,
          "old_text": "visited.size()",
          "new_text": null,
          "old_line_content": "    if (visited.size() < N) {",
          "new_line_content": "    // the grouper didn't find.",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": "SparseTensor::Create(empty_indices, empty_values,\n                                                   output_shape, &empty_st)",
          "new_api": null,
          "old_text": "SparseTensor::Create(empty_indices, empty_values,\n                                                   output_shape, &empty_st)",
          "new_text": null,
          "old_line_content": "      OP_REQUIRES_OK(context, SparseTensor::Create(empty_indices, empty_values,",
          "new_line_content": "      SparseTensor empty_st;",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": "dims",
          "new_api": null,
          "old_text": "shapes_to_concat[i].dims()",
          "new_text": null,
          "old_line_content": "      if (rank < 0) rank = shapes_to_concat[i].dims();",
          "new_line_content": "    for (int i = 0; i < N; ++i) {",
          "content_same": false
        },
        {
          "line": 341,
          "old_api": "end",
          "new_api": null,
          "old_text": "visited.end()",
          "new_text": null,
          "old_line_content": "        if (visited.find(b) == visited.end()) {",
          "new_line_content": "        // We skipped this batch entry.",
          "content_same": false
        },
        {
          "line": 470,
          "old_api": "dims",
          "new_api": null,
          "old_text": "shapes_to_concat[i].dims()",
          "new_text": null,
          "old_line_content": "                      \"] is: \", shapes_to_concat[i].dims()));",
          "new_line_content": "                      i, \"] was: \", rank, \" but rank of SparseTensor[\", i,",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": "AddSparseTensor",
          "new_api": null,
          "old_text": "OP_REQUIRES_OK(context,\n                         map->AddSparseTensor(context, empty_st, &handle))",
          "new_text": null,
          "old_line_content": "          OP_REQUIRES_OK(context,",
          "new_line_content": "          int64 handle;",
          "content_same": false
        },
        {
          "line": 350,
          "old_api": "set_output",
          "new_api": null,
          "old_text": "context->set_output(0, sparse_handles)",
          "new_text": null,
          "old_line_content": "    context->set_output(0, sparse_handles);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": "dim_size",
          "new_api": null,
          "old_text": "preconcat_shape.dim_size(d)",
          "new_text": null,
          "old_line_content": "        preconcat_shape.set_dim(d, std::max(preconcat_shape.dim_size(d),",
          "new_line_content": "      for (int d = 0; d < rank; ++d) {",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": "dims",
          "new_api": null,
          "old_text": "output.dims()",
          "new_text": null,
          "old_line_content": "    std::copy_n(output.shape().data(), output.dims(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": "end",
          "new_api": null,
          "old_text": "std_order.end()",
          "new_text": null,
          "old_line_content": "    std::iota(std_order.begin(), std_order.end(), 0);",
          "new_line_content": "    gtl::InlinedVector<int64, 8> std_order(rank);",
          "content_same": false
        },
        {
          "line": 360,
          "old_api": "TF_CALL_ALL_TYPES",
          "new_api": null,
          "old_text": "TF_CALL_ALL_TYPES(REGISTER_KERNELS)",
          "new_text": null,
          "old_line_content": "TF_CALL_ALL_TYPES(REGISTER_KERNELS);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 490,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "tensors_to_concat.reserve(N)",
          "new_text": null,
          "old_line_content": "    tensors_to_concat.reserve(N);",
          "new_line_content": "    std::vector<SparseTensor> tensors_to_concat;",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": "OP_REQUIRES_OK",
          "new_api": null,
          "old_text": "OP_REQUIRES_OK(context,\n                     SparseTensor::Create(std::move(indices_to_concat[i]),\n                                          std::move(values_to_concat[i]),\n                                          preconcat_shape, std_order, &tensor))",
          "new_text": null,
          "old_line_content": "      OP_REQUIRES_OK(context,",
          "new_line_content": "      SparseTensor tensor;",
          "content_same": false
        },
        {
          "line": 366,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit TakeManySparseFromTensorsMapOp(OpKernelConstruction* context)",
          "new_line_content": " public:",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": "std::move(tensor)",
          "new_api": null,
          "old_text": "std::move(tensor)",
          "new_text": null,
          "old_line_content": "      tensors_to_concat.push_back(std::move(tensor));",
          "new_line_content": "                                          preconcat_shape, std_order, &tensor));",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": "indices",
          "new_api": null,
          "old_text": "output.indices()",
          "new_text": null,
          "old_line_content": "    context->set_output(0, output.indices());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 371,
          "old_api": "GetMap",
          "new_api": null,
          "old_text": "GetMap(context, false /* is_writing */, &map)",
          "new_text": null,
          "old_line_content": "    OP_REQUIRES_OK(context, GetMap(context, false /* is_writing */, &map));",
          "new_line_content": "    SparseTensorsMap* map = nullptr;",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "SparseTensor::Concat<T>(tensors_to_concat)",
          "new_api": null,
          "old_text": "SparseTensor::Concat<T>(tensors_to_concat)",
          "new_text": null,
          "old_line_content": "    auto output = SparseTensor::Concat<T>(tensors_to_concat);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 373,
          "old_api": "input",
          "new_api": null,
          "old_text": "context->input(0)",
          "new_text": null,
          "old_line_content": "    const Tensor& sparse_handles = context->input(0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 375,
          "old_api": "shape",
          "new_api": null,
          "old_text": "sparse_handles.shape()",
          "new_text": null,
          "old_line_content": "    OP_REQUIRES(context, TensorShapeUtils::IsVector(sparse_handles.shape()),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": "shape",
          "new_api": null,
          "old_text": "sparse_handles.shape().DebugString()",
          "new_text": null,
          "old_line_content": "                    sparse_handles.shape().DebugString()));",
          "new_line_content": "                    \"sparse_handles should be a vector but received shape \",",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": "shape",
          "new_api": null,
          "old_text": "sparse_handles.shape().dim_size(0)",
          "new_text": null,
          "old_line_content": "    int64 N = sparse_handles.shape().dim_size(0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": "OP_REQUIRES",
          "new_api": null,
          "old_text": "OP_REQUIRES(\n        context, N > 0,\n        errors::InvalidArgument(\"Must have at least 1 serialized SparseTensor, \"\n                                \"but input matrix has 0 rows\"))",
          "new_text": null,
          "old_line_content": "    OP_REQUIRES(",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 29,
      "total_additions": 57,
      "total_deletions": 57,
      "total_api_changes": 143
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 1,
        "api_related_lines": 143,
        "non_api_lines": 1,
        "non_api_line_numbers": [
          263
        ]
      }
    },
    "api_calls_before": 274,
    "api_calls_after": 274,
    "diff_info": {
      "added_lines": 1,
      "removed_lines": 0,
      "total_diff_lines": 13
    }
  }
}