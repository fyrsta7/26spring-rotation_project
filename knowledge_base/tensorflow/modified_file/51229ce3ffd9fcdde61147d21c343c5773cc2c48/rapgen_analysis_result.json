{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/51229ce3ffd9fcdde61147d21c343c5773cc2c48",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/51229ce3ffd9fcdde61147d21c343c5773cc2c48/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/51229ce3ffd9fcdde61147d21c343c5773cc2c48/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/51229ce3ffd9fcdde61147d21c343c5773cc2c48/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 3256,
          "old_api": "atoi",
          "new_api": "getenv",
          "old_text": "atoi(env)",
          "new_text": "getenv(\"VEC_STRIDE\")",
          "old_line_content": "    vec_stride = atoi(env);",
          "new_line_content": "  char* env = getenv(\"VEC_STRIDE\");",
          "content_same": false
        },
        {
          "line": 3291,
          "old_api": "to_apply",
          "new_api": "push_back",
          "old_text": "output_instruction->to_apply()",
          "new_text": "reduce_instructions.push_back(output_instruction)",
          "old_line_content": "    reducers.push_back(output_instruction->to_apply());",
          "new_line_content": "    reduce_instructions.push_back(output_instruction);",
          "content_same": false
        },
        {
          "line": 3293,
          "old_api": "TF_ASSIGN_OR_RETURN",
          "new_api": "push_back",
          "old_text": "TF_ASSIGN_OR_RETURN(std::unique_ptr<Thunk> initializer_thunk,\n                        BuildInitializerThunk(unnested_hlo, idx))",
          "new_text": "reduction_output_shape_indices.push_back(idx)",
          "old_line_content": "    TF_ASSIGN_OR_RETURN(std::unique_ptr<Thunk> initializer_thunk,",
          "new_line_content": "    reduction_output_shape_indices.push_back(idx);",
          "content_same": false
        },
        {
          "line": 3294,
          "old_api": "BuildInitializerThunk",
          "new_api": "to_apply",
          "old_text": "BuildInitializerThunk(unnested_hlo, idx)",
          "new_text": "output_instruction->to_apply()",
          "old_line_content": "                        BuildInitializerThunk(unnested_hlo, idx));",
          "new_line_content": "    reducers.push_back(output_instruction->to_apply());",
          "content_same": false
        },
        {
          "line": 3298,
          "old_api": "at",
          "new_api": "std::move(initializer_thunk)",
          "old_text": "reduce_instructions.at(0)",
          "new_text": "std::move(initializer_thunk)",
          "old_line_content": "  const HloInstruction* first_reduce = reduce_instructions.at(0);",
          "new_line_content": "    thunks.push_back(std::move(initializer_thunk));",
          "content_same": false
        },
        {
          "line": 3302,
          "old_api": "InternalError",
          "new_api": "size",
          "old_text": "InternalError(\"Inconsistent reduction fusion outputs\")",
          "new_text": "output_instructions.size()",
          "old_line_content": "      return InternalError(\"Inconsistent reduction fusion outputs\");",
          "new_line_content": "  if (output_instructions.size() > 1) {",
          "content_same": false
        },
        {
          "line": 3313,
          "old_api": "has_layout",
          "new_api": "operand",
          "old_text": "input_shape.has_layout()",
          "new_text": "first_reduce->operand(0)->shape()",
          "old_line_content": "  CHECK(input_shape.has_layout()) << \"LayoutAssignment or InstructionFusion \"",
          "new_line_content": "  const Shape& input_shape = first_reduce->operand(0)->shape();",
          "content_same": false
        },
        {
          "line": 3318,
          "old_api": "ComputeReductionCodegenInfo",
          "new_api": "ToString",
          "old_text": "ComputeReductionCodegenInfo(unnested_hlo, first_reduce)",
          "new_text": "first_reduce->ToString()",
          "old_line_content": "      ComputeReductionCodegenInfo(unnested_hlo, first_reduce);",
          "new_line_content": "                                  << first_reduce->ToString();",
          "content_same": false
        },
        {
          "line": 3321,
          "old_api": "GetNumberOfBlocks",
          "new_api": "ComputeReductionCodegenInfo",
          "old_text": "mapping_scheme.GetNumberOfBlocks()",
          "new_text": "ComputeReductionCodegenInfo(unnested_hlo, first_reduce)",
          "old_line_content": "  LaunchDimensions launch_dimensions(mapping_scheme.GetNumberOfBlocks(),",
          "new_line_content": "      ComputeReductionCodegenInfo(unnested_hlo, first_reduce);",
          "content_same": false
        },
        {
          "line": 3323,
          "old_api": "launch_bound",
          "new_api": "GetKernelMappingScheme",
          "old_text": "GetIndexTypeForKernel(\n      unnested_hlo, launch_dimensions.launch_bound(), &b_)",
          "new_text": "reduction_info.GetKernelMappingScheme()",
          "old_line_content": "  llvm::Type* index_ty = GetIndexTypeForKernel(",
          "new_line_content": "      reduction_info.GetKernelMappingScheme();",
          "content_same": false
        },
        {
          "line": 3324,
          "old_api": "launch_bound",
          "new_api": "GetNumberOfBlocks",
          "old_text": "launch_dimensions.launch_bound()",
          "new_text": "mapping_scheme.GetNumberOfBlocks()",
          "old_line_content": "      unnested_hlo, launch_dimensions.launch_bound(), &b_);",
          "new_line_content": "  LaunchDimensions launch_dimensions(mapping_scheme.GetNumberOfBlocks(),",
          "content_same": false
        },
        {
          "line": 3325,
          "old_api": "EmitPrologueForReduction",
          "new_api": "GetThreadsPerBlock",
          "old_text": "EmitPrologueForReduction(unnested_hlo, &reduction_info, reduce_instructions,\n                           index_ty)",
          "new_text": "mapping_scheme.GetThreadsPerBlock()",
          "old_line_content": "  EmitPrologueForReduction(unnested_hlo, &reduction_info, reduce_instructions,",
          "new_line_content": "                                     mapping_scheme.GetThreadsPerBlock());",
          "content_same": false
        },
        {
          "line": 3343,
          "old_api": "EmitEpilogueForReduction",
          "new_api": "GetKernelMappingScheme",
          "old_text": "EmitEpilogueForReduction(index_ty, unnested_hlo, reduction_info,\n                           reduce_instructions, reduction_output_shape_indices,\n                           reducers, tiling_kernel_info)",
          "new_text": "reduction_info.GetKernelMappingScheme()",
          "old_line_content": "  EmitEpilogueForReduction(index_ty, unnested_hlo, reduction_info,",
          "new_line_content": "        EmitTile(reduction_info.GetKernelMappingScheme(), index, loop_name, ksl,",
          "content_same": false
        },
        {
          "line": 3350,
          "old_api": "std::move(kernel_thunk)",
          "new_api": "get",
          "old_text": "std::move(kernel_thunk)",
          "new_text": "kernel_thunk.get()",
          "old_line_content": "  thunks.push_back(std::move(kernel_thunk));",
          "new_line_content": "  UpdateLaunchDimensions(launch_dimensions, kernel_thunk.get(),",
          "content_same": false
        },
        {
          "line": 3353,
          "old_api": "std::move(sequential_thunk)",
          "new_api": "std::move(kernel_thunk)",
          "old_text": "std::move(sequential_thunk)",
          "new_text": "std::move(kernel_thunk)",
          "old_line_content": "  AddThunkToThunkSequence(std::move(sequential_thunk));",
          "new_line_content": "  thunks.push_back(std::move(kernel_thunk));",
          "content_same": false
        },
        {
          "line": 3355,
          "old_api": "Status::OK()",
          "new_api": "std::move(thunks)",
          "old_text": "Status::OK()",
          "new_text": "std::move(thunks)",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "      absl::make_unique<SequentialThunk>(std::move(thunks), unnested_hlo);",
          "content_same": false
        },
        {
          "line": 3368,
          "old_api": "size",
          "new_api": "llvm_ir::LiteralForConstantAllocation(allocation)",
          "old_text": "allocation.size()",
          "new_text": "llvm_ir::LiteralForConstantAllocation(allocation)",
          "old_line_content": "        llvm::ArrayType::get(b_.getInt8Ty(), allocation.size());",
          "new_line_content": "    const Literal& literal = llvm_ir::LiteralForConstantAllocation(allocation);",
          "content_same": false
        },
        {
          "line": 3371,
          "old_api": "llvm_ir::ConvertLiteralToIrConstant(literal, module_)",
          "new_api": "size",
          "old_text": "llvm_ir::ConvertLiteralToIrConstant(literal, module_)",
          "new_text": "allocation.size()",
          "old_line_content": "            ? llvm_ir::ConvertLiteralToIrConstant(literal, module_)",
          "new_line_content": "        llvm::ArrayType::get(b_.getInt8Ty(), allocation.size());",
          "content_same": false
        },
        {
          "line": 3374,
          "old_api": "VLOG",
          "new_api": "llvm_ir::ConvertLiteralToIrConstant(literal, module_)",
          "old_text": "VLOG(3)",
          "new_text": "llvm_ir::ConvertLiteralToIrConstant(literal, module_)",
          "old_line_content": "      VLOG(3) << \"Emitted initializer for constant with shape \"",
          "new_line_content": "            ? llvm_ir::ConvertLiteralToIrConstant(literal, module_)",
          "content_same": false
        },
        {
          "line": 3375,
          "old_api": "shape",
          "new_api": "llvm::ConstantAggregateZero::get(global_type)",
          "old_text": "literal.shape()",
          "new_text": "llvm::ConstantAggregateZero::get(global_type)",
          "old_line_content": "              << ShapeUtil::HumanString(literal.shape());",
          "new_line_content": "            : llvm::ConstantAggregateZero::get(global_type);",
          "content_same": false
        },
        {
          "line": 3426,
          "old_api": "opcode",
          "new_api": "ToString",
          "old_text": "() -> absl::Span<HloInstruction* const> {\n    if (slice_or_tuple->opcode() == HloOpcode::kSlice) {\n      return absl::Span<HloInstruction* const>(&slice_or_tuple, 1);\n    }\n    CHECK_EQ(slice_or_tuple->opcode(), HloOpcode::kTuple);\n    return slice_or_tuple->operands();\n  }()",
          "new_text": "unnested_hlo->ToString()",
          "old_line_content": "  auto slice_instructions = [&]() -> absl::Span<HloInstruction* const> {",
          "new_line_content": "  VLOG(10) << \"Emitting slice input fusion for \" << unnested_hlo->ToString();",
          "content_same": false
        },
        {
          "line": 3428,
          "old_api": "absl::Span<HloInstruction* const>(&slice_or_tuple, 1)",
          "new_api": "fused_expression_root",
          "old_text": "absl::Span<HloInstruction* const>(&slice_or_tuple, 1)",
          "new_text": "unnested_hlo->fused_expression_root()",
          "old_line_content": "      return absl::Span<HloInstruction* const>(&slice_or_tuple, 1);",
          "new_line_content": "  HloInstruction* slice_or_tuple = unnested_hlo->fused_expression_root();",
          "content_same": false
        },
        {
          "line": 3431,
          "old_api": "operands",
          "new_api": "absl::Span<HloInstruction* const>(&slice_or_tuple, 1)",
          "old_text": "slice_or_tuple->operands()",
          "new_text": "absl::Span<HloInstruction* const>(&slice_or_tuple, 1)",
          "old_line_content": "    return slice_or_tuple->operands();",
          "new_line_content": "      return absl::Span<HloInstruction* const>(&slice_or_tuple, 1);",
          "content_same": false
        },
        {
          "line": 3440,
          "old_api": "fused_expression_root",
          "new_api": "GetNestedComputer",
          "old_text": "unnested_hlo->fused_expression_root()->Accept(&fused_emitter)",
          "new_text": "GetNestedComputer()",
          "old_line_content": "  TF_CHECK_OK(unnested_hlo->fused_expression_root()->Accept(&fused_emitter));",
          "new_line_content": "                                     GetNestedComputer());",
          "content_same": false
        },
        {
          "line": 3443,
          "old_api": "ValueOrDie",
          "new_api": "fused_expression_root",
          "old_text": "input_generator(index).ValueOrDie()",
          "new_text": "unnested_hlo->fused_expression_root()->Accept(&fused_emitter)",
          "old_line_content": "    input_ir_values.push_back(input_generator(index).ValueOrDie());",
          "new_line_content": "  TF_CHECK_OK(unnested_hlo->fused_expression_root()->Accept(&fused_emitter));",
          "content_same": false
        },
        {
          "line": 3456,
          "old_api": "multidim",
          "new_api": "size",
          "old_text": "index.multidim()",
          "new_text": "slice->slice_starts().size()",
          "old_line_content": "          index.multidim()[dim],",
          "new_line_content": "    for (size_t dim = 0; dim < slice->slice_starts().size(); ++dim) {",
          "content_same": false
        },
        {
          "line": 3457,
          "old_api": "slice_starts",
          "new_api": "slice_strides",
          "old_text": "slice->slice_starts(dim)",
          "new_text": "slice->slice_strides(dim)",
          "old_line_content": "          index.GetConstantWithIndexType(slice->slice_starts(dim)));",
          "new_line_content": "      CHECK_EQ(slice->slice_strides(dim), 1);",
          "content_same": false
        },
        {
          "line": 3458,
          "old_api": "CreateICmpSLT",
          "new_api": "CreateICmpSGE",
          "old_text": "b_.CreateICmpSLT(\n          index.multidim()[dim],\n          index.GetConstantWithIndexType(slice->slice_limits(dim)))",
          "new_text": "b_.CreateICmpSGE(\n          index.multidim()[dim],\n          index.GetConstantWithIndexType(slice->slice_starts(dim)))",
          "old_line_content": "      llvm::Value* smaller_than_limit = b_.CreateICmpSLT(",
          "new_line_content": "      auto larger_or_equal_than_start = b_.CreateICmpSGE(",
          "content_same": false
        },
        {
          "line": 3460,
          "old_api": "slice_limits",
          "new_api": "slice_starts",
          "old_text": "slice->slice_limits(dim)",
          "new_text": "slice->slice_starts(dim)",
          "old_line_content": "          index.GetConstantWithIndexType(slice->slice_limits(dim)));",
          "new_line_content": "          index.GetConstantWithIndexType(slice->slice_starts(dim)));",
          "content_same": false
        },
        {
          "line": 3462,
          "old_api": "CreateAnd",
          "new_api": "multidim",
          "old_text": "b_.CreateAnd(larger_or_equal_than_start, smaller_than_limit)",
          "new_text": "index.multidim()",
          "old_line_content": "          b_.CreateAnd(larger_or_equal_than_start, smaller_than_limit);",
          "new_line_content": "          index.multidim()[dim],",
          "content_same": false
        },
        {
          "line": 3463,
          "old_api": "push_back",
          "new_api": "slice_limits",
          "old_text": "index_within_ranges.push_back(within_range)",
          "new_text": "slice->slice_limits(dim)",
          "old_line_content": "      index_within_ranges.push_back(within_range);",
          "new_line_content": "          index.GetConstantWithIndexType(slice->slice_limits(dim)));",
          "content_same": false
        },
        {
          "line": 3468,
          "old_api": "multidim",
          "new_api": "CreateAnd",
          "old_text": "index.multidim()",
          "new_text": "b_.CreateAnd(index_within_ranges)",
          "old_line_content": "      const std::vector<llvm::Value*>& src_multidim = index.multidim();",
          "new_line_content": "    llvm::Value* guarding_cond = b_.CreateAnd(index_within_ranges);",
          "content_same": false
        },
        {
          "line": 3472,
          "old_api": "GetConstantWithIndexType",
          "new_api": "size",
          "old_text": "Sub(src_multidim[dim],\n                index.GetConstantWithIndexType(slice->slice_starts(dim)))",
          "new_text": "src_multidim.size()",
          "old_line_content": "            Sub(src_multidim[dim],",
          "new_line_content": "      std::vector<llvm::Value*> dst_multidim(src_multidim.size());",
          "content_same": false
        },
        {
          "line": 3473,
          "old_api": "slice_starts",
          "new_api": "size",
          "old_text": "slice->slice_starts(dim)",
          "new_text": "src_multidim.size()",
          "old_line_content": "                index.GetConstantWithIndexType(slice->slice_starts(dim)));",
          "new_line_content": "      for (size_t dim = 0; dim < src_multidim.size(); ++dim) {",
          "content_same": false
        },
        {
          "line": 3475,
          "old_api": "opcode",
          "new_api": "GetConstantWithIndexType",
          "old_text": "slice_or_tuple->opcode()",
          "new_text": "Sub(src_multidim[dim],\n                index.GetConstantWithIndexType(slice->slice_starts(dim)))",
          "old_line_content": "      ShapeIndex shape_index = (slice_or_tuple->opcode() == HloOpcode::kSlice)",
          "new_line_content": "            Sub(src_multidim[dim],",
          "content_same": false
        },
        {
          "line": 3476,
          "old_api": "ShapeIndex",
          "new_api": "slice_starts",
          "old_text": "ShapeIndex()",
          "new_text": "slice->slice_starts(dim)",
          "old_line_content": "                                   ? ShapeIndex()",
          "new_line_content": "                index.GetConstantWithIndexType(slice->slice_starts(dim)));",
          "content_same": false
        },
        {
          "line": 3479,
          "old_api": "GetIrArray",
          "new_api": "ShapeIndex",
          "old_text": "GetIrArray(*unnested_hlo, *unnested_hlo, shape_index)",
          "new_text": "ShapeIndex()",
          "old_line_content": "          GetIrArray(*unnested_hlo, *unnested_hlo, shape_index);",
          "new_line_content": "                                   ? ShapeIndex()",
          "content_same": false
        },
        {
          "line": 3480,
          "old_api": "shape",
          "new_api": "ShapeIndex",
          "old_text": "slice->shape()",
          "new_text": "ShapeIndex({i})",
          "old_line_content": "      IrArray::Index slice_dst_index(dst_multidim, slice->shape(),",
          "new_line_content": "                                   : ShapeIndex({i});",
          "content_same": false
        },
        {
          "line": 3482,
          "old_api": "EmitArrayElementAddress",
          "new_api": "GetIrArray",
          "old_text": "src_ir_array.EmitArrayElementAddress(\n          slice_dst_index, &b_, \"slice.dest\")",
          "new_text": "GetIrArray(*unnested_hlo, *unnested_hlo, shape_index)",
          "old_line_content": "      llvm::Value* dst_addr = src_ir_array.EmitArrayElementAddress(",
          "new_line_content": "          GetIrArray(*unnested_hlo, *unnested_hlo, shape_index);",
          "content_same": false
        },
        {
          "line": 3484,
          "old_api": "CreateStore",
          "new_api": "GetType",
          "old_text": "b_.CreateStore(input_ir_values[i], dst_addr)",
          "new_text": "index.GetType()",
          "old_line_content": "      b_.CreateStore(input_ir_values[i], dst_addr);",
          "new_line_content": "                                     index.GetType());",
          "content_same": false
        },
        {
          "line": 3487,
          "old_api": "StrCat",
          "new_api": "CreateStore",
          "old_text": "StrCat(\"slice\", i)",
          "new_text": "b_.CreateStore(input_ir_values[i], dst_addr)",
          "old_line_content": "    ksl.If(StrCat(\"slice\", i), guarding_cond, emit_slice_elem_func);",
          "new_line_content": "      b_.CreateStore(input_ir_values[i], dst_addr);",
          "content_same": false
        },
        {
          "line": 3502,
          "old_api": "llvm_module",
          "new_api": "device_description",
          "old_text": "ir_emitter_context_->llvm_module()",
          "new_text": "CalculateLaunchDimensions(\n      element_shape, ir_emitter_context_->device_description(), unroll_factor)",
          "old_line_content": "                         ir_emitter_context_->llvm_module());",
          "new_line_content": "  LaunchDimensions launch_dimensions = CalculateLaunchDimensions(",
          "content_same": false
        },
        {
          "line": 3505,
          "old_api": "EmitLoop",
          "new_api": "llvm_module",
          "old_text": "ParallelLoopEmitter(\n          [&](const llvm_ir::IrArray::Index index) -> Status {\n            EmitElementForInputFusibleSlices(unnested_hlo, index);\n            return Status::OK();\n          },\n          element_shape, launch_dimensions, &b_)\n          .EmitLoop(IrName(unnested_hlo),\n                    GetIndexTypeForKernel(\n                        unnested_hlo, launch_dimensions.launch_bound(), &b_))",
          "new_text": "ir_emitter_context_->llvm_module()",
          "old_line_content": "      ParallelLoopEmitter(",
          "new_line_content": "                         ir_emitter_context_->llvm_module());",
          "content_same": false
        },
        {
          "line": 3508,
          "old_api": "Status::OK()",
          "new_api": "EmitLoop",
          "old_text": "Status::OK()",
          "new_text": "ParallelLoopEmitter(\n          [&](const llvm_ir::IrArray::Index index) -> Status {\n            EmitElementForInputFusibleSlices(unnested_hlo, index);\n            return Status::OK();\n          },\n          element_shape, launch_dimensions, &b_)\n          .EmitLoop(IrName(unnested_hlo),\n                    GetIndexTypeForKernel(\n                        unnested_hlo, launch_dimensions.launch_bound(), &b_))",
          "old_line_content": "            return Status::OK();",
          "new_line_content": "      ParallelLoopEmitter(",
          "content_same": false
        },
        {
          "line": 3511,
          "old_api": "IrName",
          "new_api": "Status::OK()",
          "old_text": "IrName(unnested_hlo)",
          "new_text": "Status::OK()",
          "old_line_content": "          .EmitLoop(IrName(unnested_hlo),",
          "new_line_content": "            return Status::OK();",
          "content_same": false
        },
        {
          "line": 3515,
          "old_api": "std::move(kernel_thunk)",
          "new_api": "launch_bound",
          "old_text": "std::move(kernel_thunk)",
          "new_text": "GetIndexTypeForKernel(\n                        unnested_hlo, launch_dimensions.launch_bound(), &b_)",
          "old_line_content": "  thunk_sequence_->emplace_back(std::move(kernel_thunk));",
          "new_line_content": "                    GetIndexTypeForKernel(",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 3328,
          "old_api": null,
          "new_api": "EmitPrologueForReduction",
          "old_text": null,
          "new_text": "EmitPrologueForReduction(unnested_hlo, &reduction_info, reduce_instructions,\n                           index_ty)",
          "old_line_content": "      [&](const llvm_ir::IrArray::Index& index, llvm::Value* y_loc,",
          "new_line_content": "  EmitPrologueForReduction(unnested_hlo, &reduction_info, reduce_instructions,",
          "content_same": false
        },
        {
          "line": 3333,
          "old_api": null,
          "new_api": "EmitTileElementForReduction",
          "old_text": null,
          "new_text": "EmitTileElementForReduction(unnested_hlo, input_shape,\n                                    output_instructions, index, reduction_info,\n                                    reducers, x_iter_num)",
          "old_line_content": "      };",
          "new_line_content": "        EmitTileElementForReduction(unnested_hlo, input_shape,",
          "content_same": false
        },
        {
          "line": 3461,
          "old_api": null,
          "new_api": "CreateICmpSLT",
          "old_text": null,
          "new_text": "b_.CreateICmpSLT(\n          index.multidim()[dim],\n          index.GetConstantWithIndexType(slice->slice_limits(dim)))",
          "old_line_content": "      llvm::Value* within_range =",
          "new_line_content": "      llvm::Value* smaller_than_limit = b_.CreateICmpSLT(",
          "content_same": false
        },
        {
          "line": 3338,
          "old_api": null,
          "new_api": "GetKernelMappingScheme",
          "old_text": null,
          "new_text": "EmitTilingKernel(\n      mapping_scheme, index_ty,\n      [&](const ThreadIdInfo& thread_id_info, const IrArray::Index& index,\n          const string& loop_name, llvm::Value* tile_height,\n          llvm::Value* tile_width, KernelSupportLibrary* ksl) {\n        EmitTile(reduction_info.GetKernelMappingScheme(), index, loop_name, ksl,\n                 thread_id_info, tile_height, tile_width, emit_reduction_tile);\n      })",
          "old_line_content": "          const string& loop_name, llvm::Value* tile_height,",
          "new_line_content": "  TilingKernelInfo tiling_kernel_info = EmitTilingKernel(",
          "content_same": false
        },
        {
          "line": 3466,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "index_within_ranges.push_back(within_range)",
          "old_line_content": "",
          "new_line_content": "      index_within_ranges.push_back(within_range);",
          "content_same": false
        },
        {
          "line": 3471,
          "old_api": null,
          "new_api": "multidim",
          "old_text": null,
          "new_text": "index.multidim()",
          "old_line_content": "        dst_multidim[dim] =",
          "new_line_content": "      const std::vector<llvm::Value*>& src_multidim = index.multidim();",
          "content_same": false
        },
        {
          "line": 3346,
          "old_api": null,
          "new_api": "EmitEpilogueForReduction",
          "old_text": null,
          "new_text": "EmitEpilogueForReduction(index_ty, unnested_hlo, reduction_info,\n                           reduce_instructions, reduction_output_shape_indices,\n                           reducers, tiling_kernel_info)",
          "old_line_content": "",
          "new_line_content": "  EmitEpilogueForReduction(index_ty, unnested_hlo, reduction_info,",
          "content_same": false
        },
        {
          "line": 3478,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "slice_or_tuple->opcode()",
          "old_line_content": "      llvm_ir::IrArray src_ir_array =",
          "new_line_content": "      ShapeIndex shape_index = (slice_or_tuple->opcode() == HloOpcode::kSlice)",
          "content_same": false
        },
        {
          "line": 3351,
          "old_api": null,
          "new_api": "llvm_module",
          "old_text": null,
          "new_text": "ir_emitter_context_->llvm_module()",
          "old_line_content": "  auto sequential_thunk =",
          "new_line_content": "                         ir_emitter_context_->llvm_module());",
          "content_same": false
        },
        {
          "line": 3483,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "slice->shape()",
          "old_line_content": "          slice_dst_index, &b_, \"slice.dest\");",
          "new_line_content": "      IrArray::Index slice_dst_index(dst_multidim, slice->shape(),",
          "content_same": false
        },
        {
          "line": 3356,
          "old_api": null,
          "new_api": "std::move(sequential_thunk)",
          "old_text": null,
          "new_text": "std::move(sequential_thunk)",
          "old_line_content": "}",
          "new_line_content": "  AddThunkToThunkSequence(std::move(sequential_thunk));",
          "content_same": false
        },
        {
          "line": 3485,
          "old_api": null,
          "new_api": "EmitArrayElementAddress",
          "old_text": null,
          "new_text": "src_ir_array.EmitArrayElementAddress(\n          slice_dst_index, &b_, \"slice.dest\")",
          "old_line_content": "    };",
          "new_line_content": "      llvm::Value* dst_addr = src_ir_array.EmitArrayElementAddress(",
          "content_same": false
        },
        {
          "line": 3358,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "Status IrEmitterUnnested::EmitConstantGlobals() {",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3490,
          "old_api": null,
          "new_api": "StrCat",
          "old_text": null,
          "new_text": "StrCat(\"slice\", i)",
          "old_line_content": "",
          "new_line_content": "    ksl.If(StrCat(\"slice\", i), guarding_cond, emit_slice_elem_func);",
          "content_same": false
        },
        {
          "line": 3363,
          "old_api": null,
          "new_api": "Allocations",
          "old_text": null,
          "new_text": "ir_emitter_context_->buffer_assignment().Allocations()",
          "old_line_content": "    }",
          "new_line_content": "       ir_emitter_context_->buffer_assignment().Allocations()) {",
          "content_same": false
        },
        {
          "line": 3364,
          "old_api": null,
          "new_api": "is_constant",
          "old_text": null,
          "new_text": "allocation.is_constant()",
          "old_line_content": "",
          "new_line_content": "    if (!allocation.is_constant()) {",
          "content_same": false
        },
        {
          "line": 3496,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "",
          "new_line_content": "  constexpr int unroll_factor = 1;",
          "content_same": false
        },
        {
          "line": 3369,
          "old_api": null,
          "new_api": "ShouldEmitLiteralInLlvmIr",
          "old_text": null,
          "new_text": "ShouldEmitLiteralInLlvmIr(literal)",
          "old_line_content": "    llvm::Constant* initializer =",
          "new_line_content": "    const bool should_emit_initializer = ShouldEmitLiteralInLlvmIr(literal);",
          "content_same": false
        },
        {
          "line": 3497,
          "old_api": null,
          "new_api": "BuildKernelThunk",
          "old_text": null,
          "new_text": "BuildKernelThunk(\n      unnested_hlo, /*implements_whole_instruction=*/true, unroll_factor)",
          "old_line_content": "  TF_ASSIGN_OR_RETURN(Shape element_shape,",
          "new_line_content": "  std::unique_ptr<KernelThunk> kernel_thunk = BuildKernelThunk(",
          "content_same": false
        },
        {
          "line": 3503,
          "old_api": null,
          "new_api": "device_description",
          "old_text": null,
          "new_text": "ir_emitter_context_->device_description()",
          "old_line_content": "",
          "new_line_content": "      element_shape, ir_emitter_context_->device_description(), unroll_factor);",
          "content_same": false
        },
        {
          "line": 3504,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "kernel_thunk.get()",
          "old_line_content": "  Status emit_status =",
          "new_line_content": "  UpdateLaunchDimensions(launch_dimensions, kernel_thunk.get(),",
          "content_same": false
        },
        {
          "line": 3377,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "",
          "new_line_content": "      VLOG(3) << \"Emitted initializer for constant with shape \"",
          "content_same": false
        },
        {
          "line": 3378,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "literal.shape()",
          "old_line_content": "    // These globals will be looked up by name by GpuExecutable so we need to",
          "new_line_content": "              << ShapeUtil::HumanString(literal.shape());",
          "content_same": false
        },
        {
          "line": 3510,
          "old_api": null,
          "new_api": "EmitElementForInputFusibleSlices",
          "old_text": null,
          "new_text": "EmitElementForInputFusibleSlices(unnested_hlo, index)",
          "old_line_content": "          element_shape, launch_dimensions, &b_)",
          "new_line_content": "            EmitElementForInputFusibleSlices(unnested_hlo, index);",
          "content_same": false
        },
        {
          "line": 3514,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(unnested_hlo)",
          "old_line_content": "",
          "new_line_content": "          .EmitLoop(IrName(unnested_hlo),",
          "content_same": false
        },
        {
          "line": 3516,
          "old_api": null,
          "new_api": "launch_bound",
          "old_text": null,
          "new_text": "launch_dimensions.launch_bound()",
          "old_line_content": "",
          "new_line_content": "                        unnested_hlo, launch_dimensions.launch_bound(), &b_));",
          "content_same": false
        },
        {
          "line": 3389,
          "old_api": null,
          "new_api": "llvm_module",
          "old_text": null,
          "new_text": "llvm_ir::GetGlobalMemoryAddressSpace(\n        *ir_emitter_context_->llvm_module())",
          "old_line_content": "        global_type, /*isConstant=*/should_emit_initializer,",
          "new_line_content": "    unsigned global_address_space = llvm_ir::GetGlobalMemoryAddressSpace(",
          "content_same": false
        },
        {
          "line": 3262,
          "old_api": null,
          "new_api": "atoi",
          "old_text": null,
          "new_text": "atoi(env)",
          "old_line_content": "      {reduction_tiling[0], reduction_tiling[1] * num_threads_y,",
          "new_line_content": "    vec_stride = atoi(env);",
          "content_same": false
        },
        {
          "line": 3390,
          "old_api": null,
          "new_api": "llvm_module",
          "old_text": null,
          "new_text": "ir_emitter_context_->llvm_module()",
          "old_line_content": "        llvm::GlobalValue::ExternalLinkage,",
          "new_line_content": "        *ir_emitter_context_->llvm_module());",
          "content_same": false
        },
        {
          "line": 3518,
          "old_api": null,
          "new_api": "std::move(kernel_thunk)",
          "old_text": null,
          "new_text": "std::move(kernel_thunk)",
          "old_line_content": "}",
          "new_line_content": "  thunk_sequence_->emplace_back(std::move(kernel_thunk));",
          "content_same": false
        },
        {
          "line": 3395,
          "old_api": null,
          "new_api": "llvm_ir::ConstantBufferAllocationToGlobalName(allocation)",
          "old_text": null,
          "new_text": "llvm_ir::ConstantBufferAllocationToGlobalName(allocation)",
          "old_line_content": "        /*isExternallyInitialized=*/false);",
          "new_line_content": "        llvm_ir::ConstantBufferAllocationToGlobalName(allocation),",
          "content_same": false
        },
        {
          "line": 3269,
          "old_api": null,
          "new_api": "ReductionCodegenInfo",
          "old_text": null,
          "new_text": "ReductionCodegenInfo(mapping_scheme,\n                              reduction_dimensions.is_row_reduction)",
          "old_line_content": "",
          "new_line_content": "  return ReductionCodegenInfo(mapping_scheme,",
          "content_same": false
        },
        {
          "line": 3399,
          "old_api": null,
          "new_api": "setAlignment",
          "old_text": null,
          "new_text": "global_for_const->setAlignment(kConstantBufferAlignBytes)",
          "old_line_content": "  }",
          "new_line_content": "    global_for_const->setAlignment(kConstantBufferAlignBytes);",
          "content_same": false
        },
        {
          "line": 3400,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "ir_emitter_context_->llvm_module()->getGlobalList().push_back(\n        global_for_const)",
          "old_line_content": "",
          "new_line_content": "    ir_emitter_context_->llvm_module()->getGlobalList().push_back(",
          "content_same": false
        },
        {
          "line": 3276,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "output_instructions.size()",
          "old_line_content": "  std::vector<HloInstruction*> reduce_instructions;",
          "new_line_content": "  bool returns_tuple = output_instructions.size() > 1;",
          "content_same": false
        },
        {
          "line": 3277,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "unnested_hlo->ToString()",
          "old_line_content": "  InlinedVector<ShapeIndex, 1> reduction_output_shape_indices;",
          "new_line_content": "  VLOG(10) << \"Emitting reduction to vector \" << unnested_hlo->ToString();",
          "content_same": false
        },
        {
          "line": 3404,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "// Emits code for slices based on the below structure. An if statement with",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3285,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "output_instructions.size()",
          "old_line_content": "    }",
          "new_line_content": "  for (int i = 0; i < output_instructions.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 3286,
          "old_api": null,
          "new_api": "IsReductionFromOrToContiguousDimensions",
          "old_text": null,
          "new_text": "IsReductionFromOrToContiguousDimensions(*output_instructions[i])",
          "old_line_content": "",
          "new_line_content": "    if (!IsReductionFromOrToContiguousDimensions(*output_instructions[i])) {",
          "content_same": false
        },
        {
          "line": 3292,
          "old_api": null,
          "new_api": "ShapeIndex",
          "old_text": null,
          "new_text": "ShapeIndex({})",
          "old_line_content": "",
          "new_line_content": "    ShapeIndex idx = returns_tuple ? ShapeIndex({i}) : ShapeIndex({});",
          "content_same": false
        },
        {
          "line": 3296,
          "old_api": null,
          "new_api": "TF_ASSIGN_OR_RETURN",
          "old_text": null,
          "new_text": "TF_ASSIGN_OR_RETURN(std::unique_ptr<Thunk> initializer_thunk,\n                        BuildInitializerThunk(unnested_hlo, idx))",
          "old_line_content": "  }",
          "new_line_content": "    TF_ASSIGN_OR_RETURN(std::unique_ptr<Thunk> initializer_thunk,",
          "content_same": false
        },
        {
          "line": 3297,
          "old_api": null,
          "new_api": "BuildInitializerThunk",
          "old_text": null,
          "new_text": "BuildInitializerThunk(unnested_hlo, idx)",
          "old_line_content": "",
          "new_line_content": "                        BuildInitializerThunk(unnested_hlo, idx));",
          "content_same": false
        },
        {
          "line": 3301,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "reduce_instructions.at(0)",
          "old_line_content": "                                            first_reduce)) {",
          "new_line_content": "  const HloInstruction* first_reduce = reduce_instructions.at(0);",
          "content_same": false
        },
        {
          "line": 3429,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "() -> absl::Span<HloInstruction* const> {\n    if (slice_or_tuple->opcode() == HloOpcode::kSlice) {\n      return absl::Span<HloInstruction* const>(&slice_or_tuple, 1);\n    }\n    CHECK_EQ(slice_or_tuple->opcode(), HloOpcode::kTuple);\n    return slice_or_tuple->operands();\n  }()",
          "old_line_content": "    }",
          "new_line_content": "  auto slice_instructions = [&]() -> absl::Span<HloInstruction* const> {",
          "content_same": false
        },
        {
          "line": 3303,
          "old_api": null,
          "new_api": "AreFusedReductionOutputsConsistent",
          "old_text": null,
          "new_text": "AreFusedReductionOutputsConsistent(output_instructions,\n                                            first_reduce)",
          "old_line_content": "    }",
          "new_line_content": "    if (!AreFusedReductionOutputsConsistent(output_instructions,",
          "content_same": false
        },
        {
          "line": 3305,
          "old_api": null,
          "new_api": "InternalError",
          "old_text": null,
          "new_text": "InternalError(\"Inconsistent reduction fusion outputs\")",
          "old_line_content": "",
          "new_line_content": "      return InternalError(\"Inconsistent reduction fusion outputs\");",
          "content_same": false
        },
        {
          "line": 3433,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "slice_or_tuple->opcode()",
          "old_line_content": "",
          "new_line_content": "    CHECK_EQ(slice_or_tuple->opcode(), HloOpcode::kTuple);",
          "content_same": false
        },
        {
          "line": 3434,
          "old_api": null,
          "new_api": "operands",
          "old_text": null,
          "new_text": "slice_or_tuple->operands()",
          "old_line_content": "  // Emit input operand values of slices.",
          "new_line_content": "    return slice_or_tuple->operands();",
          "content_same": false
        },
        {
          "line": 3311,
          "old_api": null,
          "new_api": "BuildKernelThunk",
          "old_text": null,
          "new_text": "BuildKernelThunk(unnested_hlo, /*implements_whole_instruction=*/false)",
          "old_line_content": "  // The layout of a reduction input is either set by LayoutAssignment for",
          "new_line_content": "      BuildKernelThunk(unnested_hlo, /*implements_whole_instruction=*/false);",
          "content_same": false
        },
        {
          "line": 3441,
          "old_api": null,
          "new_api": "GetGeneratorForOperandIrArrays",
          "old_text": null,
          "new_text": "GetGeneratorForOperandIrArrays(unnested_hlo)",
          "old_line_content": "  for (const HloInstruction* slice : slice_instructions) {",
          "new_line_content": "  FusedIrEmitter fused_emitter(GetGeneratorForOperandIrArrays(unnested_hlo),",
          "content_same": false
        },
        {
          "line": 3316,
          "old_api": null,
          "new_api": "has_layout",
          "old_text": null,
          "new_text": "input_shape.has_layout()",
          "old_line_content": "",
          "new_line_content": "  CHECK(input_shape.has_layout()) << \"LayoutAssignment or InstructionFusion \"",
          "content_same": false
        },
        {
          "line": 3445,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "slice->operand(0)",
          "old_line_content": "",
          "new_line_content": "    auto input_generator = fused_emitter.GetGenerator(slice->operand(0));",
          "content_same": false
        },
        {
          "line": 3446,
          "old_api": null,
          "new_api": "ValueOrDie",
          "old_text": null,
          "new_text": "input_generator(index).ValueOrDie()",
          "old_line_content": "  // Emit for slice_instructions.",
          "new_line_content": "    input_ir_values.push_back(input_generator(index).ValueOrDie());",
          "content_same": false
        },
        {
          "line": 3451,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "slice_instructions.size()",
          "old_line_content": "    // guarding_cond := index >= start && index < limit, for each dim.",
          "new_line_content": "  for (int64 i = 0; i < slice_instructions.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 3326,
          "old_api": null,
          "new_api": "launch_bound",
          "old_text": null,
          "new_text": "GetIndexTypeForKernel(\n      unnested_hlo, launch_dimensions.launch_bound(), &b_)",
          "old_line_content": "                           index_ty);",
          "new_line_content": "  llvm::Type* index_ty = GetIndexTypeForKernel(",
          "content_same": false
        },
        {
          "line": 3327,
          "old_api": null,
          "new_api": "launch_bound",
          "old_text": null,
          "new_text": "launch_dimensions.launch_bound()",
          "old_line_content": "  EmitElementFunction emit_reduction_tile =",
          "new_line_content": "      unnested_hlo, launch_dimensions.launch_bound(), &b_);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 3330,
          "old_api": "EmitTileElementForReduction",
          "new_api": null,
          "old_text": "EmitTileElementForReduction(unnested_hlo, input_shape,\n                                    output_instructions, index, reduction_info,\n                                    reducers, x_iter_num)",
          "new_text": null,
          "old_line_content": "        EmitTileElementForReduction(unnested_hlo, input_shape,",
          "new_line_content": "  EmitElementFunction emit_reduction_tile =",
          "content_same": false
        },
        {
          "line": 3335,
          "old_api": "GetKernelMappingScheme",
          "new_api": null,
          "old_text": "EmitTilingKernel(\n      mapping_scheme, index_ty,\n      [&](const ThreadIdInfo& thread_id_info, const IrArray::Index& index,\n          const string& loop_name, llvm::Value* tile_height,\n          llvm::Value* tile_width, KernelSupportLibrary* ksl) {\n        EmitTile(reduction_info.GetKernelMappingScheme(), index, loop_name, ksl,\n                 thread_id_info, tile_height, tile_width, emit_reduction_tile);\n      })",
          "new_text": null,
          "old_line_content": "  TilingKernelInfo tiling_kernel_info = EmitTilingKernel(",
          "new_line_content": "                                    reducers, x_iter_num);",
          "content_same": false
        },
        {
          "line": 3340,
          "old_api": "GetKernelMappingScheme",
          "new_api": null,
          "old_text": "reduction_info.GetKernelMappingScheme()",
          "new_text": null,
          "old_line_content": "        EmitTile(reduction_info.GetKernelMappingScheme(), index, loop_name, ksl,",
          "new_line_content": "      [&](const ThreadIdInfo& thread_id_info, const IrArray::Index& index,",
          "content_same": false
        },
        {
          "line": 3469,
          "old_api": "size",
          "new_api": null,
          "old_text": "src_multidim.size()",
          "new_text": null,
          "old_line_content": "      std::vector<llvm::Value*> dst_multidim(src_multidim.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3470,
          "old_api": "size",
          "new_api": null,
          "old_text": "src_multidim.size()",
          "new_text": null,
          "old_line_content": "      for (size_t dim = 0; dim < src_multidim.size(); ++dim) {",
          "new_line_content": "    auto emit_slice_elem_func = [&] {",
          "content_same": false
        },
        {
          "line": 3347,
          "old_api": "get",
          "new_api": null,
          "old_text": "kernel_thunk.get()",
          "new_text": null,
          "old_line_content": "  UpdateLaunchDimensions(launch_dimensions, kernel_thunk.get(),",
          "new_line_content": "                           reduce_instructions, reduction_output_shape_indices,",
          "content_same": false
        },
        {
          "line": 3348,
          "old_api": "llvm_module",
          "new_api": null,
          "old_text": "ir_emitter_context_->llvm_module()",
          "new_text": null,
          "old_line_content": "                         ir_emitter_context_->llvm_module());",
          "new_line_content": "                           reducers, tiling_kernel_info);",
          "content_same": false
        },
        {
          "line": 3477,
          "old_api": "ShapeIndex",
          "new_api": null,
          "old_text": "ShapeIndex({i})",
          "new_text": null,
          "old_line_content": "                                   : ShapeIndex({i});",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3352,
          "old_api": "std::move(thunks)",
          "new_api": null,
          "old_text": "std::move(thunks)",
          "new_text": null,
          "old_line_content": "      absl::make_unique<SequentialThunk>(std::move(thunks), unnested_hlo);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3481,
          "old_api": "GetType",
          "new_api": null,
          "old_text": "index.GetType()",
          "new_text": null,
          "old_line_content": "                                     index.GetType());",
          "new_line_content": "      llvm_ir::IrArray src_ir_array =",
          "content_same": false
        },
        {
          "line": 3360,
          "old_api": "Allocations",
          "new_api": null,
          "old_text": "ir_emitter_context_->buffer_assignment().Allocations()",
          "new_text": null,
          "old_line_content": "       ir_emitter_context_->buffer_assignment().Allocations()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3361,
          "old_api": "is_constant",
          "new_api": null,
          "old_text": "allocation.is_constant()",
          "new_text": null,
          "old_line_content": "    if (!allocation.is_constant()) {",
          "new_line_content": "Status IrEmitterUnnested::EmitConstantGlobals() {",
          "content_same": false
        },
        {
          "line": 3365,
          "old_api": "llvm_ir::LiteralForConstantAllocation(allocation)",
          "new_api": null,
          "old_text": "llvm_ir::LiteralForConstantAllocation(allocation)",
          "new_text": null,
          "old_line_content": "    const Literal& literal = llvm_ir::LiteralForConstantAllocation(allocation);",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 3366,
          "old_api": "ShouldEmitLiteralInLlvmIr",
          "new_api": null,
          "old_text": "ShouldEmitLiteralInLlvmIr(literal)",
          "new_text": null,
          "old_line_content": "    const bool should_emit_initializer = ShouldEmitLiteralInLlvmIr(literal);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3493,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "  constexpr int unroll_factor = 1;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3494,
          "old_api": "BuildKernelThunk",
          "new_api": null,
          "old_text": "BuildKernelThunk(\n      unnested_hlo, /*implements_whole_instruction=*/true, unroll_factor)",
          "new_text": null,
          "old_line_content": "  std::unique_ptr<KernelThunk> kernel_thunk = BuildKernelThunk(",
          "new_line_content": "Status IrEmitterUnnested::EmitInputFusibleNonStridedSlices(",
          "content_same": false
        },
        {
          "line": 3499,
          "old_api": "device_description",
          "new_api": null,
          "old_text": "CalculateLaunchDimensions(\n      element_shape, ir_emitter_context_->device_description(), unroll_factor)",
          "new_text": null,
          "old_line_content": "  LaunchDimensions launch_dimensions = CalculateLaunchDimensions(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3372,
          "old_api": "llvm::ConstantAggregateZero::get(global_type)",
          "new_api": null,
          "old_text": "llvm::ConstantAggregateZero::get(global_type)",
          "new_text": null,
          "old_line_content": "            : llvm::ConstantAggregateZero::get(global_type);",
          "new_line_content": "    llvm::Constant* initializer =",
          "content_same": false
        },
        {
          "line": 3500,
          "old_api": "device_description",
          "new_api": null,
          "old_text": "ir_emitter_context_->device_description()",
          "new_text": null,
          "old_line_content": "      element_shape, ir_emitter_context_->device_description(), unroll_factor);",
          "new_line_content": "  TF_ASSIGN_OR_RETURN(Shape element_shape,",
          "content_same": false
        },
        {
          "line": 3501,
          "old_api": "get",
          "new_api": null,
          "old_text": "kernel_thunk.get()",
          "new_text": null,
          "old_line_content": "  UpdateLaunchDimensions(launch_dimensions, kernel_thunk.get(),",
          "new_line_content": "                      GetConsistentInputShapeForRootSlices(*unnested_hlo));",
          "content_same": false
        },
        {
          "line": 3507,
          "old_api": "EmitElementForInputFusibleSlices",
          "new_api": null,
          "old_text": "EmitElementForInputFusibleSlices(unnested_hlo, index)",
          "new_text": null,
          "old_line_content": "            EmitElementForInputFusibleSlices(unnested_hlo, index);",
          "new_line_content": "  Status emit_status =",
          "content_same": false
        },
        {
          "line": 3254,
          "old_api": "getenv",
          "new_api": null,
          "old_text": "getenv(\"VEC_STRIDE\")",
          "new_text": null,
          "old_line_content": "  char* env = getenv(\"VEC_STRIDE\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3512,
          "old_api": "launch_bound",
          "new_api": null,
          "old_text": "GetIndexTypeForKernel(\n                        unnested_hlo, launch_dimensions.launch_bound(), &b_)",
          "new_text": null,
          "old_line_content": "                    GetIndexTypeForKernel(",
          "new_line_content": "          },",
          "content_same": false
        },
        {
          "line": 3513,
          "old_api": "launch_bound",
          "new_api": null,
          "old_text": "launch_dimensions.launch_bound()",
          "new_text": null,
          "old_line_content": "                        unnested_hlo, launch_dimensions.launch_bound(), &b_));",
          "new_line_content": "          element_shape, launch_dimensions, &b_)",
          "content_same": false
        },
        {
          "line": 3386,
          "old_api": "llvm_module",
          "new_api": null,
          "old_text": "llvm_ir::GetGlobalMemoryAddressSpace(\n        *ir_emitter_context_->llvm_module())",
          "new_text": null,
          "old_line_content": "    unsigned global_address_space = llvm_ir::GetGlobalMemoryAddressSpace(",
          "new_line_content": "    //",
          "content_same": false
        },
        {
          "line": 3387,
          "old_api": "llvm_module",
          "new_api": null,
          "old_text": "ir_emitter_context_->llvm_module()",
          "new_text": null,
          "old_line_content": "        *ir_emitter_context_->llvm_module());",
          "new_line_content": "    // We may have to be more more clever here in the future if we notice that",
          "content_same": false
        },
        {
          "line": 3392,
          "old_api": "llvm_ir::ConstantBufferAllocationToGlobalName(allocation)",
          "new_api": null,
          "old_text": "llvm_ir::ConstantBufferAllocationToGlobalName(allocation)",
          "new_text": null,
          "old_line_content": "        llvm_ir::ConstantBufferAllocationToGlobalName(allocation),",
          "new_line_content": "        global_type, /*isConstant=*/should_emit_initializer,",
          "content_same": false
        },
        {
          "line": 3266,
          "old_api": "ReductionCodegenInfo",
          "new_api": null,
          "old_text": "ReductionCodegenInfo(mapping_scheme,\n                              reduction_dimensions.is_row_reduction)",
          "new_text": null,
          "old_line_content": "  return ReductionCodegenInfo(mapping_scheme,",
          "new_line_content": "      {reduction_tiling[0], reduction_tiling[1] * num_threads_y, tile_size_x},",
          "content_same": false
        },
        {
          "line": 3396,
          "old_api": "setAlignment",
          "new_api": null,
          "old_text": "global_for_const->setAlignment(kConstantBufferAlignBytes)",
          "new_text": null,
          "old_line_content": "    global_for_const->setAlignment(kConstantBufferAlignBytes);",
          "new_line_content": "        /*TLMode=*/llvm::GlobalValue::NotThreadLocal,",
          "content_same": false
        },
        {
          "line": 3397,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "ir_emitter_context_->llvm_module()->getGlobalList().push_back(\n        global_for_const)",
          "new_text": null,
          "old_line_content": "    ir_emitter_context_->llvm_module()->getGlobalList().push_back(",
          "new_line_content": "        /*AddressSpace=*/global_address_space,",
          "content_same": false
        },
        {
          "line": 3448,
          "old_api": "size",
          "new_api": null,
          "old_text": "slice_instructions.size()",
          "new_text": null,
          "old_line_content": "  for (int64 i = 0; i < slice_instructions.size(); ++i) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3273,
          "old_api": "size",
          "new_api": null,
          "old_text": "output_instructions.size()",
          "new_text": null,
          "old_line_content": "  bool returns_tuple = output_instructions.size() > 1;",
          "new_line_content": "Status IrEmitterUnnested::EmitReductionFromOrToContiguousDimensions(",
          "content_same": false
        },
        {
          "line": 3274,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "unnested_hlo->ToString()",
          "new_text": null,
          "old_line_content": "  VLOG(10) << \"Emitting reduction to vector \" << unnested_hlo->ToString();",
          "new_line_content": "    HloInstruction* unnested_hlo,",
          "content_same": false
        },
        {
          "line": 3401,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "        global_for_const);",
          "content_same": false
        },
        {
          "line": 3282,
          "old_api": "size",
          "new_api": null,
          "old_text": "output_instructions.size()",
          "new_text": null,
          "old_line_content": "  for (int i = 0; i < output_instructions.size(); ++i) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3283,
          "old_api": "IsReductionFromOrToContiguousDimensions",
          "new_api": null,
          "old_text": "IsReductionFromOrToContiguousDimensions(*output_instructions[i])",
          "new_text": null,
          "old_line_content": "    if (!IsReductionFromOrToContiguousDimensions(*output_instructions[i])) {",
          "new_line_content": "  // Build an initializer thunk to initialize each reduction output.",
          "content_same": false
        },
        {
          "line": 3288,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "reduce_instructions.push_back(output_instruction)",
          "new_text": null,
          "old_line_content": "    reduce_instructions.push_back(output_instruction);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3289,
          "old_api": "ShapeIndex",
          "new_api": null,
          "old_text": "ShapeIndex({})",
          "new_text": null,
          "old_line_content": "    ShapeIndex idx = returns_tuple ? ShapeIndex({i}) : ShapeIndex({});",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3290,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "reduction_output_shape_indices.push_back(idx)",
          "new_text": null,
          "old_line_content": "    reduction_output_shape_indices.push_back(idx);",
          "new_line_content": "    HloInstruction* output_instruction = output_instructions[i];",
          "content_same": false
        },
        {
          "line": 3295,
          "old_api": "std::move(initializer_thunk)",
          "new_api": null,
          "old_text": "std::move(initializer_thunk)",
          "new_text": null,
          "old_line_content": "    thunks.push_back(std::move(initializer_thunk));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3423,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "unnested_hlo->ToString()",
          "new_text": null,
          "old_line_content": "  VLOG(10) << \"Emitting slice input fusion for \" << unnested_hlo->ToString();",
          "new_line_content": "//",
          "content_same": false
        },
        {
          "line": 3425,
          "old_api": "fused_expression_root",
          "new_api": null,
          "old_text": "unnested_hlo->fused_expression_root()",
          "new_text": null,
          "old_line_content": "  HloInstruction* slice_or_tuple = unnested_hlo->fused_expression_root();",
          "new_line_content": "    HloInstruction* unnested_hlo, const llvm_ir::IrArray::Index& index) {",
          "content_same": false
        },
        {
          "line": 3299,
          "old_api": "size",
          "new_api": null,
          "old_text": "output_instructions.size()",
          "new_text": null,
          "old_line_content": "  if (output_instructions.size() > 1) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3300,
          "old_api": "AreFusedReductionOutputsConsistent",
          "new_api": null,
          "old_text": "AreFusedReductionOutputsConsistent(output_instructions,\n                                            first_reduce)",
          "new_text": null,
          "old_line_content": "    if (!AreFusedReductionOutputsConsistent(output_instructions,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3427,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "slice_or_tuple->opcode()",
          "new_text": null,
          "old_line_content": "    if (slice_or_tuple->opcode() == HloOpcode::kSlice) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3308,
          "old_api": "BuildKernelThunk",
          "new_api": null,
          "old_text": "BuildKernelThunk(unnested_hlo, /*implements_whole_instruction=*/false)",
          "new_text": null,
          "old_line_content": "      BuildKernelThunk(unnested_hlo, /*implements_whole_instruction=*/false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3437,
          "old_api": "GetNestedComputer",
          "new_api": null,
          "old_text": "GetNestedComputer()",
          "new_text": null,
          "old_line_content": "                                     GetNestedComputer());",
          "new_line_content": "  // Emit input operand values of slices.",
          "content_same": false
        },
        {
          "line": 3310,
          "old_api": "operand",
          "new_api": null,
          "old_text": "first_reduce->operand(0)->shape()",
          "new_text": null,
          "old_line_content": "  const Shape& input_shape = first_reduce->operand(0)->shape();",
          "new_line_content": "  std::unique_ptr<KernelThunk> kernel_thunk =",
          "content_same": false
        },
        {
          "line": 3438,
          "old_api": "GetGeneratorForOperandIrArrays",
          "new_api": null,
          "old_text": "GetGeneratorForOperandIrArrays(unnested_hlo)",
          "new_text": null,
          "old_line_content": "  FusedIrEmitter fused_emitter(GetGeneratorForOperandIrArrays(unnested_hlo),",
          "new_line_content": "  std::vector<llvm::Value*> input_ir_values;",
          "content_same": false
        },
        {
          "line": 3442,
          "old_api": "operand",
          "new_api": null,
          "old_text": "slice->operand(0)",
          "new_text": null,
          "old_line_content": "    auto input_generator = fused_emitter.GetGenerator(slice->operand(0));",
          "new_line_content": "                               &elem_emitter);",
          "content_same": false
        },
        {
          "line": 3315,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "first_reduce->ToString()",
          "new_text": null,
          "old_line_content": "                                  << first_reduce->ToString();",
          "new_line_content": "  // unnested kReduce or by InstructionFusion for fused kReduce.",
          "content_same": false
        },
        {
          "line": 3320,
          "old_api": "GetKernelMappingScheme",
          "new_api": null,
          "old_text": "reduction_info.GetKernelMappingScheme()",
          "new_text": null,
          "old_line_content": "      reduction_info.GetKernelMappingScheme();",
          "new_line_content": "  ReductionCodegenInfo reduction_info =",
          "content_same": false
        },
        {
          "line": 3322,
          "old_api": "GetThreadsPerBlock",
          "new_api": null,
          "old_text": "mapping_scheme.GetThreadsPerBlock()",
          "new_text": null,
          "old_line_content": "                                     mapping_scheme.GetThreadsPerBlock());",
          "new_line_content": "  const KernelMappingScheme& mapping_scheme =",
          "content_same": false
        },
        {
          "line": 3453,
          "old_api": "size",
          "new_api": null,
          "old_text": "slice->slice_starts().size()",
          "new_text": null,
          "old_line_content": "    for (size_t dim = 0; dim < slice->slice_starts().size(); ++dim) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3454,
          "old_api": "slice_strides",
          "new_api": null,
          "old_text": "slice->slice_strides(dim)",
          "new_text": null,
          "old_line_content": "      CHECK_EQ(slice->slice_strides(dim), 1);",
          "new_line_content": "    // guarding_cond := index >= start && index < limit, for each dim.",
          "content_same": false
        },
        {
          "line": 3455,
          "old_api": "CreateICmpSGE",
          "new_api": null,
          "old_text": "b_.CreateICmpSGE(\n          index.multidim()[dim],\n          index.GetConstantWithIndexType(slice->slice_starts(dim)))",
          "new_text": null,
          "old_line_content": "      auto larger_or_equal_than_start = b_.CreateICmpSGE(",
          "new_line_content": "    std::vector<llvm::Value*> index_within_ranges;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 46,
      "total_additions": 56,
      "total_deletions": 56,
      "total_api_changes": 158
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 11,
        "api_related_lines": 158,
        "non_api_lines": 8,
        "non_api_line_numbers": [
          3253,
          3255,
          3257,
          3258,
          3259,
          3260,
          3261,
          3263
        ]
      }
    },
    "api_calls_before": 1750,
    "api_calls_after": 1750,
    "diff_info": {
      "added_lines": 9,
      "removed_lines": 6,
      "total_diff_lines": 32
    }
  }
}