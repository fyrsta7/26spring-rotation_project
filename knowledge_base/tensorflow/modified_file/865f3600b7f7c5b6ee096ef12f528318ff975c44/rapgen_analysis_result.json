{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/865f3600b7f7c5b6ee096ef12f528318ff975c44",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/865f3600b7f7c5b6ee096ef12f528318ff975c44/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/865f3600b7f7c5b6ee096ef12f528318ff975c44/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/865f3600b7f7c5b6ee096ef12f528318ff975c44/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 2026,
          "old_api": "emit_elem_function",
          "new_api": "CreateICmpULT",
          "old_text": "emit_elem_function(source_idx_x, y_loc, x_loc, old_j)",
          "new_text": "b_.CreateICmpULT(x_loc, tile_width)",
          "old_line_content": "                return emit_elem_function(source_idx_x, y_loc, x_loc, old_j);",
          "new_line_content": "                        b_.CreateICmpULT(x_loc, tile_width), emit_element);",
          "content_same": false
        },
        {
          "line": 2045,
          "old_api": "CreateICmpEQ",
          "new_api": "GetTileSizeX",
          "old_text": "ksl->If(loop_name + \"_is_full_tile\",\n                  // if (block fully fit) {fast path} else {slow path}\n                  // tile_width is always exact. For the last block,\n                  // it will be the exact number of elements left.\n                  b_.CreateICmpEQ(constant(mapping_scheme.GetTileSizeX()),\n                                  tile_width),\n                  [&] {\n                    unroll(/*add_index_boundary_condition=*/false, vector_size);\n                  },\n                  [&] {\n                    unroll(/*add_index_boundary_condition=*/true, vector_size);\n                  })",
          "new_text": "mapping_scheme.GetTileSizeX()",
          "old_line_content": "          ksl->If(loop_name + \"_is_full_tile\",",
          "new_line_content": "                  b_.CreateICmpEQ(constant(mapping_scheme.GetTileSizeX()),",
          "content_same": false
        },
        {
          "line": 2076,
          "old_api": "getInt64",
          "new_api": "GetDimsInElems",
          "old_text": "b_.getInt64(0)",
          "new_text": "mapping_scheme.GetDimsInElems()",
          "old_line_content": "      Load(GEP(param_shmem_buffers[0], {b_.getInt64(0), x_loc, y_loc}),",
          "new_line_content": "      hlo->shape().element_type(), mapping_scheme.GetDimsInElems());",
          "content_same": false
        },
        {
          "line": 2079,
          "old_api": "element_type",
          "new_api": "CastToShape",
          "old_text": "ShapeUtil::MakeShapeWithDescendingLayout(\n      hlo->shape().element_type(), mapping_scheme.GetDimsInElems())",
          "new_text": "output_array.CastToShape(output_reduced_shape, &b_)\n      .EmitWriteArrayElement(index, load_from_shmem_buffer, &b_)",
          "old_line_content": "  Shape output_reduced_shape = ShapeUtil::MakeShapeWithDescendingLayout(",
          "new_line_content": "  output_array.CastToShape(output_reduced_shape, &b_)",
          "content_same": false
        },
        {
          "line": 2111,
          "old_api": "GetGeneratorForOperandIrArrays",
          "new_api": "fused_expression_root",
          "old_text": "GetGeneratorForOperandIrArrays(hlo)",
          "new_text": "hlo->fused_expression_root()->Accept(&fused_emitter)",
          "old_line_content": "  FusedIrEmitter fused_emitter(GetGeneratorForOperandIrArrays(hlo),",
          "new_line_content": "  TF_CHECK_OK(hlo->fused_expression_root()->Accept(&fused_emitter));",
          "content_same": false
        },
        {
          "line": 2115,
          "old_api": "fused_expression_root",
          "new_api": "GetRootGenerator",
          "old_text": "hlo->fused_expression_root()->Accept(&fused_emitter)",
          "new_text": "fused_emitter.GetRootGenerator()",
          "old_line_content": "  TF_CHECK_OK(hlo->fused_expression_root()->Accept(&fused_emitter));",
          "new_line_content": "      fused_emitter.GetRootGenerator();",
          "content_same": false
        },
        {
          "line": 2116,
          "old_api": "GetShape",
          "new_api": "ValueOrDie",
          "old_text": "GetUnnormalizedIndex(\n      index, output_arrays[0].GetShape(), &b_, mapping_scheme)",
          "new_text": "output_generator(untiled_index).ValueOrDie()",
          "old_line_content": "  IrArray::Index untiled_index = GetUnnormalizedIndex(",
          "new_line_content": "  llvm::Value* output_value = output_generator(untiled_index).ValueOrDie();",
          "content_same": false
        },
        {
          "line": 2117,
          "old_api": "GetShape",
          "new_api": "IsMultiOutputFusion",
          "old_text": "output_arrays[0].GetShape()",
          "new_text": "hlo->IsMultiOutputFusion()",
          "old_line_content": "      index, output_arrays[0].GetShape(), &b_, mapping_scheme);",
          "new_line_content": "  if (hlo->IsMultiOutputFusion()) {",
          "content_same": false
        },
        {
          "line": 2119,
          "old_api": "GetRootGenerator",
          "new_api": "getType",
          "old_text": "fused_emitter.GetRootGenerator()",
          "new_text": "output_value->getType()->getStructNumElements()",
          "old_line_content": "      fused_emitter.GetRootGenerator();",
          "new_line_content": "    DCHECK_EQ(output_value->getType()->getStructNumElements(),",
          "content_same": false
        },
        {
          "line": 2120,
          "old_api": "ValueOrDie",
          "new_api": "size",
          "old_text": "output_generator(untiled_index).ValueOrDie()",
          "new_text": "output_arrays.size()",
          "old_line_content": "  llvm::Value* output_value = output_generator(untiled_index).ValueOrDie();",
          "new_line_content": "              output_arrays.size());",
          "content_same": false
        },
        {
          "line": 2121,
          "old_api": "IsMultiOutputFusion",
          "new_api": "size",
          "old_text": "hlo->IsMultiOutputFusion()",
          "new_text": "output_arrays.size()",
          "old_line_content": "  if (hlo->IsMultiOutputFusion()) {",
          "new_line_content": "    for (int64 i = 0; i < output_arrays.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2122,
          "old_api": "getType",
          "new_api": "EmitWriteArrayElement",
          "old_text": "output_value->getType()->isStructTy()",
          "new_text": "output_arrays[i].EmitWriteArrayElement(\n          untiled_index, ExtractValue(output_value, i), &b_)",
          "old_line_content": "    DCHECK(output_value->getType()->isStructTy());",
          "new_line_content": "      output_arrays[i].EmitWriteArrayElement(",
          "content_same": false
        },
        {
          "line": 2123,
          "old_api": "getType",
          "new_api": "ExtractValue",
          "old_text": "output_value->getType()->getStructNumElements()",
          "new_text": "ExtractValue(output_value, i)",
          "old_line_content": "    DCHECK_EQ(output_value->getType()->getStructNumElements(),",
          "new_line_content": "          untiled_index, ExtractValue(output_value, i), &b_);",
          "content_same": false
        },
        {
          "line": 2140,
          "old_api": "IsRowReduction",
          "new_api": "GetIndexingOrder",
          "old_text": "reduction_info.IsRowReduction()",
          "new_text": "mapping_scheme.GetIndexingOrder()",
          "old_line_content": "  if (reduction_info.IsRowReduction()) {",
          "new_line_content": "      mapping_scheme.GetIndexingOrder() == kStridedIndexingX ? 1 : 2;",
          "content_same": false
        },
        {
          "line": 2157,
          "old_api": "GetNestedComputer",
          "new_api": "ToString",
          "old_text": "GetNestedComputer()",
          "new_text": "reduce_inst->ToString()",
          "old_line_content": "                                          &b_, GetNestedComputer());",
          "new_line_content": "    VLOG(10) << \"Emit prologue for reduction: \" << reduce_inst->ToString();",
          "content_same": false
        },
        {
          "line": 2161,
          "old_api": "ToString",
          "new_api": "dimensions",
          "old_text": "reduce_inst->ToString()",
          "new_text": "reduce_inst->dimensions()",
          "old_line_content": "    VLOG(10) << \"Emit prologue for reduction: \" << reduce_inst->ToString();",
          "new_line_content": "      CHECK(first_reduce->dimensions() == reduce_inst->dimensions());",
          "content_same": false
        },
        {
          "line": 2165,
          "old_api": "dimensions",
          "new_api": "GetMutableReductionInputAddresses",
          "old_text": "reduce_inst->dimensions()",
          "new_text": "reduction_info->GetMutableReductionInputAddresses()",
          "old_line_content": "      CHECK(first_reduce->dimensions() == reduce_inst->dimensions());",
          "new_line_content": "        reduction_info->GetMutableReductionInputAddresses();",
          "content_same": false
        },
        {
          "line": 2169,
          "old_api": "GetMutableReductionInputAddresses",
          "new_api": "Alloca",
          "old_text": "reduction_info->GetMutableReductionInputAddresses()",
          "new_text": "Alloca(element_type)",
          "old_line_content": "        reduction_info->GetMutableReductionInputAddresses();",
          "new_line_content": "    llvm::AllocaInst* reduction_input_address = Alloca(element_type);",
          "content_same": false
        },
        {
          "line": 2172,
          "old_api": "llvm_module",
          "new_api": "GetNumberOfPartialResults",
          "old_text": "ir_emitter_context_->llvm_module()",
          "new_text": "GetNumberOfPartialResults(*reduction_info)",
          "old_line_content": "                                       ir_emitter_context_->llvm_module());",
          "new_line_content": "    int num_partial_results = GetNumberOfPartialResults(*reduction_info);",
          "content_same": false
        },
        {
          "line": 2174,
          "old_api": "push_back",
          "new_api": "GetMutablePartialResultAddresses",
          "old_text": "reduction_input_addresses->push_back(reduction_input_address)",
          "new_text": "reduction_info->GetMutablePartialResultAddresses()",
          "old_line_content": "    reduction_input_addresses->push_back(reduction_input_address);",
          "new_line_content": "        reduction_info->GetMutablePartialResultAddresses();",
          "content_same": false
        },
        {
          "line": 2176,
          "old_api": "GetNumberOfPartialResults",
          "new_api": "getInt32",
          "old_text": "GetNumberOfPartialResults(*reduction_info)",
          "new_text": "b_.getInt32(num_partial_results)",
          "old_line_content": "    int num_partial_results = GetNumberOfPartialResults(*reduction_info);",
          "new_line_content": "        Alloca(element_type, /*ArraySize=*/b_.getInt32(num_partial_results),",
          "content_same": false
        },
        {
          "line": 2178,
          "old_api": "GetMutablePartialResultAddresses",
          "new_api": "push_back",
          "old_text": "reduction_info->GetMutablePartialResultAddresses()",
          "new_text": "partial_result_addresses->push_back(partial_result_address)",
          "old_line_content": "        reduction_info->GetMutablePartialResultAddresses();",
          "new_line_content": "    partial_result_addresses->push_back(partial_result_address);",
          "content_same": false
        },
        {
          "line": 2182,
          "old_api": "push_back",
          "new_api": "operand",
          "old_text": "partial_result_addresses->push_back(partial_result_address)",
          "new_text": "reduce_inst->operand(1)",
          "old_line_content": "    partial_result_addresses->push_back(partial_result_address);",
          "new_line_content": "    const HloInstruction* init_value = reduce_inst->operand(1);",
          "content_same": false
        },
        {
          "line": 2187,
          "old_api": "opcode",
          "new_api": "Accept",
          "old_text": "unnested_hlo->opcode()",
          "new_text": "init_value->Accept(&fused_emitter)",
          "old_line_content": "    if (unnested_hlo->opcode() == HloOpcode::kFusion) {",
          "new_line_content": "      TF_CHECK_OK(init_value->Accept(&fused_emitter));",
          "content_same": false
        },
        {
          "line": 2194,
          "old_api": "getInt32Ty",
          "new_api": "EmitReadArrayElement",
          "old_text": "b_.getInt32Ty()",
          "new_text": "GetIrArray(*init_value, *unnested_hlo)\n              .EmitReadArrayElement(IrArray::Index(b_.getInt32Ty()), &b_)",
          "old_line_content": "              .GetGenerator(init_value)(IrArray::Index(b_.getInt32Ty()))",
          "new_line_content": "          GetIrArray(*init_value, *unnested_hlo)",
          "content_same": false
        },
        {
          "line": 2199,
          "old_api": "getInt32Ty",
          "new_api": "getInt32",
          "old_text": "b_.getInt32Ty()",
          "new_text": "Store(init_ir_value,\n            InBoundsGEP(partial_result_address, {b_.getInt32(i)}))",
          "old_line_content": "              .EmitReadArrayElement(IrArray::Index(b_.getInt32Ty()), &b_);",
          "new_line_content": "      Store(init_ir_value,",
          "content_same": false
        },
        {
          "line": 2204,
          "old_api": "getInt32",
          "new_api": "GetKernelMappingScheme",
          "old_text": "b_.getInt32(i)",
          "new_text": "reduction_info->GetKernelMappingScheme()",
          "old_line_content": "            InBoundsGEP(partial_result_address, {b_.getInt32(i)}));",
          "new_line_content": "    auto& mapping_scheme = reduction_info->GetKernelMappingScheme();",
          "content_same": false
        },
        {
          "line": 2206,
          "old_api": "GetMutableInitialValues",
          "new_api": "element_type",
          "old_text": "reduction_info->GetMutableInitialValues()->push_back(init_ir_value)",
          "new_text": "llvm_ir::PrimitiveTypeToIrType(\n        reduce_inst->shape().element_type(), module_)",
          "old_line_content": "    reduction_info->GetMutableInitialValues()->push_back(init_ir_value);",
          "new_line_content": "    llvm::Type* primitive_type = llvm_ir::PrimitiveTypeToIrType(",
          "content_same": false
        },
        {
          "line": 2208,
          "old_api": "GetKernelMappingScheme",
          "new_api": "GetNumThreadsY",
          "old_text": "reduction_info->GetKernelMappingScheme()",
          "new_text": "[&] {\n      if (reduction_info->IsRowReduction()) {\n        // Allocate __shared__ cache[num_partial_results][kWarpSize].\n        return llvm::ArrayType::get(\n            llvm::ArrayType::get(primitive_type, kWarpSize),\n            num_partial_results);\n      } else {\n        // Allocate __shared__\n        // cache[num_partial_results][num_threads][num_threads + 1], where\n        // num_threads == num_threads_x == num_threads_y.  The \"+1\" is used to\n        // avoid bank conflicts.\n        CHECK_EQ(num_threads_x, mapping_scheme.GetNumThreadsY());\n        return llvm::ArrayType::get(\n            llvm::ArrayType::get(\n                llvm::ArrayType::get(primitive_type, num_threads_x + 1),\n                num_threads_x),\n            num_partial_results);\n      }\n    }()",
          "old_line_content": "    auto& mapping_scheme = reduction_info->GetKernelMappingScheme();",
          "new_line_content": "    llvm::Type* buffer_type = [&] {",
          "content_same": false
        },
        {
          "line": 2209,
          "old_api": "GetNumThreadsX",
          "new_api": "IsRowReduction",
          "old_text": "mapping_scheme.GetNumThreadsX()",
          "new_text": "reduction_info->IsRowReduction()",
          "old_line_content": "    int64 num_threads_x = mapping_scheme.GetNumThreadsX();",
          "new_line_content": "      if (reduction_info->IsRowReduction()) {",
          "content_same": false
        },
        {
          "line": 2211,
          "old_api": "element_type",
          "new_api": "llvm::ArrayType::get(\n            llvm::ArrayType::get(primitive_type, kWarpSize),\n            num_partial_results)",
          "old_text": "reduce_inst->shape().element_type()",
          "new_text": "llvm::ArrayType::get(\n            llvm::ArrayType::get(primitive_type, kWarpSize),\n            num_partial_results)",
          "old_line_content": "        reduce_inst->shape().element_type(), module_);",
          "new_line_content": "        return llvm::ArrayType::get(",
          "content_same": false
        },
        {
          "line": 2212,
          "old_api": "GetNumThreadsY",
          "new_api": "llvm::ArrayType::get(primitive_type, kWarpSize)",
          "old_text": "[&] {\n      if (reduction_info->IsRowReduction()) {\n        // Allocate __shared__ cache[num_partial_results][kWarpSize].\n        return llvm::ArrayType::get(\n            llvm::ArrayType::get(primitive_type, kWarpSize),\n            num_partial_results);\n      } else {\n        // Allocate __shared__\n        // cache[num_partial_results][num_threads][num_threads + 1], where\n        // num_threads == num_threads_x == num_threads_y.  The \"+1\" is used to\n        // avoid bank conflicts.\n        CHECK_EQ(num_threads_x, mapping_scheme.GetNumThreadsY());\n        return llvm::ArrayType::get(\n            llvm::ArrayType::get(\n                llvm::ArrayType::get(primitive_type, num_threads_x + 1),\n                num_threads_x),\n            num_partial_results);\n      }\n    }()",
          "new_text": "llvm::ArrayType::get(primitive_type, kWarpSize)",
          "old_line_content": "    llvm::Type* buffer_type = [&] {",
          "new_line_content": "            llvm::ArrayType::get(primitive_type, kWarpSize),",
          "content_same": false
        },
        {
          "line": 2256,
          "old_api": "Alloca",
          "new_api": "getIntNTy",
          "old_text": "Alloca(element_type, nullptr, \"result_from_other_lane\")",
          "new_text": "b_.getIntNTy(bit_width)",
          "old_line_content": "        Alloca(element_type, nullptr, \"result_from_other_lane\");",
          "new_line_content": "        element_type->isStructTy() ? b_.getIntNTy(bit_width) : element_type;",
          "content_same": false
        },
        {
          "line": 2262,
          "old_api": "CreatePointerBitCastOrAddrSpaceCast",
          "new_api": "convert_pointer_for_shuffle",
          "old_text": "b_.CreatePointerBitCastOrAddrSpaceCast(\n          ptr, shuffled_value_type->getPointerTo())",
          "new_text": "convert_pointer_for_shuffle(partial_result_address)",
          "old_line_content": "      return b_.CreatePointerBitCastOrAddrSpaceCast(",
          "new_line_content": "        Load(convert_pointer_for_shuffle(partial_result_address),",
          "content_same": false
        },
        {
          "line": 2266,
          "old_api": "convert_pointer_for_shuffle",
          "new_api": "EmitCallToNestedComputation",
          "old_text": "convert_pointer_for_shuffle(partial_result_address)",
          "new_text": "EmitCallToNestedComputation(\n        *reducer, {partial_result_address, result_from_other_lane},\n        partial_result_address)",
          "old_line_content": "        Load(convert_pointer_for_shuffle(partial_result_address),",
          "new_line_content": "    TF_CHECK_OK(EmitCallToNestedComputation(",
          "content_same": false
        },
        {
          "line": 2305,
          "old_api": "llvm::ConstantInt::get(index_ty, c)",
          "new_api": "GetThreadsPerBlock",
          "old_text": "llvm::ConstantInt::get(index_ty, c)",
          "new_text": "mapping_scheme.GetThreadsPerBlock()",
          "old_line_content": "    return llvm::ConstantInt::get(index_ty, c);",
          "new_line_content": "      EmitThreadIdInfo(mapping_scheme.GetThreadsPerBlock(), index_ty,",
          "content_same": false
        },
        {
          "line": 2312,
          "old_api": "IsRowReduction",
          "new_api": "std::swap(x_loc, y_loc)",
          "old_text": "[&] {\n    llvm::Value* x_loc = thread_id_info.thread_id_x;\n    llvm::Value* y_loc = thread_id_info.thread_id_y;\n    if (!reduction_info.IsRowReduction()) {\n      std::swap(x_loc, y_loc);\n    }\n    llvm::Value* start_offset_x =\n        GetStartOffsetX(mapping_scheme, x_loc, index_ty, &b_);\n    return tiling_kernel_info.tile_origin.AddOffsetToDim(y_loc, kDimY, &b_)\n        .AddOffsetToDim(start_offset_x, kDimX, &b_);\n  }()",
          "new_text": "std::swap(x_loc, y_loc)",
          "old_line_content": "  IrArray::Index start_offset = [&] {",
          "new_line_content": "      std::swap(x_loc, y_loc);",
          "content_same": false
        },
        {
          "line": 2315,
          "old_api": "IsRowReduction",
          "new_api": "GetStartOffsetX",
          "old_text": "reduction_info.IsRowReduction()",
          "new_text": "GetStartOffsetX(mapping_scheme, x_loc, index_ty, &b_)",
          "old_line_content": "    if (!reduction_info.IsRowReduction()) {",
          "new_line_content": "        GetStartOffsetX(mapping_scheme, x_loc, index_ty, &b_);",
          "content_same": false
        },
        {
          "line": 2316,
          "old_api": "std::swap(x_loc, y_loc)",
          "new_api": "AddOffsetToDim",
          "old_text": "std::swap(x_loc, y_loc)",
          "new_text": "tiling_kernel_info.tile_origin.AddOffsetToDim(y_loc, kDimY, &b_)\n        .AddOffsetToDim(start_offset_x, kDimX, &b_)",
          "old_line_content": "      std::swap(x_loc, y_loc);",
          "new_line_content": "    return tiling_kernel_info.tile_origin.AddOffsetToDim(y_loc, kDimY, &b_)",
          "content_same": false
        },
        {
          "line": 2320,
          "old_api": "AddOffsetToDim",
          "new_api": "size",
          "old_text": "tiling_kernel_info.tile_origin.AddOffsetToDim(y_loc, kDimY, &b_)\n        .AddOffsetToDim(start_offset_x, kDimX, &b_)",
          "new_text": "reducers.size()",
          "old_line_content": "    return tiling_kernel_info.tile_origin.AddOffsetToDim(y_loc, kDimY, &b_)",
          "new_line_content": "  int num_reduces = reducers.size();",
          "content_same": false
        },
        {
          "line": 2324,
          "old_api": "size",
          "new_api": "GetNumberOfPartialResults",
          "old_text": "reducers.size()",
          "new_text": "GetNumberOfPartialResults(reduction_info)",
          "old_line_content": "  int num_reduces = reducers.size();",
          "new_line_content": "  int num_partial_results = GetNumberOfPartialResults(reduction_info);",
          "content_same": false
        },
        {
          "line": 2335,
          "old_api": "dimensions",
          "new_api": "operand",
          "old_text": "ShapeUtil::FilterDimensions(\n        [&](int64 dim) {\n          return !absl::c_linear_search(reduce_hlo->dimensions(), dim);\n        },\n        reduce_hlo->operand(0)->shape())",
          "new_text": "reduce_hlo->operand(0)->shape()",
          "old_line_content": "    Shape reduction_kept_element_shape = ShapeUtil::FilterDimensions(",
          "new_line_content": "        reduce_hlo->operand(0)->shape());",
          "content_same": false
        },
        {
          "line": 2339,
          "old_api": "operand",
          "new_api": "constant",
          "old_text": "reduce_hlo->operand(0)->shape()",
          "new_text": "constant(j)",
          "old_line_content": "        reduce_hlo->operand(0)->shape());",
          "new_line_content": "              &b_, start_offset.AddOffsetToDim(constant(j), kDimX, &b_),",
          "content_same": false
        },
        {
          "line": 2360,
          "old_api": "GetShape",
          "new_api": "CreateInBoundsGEP",
          "old_text": "output_array.GetShape()",
          "new_text": "b_.CreateInBoundsGEP(\n          partial_result_addresses[i], {constant(j)}, \"current_output\")",
          "old_line_content": "                                  output_array.GetShape(),",
          "new_line_content": "      llvm::Value* current_output = b_.CreateInBoundsGEP(",
          "content_same": false
        },
        {
          "line": 2361,
          "old_api": "GetType",
          "new_api": "constant",
          "old_text": "element_index.GetType()",
          "new_text": "constant(j)",
          "old_line_content": "                                  element_index.GetType());",
          "new_line_content": "          partial_result_addresses[i], {constant(j)}, \"current_output\");",
          "content_same": false
        },
        {
          "line": 2386,
          "old_api": "IsRowReduction",
          "new_api": "constant",
          "old_text": "reduction_info.IsRowReduction()",
          "new_text": "constant(kWarpSize)",
          "old_line_content": "      if (reduction_info.IsRowReduction()) {",
          "new_line_content": "            b_.CreateUDiv(thread_id_info.thread_id_x, constant(kWarpSize));",
          "content_same": false
        },
        {
          "line": 2387,
          "old_api": "EmitFullWarpShuffleDownLoopForReduce",
          "new_api": "is_zero",
          "old_text": "EmitFullWarpShuffleDownLoopForReduce(reducers[i], element_type,\n                                             current_output)",
          "new_text": "is_zero(thread_id_info.lane_id)",
          "old_line_content": "        EmitFullWarpShuffleDownLoopForReduce(reducers[i], element_type,",
          "new_line_content": "        ksl.If(is_zero(thread_id_info.lane_id), [&] {",
          "content_same": false
        },
        {
          "line": 2391,
          "old_api": "is_zero",
          "new_api": "CreateLoad",
          "old_text": "is_zero(thread_id_info.lane_id)",
          "new_text": "b_.CreateLoad(current_output)",
          "old_line_content": "        ksl.If(is_zero(thread_id_info.lane_id), [&] {",
          "new_line_content": "          b_.CreateStore(b_.CreateLoad(current_output), shmem_output_addr);",
          "content_same": false
        },
        {
          "line": 2394,
          "old_api": "constant",
          "new_api": "EmitSyncThreads",
          "old_text": "constant(j)",
          "new_text": "EmitSyncThreads()",
          "old_line_content": "                  shared_cache, {b_.getInt32(0), constant(j), warp_id}));",
          "new_line_content": "        EmitSyncThreads();",
          "content_same": false
        },
        {
          "line": 2395,
          "old_api": "CreateLoad",
          "new_api": "is_zero",
          "old_text": "b_.CreateLoad(current_output)",
          "new_text": "is_zero(warp_id)",
          "old_line_content": "          b_.CreateStore(b_.CreateLoad(current_output), shmem_output_addr);",
          "new_line_content": "        ksl.If(is_zero(warp_id), [&] {",
          "content_same": false
        },
        {
          "line": 2398,
          "old_api": "EmitSyncThreads",
          "new_api": "constant",
          "old_text": "EmitSyncThreads()",
          "new_text": "constant(j)",
          "old_line_content": "        EmitSyncThreads();",
          "new_line_content": "              {b_.getInt32(0), constant(j), thread_id_info.lane_id}));",
          "content_same": false
        },
        {
          "line": 2399,
          "old_api": "is_zero",
          "new_api": "GetInitialValues",
          "old_text": "is_zero(warp_id)",
          "new_text": "reduction_info.GetInitialValues()",
          "old_line_content": "        ksl.If(is_zero(warp_id), [&] {",
          "new_line_content": "          llvm::Value* initial_value = reduction_info.GetInitialValues()[i];",
          "content_same": false
        },
        {
          "line": 2403,
          "old_api": "GetInitialValues",
          "new_api": "CreateStore",
          "old_text": "reduction_info.GetInitialValues()",
          "new_text": "b_.CreateStore(initial_value, initial_value_addr)",
          "old_line_content": "          llvm::Value* initial_value = reduction_info.GetInitialValues()[i];",
          "new_line_content": "          b_.CreateStore(initial_value, initial_value_addr);",
          "content_same": false
        },
        {
          "line": 2405,
          "old_api": "llvm_ir::EmitAllocaAtFunctionEntry(\n                  element_type, \"initial_value_addr\", &b_)",
          "new_api": "CreateICmpULT",
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n                  element_type, \"initial_value_addr\", &b_)",
          "new_text": "b_.CreateICmpULT(\n              thread_id_info.thread_id_x,\n              constant(mapping_scheme.GetNumThreadsX() / kWarpSize))",
          "old_line_content": "              shared_to_global(llvm_ir::EmitAllocaAtFunctionEntry(",
          "new_line_content": "          llvm::Value* warp_exists = b_.CreateICmpULT(",
          "content_same": false
        },
        {
          "line": 2407,
          "old_api": "CreateStore",
          "new_api": "GetNumThreadsX",
          "old_text": "b_.CreateStore(initial_value, initial_value_addr)",
          "new_text": "mapping_scheme.GetNumThreadsX()",
          "old_line_content": "          b_.CreateStore(initial_value, initial_value_addr);",
          "new_line_content": "              constant(mapping_scheme.GetNumThreadsX() / kWarpSize));",
          "content_same": false
        },
        {
          "line": 2409,
          "old_api": "CreateICmpULT",
          "new_api": "CreateSelect",
          "old_text": "b_.CreateICmpULT(\n              thread_id_info.thread_id_x,\n              constant(mapping_scheme.GetNumThreadsX() / kWarpSize))",
          "new_text": "b_.CreateSelect(\n              warp_exists, block_accum_addr, initial_value_addr)",
          "old_line_content": "          llvm::Value* warp_exists = b_.CreateICmpULT(",
          "new_line_content": "          llvm::Value* selected_value = b_.CreateSelect(",
          "content_same": false
        },
        {
          "line": 2416,
          "old_api": "EmitFullWarpShuffleDownLoopForReduce",
          "new_api": "EmitAtomicOperationForNestedComputation",
          "old_text": "EmitFullWarpShuffleDownLoopForReduce(\n              reducers[i], element_type,\n              /*block_accum_addr*/ selected_value)",
          "new_text": "EmitAtomicOperationForNestedComputation(\n                *reducers[i], output_address, block_accum_addr)",
          "old_line_content": "          EmitFullWarpShuffleDownLoopForReduce(",
          "new_line_content": "            TF_CHECK_OK(EmitAtomicOperationForNestedComputation(",
          "content_same": false
        },
        {
          "line": 2427,
          "old_api": "constant",
          "new_api": "CreateLoad",
          "old_text": "constant(j)",
          "new_text": "b_.CreateLoad(current_output)",
          "old_line_content": "            b_.CreateInBoundsGEP(shared_cache, {b_.getInt32(0), constant(j),",
          "new_line_content": "        llvm::Value* current_output_value = b_.CreateLoad(current_output);",
          "content_same": false
        },
        {
          "line": 2434,
          "old_api": "EmitSyncThreads",
          "new_api": "CreateInBoundsGEP",
          "old_text": "EmitSyncThreads()",
          "new_text": "b_.CreateInBoundsGEP(\n                shared_cache,\n                {b_.getInt32(0), constant(j), thread_id_info.thread_id_y,\n                 thread_id_info.thread_id_x},\n                \"shmem_transposed_addr\")",
          "old_line_content": "        EmitSyncThreads();",
          "new_line_content": "            shared_to_global(b_.CreateInBoundsGEP(",
          "content_same": false
        },
        {
          "line": 2440,
          "old_api": "constant",
          "new_api": "EmitFullWarpShuffleDownLoopForReduce",
          "old_text": "constant(j)",
          "new_text": "EmitFullWarpShuffleDownLoopForReduce(reducers[i], element_type,\n                                             shmem_transposed_addr)",
          "old_line_content": "                {b_.getInt32(0), constant(j), thread_id_info.thread_id_y,",
          "new_line_content": "        EmitFullWarpShuffleDownLoopForReduce(reducers[i], element_type,",
          "content_same": false
        },
        {
          "line": 2454,
          "old_api": "CreateICmpULT",
          "new_api": "EmitAtomicOperationForNestedComputation",
          "old_text": "b_.CreateICmpULT(thread_id_info.thread_id_x,\n                             tiling_kernel_info.output_tile_bounds[kDimY])",
          "new_text": "EmitAtomicOperationForNestedComputation(\n              *reducers[i], output_address, shmem_transposed_addr)",
          "old_line_content": "            b_.CreateICmpULT(thread_id_info.thread_id_x,",
          "new_line_content": "          TF_CHECK_OK(EmitAtomicOperationForNestedComputation(",
          "content_same": false
        },
        {
          "line": 2475,
          "old_api": "getInt32Ty",
          "new_api": "end",
          "old_text": "b_.getInt32Ty()",
          "new_text": "arguments.end()",
          "old_line_content": "  llvm::Value* thread_id = EmitThreadId(1024, b_.getInt32Ty());",
          "new_line_content": "                           arguments.end());",
          "content_same": false
        },
        {
          "line": 2476,
          "old_api": "EmitBlockId",
          "new_api": "getTrue",
          "old_text": "EmitBlockId()",
          "new_text": "b_.getTrue()",
          "old_line_content": "  llvm::Value* block_id = EmitBlockId();",
          "new_line_content": "  llvm::Value* constraint = b_.getTrue();",
          "content_same": false
        },
        {
          "line": 2478,
          "old_api": "begin",
          "new_api": "CreateAnd",
          "old_text": "arguments.begin()",
          "new_text": "b_.CreateAnd(\n        constraint, b_.CreateICmpEQ(thread_id, b_.getInt32(*thread_id_filter)))",
          "old_line_content": "  updated_arguments.insert(updated_arguments.end(), arguments.begin(),",
          "new_line_content": "    constraint = b_.CreateAnd(",
          "content_same": false
        },
        {
          "line": 2479,
          "old_api": "end",
          "new_api": "getInt32",
          "old_text": "arguments.end()",
          "new_text": "b_.getInt32(*thread_id_filter)",
          "old_line_content": "                           arguments.end());",
          "new_line_content": "        constraint, b_.CreateICmpEQ(thread_id, b_.getInt32(*thread_id_filter)));",
          "content_same": false
        },
        {
          "line": 2486,
          "old_api": "CreateAnd",
          "new_api": "If",
          "old_text": "b_.CreateAnd(\n        constraint, b_.CreateICmpEQ(block_id, b_.getInt32(*block_id_filter)))",
          "new_text": "ksl.If(constraint, [&] {\n    ::xla::gpu::EmitPrintf(absl::StrCat(\"[TID=%d,BID=%d] \", fmt, \"\\n\"),\n                           updated_arguments, &b_);\n  })",
          "old_line_content": "    constraint = b_.CreateAnd(",
          "new_line_content": "  ksl.If(constraint, [&] {",
          "content_same": false
        },
        {
          "line": 2487,
          "old_api": "getInt32",
          "new_api": "absl::StrCat(\"[TID=%d,BID=%d] \", fmt, \"\\n\")",
          "old_text": "b_.getInt32(*block_id_filter)",
          "new_text": "absl::StrCat(\"[TID=%d,BID=%d] \", fmt, \"\\n\")",
          "old_line_content": "        constraint, b_.CreateICmpEQ(block_id, b_.getInt32(*block_id_filter)));",
          "new_line_content": "    ::xla::gpu::EmitPrintf(absl::StrCat(\"[TID=%d,BID=%d] \", fmt, \"\\n\"),",
          "content_same": false
        },
        {
          "line": 2511,
          "old_api": "GetGeneratorForOperandIrArrays",
          "new_api": "opcode",
          "old_text": "GetGeneratorForOperandIrArrays(unnested_hlo)",
          "new_text": "unnested_hlo->opcode()",
          "old_line_content": "  FusedIrEmitter fused_emitter(GetGeneratorForOperandIrArrays(unnested_hlo),",
          "new_line_content": "  if (unnested_hlo->opcode() == HloOpcode::kFusion) {",
          "content_same": false
        },
        {
          "line": 2516,
          "old_api": "fused_expression_root",
          "new_api": "ShapeIndex",
          "old_text": "unnested_hlo->fused_expression_root()->Accept(&fused_emitter)",
          "new_text": "ShapeIndex({})",
          "old_line_content": "    TF_CHECK_OK(unnested_hlo->fused_expression_root()->Accept(&fused_emitter));",
          "new_line_content": "      ShapeIndex idx = returns_tuple ? ShapeIndex({i}) : ShapeIndex({});",
          "content_same": false
        },
        {
          "line": 2518,
          "old_api": "size",
          "new_api": "operand",
          "old_text": "output_instructions.size()",
          "new_text": "inst->operand(0)",
          "old_line_content": "    for (int i = 0, e = output_instructions.size(); i != e; ++i) {",
          "new_line_content": "        input_gens.push_back(fused_emitter.GetGenerator(inst->operand(0)));",
          "content_same": false
        },
        {
          "line": 2520,
          "old_api": "ShapeIndex",
          "new_api": "GetGenerator",
          "old_text": "ShapeIndex({})",
          "new_text": "fused_emitter.GetGenerator(inst)",
          "old_line_content": "      ShapeIndex idx = returns_tuple ? ShapeIndex({i}) : ShapeIndex({});",
          "new_line_content": "        extra_output_gens.emplace_back(fused_emitter.GetGenerator(inst),",
          "content_same": false
        },
        {
          "line": 2521,
          "old_api": "IsReductionFromOrToContiguousDimensions",
          "new_api": "std::move(idx)",
          "old_text": "IsReductionFromOrToContiguousDimensions(*inst)",
          "new_text": "std::move(idx)",
          "old_line_content": "      if (IsReductionFromOrToContiguousDimensions(*inst)) {",
          "new_line_content": "                                       std::move(idx));",
          "content_same": false
        },
        {
          "line": 2525,
          "old_api": "std::move(idx)",
          "new_api": "push_back",
          "old_text": "std::move(idx)",
          "new_text": "input_gens.push_back([&](const IrArray::Index& index) {\n      return GetIrArray(*unnested_hlo->operand(0), *unnested_hlo)\n          .EmitReadArrayElement(index, &b_);\n    })",
          "old_line_content": "                                       std::move(idx));",
          "new_line_content": "    input_gens.push_back([&](const IrArray::Index& index) {",
          "content_same": false
        },
        {
          "line": 2544,
          "old_api": "GetType",
          "new_api": "size",
          "old_text": "input_index.GetType()",
          "new_text": "reducers.size()",
          "old_line_content": "      input_index.multidim(), reduction_operand_shape, input_index.GetType());",
          "new_line_content": "  for (int i = 0; i != reducers.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2548,
          "old_api": "size",
          "new_api": "GetPartialResultAddresses",
          "old_text": "reducers.size()",
          "new_text": "reduction_info.GetPartialResultAddresses()",
          "old_line_content": "  for (int i = 0; i != reducers.size(); ++i) {",
          "new_line_content": "        reduction_info.GetPartialResultAddresses()[i];",
          "content_same": false
        },
        {
          "line": 2550,
          "old_api": "GetReductionInputAddresses",
          "new_api": "ValueOrDie",
          "old_text": "reduction_info.GetReductionInputAddresses()",
          "new_text": "input_gens[i](num_partial_results > 1 ? index_without_linear\n                                              : input_index)\n            .ValueOrDie()",
          "old_line_content": "        reduction_info.GetReductionInputAddresses()[i];",
          "new_line_content": "        input_gens[i](num_partial_results > 1 ? index_without_linear",
          "content_same": false
        },
        {
          "line": 2554,
          "old_api": "ValueOrDie",
          "new_api": "getInt32",
          "old_text": "input_gens[i](num_partial_results > 1 ? index_without_linear\n                                              : input_index)\n            .ValueOrDie()",
          "new_text": "InBoundsGEP(\n        partial_reduction_result_address, {b_.getInt32(partial_result_index)})",
          "old_line_content": "        input_gens[i](num_partial_results > 1 ? index_without_linear",
          "new_line_content": "    llvm::Value* partial_result_address = InBoundsGEP(",
          "content_same": false
        },
        {
          "line": 2588,
          "old_api": "EmitThreadId",
          "new_api": "CreateURem",
          "old_text": "EmitThreadId(threads_per_block, index_ty)",
          "new_text": "b_.CreateURem(thread_id, num_threads_x_v, \"thread_id.x\")",
          "old_line_content": "  llvm::Value* thread_id = EmitThreadId(threads_per_block, index_ty);",
          "new_line_content": "      /*thread_id_x=*/b_.CreateURem(thread_id, num_threads_x_v, \"thread_id.x\"),",
          "content_same": false
        },
        {
          "line": 2589,
          "old_api": "constant",
          "new_api": "CreateUDiv",
          "old_text": "constant(num_threads_x)",
          "new_text": "b_.CreateUDiv(thread_id, num_threads_x_v, \"thread_id.y\")",
          "old_line_content": "  llvm::Value* num_threads_x_v = constant(num_threads_x);",
          "new_line_content": "      /*thread_id_y=*/b_.CreateUDiv(thread_id, num_threads_x_v, \"thread_id.y\"),",
          "content_same": false
        },
        {
          "line": 2600,
          "old_api": "GetDimsInElems",
          "new_api": "GetTileSizeX",
          "old_text": "mapping_scheme.GetDimsInElems()",
          "new_text": "mapping_scheme.GetTileSizeX()",
          "old_line_content": "  absl::Span<const int64> dims_in_elems = mapping_scheme.GetDimsInElems();",
          "new_line_content": "      CeilOfRatio(dims_in_elems[2], mapping_scheme.GetTileSizeX())};",
          "content_same": false
        },
        {
          "line": 2602,
          "old_api": "GetTileSizeZ",
          "new_api": "llvm::ConstantInt::get(index_ty, c)",
          "old_text": "mapping_scheme.GetTileSizeZ()",
          "new_text": "llvm::ConstantInt::get(index_ty, c)",
          "old_line_content": "      CeilOfRatio(dims_in_elems[0], mapping_scheme.GetTileSizeZ()),",
          "new_line_content": "    return llvm::ConstantInt::get(index_ty, c);",
          "content_same": false
        },
        {
          "line": 2606,
          "old_api": "llvm::ConstantInt::get(index_ty, c)",
          "new_api": "GetThreadsPerBlock",
          "old_text": "llvm::ConstantInt::get(index_ty, c)",
          "new_text": "mapping_scheme.GetThreadsPerBlock()",
          "old_line_content": "    return llvm::ConstantInt::get(index_ty, c);",
          "new_line_content": "      EmitThreadIdInfo(mapping_scheme.GetThreadsPerBlock(), index_ty,",
          "content_same": false
        },
        {
          "line": 2611,
          "old_api": "GetNumThreadsX",
          "new_api": "GetNumberOfBlocks",
          "old_text": "mapping_scheme.GetNumThreadsX()",
          "new_text": "[&] {\n    llvm::Value* block_id = EmitBlockId();\n    llvm_ir::AddRangeMetadata(0, mapping_scheme.GetNumberOfBlocks(),\n                              llvm::cast<llvm::Instruction>(block_id));\n    llvm::Value* linear_block_id =\n        b_.CreateIntCast(block_id, index_ty, /*isSigned=*/true, \"block.id.x\");\n    IrArray::Index starting_block(linear_block_id,\n                                  ShapeUtil::MakeShapeWithDescendingLayout(\n                                      PRED /*arbitrary*/, dims_in_blocks),\n                                  &b_);\n\n    std::vector<llvm::Value*> multidim = {\n        b_.CreateMul(starting_block[0], constant(mapping_scheme.GetTileSizeZ()),\n                     \"block_origin.z\"),\n        starting_block[1], starting_block[2]};\n    return IrArray::Index(multidim, dims_in_blocks, index_ty);\n  }()",
          "old_line_content": "                       mapping_scheme.GetNumThreadsX());",
          "new_line_content": "  const IrArray::Index block_coords = [&] {",
          "content_same": false
        },
        {
          "line": 2616,
          "old_api": "EmitBlockId",
          "new_api": "CreateIntCast",
          "old_text": "EmitBlockId()",
          "new_text": "b_.CreateIntCast(block_id, index_ty, /*isSigned=*/true, \"block.id.x\")",
          "old_line_content": "    llvm::Value* block_id = EmitBlockId();",
          "new_line_content": "        b_.CreateIntCast(block_id, index_ty, /*isSigned=*/true, \"block.id.x\");",
          "content_same": false
        },
        {
          "line": 2618,
          "old_api": "llvm::cast<llvm::Instruction>(block_id)",
          "new_api": "ShapeUtil::MakeShapeWithDescendingLayout(\n                                      PRED /*arbitrary*/, dims_in_blocks)",
          "old_text": "llvm::cast<llvm::Instruction>(block_id)",
          "new_text": "ShapeUtil::MakeShapeWithDescendingLayout(\n                                      PRED /*arbitrary*/, dims_in_blocks)",
          "old_line_content": "                              llvm::cast<llvm::Instruction>(block_id));",
          "new_line_content": "                                  ShapeUtil::MakeShapeWithDescendingLayout(",
          "content_same": false
        },
        {
          "line": 2642,
          "old_api": "constant",
          "new_api": "multidim",
          "old_text": "constant(partial_row)",
          "new_text": "[&] {\n    std::vector<llvm::Value*> elem_multi_index = block_coords.multidim();\n    llvm::Type* index_ty = block_coords.GetType();\n    for (int i = kDimY; i < kDimTot; ++i) {\n      elem_multi_index[i] = b_.CreateMul(\n          block_coords[i],\n          llvm::ConstantInt::get(index_ty, mapping_scheme.GetTileSizeFor(i)),\n          \"tile_origin.\" + std::to_string(i));\n    }\n    return IrArray::Index(elem_multi_index, mapping_scheme.GetDimsInElems(),\n                          index_ty);\n  }()",
          "old_line_content": "        b_.CreateSelect(is_last, constant(partial_row),",
          "new_line_content": "  IrArray::Index tile_origin = [&] {",
          "content_same": false
        },
        {
          "line": 2643,
          "old_api": "constant",
          "new_api": "multidim",
          "old_text": "constant(tile_size_for_dim)",
          "new_text": "block_coords.multidim()",
          "old_line_content": "                        constant(tile_size_for_dim), \"tile_bound\");",
          "new_line_content": "    std::vector<llvm::Value*> elem_multi_index = block_coords.multidim();",
          "content_same": false
        },
        {
          "line": 2646,
          "old_api": "multidim",
          "new_api": "CreateMul",
          "old_text": "[&] {\n    std::vector<llvm::Value*> elem_multi_index = block_coords.multidim();\n    llvm::Type* index_ty = block_coords.GetType();\n    for (int i = kDimY; i < kDimTot; ++i) {\n      elem_multi_index[i] = b_.CreateMul(\n          block_coords[i],\n          llvm::ConstantInt::get(index_ty, mapping_scheme.GetTileSizeFor(i)),\n          \"tile_origin.\" + std::to_string(i));\n    }\n    return IrArray::Index(elem_multi_index, mapping_scheme.GetDimsInElems(),\n                          index_ty);\n  }()",
          "new_text": "b_.CreateMul(\n          block_coords[i],\n          llvm::ConstantInt::get(index_ty, mapping_scheme.GetTileSizeFor(i)),\n          \"tile_origin.\" + std::to_string(i))",
          "old_line_content": "  IrArray::Index tile_origin = [&] {",
          "new_line_content": "      elem_multi_index[i] = b_.CreateMul(",
          "content_same": false
        },
        {
          "line": 2648,
          "old_api": "GetType",
          "new_api": "GetTileSizeFor",
          "old_text": "block_coords.GetType()",
          "new_text": "mapping_scheme.GetTileSizeFor(i)",
          "old_line_content": "    llvm::Type* index_ty = block_coords.GetType();",
          "new_line_content": "          llvm::ConstantInt::get(index_ty, mapping_scheme.GetTileSizeFor(i)),",
          "content_same": false
        },
        {
          "line": 2660,
          "old_api": "tile_element_generator",
          "new_api": "GetTileSizeZ",
          "old_text": "tile_element_generator(thread_id_info, tile, \"output\",\n                           output_tile_bounds[1], output_tile_bounds[2], &ksl)",
          "new_text": "mapping_scheme.GetTileSizeZ()",
          "old_line_content": "    tile_element_generator(thread_id_info, tile, \"output\",",
          "new_line_content": "  if (mapping_scheme.GetTileSizeZ() == 1) {",
          "content_same": false
        },
        {
          "line": 2670,
          "old_api": "CreateUDiv",
          "new_api": "GetTileSizeZ",
          "old_text": "b_.CreateUDiv(starting_tile_index_for_dim, block_size_for_dim)",
          "new_text": "mapping_scheme.GetTileSizeZ()",
          "old_line_content": "        b_.CreateUDiv(starting_tile_index_for_dim, block_size_for_dim);",
          "new_line_content": "                 (dims_in_blocks[kDimZ] - 1) * mapping_scheme.GetTileSizeZ());",
          "content_same": false
        },
        {
          "line": 2673,
          "old_api": "GetTileSizeZ",
          "new_api": "CreateICmpEQ",
          "old_text": "constant(dims_in_elems[kDimZ] -\n                 (dims_in_blocks[kDimZ] - 1) * mapping_scheme.GetTileSizeZ())",
          "new_text": "b_.CreateICmpEQ(last_block_for_dim, block_id_for_dim)",
          "old_line_content": "        constant(dims_in_elems[kDimZ] -",
          "new_line_content": "        b_.CreateSelect(b_.CreateICmpEQ(last_block_for_dim, block_id_for_dim),",
          "content_same": false
        },
        {
          "line": 2679,
          "old_api": "For",
          "new_api": "AddOffsetToDim",
          "old_text": "ksl.For(\"loop_z\",\n            /*start=*/constant(0),\n            /*end=*/num_tiles_in_block,\n            /*step=*/1, [&](llvm::Value* block_dim_induction_var) {\n              IrArray::Index tile_index = tile_origin.AddOffsetToDim(\n                  block_dim_induction_var, kDimZ, &b_);\n              emit_tile(tile_index);\n            })",
          "new_text": "tile_origin.AddOffsetToDim(\n                  block_dim_induction_var, kDimZ, &b_)",
          "old_line_content": "    ksl.For(\"loop_z\",",
          "new_line_content": "              IrArray::Index tile_index = tile_origin.AddOffsetToDim(",
          "content_same": false
        },
        {
          "line": 2752,
          "old_api": "GetInsertBlock",
          "new_api": "operand_count",
          "old_text": "b_.GetInsertBlock()->getModule()",
          "new_text": "hlo->operand_count()",
          "old_line_content": "    return llvm_ir::AllocateSharedMemoryTile(b_.GetInsertBlock()->getModule(),",
          "new_line_content": "  for (int64 id = 0; id < hlo->operand_count(); id++) {",
          "content_same": false
        },
        {
          "line": 2756,
          "old_api": "operand_count",
          "new_api": "absl::c_linear_search(tiled_param_ids, id)",
          "old_text": "hlo->operand_count()",
          "new_text": "absl::c_linear_search(tiled_param_ids, id)",
          "old_line_content": "  for (int64 id = 0; id < hlo->operand_count(); id++) {",
          "new_line_content": "    if (absl::c_linear_search(tiled_param_ids, id)) {",
          "content_same": false
        },
        {
          "line": 2758,
          "old_api": "GetIrArray",
          "new_api": "element_type",
          "old_text": "GetIrArray(*param, *hlo)",
          "new_text": "llvm_ir::PrimitiveTypeToIrType(\n                                       param->shape().element_type(), module_)",
          "old_line_content": "    param_arrays.push_back(GetIrArray(*param, *hlo));",
          "new_line_content": "          get_shared_memory_buffer(llvm_ir::PrimitiveTypeToIrType(",
          "content_same": false
        },
        {
          "line": 2760,
          "old_api": "absl::c_linear_search(tiled_param_ids, id)",
          "new_api": "StrCat",
          "old_text": "absl::c_linear_search(tiled_param_ids, id)",
          "new_text": "StrCat(\"tile\", id)",
          "old_line_content": "    if (absl::c_linear_search(tiled_param_ids, id)) {",
          "new_line_content": "                                   IrName(hlo, StrCat(\"tile\", id)));",
          "content_same": false
        },
        {
          "line": 2762,
          "old_api": "element_type",
          "new_api": "llvm_ir::DumpToString(*param_shmem_buffers[id])",
          "old_text": "llvm_ir::PrimitiveTypeToIrType(\n                                       param->shape().element_type(), module_)",
          "new_text": "llvm_ir::DumpToString(*param_shmem_buffers[id])",
          "old_line_content": "          get_shared_memory_buffer(llvm_ir::PrimitiveTypeToIrType(",
          "new_line_content": "              << llvm_ir::DumpToString(*param_shmem_buffers[id]);",
          "content_same": false
        },
        {
          "line": 2764,
          "old_api": "StrCat",
          "new_api": "element_type",
          "old_text": "StrCat(\"tile\", id)",
          "new_text": "param->shape().element_type()",
          "old_line_content": "                                   IrName(hlo, StrCat(\"tile\", id)));",
          "new_line_content": "          param->shape().element_type(),",
          "content_same": false
        },
        {
          "line": 2765,
          "old_api": "VLOG",
          "new_api": "Permute",
          "old_text": "VLOG(3)",
          "new_text": "Permute({0, 2, 1}, reduced_output_dims)",
          "old_line_content": "      VLOG(3) << \"Added shmem buffer for parameter \" << id << \": \"",
          "new_line_content": "          Permute({0, 2, 1}, reduced_output_dims));",
          "content_same": false
        },
        {
          "line": 2766,
          "old_api": "llvm_ir::DumpToString(*param_shmem_buffers[id])",
          "new_api": "push_back",
          "old_text": "llvm_ir::DumpToString(*param_shmem_buffers[id])",
          "new_text": "param_in_reduced_shape_arrays.push_back(\n          param_arrays[id].CastToShape(reduced_shape, &b_))",
          "old_line_content": "              << llvm_ir::DumpToString(*param_shmem_buffers[id]);",
          "new_line_content": "      param_in_reduced_shape_arrays.push_back(",
          "content_same": false
        },
        {
          "line": 2767,
          "old_api": "element_type",
          "new_api": "CastToShape",
          "old_text": "ShapeUtil::MakeShapeWithDescendingLayout(\n          param->shape().element_type(),\n          Permute({0, 2, 1}, reduced_output_dims))",
          "new_text": "param_arrays[id].CastToShape(reduced_shape, &b_)",
          "old_line_content": "      Shape reduced_shape = ShapeUtil::MakeShapeWithDescendingLayout(",
          "new_line_content": "          param_arrays[id].CastToShape(reduced_shape, &b_));",
          "content_same": false
        },
        {
          "line": 2769,
          "old_api": "Permute",
          "new_api": "IrArray",
          "old_text": "Permute({0, 2, 1}, reduced_output_dims)",
          "new_text": "IrArray()",
          "old_line_content": "          Permute({0, 2, 1}, reduced_output_dims));",
          "new_line_content": "      param_in_reduced_shape_arrays.push_back(IrArray());",
          "content_same": false
        },
        {
          "line": 2781,
          "old_api": "EmitTileElementForCopy",
          "new_api": "EmitTileElementForFusion",
          "old_text": "EmitTileElementForCopy(hlo, index, mapping_scheme, y_loc, x_loc,\n                                 param_shmem_buffers)",
          "new_text": "EmitTileElementForFusion(hlo, index, mapping_scheme, y_loc, x_loc,\n                                   param_shmem_buffers)",
          "old_line_content": "          EmitTileElementForCopy(hlo, index, mapping_scheme, y_loc, x_loc,",
          "new_line_content": "          EmitTileElementForFusion(hlo, index, mapping_scheme, y_loc, x_loc,",
          "content_same": false
        },
        {
          "line": 2797,
          "old_api": "empty",
          "new_api": "GetType",
          "old_text": "tiled_param_ids.empty()",
          "new_text": "index.GetType()",
          "old_line_content": "        if (!tiled_param_ids.empty()) {",
          "new_line_content": "              Permute({0, 2, 1}, index.dims()), index.GetType());",
          "content_same": false
        },
        {
          "line": 2817,
          "old_api": "llvm::ConstantInt::get(index_type, 0)",
          "new_api": "EmitReadArrayElement",
          "old_text": "llvm::ConstantInt::get(index_type, 0)",
          "new_text": "input_in_logical_shape.EmitReadArrayElement(\n                                 index, &b_, \"input_element\")",
          "old_line_content": "                           llvm::ConstantInt::get(index_type, 0);",
          "new_line_content": "                       Store(input_in_logical_shape.EmitReadArrayElement(",
          "content_same": false
        },
        {
          "line": 2854,
          "old_api": "ConstructIrArrayForOutputs",
          "new_api": "EmitTilingKernel",
          "old_text": "ConstructIrArrayForOutputs(*hlo)",
          "new_text": "EmitTilingKernel(mapping_scheme, index_type, tile_generator)",
          "old_line_content": "                         ConstructIrArrayForOutputs(*hlo), &b_);",
          "new_line_content": "  EmitTilingKernel(mapping_scheme, index_type, tile_generator);",
          "content_same": false
        },
        {
          "line": 2905,
          "old_api": "IsInstructionSafeForShmemTranspose",
          "new_api": "opcode",
          "old_text": "IsInstructionSafeForShmemTranspose(user)",
          "new_text": "hlo->opcode()",
          "old_line_content": "      return IsInstructionSafeForShmemTranspose(user);",
          "new_line_content": "  switch (hlo->opcode()) {",
          "content_same": false
        },
        {
          "line": 2946,
          "old_api": "fused_parameter",
          "new_api": "ToString",
          "old_text": "fusion->fused_parameter(input_ids[i])",
          "new_text": "input->ToString()",
          "old_line_content": "    const HloInstruction* input = fusion->fused_parameter(input_ids[i]);",
          "new_line_content": "      VLOG(10) << \"Input not safe for shmem transpose \" << input->ToString();",
          "content_same": false
        },
        {
          "line": 2959,
          "old_api": "opcode",
          "new_api": "IsMultiOutputFusion",
          "old_text": "hlo->opcode()",
          "new_text": "hlo->IsMultiOutputFusion()",
          "old_line_content": "  HloOpcode opcode = hlo->opcode();",
          "new_line_content": "  const Shape& output_shape = hlo->IsMultiOutputFusion()",
          "content_same": false
        },
        {
          "line": 2961,
          "old_api": "IsLoopFusion",
          "new_api": "shape",
          "old_text": "hlo->IsLoopFusion()",
          "new_text": "hlo->shape()",
          "old_line_content": "  CHECK(hlo->IsLoopFusion() || opcode == HloOpcode::kCopy);",
          "new_line_content": "                                  : hlo->shape();",
          "content_same": false
        },
        {
          "line": 2971,
          "old_api": "operand_count",
          "new_api": "shape",
          "old_text": "hlo->operand_count()",
          "new_text": "operand->shape()",
          "old_line_content": "  for (int64 operand_idx = 0; operand_idx < hlo->operand_count();",
          "new_line_content": "        ShapeUtil::FindTranspose021(operand->shape(), output_shape);",
          "content_same": false
        },
        {
          "line": 3025,
          "old_api": "constexpr",
          "new_api": "operand",
          "old_text": "constexpr",
          "new_text": "hlo->operand(params_012[i])",
          "old_line_content": "  constexpr int kMinBlocksPerCore = 3;",
          "new_line_content": "    const HloInstruction* operand = hlo->operand(params_012[i]);",
          "content_same": false
        },
        {
          "line": 3028,
          "old_api": "size",
          "new_api": "element_type",
          "old_text": "params_012.size()",
          "new_text": "operand->shape().element_type()",
          "old_line_content": "  for (int64 i = 0; i < params_012.size(); ++i) {",
          "new_line_content": "        ShapeUtil::ByteSizeOfPrimitiveType(operand->shape().element_type());",
          "content_same": false
        },
        {
          "line": 3032,
          "old_api": "element_type",
          "new_api": "resize",
          "old_text": "operand->shape().element_type()",
          "new_text": "params_012.resize(i)",
          "old_line_content": "        ShapeUtil::ByteSizeOfPrimitiveType(operand->shape().element_type());",
          "new_line_content": "      params_012.resize(i);",
          "content_same": false
        },
        {
          "line": 3041,
          "old_api": "empty",
          "new_api": "ToString",
          "old_text": "params_012.empty()",
          "new_text": "hlo->ToString()",
          "old_line_content": "  if (params_012.empty()) {",
          "new_line_content": "  VLOG(3) << \"EmitHlo021Tile Emitting hlo tile 0-2-1\" << hlo->ToString();",
          "content_same": false
        },
        {
          "line": 3045,
          "old_api": "ToString",
          "new_api": "std::move(kernel_thunk)",
          "old_text": "hlo->ToString()",
          "new_text": "std::move(kernel_thunk)",
          "old_line_content": "  VLOG(3) << \"EmitHlo021Tile Emitting hlo tile 0-2-1\" << hlo->ToString();",
          "new_line_content": "  AddThunkToThunkSequence(std::move(kernel_thunk));",
          "content_same": false
        },
        {
          "line": 3071,
          "old_api": "fused_parameters",
          "new_api": "AreUsersElementwise",
          "old_text": "absl::c_count_if(\n      unnested_hlo->fused_parameters(), [&](const HloInstruction* parameter) {\n        const Shape& parameter_shape = parameter->shape();\n        return ShapeUtil::SameDimensions(op_shape, parameter_shape) &&\n               AreUsersElementwise(parameter, use_chain_endings);\n      })",
          "new_text": "AreUsersElementwise(parameter, use_chain_endings)",
          "old_line_content": "  return absl::c_count_if(",
          "new_line_content": "               AreUsersElementwise(parameter, use_chain_endings);",
          "content_same": false
        },
        {
          "line": 3101,
          "old_api": "static_cast<uint64>(num_kept_minor)",
          "new_api": "IsReductionFromOrToContiguousDimensions",
          "old_text": "static_cast<uint64>(num_kept_minor)",
          "new_text": "IsReductionFromOrToContiguousDimensions(*unnested_hlo)",
          "old_line_content": "  if (!IsPowerOfTwo(static_cast<uint64>(num_kept_minor))) {",
          "new_line_content": "  if (IsReductionFromOrToContiguousDimensions(*unnested_hlo)) {",
          "content_same": false
        },
        {
          "line": 3105,
          "old_api": "IsReductionFromOrToContiguousDimensions",
          "new_api": "opcode",
          "old_text": "IsReductionFromOrToContiguousDimensions(*unnested_hlo)",
          "new_text": "unnested_hlo->opcode()",
          "old_line_content": "  if (IsReductionFromOrToContiguousDimensions(*unnested_hlo)) {",
          "new_line_content": "  CHECK_EQ(unnested_hlo->opcode(), HloOpcode::kFusion);",
          "content_same": false
        },
        {
          "line": 3115,
          "old_api": "insert",
          "new_api": "opcode",
          "old_text": "use_chain_endings.insert(fused_root)",
          "new_text": "fused_root->opcode()",
          "old_line_content": "    use_chain_endings.insert(fused_root);",
          "new_line_content": "    CHECK_EQ(fused_root->opcode(), HloOpcode::kTuple);",
          "content_same": false
        },
        {
          "line": 3165,
          "old_api": "get_dtype_bits",
          "new_api": "device_description",
          "old_text": "get_dtype_bits(input)",
          "new_text": "ir_emitter_context_->device_description()",
          "old_line_content": "        std::min(get_dtype_bits(input), smallest_input_dtype_bits);",
          "new_line_content": "                         &ir_emitter_context_->device_description());",
          "content_same": false
        },
        {
          "line": 3168,
          "old_api": "device_description",
          "new_api": "IsUnrollingColumnReductionBeneficial",
          "old_text": "GetReductionTiling(reduction_dimensions, smallest_input_dtype_bits,\n                         &ir_emitter_context_->device_description())",
          "new_text": "IsUnrollingColumnReductionBeneficial(unnested_hlo, input_shape,\n                                            reduction_dimensions.dimensions[2])",
          "old_line_content": "      GetReductionTiling(reduction_dimensions, smallest_input_dtype_bits,",
          "new_line_content": "      !IsUnrollingColumnReductionBeneficial(unnested_hlo, input_shape,",
          "content_same": false
        },
        {
          "line": 3197,
          "old_api": "[&] {\n    if (reduction_dimensions.is_row_reduction) {\n      return std::min(\n          kWarpSize * kWarpSize,\n          RoundUpToNearest(CeilOfRatio(reduction_dimensions.dimensions[2],\n                                       reduction_tiling[2]),\n                           kWarpSize));\n    }\n    return kWarpSize;\n  }()",
          "new_api": "CeilOfRatio",
          "old_text": "[&] {\n    if (reduction_dimensions.is_row_reduction) {\n      return std::min(\n          kWarpSize * kWarpSize,\n          RoundUpToNearest(CeilOfRatio(reduction_dimensions.dimensions[2],\n                                       reduction_tiling[2]),\n                           kWarpSize));\n    }\n    return kWarpSize;\n  }()",
          "new_text": "CeilOfRatio(reduction_dimensions.dimensions[2],\n                                       reduction_tiling[2])",
          "old_line_content": "  int64 num_threads_x = [&] {",
          "new_line_content": "          RoundUpToNearest(CeilOfRatio(reduction_dimensions.dimensions[2],",
          "content_same": false
        },
        {
          "line": 3248,
          "old_api": "ShapeIndex",
          "new_api": "TF_ASSIGN_OR_RETURN",
          "old_text": "ShapeIndex({})",
          "new_text": "TF_ASSIGN_OR_RETURN(std::unique_ptr<Thunk> initializer_thunk,\n                        BuildInitializerThunk(unnested_hlo, idx))",
          "old_line_content": "    ShapeIndex idx = returns_tuple ? ShapeIndex({i}) : ShapeIndex({});",
          "new_line_content": "    TF_ASSIGN_OR_RETURN(std::unique_ptr<Thunk> initializer_thunk,",
          "content_same": false
        },
        {
          "line": 3249,
          "old_api": "push_back",
          "new_api": "BuildInitializerThunk",
          "old_text": "reduction_output_shape_indices.push_back(idx)",
          "new_text": "BuildInitializerThunk(unnested_hlo, idx)",
          "old_line_content": "    reduction_output_shape_indices.push_back(idx);",
          "new_line_content": "                        BuildInitializerThunk(unnested_hlo, idx));",
          "content_same": false
        },
        {
          "line": 3250,
          "old_api": "to_apply",
          "new_api": "std::move(initializer_thunk)",
          "old_text": "output_instruction->to_apply()",
          "new_text": "std::move(initializer_thunk)",
          "old_line_content": "    reducers.push_back(output_instruction->to_apply());",
          "new_line_content": "    thunks.push_back(std::move(initializer_thunk));",
          "content_same": false
        },
        {
          "line": 3253,
          "old_api": "BuildInitializerThunk",
          "new_api": "at",
          "old_text": "BuildInitializerThunk(unnested_hlo, idx)",
          "new_text": "reduce_instructions.at(0)",
          "old_line_content": "                        BuildInitializerThunk(unnested_hlo, idx));",
          "new_line_content": "  const HloInstruction* first_reduce = reduce_instructions.at(0);",
          "content_same": false
        },
        {
          "line": 3254,
          "old_api": "std::move(initializer_thunk)",
          "new_api": "size",
          "old_text": "std::move(initializer_thunk)",
          "new_text": "output_instructions.size()",
          "old_line_content": "    thunks.push_back(std::move(initializer_thunk));",
          "new_line_content": "  if (output_instructions.size() > 1) {",
          "content_same": false
        },
        {
          "line": 3257,
          "old_api": "at",
          "new_api": "InternalError",
          "old_text": "reduce_instructions.at(0)",
          "new_text": "InternalError(\"Inconsistent reduction fusion outputs\")",
          "old_line_content": "  const HloInstruction* first_reduce = reduce_instructions.at(0);",
          "new_line_content": "      return InternalError(\"Inconsistent reduction fusion outputs\");",
          "content_same": false
        },
        {
          "line": 3277,
          "old_api": "ComputeReductionCodegenInfo",
          "new_api": "GetThreadsPerBlock",
          "old_text": "ComputeReductionCodegenInfo(unnested_hlo, first_reduce)",
          "new_text": "mapping_scheme.GetThreadsPerBlock()",
          "old_line_content": "      ComputeReductionCodegenInfo(unnested_hlo, first_reduce);",
          "new_line_content": "                                     mapping_scheme.GetThreadsPerBlock());",
          "content_same": false
        },
        {
          "line": 3279,
          "old_api": "GetKernelMappingScheme",
          "new_api": "launch_bound",
          "old_text": "reduction_info.GetKernelMappingScheme()",
          "new_text": "launch_dimensions.launch_bound()",
          "old_line_content": "      reduction_info.GetKernelMappingScheme();",
          "new_line_content": "      unnested_hlo, launch_dimensions.launch_bound(), &b_);",
          "content_same": false
        },
        {
          "line": 3280,
          "old_api": "GetNumberOfBlocks",
          "new_api": "EmitPrologueForReduction",
          "old_text": "mapping_scheme.GetNumberOfBlocks()",
          "new_text": "EmitPrologueForReduction(unnested_hlo, &reduction_info, reduce_instructions,\n                           index_ty)",
          "old_line_content": "  LaunchDimensions launch_dimensions(mapping_scheme.GetNumberOfBlocks(),",
          "new_line_content": "  EmitPrologueForReduction(unnested_hlo, &reduction_info, reduce_instructions,",
          "content_same": false
        },
        {
          "line": 3302,
          "old_api": "EmitEpilogueForReduction",
          "new_api": "get",
          "old_text": "EmitEpilogueForReduction(index_ty, unnested_hlo, reduction_info,\n                           reduce_instructions, reduction_output_shape_indices,\n                           reducers, tiling_kernel_info)",
          "new_text": "kernel_thunk.get()",
          "old_line_content": "  EmitEpilogueForReduction(index_ty, unnested_hlo, reduction_info,",
          "new_line_content": "  UpdateLaunchDimensions(launch_dimensions, kernel_thunk.get(),",
          "content_same": false
        },
        {
          "line": 3307,
          "old_api": "llvm_module",
          "new_api": "std::move(thunks)",
          "old_text": "ir_emitter_context_->llvm_module()",
          "new_text": "std::move(thunks)",
          "old_line_content": "                         ir_emitter_context_->llvm_module());",
          "new_line_content": "      absl::make_unique<SequentialThunk>(std::move(thunks), unnested_hlo);",
          "content_same": false
        },
        {
          "line": 3320,
          "old_api": "is_constant",
          "new_api": "llvm_ir::LiteralForConstantAllocation(allocation)",
          "old_text": "allocation.is_constant()",
          "new_text": "llvm_ir::LiteralForConstantAllocation(allocation)",
          "old_line_content": "    if (!allocation.is_constant()) {",
          "new_line_content": "    const Literal& literal = llvm_ir::LiteralForConstantAllocation(allocation);",
          "content_same": false
        },
        {
          "line": 3327,
          "old_api": "size",
          "new_api": "llvm::ConstantAggregateZero::get(global_type)",
          "old_text": "allocation.size()",
          "new_text": "llvm::ConstantAggregateZero::get(global_type)",
          "old_line_content": "        llvm::ArrayType::get(b_.getInt8Ty(), allocation.size());",
          "new_line_content": "            : llvm::ConstantAggregateZero::get(global_type);",
          "content_same": false
        },
        {
          "line": 3330,
          "old_api": "llvm_ir::ConvertLiteralToIrConstant(literal, module_)",
          "new_api": "shape",
          "old_text": "llvm_ir::ConvertLiteralToIrConstant(literal, module_)",
          "new_text": "literal.shape()",
          "old_line_content": "            ? llvm_ir::ConvertLiteralToIrConstant(literal, module_)",
          "new_line_content": "              << ShapeUtil::HumanString(literal.shape());",
          "content_same": false
        },
        {
          "line": 3351,
          "old_api": "llvm_ir::ConstantBufferAllocationToGlobalName(allocation)",
          "new_api": "setAlignment",
          "old_text": "llvm_ir::ConstantBufferAllocationToGlobalName(allocation)",
          "new_text": "global_for_const->setAlignment(kConstantBufferAlignBytes)",
          "old_line_content": "        llvm_ir::ConstantBufferAllocationToGlobalName(allocation),",
          "new_line_content": "    global_for_const->setAlignment(kConstantBufferAlignBytes);",
          "content_same": false
        },
        {
          "line": 3356,
          "old_api": "push_back",
          "new_api": "Status::OK()",
          "old_text": "ir_emitter_context_->llvm_module()->getGlobalList().push_back(\n        global_for_const)",
          "new_text": "Status::OK()",
          "old_line_content": "    ir_emitter_context_->llvm_module()->getGlobalList().push_back(",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3382,
          "old_api": "ToString",
          "new_api": "opcode",
          "old_text": "unnested_hlo->ToString()",
          "new_text": "slice_or_tuple->opcode()",
          "old_line_content": "  VLOG(10) << \"Emitting slice input fusion for \" << unnested_hlo->ToString();",
          "new_line_content": "    if (slice_or_tuple->opcode() == HloOpcode::kSlice) {",
          "content_same": false
        },
        {
          "line": 3386,
          "old_api": "opcode",
          "new_api": "operands",
          "old_text": "slice_or_tuple->opcode()",
          "new_text": "slice_or_tuple->operands()",
          "old_line_content": "    if (slice_or_tuple->opcode() == HloOpcode::kSlice) {",
          "new_line_content": "    return slice_or_tuple->operands();",
          "content_same": false
        },
        {
          "line": 3397,
          "old_api": "GetGeneratorForOperandIrArrays",
          "new_api": "operand",
          "old_text": "GetGeneratorForOperandIrArrays(unnested_hlo)",
          "new_text": "slice->operand(0)",
          "old_line_content": "  FusedIrEmitter fused_emitter(GetGeneratorForOperandIrArrays(unnested_hlo),",
          "new_line_content": "    auto input_generator = fused_emitter.GetGenerator(slice->operand(0));",
          "content_same": false
        },
        {
          "line": 3412,
          "old_api": "size",
          "new_api": "slice_starts",
          "old_text": "slice->slice_starts().size()",
          "new_text": "slice->slice_starts(dim)",
          "old_line_content": "    for (size_t dim = 0; dim < slice->slice_starts().size(); ++dim) {",
          "new_line_content": "          index.GetConstantWithIndexType(slice->slice_starts(dim)));",
          "content_same": false
        },
        {
          "line": 3413,
          "old_api": "slice_strides",
          "new_api": "CreateICmpSLT",
          "old_text": "slice->slice_strides(dim)",
          "new_text": "b_.CreateICmpSLT(\n          index.multidim()[dim],\n          index.GetConstantWithIndexType(slice->slice_limits(dim)))",
          "old_line_content": "      CHECK_EQ(slice->slice_strides(dim), 1);",
          "new_line_content": "      llvm::Value* smaller_than_limit = b_.CreateICmpSLT(",
          "content_same": false
        },
        {
          "line": 3414,
          "old_api": "CreateICmpSGE",
          "new_api": "multidim",
          "old_text": "b_.CreateICmpSGE(\n          index.multidim()[dim],\n          index.GetConstantWithIndexType(slice->slice_starts(dim)))",
          "new_text": "index.multidim()",
          "old_line_content": "      auto larger_or_equal_than_start = b_.CreateICmpSGE(",
          "new_line_content": "          index.multidim()[dim],",
          "content_same": false
        },
        {
          "line": 3415,
          "old_api": "multidim",
          "new_api": "slice_limits",
          "old_text": "index.multidim()",
          "new_text": "slice->slice_limits(dim)",
          "old_line_content": "          index.multidim()[dim],",
          "new_line_content": "          index.GetConstantWithIndexType(slice->slice_limits(dim)));",
          "content_same": false
        },
        {
          "line": 3417,
          "old_api": "CreateICmpSLT",
          "new_api": "CreateAnd",
          "old_text": "b_.CreateICmpSLT(\n          index.multidim()[dim],\n          index.GetConstantWithIndexType(slice->slice_limits(dim)))",
          "new_text": "b_.CreateAnd(larger_or_equal_than_start, smaller_than_limit)",
          "old_line_content": "      llvm::Value* smaller_than_limit = b_.CreateICmpSLT(",
          "new_line_content": "          b_.CreateAnd(larger_or_equal_than_start, smaller_than_limit);",
          "content_same": false
        },
        {
          "line": 3418,
          "old_api": "multidim",
          "new_api": "push_back",
          "old_text": "index.multidim()",
          "new_text": "index_within_ranges.push_back(within_range)",
          "old_line_content": "          index.multidim()[dim],",
          "new_line_content": "      index_within_ranges.push_back(within_range);",
          "content_same": false
        },
        {
          "line": 3424,
          "old_api": "CreateAnd",
          "new_api": "size",
          "old_text": "b_.CreateAnd(index_within_ranges)",
          "new_text": "src_multidim.size()",
          "old_line_content": "    llvm::Value* guarding_cond = b_.CreateAnd(index_within_ranges);",
          "new_line_content": "      std::vector<llvm::Value*> dst_multidim(src_multidim.size());",
          "content_same": false
        },
        {
          "line": 3427,
          "old_api": "multidim",
          "new_api": "GetConstantWithIndexType",
          "old_text": "index.multidim()",
          "new_text": "Sub(src_multidim[dim],\n                index.GetConstantWithIndexType(slice->slice_starts(dim)))",
          "old_line_content": "      const std::vector<llvm::Value*>& src_multidim = index.multidim();",
          "new_line_content": "            Sub(src_multidim[dim],",
          "content_same": false
        },
        {
          "line": 3428,
          "old_api": "size",
          "new_api": "slice_starts",
          "old_text": "src_multidim.size()",
          "new_text": "slice->slice_starts(dim)",
          "old_line_content": "      std::vector<llvm::Value*> dst_multidim(src_multidim.size());",
          "new_line_content": "                index.GetConstantWithIndexType(slice->slice_starts(dim)));",
          "content_same": false
        },
        {
          "line": 3431,
          "old_api": "GetConstantWithIndexType",
          "new_api": "ShapeIndex",
          "old_text": "Sub(src_multidim[dim],\n                index.GetConstantWithIndexType(slice->slice_starts(dim)))",
          "new_text": "ShapeIndex()",
          "old_line_content": "            Sub(src_multidim[dim],",
          "new_line_content": "                                   ? ShapeIndex()",
          "content_same": false
        },
        {
          "line": 3432,
          "old_api": "slice_starts",
          "new_api": "ShapeIndex",
          "old_text": "slice->slice_starts(dim)",
          "new_text": "ShapeIndex({i})",
          "old_line_content": "                index.GetConstantWithIndexType(slice->slice_starts(dim)));",
          "new_line_content": "                                   : ShapeIndex({i});",
          "content_same": false
        },
        {
          "line": 3434,
          "old_api": "opcode",
          "new_api": "GetIrArray",
          "old_text": "slice_or_tuple->opcode()",
          "new_text": "GetIrArray(*unnested_hlo, *unnested_hlo, shape_index)",
          "old_line_content": "      ShapeIndex shape_index = (slice_or_tuple->opcode() == HloOpcode::kSlice)",
          "new_line_content": "          GetIrArray(*unnested_hlo, *unnested_hlo, shape_index);",
          "content_same": false
        },
        {
          "line": 3435,
          "old_api": "ShapeIndex",
          "new_api": "shape",
          "old_text": "ShapeIndex()",
          "new_text": "slice->shape()",
          "old_line_content": "                                   ? ShapeIndex()",
          "new_line_content": "      IrArray::Index slice_dst_index(dst_multidim, slice->shape(),",
          "content_same": false
        },
        {
          "line": 3436,
          "old_api": "ShapeIndex",
          "new_api": "GetType",
          "old_text": "ShapeIndex({i})",
          "new_text": "index.GetType()",
          "old_line_content": "                                   : ShapeIndex({i});",
          "new_line_content": "                                     index.GetType());",
          "content_same": false
        },
        {
          "line": 3439,
          "old_api": "shape",
          "new_api": "CreateStore",
          "old_text": "slice->shape()",
          "new_text": "b_.CreateStore(input_ir_values[i], dst_addr)",
          "old_line_content": "      IrArray::Index slice_dst_index(dst_multidim, slice->shape(),",
          "new_line_content": "      b_.CreateStore(input_ir_values[i], dst_addr);",
          "content_same": false
        },
        {
          "line": 3460,
          "old_api": "get",
          "new_api": "EmitLoop",
          "old_text": "kernel_thunk.get()",
          "new_text": "ParallelLoopEmitter(\n          [&](const llvm_ir::IrArray::Index index) -> Status {\n            EmitElementForInputFusibleSlices(unnested_hlo, index);\n            return Status::OK();\n          },\n          element_shape, launch_dimensions, &b_)\n          .EmitLoop(IrName(unnested_hlo),\n                    GetIndexTypeForKernel(\n                        unnested_hlo, launch_dimensions.launch_bound(), &b_))",
          "old_line_content": "  UpdateLaunchDimensions(launch_dimensions, kernel_thunk.get(),",
          "new_line_content": "      ParallelLoopEmitter(",
          "content_same": false
        },
        {
          "line": 3466,
          "old_api": "EmitElementForInputFusibleSlices",
          "new_api": "IrName",
          "old_text": "EmitElementForInputFusibleSlices(unnested_hlo, index)",
          "new_text": "IrName(unnested_hlo)",
          "old_line_content": "            EmitElementForInputFusibleSlices(unnested_hlo, index);",
          "new_line_content": "          .EmitLoop(IrName(unnested_hlo),",
          "content_same": false
        },
        {
          "line": 3467,
          "old_api": "Status::OK()",
          "new_api": "launch_bound",
          "old_text": "Status::OK()",
          "new_text": "GetIndexTypeForKernel(\n                        unnested_hlo, launch_dimensions.launch_bound(), &b_)",
          "old_line_content": "            return Status::OK();",
          "new_line_content": "                    GetIndexTypeForKernel(",
          "content_same": false
        },
        {
          "line": 3470,
          "old_api": "IrName",
          "new_api": "std::move(kernel_thunk)",
          "old_text": "IrName(unnested_hlo)",
          "new_text": "std::move(kernel_thunk)",
          "old_line_content": "          .EmitLoop(IrName(unnested_hlo),",
          "new_line_content": "  thunk_sequence_->emplace_back(std::move(kernel_thunk));",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2048,
          "old_api": null,
          "new_api": "unroll",
          "old_text": null,
          "new_text": "unroll(/*add_index_boundary_condition=*/false, vector_size)",
          "old_line_content": "                  // it will be the exact number of elements left.",
          "new_line_content": "                    unroll(/*add_index_boundary_condition=*/false, vector_size);",
          "content_same": false
        },
        {
          "line": 2051,
          "old_api": null,
          "new_api": "unroll",
          "old_text": null,
          "new_text": "unroll(/*add_index_boundary_condition=*/true, vector_size)",
          "old_line_content": "                  [&] {",
          "new_line_content": "                    unroll(/*add_index_boundary_condition=*/true, vector_size);",
          "content_same": false
        },
        {
          "line": 2054,
          "old_api": null,
          "new_api": "unroll",
          "old_text": null,
          "new_text": "unroll(/*add_index_boundary_condition=*/!x_tile_fits, vector_size)",
          "old_line_content": "                  [&] {",
          "new_line_content": "          unroll(/*add_index_boundary_condition=*/!x_tile_fits, vector_size);",
          "content_same": false
        },
        {
          "line": 2072,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "b_.getInt64(0)",
          "old_line_content": "    const KernelMappingScheme& mapping_scheme, llvm::Value* y_loc,",
          "new_line_content": "      Load(GEP(param_shmem_buffers[0], {b_.getInt64(0), x_loc, y_loc}),",
          "content_same": false
        },
        {
          "line": 2074,
          "old_api": null,
          "new_api": "GetIrArray",
          "old_text": null,
          "new_text": "GetIrArray(*hlo, *hlo)",
          "old_line_content": "  // TODO(jlebar): Add AA metadata to this load.",
          "new_line_content": "  llvm_ir::IrArray output_array = GetIrArray(*hlo, *hlo);",
          "content_same": false
        },
        {
          "line": 2075,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "ShapeUtil::MakeShapeWithDescendingLayout(\n      hlo->shape().element_type(), mapping_scheme.GetDimsInElems())",
          "old_line_content": "  llvm::Instruction* load_from_shmem_buffer =",
          "new_line_content": "  Shape output_reduced_shape = ShapeUtil::MakeShapeWithDescendingLayout(",
          "content_same": false
        },
        {
          "line": 2087,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "normalized_shape_index.size()",
          "old_line_content": "static IrArray::Index GetUnnormalizedIndex(",
          "new_line_content": "  DCHECK_EQ(normalized_shape_index.size(), 3);",
          "content_same": false
        },
        {
          "line": 2088,
          "old_api": null,
          "new_api": "Linearize",
          "old_text": null,
          "new_text": "normalized_shape_index.Linearize(\n      kernel_mapping_scheme.GetDimsInElems(), b_)",
          "old_line_content": "    const IrArray::Index& normalized_shape_index,",
          "new_line_content": "  llvm::Value* linear = normalized_shape_index.Linearize(",
          "content_same": false
        },
        {
          "line": 2089,
          "old_api": null,
          "new_api": "GetDimsInElems",
          "old_text": null,
          "new_text": "kernel_mapping_scheme.GetDimsInElems()",
          "old_line_content": "    const Shape& unnormalized_shape, llvm::IRBuilder<>* b_,",
          "new_line_content": "      kernel_mapping_scheme.GetDimsInElems(), b_);",
          "content_same": false
        },
        {
          "line": 2090,
          "old_api": null,
          "new_api": "IrArray::Index(linear, unnormalized_shape, b_)",
          "old_text": null,
          "new_text": "IrArray::Index(linear, unnormalized_shape, b_)",
          "old_line_content": "    const KernelMappingScheme& kernel_mapping_scheme) {",
          "new_line_content": "  return IrArray::Index(linear, unnormalized_shape, b_);",
          "content_same": false
        },
        {
          "line": 2104,
          "old_api": null,
          "new_api": "ConstructIrArrayForOutputs",
          "old_text": null,
          "new_text": "ConstructIrArrayForOutputs(*hlo)",
          "old_line_content": "void IrEmitterUnnested::EmitTileElementForFusion(",
          "new_line_content": "  std::vector<IrArray> output_arrays = ConstructIrArrayForOutputs(*hlo);",
          "content_same": false
        },
        {
          "line": 2106,
          "old_api": null,
          "new_api": "GetNestedComputer",
          "old_text": null,
          "new_text": "GetNestedComputer()",
          "old_line_content": "    const KernelMappingScheme& mapping_scheme, llvm::Value* y_loc,",
          "new_line_content": "                                     GetNestedComputer());",
          "content_same": false
        },
        {
          "line": 2107,
          "old_api": null,
          "new_api": "GetGeneratorForOperandIrArrays",
          "old_text": null,
          "new_text": "GetGeneratorForOperandIrArrays(hlo)",
          "old_line_content": "    llvm::Value* x_loc, absl::Span<llvm::Value* const> param_shmem_buffers) {",
          "new_line_content": "  FusedIrEmitter fused_emitter(GetGeneratorForOperandIrArrays(hlo),",
          "content_same": false
        },
        {
          "line": 2112,
          "old_api": null,
          "new_api": "GetShape",
          "old_text": null,
          "new_text": "GetUnnormalizedIndex(\n      index, output_arrays[0].GetShape(), &b_, mapping_scheme)",
          "old_line_content": "                               &elem_emitter, x_loc, y_loc,",
          "new_line_content": "  IrArray::Index untiled_index = GetUnnormalizedIndex(",
          "content_same": false
        },
        {
          "line": 2113,
          "old_api": null,
          "new_api": "GetShape",
          "old_text": null,
          "new_text": "output_arrays[0].GetShape()",
          "old_line_content": "                               param_shmem_buffers);",
          "new_line_content": "      index, output_arrays[0].GetShape(), &b_, mapping_scheme);",
          "content_same": false
        },
        {
          "line": 2118,
          "old_api": null,
          "new_api": "getType",
          "old_text": null,
          "new_text": "output_value->getType()->isStructTy()",
          "old_line_content": "  const llvm_ir::ElementGenerator& output_generator =",
          "new_line_content": "    DCHECK(output_value->getType()->isStructTy());",
          "content_same": false
        },
        {
          "line": 2135,
          "old_api": null,
          "new_api": "GetKernelMappingScheme",
          "old_text": null,
          "new_text": "reduction_info.GetKernelMappingScheme()",
          "old_line_content": "// reduction.",
          "new_line_content": "      reduction_info.GetKernelMappingScheme();",
          "content_same": false
        },
        {
          "line": 2136,
          "old_api": null,
          "new_api": "IsRowReduction",
          "old_text": null,
          "new_text": "reduction_info.IsRowReduction()",
          "old_line_content": "static int GetNumberOfPartialResults(",
          "new_line_content": "  if (reduction_info.IsRowReduction()) {",
          "content_same": false
        },
        {
          "line": 2141,
          "old_api": null,
          "new_api": "GetTileSizeX",
          "old_text": null,
          "new_text": "CHECK_EQ(num_partial_results,\n           (mapping_scheme.GetTileSizeX() / mapping_scheme.GetNumThreadsX()))",
          "old_line_content": "    return 1;",
          "new_line_content": "  CHECK_EQ(num_partial_results,",
          "content_same": false
        },
        {
          "line": 2142,
          "old_api": null,
          "new_api": "GetNumThreadsX",
          "old_text": null,
          "new_text": "mapping_scheme.GetNumThreadsX()",
          "old_line_content": "  }",
          "new_line_content": "           (mapping_scheme.GetTileSizeX() / mapping_scheme.GetNumThreadsX()));",
          "content_same": false
        },
        {
          "line": 2150,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "unnested_hlo->ToString()",
          "old_line_content": "void IrEmitterUnnested::EmitPrologueForReduction(",
          "new_line_content": "  VLOG(10) << \"Emit prologue for reduction: \" << unnested_hlo->ToString();",
          "content_same": false
        },
        {
          "line": 2152,
          "old_api": null,
          "new_api": "llvm_module",
          "old_text": null,
          "new_text": "ir_emitter_context_->llvm_module()",
          "old_line_content": "    absl::Span<HloInstruction* const> reduce_instructions,",
          "new_line_content": "                                          ir_emitter_context_->llvm_module(),",
          "content_same": false
        },
        {
          "line": 2153,
          "old_api": null,
          "new_api": "GetNestedComputer",
          "old_text": null,
          "new_text": "GetNestedComputer()",
          "old_line_content": "    llvm::Type* index_type) {",
          "new_line_content": "                                          &b_, GetNestedComputer());",
          "content_same": false
        },
        {
          "line": 2155,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "reduce_instructions.size()",
          "old_line_content": "  GpuElementalIrEmitter elemental_emitter(hlo_module_config_,",
          "new_line_content": "  for (int i = 0; i < reduce_instructions.size(); i++) {",
          "content_same": false
        },
        {
          "line": 2167,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "reduce_inst->shape().element_type()",
          "old_line_content": "",
          "new_line_content": "        llvm_ir::PrimitiveTypeToIrType(reduce_inst->shape().element_type(),",
          "content_same": false
        },
        {
          "line": 2168,
          "old_api": null,
          "new_api": "llvm_module",
          "old_text": null,
          "new_text": "ir_emitter_context_->llvm_module()",
          "old_line_content": "    AddressVector* reduction_input_addresses =",
          "new_line_content": "                                       ir_emitter_context_->llvm_module());",
          "content_same": false
        },
        {
          "line": 2170,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "reduction_input_addresses->push_back(reduction_input_address)",
          "old_line_content": "    llvm::Type* element_type =",
          "new_line_content": "    reduction_input_addresses->push_back(reduction_input_address);",
          "content_same": false
        },
        {
          "line": 2177,
          "old_api": null,
          "new_api": "llvm::Twine(i)",
          "old_text": null,
          "new_text": "llvm::Twine(i)",
          "old_line_content": "    AddressVector* partial_result_addresses =",
          "new_line_content": "               \"partial_reduction_result.\" + llvm::Twine(i));",
          "content_same": false
        },
        {
          "line": 2183,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "unnested_hlo->opcode()",
          "old_line_content": "",
          "new_line_content": "    if (unnested_hlo->opcode() == HloOpcode::kFusion) {",
          "content_same": false
        },
        {
          "line": 2184,
          "old_api": null,
          "new_api": "GetGeneratorForOperandIrArrays",
          "old_text": null,
          "new_text": "GetGeneratorForOperandIrArrays(unnested_hlo)",
          "old_line_content": "    // Initialize the partial result with the initial value of the reduction.",
          "new_line_content": "      FusedIrEmitter fused_emitter(GetGeneratorForOperandIrArrays(unnested_hlo),",
          "content_same": false
        },
        {
          "line": 2189,
          "old_api": null,
          "new_api": "GetGenerator",
          "old_text": null,
          "new_text": "fused_emitter\n              .GetGenerator(init_value)(IrArray::Index(b_.getInt32Ty()))\n              .ValueOrDie()",
          "old_line_content": "                                   &elemental_emitter);",
          "new_line_content": "          fused_emitter",
          "content_same": false
        },
        {
          "line": 2190,
          "old_api": null,
          "new_api": "getInt32Ty",
          "old_text": null,
          "new_text": "b_.getInt32Ty()",
          "old_line_content": "",
          "new_line_content": "              .GetGenerator(init_value)(IrArray::Index(b_.getInt32Ty()))",
          "content_same": false
        },
        {
          "line": 2195,
          "old_api": null,
          "new_api": "getInt32Ty",
          "old_text": null,
          "new_text": "b_.getInt32Ty()",
          "old_line_content": "              .ValueOrDie();",
          "new_line_content": "              .EmitReadArrayElement(IrArray::Index(b_.getInt32Ty()), &b_);",
          "content_same": false
        },
        {
          "line": 2200,
          "old_api": null,
          "new_api": "getInt32",
          "old_text": null,
          "new_text": "b_.getInt32(i)",
          "old_line_content": "    }",
          "new_line_content": "            InBoundsGEP(partial_result_address, {b_.getInt32(i)}));",
          "content_same": false
        },
        {
          "line": 2202,
          "old_api": null,
          "new_api": "GetMutableInitialValues",
          "old_text": null,
          "new_text": "reduction_info->GetMutableInitialValues()->push_back(init_ir_value)",
          "old_line_content": "    for (int i = 0; i < num_partial_results; ++i) {",
          "new_line_content": "    reduction_info->GetMutableInitialValues()->push_back(init_ir_value);",
          "content_same": false
        },
        {
          "line": 2205,
          "old_api": null,
          "new_api": "GetNumThreadsX",
          "old_text": null,
          "new_text": "mapping_scheme.GetNumThreadsX()",
          "old_line_content": "    }",
          "new_line_content": "    int64 num_threads_x = mapping_scheme.GetNumThreadsX();",
          "content_same": false
        },
        {
          "line": 2207,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "reduce_inst->shape().element_type()",
          "old_line_content": "",
          "new_line_content": "        reduce_inst->shape().element_type(), module_);",
          "content_same": false
        },
        {
          "line": 2219,
          "old_api": null,
          "new_api": "GetNumThreadsY",
          "old_text": null,
          "new_text": "mapping_scheme.GetNumThreadsY()",
          "old_line_content": "        // Allocate __shared__",
          "new_line_content": "        CHECK_EQ(num_threads_x, mapping_scheme.GetNumThreadsY());",
          "content_same": false
        },
        {
          "line": 2220,
          "old_api": null,
          "new_api": "llvm::ArrayType::get(\n            llvm::ArrayType::get(\n                llvm::ArrayType::get(primitive_type, num_threads_x + 1),\n                num_threads_x),\n            num_partial_results)",
          "old_text": null,
          "new_text": "llvm::ArrayType::get(\n            llvm::ArrayType::get(\n                llvm::ArrayType::get(primitive_type, num_threads_x + 1),\n                num_threads_x),\n            num_partial_results)",
          "old_line_content": "        // cache[num_partial_results][num_threads][num_threads + 1], where",
          "new_line_content": "        return llvm::ArrayType::get(",
          "content_same": false
        },
        {
          "line": 2221,
          "old_api": null,
          "new_api": "llvm::ArrayType::get(\n                llvm::ArrayType::get(primitive_type, num_threads_x + 1),\n                num_threads_x)",
          "old_text": null,
          "new_text": "llvm::ArrayType::get(\n                llvm::ArrayType::get(primitive_type, num_threads_x + 1),\n                num_threads_x)",
          "old_line_content": "        // num_threads == num_threads_x == num_threads_y.  The \"+1\" is used to",
          "new_line_content": "            llvm::ArrayType::get(",
          "content_same": false
        },
        {
          "line": 2222,
          "old_api": null,
          "new_api": "llvm::ArrayType::get(primitive_type, num_threads_x + 1)",
          "old_text": null,
          "new_text": "llvm::ArrayType::get(primitive_type, num_threads_x + 1)",
          "old_line_content": "        // avoid bank conflicts.",
          "new_line_content": "                llvm::ArrayType::get(primitive_type, num_threads_x + 1),",
          "content_same": false
        },
        {
          "line": 2228,
          "old_api": null,
          "new_api": "GetInsertBlock",
          "old_text": null,
          "new_text": "b_.GetInsertBlock()->getModule()",
          "old_line_content": "            num_partial_results);",
          "new_line_content": "        llvm_ir::AllocateSharedMemoryTile(b_.GetInsertBlock()->getModule(),",
          "content_same": false
        },
        {
          "line": 2230,
          "old_api": null,
          "new_api": "absl::StrCat(\"shared_cache_\", i)",
          "old_text": null,
          "new_text": "absl::StrCat(\"shared_cache_\", i)",
          "old_line_content": "    }();",
          "new_line_content": "                                          absl::StrCat(\"shared_cache_\", i));",
          "content_same": false
        },
        {
          "line": 2231,
          "old_api": null,
          "new_api": "GetMutableSharedCache",
          "old_text": null,
          "new_text": "reduction_info->GetMutableSharedCache()->push_back(shared_cache_per_reduce)",
          "old_line_content": "    llvm::GlobalVariable* shared_cache_per_reduce =",
          "new_line_content": "    reduction_info->GetMutableSharedCache()->push_back(shared_cache_per_reduce);",
          "content_same": false
        },
        {
          "line": 2238,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "partial_result_addresses.size()",
          "old_line_content": "",
          "new_line_content": "  CHECK_EQ(reducers.size(), partial_result_addresses.size());",
          "content_same": false
        },
        {
          "line": 2239,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "reducers.size()",
          "old_line_content": "void IrEmitterUnnested::EmitFullWarpShuffleDownLoopForAllReduces(",
          "new_line_content": "  for (int i = 0; i != reducers.size(); i++) {",
          "content_same": false
        },
        {
          "line": 2240,
          "old_api": null,
          "new_api": "getType",
          "old_text": null,
          "new_text": "EmitFullWarpShuffleDownLoopForReduce(\n        reducers[i], partial_result_addresses[i]->getType()->getElementType(),\n        partial_result_addresses[i])",
          "old_line_content": "    absl::Span<HloComputation* const> reducers,",
          "new_line_content": "    EmitFullWarpShuffleDownLoopForReduce(",
          "content_same": false
        },
        {
          "line": 2241,
          "old_api": null,
          "new_api": "getType",
          "old_text": null,
          "new_text": "partial_result_addresses[i]->getType()->getElementType()",
          "old_line_content": "    absl::Span<llvm::AllocaInst* const> partial_result_addresses) {",
          "new_line_content": "        reducers[i], partial_result_addresses[i]->getType()->getElementType(),",
          "content_same": false
        },
        {
          "line": 2250,
          "old_api": null,
          "new_api": "llvm_ir::GetSizeInBits(element_type)",
          "old_text": null,
          "new_text": "llvm_ir::GetSizeInBits(element_type)",
          "old_line_content": "void IrEmitterUnnested::EmitFullWarpShuffleDownLoopForReduce(",
          "new_line_content": "    int bit_width = llvm_ir::GetSizeInBits(element_type);",
          "content_same": false
        },
        {
          "line": 2252,
          "old_api": null,
          "new_api": "Alloca",
          "old_text": null,
          "new_text": "Alloca(element_type, nullptr, \"result_from_other_lane\")",
          "old_line_content": "    llvm::Value* partial_result_address) {",
          "new_line_content": "        Alloca(element_type, nullptr, \"result_from_other_lane\");",
          "content_same": false
        },
        {
          "line": 2258,
          "old_api": null,
          "new_api": "CreatePointerBitCastOrAddrSpaceCast",
          "old_text": null,
          "new_text": "b_.CreatePointerBitCastOrAddrSpaceCast(\n          ptr, shuffled_value_type->getPointerTo())",
          "old_line_content": "    // we bitcast addresses of load/store to intN* of the same bit-width.",
          "new_line_content": "      return b_.CreatePointerBitCastOrAddrSpaceCast(",
          "content_same": false
        },
        {
          "line": 2259,
          "old_api": null,
          "new_api": "getPointerTo",
          "old_text": null,
          "new_text": "shuffled_value_type->getPointerTo()",
          "old_line_content": "    llvm::Type* shuffled_value_type =",
          "new_line_content": "          ptr, shuffled_value_type->getPointerTo());",
          "content_same": false
        },
        {
          "line": 2264,
          "old_api": null,
          "new_api": "getInt32",
          "old_text": null,
          "new_text": "b_.getInt32(distance)",
          "old_line_content": "    };",
          "new_line_content": "    Store(EmitFullWarpShuffleDown(partial_result, b_.getInt32(distance), &b_),",
          "content_same": false
        },
        {
          "line": 2265,
          "old_api": null,
          "new_api": "convert_pointer_for_shuffle",
          "old_text": null,
          "new_text": "convert_pointer_for_shuffle(result_from_other_lane)",
          "old_line_content": "    llvm::Value* partial_result =",
          "new_line_content": "          convert_pointer_for_shuffle(result_from_other_lane));",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": null,
          "new_api": "GetKernelMappingScheme",
          "old_text": null,
          "new_text": "reduction_info.GetKernelMappingScheme()",
          "old_line_content": "static llvm::Value* GetUntransposedOutputLinearAddress(",
          "new_line_content": "      reduction_info.GetKernelMappingScheme();",
          "content_same": false
        },
        {
          "line": 2280,
          "old_api": null,
          "new_api": "IsRowReduction",
          "old_text": null,
          "new_text": "reduction_info.IsRowReduction()",
          "old_line_content": "    llvm::IRBuilder<>* b, const llvm_ir::IrArray::Index& index,",
          "new_line_content": "  if (reduction_info.IsRowReduction()) {",
          "content_same": false
        },
        {
          "line": 2285,
          "old_api": null,
          "new_api": "GetDimsInElems",
          "old_text": null,
          "new_text": "kernel_mapping_scheme.GetDimsInElems()",
          "old_line_content": "    // For row-reduction, y-coordinate determines which row we write into.",
          "new_line_content": "  absl::Span<const int64> dims_in_elem = kernel_mapping_scheme.GetDimsInElems();",
          "content_same": false
        },
        {
          "line": 2286,
          "old_api": null,
          "new_api": "GetConstantWithIndexType",
          "old_text": null,
          "new_text": "index.GetConstantWithIndexType(dims_in_elem[kDimX])",
          "old_line_content": "    return index[kDimY];",
          "new_line_content": "  llvm::Value* x_dim_size = index.GetConstantWithIndexType(dims_in_elem[kDimX]);",
          "content_same": false
        },
        {
          "line": 2287,
          "old_api": null,
          "new_api": "CreateMul",
          "old_text": null,
          "new_text": "b->CreateMul(index[kDimZ], x_dim_size)",
          "old_line_content": "  }",
          "new_line_content": "  llvm::Value* x_block_offset = b->CreateMul(index[kDimZ], x_dim_size);",
          "content_same": false
        },
        {
          "line": 2288,
          "old_api": null,
          "new_api": "CreateAdd",
          "old_text": null,
          "new_text": "b->CreateAdd(x_block_offset, index[kDimX])",
          "old_line_content": "  // For column reduction, we get the transposed address.",
          "new_line_content": "  return b->CreateAdd(x_block_offset, index[kDimX]);",
          "content_same": false
        },
        {
          "line": 2299,
          "old_api": null,
          "new_api": "GetKernelMappingScheme",
          "old_text": null,
          "new_text": "reduction_info.GetKernelMappingScheme()",
          "old_line_content": "    absl::Span<const ShapeIndex> reduction_output_shape_indices,",
          "new_line_content": "      reduction_info.GetKernelMappingScheme();",
          "content_same": false
        },
        {
          "line": 2301,
          "old_api": null,
          "new_api": "llvm::ConstantInt::get(index_ty, c)",
          "old_text": null,
          "new_text": "llvm::ConstantInt::get(index_ty, c)",
          "old_line_content": "    const TilingKernelInfo& tiling_kernel_info) {",
          "new_line_content": "    return llvm::ConstantInt::get(index_ty, c);",
          "content_same": false
        },
        {
          "line": 2306,
          "old_api": null,
          "new_api": "GetNumThreadsX",
          "old_text": null,
          "new_text": "mapping_scheme.GetNumThreadsX()",
          "old_line_content": "  };",
          "new_line_content": "                       mapping_scheme.GetNumThreadsX());",
          "content_same": false
        },
        {
          "line": 2308,
          "old_api": null,
          "new_api": "IsRowReduction",
          "old_text": null,
          "new_text": "[&] {\n    llvm::Value* x_loc = thread_id_info.thread_id_x;\n    llvm::Value* y_loc = thread_id_info.thread_id_y;\n    if (!reduction_info.IsRowReduction()) {\n      std::swap(x_loc, y_loc);\n    }\n    llvm::Value* start_offset_x =\n        GetStartOffsetX(mapping_scheme, x_loc, index_ty, &b_);\n    return tiling_kernel_info.tile_origin.AddOffsetToDim(y_loc, kDimY, &b_)\n        .AddOffsetToDim(start_offset_x, kDimX, &b_);\n  }()",
          "old_line_content": "  IrEmitterUnnested::ThreadIdInfo thread_id_info =",
          "new_line_content": "  IrArray::Index start_offset = [&] {",
          "content_same": false
        },
        {
          "line": 2311,
          "old_api": null,
          "new_api": "IsRowReduction",
          "old_text": null,
          "new_text": "reduction_info.IsRowReduction()",
          "old_line_content": "",
          "new_line_content": "    if (!reduction_info.IsRowReduction()) {",
          "content_same": false
        },
        {
          "line": 2322,
          "old_api": null,
          "new_api": "GetPartialResultAddresses",
          "old_text": null,
          "new_text": "reduction_info.GetPartialResultAddresses()",
          "old_line_content": "  }();",
          "new_line_content": "      reduction_info.GetPartialResultAddresses();",
          "content_same": false
        },
        {
          "line": 2331,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "ShapeUtil::FilterDimensions(\n        [&](int64 dim) {\n          return !absl::c_linear_search(reduce_hlo->dimensions(), dim);\n        },\n        reduce_hlo->operand(0)->shape())",
          "old_line_content": "  // output element. For row reduction, this is only for lane 0 due to the",
          "new_line_content": "    Shape reduction_kept_element_shape = ShapeUtil::FilterDimensions(",
          "content_same": false
        },
        {
          "line": 2333,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "reduce_hlo->dimensions()",
          "old_line_content": "  for (int i = 0; i != num_reduces; ++i) {",
          "new_line_content": "          return !absl::c_linear_search(reduce_hlo->dimensions(), dim);",
          "content_same": false
        },
        {
          "line": 2338,
          "old_api": null,
          "new_api": "AddOffsetToDim",
          "old_text": null,
          "new_text": "GetUntransposedOutputLinearAddress(\n              &b_, start_offset.AddOffsetToDim(constant(j), kDimX, &b_),\n              reduction_info)",
          "old_line_content": "        },",
          "new_line_content": "          GetUntransposedOutputLinearAddress(",
          "content_same": false
        },
        {
          "line": 2350,
          "old_api": null,
          "new_api": "GetIrArray",
          "old_text": null,
          "new_text": "GetIrArray(*unnested_hlo, *unnested_hlo,\n                                     reduction_output_shape_indices[i])",
          "old_line_content": "      //",
          "new_line_content": "      auto output_array = GetIrArray(*unnested_hlo, *unnested_hlo,",
          "content_same": false
        },
        {
          "line": 2355,
          "old_api": null,
          "new_api": "multidim",
          "old_text": null,
          "new_text": "element_index.multidim()",
          "old_line_content": "                                     reduction_output_shape_indices[i]);",
          "new_line_content": "      IrArray::Index output_index(element_index.multidim(),",
          "content_same": false
        },
        {
          "line": 2356,
          "old_api": null,
          "new_api": "GetShape",
          "old_text": null,
          "new_text": "output_array.GetShape()",
          "old_line_content": "      IrArray::Index element_index(",
          "new_line_content": "                                  output_array.GetShape(),",
          "content_same": false
        },
        {
          "line": 2357,
          "old_api": null,
          "new_api": "GetType",
          "old_text": null,
          "new_text": "element_index.GetType()",
          "old_line_content": "          /*linear=*/untransposed_output_linear_address,",
          "new_line_content": "                                  element_index.GetType());",
          "content_same": false
        },
        {
          "line": 2358,
          "old_api": null,
          "new_api": "EmitArrayElementAddress",
          "old_text": null,
          "new_text": "output_array.EmitArrayElementAddress(\n          output_index, &b_, \"output_element_address\")",
          "old_line_content": "          reduction_kept_element_shape, &b_);",
          "new_line_content": "      llvm::Value* output_address = output_array.EmitArrayElementAddress(",
          "content_same": false
        },
        {
          "line": 2363,
          "old_api": null,
          "new_api": "GetSharedCache",
          "old_text": null,
          "new_text": "reduction_info.GetSharedCache()",
          "old_line_content": "          output_index, &b_, \"output_element_address\");",
          "new_line_content": "      llvm::GlobalVariable* shared_cache = reduction_info.GetSharedCache()[i];",
          "content_same": false
        },
        {
          "line": 2368,
          "old_api": null,
          "new_api": "CreateAddrSpaceCast",
          "old_text": null,
          "new_text": "b_.CreateAddrSpaceCast(\n            input,\n            llvm::PointerType::get(input->getType()->getPointerElementType(),\n                                   /*AddressSpace=*/0),\n            name)",
          "old_line_content": "",
          "new_line_content": "        return b_.CreateAddrSpaceCast(",
          "content_same": false
        },
        {
          "line": 2370,
          "old_api": null,
          "new_api": "getType",
          "old_text": null,
          "new_text": "input->getType()->getPointerElementType()",
          "old_line_content": "      // global address space before writing or reading.",
          "new_line_content": "            llvm::PointerType::get(input->getType()->getPointerElementType(),",
          "content_same": false
        },
        {
          "line": 2376,
          "old_api": null,
          "new_api": "constant",
          "old_text": null,
          "new_text": "constant(0)",
          "old_line_content": "            name);",
          "new_line_content": "        return b_.CreateICmpEQ(value, constant(0));",
          "content_same": false
        },
        {
          "line": 2381,
          "old_api": null,
          "new_api": "getType",
          "old_text": null,
          "new_text": "partial_result_addresses[i]->getType()->getElementType()",
          "old_line_content": "      };",
          "new_line_content": "          partial_result_addresses[i]->getType()->getElementType();",
          "content_same": false
        },
        {
          "line": 2382,
          "old_api": null,
          "new_api": "IsRowReduction",
          "old_text": null,
          "new_text": "reduction_info.IsRowReduction()",
          "old_line_content": "",
          "new_line_content": "      if (reduction_info.IsRowReduction()) {",
          "content_same": false
        },
        {
          "line": 2383,
          "old_api": null,
          "new_api": "EmitFullWarpShuffleDownLoopForReduce",
          "old_text": null,
          "new_text": "EmitFullWarpShuffleDownLoopForReduce(reducers[i], element_type,\n                                             current_output)",
          "old_line_content": "      KernelSupportLibrary ksl(&b_);",
          "new_line_content": "        EmitFullWarpShuffleDownLoopForReduce(reducers[i], element_type,",
          "content_same": false
        },
        {
          "line": 2389,
          "old_api": null,
          "new_api": "CreateInBoundsGEP",
          "old_text": null,
          "new_text": "b_.CreateInBoundsGEP(\n                  shared_cache, {b_.getInt32(0), constant(j), warp_id})",
          "old_line_content": "        llvm::Value* warp_id =",
          "new_line_content": "              shared_to_global(b_.CreateInBoundsGEP(",
          "content_same": false
        },
        {
          "line": 2396,
          "old_api": null,
          "new_api": "CreateInBoundsGEP",
          "old_text": null,
          "new_text": "b_.CreateInBoundsGEP(\n              shared_cache,\n              {b_.getInt32(0), constant(j), thread_id_info.lane_id})",
          "old_line_content": "        });",
          "new_line_content": "          llvm::Value* block_accum_addr = shared_to_global(b_.CreateInBoundsGEP(",
          "content_same": false
        },
        {
          "line": 2401,
          "old_api": null,
          "new_api": "llvm_ir::EmitAllocaAtFunctionEntry(\n                  element_type, \"initial_value_addr\", &b_)",
          "old_text": null,
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n                  element_type, \"initial_value_addr\", &b_)",
          "old_line_content": "              shared_cache,",
          "new_line_content": "              shared_to_global(llvm_ir::EmitAllocaAtFunctionEntry(",
          "content_same": false
        },
        {
          "line": 2412,
          "old_api": null,
          "new_api": "EmitFullWarpShuffleDownLoopForReduce",
          "old_text": null,
          "new_text": "EmitFullWarpShuffleDownLoopForReduce(\n              reducers[i], element_type,\n              /*block_accum_addr*/ selected_value)",
          "old_line_content": "",
          "new_line_content": "          EmitFullWarpShuffleDownLoopForReduce(",
          "content_same": false
        },
        {
          "line": 2415,
          "old_api": null,
          "new_api": "is_zero",
          "old_text": null,
          "new_text": "is_zero(thread_id_info.thread_id_x)",
          "old_line_content": "",
          "new_line_content": "          ksl.If(is_zero(thread_id_info.thread_id_x), [&] {",
          "content_same": false
        },
        {
          "line": 2422,
          "old_api": null,
          "new_api": "CreateInBoundsGEP",
          "old_text": null,
          "new_text": "shared_to_global(\n            b_.CreateInBoundsGEP(shared_cache, {b_.getInt32(0), constant(j),\n                                                thread_id_info.thread_id_x,\n                                                thread_id_info.thread_id_y}),\n            \"shmem_output_address\")",
          "old_line_content": "          });",
          "new_line_content": "        llvm::Value* shmem_output_addr = shared_to_global(",
          "content_same": false
        },
        {
          "line": 2423,
          "old_api": null,
          "new_api": "constant",
          "old_text": null,
          "new_text": "constant(j)",
          "old_line_content": "        });",
          "new_line_content": "            b_.CreateInBoundsGEP(shared_cache, {b_.getInt32(0), constant(j),",
          "content_same": false
        },
        {
          "line": 2428,
          "old_api": null,
          "new_api": "CreateStore",
          "old_text": null,
          "new_text": "b_.CreateStore(current_output_value, shmem_output_addr)",
          "old_line_content": "                                                thread_id_info.thread_id_x,",
          "new_line_content": "        b_.CreateStore(current_output_value, shmem_output_addr);",
          "content_same": false
        },
        {
          "line": 2430,
          "old_api": null,
          "new_api": "EmitSyncThreads",
          "old_text": null,
          "new_text": "EmitSyncThreads()",
          "old_line_content": "            \"shmem_output_address\");",
          "new_line_content": "        EmitSyncThreads();",
          "content_same": false
        },
        {
          "line": 2436,
          "old_api": null,
          "new_api": "constant",
          "old_text": null,
          "new_text": "constant(j)",
          "old_line_content": "        // Get transposed element from shared memory.",
          "new_line_content": "                {b_.getInt32(0), constant(j), thread_id_info.thread_id_y,",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": null,
          "new_api": "CreateAnd",
          "old_text": null,
          "new_text": "b_.CreateAnd(\n            b_.CreateICmpULT(\n                GetStartOffsetX(mapping_scheme, thread_id_info.thread_id_y,\n                                index_ty, &b_),\n                tiling_kernel_info.output_tile_bounds[kDimX]),\n            b_.CreateICmpULT(thread_id_info.thread_id_x,\n                             tiling_kernel_info.output_tile_bounds[kDimY]))",
          "old_line_content": "                                             shmem_transposed_addr);",
          "new_line_content": "        llvm::Value* has_output = b_.CreateAnd(",
          "content_same": false
        },
        {
          "line": 2446,
          "old_api": null,
          "new_api": "CreateICmpULT",
          "old_text": null,
          "new_text": "b_.CreateICmpULT(\n                GetStartOffsetX(mapping_scheme, thread_id_info.thread_id_y,\n                                index_ty, &b_),\n                tiling_kernel_info.output_tile_bounds[kDimX])",
          "old_line_content": "",
          "new_line_content": "            b_.CreateICmpULT(",
          "content_same": false
        },
        {
          "line": 2447,
          "old_api": null,
          "new_api": "GetStartOffsetX",
          "old_text": null,
          "new_text": "GetStartOffsetX(mapping_scheme, thread_id_info.thread_id_y,\n                                index_ty, &b_)",
          "old_line_content": "        // Some threads in the block are completely outside of the bound of the",
          "new_line_content": "                GetStartOffsetX(mapping_scheme, thread_id_info.thread_id_y,",
          "content_same": false
        },
        {
          "line": 2453,
          "old_api": null,
          "new_api": "is_zero",
          "old_text": null,
          "new_text": "is_zero(thread_id_info.lane_id)",
          "old_line_content": "                tiling_kernel_info.output_tile_bounds[kDimX]),",
          "new_line_content": "        ksl.If(b_.CreateAnd(has_output, is_zero(thread_id_info.lane_id)), [&] {",
          "content_same": false
        },
        {
          "line": 2463,
          "old_api": null,
          "new_api": "gpu::EmitCallToTargetIntrinsic(gpu::TargetIntrinsicID::kBlockIdx, {},\n                                        {}, &b_)",
          "old_text": null,
          "new_text": "gpu::EmitCallToTargetIntrinsic(gpu::TargetIntrinsicID::kBlockIdx, {},\n                                        {}, &b_)",
          "old_line_content": "  }",
          "new_line_content": "  return gpu::EmitCallToTargetIntrinsic(gpu::TargetIntrinsicID::kBlockIdx, {},",
          "content_same": false
        },
        {
          "line": 2471,
          "old_api": null,
          "new_api": "getInt32Ty",
          "old_text": null,
          "new_text": "b_.getInt32Ty()",
          "old_line_content": "void IrEmitterUnnested::EmitPrintfWithThreadId(",
          "new_line_content": "  llvm::Value* thread_id = EmitThreadId(1024, b_.getInt32Ty());",
          "content_same": false
        },
        {
          "line": 2472,
          "old_api": null,
          "new_api": "EmitBlockId",
          "old_text": null,
          "new_text": "EmitBlockId()",
          "old_line_content": "    absl::string_view fmt, absl::Span<llvm::Value* const> arguments,",
          "new_line_content": "  llvm::Value* block_id = EmitBlockId();",
          "content_same": false
        },
        {
          "line": 2474,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "arguments.begin()",
          "old_line_content": "    absl::optional<int64> block_id_filter) {",
          "new_line_content": "  updated_arguments.insert(updated_arguments.end(), arguments.begin(),",
          "content_same": false
        },
        {
          "line": 2498,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "unnested_hlo->ToString()",
          "old_line_content": "    absl::Span<HloInstruction* const> output_instructions,",
          "new_line_content": "  VLOG(10) << \"Emit tile element for reduce \" << unnested_hlo->ToString();",
          "content_same": false
        },
        {
          "line": 2499,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "output_instructions.size()",
          "old_line_content": "    const llvm_ir::IrArray::Index& index,",
          "new_line_content": "  bool returns_tuple = output_instructions.size() > 1;",
          "content_same": false
        },
        {
          "line": 2500,
          "old_api": null,
          "new_api": "IsRowReduction",
          "old_text": null,
          "new_text": "reduction_info.IsRowReduction()",
          "old_line_content": "    const ReductionCodegenInfo& reduction_info,",
          "new_line_content": "  int partial_result_index = reduction_info.IsRowReduction() ? 0 : x_iter_num;",
          "content_same": false
        },
        {
          "line": 2506,
          "old_api": null,
          "new_api": "GetNestedComputer",
          "old_text": null,
          "new_text": "GetNestedComputer()",
          "old_line_content": "  InlinedVector<llvm_ir::ElementGenerator, 1> input_gens;",
          "new_line_content": "                                     GetNestedComputer());",
          "content_same": false
        },
        {
          "line": 2507,
          "old_api": null,
          "new_api": "GetGeneratorForOperandIrArrays",
          "old_text": null,
          "new_text": "GetGeneratorForOperandIrArrays(unnested_hlo)",
          "old_line_content": "  std::vector<std::pair<llvm_ir::ElementGenerator, ShapeIndex>>",
          "new_line_content": "  FusedIrEmitter fused_emitter(GetGeneratorForOperandIrArrays(unnested_hlo),",
          "content_same": false
        },
        {
          "line": 2512,
          "old_api": null,
          "new_api": "fused_expression_root",
          "old_text": null,
          "new_text": "unnested_hlo->fused_expression_root()->Accept(&fused_emitter)",
          "old_line_content": "                               &elem_emitter);",
          "new_line_content": "    TF_CHECK_OK(unnested_hlo->fused_expression_root()->Accept(&fused_emitter));",
          "content_same": false
        },
        {
          "line": 2514,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "output_instructions.size()",
          "old_line_content": "  // the group of output instructions.",
          "new_line_content": "    for (int i = 0, e = output_instructions.size(); i != e; ++i) {",
          "content_same": false
        },
        {
          "line": 2517,
          "old_api": null,
          "new_api": "IsReductionFromOrToContiguousDimensions",
          "old_text": null,
          "new_text": "IsReductionFromOrToContiguousDimensions(*inst)",
          "old_line_content": "",
          "new_line_content": "      if (IsReductionFromOrToContiguousDimensions(*inst)) {",
          "content_same": false
        },
        {
          "line": 2526,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "unnested_hlo->operand(0)",
          "old_line_content": "      }",
          "new_line_content": "      return GetIrArray(*unnested_hlo->operand(0), *unnested_hlo)",
          "content_same": false
        },
        {
          "line": 2532,
          "old_api": null,
          "new_api": "GetKernelMappingScheme",
          "old_text": null,
          "new_text": "GetUnnormalizedIndex(index, reduction_operand_shape, &b_,\n                           reduction_info.GetKernelMappingScheme())",
          "old_line_content": "    });",
          "new_line_content": "      GetUnnormalizedIndex(index, reduction_operand_shape, &b_,",
          "content_same": false
        },
        {
          "line": 2533,
          "old_api": null,
          "new_api": "GetKernelMappingScheme",
          "old_text": null,
          "new_text": "reduction_info.GetKernelMappingScheme()",
          "old_line_content": "  }",
          "new_line_content": "                           reduction_info.GetKernelMappingScheme());",
          "content_same": false
        },
        {
          "line": 2538,
          "old_api": null,
          "new_api": "GetNumberOfPartialResults",
          "old_text": null,
          "new_text": "GetNumberOfPartialResults(reduction_info)",
          "old_line_content": "  // Clear the linear index field of the IrArray::Index to enable the use of",
          "new_line_content": "  int num_partial_results = GetNumberOfPartialResults(reduction_info);",
          "content_same": false
        },
        {
          "line": 2539,
          "old_api": null,
          "new_api": "multidim",
          "old_text": null,
          "new_text": "IrArray::Index(\n      input_index.multidim(), reduction_operand_shape, input_index.GetType())",
          "old_line_content": "  // GetElementPointer with array types. This enables the vectorization of",
          "new_line_content": "  auto index_without_linear = IrArray::Index(",
          "content_same": false
        },
        {
          "line": 2540,
          "old_api": null,
          "new_api": "GetType",
          "old_text": null,
          "new_text": "input_index.GetType()",
          "old_line_content": "  // the computation for different partial results. Use this index if",
          "new_line_content": "      input_index.multidim(), reduction_operand_shape, input_index.GetType());",
          "content_same": false
        },
        {
          "line": 2546,
          "old_api": null,
          "new_api": "GetReductionInputAddresses",
          "old_text": null,
          "new_text": "reduction_info.GetReductionInputAddresses()",
          "old_line_content": "  // Emit code to generate the input and perform the reduction computation for",
          "new_line_content": "        reduction_info.GetReductionInputAddresses()[i];",
          "content_same": false
        },
        {
          "line": 2553,
          "old_api": null,
          "new_api": "Store",
          "old_text": null,
          "new_text": "Store(input_ir_value, input_address)",
          "old_line_content": "    llvm::Value* const input_ir_value =",
          "new_line_content": "    Store(input_ir_value, input_address);",
          "content_same": false
        },
        {
          "line": 2555,
          "old_api": null,
          "new_api": "getInt32",
          "old_text": null,
          "new_text": "b_.getInt32(partial_result_index)",
          "old_line_content": "                                              : input_index)",
          "new_line_content": "        partial_reduction_result_address, {b_.getInt32(partial_result_index)});",
          "content_same": false
        },
        {
          "line": 2556,
          "old_api": null,
          "new_api": "EmitCallToNestedComputation",
          "old_text": null,
          "new_text": "EmitCallToNestedComputation(\n        *reducers[i], {partial_result_address, input_address},\n        partial_result_address)",
          "old_line_content": "            .ValueOrDie();",
          "new_line_content": "    TF_CHECK_OK(EmitCallToNestedComputation(",
          "content_same": false
        },
        {
          "line": 2563,
          "old_api": null,
          "new_api": "EmitExtraOutputsForReduce",
          "old_text": null,
          "new_text": "EmitExtraOutputsForReduce(\n      unnested_hlo, input_index,\n      /*use_linear_index=*/num_partial_results == 1, extra_output_gens)",
          "old_line_content": "  }",
          "new_line_content": "  TF_CHECK_OK(EmitExtraOutputsForReduce(",
          "content_same": false
        },
        {
          "line": 2572,
          "old_api": null,
          "new_api": "gpu::EmitCallToTargetIntrinsic(\n      gpu::TargetIntrinsicID::kThreadIdx, {}, {}, &b_)",
          "old_text": null,
          "new_text": "gpu::EmitCallToTargetIntrinsic(\n      gpu::TargetIntrinsicID::kThreadIdx, {}, {}, &b_)",
          "old_line_content": "llvm::Value* IrEmitterUnnested::EmitThreadId(int64 threads_per_block,",
          "new_line_content": "  llvm::CallInst* thread_id_raw = gpu::EmitCallToTargetIntrinsic(",
          "content_same": false
        },
        {
          "line": 2574,
          "old_api": null,
          "new_api": "llvm_ir::AddRangeMetadata(0, threads_per_block, thread_id_raw)",
          "old_text": null,
          "new_text": "llvm_ir::AddRangeMetadata(0, threads_per_block, thread_id_raw)",
          "old_line_content": "  // Calculate (y, x) coordinates respectively in the 2D view of thread block,",
          "new_line_content": "  llvm_ir::AddRangeMetadata(0, threads_per_block, thread_id_raw);",
          "content_same": false
        },
        {
          "line": 2575,
          "old_api": null,
          "new_api": "CreateIntCast",
          "old_text": null,
          "new_text": "b_.CreateIntCast(thread_id_raw, index_ty,\n                          /*isSigned=*/true, \"thread.id.x\")",
          "old_line_content": "  // defined by (num_thread_y, num_thread_x) from thread_id.",
          "new_line_content": "  return b_.CreateIntCast(thread_id_raw, index_ty,",
          "content_same": false
        },
        {
          "line": 2582,
          "old_api": null,
          "new_api": "llvm::ConstantInt::get(index_ty, c)",
          "old_text": null,
          "new_text": "llvm::ConstantInt::get(index_ty, c)",
          "old_line_content": "",
          "new_line_content": "    return llvm::ConstantInt::get(index_ty, c);",
          "content_same": false
        },
        {
          "line": 2584,
          "old_api": null,
          "new_api": "EmitThreadId",
          "old_text": null,
          "new_text": "EmitThreadId(threads_per_block, index_ty)",
          "old_line_content": "    int64 threads_per_block, llvm::Type* index_ty, int64 num_threads_x) {",
          "new_line_content": "  llvm::Value* thread_id = EmitThreadId(threads_per_block, index_ty);",
          "content_same": false
        },
        {
          "line": 2585,
          "old_api": null,
          "new_api": "constant",
          "old_text": null,
          "new_text": "constant(num_threads_x)",
          "old_line_content": "  auto constant = [&](uint64 c) -> llvm::Constant* {",
          "new_line_content": "  llvm::Value* num_threads_x_v = constant(num_threads_x);",
          "content_same": false
        },
        {
          "line": 2590,
          "old_api": null,
          "new_api": "constant",
          "old_text": null,
          "new_text": "constant(kWarpSize)",
          "old_line_content": "  return {",
          "new_line_content": "      /*lane_id=*/b_.CreateURem(thread_id, constant(kWarpSize), \"lane_id\")};",
          "content_same": false
        },
        {
          "line": 2596,
          "old_api": null,
          "new_api": "GetDimsInElems",
          "old_text": null,
          "new_text": "mapping_scheme.GetDimsInElems()",
          "old_line_content": "",
          "new_line_content": "  absl::Span<const int64> dims_in_elems = mapping_scheme.GetDimsInElems();",
          "content_same": false
        },
        {
          "line": 2598,
          "old_api": null,
          "new_api": "GetTileSizeZ",
          "old_text": null,
          "new_text": "mapping_scheme.GetTileSizeZ()",
          "old_line_content": "    const KernelMappingScheme& mapping_scheme, llvm::Type* index_ty,",
          "new_line_content": "      CeilOfRatio(dims_in_elems[0], mapping_scheme.GetTileSizeZ()),",
          "content_same": false
        },
        {
          "line": 2599,
          "old_api": null,
          "new_api": "GetTileSizeY",
          "old_text": null,
          "new_text": "mapping_scheme.GetTileSizeY()",
          "old_line_content": "    const TileElementGenerator& tile_element_generator) {",
          "new_line_content": "      CeilOfRatio(dims_in_elems[1], mapping_scheme.GetTileSizeY()),",
          "content_same": false
        },
        {
          "line": 2607,
          "old_api": null,
          "new_api": "GetNumThreadsX",
          "old_text": null,
          "new_text": "mapping_scheme.GetNumThreadsX()",
          "old_line_content": "  };",
          "new_line_content": "                       mapping_scheme.GetNumThreadsX());",
          "content_same": false
        },
        {
          "line": 2612,
          "old_api": null,
          "new_api": "EmitBlockId",
          "old_text": null,
          "new_text": "EmitBlockId()",
          "old_line_content": "",
          "new_line_content": "    llvm::Value* block_id = EmitBlockId();",
          "content_same": false
        },
        {
          "line": 2613,
          "old_api": null,
          "new_api": "GetNumberOfBlocks",
          "old_text": null,
          "new_text": "mapping_scheme.GetNumberOfBlocks()",
          "old_line_content": "  KernelSupportLibrary ksl(&b_, llvm_ir::UnrollMode::kDefaultUnroll);",
          "new_line_content": "    llvm_ir::AddRangeMetadata(0, mapping_scheme.GetNumberOfBlocks(),",
          "content_same": false
        },
        {
          "line": 2614,
          "old_api": null,
          "new_api": "llvm::cast<llvm::Instruction>(block_id)",
          "old_text": null,
          "new_text": "llvm::cast<llvm::Instruction>(block_id)",
          "old_line_content": "",
          "new_line_content": "                              llvm::cast<llvm::Instruction>(block_id));",
          "content_same": false
        },
        {
          "line": 2623,
          "old_api": null,
          "new_api": "GetTileSizeZ",
          "old_text": null,
          "new_text": "mapping_scheme.GetTileSizeZ()",
          "old_line_content": "                                      PRED /*arbitrary*/, dims_in_blocks),",
          "new_line_content": "        b_.CreateMul(starting_block[0], constant(mapping_scheme.GetTileSizeZ()),",
          "content_same": false
        },
        {
          "line": 2626,
          "old_api": null,
          "new_api": "IrArray::Index(multidim, dims_in_blocks, index_ty)",
          "old_text": null,
          "new_text": "IrArray::Index(multidim, dims_in_blocks, index_ty)",
          "old_line_content": "    std::vector<llvm::Value*> multidim = {",
          "new_line_content": "    return IrArray::Index(multidim, dims_in_blocks, index_ty);",
          "content_same": false
        },
        {
          "line": 2631,
          "old_api": null,
          "new_api": "GetTileSizeFor",
          "old_text": null,
          "new_text": "mapping_scheme.GetTileSizeFor(i)",
          "old_line_content": "  }();",
          "new_line_content": "    int64 tile_size_for_dim = mapping_scheme.GetTileSizeFor(i);",
          "content_same": false
        },
        {
          "line": 2634,
          "old_api": null,
          "new_api": "constant",
          "old_text": null,
          "new_text": "constant(dims_in_blocks[i] - 1)",
          "old_line_content": "  for (int i = kDimY; i < kDimTot; ++i) {",
          "new_line_content": "        b_.CreateICmpEQ(block_coords[i], constant(dims_in_blocks[i] - 1));",
          "content_same": false
        },
        {
          "line": 2639,
          "old_api": null,
          "new_api": "constant",
          "old_text": null,
          "new_text": "constant(tile_size_for_dim)",
          "old_line_content": "    int64 partial_row =",
          "new_line_content": "                        constant(tile_size_for_dim), \"tile_bound\");",
          "content_same": false
        },
        {
          "line": 2644,
          "old_api": null,
          "new_api": "GetType",
          "old_text": null,
          "new_text": "block_coords.GetType()",
          "old_line_content": "  }",
          "new_line_content": "    llvm::Type* index_ty = block_coords.GetType();",
          "content_same": false
        },
        {
          "line": 2649,
          "old_api": null,
          "new_api": "std::to_string(i)",
          "old_text": null,
          "new_text": "std::to_string(i)",
          "old_line_content": "    for (int i = kDimY; i < kDimTot; ++i) {",
          "new_line_content": "          \"tile_origin.\" + std::to_string(i));",
          "content_same": false
        },
        {
          "line": 2651,
          "old_api": null,
          "new_api": "GetDimsInElems",
          "old_text": null,
          "new_text": "mapping_scheme.GetDimsInElems()",
          "old_line_content": "          block_coords[i],",
          "new_line_content": "    return IrArray::Index(elem_multi_index, mapping_scheme.GetDimsInElems(),",
          "content_same": false
        },
        {
          "line": 2656,
          "old_api": null,
          "new_api": "tile_element_generator",
          "old_text": null,
          "new_text": "tile_element_generator(thread_id_info, tile, \"output\",\n                           output_tile_bounds[1], output_tile_bounds[2], &ksl)",
          "old_line_content": "                          index_ty);",
          "new_line_content": "    tile_element_generator(thread_id_info, tile, \"output\",",
          "content_same": false
        },
        {
          "line": 2661,
          "old_api": null,
          "new_api": "emit_tile",
          "old_text": null,
          "new_text": "emit_tile(tile_origin)",
          "old_line_content": "                           output_tile_bounds[1], output_tile_bounds[2], &ksl);",
          "new_line_content": "    emit_tile(tile_origin);",
          "content_same": false
        },
        {
          "line": 2666,
          "old_api": null,
          "new_api": "CreateUDiv",
          "old_text": null,
          "new_text": "b_.CreateUDiv(starting_tile_index_for_dim, block_size_for_dim)",
          "old_line_content": "  } else {",
          "new_line_content": "        b_.CreateUDiv(starting_tile_index_for_dim, block_size_for_dim);",
          "content_same": false
        },
        {
          "line": 2667,
          "old_api": null,
          "new_api": "constant",
          "old_text": null,
          "new_text": "constant(dims_in_blocks[kDimZ] - 1)",
          "old_line_content": "    llvm::Value* starting_tile_index_for_dim = tile_origin[kDimZ];",
          "new_line_content": "    llvm::Value* last_block_for_dim = constant(dims_in_blocks[kDimZ] - 1);",
          "content_same": false
        },
        {
          "line": 2669,
          "old_api": null,
          "new_api": "GetTileSizeZ",
          "old_text": null,
          "new_text": "constant(dims_in_elems[kDimZ] -\n                 (dims_in_blocks[kDimZ] - 1) * mapping_scheme.GetTileSizeZ())",
          "old_line_content": "    llvm::Value* block_id_for_dim =",
          "new_line_content": "        constant(dims_in_elems[kDimZ] -",
          "content_same": false
        },
        {
          "line": 2675,
          "old_api": null,
          "new_api": "For",
          "old_text": null,
          "new_text": "ksl.For(\"loop_z\",\n            /*start=*/constant(0),\n            /*end=*/num_tiles_in_block,\n            /*step=*/1, [&](llvm::Value* block_dim_induction_var) {\n              IrArray::Index tile_index = tile_origin.AddOffsetToDim(\n                  block_dim_induction_var, kDimZ, &b_);\n              emit_tile(tile_index);\n            })",
          "old_line_content": "",
          "new_line_content": "    ksl.For(\"loop_z\",",
          "content_same": false
        },
        {
          "line": 2676,
          "old_api": null,
          "new_api": "constant",
          "old_text": null,
          "new_text": "constant(0)",
          "old_line_content": "    llvm::Value* num_tiles_in_block =",
          "new_line_content": "            /*start=*/constant(0),",
          "content_same": false
        },
        {
          "line": 2681,
          "old_api": null,
          "new_api": "emit_tile",
          "old_text": null,
          "new_text": "emit_tile(tile_index)",
          "old_line_content": "            /*end=*/num_tiles_in_block,",
          "new_line_content": "              emit_tile(tile_index);",
          "content_same": false
        },
        {
          "line": 2688,
          "old_api": null,
          "new_api": "EmitCallToTargetIntrinsic",
          "old_text": null,
          "new_text": "EmitCallToTargetIntrinsic(TargetIntrinsicID::kBarrierId, {}, {}, &b_)",
          "old_line_content": "  return {output_tile_bounds, tile_origin};",
          "new_line_content": "  return EmitCallToTargetIntrinsic(TargetIntrinsicID::kBarrierId, {}, {}, &b_);",
          "content_same": false
        },
        {
          "line": 2719,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "void IrEmitterUnnested::EmitHlo021Tile(",
          "new_line_content": "  constexpr int kNumRows = 4;",
          "content_same": false
        },
        {
          "line": 2726,
          "old_api": null,
          "new_api": "GetNumberOfBlocks",
          "old_text": null,
          "new_text": "mapping_scheme.GetNumberOfBlocks()",
          "old_line_content": "                                     /*num_threads_y=*/kNumRows,",
          "new_line_content": "  LaunchDimensions launch_dimensions(mapping_scheme.GetNumberOfBlocks(),",
          "content_same": false
        },
        {
          "line": 2727,
          "old_api": null,
          "new_api": "GetThreadsPerBlock",
          "old_text": null,
          "new_text": "mapping_scheme.GetThreadsPerBlock()",
          "old_line_content": "                                     /*num_threads_x=*/kWarpSize,",
          "new_line_content": "                                     mapping_scheme.GetThreadsPerBlock());",
          "content_same": false
        },
        {
          "line": 2729,
          "old_api": null,
          "new_api": "launch_bound",
          "old_text": null,
          "new_text": "launch_dimensions.launch_bound()",
          "old_line_content": "                                     /*vector_size=*/1);",
          "new_line_content": "      GetIndexTypeForKernel(hlo, launch_dimensions.launch_bound(), &b_);",
          "content_same": false
        },
        {
          "line": 2735,
          "old_api": null,
          "new_api": "operand_count",
          "old_text": null,
          "new_text": "hlo->operand_count()",
          "old_line_content": "",
          "new_line_content": "  std::vector<llvm::Value*> param_shmem_buffers(hlo->operand_count(), nullptr);",
          "content_same": false
        },
        {
          "line": 2745,
          "old_api": null,
          "new_api": "GetTileSizeX",
          "old_text": null,
          "new_text": "llvm::ArrayType::get(\n        llvm::ArrayType::get(elem_ty, mapping_scheme.GetTileSizeX() + 1),\n        mapping_scheme.GetTileSizeY())",
          "old_line_content": "    // a the warp size as the size for tiling. This may cause all elements in",
          "new_line_content": "    llvm::Type* buffer_type = llvm::ArrayType::get(",
          "content_same": false
        },
        {
          "line": 2746,
          "old_api": null,
          "new_api": "GetTileSizeX",
          "old_text": null,
          "new_text": "mapping_scheme.GetTileSizeX()",
          "old_line_content": "    // the same column of a tile use the same memory bank and therefore shared",
          "new_line_content": "        llvm::ArrayType::get(elem_ty, mapping_scheme.GetTileSizeX() + 1),",
          "content_same": false
        },
        {
          "line": 2747,
          "old_api": null,
          "new_api": "GetTileSizeY",
          "old_text": null,
          "new_text": "mapping_scheme.GetTileSizeY()",
          "old_line_content": "    // memory bank conflicts. Adding 1 to the minor dimension of the shared",
          "new_line_content": "        mapping_scheme.GetTileSizeY());",
          "content_same": false
        },
        {
          "line": 2748,
          "old_api": null,
          "new_api": "GetInsertBlock",
          "old_text": null,
          "new_text": "b_.GetInsertBlock()->getModule()",
          "old_line_content": "    // memory buffer can reduce such shared memory bank conflicts.",
          "new_line_content": "    return llvm_ir::AllocateSharedMemoryTile(b_.GetInsertBlock()->getModule(),",
          "content_same": false
        },
        {
          "line": 2753,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "hlo->operand(id)",
          "old_line_content": "                                             buffer_type, buffer_name);",
          "new_line_content": "    const HloInstruction* param = hlo->operand(id);",
          "content_same": false
        },
        {
          "line": 2754,
          "old_api": null,
          "new_api": "GetIrArray",
          "old_text": null,
          "new_text": "GetIrArray(*param, *hlo)",
          "old_line_content": "  };",
          "new_line_content": "    param_arrays.push_back(GetIrArray(*param, *hlo));",
          "content_same": false
        },
        {
          "line": 2759,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "param->shape().element_type()",
          "old_line_content": "",
          "new_line_content": "                                       param->shape().element_type(), module_),",
          "content_same": false
        },
        {
          "line": 2761,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "      param_shmem_buffers[id] =",
          "new_line_content": "      VLOG(3) << \"Added shmem buffer for parameter \" << id << \": \"",
          "content_same": false
        },
        {
          "line": 2776,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "hlo->opcode()",
          "old_line_content": "",
          "new_line_content": "        if (hlo->opcode() == HloOpcode::kCopy) {",
          "content_same": false
        },
        {
          "line": 2777,
          "old_api": null,
          "new_api": "EmitTileElementForCopy",
          "old_text": null,
          "new_text": "EmitTileElementForCopy(hlo, index, mapping_scheme, y_loc, x_loc,\n                                 param_shmem_buffers)",
          "old_line_content": "  EmitElementFunction element_generator =",
          "new_line_content": "          EmitTileElementForCopy(hlo, index, mapping_scheme, y_loc, x_loc,",
          "content_same": false
        },
        {
          "line": 2793,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "tiled_param_ids.empty()",
          "old_line_content": "          llvm::Value* tile_width, KernelSupportLibrary* ksl) {",
          "new_line_content": "        if (!tiled_param_ids.empty()) {",
          "content_same": false
        },
        {
          "line": 2796,
          "old_api": null,
          "new_api": "multidim",
          "old_text": null,
          "new_text": "index.multidim()",
          "old_line_content": "        // thread copies it from input to tile. This is `__syncthreads` in CUDA.",
          "new_line_content": "              Permute({0, 2, 1}, index.multidim()),",
          "content_same": false
        },
        {
          "line": 2803,
          "old_api": null,
          "new_api": "EmitReadArrayElement",
          "old_text": null,
          "new_text": "EmitTile(mapping_scheme, input_tile_origin, \"input\", ksl,\n                   thread_id_info, tile_width, tile_height,\n                   [&](const IrArray::Index& index, llvm::Value* y_loc,\n                       llvm::Value* x_loc, int64 /*x_iter_num*/) {\n                     for (int64 id : tiled_param_ids) {\n                       IrArray& input_in_logical_shape =\n                           param_in_reduced_shape_arrays[id];\n\n                       llvm::Value* shmem_buffer = param_shmem_buffers[id];\n                       llvm::Value* zero =\n                           llvm::ConstantInt::get(index_type, 0);\n                       // TODO(jlebar): Add AA metadata to this store.  Tile\n                       // buffers are global variables, so LLVM can't infer much\n                       // about it.\n                       Store(input_in_logical_shape.EmitReadArrayElement(\n                                 index, &b_, \"input_element\"),\n                             GEP(shmem_buffer, {zero, y_loc, x_loc}));\n                     }\n                   })",
          "old_line_content": "          // Copy input parameter values to shared memory buffers:",
          "new_line_content": "          EmitTile(mapping_scheme, input_tile_origin, \"input\", ksl,",
          "content_same": false
        },
        {
          "line": 2813,
          "old_api": null,
          "new_api": "llvm::ConstantInt::get(index_type, 0)",
          "old_text": null,
          "new_text": "llvm::ConstantInt::get(index_type, 0)",
          "old_line_content": "                           param_in_reduced_shape_arrays[id];",
          "new_line_content": "                           llvm::ConstantInt::get(index_type, 0);",
          "content_same": false
        },
        {
          "line": 2819,
          "old_api": null,
          "new_api": "GEP",
          "old_text": null,
          "new_text": "GEP(shmem_buffer, {zero, y_loc, x_loc})",
          "old_line_content": "                       // buffers are global variables, so LLVM can't infer much",
          "new_line_content": "                             GEP(shmem_buffer, {zero, y_loc, x_loc}));",
          "content_same": false
        },
        {
          "line": 2825,
          "old_api": null,
          "new_api": "EmitSyncThreads",
          "old_text": null,
          "new_text": "EmitSyncThreads()",
          "old_line_content": "                   });",
          "new_line_content": "          EmitSyncThreads();",
          "content_same": false
        },
        {
          "line": 2828,
          "old_api": null,
          "new_api": "EmitTile",
          "old_text": null,
          "new_text": "EmitTile(mapping_scheme, index, loop_name, ksl, thread_id_info,\n                 tile_height, tile_width, element_generator)",
          "old_line_content": "          // CUDA.",
          "new_line_content": "        EmitTile(mapping_scheme, index, loop_name, ksl, thread_id_info,",
          "content_same": false
        },
        {
          "line": 2830,
          "old_api": null,
          "new_api": "GetTileSizeZ",
          "old_text": null,
          "new_text": "mapping_scheme.GetTileSizeZ()",
          "old_line_content": "        }",
          "new_line_content": "        bool block_contains_multi_tiles = mapping_scheme.GetTileSizeZ() > 1;",
          "content_same": false
        },
        {
          "line": 2836,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "tiled_param_ids.empty()",
          "old_line_content": "        // If a tile block contains multiple tiles and shared memory buffers are",
          "new_line_content": "        if (block_contains_multi_tiles && !tiled_param_ids.empty()) {",
          "content_same": false
        },
        {
          "line": 2837,
          "old_api": null,
          "new_api": "EmitSyncThreads",
          "old_text": null,
          "new_text": "EmitSyncThreads()",
          "old_line_content": "        // used, we need to wait for all threads to finish using the shared",
          "new_line_content": "          EmitSyncThreads();",
          "content_same": false
        },
        {
          "line": 2847,
          "old_api": null,
          "new_api": "IsMultiOutputFusion",
          "old_text": null,
          "new_text": "hlo->IsMultiOutputFusion()",
          "old_line_content": "  // at any point in the kernel, but we do it at the beginning in",
          "new_line_content": "  if (hlo->IsMultiOutputFusion()) {",
          "content_same": false
        },
        {
          "line": 2848,
          "old_api": null,
          "new_api": "IsBlock0Thread0",
          "old_text": null,
          "new_text": "IsBlock0Thread0(&b_)",
          "old_line_content": "  // the hopes of reducing register pressure, since we touch",
          "new_line_content": "    KernelSupportLibrary{&b_}.If(\"emit_mof_tuple\", IsBlock0Thread0(&b_), [&] {",
          "content_same": false
        },
        {
          "line": 2849,
          "old_api": null,
          "new_api": "GetIrArray",
          "old_text": null,
          "new_text": "GetIrArray(*hlo, *hlo)",
          "old_line_content": "  // threadIdx.x and blockIdx.x at the beginning of the kernel",
          "new_line_content": "      llvm_ir::EmitTuple(GetIrArray(*hlo, *hlo),",
          "content_same": false
        },
        {
          "line": 2850,
          "old_api": null,
          "new_api": "ConstructIrArrayForOutputs",
          "old_text": null,
          "new_text": "ConstructIrArrayForOutputs(*hlo)",
          "old_line_content": "  // *anyway*.",
          "new_line_content": "                         ConstructIrArrayForOutputs(*hlo), &b_);",
          "content_same": false
        },
        {
          "line": 2855,
          "old_api": null,
          "new_api": "llvm_module",
          "old_text": null,
          "new_text": "UpdateLaunchDimensions(launch_dimensions, kernel_thunk,\n                         ir_emitter_context_->llvm_module())",
          "old_line_content": "    });",
          "new_line_content": "  UpdateLaunchDimensions(launch_dimensions, kernel_thunk,",
          "content_same": false
        },
        {
          "line": 2856,
          "old_api": null,
          "new_api": "llvm_module",
          "old_text": null,
          "new_text": "ir_emitter_context_->llvm_module()",
          "old_line_content": "  }",
          "new_line_content": "                         ir_emitter_context_->llvm_module());",
          "content_same": false
        },
        {
          "line": 2899,
          "old_api": null,
          "new_api": "IsElementwise",
          "old_text": null,
          "new_text": "hlo->IsElementwise()",
          "old_line_content": "// a reduce operations. In this case, the above description on \"output\" apply",
          "new_line_content": "  if (hlo->IsElementwise()) {",
          "content_same": false
        },
        {
          "line": 2900,
          "old_api": null,
          "new_api": "users",
          "old_text": null,
          "new_text": "hlo->users()",
          "old_line_content": "// to the result of such a use-chain, which provides the input to the reduce",
          "new_line_content": "    return absl::c_all_of(hlo->users(), [&](const HloInstruction* user) {",
          "content_same": false
        },
        {
          "line": 2901,
          "old_api": null,
          "new_api": "IsInstructionSafeForShmemTranspose",
          "old_text": null,
          "new_text": "IsInstructionSafeForShmemTranspose(user)",
          "old_line_content": "// operation.",
          "new_line_content": "      return IsInstructionSafeForShmemTranspose(user);",
          "content_same": false
        },
        {
          "line": 2917,
          "old_api": null,
          "new_api": "users",
          "old_text": null,
          "new_text": "hlo->users()",
          "old_line_content": "    case HloOpcode::kMap:",
          "new_line_content": "      return absl::c_all_of(hlo->users(), [&](const HloInstruction* user) {",
          "content_same": false
        },
        {
          "line": 2918,
          "old_api": null,
          "new_api": "IsInstructionSafeForShmemTranspose",
          "old_text": null,
          "new_text": "IsInstructionSafeForShmemTranspose(user)",
          "old_line_content": "    case HloOpcode::kParameter:",
          "new_line_content": "        return IsInstructionSafeForShmemTranspose(user);",
          "content_same": false
        },
        {
          "line": 2941,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "input_ids.size()",
          "old_line_content": "// that can make preloading the input tile unsafe.",
          "new_line_content": "  for (int64 i = 0; i < input_ids.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2942,
          "old_api": null,
          "new_api": "fused_parameter",
          "old_text": null,
          "new_text": "fusion->fused_parameter(input_ids[i])",
          "old_line_content": "std::vector<int64> FilterInputsForShmemTranspose(const HloInstruction* fusion,",
          "new_line_content": "    const HloInstruction* input = fusion->fused_parameter(input_ids[i]);",
          "content_same": false
        },
        {
          "line": 2943,
          "old_api": null,
          "new_api": "IsInstructionSafeForShmemTranspose",
          "old_text": null,
          "new_text": "IsInstructionSafeForShmemTranspose(input)",
          "old_line_content": "                                                 std::vector<int64> input_ids) {",
          "new_line_content": "    if (IsInstructionSafeForShmemTranspose(input)) {",
          "content_same": false
        },
        {
          "line": 2944,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "filtered_input_ids.push_back(input_ids[i])",
          "old_line_content": "  std::vector<int64> filtered_input_ids;",
          "new_line_content": "      filtered_input_ids.push_back(input_ids[i]);",
          "content_same": false
        },
        {
          "line": 2955,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "hlo->opcode()",
          "old_line_content": "",
          "new_line_content": "  HloOpcode opcode = hlo->opcode();",
          "content_same": false
        },
        {
          "line": 2957,
          "old_api": null,
          "new_api": "IsLoopFusion",
          "old_text": null,
          "new_text": "hlo->IsLoopFusion()",
          "old_line_content": "",
          "new_line_content": "  CHECK(hlo->IsLoopFusion() || opcode == HloOpcode::kCopy);",
          "content_same": false
        },
        {
          "line": 2960,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "hlo->shape()",
          "old_line_content": "",
          "new_line_content": "                                  ? ShapeUtil::GetSubshape(hlo->shape(), {0})",
          "content_same": false
        },
        {
          "line": 2967,
          "old_api": null,
          "new_api": "operand_count",
          "old_text": null,
          "new_text": "hlo->operand_count()",
          "old_line_content": "  // If the output_shape is reduced to 021 shape, find all the parameters of",
          "new_line_content": "  for (int64 operand_idx = 0; operand_idx < hlo->operand_count();",
          "content_same": false
        },
        {
          "line": 2969,
          "old_api": null,
          "new_api": "mutable_operand",
          "old_text": null,
          "new_text": "hlo->mutable_operand(operand_idx)",
          "old_line_content": "  std::vector<int64> params_012;",
          "new_line_content": "    HloInstruction* operand = hlo->mutable_operand(operand_idx);",
          "content_same": false
        },
        {
          "line": 2972,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "find_transpose_result.has_value()",
          "old_line_content": "       ++operand_idx) {",
          "new_line_content": "    if (!find_transpose_result.has_value()) {",
          "content_same": false
        },
        {
          "line": 2979,
          "old_api": null,
          "new_api": "absl::c_equal(*reduced_dims_021, curr_reduced_dims_021)",
          "old_text": null,
          "new_text": "absl::c_equal(*reduced_dims_021, curr_reduced_dims_021)",
          "old_line_content": "    const std::vector<int64>& curr_reduced_dims_021 = *find_transpose_result;",
          "new_line_content": "    if (!absl::c_equal(*reduced_dims_021, curr_reduced_dims_021)) {",
          "content_same": false
        },
        {
          "line": 2984,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "params_012.push_back(operand_idx)",
          "old_line_content": "      // There is more than one possible transpose. Instead of picking one",
          "new_line_content": "    params_012.push_back(operand_idx);",
          "content_same": false
        },
        {
          "line": 2987,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "reduced_dims_021.has_value()",
          "old_line_content": "    }",
          "new_line_content": "  if (!reduced_dims_021.has_value()) {",
          "content_same": false
        },
        {
          "line": 2997,
          "old_api": null,
          "new_api": "FilterInputsForShmemTranspose",
          "old_text": null,
          "new_text": "FilterInputsForShmemTranspose(hlo, params_012)",
          "old_line_content": "    return false;",
          "new_line_content": "    params_012 = FilterInputsForShmemTranspose(hlo, params_012);",
          "content_same": false
        },
        {
          "line": 2998,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "params_012.empty()",
          "old_line_content": "  }",
          "new_line_content": "    if (params_012.empty()) {",
          "content_same": false
        },
        {
          "line": 3021,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "  //",
          "new_line_content": "  constexpr int kMinBlocksPerCore = 3;",
          "content_same": false
        },
        {
          "line": 3022,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "  // This is only sound if tiled transposes are the only place where we use",
          "new_line_content": "  constexpr int64 kShmemPerCore = 48 * 1024;",
          "content_same": false
        },
        {
          "line": 3024,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "params_012.size()",
          "old_line_content": "  // memory, we'll have to adjust this heuristic.",
          "new_line_content": "  for (int64 i = 0; i < params_012.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 3037,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "params_012.empty()",
          "old_line_content": "      break;",
          "new_line_content": "  if (params_012.empty()) {",
          "content_same": false
        },
        {
          "line": 3043,
          "old_api": null,
          "new_api": "BuildKernelThunk",
          "old_text": null,
          "new_text": "BuildKernelThunk(hlo, /*implements_whole_instruction=*/true)",
          "old_line_content": "  }",
          "new_line_content": "      BuildKernelThunk(hlo, /*implements_whole_instruction=*/true);",
          "content_same": false
        },
        {
          "line": 3044,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "kernel_thunk.get()",
          "old_line_content": "",
          "new_line_content": "  EmitHlo021Tile(hlo, kernel_thunk.get(), *reduced_dims_021, params_012);",
          "content_same": false
        },
        {
          "line": 3055,
          "old_api": null,
          "new_api": "users",
          "old_text": null,
          "new_text": "hlo->users()",
          "old_line_content": "// Returns true if all the transitive users of hlo before hitting users in",
          "new_line_content": "  return absl::c_all_of(hlo->users(), [&](const HloInstruction* user) {",
          "content_same": false
        },
        {
          "line": 3056,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "use_chain_endings.count(user)",
          "old_line_content": "// use_chain_endings are elementwise operations.",
          "new_line_content": "    return use_chain_endings.count(user) ||",
          "content_same": false
        },
        {
          "line": 3057,
          "old_api": null,
          "new_api": "IsElementwise",
          "old_text": null,
          "new_text": "user->IsElementwise()",
          "old_line_content": "bool AreUsersElementwise(const HloInstruction* hlo,",
          "new_line_content": "           (user->IsElementwise() &&",
          "content_same": false
        },
        {
          "line": 3058,
          "old_api": null,
          "new_api": "AreUsersElementwise",
          "old_text": null,
          "new_text": "AreUsersElementwise(user, use_chain_endings)",
          "old_line_content": "                         const ConstHloInstructionSet& use_chain_endings) {",
          "new_line_content": "            AreUsersElementwise(user, use_chain_endings));",
          "content_same": false
        },
        {
          "line": 3067,
          "old_api": null,
          "new_api": "fused_parameters",
          "old_text": null,
          "new_text": "absl::c_count_if(\n      unnested_hlo->fused_parameters(), [&](const HloInstruction* parameter) {\n        const Shape& parameter_shape = parameter->shape();\n        return ShapeUtil::SameDimensions(op_shape, parameter_shape) &&\n               AreUsersElementwise(parameter, use_chain_endings);\n      })",
          "old_line_content": "// given shape, and involve in only elementwise operations.",
          "new_line_content": "  return absl::c_count_if(",
          "content_same": false
        },
        {
          "line": 3068,
          "old_api": null,
          "new_api": "fused_parameters",
          "old_text": null,
          "new_text": "unnested_hlo->fused_parameters()",
          "old_line_content": "int64 NumInputsInvolveInOnlyElementwiseOps(",
          "new_line_content": "      unnested_hlo->fused_parameters(), [&](const HloInstruction* parameter) {",
          "content_same": false
        },
        {
          "line": 3069,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "parameter->shape()",
          "old_line_content": "    const HloInstruction* unnested_hlo, const Shape& op_shape,",
          "new_line_content": "        const Shape& parameter_shape = parameter->shape();",
          "content_same": false
        },
        {
          "line": 3070,
          "old_api": null,
          "new_api": "ShapeUtil::SameDimensions(op_shape, parameter_shape)",
          "old_text": null,
          "new_text": "ShapeUtil::SameDimensions(op_shape, parameter_shape)",
          "old_line_content": "    const ConstHloInstructionSet& use_chain_endings) {",
          "new_line_content": "        return ShapeUtil::SameDimensions(op_shape, parameter_shape) &&",
          "content_same": false
        },
        {
          "line": 3079,
          "old_api": null,
          "new_api": "ShapeUtil::ElementsIn(shape)",
          "old_text": null,
          "new_text": "ShapeUtil::ElementsIn(shape)",
          "old_line_content": "// Returns the number of fusion inputs that have more elements than the given",
          "new_line_content": "  int64 num_elements = ShapeUtil::ElementsIn(shape);",
          "content_same": false
        },
        {
          "line": 3080,
          "old_api": null,
          "new_api": "fused_parameters",
          "old_text": null,
          "new_text": "absl::c_count_if(\n      unnested_hlo->fused_parameters(), [&](const HloInstruction* parameter) {\n        return ShapeUtil::ElementsIn(parameter->shape()) > num_elements;\n      })",
          "old_line_content": "// shape.",
          "new_line_content": "  return absl::c_count_if(",
          "content_same": false
        },
        {
          "line": 3081,
          "old_api": null,
          "new_api": "fused_parameters",
          "old_text": null,
          "new_text": "unnested_hlo->fused_parameters()",
          "old_line_content": "int64 NumInputsWithMoreElementsThan(const HloInstruction* unnested_hlo,",
          "new_line_content": "      unnested_hlo->fused_parameters(), [&](const HloInstruction* parameter) {",
          "content_same": false
        },
        {
          "line": 3082,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "parameter->shape()",
          "old_line_content": "                                    const Shape& shape) {",
          "new_line_content": "        return ShapeUtil::ElementsIn(parameter->shape()) > num_elements;",
          "content_same": false
        },
        {
          "line": 3097,
          "old_api": null,
          "new_api": "static_cast<uint64>(num_kept_minor)",
          "old_text": null,
          "new_text": "static_cast<uint64>(num_kept_minor)",
          "old_line_content": "                                          const Shape& input_shape,",
          "new_line_content": "  if (!IsPowerOfTwo(static_cast<uint64>(num_kept_minor))) {",
          "content_same": false
        },
        {
          "line": 3108,
          "old_api": null,
          "new_api": "fused_expression_root",
          "old_text": null,
          "new_text": "unnested_hlo->fused_expression_root()",
          "old_line_content": "",
          "new_line_content": "  const HloInstruction* fused_root = unnested_hlo->fused_expression_root();",
          "content_same": false
        },
        {
          "line": 3110,
          "old_api": null,
          "new_api": "IsReductionFromOrToContiguousDimensions",
          "old_text": null,
          "new_text": "IsReductionFromOrToContiguousDimensions(*fused_root)",
          "old_line_content": "  int64 can_be_vectorized = 0;",
          "new_line_content": "  if (IsReductionFromOrToContiguousDimensions(*fused_root)) {",
          "content_same": false
        },
        {
          "line": 3111,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "use_chain_endings.insert(fused_root)",
          "old_line_content": "  int64 cannot_be_vectorized = 0;",
          "new_line_content": "    use_chain_endings.insert(fused_root);",
          "content_same": false
        },
        {
          "line": 3116,
          "old_api": null,
          "new_api": "operands",
          "old_text": null,
          "new_text": "fused_root->operands()",
          "old_line_content": "    // Atomic.add of the reduction result can't be vectorized.",
          "new_line_content": "    for (const HloInstruction* instr : fused_root->operands()) {",
          "content_same": false
        },
        {
          "line": 3117,
          "old_api": null,
          "new_api": "IsReductionFromOrToContiguousDimensions",
          "old_text": null,
          "new_text": "IsReductionFromOrToContiguousDimensions(*instr)",
          "old_line_content": "    cannot_be_vectorized++;",
          "new_line_content": "      if (IsReductionFromOrToContiguousDimensions(*instr)) {",
          "content_same": false
        },
        {
          "line": 3124,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "use_chain_endings.insert(instr)",
          "old_line_content": "      } else {",
          "new_line_content": "      use_chain_endings.insert(instr);",
          "content_same": false
        },
        {
          "line": 3129,
          "old_api": null,
          "new_api": "NumInputsInvolveInOnlyElementwiseOps",
          "old_text": null,
          "new_text": "NumInputsInvolveInOnlyElementwiseOps(\n      unnested_hlo, input_shape, use_chain_endings)",
          "old_line_content": "    }",
          "new_line_content": "  can_be_vectorized += NumInputsInvolveInOnlyElementwiseOps(",
          "content_same": false
        },
        {
          "line": 3137,
          "old_api": null,
          "new_api": "NumInputsWithMoreElementsThan",
          "old_text": null,
          "new_text": "NumInputsWithMoreElementsThan(unnested_hlo, input_shape)",
          "old_line_content": "  // for the purpose of estimating the benefit of unrolling. If the kernel is",
          "new_line_content": "      NumInputsWithMoreElementsThan(unnested_hlo, input_shape);",
          "content_same": false
        },
        {
          "line": 3145,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "first_reduce->operand(0)->shape()",
          "old_line_content": "}  // namespace",
          "new_line_content": "  const Shape& input_shape = first_reduce->operand(0)->shape();",
          "content_same": false
        },
        {
          "line": 3147,
          "old_api": null,
          "new_api": "GetReductionKindAndContiguousComponents",
          "old_text": null,
          "new_text": "GetReductionKindAndContiguousComponents(*first_reduce)",
          "old_line_content": "ReductionCodegenInfo IrEmitterUnnested::ComputeReductionCodegenInfo(",
          "new_line_content": "      GetReductionKindAndContiguousComponents(*first_reduce);",
          "content_same": false
        },
        {
          "line": 3148,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(10)",
          "old_line_content": "    const HloInstruction* unnested_hlo, const HloInstruction* first_reduce) {",
          "new_line_content": "  VLOG(10) << \"is_row_reduction \" << reduction_dimensions.is_row_reduction",
          "content_same": false
        },
        {
          "line": 3153,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "i->shape().element_type()",
          "old_line_content": "           << \" \" << reduction_dimensions.dimensions[0] << \" \"",
          "new_line_content": "    return primitive_util::BitWidth(i->shape().element_type());",
          "content_same": false
        },
        {
          "line": 3158,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "first_reduce->operand(0)",
          "old_line_content": "  };",
          "new_line_content": "  int smallest_input_dtype_bits = get_dtype_bits(first_reduce->operand(0));",
          "content_same": false
        },
        {
          "line": 3159,
          "old_api": null,
          "new_api": "operands",
          "old_text": null,
          "new_text": "unnested_hlo->operands()",
          "old_line_content": "",
          "new_line_content": "  for (xla::HloInstruction* input : unnested_hlo->operands()) {",
          "content_same": false
        },
        {
          "line": 3161,
          "old_api": null,
          "new_api": "get_dtype_bits",
          "old_text": null,
          "new_text": "get_dtype_bits(input)",
          "old_line_content": "  // select the reduction_tiling.",
          "new_line_content": "        std::min(get_dtype_bits(input), smallest_input_dtype_bits);",
          "content_same": false
        },
        {
          "line": 3164,
          "old_api": null,
          "new_api": "device_description",
          "old_text": null,
          "new_text": "GetReductionTiling(reduction_dimensions, smallest_input_dtype_bits,\n                         &ir_emitter_context_->device_description())",
          "old_line_content": "    smallest_input_dtype_bits =",
          "new_line_content": "      GetReductionTiling(reduction_dimensions, smallest_input_dtype_bits,",
          "content_same": false
        },
        {
          "line": 3178,
          "old_api": null,
          "new_api": "IsUnrollingColumnReductionBeneficial",
          "old_text": null,
          "new_text": "IsUnrollingColumnReductionBeneficial(\n                 unnested_hlo, input_shape,\n                 reduction_dimensions.dimensions[2])",
          "old_line_content": "      // For odd row size, every other row isn't aligned, so can't be",
          "new_line_content": "  } else if (IsUnrollingColumnReductionBeneficial(",
          "content_same": false
        },
        {
          "line": 3193,
          "old_api": null,
          "new_api": "[&] {\n    if (reduction_dimensions.is_row_reduction) {\n      return std::min(\n          kWarpSize * kWarpSize,\n          RoundUpToNearest(CeilOfRatio(reduction_dimensions.dimensions[2],\n                                       reduction_tiling[2]),\n                           kWarpSize));\n    }\n    return kWarpSize;\n  }()",
          "old_text": null,
          "new_text": "[&] {\n    if (reduction_dimensions.is_row_reduction) {\n      return std::min(\n          kWarpSize * kWarpSize,\n          RoundUpToNearest(CeilOfRatio(reduction_dimensions.dimensions[2],\n                                       reduction_tiling[2]),\n                           kWarpSize));\n    }\n    return kWarpSize;\n  }()",
          "old_line_content": "    reduction_tiling[2] *= 2;",
          "new_line_content": "  int64 num_threads_x = [&] {",
          "content_same": false
        },
        {
          "line": 3195,
          "old_api": null,
          "new_api": "std::min(\n          kWarpSize * kWarpSize,\n          RoundUpToNearest(CeilOfRatio(reduction_dimensions.dimensions[2],\n                                       reduction_tiling[2]),\n                           kWarpSize))",
          "old_text": null,
          "new_text": "std::min(\n          kWarpSize * kWarpSize,\n          RoundUpToNearest(CeilOfRatio(reduction_dimensions.dimensions[2],\n                                       reduction_tiling[2]),\n                           kWarpSize))",
          "old_line_content": "",
          "new_line_content": "      return std::min(",
          "content_same": false
        },
        {
          "line": 3211,
          "old_api": null,
          "new_api": "MayPreventVectorization",
          "old_text": null,
          "new_text": "MayPreventVectorization(*unnested_hlo)",
          "old_line_content": "  if (indexing_order == kLinearStridedIndexingX) {",
          "new_line_content": "        !MayPreventVectorization(*unnested_hlo)) {",
          "content_same": false
        },
        {
          "line": 3221,
          "old_api": null,
          "new_api": "ReductionCodegenInfo",
          "old_text": null,
          "new_text": "ReductionCodegenInfo(mapping_scheme,\n                              reduction_dimensions.is_row_reduction)",
          "old_line_content": "  KernelMappingScheme mapping_scheme(",
          "new_line_content": "  return ReductionCodegenInfo(mapping_scheme,",
          "content_same": false
        },
        {
          "line": 3228,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "output_instructions.size()",
          "old_line_content": "",
          "new_line_content": "  bool returns_tuple = output_instructions.size() > 1;",
          "content_same": false
        },
        {
          "line": 3229,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "unnested_hlo->ToString()",
          "old_line_content": "Status IrEmitterUnnested::EmitReductionFromOrToContiguousDimensions(",
          "new_line_content": "  VLOG(10) << \"Emitting reduction to vector \" << unnested_hlo->ToString();",
          "content_same": false
        },
        {
          "line": 3237,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "output_instructions.size()",
          "old_line_content": "  InlinedVector<HloComputation*, 1> reducers;",
          "new_line_content": "  for (int i = 0; i < output_instructions.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 3238,
          "old_api": null,
          "new_api": "IsReductionFromOrToContiguousDimensions",
          "old_text": null,
          "new_text": "IsReductionFromOrToContiguousDimensions(*output_instructions[i])",
          "old_line_content": "",
          "new_line_content": "    if (!IsReductionFromOrToContiguousDimensions(*output_instructions[i])) {",
          "content_same": false
        },
        {
          "line": 3243,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "reduce_instructions.push_back(output_instruction)",
          "old_line_content": "      continue;",
          "new_line_content": "    reduce_instructions.push_back(output_instruction);",
          "content_same": false
        },
        {
          "line": 3244,
          "old_api": null,
          "new_api": "ShapeIndex",
          "old_text": null,
          "new_text": "ShapeIndex({})",
          "old_line_content": "    }",
          "new_line_content": "    ShapeIndex idx = returns_tuple ? ShapeIndex({i}) : ShapeIndex({});",
          "content_same": false
        },
        {
          "line": 3245,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "reduction_output_shape_indices.push_back(idx)",
          "old_line_content": "",
          "new_line_content": "    reduction_output_shape_indices.push_back(idx);",
          "content_same": false
        },
        {
          "line": 3246,
          "old_api": null,
          "new_api": "to_apply",
          "old_text": null,
          "new_text": "output_instruction->to_apply()",
          "old_line_content": "    HloInstruction* output_instruction = output_instructions[i];",
          "new_line_content": "    reducers.push_back(output_instruction->to_apply());",
          "content_same": false
        },
        {
          "line": 3255,
          "old_api": null,
          "new_api": "AreFusedReductionOutputsConsistent",
          "old_text": null,
          "new_text": "AreFusedReductionOutputsConsistent(output_instructions,\n                                            first_reduce)",
          "old_line_content": "  }",
          "new_line_content": "    if (!AreFusedReductionOutputsConsistent(output_instructions,",
          "content_same": false
        },
        {
          "line": 3263,
          "old_api": null,
          "new_api": "BuildKernelThunk",
          "old_text": null,
          "new_text": "BuildKernelThunk(unnested_hlo, /*implements_whole_instruction=*/false)",
          "old_line_content": "  }",
          "new_line_content": "      BuildKernelThunk(unnested_hlo, /*implements_whole_instruction=*/false);",
          "content_same": false
        },
        {
          "line": 3265,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "first_reduce->operand(0)->shape()",
          "old_line_content": "  // Build a kernel thunk to compute all the outputs.",
          "new_line_content": "  const Shape& input_shape = first_reduce->operand(0)->shape();",
          "content_same": false
        },
        {
          "line": 3268,
          "old_api": null,
          "new_api": "has_layout",
          "old_text": null,
          "new_text": "input_shape.has_layout()",
          "old_line_content": "",
          "new_line_content": "  CHECK(input_shape.has_layout()) << \"LayoutAssignment or InstructionFusion \"",
          "content_same": false
        },
        {
          "line": 3270,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "first_reduce->ToString()",
          "old_line_content": "  // The layout of a reduction input is either set by LayoutAssignment for",
          "new_line_content": "                                  << first_reduce->ToString();",
          "content_same": false
        },
        {
          "line": 3273,
          "old_api": null,
          "new_api": "ComputeReductionCodegenInfo",
          "old_text": null,
          "new_text": "ComputeReductionCodegenInfo(unnested_hlo, first_reduce)",
          "old_line_content": "                                     \"doesn't set the input layout of \"",
          "new_line_content": "      ComputeReductionCodegenInfo(unnested_hlo, first_reduce);",
          "content_same": false
        },
        {
          "line": 3275,
          "old_api": null,
          "new_api": "GetKernelMappingScheme",
          "old_text": null,
          "new_text": "reduction_info.GetKernelMappingScheme()",
          "old_line_content": "",
          "new_line_content": "      reduction_info.GetKernelMappingScheme();",
          "content_same": false
        },
        {
          "line": 3276,
          "old_api": null,
          "new_api": "GetNumberOfBlocks",
          "old_text": null,
          "new_text": "mapping_scheme.GetNumberOfBlocks()",
          "old_line_content": "  ReductionCodegenInfo reduction_info =",
          "new_line_content": "  LaunchDimensions launch_dimensions(mapping_scheme.GetNumberOfBlocks(),",
          "content_same": false
        },
        {
          "line": 3278,
          "old_api": null,
          "new_api": "launch_bound",
          "old_text": null,
          "new_text": "GetIndexTypeForKernel(\n      unnested_hlo, launch_dimensions.launch_bound(), &b_)",
          "old_line_content": "  const KernelMappingScheme& mapping_scheme =",
          "new_line_content": "  llvm::Type* index_ty = GetIndexTypeForKernel(",
          "content_same": false
        },
        {
          "line": 3285,
          "old_api": null,
          "new_api": "EmitTileElementForReduction",
          "old_text": null,
          "new_text": "EmitTileElementForReduction(unnested_hlo, input_shape,\n                                    output_instructions, index, reduction_info,\n                                    reducers, x_iter_num)",
          "old_line_content": "                           index_ty);",
          "new_line_content": "        EmitTileElementForReduction(unnested_hlo, input_shape,",
          "content_same": false
        },
        {
          "line": 3290,
          "old_api": null,
          "new_api": "GetKernelMappingScheme",
          "old_text": null,
          "new_text": "EmitTilingKernel(\n      mapping_scheme, index_ty,\n      [&](const ThreadIdInfo& thread_id_info, const IrArray::Index& index,\n          const string& loop_name, llvm::Value* tile_height,\n          llvm::Value* tile_width, KernelSupportLibrary* ksl) {\n        EmitTile(reduction_info.GetKernelMappingScheme(), index, loop_name, ksl,\n                 thread_id_info, tile_height, tile_width, emit_reduction_tile);\n      })",
          "old_line_content": "                                    output_instructions, index, reduction_info,",
          "new_line_content": "  TilingKernelInfo tiling_kernel_info = EmitTilingKernel(",
          "content_same": false
        },
        {
          "line": 3295,
          "old_api": null,
          "new_api": "GetKernelMappingScheme",
          "old_text": null,
          "new_text": "reduction_info.GetKernelMappingScheme()",
          "old_line_content": "      mapping_scheme, index_ty,",
          "new_line_content": "        EmitTile(reduction_info.GetKernelMappingScheme(), index, loop_name, ksl,",
          "content_same": false
        },
        {
          "line": 3298,
          "old_api": null,
          "new_api": "EmitEpilogueForReduction",
          "old_text": null,
          "new_text": "EmitEpilogueForReduction(index_ty, unnested_hlo, reduction_info,\n                           reduce_instructions, reduction_output_shape_indices,\n                           reducers, tiling_kernel_info)",
          "old_line_content": "          llvm::Value* tile_width, KernelSupportLibrary* ksl) {",
          "new_line_content": "  EmitEpilogueForReduction(index_ty, unnested_hlo, reduction_info,",
          "content_same": false
        },
        {
          "line": 3303,
          "old_api": null,
          "new_api": "llvm_module",
          "old_text": null,
          "new_text": "ir_emitter_context_->llvm_module()",
          "old_line_content": "                           reduce_instructions, reduction_output_shape_indices,",
          "new_line_content": "                         ir_emitter_context_->llvm_module());",
          "content_same": false
        },
        {
          "line": 3305,
          "old_api": null,
          "new_api": "std::move(kernel_thunk)",
          "old_text": null,
          "new_text": "std::move(kernel_thunk)",
          "old_line_content": "",
          "new_line_content": "  thunks.push_back(std::move(kernel_thunk));",
          "content_same": false
        },
        {
          "line": 3308,
          "old_api": null,
          "new_api": "std::move(sequential_thunk)",
          "old_text": null,
          "new_text": "std::move(sequential_thunk)",
          "old_line_content": "",
          "new_line_content": "  AddThunkToThunkSequence(std::move(sequential_thunk));",
          "content_same": false
        },
        {
          "line": 3310,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "  auto sequential_thunk =",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3315,
          "old_api": null,
          "new_api": "Allocations",
          "old_text": null,
          "new_text": "ir_emitter_context_->buffer_assignment().Allocations()",
          "old_line_content": "}",
          "new_line_content": "       ir_emitter_context_->buffer_assignment().Allocations()) {",
          "content_same": false
        },
        {
          "line": 3316,
          "old_api": null,
          "new_api": "is_constant",
          "old_text": null,
          "new_text": "allocation.is_constant()",
          "old_line_content": "",
          "new_line_content": "    if (!allocation.is_constant()) {",
          "content_same": false
        },
        {
          "line": 3321,
          "old_api": null,
          "new_api": "ShouldEmitLiteralInLlvmIr",
          "old_text": null,
          "new_text": "ShouldEmitLiteralInLlvmIr(literal)",
          "old_line_content": "      continue;",
          "new_line_content": "    const bool should_emit_initializer = ShouldEmitLiteralInLlvmIr(literal);",
          "content_same": false
        },
        {
          "line": 3323,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "allocation.size()",
          "old_line_content": "",
          "new_line_content": "        llvm::ArrayType::get(b_.getInt8Ty(), allocation.size());",
          "content_same": false
        },
        {
          "line": 3326,
          "old_api": null,
          "new_api": "llvm_ir::ConvertLiteralToIrConstant(literal, module_)",
          "old_text": null,
          "new_text": "llvm_ir::ConvertLiteralToIrConstant(literal, module_)",
          "old_line_content": "    llvm::ArrayType* global_type =",
          "new_line_content": "            ? llvm_ir::ConvertLiteralToIrConstant(literal, module_)",
          "content_same": false
        },
        {
          "line": 3329,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "        should_emit_initializer",
          "new_line_content": "      VLOG(3) << \"Emitted initializer for constant with shape \"",
          "content_same": false
        },
        {
          "line": 3341,
          "old_api": null,
          "new_api": "llvm_module",
          "old_text": null,
          "new_text": "llvm_ir::GetGlobalMemoryAddressSpace(\n        *ir_emitter_context_->llvm_module())",
          "old_line_content": "    // to ensure that they stick around even if they're \"unused\".",
          "new_line_content": "    unsigned global_address_space = llvm_ir::GetGlobalMemoryAddressSpace(",
          "content_same": false
        },
        {
          "line": 3342,
          "old_api": null,
          "new_api": "llvm_module",
          "old_text": null,
          "new_text": "ir_emitter_context_->llvm_module()",
          "old_line_content": "    //",
          "new_line_content": "        *ir_emitter_context_->llvm_module());",
          "content_same": false
        },
        {
          "line": 3347,
          "old_api": null,
          "new_api": "llvm_ir::ConstantBufferAllocationToGlobalName(allocation)",
          "old_text": null,
          "new_text": "llvm_ir::ConstantBufferAllocationToGlobalName(allocation)",
          "old_line_content": "    llvm::GlobalVariable* global_for_const = new llvm::GlobalVariable(",
          "new_line_content": "        llvm_ir::ConstantBufferAllocationToGlobalName(allocation),",
          "content_same": false
        },
        {
          "line": 3352,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "ir_emitter_context_->llvm_module()->getGlobalList().push_back(\n        global_for_const)",
          "old_line_content": "        /*TLMode=*/llvm::GlobalValue::NotThreadLocal,",
          "new_line_content": "    ir_emitter_context_->llvm_module()->getGlobalList().push_back(",
          "content_same": false
        },
        {
          "line": 3378,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "unnested_hlo->ToString()",
          "old_line_content": "// }",
          "new_line_content": "  VLOG(10) << \"Emitting slice input fusion for \" << unnested_hlo->ToString();",
          "content_same": false
        },
        {
          "line": 3380,
          "old_api": null,
          "new_api": "fused_expression_root",
          "old_text": null,
          "new_text": "unnested_hlo->fused_expression_root()",
          "old_line_content": "void IrEmitterUnnested::EmitElementForInputFusibleSlices(",
          "new_line_content": "  HloInstruction* slice_or_tuple = unnested_hlo->fused_expression_root();",
          "content_same": false
        },
        {
          "line": 3381,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "() -> absl::Span<HloInstruction* const> {\n    if (slice_or_tuple->opcode() == HloOpcode::kSlice) {\n      return absl::Span<HloInstruction* const>(&slice_or_tuple, 1);\n    }\n    CHECK_EQ(slice_or_tuple->opcode(), HloOpcode::kTuple);\n    return slice_or_tuple->operands();\n  }()",
          "old_line_content": "    HloInstruction* unnested_hlo, const llvm_ir::IrArray::Index& index) {",
          "new_line_content": "  auto slice_instructions = [&]() -> absl::Span<HloInstruction* const> {",
          "content_same": false
        },
        {
          "line": 3383,
          "old_api": null,
          "new_api": "absl::Span<HloInstruction* const>(&slice_or_tuple, 1)",
          "old_text": null,
          "new_text": "absl::Span<HloInstruction* const>(&slice_or_tuple, 1)",
          "old_line_content": "",
          "new_line_content": "      return absl::Span<HloInstruction* const>(&slice_or_tuple, 1);",
          "content_same": false
        },
        {
          "line": 3392,
          "old_api": null,
          "new_api": "GetNestedComputer",
          "old_text": null,
          "new_text": "GetNestedComputer()",
          "old_line_content": "",
          "new_line_content": "                                     GetNestedComputer());",
          "content_same": false
        },
        {
          "line": 3393,
          "old_api": null,
          "new_api": "GetGeneratorForOperandIrArrays",
          "old_text": null,
          "new_text": "GetGeneratorForOperandIrArrays(unnested_hlo)",
          "old_line_content": "  // Emit input operand values of slices.",
          "new_line_content": "  FusedIrEmitter fused_emitter(GetGeneratorForOperandIrArrays(unnested_hlo),",
          "content_same": false
        },
        {
          "line": 3395,
          "old_api": null,
          "new_api": "fused_expression_root",
          "old_text": null,
          "new_text": "unnested_hlo->fused_expression_root()->Accept(&fused_emitter)",
          "old_line_content": "  GpuElementalIrEmitter elem_emitter(hlo_module_config_, module_, &b_,",
          "new_line_content": "  TF_CHECK_OK(unnested_hlo->fused_expression_root()->Accept(&fused_emitter));",
          "content_same": false
        },
        {
          "line": 3398,
          "old_api": null,
          "new_api": "ValueOrDie",
          "old_text": null,
          "new_text": "input_generator(index).ValueOrDie()",
          "old_line_content": "                               &elem_emitter);",
          "new_line_content": "    input_ir_values.push_back(input_generator(index).ValueOrDie());",
          "content_same": false
        },
        {
          "line": 3403,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "slice_instructions.size()",
          "old_line_content": "  }",
          "new_line_content": "  for (int64 i = 0; i < slice_instructions.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 3408,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "slice->slice_starts().size()",
          "old_line_content": "    HloInstruction* slice = slice_instructions[i];",
          "new_line_content": "    for (size_t dim = 0; dim < slice->slice_starts().size(); ++dim) {",
          "content_same": false
        },
        {
          "line": 3409,
          "old_api": null,
          "new_api": "slice_strides",
          "old_text": null,
          "new_text": "slice->slice_strides(dim)",
          "old_line_content": "",
          "new_line_content": "      CHECK_EQ(slice->slice_strides(dim), 1);",
          "content_same": false
        },
        {
          "line": 3410,
          "old_api": null,
          "new_api": "CreateICmpSGE",
          "old_text": null,
          "new_text": "b_.CreateICmpSGE(\n          index.multidim()[dim],\n          index.GetConstantWithIndexType(slice->slice_starts(dim)))",
          "old_line_content": "    // guarding_cond := index >= start && index < limit, for each dim.",
          "new_line_content": "      auto larger_or_equal_than_start = b_.CreateICmpSGE(",
          "content_same": false
        },
        {
          "line": 3411,
          "old_api": null,
          "new_api": "multidim",
          "old_text": null,
          "new_text": "index.multidim()",
          "old_line_content": "    std::vector<llvm::Value*> index_within_ranges;",
          "new_line_content": "          index.multidim()[dim],",
          "content_same": false
        },
        {
          "line": 3420,
          "old_api": null,
          "new_api": "CreateAnd",
          "old_text": null,
          "new_text": "b_.CreateAnd(index_within_ranges)",
          "old_line_content": "      llvm::Value* within_range =",
          "new_line_content": "    llvm::Value* guarding_cond = b_.CreateAnd(index_within_ranges);",
          "content_same": false
        },
        {
          "line": 3423,
          "old_api": null,
          "new_api": "multidim",
          "old_text": null,
          "new_text": "index.multidim()",
          "old_line_content": "    }",
          "new_line_content": "      const std::vector<llvm::Value*>& src_multidim = index.multidim();",
          "content_same": false
        },
        {
          "line": 3425,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "src_multidim.size()",
          "old_line_content": "",
          "new_line_content": "      for (size_t dim = 0; dim < src_multidim.size(); ++dim) {",
          "content_same": false
        },
        {
          "line": 3430,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "slice_or_tuple->opcode()",
          "old_line_content": "        dst_multidim[dim] =",
          "new_line_content": "      ShapeIndex shape_index = (slice_or_tuple->opcode() == HloOpcode::kSlice)",
          "content_same": false
        },
        {
          "line": 3437,
          "old_api": null,
          "new_api": "EmitArrayElementAddress",
          "old_text": null,
          "new_text": "src_ir_array.EmitArrayElementAddress(\n          slice_dst_index, &b_, \"slice.dest\")",
          "old_line_content": "      llvm_ir::IrArray src_ir_array =",
          "new_line_content": "      llvm::Value* dst_addr = src_ir_array.EmitArrayElementAddress(",
          "content_same": false
        },
        {
          "line": 3442,
          "old_api": null,
          "new_api": "StrCat",
          "old_text": null,
          "new_text": "StrCat(\"slice\", i)",
          "old_line_content": "          slice_dst_index, &b_, \"slice.dest\");",
          "new_line_content": "    ksl.If(StrCat(\"slice\", i), guarding_cond, emit_slice_elem_func);",
          "content_same": false
        },
        {
          "line": 3448,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "}",
          "new_line_content": "  constexpr int unroll_factor = 1;",
          "content_same": false
        },
        {
          "line": 3449,
          "old_api": null,
          "new_api": "BuildKernelThunk",
          "old_text": null,
          "new_text": "BuildKernelThunk(\n      unnested_hlo, /*implements_whole_instruction=*/true, unroll_factor)",
          "old_line_content": "",
          "new_line_content": "  std::unique_ptr<KernelThunk> kernel_thunk = BuildKernelThunk(",
          "content_same": false
        },
        {
          "line": 3454,
          "old_api": null,
          "new_api": "device_description",
          "old_text": null,
          "new_text": "CalculateLaunchDimensions(\n      element_shape, ir_emitter_context_->device_description(), unroll_factor)",
          "old_line_content": "      unnested_hlo, /*implements_whole_instruction=*/true, unroll_factor);",
          "new_line_content": "  LaunchDimensions launch_dimensions = CalculateLaunchDimensions(",
          "content_same": false
        },
        {
          "line": 3455,
          "old_api": null,
          "new_api": "device_description",
          "old_text": null,
          "new_text": "ir_emitter_context_->device_description()",
          "old_line_content": "",
          "new_line_content": "      element_shape, ir_emitter_context_->device_description(), unroll_factor);",
          "content_same": false
        },
        {
          "line": 3456,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "kernel_thunk.get()",
          "old_line_content": "  TF_ASSIGN_OR_RETURN(Shape element_shape,",
          "new_line_content": "  UpdateLaunchDimensions(launch_dimensions, kernel_thunk.get(),",
          "content_same": false
        },
        {
          "line": 3457,
          "old_api": null,
          "new_api": "llvm_module",
          "old_text": null,
          "new_text": "ir_emitter_context_->llvm_module()",
          "old_line_content": "                      GetConsistentInputShapeForRootSlices(*unnested_hlo));",
          "new_line_content": "                         ir_emitter_context_->llvm_module());",
          "content_same": false
        },
        {
          "line": 3462,
          "old_api": null,
          "new_api": "EmitElementForInputFusibleSlices",
          "old_text": null,
          "new_text": "EmitElementForInputFusibleSlices(unnested_hlo, index)",
          "old_line_content": "",
          "new_line_content": "            EmitElementForInputFusibleSlices(unnested_hlo, index);",
          "content_same": false
        },
        {
          "line": 3463,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "  Status emit_status =",
          "new_line_content": "            return Status::OK();",
          "content_same": false
        },
        {
          "line": 3468,
          "old_api": null,
          "new_api": "launch_bound",
          "old_text": null,
          "new_text": "launch_dimensions.launch_bound()",
          "old_line_content": "          },",
          "new_line_content": "                        unnested_hlo, launch_dimensions.launch_bound(), &b_));",
          "content_same": false
        },
        {
          "line": 2018,
          "old_api": null,
          "new_api": "constant",
          "old_text": null,
          "new_text": "constant(i)",
          "old_line_content": "              llvm::Value* x_loc = x_loc_base;",
          "new_line_content": "              llvm::Value* x_loc = b_.CreateAdd(constant(i), x_loc_base, \"x_loc\");",
          "content_same": false
        },
        {
          "line": 2020,
          "old_api": null,
          "new_api": "constant",
          "old_text": null,
          "new_text": "constant(i)",
          "old_line_content": "              if (i > 0) {",
          "new_line_content": "                  source_idx_x_base.AddOffsetToDim(constant(i), kDimX, &b_);",
          "content_same": false
        },
        {
          "line": 2022,
          "old_api": null,
          "new_api": "emit_elem_function",
          "old_text": null,
          "new_text": "emit_elem_function(source_idx_x, y_loc, x_loc, old_j)",
          "old_line_content": "                source_idx_x =",
          "new_line_content": "                return emit_elem_function(source_idx_x, y_loc, x_loc, old_j);",
          "content_same": false
        },
        {
          "line": 2025,
          "old_api": null,
          "new_api": "CreateICmpULT",
          "old_text": null,
          "new_text": "ksl->If(loop_name + \"_x_in_tile\",\n                        b_.CreateICmpULT(x_loc, tile_width), emit_element)",
          "old_line_content": "              auto emit_element = [&] {",
          "new_line_content": "                ksl->If(loop_name + \"_x_in_tile\",",
          "content_same": false
        },
        {
          "line": 2028,
          "old_api": null,
          "new_api": "emit_element",
          "old_text": null,
          "new_text": "emit_element()",
          "old_line_content": "              if (add_index_boundary_condition) {",
          "new_line_content": "                emit_element();",
          "content_same": false
        },
        {
          "line": 2035,
          "old_api": null,
          "new_api": "GetIndexingOrder",
          "old_text": null,
          "new_text": "mapping_scheme.GetIndexingOrder()",
          "old_line_content": "          }",
          "new_line_content": "            mapping_scheme.GetIndexingOrder() == kLinearStridedIndexingX) {",
          "content_same": false
        },
        {
          "line": 2041,
          "old_api": null,
          "new_api": "CreateICmpEQ",
          "old_text": null,
          "new_text": "ksl->If(loop_name + \"_is_full_tile\",\n                  // if (block fully fit) {fast path} else {slow path}\n                  // tile_width is always exact. For the last block,\n                  // it will be the exact number of elements left.\n                  b_.CreateICmpEQ(constant(mapping_scheme.GetTileSizeX()),\n                                  tile_width),\n                  [&] {\n                    unroll(/*add_index_boundary_condition=*/false, vector_size);\n                  },\n                  [&] {\n                    unroll(/*add_index_boundary_condition=*/true, vector_size);\n                  })",
          "old_line_content": "",
          "new_line_content": "          ksl->If(loop_name + \"_is_full_tile\",",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2049,
          "old_api": "GetTileSizeX",
          "new_api": null,
          "old_text": "mapping_scheme.GetTileSizeX()",
          "new_text": null,
          "old_line_content": "                  b_.CreateICmpEQ(constant(mapping_scheme.GetTileSizeX()),",
          "new_line_content": "                  },",
          "content_same": false
        },
        {
          "line": 2052,
          "old_api": "unroll",
          "new_api": null,
          "old_text": "unroll(/*add_index_boundary_condition=*/false, vector_size)",
          "new_text": null,
          "old_line_content": "                    unroll(/*add_index_boundary_condition=*/false, vector_size);",
          "new_line_content": "                  });",
          "content_same": false
        },
        {
          "line": 2055,
          "old_api": "unroll",
          "new_api": null,
          "old_text": "unroll(/*add_index_boundary_condition=*/true, vector_size)",
          "new_text": null,
          "old_line_content": "                    unroll(/*add_index_boundary_condition=*/true, vector_size);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2058,
          "old_api": "unroll",
          "new_api": null,
          "old_text": "unroll(/*add_index_boundary_condition=*/!x_tile_fits, vector_size)",
          "new_text": null,
          "old_line_content": "          unroll(/*add_index_boundary_condition=*/!x_tile_fits, vector_size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2078,
          "old_api": "GetIrArray",
          "new_api": null,
          "old_text": "GetIrArray(*hlo, *hlo)",
          "new_text": null,
          "old_line_content": "  llvm_ir::IrArray output_array = GetIrArray(*hlo, *hlo);",
          "new_line_content": "  // the 0-2-1 transpose is achieved through EmitWriteArrayElement.",
          "content_same": false
        },
        {
          "line": 2080,
          "old_api": "GetDimsInElems",
          "new_api": null,
          "old_text": "mapping_scheme.GetDimsInElems()",
          "new_text": null,
          "old_line_content": "      hlo->shape().element_type(), mapping_scheme.GetDimsInElems());",
          "new_line_content": "      .EmitWriteArrayElement(index, load_from_shmem_buffer, &b_);",
          "content_same": false
        },
        {
          "line": 2083,
          "old_api": "CastToShape",
          "new_api": null,
          "old_text": "output_array.CastToShape(output_reduced_shape, &b_)\n      .EmitWriteArrayElement(index, load_from_shmem_buffer, &b_)",
          "new_text": null,
          "old_line_content": "  output_array.CastToShape(output_reduced_shape, &b_)",
          "new_line_content": "static IrArray::Index GetUnnormalizedIndex(",
          "content_same": false
        },
        {
          "line": 2091,
          "old_api": "size",
          "new_api": null,
          "old_text": "normalized_shape_index.size()",
          "new_text": null,
          "old_line_content": "  DCHECK_EQ(normalized_shape_index.size(), 3);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2092,
          "old_api": "Linearize",
          "new_api": null,
          "old_text": "normalized_shape_index.Linearize(\n      kernel_mapping_scheme.GetDimsInElems(), b_)",
          "new_text": null,
          "old_line_content": "  llvm::Value* linear = normalized_shape_index.Linearize(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2093,
          "old_api": "GetDimsInElems",
          "new_api": null,
          "old_text": "kernel_mapping_scheme.GetDimsInElems()",
          "new_text": null,
          "old_line_content": "      kernel_mapping_scheme.GetDimsInElems(), b_);",
          "new_line_content": "// Emits code to process a tensor element in a tile for the given kLoop fusion",
          "content_same": false
        },
        {
          "line": 2094,
          "old_api": "IrArray::Index(linear, unnormalized_shape, b_)",
          "new_api": null,
          "old_text": "IrArray::Index(linear, unnormalized_shape, b_)",
          "new_text": null,
          "old_line_content": "  return IrArray::Index(linear, unnormalized_shape, b_);",
          "new_line_content": "// HLO containing parameters that are 0-2-1 transpose of its outputs.",
          "content_same": false
        },
        {
          "line": 2108,
          "old_api": "ConstructIrArrayForOutputs",
          "new_api": null,
          "old_text": "ConstructIrArrayForOutputs(*hlo)",
          "new_text": null,
          "old_line_content": "  std::vector<IrArray> output_arrays = ConstructIrArrayForOutputs(*hlo);",
          "new_line_content": "                               &elem_emitter, x_loc, y_loc,",
          "content_same": false
        },
        {
          "line": 2110,
          "old_api": "GetNestedComputer",
          "new_api": null,
          "old_text": "GetNestedComputer()",
          "new_text": null,
          "old_line_content": "                                     GetNestedComputer());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2124,
          "old_api": "size",
          "new_api": null,
          "old_text": "output_arrays.size()",
          "new_text": null,
          "old_line_content": "              output_arrays.size());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2125,
          "old_api": "size",
          "new_api": null,
          "old_text": "output_arrays.size()",
          "new_text": null,
          "old_line_content": "    for (int64 i = 0; i < output_arrays.size(); ++i) {",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 2127,
          "old_api": "ExtractValue",
          "new_api": null,
          "old_text": "ExtractValue(output_value, i)",
          "new_text": null,
          "old_line_content": "          untiled_index, ExtractValue(output_value, i), &b_);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2130,
          "old_api": "EmitWriteArrayElement",
          "new_api": null,
          "old_text": "output_arrays[0].EmitWriteArrayElement(untiled_index, output_value, &b_)",
          "new_text": null,
          "old_line_content": "    output_arrays[0].EmitWriteArrayElement(untiled_index, output_value, &b_);",
          "new_line_content": "// Gets the number of partial results accumulated by a single thread performing",
          "content_same": false
        },
        {
          "line": 2139,
          "old_api": "GetKernelMappingScheme",
          "new_api": null,
          "old_text": "reduction_info.GetKernelMappingScheme()",
          "new_text": null,
          "old_line_content": "      reduction_info.GetKernelMappingScheme();",
          "new_line_content": "  int64 num_partial_results =",
          "content_same": false
        },
        {
          "line": 2144,
          "old_api": "GetIndexingOrder",
          "new_api": null,
          "old_text": "mapping_scheme.GetIndexingOrder()",
          "new_text": null,
          "old_line_content": "      mapping_scheme.GetIndexingOrder() == kStridedIndexingX ? 1 : 2;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2145,
          "old_api": "GetTileSizeX",
          "new_api": null,
          "old_text": "CHECK_EQ(num_partial_results,\n           (mapping_scheme.GetTileSizeX() / mapping_scheme.GetNumThreadsX()))",
          "new_text": null,
          "old_line_content": "  CHECK_EQ(num_partial_results,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2146,
          "old_api": "GetNumThreadsX",
          "new_api": null,
          "old_text": "mapping_scheme.GetNumThreadsX()",
          "new_text": null,
          "old_line_content": "           (mapping_scheme.GetTileSizeX() / mapping_scheme.GetNumThreadsX()));",
          "new_line_content": "void IrEmitterUnnested::EmitPrologueForReduction(",
          "content_same": false
        },
        {
          "line": 2154,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "unnested_hlo->ToString()",
          "new_text": null,
          "old_line_content": "  VLOG(10) << \"Emit prologue for reduction: \" << unnested_hlo->ToString();",
          "new_line_content": "  const HloInstruction* first_reduce = nullptr;",
          "content_same": false
        },
        {
          "line": 2156,
          "old_api": "llvm_module",
          "new_api": null,
          "old_text": "ir_emitter_context_->llvm_module()",
          "new_text": null,
          "old_line_content": "                                          ir_emitter_context_->llvm_module(),",
          "new_line_content": "    HloInstruction* reduce_inst = reduce_instructions[i];",
          "content_same": false
        },
        {
          "line": 2159,
          "old_api": "size",
          "new_api": null,
          "old_text": "reduce_instructions.size()",
          "new_text": null,
          "old_line_content": "  for (int i = 0; i < reduce_instructions.size(); i++) {",
          "new_line_content": "      first_reduce = reduce_inst;",
          "content_same": false
        },
        {
          "line": 2171,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "reduce_inst->shape().element_type()",
          "new_text": null,
          "old_line_content": "        llvm_ir::PrimitiveTypeToIrType(reduce_inst->shape().element_type(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2173,
          "old_api": "Alloca",
          "new_api": null,
          "old_text": "Alloca(element_type)",
          "new_text": null,
          "old_line_content": "    llvm::AllocaInst* reduction_input_address = Alloca(element_type);",
          "new_line_content": "    AddressVector* partial_result_addresses =",
          "content_same": false
        },
        {
          "line": 2180,
          "old_api": "getInt32",
          "new_api": null,
          "old_text": "b_.getInt32(num_partial_results)",
          "new_text": null,
          "old_line_content": "        Alloca(element_type, /*ArraySize=*/b_.getInt32(num_partial_results),",
          "new_line_content": "    // Initialize the partial result with the initial value of the reduction.",
          "content_same": false
        },
        {
          "line": 2181,
          "old_api": "llvm::Twine(i)",
          "new_api": null,
          "old_text": "llvm::Twine(i)",
          "new_text": null,
          "old_line_content": "               \"partial_reduction_result.\" + llvm::Twine(i));",
          "new_line_content": "    llvm::Value* init_ir_value;",
          "content_same": false
        },
        {
          "line": 2186,
          "old_api": "operand",
          "new_api": null,
          "old_text": "reduce_inst->operand(1)",
          "new_text": null,
          "old_line_content": "    const HloInstruction* init_value = reduce_inst->operand(1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2188,
          "old_api": "GetGeneratorForOperandIrArrays",
          "new_api": null,
          "old_text": "GetGeneratorForOperandIrArrays(unnested_hlo)",
          "new_text": null,
          "old_line_content": "      FusedIrEmitter fused_emitter(GetGeneratorForOperandIrArrays(unnested_hlo),",
          "new_line_content": "      init_ir_value =",
          "content_same": false
        },
        {
          "line": 2191,
          "old_api": "Accept",
          "new_api": null,
          "old_text": "init_value->Accept(&fused_emitter)",
          "new_text": null,
          "old_line_content": "      TF_CHECK_OK(init_value->Accept(&fused_emitter));",
          "new_line_content": "              .ValueOrDie();",
          "content_same": false
        },
        {
          "line": 2193,
          "old_api": "GetGenerator",
          "new_api": null,
          "old_text": "fused_emitter\n              .GetGenerator(init_value)(IrArray::Index(b_.getInt32Ty()))\n              .ValueOrDie()",
          "new_text": null,
          "old_line_content": "          fused_emitter",
          "new_line_content": "      init_ir_value =",
          "content_same": false
        },
        {
          "line": 2198,
          "old_api": "EmitReadArrayElement",
          "new_api": null,
          "old_text": "GetIrArray(*init_value, *unnested_hlo)\n              .EmitReadArrayElement(IrArray::Index(b_.getInt32Ty()), &b_)",
          "new_text": null,
          "old_line_content": "          GetIrArray(*init_value, *unnested_hlo)",
          "new_line_content": "    for (int i = 0; i < num_partial_results; ++i) {",
          "content_same": false
        },
        {
          "line": 2203,
          "old_api": "getInt32",
          "new_api": null,
          "old_text": "Store(init_ir_value,\n            InBoundsGEP(partial_result_address, {b_.getInt32(i)}))",
          "new_text": null,
          "old_line_content": "      Store(init_ir_value,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2210,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "llvm_ir::PrimitiveTypeToIrType(\n        reduce_inst->shape().element_type(), module_)",
          "new_text": null,
          "old_line_content": "    llvm::Type* primitive_type = llvm_ir::PrimitiveTypeToIrType(",
          "new_line_content": "        // Allocate __shared__ cache[num_partial_results][kWarpSize].",
          "content_same": false
        },
        {
          "line": 2213,
          "old_api": "IsRowReduction",
          "new_api": null,
          "old_text": "reduction_info->IsRowReduction()",
          "new_text": null,
          "old_line_content": "      if (reduction_info->IsRowReduction()) {",
          "new_line_content": "            num_partial_results);",
          "content_same": false
        },
        {
          "line": 2215,
          "old_api": "llvm::ArrayType::get(\n            llvm::ArrayType::get(primitive_type, kWarpSize),\n            num_partial_results)",
          "new_api": null,
          "old_text": "llvm::ArrayType::get(\n            llvm::ArrayType::get(primitive_type, kWarpSize),\n            num_partial_results)",
          "new_text": null,
          "old_line_content": "        return llvm::ArrayType::get(",
          "new_line_content": "        // Allocate __shared__",
          "content_same": false
        },
        {
          "line": 2216,
          "old_api": "llvm::ArrayType::get(primitive_type, kWarpSize)",
          "new_api": null,
          "old_text": "llvm::ArrayType::get(primitive_type, kWarpSize)",
          "new_text": null,
          "old_line_content": "            llvm::ArrayType::get(primitive_type, kWarpSize),",
          "new_line_content": "        // cache[num_partial_results][num_threads][num_threads + 1], where",
          "content_same": false
        },
        {
          "line": 2223,
          "old_api": "GetNumThreadsY",
          "new_api": null,
          "old_text": "mapping_scheme.GetNumThreadsY()",
          "new_text": null,
          "old_line_content": "        CHECK_EQ(num_threads_x, mapping_scheme.GetNumThreadsY());",
          "new_line_content": "                num_threads_x),",
          "content_same": false
        },
        {
          "line": 2224,
          "old_api": "llvm::ArrayType::get(\n            llvm::ArrayType::get(\n                llvm::ArrayType::get(primitive_type, num_threads_x + 1),\n                num_threads_x),\n            num_partial_results)",
          "new_api": null,
          "old_text": "llvm::ArrayType::get(\n            llvm::ArrayType::get(\n                llvm::ArrayType::get(primitive_type, num_threads_x + 1),\n                num_threads_x),\n            num_partial_results)",
          "new_text": null,
          "old_line_content": "        return llvm::ArrayType::get(",
          "new_line_content": "            num_partial_results);",
          "content_same": false
        },
        {
          "line": 2225,
          "old_api": "llvm::ArrayType::get(\n                llvm::ArrayType::get(primitive_type, num_threads_x + 1),\n                num_threads_x)",
          "new_api": null,
          "old_text": "llvm::ArrayType::get(\n                llvm::ArrayType::get(primitive_type, num_threads_x + 1),\n                num_threads_x)",
          "new_text": null,
          "old_line_content": "            llvm::ArrayType::get(",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2226,
          "old_api": "llvm::ArrayType::get(primitive_type, num_threads_x + 1)",
          "new_api": null,
          "old_text": "llvm::ArrayType::get(primitive_type, num_threads_x + 1)",
          "new_text": null,
          "old_line_content": "                llvm::ArrayType::get(primitive_type, num_threads_x + 1),",
          "new_line_content": "    }();",
          "content_same": false
        },
        {
          "line": 2232,
          "old_api": "GetInsertBlock",
          "new_api": null,
          "old_text": "b_.GetInsertBlock()->getModule()",
          "new_text": null,
          "old_line_content": "        llvm_ir::AllocateSharedMemoryTile(b_.GetInsertBlock()->getModule(),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2234,
          "old_api": "absl::StrCat(\"shared_cache_\", i)",
          "new_api": null,
          "old_text": "absl::StrCat(\"shared_cache_\", i)",
          "new_text": null,
          "old_line_content": "                                          absl::StrCat(\"shared_cache_\", i));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2235,
          "old_api": "GetMutableSharedCache",
          "new_api": null,
          "old_text": "reduction_info->GetMutableSharedCache()->push_back(shared_cache_per_reduce)",
          "new_text": null,
          "old_line_content": "    reduction_info->GetMutableSharedCache()->push_back(shared_cache_per_reduce);",
          "new_line_content": "void IrEmitterUnnested::EmitFullWarpShuffleDownLoopForAllReduces(",
          "content_same": false
        },
        {
          "line": 2242,
          "old_api": "size",
          "new_api": null,
          "old_text": "partial_result_addresses.size()",
          "new_text": null,
          "old_line_content": "  CHECK_EQ(reducers.size(), partial_result_addresses.size());",
          "new_line_content": "        partial_result_addresses[i]);",
          "content_same": false
        },
        {
          "line": 2243,
          "old_api": "size",
          "new_api": null,
          "old_text": "reducers.size()",
          "new_text": null,
          "old_line_content": "  for (int i = 0; i != reducers.size(); i++) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2244,
          "old_api": "getType",
          "new_api": null,
          "old_text": "EmitFullWarpShuffleDownLoopForReduce(\n        reducers[i], partial_result_addresses[i]->getType()->getElementType(),\n        partial_result_addresses[i])",
          "new_text": null,
          "old_line_content": "    EmitFullWarpShuffleDownLoopForReduce(",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2245,
          "old_api": "getType",
          "new_api": null,
          "old_text": "partial_result_addresses[i]->getType()->getElementType()",
          "new_text": null,
          "old_line_content": "        reducers[i], partial_result_addresses[i]->getType()->getElementType(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2254,
          "old_api": "llvm_ir::GetSizeInBits(element_type)",
          "new_api": null,
          "old_text": "llvm_ir::GetSizeInBits(element_type)",
          "new_text": null,
          "old_line_content": "    int bit_width = llvm_ir::GetSizeInBits(element_type);",
          "new_line_content": "    // we bitcast addresses of load/store to intN* of the same bit-width.",
          "content_same": false
        },
        {
          "line": 2260,
          "old_api": "getIntNTy",
          "new_api": null,
          "old_text": "b_.getIntNTy(bit_width)",
          "new_text": null,
          "old_line_content": "        element_type->isStructTy() ? b_.getIntNTy(bit_width) : element_type;",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 2263,
          "old_api": "getPointerTo",
          "new_api": null,
          "old_text": "shuffled_value_type->getPointerTo()",
          "new_text": null,
          "old_line_content": "          ptr, shuffled_value_type->getPointerTo());",
          "new_line_content": "             \"partial_reduction_result\");",
          "content_same": false
        },
        {
          "line": 2268,
          "old_api": "getInt32",
          "new_api": null,
          "old_text": "b_.getInt32(distance)",
          "new_text": null,
          "old_line_content": "    Store(EmitFullWarpShuffleDown(partial_result, b_.getInt32(distance), &b_),",
          "new_line_content": "        partial_result_address));",
          "content_same": false
        },
        {
          "line": 2269,
          "old_api": "convert_pointer_for_shuffle",
          "new_api": null,
          "old_text": "convert_pointer_for_shuffle(result_from_other_lane)",
          "new_text": null,
          "old_line_content": "          convert_pointer_for_shuffle(result_from_other_lane));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2270,
          "old_api": "EmitCallToNestedComputation",
          "new_api": null,
          "old_text": "EmitCallToNestedComputation(\n        *reducer, {partial_result_address, result_from_other_lane},\n        partial_result_address)",
          "new_text": null,
          "old_line_content": "    TF_CHECK_OK(EmitCallToNestedComputation(",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2283,
          "old_api": "GetKernelMappingScheme",
          "new_api": null,
          "old_text": "reduction_info.GetKernelMappingScheme()",
          "new_text": null,
          "old_line_content": "      reduction_info.GetKernelMappingScheme();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2284,
          "old_api": "IsRowReduction",
          "new_api": null,
          "old_text": "reduction_info.IsRowReduction()",
          "new_text": null,
          "old_line_content": "  if (reduction_info.IsRowReduction()) {",
          "new_line_content": "  // For column reduction, we get the transposed address.",
          "content_same": false
        },
        {
          "line": 2289,
          "old_api": "GetDimsInElems",
          "new_api": null,
          "old_text": "kernel_mapping_scheme.GetDimsInElems()",
          "new_text": null,
          "old_line_content": "  absl::Span<const int64> dims_in_elem = kernel_mapping_scheme.GetDimsInElems();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2290,
          "old_api": "GetConstantWithIndexType",
          "new_api": null,
          "old_text": "index.GetConstantWithIndexType(dims_in_elem[kDimX])",
          "new_text": null,
          "old_line_content": "  llvm::Value* x_dim_size = index.GetConstantWithIndexType(dims_in_elem[kDimX]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": "CreateMul",
          "new_api": null,
          "old_text": "b->CreateMul(index[kDimZ], x_dim_size)",
          "new_text": null,
          "old_line_content": "  llvm::Value* x_block_offset = b->CreateMul(index[kDimZ], x_dim_size);",
          "new_line_content": "void IrEmitterUnnested::EmitEpilogueForReduction(",
          "content_same": false
        },
        {
          "line": 2292,
          "old_api": "CreateAdd",
          "new_api": null,
          "old_text": "b->CreateAdd(x_block_offset, index[kDimX])",
          "new_text": null,
          "old_line_content": "  return b->CreateAdd(x_block_offset, index[kDimX]);",
          "new_line_content": "    llvm::Type* index_ty, HloInstruction* unnested_hlo,",
          "content_same": false
        },
        {
          "line": 2303,
          "old_api": "GetKernelMappingScheme",
          "new_api": null,
          "old_text": "reduction_info.GetKernelMappingScheme()",
          "new_text": null,
          "old_line_content": "      reduction_info.GetKernelMappingScheme();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2309,
          "old_api": "GetThreadsPerBlock",
          "new_api": null,
          "old_text": "mapping_scheme.GetThreadsPerBlock()",
          "new_text": null,
          "old_line_content": "      EmitThreadIdInfo(mapping_scheme.GetThreadsPerBlock(), index_ty,",
          "new_line_content": "    llvm::Value* x_loc = thread_id_info.thread_id_x;",
          "content_same": false
        },
        {
          "line": 2310,
          "old_api": "GetNumThreadsX",
          "new_api": null,
          "old_text": "mapping_scheme.GetNumThreadsX()",
          "new_text": null,
          "old_line_content": "                       mapping_scheme.GetNumThreadsX());",
          "new_line_content": "    llvm::Value* y_loc = thread_id_info.thread_id_y;",
          "content_same": false
        },
        {
          "line": 2319,
          "old_api": "GetStartOffsetX",
          "new_api": null,
          "old_text": "GetStartOffsetX(mapping_scheme, x_loc, index_ty, &b_)",
          "new_text": null,
          "old_line_content": "        GetStartOffsetX(mapping_scheme, x_loc, index_ty, &b_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2326,
          "old_api": "GetPartialResultAddresses",
          "new_api": null,
          "old_text": "reduction_info.GetPartialResultAddresses()",
          "new_text": null,
          "old_line_content": "      reduction_info.GetPartialResultAddresses();",
          "new_line_content": "  // Emit an atomic operation that accumulates the partial reduction to the",
          "content_same": false
        },
        {
          "line": 2328,
          "old_api": "GetNumberOfPartialResults",
          "new_api": null,
          "old_text": "GetNumberOfPartialResults(reduction_info)",
          "new_text": null,
          "old_line_content": "  int num_partial_results = GetNumberOfPartialResults(reduction_info);",
          "new_line_content": "  // if-statement emitted above.",
          "content_same": false
        },
        {
          "line": 2337,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "reduce_hlo->dimensions()",
          "new_text": null,
          "old_line_content": "          return !absl::c_linear_search(reduce_hlo->dimensions(), dim);",
          "new_line_content": "      llvm::Value* untransposed_output_linear_address =",
          "content_same": false
        },
        {
          "line": 2342,
          "old_api": "AddOffsetToDim",
          "new_api": null,
          "old_text": "GetUntransposedOutputLinearAddress(\n              &b_, start_offset.AddOffsetToDim(constant(j), kDimX, &b_),\n              reduction_info)",
          "new_text": null,
          "old_line_content": "          GetUntransposedOutputLinearAddress(",
          "new_line_content": "      // A reduction is allowed to transpose its output.  For example, suppose",
          "content_same": false
        },
        {
          "line": 2343,
          "old_api": "constant",
          "new_api": null,
          "old_text": "constant(j)",
          "new_text": null,
          "old_line_content": "              &b_, start_offset.AddOffsetToDim(constant(j), kDimX, &b_),",
          "new_line_content": "      // we are reducing the second dimension of f32[10,20,30]{3,2,1}.  We are",
          "content_same": false
        },
        {
          "line": 2354,
          "old_api": "GetIrArray",
          "new_api": null,
          "old_text": "GetIrArray(*unnested_hlo, *unnested_hlo,\n                                     reduction_output_shape_indices[i])",
          "new_text": null,
          "old_line_content": "      auto output_array = GetIrArray(*unnested_hlo, *unnested_hlo,",
          "new_line_content": "          reduction_kept_element_shape, &b_);",
          "content_same": false
        },
        {
          "line": 2359,
          "old_api": "multidim",
          "new_api": null,
          "old_text": "element_index.multidim()",
          "new_text": null,
          "old_line_content": "      IrArray::Index output_index(element_index.multidim(),",
          "new_line_content": "          output_index, &b_, \"output_element_address\");",
          "content_same": false
        },
        {
          "line": 2362,
          "old_api": "EmitArrayElementAddress",
          "new_api": null,
          "old_text": "output_array.EmitArrayElementAddress(\n          output_index, &b_, \"output_element_address\")",
          "new_text": null,
          "old_line_content": "      llvm::Value* output_address = output_array.EmitArrayElementAddress(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2364,
          "old_api": "CreateInBoundsGEP",
          "new_api": null,
          "old_text": "b_.CreateInBoundsGEP(\n          partial_result_addresses[i], {constant(j)}, \"current_output\")",
          "new_text": null,
          "old_line_content": "      llvm::Value* current_output = b_.CreateInBoundsGEP(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2365,
          "old_api": "constant",
          "new_api": null,
          "old_text": "constant(j)",
          "new_text": null,
          "old_line_content": "          partial_result_addresses[i], {constant(j)}, \"current_output\");",
          "new_line_content": "      // __shared__ memory uses a different address space, so we cast it to",
          "content_same": false
        },
        {
          "line": 2367,
          "old_api": "GetSharedCache",
          "new_api": null,
          "old_text": "reduction_info.GetSharedCache()",
          "new_text": null,
          "old_line_content": "      llvm::GlobalVariable* shared_cache = reduction_info.GetSharedCache()[i];",
          "new_line_content": "      auto shared_to_global = [&](llvm::Value* input, llvm::Twine name = \"\") {",
          "content_same": false
        },
        {
          "line": 2372,
          "old_api": "CreateAddrSpaceCast",
          "new_api": null,
          "old_text": "b_.CreateAddrSpaceCast(\n            input,\n            llvm::PointerType::get(input->getType()->getPointerElementType(),\n                                   /*AddressSpace=*/0),\n            name)",
          "new_text": null,
          "old_line_content": "        return b_.CreateAddrSpaceCast(",
          "new_line_content": "            name);",
          "content_same": false
        },
        {
          "line": 2374,
          "old_api": "getType",
          "new_api": null,
          "old_text": "input->getType()->getPointerElementType()",
          "new_text": null,
          "old_line_content": "            llvm::PointerType::get(input->getType()->getPointerElementType(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2380,
          "old_api": "constant",
          "new_api": null,
          "old_text": "constant(0)",
          "new_text": null,
          "old_line_content": "        return b_.CreateICmpEQ(value, constant(0));",
          "new_line_content": "      llvm::Type* element_type =",
          "content_same": false
        },
        {
          "line": 2385,
          "old_api": "getType",
          "new_api": null,
          "old_text": "partial_result_addresses[i]->getType()->getElementType()",
          "new_text": null,
          "old_line_content": "          partial_result_addresses[i]->getType()->getElementType();",
          "new_line_content": "        llvm::Value* warp_id =",
          "content_same": false
        },
        {
          "line": 2393,
          "old_api": "CreateInBoundsGEP",
          "new_api": null,
          "old_text": "b_.CreateInBoundsGEP(\n                  shared_cache, {b_.getInt32(0), constant(j), warp_id})",
          "new_text": null,
          "old_line_content": "              shared_to_global(b_.CreateInBoundsGEP(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2400,
          "old_api": "CreateInBoundsGEP",
          "new_api": null,
          "old_text": "b_.CreateInBoundsGEP(\n              shared_cache,\n              {b_.getInt32(0), constant(j), thread_id_info.lane_id})",
          "new_text": null,
          "old_line_content": "          llvm::Value* block_accum_addr = shared_to_global(b_.CreateInBoundsGEP(",
          "new_line_content": "          llvm::Value* initial_value_addr =",
          "content_same": false
        },
        {
          "line": 2402,
          "old_api": "constant",
          "new_api": null,
          "old_text": "constant(j)",
          "new_text": null,
          "old_line_content": "              {b_.getInt32(0), constant(j), thread_id_info.lane_id}));",
          "new_line_content": "                  element_type, \"initial_value_addr\", &b_));",
          "content_same": false
        },
        {
          "line": 2411,
          "old_api": "GetNumThreadsX",
          "new_api": null,
          "old_text": "mapping_scheme.GetNumThreadsX()",
          "new_text": null,
          "old_line_content": "              constant(mapping_scheme.GetNumThreadsX() / kWarpSize));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2413,
          "old_api": "CreateSelect",
          "new_api": null,
          "old_text": "b_.CreateSelect(\n              warp_exists, block_accum_addr, initial_value_addr)",
          "new_text": null,
          "old_line_content": "          llvm::Value* selected_value = b_.CreateSelect(",
          "new_line_content": "              reducers[i], element_type,",
          "content_same": false
        },
        {
          "line": 2419,
          "old_api": "is_zero",
          "new_api": null,
          "old_text": "is_zero(thread_id_info.thread_id_x)",
          "new_text": null,
          "old_line_content": "          ksl.If(is_zero(thread_id_info.thread_id_x), [&] {",
          "new_line_content": "        });",
          "content_same": false
        },
        {
          "line": 2420,
          "old_api": "EmitAtomicOperationForNestedComputation",
          "new_api": null,
          "old_text": "EmitAtomicOperationForNestedComputation(\n                *reducers[i], output_address, block_accum_addr)",
          "new_text": null,
          "old_line_content": "            TF_CHECK_OK(EmitAtomicOperationForNestedComputation(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2426,
          "old_api": "CreateInBoundsGEP",
          "new_api": null,
          "old_text": "shared_to_global(\n            b_.CreateInBoundsGEP(shared_cache, {b_.getInt32(0), constant(j),\n                                                thread_id_info.thread_id_x,\n                                                thread_id_info.thread_id_y}),\n            \"shmem_output_address\")",
          "new_text": null,
          "old_line_content": "        llvm::Value* shmem_output_addr = shared_to_global(",
          "new_line_content": "            \"shmem_output_address\");",
          "content_same": false
        },
        {
          "line": 2431,
          "old_api": "CreateLoad",
          "new_api": null,
          "old_text": "b_.CreateLoad(current_output)",
          "new_text": null,
          "old_line_content": "        llvm::Value* current_output_value = b_.CreateLoad(current_output);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2432,
          "old_api": "CreateStore",
          "new_api": null,
          "old_text": "b_.CreateStore(current_output_value, shmem_output_addr)",
          "new_text": null,
          "old_line_content": "        b_.CreateStore(current_output_value, shmem_output_addr);",
          "new_line_content": "        // Get transposed element from shared memory.",
          "content_same": false
        },
        {
          "line": 2438,
          "old_api": "CreateInBoundsGEP",
          "new_api": null,
          "old_text": "b_.CreateInBoundsGEP(\n                shared_cache,\n                {b_.getInt32(0), constant(j), thread_id_info.thread_id_y,\n                 thread_id_info.thread_id_x},\n                \"shmem_transposed_addr\")",
          "new_text": null,
          "old_line_content": "            shared_to_global(b_.CreateInBoundsGEP(",
          "new_line_content": "                \"shmem_transposed_addr\"));",
          "content_same": false
        },
        {
          "line": 2444,
          "old_api": "EmitFullWarpShuffleDownLoopForReduce",
          "new_api": null,
          "old_text": "EmitFullWarpShuffleDownLoopForReduce(reducers[i], element_type,\n                                             shmem_transposed_addr)",
          "new_text": null,
          "old_line_content": "        EmitFullWarpShuffleDownLoopForReduce(reducers[i], element_type,",
          "new_line_content": "        // tensor, so they should not write any output at all.",
          "content_same": false
        },
        {
          "line": 2449,
          "old_api": "CreateAnd",
          "new_api": null,
          "old_text": "b_.CreateAnd(\n            b_.CreateICmpULT(\n                GetStartOffsetX(mapping_scheme, thread_id_info.thread_id_y,\n                                index_ty, &b_),\n                tiling_kernel_info.output_tile_bounds[kDimX]),\n            b_.CreateICmpULT(thread_id_info.thread_id_x,\n                             tiling_kernel_info.output_tile_bounds[kDimY]))",
          "new_text": null,
          "old_line_content": "        llvm::Value* has_output = b_.CreateAnd(",
          "new_line_content": "                tiling_kernel_info.output_tile_bounds[kDimX]),",
          "content_same": false
        },
        {
          "line": 2451,
          "old_api": "GetStartOffsetX",
          "new_api": null,
          "old_text": "GetStartOffsetX(mapping_scheme, thread_id_info.thread_id_y,\n                                index_ty, &b_)",
          "new_text": null,
          "old_line_content": "                GetStartOffsetX(mapping_scheme, thread_id_info.thread_id_y,",
          "new_line_content": "                             tiling_kernel_info.output_tile_bounds[kDimY]));",
          "content_same": false
        },
        {
          "line": 2457,
          "old_api": "is_zero",
          "new_api": null,
          "old_text": "is_zero(thread_id_info.lane_id)",
          "new_text": null,
          "old_line_content": "        ksl.If(b_.CreateAnd(has_output, is_zero(thread_id_info.lane_id)), [&] {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2458,
          "old_api": "EmitAtomicOperationForNestedComputation",
          "new_api": null,
          "old_text": "EmitAtomicOperationForNestedComputation(\n              *reducers[i], output_address, shmem_transposed_addr)",
          "new_text": null,
          "old_line_content": "          TF_CHECK_OK(EmitAtomicOperationForNestedComputation(",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2467,
          "old_api": "gpu::EmitCallToTargetIntrinsic(gpu::TargetIntrinsicID::kBlockIdx, {},\n                                        {}, &b_)",
          "new_api": null,
          "old_text": "gpu::EmitCallToTargetIntrinsic(gpu::TargetIntrinsicID::kBlockIdx, {},\n                                        {}, &b_)",
          "new_text": null,
          "old_line_content": "  return gpu::EmitCallToTargetIntrinsic(gpu::TargetIntrinsicID::kBlockIdx, {},",
          "new_line_content": "void IrEmitterUnnested::EmitPrintfWithThreadId(",
          "content_same": false
        },
        {
          "line": 2480,
          "old_api": "getTrue",
          "new_api": null,
          "old_text": "b_.getTrue()",
          "new_text": null,
          "old_line_content": "  llvm::Value* constraint = b_.getTrue();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2490,
          "old_api": "If",
          "new_api": null,
          "old_text": "ksl.If(constraint, [&] {\n    ::xla::gpu::EmitPrintf(absl::StrCat(\"[TID=%d,BID=%d] \", fmt, \"\\n\"),\n                           updated_arguments, &b_);\n  })",
          "new_text": null,
          "old_line_content": "  ksl.If(constraint, [&] {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2491,
          "old_api": "absl::StrCat(\"[TID=%d,BID=%d] \", fmt, \"\\n\")",
          "new_api": null,
          "old_text": "absl::StrCat(\"[TID=%d,BID=%d] \", fmt, \"\\n\")",
          "new_text": null,
          "old_line_content": "    ::xla::gpu::EmitPrintf(absl::StrCat(\"[TID=%d,BID=%d] \", fmt, \"\\n\"),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2502,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "unnested_hlo->ToString()",
          "new_text": null,
          "old_line_content": "  VLOG(10) << \"Emit tile element for reduce \" << unnested_hlo->ToString();",
          "new_line_content": "  InlinedVector<llvm_ir::ElementGenerator, 1> input_gens;",
          "content_same": false
        },
        {
          "line": 2503,
          "old_api": "size",
          "new_api": null,
          "old_text": "output_instructions.size()",
          "new_text": null,
          "old_line_content": "  bool returns_tuple = output_instructions.size() > 1;",
          "new_line_content": "  std::vector<std::pair<llvm_ir::ElementGenerator, ShapeIndex>>",
          "content_same": false
        },
        {
          "line": 2504,
          "old_api": "IsRowReduction",
          "new_api": null,
          "old_text": "reduction_info.IsRowReduction()",
          "new_text": null,
          "old_line_content": "  int partial_result_index = reduction_info.IsRowReduction() ? 0 : x_iter_num;",
          "new_line_content": "      extra_output_gens;",
          "content_same": false
        },
        {
          "line": 2510,
          "old_api": "GetNestedComputer",
          "new_api": null,
          "old_text": "GetNestedComputer()",
          "new_text": null,
          "old_line_content": "                                     GetNestedComputer());",
          "new_line_content": "  // the group of output instructions.",
          "content_same": false
        },
        {
          "line": 2515,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "unnested_hlo->opcode()",
          "new_text": null,
          "old_line_content": "  if (unnested_hlo->opcode() == HloOpcode::kFusion) {",
          "new_line_content": "      const HloInstruction* inst = output_instructions[i];",
          "content_same": false
        },
        {
          "line": 2522,
          "old_api": "operand",
          "new_api": null,
          "old_text": "inst->operand(0)",
          "new_text": null,
          "old_line_content": "        input_gens.push_back(fused_emitter.GetGenerator(inst->operand(0)));",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2524,
          "old_api": "GetGenerator",
          "new_api": null,
          "old_text": "fused_emitter.GetGenerator(inst)",
          "new_text": null,
          "old_line_content": "        extra_output_gens.emplace_back(fused_emitter.GetGenerator(inst),",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 2529,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "input_gens.push_back([&](const IrArray::Index& index) {\n      return GetIrArray(*unnested_hlo->operand(0), *unnested_hlo)\n          .EmitReadArrayElement(index, &b_);\n    })",
          "new_text": null,
          "old_line_content": "    input_gens.push_back([&](const IrArray::Index& index) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2530,
          "old_api": "operand",
          "new_api": null,
          "old_text": "unnested_hlo->operand(0)",
          "new_text": null,
          "old_line_content": "      return GetIrArray(*unnested_hlo->operand(0), *unnested_hlo)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2536,
          "old_api": "GetKernelMappingScheme",
          "new_api": null,
          "old_text": "GetUnnormalizedIndex(index, reduction_operand_shape, &b_,\n                           reduction_info.GetKernelMappingScheme())",
          "new_text": null,
          "old_line_content": "      GetUnnormalizedIndex(index, reduction_operand_shape, &b_,",
          "new_line_content": "  // the computation for different partial results. Use this index if",
          "content_same": false
        },
        {
          "line": 2537,
          "old_api": "GetKernelMappingScheme",
          "new_api": null,
          "old_text": "reduction_info.GetKernelMappingScheme()",
          "new_text": null,
          "old_line_content": "                           reduction_info.GetKernelMappingScheme());",
          "new_line_content": "  // 'num_partial_results > 1'.",
          "content_same": false
        },
        {
          "line": 2542,
          "old_api": "GetNumberOfPartialResults",
          "new_api": null,
          "old_text": "GetNumberOfPartialResults(reduction_info)",
          "new_text": null,
          "old_line_content": "  int num_partial_results = GetNumberOfPartialResults(reduction_info);",
          "new_line_content": "  // Emit code to generate the input and perform the reduction computation for",
          "content_same": false
        },
        {
          "line": 2543,
          "old_api": "multidim",
          "new_api": null,
          "old_text": "IrArray::Index(\n      input_index.multidim(), reduction_operand_shape, input_index.GetType())",
          "new_text": null,
          "old_line_content": "  auto index_without_linear = IrArray::Index(",
          "new_line_content": "  // each reduction instruction.",
          "content_same": false
        },
        {
          "line": 2552,
          "old_api": "GetPartialResultAddresses",
          "new_api": null,
          "old_text": "reduction_info.GetPartialResultAddresses()",
          "new_text": null,
          "old_line_content": "        reduction_info.GetPartialResultAddresses()[i];",
          "new_line_content": "            .ValueOrDie();",
          "content_same": false
        },
        {
          "line": 2557,
          "old_api": "Store",
          "new_api": null,
          "old_text": "Store(input_ir_value, input_address)",
          "new_text": null,
          "old_line_content": "    Store(input_ir_value, input_address);",
          "new_line_content": "        *reducers[i], {partial_result_address, input_address},",
          "content_same": false
        },
        {
          "line": 2558,
          "old_api": "getInt32",
          "new_api": null,
          "old_text": "InBoundsGEP(\n        partial_reduction_result_address, {b_.getInt32(partial_result_index)})",
          "new_text": null,
          "old_line_content": "    llvm::Value* partial_result_address = InBoundsGEP(",
          "new_line_content": "        partial_result_address));",
          "content_same": false
        },
        {
          "line": 2559,
          "old_api": "getInt32",
          "new_api": null,
          "old_text": "b_.getInt32(partial_result_index)",
          "new_text": null,
          "old_line_content": "        partial_reduction_result_address, {b_.getInt32(partial_result_index)});",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2560,
          "old_api": "EmitCallToNestedComputation",
          "new_api": null,
          "old_text": "EmitCallToNestedComputation(\n        *reducers[i], {partial_result_address, input_address},\n        partial_result_address)",
          "new_text": null,
          "old_line_content": "    TF_CHECK_OK(EmitCallToNestedComputation(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2567,
          "old_api": "EmitExtraOutputsForReduce",
          "new_api": null,
          "old_text": "EmitExtraOutputsForReduce(\n      unnested_hlo, input_index,\n      /*use_linear_index=*/num_partial_results == 1, extra_output_gens)",
          "new_text": null,
          "old_line_content": "  TF_CHECK_OK(EmitExtraOutputsForReduce(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2576,
          "old_api": "gpu::EmitCallToTargetIntrinsic(\n      gpu::TargetIntrinsicID::kThreadIdx, {}, {}, &b_)",
          "new_api": null,
          "old_text": "gpu::EmitCallToTargetIntrinsic(\n      gpu::TargetIntrinsicID::kThreadIdx, {}, {}, &b_)",
          "new_text": null,
          "old_line_content": "  llvm::CallInst* thread_id_raw = gpu::EmitCallToTargetIntrinsic(",
          "new_line_content": "                          /*isSigned=*/true, \"thread.id.x\");",
          "content_same": false
        },
        {
          "line": 2578,
          "old_api": "llvm_ir::AddRangeMetadata(0, threads_per_block, thread_id_raw)",
          "new_api": null,
          "old_text": "llvm_ir::AddRangeMetadata(0, threads_per_block, thread_id_raw)",
          "new_text": null,
          "old_line_content": "  llvm_ir::AddRangeMetadata(0, threads_per_block, thread_id_raw);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2579,
          "old_api": "CreateIntCast",
          "new_api": null,
          "old_text": "b_.CreateIntCast(thread_id_raw, index_ty,\n                          /*isSigned=*/true, \"thread.id.x\")",
          "new_text": null,
          "old_line_content": "  return b_.CreateIntCast(thread_id_raw, index_ty,",
          "new_line_content": "IrEmitterUnnested::ThreadIdInfo IrEmitterUnnested::EmitThreadIdInfo(",
          "content_same": false
        },
        {
          "line": 2586,
          "old_api": "llvm::ConstantInt::get(index_ty, c)",
          "new_api": null,
          "old_text": "llvm::ConstantInt::get(index_ty, c)",
          "new_text": null,
          "old_line_content": "    return llvm::ConstantInt::get(index_ty, c);",
          "new_line_content": "  return {",
          "content_same": false
        },
        {
          "line": 2592,
          "old_api": "CreateURem",
          "new_api": null,
          "old_text": "b_.CreateURem(thread_id, num_threads_x_v, \"thread_id.x\")",
          "new_text": null,
          "old_line_content": "      /*thread_id_x=*/b_.CreateURem(thread_id, num_threads_x_v, \"thread_id.x\"),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2593,
          "old_api": "CreateUDiv",
          "new_api": null,
          "old_text": "b_.CreateUDiv(thread_id, num_threads_x_v, \"thread_id.y\")",
          "new_text": null,
          "old_line_content": "      /*thread_id_y=*/b_.CreateUDiv(thread_id, num_threads_x_v, \"thread_id.y\"),",
          "new_line_content": "IrEmitterUnnested::TilingKernelInfo IrEmitterUnnested::EmitTilingKernel(",
          "content_same": false
        },
        {
          "line": 2594,
          "old_api": "constant",
          "new_api": null,
          "old_text": "constant(kWarpSize)",
          "new_text": null,
          "old_line_content": "      /*lane_id=*/b_.CreateURem(thread_id, constant(kWarpSize), \"lane_id\")};",
          "new_line_content": "    const KernelMappingScheme& mapping_scheme, llvm::Type* index_ty,",
          "content_same": false
        },
        {
          "line": 2603,
          "old_api": "GetTileSizeY",
          "new_api": null,
          "old_text": "mapping_scheme.GetTileSizeY()",
          "new_text": null,
          "old_line_content": "      CeilOfRatio(dims_in_elems[1], mapping_scheme.GetTileSizeY()),",
          "new_line_content": "  };",
          "content_same": false
        },
        {
          "line": 2604,
          "old_api": "GetTileSizeX",
          "new_api": null,
          "old_text": "mapping_scheme.GetTileSizeX()",
          "new_text": null,
          "old_line_content": "      CeilOfRatio(dims_in_elems[2], mapping_scheme.GetTileSizeX())};",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2610,
          "old_api": "GetThreadsPerBlock",
          "new_api": null,
          "old_text": "mapping_scheme.GetThreadsPerBlock()",
          "new_text": null,
          "old_line_content": "      EmitThreadIdInfo(mapping_scheme.GetThreadsPerBlock(), index_ty,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2615,
          "old_api": "GetNumberOfBlocks",
          "new_api": null,
          "old_text": "[&] {\n    llvm::Value* block_id = EmitBlockId();\n    llvm_ir::AddRangeMetadata(0, mapping_scheme.GetNumberOfBlocks(),\n                              llvm::cast<llvm::Instruction>(block_id));\n    llvm::Value* linear_block_id =\n        b_.CreateIntCast(block_id, index_ty, /*isSigned=*/true, \"block.id.x\");\n    IrArray::Index starting_block(linear_block_id,\n                                  ShapeUtil::MakeShapeWithDescendingLayout(\n                                      PRED /*arbitrary*/, dims_in_blocks),\n                                  &b_);\n\n    std::vector<llvm::Value*> multidim = {\n        b_.CreateMul(starting_block[0], constant(mapping_scheme.GetTileSizeZ()),\n                     \"block_origin.z\"),\n        starting_block[1], starting_block[2]};\n    return IrArray::Index(multidim, dims_in_blocks, index_ty);\n  }()",
          "new_text": null,
          "old_line_content": "  const IrArray::Index block_coords = [&] {",
          "new_line_content": "    llvm::Value* linear_block_id =",
          "content_same": false
        },
        {
          "line": 2617,
          "old_api": "GetNumberOfBlocks",
          "new_api": null,
          "old_text": "mapping_scheme.GetNumberOfBlocks()",
          "new_text": null,
          "old_line_content": "    llvm_ir::AddRangeMetadata(0, mapping_scheme.GetNumberOfBlocks(),",
          "new_line_content": "    IrArray::Index starting_block(linear_block_id,",
          "content_same": false
        },
        {
          "line": 2620,
          "old_api": "CreateIntCast",
          "new_api": null,
          "old_text": "b_.CreateIntCast(block_id, index_ty, /*isSigned=*/true, \"block.id.x\")",
          "new_text": null,
          "old_line_content": "        b_.CreateIntCast(block_id, index_ty, /*isSigned=*/true, \"block.id.x\");",
          "new_line_content": "                                  &b_);",
          "content_same": false
        },
        {
          "line": 2622,
          "old_api": "ShapeUtil::MakeShapeWithDescendingLayout(\n                                      PRED /*arbitrary*/, dims_in_blocks)",
          "new_api": null,
          "old_text": "ShapeUtil::MakeShapeWithDescendingLayout(\n                                      PRED /*arbitrary*/, dims_in_blocks)",
          "new_text": null,
          "old_line_content": "                                  ShapeUtil::MakeShapeWithDescendingLayout(",
          "new_line_content": "    std::vector<llvm::Value*> multidim = {",
          "content_same": false
        },
        {
          "line": 2627,
          "old_api": "GetTileSizeZ",
          "new_api": null,
          "old_text": "mapping_scheme.GetTileSizeZ()",
          "new_text": null,
          "old_line_content": "        b_.CreateMul(starting_block[0], constant(mapping_scheme.GetTileSizeZ()),",
          "new_line_content": "  }();",
          "content_same": false
        },
        {
          "line": 2630,
          "old_api": "IrArray::Index(multidim, dims_in_blocks, index_ty)",
          "new_api": null,
          "old_text": "IrArray::Index(multidim, dims_in_blocks, index_ty)",
          "new_text": null,
          "old_line_content": "    return IrArray::Index(multidim, dims_in_blocks, index_ty);",
          "new_line_content": "  for (int i = kDimY; i < kDimTot; ++i) {",
          "content_same": false
        },
        {
          "line": 2635,
          "old_api": "GetTileSizeFor",
          "new_api": null,
          "old_text": "mapping_scheme.GetTileSizeFor(i)",
          "new_text": null,
          "old_line_content": "    int64 tile_size_for_dim = mapping_scheme.GetTileSizeFor(i);",
          "new_line_content": "    int64 partial_row =",
          "content_same": false
        },
        {
          "line": 2647,
          "old_api": "multidim",
          "new_api": null,
          "old_text": "block_coords.multidim()",
          "new_text": null,
          "old_line_content": "    std::vector<llvm::Value*> elem_multi_index = block_coords.multidim();",
          "new_line_content": "          block_coords[i],",
          "content_same": false
        },
        {
          "line": 2650,
          "old_api": "CreateMul",
          "new_api": null,
          "old_text": "b_.CreateMul(\n          block_coords[i],\n          llvm::ConstantInt::get(index_ty, mapping_scheme.GetTileSizeFor(i)),\n          \"tile_origin.\" + std::to_string(i))",
          "new_text": null,
          "old_line_content": "      elem_multi_index[i] = b_.CreateMul(",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2652,
          "old_api": "GetTileSizeFor",
          "new_api": null,
          "old_text": "mapping_scheme.GetTileSizeFor(i)",
          "new_text": null,
          "old_line_content": "          llvm::ConstantInt::get(index_ty, mapping_scheme.GetTileSizeFor(i)),",
          "new_line_content": "                          index_ty);",
          "content_same": false
        },
        {
          "line": 2653,
          "old_api": "std::to_string(i)",
          "new_api": null,
          "old_text": "std::to_string(i)",
          "new_text": null,
          "old_line_content": "          \"tile_origin.\" + std::to_string(i));",
          "new_line_content": "  }();",
          "content_same": false
        },
        {
          "line": 2655,
          "old_api": "GetDimsInElems",
          "new_api": null,
          "old_text": "mapping_scheme.GetDimsInElems()",
          "new_text": null,
          "old_line_content": "    return IrArray::Index(elem_multi_index, mapping_scheme.GetDimsInElems(),",
          "new_line_content": "  auto emit_tile = [&](const IrArray::Index& tile) {",
          "content_same": false
        },
        {
          "line": 2665,
          "old_api": "emit_tile",
          "new_api": null,
          "old_text": "emit_tile(tile_origin)",
          "new_text": null,
          "old_line_content": "    emit_tile(tile_origin);",
          "new_line_content": "    llvm::Value* block_id_for_dim =",
          "content_same": false
        },
        {
          "line": 2668,
          "old_api": "GetTileSizeZ",
          "new_api": null,
          "old_text": "mapping_scheme.GetTileSizeZ()",
          "new_text": null,
          "old_line_content": "    llvm::Value* block_size_for_dim = constant(mapping_scheme.GetTileSizeZ());",
          "new_line_content": "    llvm::Value* last_block_size_for_dim =",
          "content_same": false
        },
        {
          "line": 2671,
          "old_api": "constant",
          "new_api": null,
          "old_text": "constant(dims_in_blocks[kDimZ] - 1)",
          "new_text": null,
          "old_line_content": "    llvm::Value* last_block_for_dim = constant(dims_in_blocks[kDimZ] - 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2674,
          "old_api": "GetTileSizeZ",
          "new_api": null,
          "old_text": "mapping_scheme.GetTileSizeZ()",
          "new_text": null,
          "old_line_content": "                 (dims_in_blocks[kDimZ] - 1) * mapping_scheme.GetTileSizeZ());",
          "new_line_content": "                        last_block_size_for_dim, block_size_for_dim);",
          "content_same": false
        },
        {
          "line": 2677,
          "old_api": "CreateICmpEQ",
          "new_api": null,
          "old_text": "b_.CreateICmpEQ(last_block_for_dim, block_id_for_dim)",
          "new_text": null,
          "old_line_content": "        b_.CreateSelect(b_.CreateICmpEQ(last_block_for_dim, block_id_for_dim),",
          "new_line_content": "            /*end=*/num_tiles_in_block,",
          "content_same": false
        },
        {
          "line": 2680,
          "old_api": "constant",
          "new_api": null,
          "old_text": "constant(0)",
          "new_text": null,
          "old_line_content": "            /*start=*/constant(0),",
          "new_line_content": "                  block_dim_induction_var, kDimZ, &b_);",
          "content_same": false
        },
        {
          "line": 2683,
          "old_api": "AddOffsetToDim",
          "new_api": null,
          "old_text": "tile_origin.AddOffsetToDim(\n                  block_dim_induction_var, kDimZ, &b_)",
          "new_text": null,
          "old_line_content": "              IrArray::Index tile_index = tile_origin.AddOffsetToDim(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2685,
          "old_api": "emit_tile",
          "new_api": null,
          "old_text": "emit_tile(tile_index)",
          "new_text": null,
          "old_line_content": "              emit_tile(tile_index);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2692,
          "old_api": "EmitCallToTargetIntrinsic",
          "new_api": null,
          "old_text": "EmitCallToTargetIntrinsic(TargetIntrinsicID::kBarrierId, {}, {}, &b_)",
          "new_text": null,
          "old_line_content": "  return EmitCallToTargetIntrinsic(TargetIntrinsicID::kBarrierId, {}, {}, &b_);",
          "new_line_content": "// algorithm to improve the memory access patterns for the input parameters",
          "content_same": false
        },
        {
          "line": 2723,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "  constexpr int kNumRows = 4;",
          "new_line_content": "                                     /*num_threads_x=*/kWarpSize,",
          "content_same": false
        },
        {
          "line": 2730,
          "old_api": "GetNumberOfBlocks",
          "new_api": null,
          "old_text": "mapping_scheme.GetNumberOfBlocks()",
          "new_text": null,
          "old_line_content": "  LaunchDimensions launch_dimensions(mapping_scheme.GetNumberOfBlocks(),",
          "new_line_content": "  std::vector<IrArray> param_arrays;",
          "content_same": false
        },
        {
          "line": 2731,
          "old_api": "GetThreadsPerBlock",
          "new_api": null,
          "old_text": "mapping_scheme.GetThreadsPerBlock()",
          "new_text": null,
          "old_line_content": "                                     mapping_scheme.GetThreadsPerBlock());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2733,
          "old_api": "launch_bound",
          "new_api": null,
          "old_text": "launch_dimensions.launch_bound()",
          "new_text": null,
          "old_line_content": "      GetIndexTypeForKernel(hlo, launch_dimensions.launch_bound(), &b_);",
          "new_line_content": "  // reduced shape and keep the reduced shape live during IR emission.",
          "content_same": false
        },
        {
          "line": 2739,
          "old_api": "operand_count",
          "new_api": null,
          "old_text": "hlo->operand_count()",
          "new_text": null,
          "old_line_content": "  std::vector<llvm::Value*> param_shmem_buffers(hlo->operand_count(), nullptr);",
          "new_line_content": "    // For Nvidia GPUs, the warp size is 32 threads and the shared memory bank",
          "content_same": false
        },
        {
          "line": 2749,
          "old_api": "GetTileSizeX",
          "new_api": null,
          "old_text": "llvm::ArrayType::get(\n        llvm::ArrayType::get(elem_ty, mapping_scheme.GetTileSizeX() + 1),\n        mapping_scheme.GetTileSizeY())",
          "new_text": null,
          "old_line_content": "    llvm::Type* buffer_type = llvm::ArrayType::get(",
          "new_line_content": "                                             buffer_type, buffer_name);",
          "content_same": false
        },
        {
          "line": 2750,
          "old_api": "GetTileSizeX",
          "new_api": null,
          "old_text": "mapping_scheme.GetTileSizeX()",
          "new_text": null,
          "old_line_content": "        llvm::ArrayType::get(elem_ty, mapping_scheme.GetTileSizeX() + 1),",
          "new_line_content": "  };",
          "content_same": false
        },
        {
          "line": 2751,
          "old_api": "GetTileSizeY",
          "new_api": null,
          "old_text": "mapping_scheme.GetTileSizeY()",
          "new_text": null,
          "old_line_content": "        mapping_scheme.GetTileSizeY());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2757,
          "old_api": "operand",
          "new_api": null,
          "old_text": "hlo->operand(id)",
          "new_text": null,
          "old_line_content": "    const HloInstruction* param = hlo->operand(id);",
          "new_line_content": "      param_shmem_buffers[id] =",
          "content_same": false
        },
        {
          "line": 2768,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "param->shape().element_type()",
          "new_text": null,
          "old_line_content": "          param->shape().element_type(),",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 2770,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "param_in_reduced_shape_arrays.push_back(\n          param_arrays[id].CastToShape(reduced_shape, &b_))",
          "new_text": null,
          "old_line_content": "      param_in_reduced_shape_arrays.push_back(",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2771,
          "old_api": "CastToShape",
          "new_api": null,
          "old_text": "param_arrays[id].CastToShape(reduced_shape, &b_)",
          "new_text": null,
          "old_line_content": "          param_arrays[id].CastToShape(reduced_shape, &b_));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2773,
          "old_api": "IrArray",
          "new_api": null,
          "old_text": "IrArray()",
          "new_text": null,
          "old_line_content": "      param_in_reduced_shape_arrays.push_back(IrArray());",
          "new_line_content": "  EmitElementFunction element_generator =",
          "content_same": false
        },
        {
          "line": 2784,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "hlo->opcode()",
          "new_text": null,
          "old_line_content": "          CHECK_EQ(hlo->opcode(), HloOpcode::kFusion);",
          "new_line_content": "      };",
          "content_same": false
        },
        {
          "line": 2785,
          "old_api": "EmitTileElementForFusion",
          "new_api": null,
          "old_text": "EmitTileElementForFusion(hlo, index, mapping_scheme, y_loc, x_loc,\n                                   param_shmem_buffers)",
          "new_text": null,
          "old_line_content": "          EmitTileElementForFusion(hlo, index, mapping_scheme, y_loc, x_loc,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2800,
          "old_api": "multidim",
          "new_api": null,
          "old_text": "index.multidim()",
          "new_text": null,
          "old_line_content": "              Permute({0, 2, 1}, index.multidim()),",
          "new_line_content": "          // tile[thread_id_y, thread_id_x] = input[index]",
          "content_same": false
        },
        {
          "line": 2801,
          "old_api": "GetType",
          "new_api": null,
          "old_text": "index.GetType()",
          "new_text": null,
          "old_line_content": "              Permute({0, 2, 1}, index.dims()), index.GetType());",
          "new_line_content": "          // Note that tile_width and tile_height are flipped here because we",
          "content_same": false
        },
        {
          "line": 2807,
          "old_api": "EmitReadArrayElement",
          "new_api": null,
          "old_text": "EmitTile(mapping_scheme, input_tile_origin, \"input\", ksl,\n                   thread_id_info, tile_width, tile_height,\n                   [&](const IrArray::Index& index, llvm::Value* y_loc,\n                       llvm::Value* x_loc, int64 /*x_iter_num*/) {\n                     for (int64 id : tiled_param_ids) {\n                       IrArray& input_in_logical_shape =\n                           param_in_reduced_shape_arrays[id];\n\n                       llvm::Value* shmem_buffer = param_shmem_buffers[id];\n                       llvm::Value* zero =\n                           llvm::ConstantInt::get(index_type, 0);\n                       // TODO(jlebar): Add AA metadata to this store.  Tile\n                       // buffers are global variables, so LLVM can't infer much\n                       // about it.\n                       Store(input_in_logical_shape.EmitReadArrayElement(\n                                 index, &b_, \"input_element\"),\n                             GEP(shmem_buffer, {zero, y_loc, x_loc}));\n                     }\n                   })",
          "new_text": null,
          "old_line_content": "          EmitTile(mapping_scheme, input_tile_origin, \"input\", ksl,",
          "new_line_content": "                     for (int64 id : tiled_param_ids) {",
          "content_same": false
        },
        {
          "line": 2821,
          "old_api": "EmitReadArrayElement",
          "new_api": null,
          "old_text": "input_in_logical_shape.EmitReadArrayElement(\n                                 index, &b_, \"input_element\")",
          "new_text": null,
          "old_line_content": "                       Store(input_in_logical_shape.EmitReadArrayElement(",
          "new_line_content": "                   });",
          "content_same": false
        },
        {
          "line": 2823,
          "old_api": "GEP",
          "new_api": null,
          "old_text": "GEP(shmem_buffer, {zero, y_loc, x_loc})",
          "new_text": null,
          "old_line_content": "                             GEP(shmem_buffer, {zero, y_loc, x_loc}));",
          "new_line_content": "          // Wait for all threads to reach this point using `__syncthreads` in",
          "content_same": false
        },
        {
          "line": 2829,
          "old_api": "EmitSyncThreads",
          "new_api": null,
          "old_text": "EmitSyncThreads()",
          "new_text": null,
          "old_line_content": "          EmitSyncThreads();",
          "new_line_content": "                 tile_height, tile_width, element_generator);",
          "content_same": false
        },
        {
          "line": 2832,
          "old_api": "EmitTile",
          "new_api": null,
          "old_text": "EmitTile(mapping_scheme, index, loop_name, ksl, thread_id_info,\n                 tile_height, tile_width, element_generator)",
          "new_text": null,
          "old_line_content": "        EmitTile(mapping_scheme, index, loop_name, ksl, thread_id_info,",
          "new_line_content": "        // If a tile block contains multiple tiles and shared memory buffers are",
          "content_same": false
        },
        {
          "line": 2834,
          "old_api": "GetTileSizeZ",
          "new_api": null,
          "old_text": "mapping_scheme.GetTileSizeZ()",
          "new_text": null,
          "old_line_content": "        bool block_contains_multi_tiles = mapping_scheme.GetTileSizeZ() > 1;",
          "new_line_content": "        // memory buffer for the current tile before we move on to process the",
          "content_same": false
        },
        {
          "line": 2840,
          "old_api": "empty",
          "new_api": null,
          "old_text": "tiled_param_ids.empty()",
          "new_text": null,
          "old_line_content": "        if (block_contains_multi_tiles && !tiled_param_ids.empty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2841,
          "old_api": "EmitSyncThreads",
          "new_api": null,
          "old_text": "EmitSyncThreads()",
          "new_text": null,
          "old_line_content": "          EmitSyncThreads();",
          "new_line_content": "  // For multioutput fusion, one thread needs to output a tuple",
          "content_same": false
        },
        {
          "line": 2851,
          "old_api": "IsMultiOutputFusion",
          "new_api": null,
          "old_text": "hlo->IsMultiOutputFusion()",
          "new_text": null,
          "old_line_content": "  if (hlo->IsMultiOutputFusion()) {",
          "new_line_content": "    });",
          "content_same": false
        },
        {
          "line": 2852,
          "old_api": "IsBlock0Thread0",
          "new_api": null,
          "old_text": "IsBlock0Thread0(&b_)",
          "new_text": null,
          "old_line_content": "    KernelSupportLibrary{&b_}.If(\"emit_mof_tuple\", IsBlock0Thread0(&b_), [&] {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2853,
          "old_api": "GetIrArray",
          "new_api": null,
          "old_text": "GetIrArray(*hlo, *hlo)",
          "new_text": null,
          "old_line_content": "      llvm_ir::EmitTuple(GetIrArray(*hlo, *hlo),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2858,
          "old_api": "EmitTilingKernel",
          "new_api": null,
          "old_text": "EmitTilingKernel(mapping_scheme, index_type, tile_generator)",
          "new_text": null,
          "old_line_content": "  EmitTilingKernel(mapping_scheme, index_type, tile_generator);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2859,
          "old_api": "llvm_module",
          "new_api": null,
          "old_text": "UpdateLaunchDimensions(launch_dimensions, kernel_thunk,\n                         ir_emitter_context_->llvm_module())",
          "new_text": null,
          "old_line_content": "  UpdateLaunchDimensions(launch_dimensions, kernel_thunk,",
          "new_line_content": "namespace {",
          "content_same": false
        },
        {
          "line": 2860,
          "old_api": "llvm_module",
          "new_api": null,
          "old_text": "ir_emitter_context_->llvm_module()",
          "new_text": null,
          "old_line_content": "                         ir_emitter_context_->llvm_module());",
          "new_line_content": "// A recursive function to inspect the users of a parameter to determine",
          "content_same": false
        },
        {
          "line": 2903,
          "old_api": "IsElementwise",
          "new_api": null,
          "old_text": "hlo->IsElementwise()",
          "new_text": null,
          "old_line_content": "  if (hlo->IsElementwise()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2904,
          "old_api": "users",
          "new_api": null,
          "old_text": "hlo->users()",
          "new_text": null,
          "old_line_content": "    return absl::c_all_of(hlo->users(), [&](const HloInstruction* user) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2909,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "hlo->opcode()",
          "new_text": null,
          "old_line_content": "  switch (hlo->opcode()) {",
          "new_line_content": "      // The result of the operation doesn't rely on the content of the",
          "content_same": false
        },
        {
          "line": 2921,
          "old_api": "users",
          "new_api": null,
          "old_text": "hlo->users()",
          "new_text": null,
          "old_line_content": "      return absl::c_all_of(hlo->users(), [&](const HloInstruction* user) {",
          "new_line_content": "    default:",
          "content_same": false
        },
        {
          "line": 2922,
          "old_api": "IsInstructionSafeForShmemTranspose",
          "new_api": null,
          "old_text": "IsInstructionSafeForShmemTranspose(user)",
          "new_text": null,
          "old_line_content": "        return IsInstructionSafeForShmemTranspose(user);",
          "new_line_content": "      return false;",
          "content_same": false
        },
        {
          "line": 2945,
          "old_api": "size",
          "new_api": null,
          "old_text": "input_ids.size()",
          "new_text": null,
          "old_line_content": "  for (int64 i = 0; i < input_ids.size(); ++i) {",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 2947,
          "old_api": "IsInstructionSafeForShmemTranspose",
          "new_api": null,
          "old_text": "IsInstructionSafeForShmemTranspose(input)",
          "new_text": null,
          "old_line_content": "    if (IsInstructionSafeForShmemTranspose(input)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2948,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "filtered_input_ids.push_back(input_ids[i])",
          "new_text": null,
          "old_line_content": "      filtered_input_ids.push_back(input_ids[i]);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2950,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "input->ToString()",
          "new_text": null,
          "old_line_content": "      VLOG(10) << \"Input not safe for shmem transpose \" << input->ToString();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2963,
          "old_api": "IsMultiOutputFusion",
          "new_api": null,
          "old_text": "hlo->IsMultiOutputFusion()",
          "new_text": null,
          "old_line_content": "  const Shape& output_shape = hlo->IsMultiOutputFusion()",
          "new_line_content": "  // If the output_shape is reduced to 021 shape, find all the parameters of",
          "content_same": false
        },
        {
          "line": 2964,
          "old_api": "shape",
          "new_api": null,
          "old_text": "hlo->shape()",
          "new_text": null,
          "old_line_content": "                                  ? ShapeUtil::GetSubshape(hlo->shape(), {0})",
          "new_line_content": "  // the HLO that are in the corresponding 012 shape.",
          "content_same": false
        },
        {
          "line": 2965,
          "old_api": "shape",
          "new_api": null,
          "old_text": "hlo->shape()",
          "new_text": null,
          "old_line_content": "                                  : hlo->shape();",
          "new_line_content": "  std::vector<int64> params_012;",
          "content_same": false
        },
        {
          "line": 2973,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "hlo->mutable_operand(operand_idx)",
          "new_text": null,
          "old_line_content": "    HloInstruction* operand = hlo->mutable_operand(operand_idx);",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 2975,
          "old_api": "shape",
          "new_api": null,
          "old_text": "operand->shape()",
          "new_text": null,
          "old_line_content": "        ShapeUtil::FindTranspose021(operand->shape(), output_shape);",
          "new_line_content": "    const std::vector<int64>& curr_reduced_dims_021 = *find_transpose_result;",
          "content_same": false
        },
        {
          "line": 2980,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "reduced_dims_021.has_value()",
          "new_text": null,
          "old_line_content": "    if (!reduced_dims_021.has_value()) {",
          "new_line_content": "      // There is more than one possible transpose. Instead of picking one",
          "content_same": false
        },
        {
          "line": 2983,
          "old_api": "absl::c_equal(*reduced_dims_021, curr_reduced_dims_021)",
          "new_api": null,
          "old_text": "absl::c_equal(*reduced_dims_021, curr_reduced_dims_021)",
          "new_text": null,
          "old_line_content": "    if (!absl::c_equal(*reduced_dims_021, curr_reduced_dims_021)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2988,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "params_012.push_back(operand_idx)",
          "new_text": null,
          "old_line_content": "    params_012.push_back(operand_idx);",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 2991,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "reduced_dims_021.has_value()",
          "new_text": null,
          "old_line_content": "  if (!reduced_dims_021.has_value()) {",
          "new_line_content": "  if ((*reduced_dims_021)[1] < kMinDimensionToTransposeTiled ||",
          "content_same": false
        },
        {
          "line": 3001,
          "old_api": "FilterInputsForShmemTranspose",
          "new_api": null,
          "old_text": "FilterInputsForShmemTranspose(hlo, params_012)",
          "new_text": null,
          "old_line_content": "    params_012 = FilterInputsForShmemTranspose(hlo, params_012);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3002,
          "old_api": "empty",
          "new_api": null,
          "old_text": "params_012.empty()",
          "new_text": null,
          "old_line_content": "    if (params_012.empty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3026,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "  constexpr int64 kShmemPerCore = 48 * 1024;",
          "new_line_content": "    shmem_used +=",
          "content_same": false
        },
        {
          "line": 3029,
          "old_api": "operand",
          "new_api": null,
          "old_text": "hlo->operand(params_012[i])",
          "new_text": null,
          "old_line_content": "    const HloInstruction* operand = hlo->operand(params_012[i]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3036,
          "old_api": "resize",
          "new_api": null,
          "old_text": "params_012.resize(i)",
          "new_text": null,
          "old_line_content": "      params_012.resize(i);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3047,
          "old_api": "BuildKernelThunk",
          "new_api": null,
          "old_text": "BuildKernelThunk(hlo, /*implements_whole_instruction=*/true)",
          "new_text": null,
          "old_line_content": "      BuildKernelThunk(hlo, /*implements_whole_instruction=*/true);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3048,
          "old_api": "get",
          "new_api": null,
          "old_text": "kernel_thunk.get()",
          "new_text": null,
          "old_line_content": "  EmitHlo021Tile(hlo, kernel_thunk.get(), *reduced_dims_021, params_012);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3049,
          "old_api": "std::move(kernel_thunk)",
          "new_api": null,
          "old_text": "std::move(kernel_thunk)",
          "new_text": null,
          "old_line_content": "  AddThunkToThunkSequence(std::move(kernel_thunk));",
          "new_line_content": "namespace {",
          "content_same": false
        },
        {
          "line": 3059,
          "old_api": "users",
          "new_api": null,
          "old_text": "hlo->users()",
          "new_text": null,
          "old_line_content": "  return absl::c_all_of(hlo->users(), [&](const HloInstruction* user) {",
          "new_line_content": "  });",
          "content_same": false
        },
        {
          "line": 3060,
          "old_api": "count",
          "new_api": null,
          "old_text": "use_chain_endings.count(user)",
          "new_text": null,
          "old_line_content": "    return use_chain_endings.count(user) ||",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3061,
          "old_api": "IsElementwise",
          "new_api": null,
          "old_text": "user->IsElementwise()",
          "new_text": null,
          "old_line_content": "           (user->IsElementwise() &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3062,
          "old_api": "AreUsersElementwise",
          "new_api": null,
          "old_text": "AreUsersElementwise(user, use_chain_endings)",
          "new_text": null,
          "old_line_content": "            AreUsersElementwise(user, use_chain_endings));",
          "new_line_content": "// Returns the number of fusion inputs that have the same dimension as the",
          "content_same": false
        },
        {
          "line": 3072,
          "old_api": "fused_parameters",
          "new_api": null,
          "old_text": "unnested_hlo->fused_parameters()",
          "new_text": null,
          "old_line_content": "      unnested_hlo->fused_parameters(), [&](const HloInstruction* parameter) {",
          "new_line_content": "      });",
          "content_same": false
        },
        {
          "line": 3073,
          "old_api": "shape",
          "new_api": null,
          "old_text": "parameter->shape()",
          "new_text": null,
          "old_line_content": "        const Shape& parameter_shape = parameter->shape();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3074,
          "old_api": "ShapeUtil::SameDimensions(op_shape, parameter_shape)",
          "new_api": null,
          "old_text": "ShapeUtil::SameDimensions(op_shape, parameter_shape)",
          "new_text": null,
          "old_line_content": "        return ShapeUtil::SameDimensions(op_shape, parameter_shape) &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3075,
          "old_api": "AreUsersElementwise",
          "new_api": null,
          "old_text": "AreUsersElementwise(parameter, use_chain_endings)",
          "new_text": null,
          "old_line_content": "               AreUsersElementwise(parameter, use_chain_endings);",
          "new_line_content": "// Returns the number of fusion inputs that have more elements than the given",
          "content_same": false
        },
        {
          "line": 3083,
          "old_api": "ShapeUtil::ElementsIn(shape)",
          "new_api": null,
          "old_text": "ShapeUtil::ElementsIn(shape)",
          "new_text": null,
          "old_line_content": "  int64 num_elements = ShapeUtil::ElementsIn(shape);",
          "new_line_content": "      });",
          "content_same": false
        },
        {
          "line": 3084,
          "old_api": "fused_parameters",
          "new_api": null,
          "old_text": "absl::c_count_if(\n      unnested_hlo->fused_parameters(), [&](const HloInstruction* parameter) {\n        return ShapeUtil::ElementsIn(parameter->shape()) > num_elements;\n      })",
          "new_text": null,
          "old_line_content": "  return absl::c_count_if(",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3085,
          "old_api": "fused_parameters",
          "new_api": null,
          "old_text": "unnested_hlo->fused_parameters()",
          "new_text": null,
          "old_line_content": "      unnested_hlo->fused_parameters(), [&](const HloInstruction* parameter) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3086,
          "old_api": "shape",
          "new_api": null,
          "old_text": "parameter->shape()",
          "new_text": null,
          "old_line_content": "        return ShapeUtil::ElementsIn(parameter->shape()) > num_elements;",
          "new_line_content": "// The benefit of unrolling a kInput fusion that is a column reduction comes",
          "content_same": false
        },
        {
          "line": 3109,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "unnested_hlo->opcode()",
          "new_text": null,
          "old_line_content": "  CHECK_EQ(unnested_hlo->opcode(), HloOpcode::kFusion);",
          "new_line_content": "  ConstHloInstructionSet use_chain_endings;",
          "content_same": false
        },
        {
          "line": 3112,
          "old_api": "fused_expression_root",
          "new_api": null,
          "old_text": "unnested_hlo->fused_expression_root()",
          "new_text": null,
          "old_line_content": "  const HloInstruction* fused_root = unnested_hlo->fused_expression_root();",
          "new_line_content": "    // Atomic.add of the reduction result can't be vectorized.",
          "content_same": false
        },
        {
          "line": 3114,
          "old_api": "IsReductionFromOrToContiguousDimensions",
          "new_api": null,
          "old_text": "IsReductionFromOrToContiguousDimensions(*fused_root)",
          "new_text": null,
          "old_line_content": "  if (IsReductionFromOrToContiguousDimensions(*fused_root)) {",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 3119,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "fused_root->opcode()",
          "new_text": null,
          "old_line_content": "    CHECK_EQ(fused_root->opcode(), HloOpcode::kTuple);",
          "new_line_content": "        cannot_be_vectorized++;",
          "content_same": false
        },
        {
          "line": 3120,
          "old_api": "operands",
          "new_api": null,
          "old_text": "fused_root->operands()",
          "new_text": null,
          "old_line_content": "    for (const HloInstruction* instr : fused_root->operands()) {",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 3121,
          "old_api": "IsReductionFromOrToContiguousDimensions",
          "new_api": null,
          "old_text": "IsReductionFromOrToContiguousDimensions(*instr)",
          "new_text": null,
          "old_line_content": "      if (IsReductionFromOrToContiguousDimensions(*instr)) {",
          "new_line_content": "        // Write of the non-reduction result can be vectorized.",
          "content_same": false
        },
        {
          "line": 3128,
          "old_api": "insert",
          "new_api": null,
          "old_text": "use_chain_endings.insert(instr)",
          "new_text": null,
          "old_line_content": "      use_chain_endings.insert(instr);",
          "new_line_content": "  // only involve in elementwise operations can be vectorized.",
          "content_same": false
        },
        {
          "line": 3133,
          "old_api": "NumInputsInvolveInOnlyElementwiseOps",
          "new_api": null,
          "old_text": "NumInputsInvolveInOnlyElementwiseOps(\n      unnested_hlo, input_shape, use_chain_endings)",
          "new_text": null,
          "old_line_content": "  can_be_vectorized += NumInputsInvolveInOnlyElementwiseOps(",
          "new_line_content": "  // for the purpose of estimating the benefit of unrolling. If the kernel is",
          "content_same": false
        },
        {
          "line": 3141,
          "old_api": "NumInputsWithMoreElementsThan",
          "new_api": null,
          "old_text": "NumInputsWithMoreElementsThan(unnested_hlo, input_shape)",
          "new_text": null,
          "old_line_content": "      NumInputsWithMoreElementsThan(unnested_hlo, input_shape);",
          "new_line_content": "}  // namespace",
          "content_same": false
        },
        {
          "line": 3149,
          "old_api": "operand",
          "new_api": null,
          "old_text": "first_reduce->operand(0)->shape()",
          "new_text": null,
          "old_line_content": "  const Shape& input_shape = first_reduce->operand(0)->shape();",
          "new_line_content": "           << \" \" << reduction_dimensions.dimensions[0] << \" \"",
          "content_same": false
        },
        {
          "line": 3151,
          "old_api": "GetReductionKindAndContiguousComponents",
          "new_api": null,
          "old_text": "GetReductionKindAndContiguousComponents(*first_reduce)",
          "new_text": null,
          "old_line_content": "      GetReductionKindAndContiguousComponents(*first_reduce);",
          "new_line_content": "           << reduction_dimensions.dimensions[2];",
          "content_same": false
        },
        {
          "line": 3152,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(10)",
          "new_text": null,
          "old_line_content": "  VLOG(10) << \"is_row_reduction \" << reduction_dimensions.is_row_reduction",
          "new_line_content": "  auto get_dtype_bits = [](const HloInstruction* i) {",
          "content_same": false
        },
        {
          "line": 3157,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "i->shape().element_type()",
          "new_text": null,
          "old_line_content": "    return primitive_util::BitWidth(i->shape().element_type());",
          "new_line_content": "  // select the reduction_tiling.",
          "content_same": false
        },
        {
          "line": 3162,
          "old_api": "operand",
          "new_api": null,
          "old_text": "first_reduce->operand(0)",
          "new_text": null,
          "old_line_content": "  int smallest_input_dtype_bits = get_dtype_bits(first_reduce->operand(0));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3163,
          "old_api": "operands",
          "new_api": null,
          "old_text": "unnested_hlo->operands()",
          "new_text": null,
          "old_line_content": "  for (xla::HloInstruction* input : unnested_hlo->operands()) {",
          "new_line_content": "  std::array<int64, 3> reduction_tiling =",
          "content_same": false
        },
        {
          "line": 3169,
          "old_api": "device_description",
          "new_api": null,
          "old_text": "ir_emitter_context_->device_description()",
          "new_text": null,
          "old_line_content": "                         &ir_emitter_context_->device_description());",
          "new_line_content": "                                            reduction_dimensions.dimensions[2]);",
          "content_same": false
        },
        {
          "line": 3172,
          "old_api": "IsUnrollingColumnReductionBeneficial",
          "new_api": null,
          "old_text": "IsUnrollingColumnReductionBeneficial(unnested_hlo, input_shape,\n                                            reduction_dimensions.dimensions[2])",
          "new_text": null,
          "old_line_content": "      !IsUnrollingColumnReductionBeneficial(unnested_hlo, input_shape,",
          "new_line_content": "  if (reduction_dimensions.is_row_reduction &&",
          "content_same": false
        },
        {
          "line": 3182,
          "old_api": "IsUnrollingColumnReductionBeneficial",
          "new_api": null,
          "old_text": "IsUnrollingColumnReductionBeneficial(\n                 unnested_hlo, input_shape,\n                 reduction_dimensions.dimensions[2])",
          "new_text": null,
          "old_line_content": "  } else if (IsUnrollingColumnReductionBeneficial(",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 3199,
          "old_api": "std::min(\n          kWarpSize * kWarpSize,\n          RoundUpToNearest(CeilOfRatio(reduction_dimensions.dimensions[2],\n                                       reduction_tiling[2]),\n                           kWarpSize))",
          "new_api": null,
          "old_text": "std::min(\n          kWarpSize * kWarpSize,\n          RoundUpToNearest(CeilOfRatio(reduction_dimensions.dimensions[2],\n                                       reduction_tiling[2]),\n                           kWarpSize))",
          "new_text": null,
          "old_line_content": "      return std::min(",
          "new_line_content": "                           kWarpSize));",
          "content_same": false
        },
        {
          "line": 3201,
          "old_api": "CeilOfRatio",
          "new_api": null,
          "old_text": "CeilOfRatio(reduction_dimensions.dimensions[2],\n                                       reduction_tiling[2])",
          "new_text": null,
          "old_line_content": "          RoundUpToNearest(CeilOfRatio(reduction_dimensions.dimensions[2],",
          "new_line_content": "    return kWarpSize;",
          "content_same": false
        },
        {
          "line": 3215,
          "old_api": "MayPreventVectorization",
          "new_api": null,
          "old_text": "MayPreventVectorization(*unnested_hlo)",
          "new_text": null,
          "old_line_content": "        !MayPreventVectorization(*unnested_hlo)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3225,
          "old_api": "ReductionCodegenInfo",
          "new_api": null,
          "old_text": "ReductionCodegenInfo(mapping_scheme,\n                              reduction_dimensions.is_row_reduction)",
          "new_text": null,
          "old_line_content": "  return ReductionCodegenInfo(mapping_scheme,",
          "new_line_content": "Status IrEmitterUnnested::EmitReductionFromOrToContiguousDimensions(",
          "content_same": false
        },
        {
          "line": 3232,
          "old_api": "size",
          "new_api": null,
          "old_text": "output_instructions.size()",
          "new_text": null,
          "old_line_content": "  bool returns_tuple = output_instructions.size() > 1;",
          "new_line_content": "  InlinedVector<ShapeIndex, 1> reduction_output_shape_indices;",
          "content_same": false
        },
        {
          "line": 3233,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "unnested_hlo->ToString()",
          "new_text": null,
          "old_line_content": "  VLOG(10) << \"Emitting reduction to vector \" << unnested_hlo->ToString();",
          "new_line_content": "  InlinedVector<HloComputation*, 1> reducers;",
          "content_same": false
        },
        {
          "line": 3241,
          "old_api": "size",
          "new_api": null,
          "old_text": "output_instructions.size()",
          "new_text": null,
          "old_line_content": "  for (int i = 0; i < output_instructions.size(); ++i) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3242,
          "old_api": "IsReductionFromOrToContiguousDimensions",
          "new_api": null,
          "old_text": "IsReductionFromOrToContiguousDimensions(*output_instructions[i])",
          "new_text": null,
          "old_line_content": "    if (!IsReductionFromOrToContiguousDimensions(*output_instructions[i])) {",
          "new_line_content": "    HloInstruction* output_instruction = output_instructions[i];",
          "content_same": false
        },
        {
          "line": 3247,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "reduce_instructions.push_back(output_instruction)",
          "new_text": null,
          "old_line_content": "    reduce_instructions.push_back(output_instruction);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3252,
          "old_api": "TF_ASSIGN_OR_RETURN",
          "new_api": null,
          "old_text": "TF_ASSIGN_OR_RETURN(std::unique_ptr<Thunk> initializer_thunk,\n                        BuildInitializerThunk(unnested_hlo, idx))",
          "new_text": null,
          "old_line_content": "    TF_ASSIGN_OR_RETURN(std::unique_ptr<Thunk> initializer_thunk,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3258,
          "old_api": "size",
          "new_api": null,
          "old_text": "output_instructions.size()",
          "new_text": null,
          "old_line_content": "  if (output_instructions.size() > 1) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3259,
          "old_api": "AreFusedReductionOutputsConsistent",
          "new_api": null,
          "old_text": "AreFusedReductionOutputsConsistent(output_instructions,\n                                            first_reduce)",
          "new_text": null,
          "old_line_content": "    if (!AreFusedReductionOutputsConsistent(output_instructions,",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3261,
          "old_api": "InternalError",
          "new_api": null,
          "old_text": "InternalError(\"Inconsistent reduction fusion outputs\")",
          "new_text": null,
          "old_line_content": "      return InternalError(\"Inconsistent reduction fusion outputs\");",
          "new_line_content": "  // Build a kernel thunk to compute all the outputs.",
          "content_same": false
        },
        {
          "line": 3267,
          "old_api": "BuildKernelThunk",
          "new_api": null,
          "old_text": "BuildKernelThunk(unnested_hlo, /*implements_whole_instruction=*/false)",
          "new_text": null,
          "old_line_content": "      BuildKernelThunk(unnested_hlo, /*implements_whole_instruction=*/false);",
          "new_line_content": "  // unnested kReduce or by InstructionFusion for fused kReduce.",
          "content_same": false
        },
        {
          "line": 3269,
          "old_api": "operand",
          "new_api": null,
          "old_text": "first_reduce->operand(0)->shape()",
          "new_text": null,
          "old_line_content": "  const Shape& input_shape = first_reduce->operand(0)->shape();",
          "new_line_content": "                                     \"doesn't set the input layout of \"",
          "content_same": false
        },
        {
          "line": 3272,
          "old_api": "has_layout",
          "new_api": null,
          "old_text": "input_shape.has_layout()",
          "new_text": null,
          "old_line_content": "  CHECK(input_shape.has_layout()) << \"LayoutAssignment or InstructionFusion \"",
          "new_line_content": "  ReductionCodegenInfo reduction_info =",
          "content_same": false
        },
        {
          "line": 3274,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "first_reduce->ToString()",
          "new_text": null,
          "old_line_content": "                                  << first_reduce->ToString();",
          "new_line_content": "  const KernelMappingScheme& mapping_scheme =",
          "content_same": false
        },
        {
          "line": 3281,
          "old_api": "GetThreadsPerBlock",
          "new_api": null,
          "old_text": "mapping_scheme.GetThreadsPerBlock()",
          "new_text": null,
          "old_line_content": "                                     mapping_scheme.GetThreadsPerBlock());",
          "new_line_content": "                           index_ty);",
          "content_same": false
        },
        {
          "line": 3282,
          "old_api": "launch_bound",
          "new_api": null,
          "old_text": "GetIndexTypeForKernel(\n      unnested_hlo, launch_dimensions.launch_bound(), &b_)",
          "new_text": null,
          "old_line_content": "  llvm::Type* index_ty = GetIndexTypeForKernel(",
          "new_line_content": "  EmitElementFunction emit_reduction_tile =",
          "content_same": false
        },
        {
          "line": 3283,
          "old_api": "launch_bound",
          "new_api": null,
          "old_text": "launch_dimensions.launch_bound()",
          "new_text": null,
          "old_line_content": "      unnested_hlo, launch_dimensions.launch_bound(), &b_);",
          "new_line_content": "      [&](const llvm_ir::IrArray::Index& index, llvm::Value* y_loc,",
          "content_same": false
        },
        {
          "line": 3284,
          "old_api": "EmitPrologueForReduction",
          "new_api": null,
          "old_text": "EmitPrologueForReduction(unnested_hlo, &reduction_info, reduce_instructions,\n                           index_ty)",
          "new_text": null,
          "old_line_content": "  EmitPrologueForReduction(unnested_hlo, &reduction_info, reduce_instructions,",
          "new_line_content": "          llvm::Value* x_loc, int64 x_iter_num) {",
          "content_same": false
        },
        {
          "line": 3289,
          "old_api": "EmitTileElementForReduction",
          "new_api": null,
          "old_text": "EmitTileElementForReduction(unnested_hlo, input_shape,\n                                    output_instructions, index, reduction_info,\n                                    reducers, x_iter_num)",
          "new_text": null,
          "old_line_content": "        EmitTileElementForReduction(unnested_hlo, input_shape,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3294,
          "old_api": "GetKernelMappingScheme",
          "new_api": null,
          "old_text": "EmitTilingKernel(\n      mapping_scheme, index_ty,\n      [&](const ThreadIdInfo& thread_id_info, const IrArray::Index& index,\n          const string& loop_name, llvm::Value* tile_height,\n          llvm::Value* tile_width, KernelSupportLibrary* ksl) {\n        EmitTile(reduction_info.GetKernelMappingScheme(), index, loop_name, ksl,\n                 thread_id_info, tile_height, tile_width, emit_reduction_tile);\n      })",
          "new_text": null,
          "old_line_content": "  TilingKernelInfo tiling_kernel_info = EmitTilingKernel(",
          "new_line_content": "          llvm::Value* tile_width, KernelSupportLibrary* ksl) {",
          "content_same": false
        },
        {
          "line": 3299,
          "old_api": "GetKernelMappingScheme",
          "new_api": null,
          "old_text": "reduction_info.GetKernelMappingScheme()",
          "new_text": null,
          "old_line_content": "        EmitTile(reduction_info.GetKernelMappingScheme(), index, loop_name, ksl,",
          "new_line_content": "                           reduce_instructions, reduction_output_shape_indices,",
          "content_same": false
        },
        {
          "line": 3306,
          "old_api": "get",
          "new_api": null,
          "old_text": "kernel_thunk.get()",
          "new_text": null,
          "old_line_content": "  UpdateLaunchDimensions(launch_dimensions, kernel_thunk.get(),",
          "new_line_content": "  auto sequential_thunk =",
          "content_same": false
        },
        {
          "line": 3309,
          "old_api": "std::move(kernel_thunk)",
          "new_api": null,
          "old_text": "std::move(kernel_thunk)",
          "new_text": null,
          "old_line_content": "  thunks.push_back(std::move(kernel_thunk));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3311,
          "old_api": "std::move(thunks)",
          "new_api": null,
          "old_text": "std::move(thunks)",
          "new_text": null,
          "old_line_content": "      absl::make_unique<SequentialThunk>(std::move(thunks), unnested_hlo);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3312,
          "old_api": "std::move(sequential_thunk)",
          "new_api": null,
          "old_text": "std::move(sequential_thunk)",
          "new_text": null,
          "old_line_content": "  AddThunkToThunkSequence(std::move(sequential_thunk));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3314,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  for (const BufferAllocation& allocation :",
          "content_same": false
        },
        {
          "line": 3319,
          "old_api": "Allocations",
          "new_api": null,
          "old_text": "ir_emitter_context_->buffer_assignment().Allocations()",
          "new_text": null,
          "old_line_content": "       ir_emitter_context_->buffer_assignment().Allocations()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3324,
          "old_api": "llvm_ir::LiteralForConstantAllocation(allocation)",
          "new_api": null,
          "old_text": "llvm_ir::LiteralForConstantAllocation(allocation)",
          "new_text": null,
          "old_line_content": "    const Literal& literal = llvm_ir::LiteralForConstantAllocation(allocation);",
          "new_line_content": "    llvm::Constant* initializer =",
          "content_same": false
        },
        {
          "line": 3325,
          "old_api": "ShouldEmitLiteralInLlvmIr",
          "new_api": null,
          "old_text": "ShouldEmitLiteralInLlvmIr(literal)",
          "new_text": null,
          "old_line_content": "    const bool should_emit_initializer = ShouldEmitLiteralInLlvmIr(literal);",
          "new_line_content": "        should_emit_initializer",
          "content_same": false
        },
        {
          "line": 3331,
          "old_api": "llvm::ConstantAggregateZero::get(global_type)",
          "new_api": null,
          "old_text": "llvm::ConstantAggregateZero::get(global_type)",
          "new_text": null,
          "old_line_content": "            : llvm::ConstantAggregateZero::get(global_type);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3333,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \"Emitted initializer for constant with shape \"",
          "new_line_content": "    // These globals will be looked up by name by GpuExecutable so we need to",
          "content_same": false
        },
        {
          "line": 3334,
          "old_api": "shape",
          "new_api": null,
          "old_text": "literal.shape()",
          "new_text": null,
          "old_line_content": "              << ShapeUtil::HumanString(literal.shape());",
          "new_line_content": "    // give them an external linkage.  Not all of their uses are visible in",
          "content_same": false
        },
        {
          "line": 3345,
          "old_api": "llvm_module",
          "new_api": null,
          "old_text": "llvm_ir::GetGlobalMemoryAddressSpace(\n        *ir_emitter_context_->llvm_module())",
          "new_text": null,
          "old_line_content": "    unsigned global_address_space = llvm_ir::GetGlobalMemoryAddressSpace(",
          "new_line_content": "        llvm::GlobalValue::ExternalLinkage,",
          "content_same": false
        },
        {
          "line": 3346,
          "old_api": "llvm_module",
          "new_api": null,
          "old_text": "ir_emitter_context_->llvm_module()",
          "new_text": null,
          "old_line_content": "        *ir_emitter_context_->llvm_module());",
          "new_line_content": "        /*Initializer=*/initializer,",
          "content_same": false
        },
        {
          "line": 3355,
          "old_api": "setAlignment",
          "new_api": null,
          "old_text": "global_for_const->setAlignment(kConstantBufferAlignBytes)",
          "new_text": null,
          "old_line_content": "    global_for_const->setAlignment(kConstantBufferAlignBytes);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3360,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "// a guarding condition is generated for each ROOT slice.",
          "content_same": false
        },
        {
          "line": 3384,
          "old_api": "fused_expression_root",
          "new_api": null,
          "old_text": "unnested_hlo->fused_expression_root()",
          "new_text": null,
          "old_line_content": "  HloInstruction* slice_or_tuple = unnested_hlo->fused_expression_root();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3387,
          "old_api": "absl::Span<HloInstruction* const>(&slice_or_tuple, 1)",
          "new_api": null,
          "old_text": "absl::Span<HloInstruction* const>(&slice_or_tuple, 1)",
          "new_text": null,
          "old_line_content": "      return absl::Span<HloInstruction* const>(&slice_or_tuple, 1);",
          "new_line_content": "  }();",
          "content_same": false
        },
        {
          "line": 3389,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "slice_or_tuple->opcode()",
          "new_text": null,
          "old_line_content": "    CHECK_EQ(slice_or_tuple->opcode(), HloOpcode::kTuple);",
          "new_line_content": "  // Emit input operand values of slices.",
          "content_same": false
        },
        {
          "line": 3390,
          "old_api": "operands",
          "new_api": null,
          "old_text": "slice_or_tuple->operands()",
          "new_text": null,
          "old_line_content": "    return slice_or_tuple->operands();",
          "new_line_content": "  std::vector<llvm::Value*> input_ir_values;",
          "content_same": false
        },
        {
          "line": 3396,
          "old_api": "GetNestedComputer",
          "new_api": null,
          "old_text": "GetNestedComputer()",
          "new_text": null,
          "old_line_content": "                                     GetNestedComputer());",
          "new_line_content": "  for (const HloInstruction* slice : slice_instructions) {",
          "content_same": false
        },
        {
          "line": 3399,
          "old_api": "fused_expression_root",
          "new_api": null,
          "old_text": "unnested_hlo->fused_expression_root()->Accept(&fused_emitter)",
          "new_text": null,
          "old_line_content": "  TF_CHECK_OK(unnested_hlo->fused_expression_root()->Accept(&fused_emitter));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3401,
          "old_api": "operand",
          "new_api": null,
          "old_text": "slice->operand(0)",
          "new_text": null,
          "old_line_content": "    auto input_generator = fused_emitter.GetGenerator(slice->operand(0));",
          "new_line_content": "  // Emit for slice_instructions.",
          "content_same": false
        },
        {
          "line": 3402,
          "old_api": "ValueOrDie",
          "new_api": null,
          "old_text": "input_generator(index).ValueOrDie()",
          "new_text": null,
          "old_line_content": "    input_ir_values.push_back(input_generator(index).ValueOrDie());",
          "new_line_content": "  KernelSupportLibrary ksl(&b_, llvm_ir::UnrollMode::kDefaultUnroll);",
          "content_same": false
        },
        {
          "line": 3407,
          "old_api": "size",
          "new_api": null,
          "old_text": "slice_instructions.size()",
          "new_text": null,
          "old_line_content": "  for (int64 i = 0; i < slice_instructions.size(); ++i) {",
          "new_line_content": "    std::vector<llvm::Value*> index_within_ranges;",
          "content_same": false
        },
        {
          "line": 3416,
          "old_api": "slice_starts",
          "new_api": null,
          "old_text": "slice->slice_starts(dim)",
          "new_text": null,
          "old_line_content": "          index.GetConstantWithIndexType(slice->slice_starts(dim)));",
          "new_line_content": "      llvm::Value* within_range =",
          "content_same": false
        },
        {
          "line": 3419,
          "old_api": "slice_limits",
          "new_api": null,
          "old_text": "slice->slice_limits(dim)",
          "new_text": null,
          "old_line_content": "          index.GetConstantWithIndexType(slice->slice_limits(dim)));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3421,
          "old_api": "CreateAnd",
          "new_api": null,
          "old_text": "b_.CreateAnd(larger_or_equal_than_start, smaller_than_limit)",
          "new_text": null,
          "old_line_content": "          b_.CreateAnd(larger_or_equal_than_start, smaller_than_limit);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3422,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "index_within_ranges.push_back(within_range)",
          "new_text": null,
          "old_line_content": "      index_within_ranges.push_back(within_range);",
          "new_line_content": "    auto emit_slice_elem_func = [&] {",
          "content_same": false
        },
        {
          "line": 3429,
          "old_api": "size",
          "new_api": null,
          "old_text": "src_multidim.size()",
          "new_text": null,
          "old_line_content": "      for (size_t dim = 0; dim < src_multidim.size(); ++dim) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3438,
          "old_api": "GetIrArray",
          "new_api": null,
          "old_text": "GetIrArray(*unnested_hlo, *unnested_hlo, shape_index)",
          "new_text": null,
          "old_line_content": "          GetIrArray(*unnested_hlo, *unnested_hlo, shape_index);",
          "new_line_content": "          slice_dst_index, &b_, \"slice.dest\");",
          "content_same": false
        },
        {
          "line": 3440,
          "old_api": "GetType",
          "new_api": null,
          "old_text": "index.GetType()",
          "new_text": null,
          "old_line_content": "                                     index.GetType());",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 3441,
          "old_api": "EmitArrayElementAddress",
          "new_api": null,
          "old_text": "src_ir_array.EmitArrayElementAddress(\n          slice_dst_index, &b_, \"slice.dest\")",
          "new_text": null,
          "old_line_content": "      llvm::Value* dst_addr = src_ir_array.EmitArrayElementAddress(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3443,
          "old_api": "CreateStore",
          "new_api": null,
          "old_text": "b_.CreateStore(input_ir_values[i], dst_addr)",
          "new_text": null,
          "old_line_content": "      b_.CreateStore(input_ir_values[i], dst_addr);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3446,
          "old_api": "StrCat",
          "new_api": null,
          "old_text": "StrCat(\"slice\", i)",
          "new_text": null,
          "old_line_content": "    ksl.If(StrCat(\"slice\", i), guarding_cond, emit_slice_elem_func);",
          "new_line_content": "Status IrEmitterUnnested::EmitInputFusibleNonStridedSlices(",
          "content_same": false
        },
        {
          "line": 3452,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "  constexpr int unroll_factor = 1;",
          "new_line_content": "  TF_ASSIGN_OR_RETURN(Shape element_shape,",
          "content_same": false
        },
        {
          "line": 3453,
          "old_api": "BuildKernelThunk",
          "new_api": null,
          "old_text": "BuildKernelThunk(\n      unnested_hlo, /*implements_whole_instruction=*/true, unroll_factor)",
          "new_text": null,
          "old_line_content": "  std::unique_ptr<KernelThunk> kernel_thunk = BuildKernelThunk(",
          "new_line_content": "                      GetConsistentInputShapeForRootSlices(*unnested_hlo));",
          "content_same": false
        },
        {
          "line": 3458,
          "old_api": "device_description",
          "new_api": null,
          "old_text": "CalculateLaunchDimensions(\n      element_shape, ir_emitter_context_->device_description(), unroll_factor)",
          "new_text": null,
          "old_line_content": "  LaunchDimensions launch_dimensions = CalculateLaunchDimensions(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3459,
          "old_api": "device_description",
          "new_api": null,
          "old_text": "ir_emitter_context_->device_description()",
          "new_text": null,
          "old_line_content": "      element_shape, ir_emitter_context_->device_description(), unroll_factor);",
          "new_line_content": "  Status emit_status =",
          "content_same": false
        },
        {
          "line": 3461,
          "old_api": "llvm_module",
          "new_api": null,
          "old_text": "ir_emitter_context_->llvm_module()",
          "new_text": null,
          "old_line_content": "                         ir_emitter_context_->llvm_module());",
          "new_line_content": "          [&](const llvm_ir::IrArray::Index index) -> Status {",
          "content_same": false
        },
        {
          "line": 3464,
          "old_api": "EmitLoop",
          "new_api": null,
          "old_text": "ParallelLoopEmitter(\n          [&](const llvm_ir::IrArray::Index index) -> Status {\n            EmitElementForInputFusibleSlices(unnested_hlo, index);\n            return Status::OK();\n          },\n          element_shape, launch_dimensions, &b_)\n          .EmitLoop(IrName(unnested_hlo),\n                    GetIndexTypeForKernel(\n                        unnested_hlo, launch_dimensions.launch_bound(), &b_))",
          "new_text": null,
          "old_line_content": "      ParallelLoopEmitter(",
          "new_line_content": "          },",
          "content_same": false
        },
        {
          "line": 3471,
          "old_api": "launch_bound",
          "new_api": null,
          "old_text": "GetIndexTypeForKernel(\n                        unnested_hlo, launch_dimensions.launch_bound(), &b_)",
          "new_text": null,
          "old_line_content": "                    GetIndexTypeForKernel(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3472,
          "old_api": "launch_bound",
          "new_api": null,
          "old_text": "launch_dimensions.launch_bound()",
          "new_text": null,
          "old_line_content": "                        unnested_hlo, launch_dimensions.launch_bound(), &b_));",
          "new_line_content": "  return emit_status;",
          "content_same": false
        },
        {
          "line": 3474,
          "old_api": "std::move(kernel_thunk)",
          "new_api": null,
          "old_text": "std::move(kernel_thunk)",
          "new_text": null,
          "old_line_content": "  thunk_sequence_->emplace_back(std::move(kernel_thunk));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2021,
          "old_api": "constant",
          "new_api": null,
          "old_text": "constant(i)",
          "new_text": null,
          "old_line_content": "                x_loc = b_.CreateAdd(constant(i), x_loc_base, \"x_loc\");",
          "new_line_content": "              auto emit_element = [&] {",
          "content_same": false
        },
        {
          "line": 2023,
          "old_api": "constant",
          "new_api": null,
          "old_text": "constant(i)",
          "new_text": null,
          "old_line_content": "                    source_idx_x_base.AddOffsetToDim(constant(i), kDimX, &b_);",
          "new_line_content": "              };",
          "content_same": false
        },
        {
          "line": 2029,
          "old_api": "CreateICmpULT",
          "new_api": null,
          "old_text": "ksl->If(loop_name + \"_x_in_tile\",\n                        b_.CreateICmpULT(x_loc, tile_width), emit_element)",
          "new_text": null,
          "old_line_content": "                ksl->If(loop_name + \"_x_in_tile\",",
          "new_line_content": "              }",
          "content_same": false
        },
        {
          "line": 2030,
          "old_api": "CreateICmpULT",
          "new_api": null,
          "old_text": "b_.CreateICmpULT(x_loc, tile_width)",
          "new_text": null,
          "old_line_content": "                        b_.CreateICmpULT(x_loc, tile_width), emit_element);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2032,
          "old_api": "emit_element",
          "new_api": null,
          "old_text": "emit_element()",
          "new_text": null,
          "old_line_content": "                emit_element();",
          "new_line_content": "        };",
          "content_same": false
        },
        {
          "line": 2039,
          "old_api": "GetIndexingOrder",
          "new_api": null,
          "old_text": "mapping_scheme.GetIndexingOrder()",
          "new_text": null,
          "old_line_content": "            mapping_scheme.GetIndexingOrder() == kLinearStridedIndexingX) {",
          "new_line_content": "          // For odd row size every other row isn't aligned, so can't be",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 162,
      "total_additions": 310,
      "total_deletions": 310,
      "total_api_changes": 782
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 7,
        "api_related_lines": 782,
        "non_api_lines": 2,
        "non_api_line_numbers": [
          2024,
          2019
        ]
      }
    },
    "api_calls_before": 1722,
    "api_calls_after": 1722,
    "diff_info": {
      "added_lines": 3,
      "removed_lines": 7,
      "total_diff_lines": 22
    }
  }
}