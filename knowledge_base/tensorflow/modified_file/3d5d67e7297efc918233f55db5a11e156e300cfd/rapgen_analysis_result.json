{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/3d5d67e7297efc918233f55db5a11e156e300cfd",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/3d5d67e7297efc918233f55db5a11e156e300cfd/before.h",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/3d5d67e7297efc918233f55db5a11e156e300cfd/after.h",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/3d5d67e7297efc918233f55db5a11e156e300cfd/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": true,
    "api_changes": {
      "replacements": [
        {
          "line": 628,
          "old_api": "temp.flat_outer_dims<float>()",
          "new_api": "tensorflow::Tensor(DT_FLOAT, temp_shape)",
          "old_text": "temp.flat_outer_dims<float>()",
          "new_text": "tensorflow::Tensor(DT_FLOAT, temp_shape)",
          "old_line_content": "    auto temp_flat = temp.flat_outer_dims<float>();",
          "new_line_content": "      temp = tensorflow::Tensor(DT_FLOAT, temp_shape);",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": "errors::InvalidArgument(\n              \"Segment id \", out_index, \" out of range [0, \", output_rows,\n              \"), possibly because 'segment_ids' input is not sorted.\")",
          "new_api": "OP_REQUIRES",
          "old_text": "errors::InvalidArgument(\n              \"Segment id \", out_index, \" out of range [0, \", output_rows,\n              \"), possibly because 'segment_ids' input is not sorted.\")",
          "new_text": "OP_REQUIRES(\n          context, FastBoundsCheck(out_index, output_rows),\n          errors::InvalidArgument(\n              \"Segment id \", out_index, \" out of range [0, \", output_rows,\n              \"), possibly because 'segment_ids' input is not sorted.\"))",
          "old_line_content": "          errors::InvalidArgument(",
          "new_line_content": "      OP_REQUIRES(",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": "Reduce<T, Index>(input_flat, indices_vec, start,\n                                              end - start, out, temp)",
          "new_api": "output_flat.template chip<0>(out_index)",
          "old_text": "Reduce<T, Index>(input_flat, indices_vec, start,\n                                              end - start, out, temp)",
          "new_text": "output_flat.template chip<0>(out_index)",
          "old_line_content": "      const int bad_offset = Reduce<T, Index>(input_flat, indices_vec, start,",
          "new_line_content": "      auto out = output_flat.template chip<0>(out_index);",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": "dimension",
          "new_api": "Reduce<T, Index>(input_flat, indices_vec, start,\n                                              end - start, out, temp)",
          "old_text": "OP_REQUIRES(context, bad_offset < 0,\n                  errors::InvalidArgument(\n                      \"Bad: indices[\", start + bad_offset,\n                      \"] == \", indices_vec(start + bad_offset),\n                      \" out of range [0, \", input_flat.dimension(0), \")\"))",
          "new_text": "Reduce<T, Index>(input_flat, indices_vec, start,\n                                              end - start, out, temp)",
          "old_line_content": "      OP_REQUIRES(context, bad_offset < 0,",
          "new_line_content": "      const int bad_offset = Reduce<T, Index>(input_flat, indices_vec, start,",
          "content_same": false
        },
        {
          "line": 674,
          "old_api": "indices_vec",
          "new_api": "dimension",
          "old_text": "indices_vec(start + bad_offset)",
          "new_text": "errors::InvalidArgument(\n                      \"Bad: indices[\", start + bad_offset,\n                      \"] == \", indices_vec(start + bad_offset),\n                      \" out of range [0, \", input_flat.dimension(0), \")\")",
          "old_line_content": "                      \"] == \", indices_vec(start + bad_offset),",
          "new_line_content": "                  errors::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": "Tout",
          "new_api": "sqrt",
          "old_text": "Tout(1)",
          "new_text": "sqrt(num)",
          "old_line_content": "    return Tout(1) / m;",
          "new_line_content": "      m = Tout(sqrt(num));",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": "temp.template cast<Tin>()",
          "new_api": "ReduceImpl<Tin, Tindex, float>(input_flat, indices_vec, start, num,\n                                       temp, get_scaling_factor<float>(num))",
          "old_text": "temp.template cast<Tin>()",
          "new_text": "ReduceImpl<Tin, Tindex, float>(input_flat, indices_vec, start, num,\n                                       temp, get_scaling_factor<float>(num))",
          "old_line_content": "    out = temp.template cast<Tin>();",
          "new_line_content": "        ReduceImpl<Tin, Tindex, float>(input_flat, indices_vec, start, num,",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": "L",
          "new_api": "INDEX",
          "old_text": "L(1)",
          "new_text": "INDEX(0, 0)",
          "old_line_content": "          out = (L(0) + L(1)) * scaling_factor;",
          "new_line_content": "          INDEX(0, 0);",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": "L",
          "new_api": "INDEX",
          "old_text": "L(2)",
          "new_text": "INDEX(1, 1)",
          "old_line_content": "          out = (L(0) + L(1) + L(2)) * scaling_factor;",
          "new_line_content": "          INDEX(1, 1);",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": "L",
          "new_api": "INDEX",
          "old_text": "L(3)",
          "new_text": "INDEX(2, 2)",
          "old_line_content": "          out = (L(0) + L(1) + L(2) + L(3)) * scaling_factor;",
          "new_line_content": "          INDEX(2, 2);",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": "L",
          "new_api": "INDEX",
          "old_text": "L(4)",
          "new_text": "INDEX(3, 3)",
          "old_line_content": "          out = (L(0) + L(1) + L(2) + L(3) + L(4)) * scaling_factor;",
          "new_line_content": "          INDEX(3, 3);",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": "L",
          "new_api": "INDEX",
          "old_text": "L(5)",
          "new_text": "INDEX(4, 4)",
          "old_line_content": "          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5)) * scaling_factor;",
          "new_line_content": "          INDEX(4, 4);",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": "L",
          "new_api": "INDEX",
          "old_text": "L(6)",
          "new_text": "INDEX(6, 6)",
          "old_line_content": "              (L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6)) * scaling_factor;",
          "new_line_content": "          INDEX(6, 6);",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": "L",
          "new_api": "INDEX",
          "old_text": "L(7)",
          "new_text": "INDEX(6, 6)",
          "old_line_content": "          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6) + L(7)) *",
          "new_line_content": "          INDEX(6, 6);",
          "content_same": false
        },
        {
          "line": 850,
          "old_api": "L",
          "new_api": "INDEX",
          "old_text": "L(8)",
          "new_text": "INDEX(7, 7)",
          "old_line_content": "          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6) + L(7) + L(8)) *",
          "new_line_content": "          INDEX(7, 7);",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": "L",
          "new_api": "INDEX",
          "old_text": "L(7)",
          "new_text": "INDEX(6, r + 6)",
          "old_line_content": "        out += L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6) + L(7);",
          "new_line_content": "        INDEX(6, r + 6);",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": "OP_REQUIRES_OK_ASYNC",
          "new_api": "input",
          "old_text": "OP_REQUIRES_OK_ASYNC(\n        context,\n        internal::ValidateSparseSegmentReduction(\n            context, input, indices, segment_ids, has_num_segments_),\n        done)",
          "new_text": "context->input(2)",
          "old_line_content": "    OP_REQUIRES_OK_ASYNC(",
          "new_line_content": "    const Tensor& segment_ids = context->input(2);",
          "content_same": false
        },
        {
          "line": 910,
          "old_api": "internal::ValidateSparseSegmentReduction(\n            context, input, indices, segment_ids, has_num_segments_)",
          "new_api": "OP_REQUIRES_OK_ASYNC",
          "old_text": "internal::ValidateSparseSegmentReduction(\n            context, input, indices, segment_ids, has_num_segments_)",
          "new_text": "OP_REQUIRES_OK_ASYNC(\n        context,\n        internal::ValidateSparseSegmentReduction(\n            context, input, indices, segment_ids, has_num_segments_),\n        done)",
          "old_line_content": "        internal::ValidateSparseSegmentReduction(",
          "new_line_content": "    OP_REQUIRES_OK_ASYNC(",
          "content_same": false
        },
        {
          "line": 923,
          "old_api": "data",
          "new_api": "parent",
          "old_text": "last_segment_id_host.data()",
          "new_text": "stream->parent()",
          "old_line_content": "      SegmentId last_segment_id = *last_segment_id_host.data();",
          "new_line_content": "      ScopedActivateExecutorContext scoped_activation{stream->parent()};",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": "OP_REQUIRES_ASYNC",
          "new_api": "data",
          "old_text": "OP_REQUIRES_ASYNC(context, output_rows > 0,\n                        errors::InvalidArgument(\"segment ids must be >= 0\"),\n                        done)",
          "new_text": "last_segment_id_host.data()",
          "old_line_content": "      OP_REQUIRES_ASYNC(context, output_rows > 0,",
          "new_line_content": "      SegmentId last_segment_id = *last_segment_id_host.data();",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": "input.flat_outer_dims<T>()",
          "new_api": "allocate_output",
          "old_text": "input.flat_outer_dims<T>()",
          "new_text": "context->allocate_output(0, output_shape, &output)",
          "old_line_content": "      auto input_flat = input.flat_outer_dims<T>();",
          "new_line_content": "          context, context->allocate_output(0, output_shape, &output), done);",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": "segment_ids.vec<SegmentId>()",
          "new_api": "input.flat_outer_dims<T>()",
          "old_text": "segment_ids.vec<SegmentId>()",
          "new_text": "input.flat_outer_dims<T>()",
          "old_line_content": "      const auto segment_ids_vec = segment_ids.vec<SegmentId>();",
          "new_line_content": "      auto input_flat = input.flat_outer_dims<T>();",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": "output->flat_outer_dims<T>()",
          "new_api": "indices.vec<Index>()",
          "old_text": "output->flat_outer_dims<T>()",
          "new_text": "indices.vec<Index>()",
          "old_line_content": "      auto output_flat = output->flat_outer_dims<T>();",
          "new_line_content": "      const auto indices_vec = indices.vec<Index>();",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": "functor",
          "new_api": "OP_REQUIRES_OK_ASYNC",
          "old_text": "functor(context, is_mean_, is_sqrtn_, default_value_, input_flat,\n                  indices_vec, segment_ids_vec, output_flat)",
          "new_text": "OP_REQUIRES_OK_ASYNC(\n          context,\n          functor(context, is_mean_, is_sqrtn_, default_value_, input_flat,\n                  indices_vec, segment_ids_vec, output_flat),\n          done)",
          "old_line_content": "          functor(context, is_mean_, is_sqrtn_, default_value_, input_flat,",
          "new_line_content": "      OP_REQUIRES_OK_ASYNC(",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": "dtype",
          "new_api": "input",
          "old_text": "num_segments_t.dtype()",
          "new_text": "context->input(3)",
          "old_line_content": "          internal::SubtleMustCopy(num_segments_t.dtype() == DT_INT32",
          "new_line_content": "      const Tensor& num_segments_t = context->input(3);",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": "num_segments_t.scalar<int64_t>()()",
          "new_api": "dtype",
          "old_text": "num_segments_t.scalar<int64_t>()()",
          "new_text": "num_segments_t.dtype()",
          "old_line_content": "                                       : num_segments_t.scalar<int64_t>()());",
          "new_line_content": "          internal::SubtleMustCopy(num_segments_t.dtype() == DT_INT32",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": "mutable_data",
          "new_api": "num_segments_t.scalar<int32>()()",
          "old_text": "last_segment_id_host.mutable_data()",
          "new_text": "num_segments_t.scalar<int32>()()",
          "old_line_content": "      *last_segment_id_host.mutable_data() = num_segments - 1;",
          "new_line_content": "                                       ? num_segments_t.scalar<int32>()()",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": "create_and_check_output",
          "new_api": "num_segments_t.scalar<int64_t>()()",
          "old_text": "create_and_check_output()",
          "new_text": "num_segments_t.scalar<int64_t>()()",
          "old_line_content": "      create_and_check_output();",
          "new_line_content": "                                       : num_segments_t.scalar<int64_t>()());",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": "NumElements",
          "new_api": "create_and_check_output",
          "old_text": "indices.NumElements()",
          "new_text": "create_and_check_output()",
          "old_line_content": "      const int64_t num_indices = indices.NumElements();",
          "new_line_content": "      create_and_check_output();",
          "content_same": false
        },
        {
          "line": 962,
          "old_api": "shape",
          "new_api": "NumElements",
          "old_text": "input.shape()",
          "new_text": "indices.NumElements()",
          "old_line_content": "        TensorShape output_shape = input.shape();",
          "new_line_content": "      const int64_t num_indices = indices.NumElements();",
          "content_same": false
        },
        {
          "line": 968,
          "old_api": "done",
          "new_api": "allocate_output",
          "old_text": "done()",
          "new_text": "OP_REQUIRES_OK_ASYNC(\n            context, context->allocate_output(0, output_shape, &output), done)",
          "old_line_content": "        done();",
          "new_line_content": "        OP_REQUIRES_OK_ASYNC(",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": "op_device_context",
          "new_api": "data",
          "old_text": "context->op_device_context()->stream()",
          "new_text": "const_cast<Tensor&>(segment_ids).template flat<SegmentId>().data()",
          "old_line_content": "      auto stream = context->op_device_context()->stream();",
          "new_line_content": "          const_cast<Tensor&>(segment_ids).template flat<SegmentId>().data() +",
          "content_same": false
        },
        {
          "line": 1073,
          "old_api": "dimension",
          "new_api": "output->flat_outer_dims<T>()",
          "old_text": "output_flat.dimension(0)",
          "new_text": "output->flat_outer_dims<T>()",
          "old_line_content": "    const SegmentId M = output_flat.dimension(0);",
          "new_line_content": "    auto output_flat = output->flat_outer_dims<T>();",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": "segment_vec",
          "new_api": "dimension",
          "old_text": "segment_vec(N - 1)",
          "new_text": "input_flat.dimension(0)",
          "old_line_content": "        internal::SubtleMustCopy(segment_vec(N - 1)) + 1;",
          "new_line_content": "    const SegmentId num_segments = input_flat.dimension(0);",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": "absl::InvalidArgumentError(\"Invalid number of segments\")",
          "new_api": "segment_vec",
          "old_text": "absl::InvalidArgumentError(\"Invalid number of segments\")",
          "new_text": "segment_vec(N - 1)",
          "old_line_content": "                absl::InvalidArgumentError(\"Invalid number of segments\"));",
          "new_line_content": "        internal::SubtleMustCopy(segment_vec(N - 1)) + 1;",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": "value",
          "new_api": "ComputeScalingFactors",
          "old_text": "scaling_or.value()",
          "new_text": "ComputeScalingFactors(operation, segment_vec, num_segments)",
          "old_line_content": "    const std::vector<double>& scaling = scaling_or.value();",
          "new_line_content": "        ComputeScalingFactors(operation, segment_vec, num_segments);",
          "content_same": false
        },
        {
          "line": 1095,
          "old_api": "temp.flat_outer_dims<float>()",
          "new_api": "shape",
          "old_text": "temp.flat_outer_dims<float>()",
          "new_text": "output->shape()",
          "old_line_content": "    auto temp_flat = temp.flat_outer_dims<float>();",
          "new_line_content": "      temp = tensorflow::Tensor(DT_FLOAT, output->shape());",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": "dtype",
          "new_api": "temp.flat_outer_dims<float>()",
          "old_text": "output->dtype()",
          "new_text": "temp.flat_outer_dims<float>()",
          "old_line_content": "    if (output->dtype() == DT_BFLOAT16 || output->dtype() == DT_HALF) {",
          "new_line_content": "    auto temp_flat = temp.flat_outer_dims<float>();",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": "absl::StrCat(\n                      \"Index \", output_idx, \" out of range [0, \", M, \").\")",
          "new_api": "indices_vec",
          "old_text": "absl::StrCat(\n                      \"Index \", output_idx, \" out of range [0, \", M, \").\")",
          "new_text": "indices_vec(i)",
          "old_line_content": "                  absl::InvalidArgumentError(absl::StrCat(",
          "new_line_content": "      const Index output_idx = internal::SubtleMustCopy(indices_vec(i));",
          "content_same": false
        },
        {
          "line": 1111,
          "old_api": "FastBoundsCheck",
          "new_api": "segment_vec",
          "old_text": "FastBoundsCheck(idx, num_segments)",
          "new_text": "segment_vec(i)",
          "old_line_content": "          context, FastBoundsCheck(idx, num_segments),",
          "new_line_content": "      const SegmentId idx = internal::SubtleMustCopy(segment_vec(i));",
          "content_same": false
        },
        {
          "line": 1112,
          "old_api": "absl::StrCat(\n              \"Segment id \", idx, \" out of range [0, \", num_segments, \").\")",
          "new_api": "OP_REQUIRES",
          "old_text": "absl::StrCat(\n              \"Segment id \", idx, \" out of range [0, \", num_segments, \").\")",
          "new_text": "OP_REQUIRES(\n          context, FastBoundsCheck(idx, num_segments),\n          absl::InvalidArgumentError(absl::StrCat(\n              \"Segment id \", idx, \" out of range [0, \", num_segments, \").\")))",
          "old_line_content": "          absl::InvalidArgumentError(absl::StrCat(",
          "new_line_content": "      OP_REQUIRES(",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": "temp_flat.template chip<0>(output_idx)",
          "new_api": "input_flat.template chip<0>(idx)",
          "old_text": "temp_flat.template chip<0>(output_idx)",
          "new_text": "input_flat.template chip<0>(idx)",
          "old_line_content": "                    temp_flat.template chip<0>(output_idx));",
          "new_line_content": "      Accumulate<T>(input_flat.template chip<0>(idx), scale,",
          "content_same": false
        },
        {
          "line": 1172,
          "old_api": "FastBoundsCheck",
          "new_api": "size",
          "old_text": "FastBoundsCheck(idx, num_segments)",
          "new_text": "segment_vec.size()",
          "old_line_content": "      if (!FastBoundsCheck(idx, num_segments)) {",
          "new_line_content": "    for (int64_t i = 0; i < segment_vec.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": "absl::StrCat(\n            \"Segment id \", idx, \" out of range [0, \", num_segments, \").\")",
          "new_api": "segment_vec",
          "old_text": "absl::StrCat(\n            \"Segment id \", idx, \" out of range [0, \", num_segments, \").\")",
          "new_text": "segment_vec(i)",
          "old_line_content": "        return absl::InvalidArgumentError(absl::StrCat(",
          "new_line_content": "      const SegmentId idx = internal::SubtleMustCopy(segment_vec(i));",
          "content_same": false
        },
        {
          "line": 1204,
          "old_api": "dimension",
          "new_api": "size",
          "old_text": "input_flat.dimension(0)",
          "new_text": "indices_vec.size()",
          "old_line_content": "    const SegmentId num_segments = input_flat.dimension(0);",
          "new_line_content": "    const int64_t N = indices_vec.size();",
          "content_same": false
        },
        {
          "line": 1206,
          "old_api": "segment_vec",
          "new_api": "dimension",
          "old_text": "segment_vec(N - 1)",
          "new_text": "input_flat.dimension(0)",
          "old_line_content": "        internal::SubtleMustCopy(segment_vec(N - 1)) + 1;",
          "new_line_content": "    const SegmentId num_segments = input_flat.dimension(0);",
          "content_same": false
        },
        {
          "line": 1212,
          "old_api": "indices_vec",
          "new_api": "errors::InvalidArgument(\"Invalid number of segments\")",
          "old_text": "indices_vec(i)",
          "new_text": "errors::InvalidArgument(\"Invalid number of segments\")",
          "old_line_content": "      const Index output_idx = internal::SubtleMustCopy(indices_vec(i));",
          "new_line_content": "                errors::InvalidArgument(\"Invalid number of segments\"));",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": "errors::InvalidArgument(\"Index \", output_idx,\n                                          \" out of range [0, \", M, \").\")",
          "new_api": "indices_vec",
          "old_text": "errors::InvalidArgument(\"Index \", output_idx,\n                                          \" out of range [0, \", M, \").\")",
          "new_text": "indices_vec(i)",
          "old_line_content": "                  errors::InvalidArgument(\"Index \", output_idx,",
          "new_line_content": "      const Index output_idx = internal::SubtleMustCopy(indices_vec(i));",
          "content_same": false
        },
        {
          "line": 1216,
          "old_api": "segment_vec",
          "new_api": "errors::InvalidArgument(\"Index \", output_idx,\n                                          \" out of range [0, \", M, \").\")",
          "old_text": "segment_vec(i)",
          "new_text": "errors::InvalidArgument(\"Index \", output_idx,\n                                          \" out of range [0, \", M, \").\")",
          "old_line_content": "      const SegmentId segment_id = internal::SubtleMustCopy(segment_vec(i));",
          "new_line_content": "                  errors::InvalidArgument(\"Index \", output_idx,",
          "content_same": false
        },
        {
          "line": 1218,
          "old_api": "FastBoundsCheck",
          "new_api": "segment_vec",
          "old_text": "FastBoundsCheck(segment_id, num_segments)",
          "new_text": "segment_vec(i)",
          "old_line_content": "          context, FastBoundsCheck(segment_id, num_segments),",
          "new_line_content": "      const SegmentId segment_id = internal::SubtleMustCopy(segment_vec(i));",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": "errors::InvalidArgument(\"Segment id \", segment_id,\n                                  \" out of range [0, \", num_segments, \").\")",
          "new_api": "OP_REQUIRES",
          "old_text": "errors::InvalidArgument(\"Segment id \", segment_id,\n                                  \" out of range [0, \", num_segments, \").\")",
          "new_text": "OP_REQUIRES(\n          context, FastBoundsCheck(segment_id, num_segments),\n          errors::InvalidArgument(\"Segment id \", segment_id,\n                                  \" out of range [0, \", num_segments, \").\"))",
          "old_line_content": "          errors::InvalidArgument(\"Segment id \", segment_id,",
          "new_line_content": "      OP_REQUIRES(",
          "content_same": false
        },
        {
          "line": 1226,
          "old_api": "push_back",
          "new_api": "reserve",
          "old_text": "permutation.push_back(i)",
          "new_text": "permutation.reserve(N)",
          "old_line_content": "      permutation.push_back(i);",
          "new_line_content": "    permutation.reserve(N);",
          "content_same": false
        },
        {
          "line": 1228,
          "old_api": "begin",
          "new_api": "push_back",
          "old_text": "std::stable_sort(\n        permutation.begin(), permutation.end(),\n        [&](Index a, Index b) { return indices_vec(a) < indices_vec(b); })",
          "new_text": "permutation.push_back(i)",
          "old_line_content": "    std::stable_sort(",
          "new_line_content": "      permutation.push_back(i);",
          "content_same": false
        },
        {
          "line": 1230,
          "old_api": "indices_vec",
          "new_api": "begin",
          "old_text": "indices_vec(b)",
          "new_text": "std::stable_sort(\n        permutation.begin(), permutation.end(),\n        [&](Index a, Index b) { return indices_vec(a) < indices_vec(b); })",
          "old_line_content": "        [&](Index a, Index b) { return indices_vec(a) < indices_vec(b); });",
          "new_line_content": "    std::stable_sort(",
          "content_same": false
        },
        {
          "line": 1236,
          "old_api": "indices_vec",
          "new_api": "reserve",
          "old_text": "indices_vec(j)",
          "new_text": "permuted_segments.reserve(N)",
          "old_line_content": "      sorted_indices.push_back(indices_vec(j));",
          "new_line_content": "    permuted_segments.reserve(N);",
          "content_same": false
        },
        {
          "line": 1252,
          "old_api": "size",
          "new_api": "push_back",
          "old_text": "unique_indices_map.size()",
          "new_text": "unique_index_ids.push_back(unique_id)",
          "old_line_content": "    const int64_t num_unique = unique_indices_map.size();",
          "new_line_content": "      unique_index_ids.push_back(unique_id);",
          "content_same": false
        },
        {
          "line": 1259,
          "old_api": "unique_indices->vec<Index>()",
          "new_api": "allocate_output",
          "old_text": "unique_indices->vec<Index>()",
          "new_text": "context->allocate_output(1, {num_unique}, &unique_indices)",
          "old_line_content": "        unique_indices->vec<Index>();",
          "new_line_content": "                   context->allocate_output(1, {num_unique}, &unique_indices));",
          "content_same": false
        },
        {
          "line": 1261,
          "old_api": "unique_indices_vec",
          "new_api": "unique_indices->vec<Index>()",
          "old_text": "unique_indices_vec(idx_and_id.second)",
          "new_text": "unique_indices->vec<Index>()",
          "old_line_content": "      unique_indices_vec(idx_and_id.second) = idx_and_id.first;",
          "new_line_content": "        unique_indices->vec<Index>();",
          "content_same": false
        },
        {
          "line": 1267,
          "old_api": "allocate_output",
          "new_api": "SetDimWithStatus",
          "old_text": "context->allocate_output(0, output_shape, &output)",
          "new_text": "output_shape.SetDimWithStatus(0, num_unique)",
          "old_line_content": "    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));",
          "new_line_content": "    OP_REQUIRES_OK(context, output_shape.SetDimWithStatus(0, num_unique));",
          "content_same": false
        },
        {
          "line": 1303,
          "old_api": "shape",
          "new_api": "input",
          "old_text": "indices.shape()",
          "new_text": "context->input(3)",
          "old_line_content": "    OP_REQUIRES(context, TensorShapeUtils::IsVector(indices.shape()),",
          "new_line_content": "    const Tensor& output_dim0 = context->input(3);",
          "content_same": false
        },
        {
          "line": 1306,
          "old_api": "errors::InvalidArgument(\"segment_ids should be a vector.\")",
          "new_api": "errors::InvalidArgument(\"indices should be a vector.\")",
          "old_text": "errors::InvalidArgument(\"segment_ids should be a vector.\")",
          "new_text": "errors::InvalidArgument(\"indices should be a vector.\")",
          "old_line_content": "                errors::InvalidArgument(\"segment_ids should be a vector.\"));",
          "new_line_content": "                errors::InvalidArgument(\"indices should be a vector.\"));",
          "content_same": false
        },
        {
          "line": 1308,
          "old_api": "errors::InvalidArgument(\"output_dim0 should be a scalar.\")",
          "new_api": "errors::InvalidArgument(\"segment_ids should be a vector.\")",
          "old_text": "errors::InvalidArgument(\"output_dim0 should be a scalar.\")",
          "new_text": "errors::InvalidArgument(\"segment_ids should be a vector.\")",
          "old_line_content": "                errors::InvalidArgument(\"output_dim0 should be a scalar.\"));",
          "new_line_content": "                errors::InvalidArgument(\"segment_ids should be a vector.\"));",
          "content_same": false
        },
        {
          "line": 1310,
          "old_api": "NumElements",
          "new_api": "errors::InvalidArgument(\"output_dim0 should be a scalar.\")",
          "old_text": "indices.NumElements()",
          "new_text": "errors::InvalidArgument(\"output_dim0 should be a scalar.\")",
          "old_line_content": "    const int64_t N = indices.NumElements();",
          "new_line_content": "                errors::InvalidArgument(\"output_dim0 should be a scalar.\"));",
          "content_same": false
        },
        {
          "line": 1312,
          "old_api": "errors::InvalidArgument(\n                    \"segment_ids and indices should have same size.\")",
          "new_api": "NumElements",
          "old_text": "errors::InvalidArgument(\n                    \"segment_ids and indices should have same size.\")",
          "new_text": "indices.NumElements()",
          "old_line_content": "                errors::InvalidArgument(",
          "new_line_content": "    const int64_t N = indices.NumElements();",
          "content_same": false
        },
        {
          "line": 1314,
          "old_api": "output_dim0.scalar<int32>()()",
          "new_api": "errors::InvalidArgument(\n                    \"segment_ids and indices should have same size.\")",
          "old_text": "output_dim0.scalar<int32>()()",
          "new_text": "errors::InvalidArgument(\n                    \"segment_ids and indices should have same size.\")",
          "old_line_content": "    const SegmentId M = internal::SubtleMustCopy(output_dim0.scalar<int32>()());",
          "new_line_content": "                errors::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 1316,
          "old_api": "input.flat_outer_dims<T>()",
          "new_api": "output_dim0.scalar<int32>()()",
          "old_text": "input.flat_outer_dims<T>()",
          "new_text": "output_dim0.scalar<int32>()()",
          "old_line_content": "    auto input_flat = input.flat_outer_dims<T>();",
          "new_line_content": "    const SegmentId M = internal::SubtleMustCopy(output_dim0.scalar<int32>()());",
          "content_same": false
        },
        {
          "line": 1318,
          "old_api": "segment_ids.vec<SegmentId>()",
          "new_api": "input.flat_outer_dims<T>()",
          "old_text": "segment_ids.vec<SegmentId>()",
          "new_text": "input.flat_outer_dims<T>()",
          "old_line_content": "    const auto segment_vec = segment_ids.vec<SegmentId>();",
          "new_line_content": "    auto input_flat = input.flat_outer_dims<T>();",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": "shape",
          "new_api": "segment_ids.vec<SegmentId>()",
          "old_text": "input.shape()",
          "new_text": "segment_ids.vec<SegmentId>()",
          "old_line_content": "    TensorShape output_shape = input.shape();",
          "new_line_content": "    const auto segment_vec = segment_ids.vec<SegmentId>();",
          "content_same": false
        },
        {
          "line": 1323,
          "old_api": "allocate_output",
          "new_api": "SetDimWithStatus",
          "old_text": "context->allocate_output(0, output_shape, &output)",
          "new_text": "output_shape.SetDimWithStatus(0, M)",
          "old_line_content": "    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));",
          "new_line_content": "    OP_REQUIRES_OK(context, output_shape.SetDimWithStatus(0, M));",
          "content_same": false
        },
        {
          "line": 1372,
          "old_api": "shape",
          "new_api": "input",
          "old_text": "indices.shape()",
          "new_text": "context->input(3)",
          "old_line_content": "    if (!TensorShapeUtils::IsVector(indices.shape())) {",
          "new_line_content": "    const Tensor& dense_output_dim0 = context->input(3);",
          "content_same": false
        },
        {
          "line": 1375,
          "old_api": "shape",
          "new_api": "errors::InvalidArgument(\"indices should be a vector.\")",
          "old_text": "segment_ids.shape()",
          "new_text": "errors::InvalidArgument(\"indices should be a vector.\")",
          "old_line_content": "    if (!TensorShapeUtils::IsVector(segment_ids.shape())) {",
          "new_line_content": "      return errors::InvalidArgument(\"indices should be a vector.\");",
          "content_same": false
        },
        {
          "line": 1378,
          "old_api": "shape",
          "new_api": "errors::InvalidArgument(\"segment_ids should be a vector.\")",
          "old_text": "dense_output_dim0.shape()",
          "new_text": "errors::InvalidArgument(\"segment_ids should be a vector.\")",
          "old_line_content": "    if (!TensorShapeUtils::IsScalar(dense_output_dim0.shape())) {",
          "new_line_content": "      return errors::InvalidArgument(\"segment_ids should be a vector.\");",
          "content_same": false
        },
        {
          "line": 1384,
          "old_api": "errors::InvalidArgument(\n          \"segment_ids and indices should have same size.\")",
          "new_api": "NumElements",
          "old_text": "errors::InvalidArgument(\n          \"segment_ids and indices should have same size.\")",
          "new_text": "indices.NumElements()",
          "old_line_content": "      return errors::InvalidArgument(",
          "new_line_content": "    const int64_t N = indices.NumElements();",
          "content_same": false
        },
        {
          "line": 1390,
          "old_api": "SetDimWithStatus",
          "new_api": "dense_output_dim0.scalar<int32_t>()()",
          "old_text": "dense_output_shape.SetDimWithStatus(0, M)",
          "new_text": "dense_output_dim0.scalar<int32_t>()()",
          "old_line_content": "    TF_RETURN_IF_ERROR(dense_output_shape.SetDimWithStatus(0, M));",
          "new_line_content": "        internal::SubtleMustCopy(dense_output_dim0.scalar<int32_t>()());",
          "content_same": false
        },
        {
          "line": 1396,
          "old_api": "allocate_output",
          "new_api": "SetDimWithStatus",
          "old_text": "context->allocate_output(0, output_shape, &output)",
          "new_text": "output_shape.SetDimWithStatus(0, 0)",
          "old_line_content": "      TF_RETURN_IF_ERROR(context->allocate_output(0, output_shape, &output));",
          "new_line_content": "      TF_RETURN_IF_ERROR(output_shape.SetDimWithStatus(0, 0));",
          "content_same": false
        },
        {
          "line": 1398,
          "old_api": "TensorShape",
          "new_api": "allocate_output",
          "old_text": "TensorShape({0})",
          "new_text": "context->allocate_output(0, output_shape, &output)",
          "old_line_content": "      TF_RETURN_IF_ERROR(context->allocate_output(1, TensorShape({0}),",
          "new_line_content": "      TF_RETURN_IF_ERROR(context->allocate_output(0, output_shape, &output));",
          "content_same": false
        },
        {
          "line": 1400,
          "old_api": "absl::OkStatus()",
          "new_api": "TensorShape",
          "old_text": "absl::OkStatus()",
          "new_text": "TensorShape({0})",
          "old_line_content": "      return absl::OkStatus();",
          "new_line_content": "      TF_RETURN_IF_ERROR(context->allocate_output(1, TensorShape({0}),",
          "content_same": false
        },
        {
          "line": 1405,
          "old_api": "segment_ids.vec<SegmentId>()",
          "new_api": "input.flat_outer_dims<T>()",
          "old_text": "segment_ids.vec<SegmentId>()",
          "new_text": "input.flat_outer_dims<T>()",
          "old_line_content": "    const auto segment_vec = segment_ids.vec<SegmentId>();",
          "new_line_content": "    auto input_flat = input.flat_outer_dims<T>();",
          "content_same": false
        },
        {
          "line": 1407,
          "old_api": "functor::SparseSegmentGradV2Functor<Device, T, Index, SegmentId>()(\n        context, operation, input_flat, indices_vec, segment_vec,\n        dense_output_shape, done)",
          "new_api": "segment_ids.vec<SegmentId>()",
          "old_text": "functor::SparseSegmentGradV2Functor<Device, T, Index, SegmentId>()(\n        context, operation, input_flat, indices_vec, segment_vec,\n        dense_output_shape, done)",
          "new_text": "segment_ids.vec<SegmentId>()",
          "old_line_content": "    functor::SparseSegmentGradV2Functor<Device, T, Index, SegmentId>()(",
          "new_line_content": "    const auto segment_vec = segment_ids.vec<SegmentId>();",
          "content_same": false
        },
        {
          "line": 1449,
          "old_api": "SparseSegmentGradV2OpCommon<GPUDevice, T, Index, SegmentId>()(\n            context, operation_, done)",
          "new_api": "OP_REQUIRES_OK_ASYNC",
          "old_text": "SparseSegmentGradV2OpCommon<GPUDevice, T, Index, SegmentId>()(\n            context, operation_, done)",
          "new_text": "OP_REQUIRES_OK_ASYNC(\n        context,\n        (SparseSegmentGradV2OpCommon<GPUDevice, T, Index, SegmentId>()(\n            context, operation_, done)),\n        done)",
          "old_line_content": "        (SparseSegmentGradV2OpCommon<GPUDevice, T, Index, SegmentId>()(",
          "new_line_content": "    OP_REQUIRES_OK_ASYNC(",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1025,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "            context, false /*is_mean*/, true /*is_sqrtn*/,",
          "new_line_content": "  explicit SparseSegmentReductionSqrtNOp(OpKernelConstruction* context)",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": null,
          "new_api": "T",
          "old_text": null,
          "new_text": "T(0)",
          "old_line_content": "",
          "new_line_content": "            false /* has_num_segments */, T(0) /* default_value */) {}",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(",
          "new_line_content": "  explicit SparseSegmentReductionSqrtNWithNumSegmentsOp(",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": null,
          "new_api": "T",
          "old_text": null,
          "new_text": "T(0)",
          "old_line_content": "",
          "new_line_content": "            true /* has_num_segments */, T(0) /* default_value */) {}",
          "content_same": false
        },
        {
          "line": 1046,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "            context, false /*is_mean*/, false /*is_sqrtn*/,",
          "new_line_content": "  explicit SparseSegmentReductionSumOp(OpKernelConstruction* context)",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": null,
          "new_api": "T",
          "old_text": null,
          "new_text": "T(0)",
          "old_line_content": "",
          "new_line_content": "            false /* has_num_segments */, T(0) /* default_value */) {}",
          "content_same": false
        },
        {
          "line": 1056,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(",
          "new_line_content": "  explicit SparseSegmentReductionSumWithNumSegmentsOp(",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": null,
          "new_api": "T",
          "old_text": null,
          "new_text": "T(0)",
          "old_line_content": "",
          "new_line_content": "            true /* has_num_segments */, T(0) /* default_value */) {}",
          "content_same": false
        },
        {
          "line": 1074,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "indices_vec.size()",
          "old_line_content": "",
          "new_line_content": "    const int64_t N = indices_vec.size();",
          "content_same": false
        },
        {
          "line": 1075,
          "old_api": null,
          "new_api": "dimension",
          "old_text": null,
          "new_text": "output_flat.dimension(0)",
          "old_line_content": "    // Note that similar to SparseSegmentMean, we assume that segment_vec is",
          "new_line_content": "    const SegmentId M = output_flat.dimension(0);",
          "content_same": false
        },
        {
          "line": 1082,
          "old_api": null,
          "new_api": "OP_REQUIRES",
          "old_text": null,
          "new_text": "OP_REQUIRES(context, last_segment_id_plus_one <= num_segments,\n                absl::InvalidArgumentError(\"Invalid number of segments\"))",
          "old_line_content": "",
          "new_line_content": "    OP_REQUIRES(context, last_segment_id_plus_one <= num_segments,",
          "content_same": false
        },
        {
          "line": 1083,
          "old_api": null,
          "new_api": "absl::InvalidArgumentError(\"Invalid number of segments\")",
          "old_text": null,
          "new_text": "absl::InvalidArgumentError(\"Invalid number of segments\")",
          "old_line_content": "    const auto scaling_or =",
          "new_line_content": "                absl::InvalidArgumentError(\"Invalid number of segments\"));",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": null,
          "new_api": "status",
          "old_text": null,
          "new_text": "scaling_or.status()",
          "old_line_content": "",
          "new_line_content": "    OP_REQUIRES_OK(context, scaling_or.status());",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "scaling_or.value()",
          "old_line_content": "    // If we use DT_BFLOAT16 or DT_HALF, we need to use DT_FLOAT for",
          "new_line_content": "    const std::vector<double>& scaling = scaling_or.value();",
          "content_same": false
        },
        {
          "line": 1094,
          "old_api": null,
          "new_api": "dtype",
          "old_text": null,
          "new_text": "output->dtype()",
          "old_line_content": "    }",
          "new_line_content": "    if (output->dtype() == DT_BFLOAT16 || output->dtype() == DT_HALF) {",
          "content_same": false
        },
        {
          "line": 1099,
          "old_api": null,
          "new_api": "dtype",
          "old_text": null,
          "new_text": "output->dtype()",
          "old_line_content": "    } else {",
          "new_line_content": "    if (output->dtype() == DT_BFLOAT16 || output->dtype() == DT_HALF) {",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": null,
          "new_api": "setZero",
          "old_text": null,
          "new_text": "output_flat.setZero()",
          "old_line_content": "",
          "new_line_content": "      output_flat.setZero();",
          "content_same": false
        },
        {
          "line": 1107,
          "old_api": null,
          "new_api": "FastBoundsCheck",
          "old_text": null,
          "new_text": "FastBoundsCheck(output_idx, M)",
          "old_line_content": "                      \"Index \", output_idx, \" out of range [0, \", M, \").\")));",
          "new_line_content": "      OP_REQUIRES(context, FastBoundsCheck(output_idx, M),",
          "content_same": false
        },
        {
          "line": 1108,
          "old_api": null,
          "new_api": "absl::StrCat(\n                      \"Index \", output_idx, \" out of range [0, \", M, \").\")",
          "old_text": null,
          "new_text": "absl::StrCat(\n                      \"Index \", output_idx, \" out of range [0, \", M, \").\")",
          "old_line_content": "",
          "new_line_content": "                  absl::InvalidArgumentError(absl::StrCat(",
          "content_same": false
        },
        {
          "line": 1113,
          "old_api": null,
          "new_api": "FastBoundsCheck",
          "old_text": null,
          "new_text": "FastBoundsCheck(idx, num_segments)",
          "old_line_content": "              \"Segment id \", idx, \" out of range [0, \", num_segments, \").\")));",
          "new_line_content": "          context, FastBoundsCheck(idx, num_segments),",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": null,
          "new_api": "absl::StrCat(\n              \"Segment id \", idx, \" out of range [0, \", num_segments, \").\")",
          "old_text": null,
          "new_text": "absl::StrCat(\n              \"Segment id \", idx, \" out of range [0, \", num_segments, \").\")",
          "old_line_content": "",
          "new_line_content": "          absl::InvalidArgumentError(absl::StrCat(",
          "content_same": false
        },
        {
          "line": 1121,
          "old_api": null,
          "new_api": "output_flat.template chip<0>(output_idx)",
          "old_text": null,
          "new_text": "output_flat.template chip<0>(output_idx)",
          "old_line_content": "    }",
          "new_line_content": "                    output_flat.template chip<0>(output_idx),",
          "content_same": false
        },
        {
          "line": 1122,
          "old_api": null,
          "new_api": "temp_flat.template chip<0>(output_idx)",
          "old_text": null,
          "new_text": "temp_flat.template chip<0>(output_idx)",
          "old_line_content": "",
          "new_line_content": "                    temp_flat.template chip<0>(output_idx));",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": null,
          "new_api": "dtype",
          "old_text": null,
          "new_text": "output->dtype()",
          "old_line_content": "    }",
          "new_line_content": "    if (output->dtype() == DT_BFLOAT16 || output->dtype() == DT_HALF) {",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": null,
          "new_api": "temp_flat.template cast<T>()",
          "old_text": null,
          "new_text": "temp_flat.template cast<T>()",
          "old_line_content": "  }",
          "new_line_content": "      output_flat = temp_flat.template cast<T>();",
          "content_same": false
        },
        {
          "line": 627,
          "old_api": null,
          "new_api": "SetDimWithStatus",
          "old_text": null,
          "new_text": "temp_shape.SetDimWithStatus(/*d=*/0, /*size=*/1)",
          "old_line_content": "    }",
          "new_line_content": "      OP_REQUIRES_OK(context, temp_shape.SetDimWithStatus(/*d=*/0, /*size=*/1));",
          "content_same": false
        },
        {
          "line": 630,
          "old_api": null,
          "new_api": "temp.flat_outer_dims<float>()",
          "old_text": null,
          "new_text": "temp.flat_outer_dims<float>()",
          "old_line_content": "    int64_t start = 0, end = 1;",
          "new_line_content": "    auto temp_flat = temp.flat_outer_dims<float>();",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": null,
          "new_api": "segment_vec",
          "old_text": null,
          "new_text": "segment_vec(start)",
          "old_line_content": "    while (true) {",
          "new_line_content": "    SegmentId out_index = internal::SubtleMustCopy(segment_vec(start));",
          "content_same": false
        },
        {
          "line": 1149,
          "old_api": null,
          "new_api": "static_cast<Tin>(scale)",
          "old_text": null,
          "new_text": "static_cast<Tin>(scale)",
          "old_line_content": "",
          "new_line_content": "    out += in * static_cast<Tin>(scale);",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": null,
          "new_api": "segment_vec",
          "old_text": null,
          "new_text": "segment_vec(end)",
          "old_line_content": "          ++end;",
          "new_line_content": "        next_index = internal::SubtleMustCopy(segment_vec(end));",
          "content_same": false
        },
        {
          "line": 1158,
          "old_api": null,
          "new_api": "static_cast<float>(scale)",
          "old_text": null,
          "new_text": "static_cast<float>(scale)",
          "old_line_content": "",
          "new_line_content": "    temp += in.template cast<float>() * static_cast<float>(scale);",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": null,
          "new_api": "OP_REQUIRES",
          "old_text": null,
          "new_text": "OP_REQUIRES(context, out_index < next_index,\n                    errors::InvalidArgument(\"segment ids are not increasing\"))",
          "old_line_content": "      }",
          "new_line_content": "        OP_REQUIRES(context, out_index < next_index,",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": null,
          "new_api": "errors::InvalidArgument(\"segment ids are not increasing\")",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\"segment ids are not increasing\")",
          "old_line_content": "",
          "new_line_content": "                    errors::InvalidArgument(\"segment ids are not increasing\"));",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": null,
          "new_api": "FastBoundsCheck",
          "old_text": null,
          "new_text": "FastBoundsCheck(out_index, output_rows)",
          "old_line_content": "              \"Segment id \", out_index, \" out of range [0, \", output_rows,",
          "new_line_content": "          context, FastBoundsCheck(out_index, output_rows),",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": null,
          "new_api": "errors::InvalidArgument(\n              \"Segment id \", out_index, \" out of range [0, \", output_rows,\n              \"), possibly because 'segment_ids' input is not sorted.\")",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\n              \"Segment id \", out_index, \" out of range [0, \", output_rows,\n              \"), possibly because 'segment_ids' input is not sorted.\")",
          "old_line_content": "              \"), possibly because 'segment_ids' input is not sorted.\"));",
          "new_line_content": "          errors::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": null,
          "new_api": "std::vector<double>(0)",
          "old_text": null,
          "new_text": "std::vector<double>(0)",
          "old_line_content": "",
          "new_line_content": "      return std::vector<double>(0);",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": null,
          "new_api": "FastBoundsCheck",
          "old_text": null,
          "new_text": "FastBoundsCheck(idx, num_segments)",
          "old_line_content": "            \"Segment id \", idx, \" out of range [0, \", num_segments, \").\"));",
          "new_line_content": "      if (!FastBoundsCheck(idx, num_segments)) {",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": null,
          "new_api": "absl::StrCat(\n            \"Segment id \", idx, \" out of range [0, \", num_segments, \").\")",
          "old_text": null,
          "new_text": "absl::StrCat(\n            \"Segment id \", idx, \" out of range [0, \", num_segments, \").\")",
          "old_line_content": "      }",
          "new_line_content": "        return absl::InvalidArgumentError(absl::StrCat(",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": null,
          "new_api": "output_flat",
          "old_text": null,
          "new_text": "output_flat(uninitialized_index, 0)",
          "old_line_content": "      }",
          "new_line_content": "            gap_slice(&output_flat(uninitialized_index, 0), gap_slice_shape);",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": null,
          "new_api": "setConstant",
          "old_text": null,
          "new_text": "gap_slice.setConstant(default_value_)",
          "old_line_content": "",
          "new_line_content": "        gap_slice.setConstant(default_value_);",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": null,
          "new_api": "temp_flat.template chip<0>(0)",
          "old_text": null,
          "new_text": "temp_flat.template chip<0>(0)",
          "old_line_content": "                                              end - start, out, temp);",
          "new_line_content": "      auto temp = temp_flat.template chip<0>(0);",
          "content_same": false
        },
        {
          "line": 1182,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "scaling.size()",
          "old_line_content": "      }",
          "new_line_content": "      for (size_t i = 0; i < scaling.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 1183,
          "old_api": null,
          "new_api": "std::max(scaling[i], 1.0)",
          "old_text": null,
          "new_text": "std::max(scaling[i], 1.0)",
          "old_line_content": "    } else {",
          "new_line_content": "        scaling[i] = 1.0 / std::max(scaling[i], 1.0);",
          "content_same": false
        },
        {
          "line": 673,
          "old_api": null,
          "new_api": "dimension",
          "old_text": null,
          "new_text": "OP_REQUIRES(context, bad_offset < 0,\n                  errors::InvalidArgument(\n                      \"Bad: indices[\", start + bad_offset,\n                      \"] == \", indices_vec(start + bad_offset),\n                      \" out of range [0, \", input_flat.dimension(0), \")\"))",
          "old_line_content": "                      \"Bad: indices[\", start + bad_offset,",
          "new_line_content": "      OP_REQUIRES(context, bad_offset < 0,",
          "content_same": false
        },
        {
          "line": 1186,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "scaling.size()",
          "old_line_content": "      }",
          "new_line_content": "      for (size_t i = 0; i < scaling.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 1187,
          "old_api": null,
          "new_api": "std::max(scaling[i], 1.0)",
          "old_text": null,
          "new_text": "std::max(scaling[i], 1.0)",
          "old_line_content": "    }",
          "new_line_content": "        scaling[i] = 1.0 / sqrt(std::max(scaling[i], 1.0));",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": null,
          "new_api": "indices_vec",
          "old_text": null,
          "new_text": "indices_vec(start + bad_offset)",
          "old_line_content": "",
          "new_line_content": "                      \"] == \", indices_vec(start + bad_offset),",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": null,
          "new_api": "dimension",
          "old_text": null,
          "new_text": "input_flat.dimension(0)",
          "old_line_content": "      start = end;",
          "new_line_content": "                      \" out of range [0, \", input_flat.dimension(0), \")\"));",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": null,
          "new_api": "output_flat",
          "old_text": null,
          "new_text": "output_flat(uninitialized_index, 0)",
          "old_line_content": "    }",
          "new_line_content": "          gap_slice(&output_flat(uninitialized_index, 0), gap_slice_shape);",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": null,
          "new_api": "setConstant",
          "old_text": null,
          "new_text": "gap_slice.setConstant(default_value_)",
          "old_line_content": "  }",
          "new_line_content": "      gap_slice.setConstant(default_value_);",
          "content_same": false
        },
        {
          "line": 1205,
          "old_api": null,
          "new_api": "dim_size",
          "old_text": null,
          "new_text": "dense_output_shape.dim_size(0)",
          "old_line_content": "    const SegmentId last_segment_id_plus_one =",
          "new_line_content": "    const int64_t M = dense_output_shape.dim_size(0);",
          "content_same": false
        },
        {
          "line": 1208,
          "old_api": null,
          "new_api": "segment_vec",
          "old_text": null,
          "new_text": "segment_vec(N - 1)",
          "old_line_content": "    // order as the V1 implementation.",
          "new_line_content": "        internal::SubtleMustCopy(segment_vec(N - 1)) + 1;",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": null,
          "new_api": "OP_REQUIRES",
          "old_text": null,
          "new_text": "OP_REQUIRES(context, last_segment_id_plus_one <= num_segments,\n                errors::InvalidArgument(\"Invalid number of segments\"))",
          "old_line_content": "    for (int64_t i = 0; i < N; ++i) {",
          "new_line_content": "    OP_REQUIRES(context, last_segment_id_plus_one <= num_segments,",
          "content_same": false
        },
        {
          "line": 1215,
          "old_api": null,
          "new_api": "FastBoundsCheck",
          "old_text": null,
          "new_text": "FastBoundsCheck(output_idx, M)",
          "old_line_content": "                                          \" out of range [0, \", M, \").\"));",
          "new_line_content": "      OP_REQUIRES(context, FastBoundsCheck(output_idx, M),",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": null,
          "new_api": "FastBoundsCheck",
          "old_text": null,
          "new_text": "FastBoundsCheck(segment_id, num_segments)",
          "old_line_content": "                                  \" out of range [0, \", num_segments, \").\"));",
          "new_line_content": "          context, FastBoundsCheck(segment_id, num_segments),",
          "content_same": false
        },
        {
          "line": 1221,
          "old_api": null,
          "new_api": "errors::InvalidArgument(\"Segment id \", segment_id,\n                                  \" out of range [0, \", num_segments, \").\")",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\"Segment id \", segment_id,\n                                  \" out of range [0, \", num_segments, \").\")",
          "old_line_content": "    }",
          "new_line_content": "          errors::InvalidArgument(\"Segment id \", segment_id,",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": null,
          "new_api": "input_flat.template chip<0>(index)",
          "old_text": null,
          "new_text": "input_flat.template chip<0>(index)",
          "old_line_content": "",
          "new_line_content": "    return input_flat.template chip<0>(index);",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": null,
          "new_api": "input_flat.template chip<0>(index).template cast<float>()",
          "old_text": null,
          "new_text": "input_flat.template chip<0>(index).template cast<float>()",
          "old_line_content": "",
          "new_line_content": "    return input_flat.template chip<0>(index).template cast<float>();",
          "content_same": false
        },
        {
          "line": 1231,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "permutation.end()",
          "old_line_content": "    std::vector<Index> sorted_indices;",
          "new_line_content": "        permutation.begin(), permutation.end(),",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": null,
          "new_api": "indices_vec",
          "old_text": null,
          "new_text": "indices_vec(b)",
          "old_line_content": "    std::vector<SegmentId> permuted_segments;",
          "new_line_content": "        [&](Index a, Index b) { return indices_vec(a) < indices_vec(b); });",
          "content_same": false
        },
        {
          "line": 1235,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "sorted_indices.reserve(N)",
          "old_line_content": "    for (Index j : permutation) {",
          "new_line_content": "    sorted_indices.reserve(N);",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": null,
          "new_api": "Tout",
          "old_text": null,
          "new_text": "Tout(num)",
          "old_line_content": "    if (is_sqrtn_ && (num < 10)) {",
          "new_line_content": "      m = Tout(num);",
          "content_same": false
        },
        {
          "line": 1238,
          "old_api": null,
          "new_api": "indices_vec",
          "old_text": null,
          "new_text": "indices_vec(j)",
          "old_line_content": "    }",
          "new_line_content": "      sorted_indices.push_back(indices_vec(j));",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": null,
          "new_api": "segment_vec",
          "old_text": null,
          "new_text": "segment_vec(j)",
          "old_line_content": "",
          "new_line_content": "      permuted_segments.push_back(segment_vec(j));",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": null,
          "new_api": "Tout",
          "old_text": null,
          "new_text": "Tout(1)",
          "old_line_content": "",
          "new_line_content": "    return Tout(1) / m;",
          "content_same": false
        },
        {
          "line": 1246,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "unique_index_ids.reserve(N)",
          "old_line_content": "      auto iter =",
          "new_line_content": "    unique_index_ids.reserve(N);",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "unique_indices_map.size()",
          "old_line_content": "      Index unique_id = iter->second;",
          "new_line_content": "          unique_indices_map.emplace(output_idx, unique_indices_map.size())",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": null,
          "new_api": "ReduceImpl<Tin, Tindex, Tin>(input_flat, indices_vec, start, num,\n                                        out, get_scaling_factor<Tin>(num))",
          "old_text": null,
          "new_text": "ReduceImpl<Tin, Tindex, Tin>(input_flat, indices_vec, start, num,\n                                        out, get_scaling_factor<Tin>(num))",
          "old_line_content": "  }",
          "new_line_content": "    return ReduceImpl<Tin, Tindex, Tin>(input_flat, indices_vec, start, num,",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": null,
          "new_api": "get_scaling_factor<Tin>(num)",
          "old_text": null,
          "new_text": "get_scaling_factor<Tin>(num)",
          "old_line_content": "",
          "new_line_content": "                                        out, get_scaling_factor<Tin>(num));",
          "content_same": false
        },
        {
          "line": 1254,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "unique_indices_map.size()",
          "old_line_content": "    // The original index for each unique ID.",
          "new_line_content": "    const int64_t num_unique = unique_indices_map.size();",
          "content_same": false
        },
        {
          "line": 1258,
          "old_api": null,
          "new_api": "allocate_output",
          "old_text": null,
          "new_text": "OP_REQUIRES_OK(context,\n                   context->allocate_output(1, {num_unique}, &unique_indices))",
          "old_line_content": "    typename TTypes<Index>::Vec unique_indices_vec =",
          "new_line_content": "    OP_REQUIRES_OK(context,",
          "content_same": false
        },
        {
          "line": 1263,
          "old_api": null,
          "new_api": "unique_indices_vec",
          "old_text": null,
          "new_text": "unique_indices_vec(idx_and_id.second)",
          "old_line_content": "",
          "new_line_content": "      unique_indices_vec(idx_and_id.second) = idx_and_id.first;",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": null,
          "new_api": "get_scaling_factor<float>(num)",
          "old_text": null,
          "new_text": "get_scaling_factor<float>(num)",
          "old_line_content": "    return res;",
          "new_line_content": "                                       temp, get_scaling_factor<float>(num));",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": null,
          "new_api": "temp.template cast<Tin>()",
          "old_text": null,
          "new_text": "temp.template cast<Tin>()",
          "old_line_content": "  }",
          "new_line_content": "    out = temp.template cast<Tin>();",
          "content_same": false
        },
        {
          "line": 1269,
          "old_api": null,
          "new_api": "allocate_output",
          "old_text": null,
          "new_text": "context->allocate_output(0, output_shape, &output)",
          "old_line_content": "    // Call the V1 implementation with the unique/permuted indices/segments.",
          "new_line_content": "    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));",
          "content_same": false
        },
        {
          "line": 1275,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "permuted_segments.size()",
          "old_line_content": "        context, operation, input_flat, unique_index_ids_vec,",
          "new_line_content": "        permuted_segments.data(), permuted_segments.size());",
          "content_same": false
        },
        {
          "line": 1276,
          "old_api": null,
          "new_api": "SparseSegmentGradFunctor<CPUDevice, T, Index, SegmentId>()(\n        context, operation, input_flat, unique_index_ids_vec,\n        permuted_segment_vec, output)",
          "old_text": null,
          "new_text": "SparseSegmentGradFunctor<CPUDevice, T, Index, SegmentId>()(\n        context, operation, input_flat, unique_index_ids_vec,\n        permuted_segment_vec, output)",
          "old_line_content": "        permuted_segment_vec, output);",
          "new_line_content": "    SparseSegmentGradFunctor<CPUDevice, T, Index, SegmentId>()(",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": null,
          "new_api": "INDEX",
          "old_text": null,
          "new_text": "INDEX(0, 0)",
          "old_line_content": "    } else {",
          "new_line_content": "      INDEX(0, 0);",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": null,
          "new_api": "L",
          "old_text": null,
          "new_text": "L(0)",
          "old_line_content": "      int64_t r = num & 7;",
          "new_line_content": "      out = L(0);",
          "content_same": false
        },
        {
          "line": 778,
          "old_api": null,
          "new_api": "INDEX",
          "old_text": null,
          "new_text": "INDEX(1, 1)",
          "old_line_content": "          break;",
          "new_line_content": "          INDEX(1, 1);",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": null,
          "new_api": "L",
          "old_text": null,
          "new_text": "L(1)",
          "old_line_content": "        }",
          "new_line_content": "          out = (L(0) + L(1)) * scaling_factor;",
          "content_same": false
        },
        {
          "line": 1295,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "      : OpKernel(context), operation_(operation) {}",
          "new_line_content": "  explicit SparseSegmentGradOpBase(OpKernelConstruction* context,",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": null,
          "new_api": "INDEX",
          "old_text": null,
          "new_text": "INDEX(2, 2)",
          "old_line_content": "          break;",
          "new_line_content": "          INDEX(2, 2);",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": null,
          "new_api": "L",
          "old_text": null,
          "new_text": "L(2)",
          "old_line_content": "        }",
          "new_line_content": "          out = (L(0) + L(1) + L(2)) * scaling_factor;",
          "content_same": false
        },
        {
          "line": 1302,
          "old_api": null,
          "new_api": "input",
          "old_text": null,
          "new_text": "context->input(2)",
          "old_line_content": "",
          "new_line_content": "    const Tensor& segment_ids = context->input(2);",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": null,
          "new_api": "INDEX",
          "old_text": null,
          "new_text": "INDEX(3, 3)",
          "old_line_content": "          break;",
          "new_line_content": "          INDEX(3, 3);",
          "content_same": false
        },
        {
          "line": 794,
          "old_api": null,
          "new_api": "L",
          "old_text": null,
          "new_text": "L(3)",
          "old_line_content": "        }",
          "new_line_content": "          out = (L(0) + L(1) + L(2) + L(3)) * scaling_factor;",
          "content_same": false
        },
        {
          "line": 1309,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "output_dim0.shape()",
          "old_line_content": "",
          "new_line_content": "    OP_REQUIRES(context, TensorShapeUtils::IsScalar(output_dim0.shape()),",
          "content_same": false
        },
        {
          "line": 1313,
          "old_api": null,
          "new_api": "NumElements",
          "old_text": null,
          "new_text": "segment_ids.NumElements()",
          "old_line_content": "                    \"segment_ids and indices should have same size.\"));",
          "new_line_content": "    OP_REQUIRES(context, N == segment_ids.NumElements(),",
          "content_same": false
        },
        {
          "line": 802,
          "old_api": null,
          "new_api": "INDEX",
          "old_text": null,
          "new_text": "INDEX(4, 4)",
          "old_line_content": "          break;",
          "new_line_content": "          INDEX(4, 4);",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": null,
          "new_api": "L",
          "old_text": null,
          "new_text": "L(4)",
          "old_line_content": "        }",
          "new_line_content": "          out = (L(0) + L(1) + L(2) + L(3) + L(4)) * scaling_factor;",
          "content_same": false
        },
        {
          "line": 1319,
          "old_api": null,
          "new_api": "indices.vec<Index>()",
          "old_text": null,
          "new_text": "indices.vec<Index>()",
          "old_line_content": "",
          "new_line_content": "    const auto indices_vec = indices.vec<Index>();",
          "content_same": false
        },
        {
          "line": 1322,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "input.shape()",
          "old_line_content": "    Tensor* output = nullptr;",
          "new_line_content": "    TensorShape output_shape = input.shape();",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": null,
          "new_api": "INDEX",
          "old_text": null,
          "new_text": "INDEX(5, 5)",
          "old_line_content": "          break;",
          "new_line_content": "          INDEX(5, 5);",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": null,
          "new_api": "L",
          "old_text": null,
          "new_text": "L(5)",
          "old_line_content": "        }",
          "new_line_content": "          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5)) * scaling_factor;",
          "content_same": false
        },
        {
          "line": 1325,
          "old_api": null,
          "new_api": "allocate_output",
          "old_text": null,
          "new_text": "context->allocate_output(0, output_shape, &output)",
          "old_line_content": "",
          "new_line_content": "    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));",
          "content_same": false
        },
        {
          "line": 1328,
          "old_api": null,
          "new_api": "functor::SparseSegmentGradFunctor<Device, T, Index, SegmentId>()(\n        context, operation_, input_flat, indices_vec, segment_vec, output)",
          "old_text": null,
          "new_text": "functor::SparseSegmentGradFunctor<Device, T, Index, SegmentId>()(\n        context, operation_, input_flat, indices_vec, segment_vec, output)",
          "old_line_content": "  }",
          "new_line_content": "    functor::SparseSegmentGradFunctor<Device, T, Index, SegmentId>()(",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": null,
          "new_api": "INDEX",
          "old_text": null,
          "new_text": "INDEX(5, 5)",
          "old_line_content": "          out =",
          "new_line_content": "          INDEX(5, 5);",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": null,
          "new_api": "L",
          "old_text": null,
          "new_text": "L(6)",
          "old_line_content": "        }",
          "new_line_content": "              (L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6)) * scaling_factor;",
          "content_same": false
        },
        {
          "line": 1340,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "            context, SparseSegmentReductionOperation::kSum) {}",
          "new_line_content": "  explicit SparseSegmentSumGradOp(OpKernelConstruction* context)",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": null,
          "new_api": "INDEX",
          "old_text": null,
          "new_text": "INDEX(7, 7)",
          "old_line_content": "                scaling_factor;",
          "new_line_content": "          INDEX(7, 7);",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": null,
          "new_api": "L",
          "old_text": null,
          "new_text": "L(7)",
          "old_line_content": "          r = 8;",
          "new_line_content": "          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6) + L(7)) *",
          "content_same": false
        },
        {
          "line": 1349,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "            context, SparseSegmentReductionOperation::kMean) {}",
          "new_line_content": "  explicit SparseSegmentMeanGradOp(OpKernelConstruction* context)",
          "content_same": false
        },
        {
          "line": 1358,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "            context, SparseSegmentReductionOperation::kSqrtN) {}",
          "new_line_content": "  explicit SparseSegmentSqrtNGradOp(OpKernelConstruction* context)",
          "content_same": false
        },
        {
          "line": 851,
          "old_api": null,
          "new_api": "INDEX",
          "old_text": null,
          "new_text": "INDEX(8, 8)",
          "old_line_content": "                scaling_factor;",
          "new_line_content": "          INDEX(8, 8);",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": null,
          "new_api": "L",
          "old_text": null,
          "new_text": "L(8)",
          "old_line_content": "          r = 9;",
          "new_line_content": "          out = (L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6) + L(7) + L(8)) *",
          "content_same": false
        },
        {
          "line": 1371,
          "old_api": null,
          "new_api": "input",
          "old_text": null,
          "new_text": "context->input(2)",
          "old_line_content": "",
          "new_line_content": "    const Tensor& segment_ids = context->input(2);",
          "content_same": false
        },
        {
          "line": 1374,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "indices.shape()",
          "old_line_content": "    }",
          "new_line_content": "    if (!TensorShapeUtils::IsVector(indices.shape())) {",
          "content_same": false
        },
        {
          "line": 1377,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "segment_ids.shape()",
          "old_line_content": "    }",
          "new_line_content": "    if (!TensorShapeUtils::IsVector(segment_ids.shape())) {",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": null,
          "new_api": "INDEX",
          "old_text": null,
          "new_text": "INDEX(7, r + 7)",
          "old_line_content": "      }",
          "new_line_content": "        INDEX(7, r + 7);",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": null,
          "new_api": "L",
          "old_text": null,
          "new_text": "L(7)",
          "old_line_content": "      if (is_mean_ && num >= 10) {",
          "new_line_content": "        out += L(0) + L(1) + L(2) + L(3) + L(4) + L(5) + L(6) + L(7);",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "dense_output_dim0.shape()",
          "old_line_content": "    }",
          "new_line_content": "    if (!TensorShapeUtils::IsScalar(dense_output_dim0.shape())) {",
          "content_same": false
        },
        {
          "line": 1381,
          "old_api": null,
          "new_api": "errors::InvalidArgument(\"dense_output_dim0 should be a scalar.\")",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\"dense_output_dim0 should be a scalar.\")",
          "old_line_content": "",
          "new_line_content": "      return errors::InvalidArgument(\"dense_output_dim0 should be a scalar.\");",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": null,
          "new_api": "static_cast<Tout>(num)",
          "old_text": null,
          "new_text": "static_cast<Tout>(num)",
          "old_line_content": "      if (is_sqrtn_ && num >= 10) {",
          "new_line_content": "        out = out / static_cast<Tout>(num);",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": null,
          "new_api": "sqrt",
          "old_text": null,
          "new_text": "sqrt(num)",
          "old_line_content": "    }",
          "new_line_content": "        out = out / static_cast<Tout>(sqrt(num));",
          "content_same": false
        },
        {
          "line": 1385,
          "old_api": null,
          "new_api": "NumElements",
          "old_text": null,
          "new_text": "segment_ids.NumElements()",
          "old_line_content": "          \"segment_ids and indices should have same size.\");",
          "new_line_content": "    if (N != segment_ids.NumElements()) {",
          "content_same": false
        },
        {
          "line": 1386,
          "old_api": null,
          "new_api": "errors::InvalidArgument(\n          \"segment_ids and indices should have same size.\")",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\n          \"segment_ids and indices should have same size.\")",
          "old_line_content": "    }",
          "new_line_content": "      return errors::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 1391,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "input.shape()",
          "old_line_content": "",
          "new_line_content": "    TensorShape dense_output_shape = input.shape();",
          "content_same": false
        },
        {
          "line": 1392,
          "old_api": null,
          "new_api": "SetDimWithStatus",
          "old_text": null,
          "new_text": "dense_output_shape.SetDimWithStatus(0, M)",
          "old_line_content": "    if (M == 0 || N == 0) {",
          "new_line_content": "    TF_RETURN_IF_ERROR(dense_output_shape.SetDimWithStatus(0, M));",
          "content_same": false
        },
        {
          "line": 1395,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "input.shape()",
          "old_line_content": "      Tensor* output = nullptr;",
          "new_line_content": "      TensorShape output_shape = input.shape();",
          "content_same": false
        },
        {
          "line": 1402,
          "old_api": null,
          "new_api": "absl::OkStatus()",
          "old_text": null,
          "new_text": "absl::OkStatus()",
          "old_line_content": "",
          "new_line_content": "      return absl::OkStatus();",
          "content_same": false
        },
        {
          "line": 1406,
          "old_api": null,
          "new_api": "indices.vec<Index>()",
          "old_text": null,
          "new_text": "indices.vec<Index>()",
          "old_line_content": "",
          "new_line_content": "    const auto indices_vec = indices.vec<Index>();",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "                                        bool has_num_segments, T default_value)",
          "new_line_content": "  explicit SparseSegmentReductionOpBase(OpKernelConstruction* context,",
          "content_same": false
        },
        {
          "line": 1409,
          "old_api": null,
          "new_api": "functor::SparseSegmentGradV2Functor<Device, T, Index, SegmentId>()(\n        context, operation, input_flat, indices_vec, segment_vec,\n        dense_output_shape, done)",
          "old_text": null,
          "new_text": "functor::SparseSegmentGradV2Functor<Device, T, Index, SegmentId>()(\n        context, operation, input_flat, indices_vec, segment_vec,\n        dense_output_shape, done)",
          "old_line_content": "        dense_output_shape, done);",
          "new_line_content": "    functor::SparseSegmentGradV2Functor<Device, T, Index, SegmentId>()(",
          "content_same": false
        },
        {
          "line": 1413,
          "old_api": null,
          "new_api": "absl::OkStatus()",
          "old_text": null,
          "new_text": "absl::OkStatus()",
          "old_line_content": "};",
          "new_line_content": "    return absl::OkStatus();",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": null,
          "new_api": "input",
          "old_text": null,
          "new_text": "context->input(1)",
          "old_line_content": "",
          "new_line_content": "    const Tensor& indices = context->input(1);",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": null,
          "new_api": "internal::ValidateSparseSegmentReduction(\n            context, input, indices, segment_ids, has_num_segments_)",
          "old_text": null,
          "new_text": "internal::ValidateSparseSegmentReduction(\n            context, input, indices, segment_ids, has_num_segments_)",
          "old_line_content": "        done);",
          "new_line_content": "        internal::ValidateSparseSegmentReduction(",
          "content_same": false
        },
        {
          "line": 1425,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "      : OpKernel(context), operation_(operation) {}",
          "new_line_content": "  explicit SparseSegmentGradV2OpBase(OpKernelConstruction* context,",
          "content_same": false
        },
        {
          "line": 1430,
          "old_api": null,
          "new_api": "OP_REQUIRES_OK",
          "old_text": null,
          "new_text": "OP_REQUIRES_OK(\n        context, (SparseSegmentGradV2OpCommon<CPUDevice, T, Index, SegmentId>()(\n                     context, operation_)))",
          "old_line_content": "                     context, operation_)));",
          "new_line_content": "    OP_REQUIRES_OK(",
          "content_same": false
        },
        {
          "line": 1431,
          "old_api": null,
          "new_api": "SparseSegmentGradV2OpCommon<CPUDevice, T, Index, SegmentId>()(\n                     context, operation_)",
          "old_text": null,
          "new_text": "SparseSegmentGradV2OpCommon<CPUDevice, T, Index, SegmentId>()(\n                     context, operation_)",
          "old_line_content": "  }",
          "new_line_content": "        context, (SparseSegmentGradV2OpCommon<CPUDevice, T, Index, SegmentId>()(",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": null,
          "new_api": "op_device_context",
          "old_text": null,
          "new_text": "context->op_device_context()->stream()",
          "old_line_content": "",
          "new_line_content": "      auto stream = context->op_device_context()->stream();",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": null,
          "new_api": "OP_REQUIRES_ASYNC",
          "old_text": null,
          "new_text": "OP_REQUIRES_ASYNC(context, output_rows > 0,\n                        errors::InvalidArgument(\"segment ids must be >= 0\"),\n                        done)",
          "old_line_content": "                        done);",
          "new_line_content": "      OP_REQUIRES_ASYNC(context, output_rows > 0,",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": null,
          "new_api": "errors::InvalidArgument(\"segment ids must be >= 0\")",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\"segment ids must be >= 0\")",
          "old_line_content": "",
          "new_line_content": "                        errors::InvalidArgument(\"segment ids must be >= 0\"),",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "input.shape()",
          "old_line_content": "",
          "new_line_content": "      TensorShape output_shape = input.shape();",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": null,
          "new_api": "set_dim",
          "old_text": null,
          "new_text": "output_shape.set_dim(0, output_rows)",
          "old_line_content": "      Tensor* output = nullptr;",
          "new_line_content": "      output_shape.set_dim(0, output_rows);",
          "content_same": false
        },
        {
          "line": 1444,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "      : AsyncOpKernel(context), operation_(operation) {}",
          "new_line_content": "  explicit SparseSegmentGradV2OpBase(OpKernelConstruction* context,",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": null,
          "new_api": "allocate_output",
          "old_text": null,
          "new_text": "OP_REQUIRES_OK_ASYNC(\n          context, context->allocate_output(0, output_shape, &output), done)",
          "old_line_content": "",
          "new_line_content": "      OP_REQUIRES_OK_ASYNC(",
          "content_same": false
        },
        {
          "line": 1451,
          "old_api": null,
          "new_api": "SparseSegmentGradV2OpCommon<GPUDevice, T, Index, SegmentId>()(\n            context, operation_, done)",
          "old_text": null,
          "new_text": "SparseSegmentGradV2OpCommon<GPUDevice, T, Index, SegmentId>()(\n            context, operation_, done)",
          "old_line_content": "        done);",
          "new_line_content": "        (SparseSegmentGradV2OpCommon<GPUDevice, T, Index, SegmentId>()(",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": null,
          "new_api": "segment_ids.vec<SegmentId>()",
          "old_text": null,
          "new_text": "segment_ids.vec<SegmentId>()",
          "old_line_content": "",
          "new_line_content": "      const auto segment_ids_vec = segment_ids.vec<SegmentId>();",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": null,
          "new_api": "output->flat_outer_dims<T>()",
          "old_text": null,
          "new_text": "output->flat_outer_dims<T>()",
          "old_line_content": "      functor::SparseSegmentReductionFunctor<T, Index, SegmentId> functor;",
          "new_line_content": "      auto output_flat = output->flat_outer_dims<T>();",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": null,
          "new_api": "functor",
          "old_text": null,
          "new_text": "functor(context, is_mean_, is_sqrtn_, default_value_, input_flat,\n                  indices_vec, segment_ids_vec, output_flat)",
          "old_line_content": "          done);",
          "new_line_content": "          functor(context, is_mean_, is_sqrtn_, default_value_, input_flat,",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": null,
          "new_api": "done",
          "old_text": null,
          "new_text": "done()",
          "old_line_content": "",
          "new_line_content": "      done();",
          "content_same": false
        },
        {
          "line": 1464,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "            context, SparseSegmentReductionOperation::kSum) {}",
          "new_line_content": "  explicit SparseSegmentSumGradV2Op(OpKernelConstruction* context)",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": null,
          "new_api": "mutable_data",
          "old_text": null,
          "new_text": "last_segment_id_host.mutable_data()",
          "old_line_content": "    } else {",
          "new_line_content": "      *last_segment_id_host.mutable_data() = num_segments - 1;",
          "content_same": false
        },
        {
          "line": 1473,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "            context, SparseSegmentReductionOperation::kMean) {}",
          "new_line_content": "  explicit SparseSegmentMeanGradV2Op(OpKernelConstruction* context)",
          "content_same": false
        },
        {
          "line": 964,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "input.shape()",
          "old_line_content": "",
          "new_line_content": "        TensorShape output_shape = input.shape();",
          "content_same": false
        },
        {
          "line": 965,
          "old_api": null,
          "new_api": "set_dim",
          "old_text": null,
          "new_text": "output_shape.set_dim(0, 0)",
          "old_line_content": "        Tensor* output = nullptr;",
          "new_line_content": "        output_shape.set_dim(0, 0);",
          "content_same": false
        },
        {
          "line": 969,
          "old_api": null,
          "new_api": "allocate_output",
          "old_text": null,
          "new_text": "context->allocate_output(0, output_shape, &output)",
          "old_line_content": "        return;",
          "new_line_content": "            context, context->allocate_output(0, output_shape, &output), done);",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": null,
          "new_api": "done",
          "old_text": null,
          "new_text": "done()",
          "old_line_content": "      }",
          "new_line_content": "        done();",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "            context, SparseSegmentReductionOperation::kSqrtN) {}",
          "new_line_content": "  explicit SparseSegmentSqrtNGradV2Op(OpKernelConstruction* context)",
          "content_same": false
        },
        {
          "line": 979,
          "old_api": null,
          "new_api": "op_device_context",
          "old_text": null,
          "new_text": "context->op_device_context()->stream()",
          "old_line_content": "          context,",
          "new_line_content": "      auto stream = context->op_device_context()->stream();",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": null,
          "new_api": "mutable_data",
          "old_text": null,
          "new_text": "last_segment_id_host.mutable_data()",
          "old_line_content": "          done);",
          "new_line_content": "          stream->Memcpy(last_segment_id_host.mutable_data(),",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": null,
          "new_api": "device",
          "old_text": null,
          "new_text": "context->device()\n          ->tensorflow_accelerator_device_info()\n          ->event_mgr->ThenExecute(stream, create_and_check_output)",
          "old_line_content": "          ->event_mgr->ThenExecute(stream, create_and_check_output);",
          "new_line_content": "      context->device()",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "            context, true /*is_mean*/, false /*is_sqrtn*/,",
          "new_line_content": "  explicit SparseSegmentReductionMeanOp(OpKernelConstruction* context)",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": null,
          "new_api": "T",
          "old_text": null,
          "new_text": "T(0)",
          "old_line_content": "",
          "new_line_content": "            false /* has_num_segments */, T(0) /* default_value */) {}",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(",
          "new_line_content": "  explicit SparseSegmentReductionMeanWithNumSegmentsOp(",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": null,
          "new_api": "T",
          "old_text": null,
          "new_text": "T(0)",
          "old_line_content": "",
          "new_line_content": "            true /* has_num_segments */, T(0) /* default_value */) {}",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1026,
          "old_api": "T",
          "new_api": null,
          "old_text": "T(0)",
          "new_text": null,
          "old_line_content": "            false /* has_num_segments */, T(0) /* default_value */) {}",
          "new_line_content": "      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit SparseSegmentReductionSqrtNWithNumSegmentsOp(",
          "new_line_content": "    : public SparseSegmentReductionOpBase<Device, T, Index, SegmentId> {",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": "T",
          "new_api": null,
          "old_text": "T(0)",
          "new_text": null,
          "old_line_content": "            true /* has_num_segments */, T(0) /* default_value */) {}",
          "new_line_content": "      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit SparseSegmentReductionSumOp(OpKernelConstruction* context)",
          "new_line_content": "    : public SparseSegmentReductionOpBase<Device, T, Index, SegmentId> {",
          "content_same": false
        },
        {
          "line": 1047,
          "old_api": "T",
          "new_api": null,
          "old_text": "T(0)",
          "new_text": null,
          "old_line_content": "            false /* has_num_segments */, T(0) /* default_value */) {}",
          "new_line_content": "      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit SparseSegmentReductionSumWithNumSegmentsOp(",
          "new_line_content": "    : public SparseSegmentReductionOpBase<Device, T, Index, SegmentId> {",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": "T",
          "new_api": null,
          "old_text": "T(0)",
          "new_text": null,
          "old_line_content": "            true /* has_num_segments */, T(0) /* default_value */) {}",
          "new_line_content": "      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(",
          "content_same": false
        },
        {
          "line": 1071,
          "old_api": "output->flat_outer_dims<T>()",
          "new_api": null,
          "old_text": "output->flat_outer_dims<T>()",
          "new_text": null,
          "old_line_content": "    auto output_flat = output->flat_outer_dims<T>();",
          "new_line_content": "                  typename TTypes<SegmentId>::ConstVec segment_vec,",
          "content_same": false
        },
        {
          "line": 1072,
          "old_api": "size",
          "new_api": null,
          "old_text": "indices_vec.size()",
          "new_text": null,
          "old_line_content": "    const int64_t N = indices_vec.size();",
          "new_line_content": "                  Tensor* output) {",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": "dimension",
          "new_api": null,
          "old_text": "input_flat.dimension(0)",
          "new_text": null,
          "old_line_content": "    const SegmentId num_segments = input_flat.dimension(0);",
          "new_line_content": "    // Note that similar to SparseSegmentMean, we assume that segment_vec is",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": "OP_REQUIRES",
          "new_api": null,
          "old_text": "OP_REQUIRES(context, last_segment_id_plus_one <= num_segments,\n                absl::InvalidArgumentError(\"Invalid number of segments\"))",
          "new_text": null,
          "old_line_content": "    OP_REQUIRES(context, last_segment_id_plus_one <= num_segments,",
          "new_line_content": "    const SegmentId last_segment_id_plus_one =",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": "ComputeScalingFactors",
          "new_api": null,
          "old_text": "ComputeScalingFactors(operation, segment_vec, num_segments)",
          "new_text": null,
          "old_line_content": "        ComputeScalingFactors(operation, segment_vec, num_segments);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": "status",
          "new_api": null,
          "old_text": "scaling_or.status()",
          "new_text": null,
          "old_line_content": "    OP_REQUIRES_OK(context, scaling_or.status());",
          "new_line_content": "    const auto scaling_or =",
          "content_same": false
        },
        {
          "line": 1092,
          "old_api": "dtype",
          "new_api": null,
          "old_text": "output->dtype()",
          "new_text": null,
          "old_line_content": "    if (output->dtype() == DT_BFLOAT16 || output->dtype() == DT_HALF) {",
          "new_line_content": "    // every segment.",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": "shape",
          "new_api": null,
          "old_text": "output->shape()",
          "new_text": null,
          "old_line_content": "      temp = tensorflow::Tensor(DT_FLOAT, output->shape());",
          "new_line_content": "    Tensor temp;",
          "content_same": false
        },
        {
          "line": 1098,
          "old_api": "setZero",
          "new_api": null,
          "old_text": "temp_flat.setZero()",
          "new_text": null,
          "old_line_content": "      temp_flat.setZero();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1104,
          "old_api": "indices_vec",
          "new_api": null,
          "old_text": "indices_vec(i)",
          "new_text": null,
          "old_line_content": "      const Index output_idx = internal::SubtleMustCopy(indices_vec(i));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": "FastBoundsCheck",
          "new_api": null,
          "old_text": "FastBoundsCheck(output_idx, M)",
          "new_text": null,
          "old_line_content": "      OP_REQUIRES(context, FastBoundsCheck(output_idx, M),",
          "new_line_content": "    for (int64_t i = 0; i < N; ++i) {",
          "content_same": false
        },
        {
          "line": 1109,
          "old_api": "segment_vec",
          "new_api": null,
          "old_text": "segment_vec(i)",
          "new_text": null,
          "old_line_content": "      const SegmentId idx = internal::SubtleMustCopy(segment_vec(i));",
          "new_line_content": "                      \"Index \", output_idx, \" out of range [0, \", M, \").\")));",
          "content_same": false
        },
        {
          "line": 1110,
          "old_api": "OP_REQUIRES",
          "new_api": null,
          "old_text": "OP_REQUIRES(\n          context, FastBoundsCheck(idx, num_segments),\n          absl::InvalidArgumentError(absl::StrCat(\n              \"Segment id \", idx, \" out of range [0, \", num_segments, \").\")))",
          "new_text": null,
          "old_line_content": "      OP_REQUIRES(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1118,
          "old_api": "input_flat.template chip<0>(idx)",
          "new_api": null,
          "old_text": "input_flat.template chip<0>(idx)",
          "new_text": null,
          "old_line_content": "      Accumulate<T>(input_flat.template chip<0>(idx), scale,",
          "new_line_content": "                               ? 1.0",
          "content_same": false
        },
        {
          "line": 1119,
          "old_api": "output_flat.template chip<0>(output_idx)",
          "new_api": null,
          "old_text": "output_flat.template chip<0>(output_idx)",
          "new_text": null,
          "old_line_content": "                    output_flat.template chip<0>(output_idx),",
          "new_line_content": "                               : scaling[idx];",
          "content_same": false
        },
        {
          "line": 1124,
          "old_api": "dtype",
          "new_api": null,
          "old_text": "output->dtype()",
          "new_text": null,
          "old_line_content": "    if (output->dtype() == DT_BFLOAT16 || output->dtype() == DT_HALF) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1125,
          "old_api": "temp_flat.template cast<T>()",
          "new_api": null,
          "old_text": "temp_flat.template cast<T>()",
          "new_text": null,
          "old_line_content": "      output_flat = temp_flat.template cast<T>();",
          "new_line_content": "    // Copy the contents of the temp tensor to the output tensor.",
          "content_same": false
        },
        {
          "line": 626,
          "old_api": "tensorflow::Tensor(DT_FLOAT, output_shape)",
          "new_api": null,
          "old_text": "tensorflow::Tensor(DT_FLOAT, output_shape)",
          "new_text": null,
          "old_line_content": "      temp = tensorflow::Tensor(DT_FLOAT, output_shape);",
          "new_line_content": "      TensorShape temp_shape = output_shape;",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": "segment_vec",
          "new_api": null,
          "old_text": "segment_vec(start)",
          "new_text": null,
          "old_line_content": "    SegmentId out_index = internal::SubtleMustCopy(segment_vec(start));",
          "new_line_content": "    // Index from which the output is not initialized.",
          "content_same": false
        },
        {
          "line": 1147,
          "old_api": "static_cast<Tin>(scale)",
          "new_api": null,
          "old_text": "static_cast<Tin>(scale)",
          "new_text": null,
          "old_line_content": "    out += in * static_cast<Tin>(scale);",
          "new_line_content": "      Eigen::TensorChippingOp<0, typename TTypes<Tin>::Matrix> out,",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": "segment_vec",
          "new_api": null,
          "old_text": "segment_vec(end)",
          "new_text": null,
          "old_line_content": "        next_index = internal::SubtleMustCopy(segment_vec(end));",
          "new_line_content": "      SegmentId next_index = 0;",
          "content_same": false
        },
        {
          "line": 1156,
          "old_api": "static_cast<float>(scale)",
          "new_api": null,
          "old_text": "static_cast<float>(scale)",
          "new_text": null,
          "old_line_content": "    temp += in.template cast<float>() * static_cast<float>(scale);",
          "new_line_content": "      Eigen::TensorChippingOp<0, typename TTypes<Tin>::Matrix> out,",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": "OP_REQUIRES",
          "new_api": null,
          "old_text": "OP_REQUIRES(context, out_index < next_index,\n                    errors::InvalidArgument(\"segment ids are not increasing\"))",
          "new_text": null,
          "old_line_content": "        OP_REQUIRES(context, out_index < next_index,",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": "errors::InvalidArgument(\"segment ids are not increasing\")",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\"segment ids are not increasing\")",
          "new_text": null,
          "old_line_content": "                    errors::InvalidArgument(\"segment ids are not increasing\"));",
          "new_line_content": "        // We have a new segment here.  Verify that the segment ids are growing.",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": "OP_REQUIRES",
          "new_api": null,
          "old_text": "OP_REQUIRES(\n          context, FastBoundsCheck(out_index, output_rows),\n          errors::InvalidArgument(\n              \"Segment id \", out_index, \" out of range [0, \", output_rows,\n              \"), possibly because 'segment_ids' input is not sorted.\"))",
          "new_text": null,
          "old_line_content": "      OP_REQUIRES(",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": "FastBoundsCheck",
          "new_api": null,
          "old_text": "FastBoundsCheck(out_index, output_rows)",
          "new_text": null,
          "old_line_content": "          context, FastBoundsCheck(out_index, output_rows),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": "std::vector<double>(0)",
          "new_api": null,
          "old_text": "std::vector<double>(0)",
          "new_text": null,
          "old_line_content": "      return std::vector<double>(0);",
          "new_line_content": "      const SegmentId num_segments) {",
          "content_same": false
        },
        {
          "line": 1170,
          "old_api": "size",
          "new_api": null,
          "old_text": "segment_vec.size()",
          "new_text": null,
          "old_line_content": "    for (int64_t i = 0; i < segment_vec.size(); ++i) {",
          "new_line_content": "    std::vector<double> scaling(num_segments, 0);",
          "content_same": false
        },
        {
          "line": 1171,
          "old_api": "segment_vec",
          "new_api": null,
          "old_text": "segment_vec(i)",
          "new_text": null,
          "old_line_content": "      const SegmentId idx = internal::SubtleMustCopy(segment_vec(i));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": "output_flat",
          "new_api": null,
          "old_text": "output_flat(uninitialized_index, 0)",
          "new_text": null,
          "old_line_content": "            gap_slice(&output_flat(uninitialized_index, 0), gap_slice_shape);",
          "new_line_content": "            out_index - uninitialized_index, num_col);",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": "setConstant",
          "new_api": null,
          "old_text": "gap_slice.setConstant(default_value_)",
          "new_text": null,
          "old_line_content": "        gap_slice.setConstant(default_value_);",
          "new_line_content": "        Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>, Eigen::Unaligned>",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": "output_flat.template chip<0>(out_index)",
          "new_api": null,
          "old_text": "output_flat.template chip<0>(out_index)",
          "new_text": null,
          "old_line_content": "      auto out = output_flat.template chip<0>(out_index);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": "temp_flat.template chip<0>(out_index)",
          "new_api": null,
          "old_text": "temp_flat.template chip<0>(out_index)",
          "new_text": null,
          "old_line_content": "      auto temp = temp_flat.template chip<0>(out_index);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": "size",
          "new_api": null,
          "old_text": "scaling.size()",
          "new_text": null,
          "old_line_content": "      for (size_t i = 0; i < scaling.size(); ++i) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1181,
          "old_api": "std::max(scaling[i], 1.0)",
          "new_api": null,
          "old_text": "std::max(scaling[i], 1.0)",
          "new_text": null,
          "old_line_content": "        scaling[i] = 1.0 / std::max(scaling[i], 1.0);",
          "new_line_content": "    if (operation == SparseSegmentReductionOperation::kMean) {",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": "dimension",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\n                      \"Bad: indices[\", start + bad_offset,\n                      \"] == \", indices_vec(start + bad_offset),\n                      \" out of range [0, \", input_flat.dimension(0), \")\")",
          "new_text": null,
          "old_line_content": "                  errors::InvalidArgument(",
          "new_line_content": "                                              end - start, out, temp);",
          "content_same": false
        },
        {
          "line": 1184,
          "old_api": "size",
          "new_api": null,
          "old_text": "scaling.size()",
          "new_text": null,
          "old_line_content": "      for (size_t i = 0; i < scaling.size(); ++i) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": "std::max(scaling[i], 1.0)",
          "new_api": null,
          "old_text": "std::max(scaling[i], 1.0)",
          "new_text": null,
          "old_line_content": "        scaling[i] = 1.0 / sqrt(std::max(scaling[i], 1.0));",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": "dimension",
          "new_api": null,
          "old_text": "input_flat.dimension(0)",
          "new_text": null,
          "old_line_content": "                      \" out of range [0, \", input_flat.dimension(0), \")\"));",
          "new_line_content": "                      \"Bad: indices[\", start + bad_offset,",
          "content_same": false
        },
        {
          "line": 689,
          "old_api": "output_flat",
          "new_api": null,
          "old_text": "output_flat(uninitialized_index, 0)",
          "new_text": null,
          "old_line_content": "          gap_slice(&output_flat(uninitialized_index, 0), gap_slice_shape);",
          "new_line_content": "          output_rows - uninitialized_index, num_col);",
          "content_same": false
        },
        {
          "line": 690,
          "old_api": "setConstant",
          "new_api": null,
          "old_text": "gap_slice.setConstant(default_value_)",
          "new_text": null,
          "old_line_content": "      gap_slice.setConstant(default_value_);",
          "new_line_content": "      Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>, Eigen::Unaligned>",
          "content_same": false
        },
        {
          "line": 1202,
          "old_api": "size",
          "new_api": null,
          "old_text": "indices_vec.size()",
          "new_text": null,
          "old_line_content": "    const int64_t N = indices_vec.size();",
          "new_line_content": "                  const TensorShape& dense_output_shape,",
          "content_same": false
        },
        {
          "line": 1203,
          "old_api": "dim_size",
          "new_api": null,
          "old_text": "dense_output_shape.dim_size(0)",
          "new_text": null,
          "old_line_content": "    const int64_t M = dense_output_shape.dim_size(0);",
          "new_line_content": "                  typename AsyncOpKernel::DoneCallback /*done*/) {",
          "content_same": false
        },
        {
          "line": 1209,
          "old_api": "OP_REQUIRES",
          "new_api": null,
          "old_text": "OP_REQUIRES(context, last_segment_id_plus_one <= num_segments,\n                errors::InvalidArgument(\"Invalid number of segments\"))",
          "new_text": null,
          "old_line_content": "    OP_REQUIRES(context, last_segment_id_plus_one <= num_segments,",
          "new_line_content": "    // Note: We do bounds-checking up front here so that it operates in the same",
          "content_same": false
        },
        {
          "line": 1210,
          "old_api": "errors::InvalidArgument(\"Invalid number of segments\")",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\"Invalid number of segments\")",
          "new_text": null,
          "old_line_content": "                errors::InvalidArgument(\"Invalid number of segments\"));",
          "new_line_content": "    // order as the V1 implementation.",
          "content_same": false
        },
        {
          "line": 1213,
          "old_api": "FastBoundsCheck",
          "new_api": null,
          "old_text": "FastBoundsCheck(output_idx, M)",
          "new_text": null,
          "old_line_content": "      OP_REQUIRES(context, FastBoundsCheck(output_idx, M),",
          "new_line_content": "    for (int64_t i = 0; i < N; ++i) {",
          "content_same": false
        },
        {
          "line": 1217,
          "old_api": "OP_REQUIRES",
          "new_api": null,
          "old_text": "OP_REQUIRES(\n          context, FastBoundsCheck(segment_id, num_segments),\n          errors::InvalidArgument(\"Segment id \", segment_id,\n                                  \" out of range [0, \", num_segments, \").\"))",
          "new_text": null,
          "old_line_content": "      OP_REQUIRES(",
          "new_line_content": "                                          \" out of range [0, \", M, \").\"));",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": "input_flat.template chip<0>(index)",
          "new_api": null,
          "old_text": "input_flat.template chip<0>(index)",
          "new_text": null,
          "old_line_content": "    return input_flat.template chip<0>(index);",
          "new_line_content": "  EIGEN_ALWAYS_INLINE auto fetch_val(",
          "content_same": false
        },
        {
          "line": 1224,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "permutation.reserve(N)",
          "new_text": null,
          "old_line_content": "    permutation.reserve(N);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": "input_flat.template chip<0>(index).template cast<float>()",
          "new_api": null,
          "old_text": "input_flat.template chip<0>(index).template cast<float>()",
          "new_text": null,
          "old_line_content": "    return input_flat.template chip<0>(index).template cast<float>();",
          "new_line_content": "  EIGEN_ALWAYS_INLINE auto fetch_val(",
          "content_same": false
        },
        {
          "line": 1229,
          "old_api": "end",
          "new_api": null,
          "old_text": "permutation.end()",
          "new_text": null,
          "old_line_content": "        permutation.begin(), permutation.end(),",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1233,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "sorted_indices.reserve(N)",
          "new_text": null,
          "old_line_content": "    sorted_indices.reserve(N);",
          "new_line_content": "    std::vector<Index> sorted_indices;",
          "content_same": false
        },
        {
          "line": 1234,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "permuted_segments.reserve(N)",
          "new_text": null,
          "old_line_content": "    permuted_segments.reserve(N);",
          "new_line_content": "    std::vector<SegmentId> permuted_segments;",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "Tout",
          "new_api": null,
          "old_text": "Tout(num)",
          "new_text": null,
          "old_line_content": "      m = Tout(num);",
          "new_line_content": "    Tout m(1);",
          "content_same": false
        },
        {
          "line": 1237,
          "old_api": "segment_vec",
          "new_api": null,
          "old_text": "segment_vec(j)",
          "new_text": null,
          "old_line_content": "      permuted_segments.push_back(segment_vec(j));",
          "new_line_content": "    for (Index j : permutation) {",
          "content_same": false
        },
        {
          "line": 727,
          "old_api": "sqrt",
          "new_api": null,
          "old_text": "sqrt(num)",
          "new_text": null,
          "old_line_content": "      m = Tout(sqrt(num));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "unique_index_ids.reserve(N)",
          "new_text": null,
          "old_line_content": "    unique_index_ids.reserve(N);",
          "new_line_content": "    // The unique ID for each original index.",
          "content_same": false
        },
        {
          "line": 1247,
          "old_api": "size",
          "new_api": null,
          "old_text": "unique_indices_map.size()",
          "new_text": null,
          "old_line_content": "          unique_indices_map.emplace(output_idx, unique_indices_map.size())",
          "new_line_content": "    for (Index output_idx : sorted_indices) {",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": "ReduceImpl<Tin, Tindex, Tin>(input_flat, indices_vec, start, num,\n                                        out, get_scaling_factor<Tin>(num))",
          "new_api": null,
          "old_text": "ReduceImpl<Tin, Tindex, Tin>(input_flat, indices_vec, start, num,\n                                        out, get_scaling_factor<Tin>(num))",
          "new_text": null,
          "old_line_content": "    return ReduceImpl<Tin, Tindex, Tin>(input_flat, indices_vec, start, num,",
          "new_line_content": "      int64_t num, Eigen::TensorChippingOp<0, typename TTypes<Tin>::Matrix> out,",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": "get_scaling_factor<Tin>(num)",
          "new_api": null,
          "old_text": "get_scaling_factor<Tin>(num)",
          "new_text": null,
          "old_line_content": "                                        out, get_scaling_factor<Tin>(num));",
          "new_line_content": "      Eigen::TensorChippingOp<0, typename TTypes<float>::Matrix> temp) {",
          "content_same": false
        },
        {
          "line": 1250,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "unique_index_ids.push_back(unique_id)",
          "new_text": null,
          "old_line_content": "      unique_index_ids.push_back(unique_id);",
          "new_line_content": "              .first;",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": "allocate_output",
          "new_api": null,
          "old_text": "OP_REQUIRES_OK(context,\n                   context->allocate_output(1, {num_unique}, &unique_indices))",
          "new_text": null,
          "old_line_content": "    OP_REQUIRES_OK(context,",
          "new_line_content": "    // The original index for each unique ID.",
          "content_same": false
        },
        {
          "line": 1257,
          "old_api": "allocate_output",
          "new_api": null,
          "old_text": "context->allocate_output(1, {num_unique}, &unique_indices)",
          "new_text": null,
          "old_line_content": "                   context->allocate_output(1, {num_unique}, &unique_indices));",
          "new_line_content": "    Tensor* unique_indices = nullptr;",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": "ReduceImpl<Tin, Tindex, float>(input_flat, indices_vec, start, num,\n                                       temp, get_scaling_factor<float>(num))",
          "new_api": null,
          "old_text": "ReduceImpl<Tin, Tindex, float>(input_flat, indices_vec, start, num,\n                                       temp, get_scaling_factor<float>(num))",
          "new_text": null,
          "old_line_content": "        ReduceImpl<Tin, Tindex, float>(input_flat, indices_vec, start, num,",
          "new_line_content": "      Eigen::TensorChippingOp<0, typename TTypes<float>::Matrix> temp) {",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": "get_scaling_factor<float>(num)",
          "new_api": null,
          "old_text": "get_scaling_factor<float>(num)",
          "new_text": null,
          "old_line_content": "                                       temp, get_scaling_factor<float>(num));",
          "new_line_content": "    int64_t res =",
          "content_same": false
        },
        {
          "line": 1265,
          "old_api": "SetDimWithStatus",
          "new_api": null,
          "old_text": "output_shape.SetDimWithStatus(0, num_unique)",
          "new_text": null,
          "old_line_content": "    OP_REQUIRES_OK(context, output_shape.SetDimWithStatus(0, num_unique));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1271,
          "old_api": "size",
          "new_api": null,
          "old_text": "unique_index_ids.size()",
          "new_text": null,
          "old_line_content": "        unique_index_ids.data(), unique_index_ids.size());",
          "new_line_content": "    // Call the V1 implementation with the unique/permuted indices/segments.",
          "content_same": false
        },
        {
          "line": 1274,
          "old_api": "SparseSegmentGradFunctor<CPUDevice, T, Index, SegmentId>()(\n        context, operation, input_flat, unique_index_ids_vec,\n        permuted_segment_vec, output)",
          "new_api": null,
          "old_text": "SparseSegmentGradFunctor<CPUDevice, T, Index, SegmentId>()(\n        context, operation, input_flat, unique_index_ids_vec,\n        permuted_segment_vec, output)",
          "new_text": null,
          "old_line_content": "    SparseSegmentGradFunctor<CPUDevice, T, Index, SegmentId>()(",
          "new_line_content": "    typename TTypes<SegmentId>::ConstVec permuted_segment_vec(",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(0, 0)",
          "new_text": null,
          "old_line_content": "      INDEX(0, 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": "L",
          "new_api": null,
          "old_text": "L(0)",
          "new_text": null,
          "old_line_content": "      out = L(0);",
          "new_line_content": "    if (num == 1) {",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(0, 0)",
          "new_text": null,
          "old_line_content": "          INDEX(0, 0);",
          "new_line_content": "      switch (r) {",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(1, 1)",
          "new_text": null,
          "old_line_content": "          INDEX(1, 1);",
          "new_line_content": "        case 2: {",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(0, 0)",
          "new_text": null,
          "old_line_content": "          INDEX(0, 0);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(1, 1)",
          "new_text": null,
          "old_line_content": "          INDEX(1, 1);",
          "new_line_content": "        case 3: {",
          "content_same": false
        },
        {
          "line": 1293,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit SparseSegmentGradOpBase(OpKernelConstruction* context,",
          "new_line_content": "class SparseSegmentGradOpBase : public OpKernel {",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": "input",
          "new_api": null,
          "old_text": "context->input(0)",
          "new_text": null,
          "old_line_content": "    const Tensor& input = context->input(0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1299,
          "old_api": "input",
          "new_api": null,
          "old_text": "context->input(1)",
          "new_text": null,
          "old_line_content": "    const Tensor& indices = context->input(1);",
          "new_line_content": "  void Compute(OpKernelContext* context) override {",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(0, 0)",
          "new_text": null,
          "old_line_content": "          INDEX(0, 0);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(1, 1)",
          "new_text": null,
          "old_line_content": "          INDEX(1, 1);",
          "new_line_content": "        case 4: {",
          "content_same": false
        },
        {
          "line": 1304,
          "old_api": "errors::InvalidArgument(\"indices should be a vector.\")",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\"indices should be a vector.\")",
          "new_text": null,
          "old_line_content": "                errors::InvalidArgument(\"indices should be a vector.\"));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(0, 0)",
          "new_text": null,
          "old_line_content": "          INDEX(0, 0);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(1, 1)",
          "new_text": null,
          "old_line_content": "          INDEX(1, 1);",
          "new_line_content": "        case 5: {",
          "content_same": false
        },
        {
          "line": 1311,
          "old_api": "NumElements",
          "new_api": null,
          "old_text": "segment_ids.NumElements()",
          "new_text": null,
          "old_line_content": "    OP_REQUIRES(context, N == segment_ids.NumElements(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(0, 0)",
          "new_text": null,
          "old_line_content": "          INDEX(0, 0);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(1, 1)",
          "new_text": null,
          "old_line_content": "          INDEX(1, 1);",
          "new_line_content": "        case 6: {",
          "content_same": false
        },
        {
          "line": 1317,
          "old_api": "indices.vec<Index>()",
          "new_api": null,
          "old_text": "indices.vec<Index>()",
          "new_text": null,
          "old_line_content": "    const auto indices_vec = indices.vec<Index>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1321,
          "old_api": "SetDimWithStatus",
          "new_api": null,
          "old_text": "output_shape.SetDimWithStatus(0, M)",
          "new_text": null,
          "old_line_content": "    OP_REQUIRES_OK(context, output_shape.SetDimWithStatus(0, M));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1326,
          "old_api": "functor::SparseSegmentGradFunctor<Device, T, Index, SegmentId>()(\n        context, operation_, input_flat, indices_vec, segment_vec, output)",
          "new_api": null,
          "old_text": "functor::SparseSegmentGradFunctor<Device, T, Index, SegmentId>()(\n        context, operation_, input_flat, indices_vec, segment_vec, output)",
          "new_text": null,
          "old_line_content": "    functor::SparseSegmentGradFunctor<Device, T, Index, SegmentId>()(",
          "new_line_content": "    if (M == 0 || N == 0) return;",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(0, 0)",
          "new_text": null,
          "old_line_content": "          INDEX(0, 0);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(1, 1)",
          "new_text": null,
          "old_line_content": "          INDEX(1, 1);",
          "new_line_content": "        case 7: {",
          "content_same": false
        },
        {
          "line": 1338,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit SparseSegmentSumGradOp(OpKernelConstruction* context)",
          "new_line_content": "    : public SparseSegmentGradOpBase<Device, T, Index, SegmentId> {",
          "content_same": false
        },
        {
          "line": 827,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(0, 0)",
          "new_text": null,
          "old_line_content": "          INDEX(0, 0);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 828,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(1, 1)",
          "new_text": null,
          "old_line_content": "          INDEX(1, 1);",
          "new_line_content": "        case 0: {",
          "content_same": false
        },
        {
          "line": 1347,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit SparseSegmentMeanGradOp(OpKernelConstruction* context)",
          "new_line_content": "    : public SparseSegmentGradOpBase<Device, T, Index, SegmentId> {",
          "content_same": false
        },
        {
          "line": 841,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(0, 0)",
          "new_text": null,
          "old_line_content": "          INDEX(0, 0);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(1, 1)",
          "new_text": null,
          "old_line_content": "          INDEX(1, 1);",
          "new_line_content": "        case 1: {",
          "content_same": false
        },
        {
          "line": 1356,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit SparseSegmentSqrtNGradOp(OpKernelConstruction* context)",
          "new_line_content": "    : public SparseSegmentGradOpBase<Device, T, Index, SegmentId> {",
          "content_same": false
        },
        {
          "line": 1367,
          "old_api": "input",
          "new_api": null,
          "old_text": "context->input(0)",
          "new_text": null,
          "old_line_content": "    const Tensor& input = context->input(0);",
          "new_line_content": "                    SparseSegmentReductionOperation operation,",
          "content_same": false
        },
        {
          "line": 1368,
          "old_api": "input",
          "new_api": null,
          "old_text": "context->input(1)",
          "new_text": null,
          "old_line_content": "    const Tensor& indices = context->input(1);",
          "new_line_content": "                    typename AsyncOpKernel::DoneCallback done = nullptr) {",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(0, r)",
          "new_text": null,
          "old_line_content": "        INDEX(0, r);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": "INDEX",
          "new_api": null,
          "old_text": "INDEX(1, r + 1)",
          "new_text": null,
          "old_line_content": "        INDEX(1, r + 1);",
          "new_line_content": "      for (; r < num; r += 8) {",
          "content_same": false
        },
        {
          "line": 1373,
          "old_api": "errors::InvalidArgument(\"indices should be a vector.\")",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\"indices should be a vector.\")",
          "new_text": null,
          "old_line_content": "      return errors::InvalidArgument(\"indices should be a vector.\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1376,
          "old_api": "errors::InvalidArgument(\"segment_ids should be a vector.\")",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\"segment_ids should be a vector.\")",
          "new_text": null,
          "old_line_content": "      return errors::InvalidArgument(\"segment_ids should be a vector.\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1379,
          "old_api": "errors::InvalidArgument(\"dense_output_dim0 should be a scalar.\")",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\"dense_output_dim0 should be a scalar.\")",
          "new_text": null,
          "old_line_content": "      return errors::InvalidArgument(\"dense_output_dim0 should be a scalar.\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": "static_cast<Tout>(num)",
          "new_api": null,
          "old_text": "static_cast<Tout>(num)",
          "new_text": null,
          "old_line_content": "        out = out / static_cast<Tout>(num);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1382,
          "old_api": "NumElements",
          "new_api": null,
          "old_text": "indices.NumElements()",
          "new_text": null,
          "old_line_content": "    const int64_t N = indices.NumElements();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": "sqrt",
          "new_api": null,
          "old_text": "sqrt(num)",
          "new_text": null,
          "old_line_content": "        out = out / static_cast<Tout>(sqrt(num));",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1383,
          "old_api": "NumElements",
          "new_api": null,
          "old_text": "segment_ids.NumElements()",
          "new_text": null,
          "old_line_content": "    if (N != segment_ids.NumElements()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1388,
          "old_api": "dense_output_dim0.scalar<int32_t>()()",
          "new_api": null,
          "old_text": "dense_output_dim0.scalar<int32_t>()()",
          "new_text": null,
          "old_line_content": "        internal::SubtleMustCopy(dense_output_dim0.scalar<int32_t>()());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1389,
          "old_api": "shape",
          "new_api": null,
          "old_text": "input.shape()",
          "new_text": null,
          "old_line_content": "    TensorShape dense_output_shape = input.shape();",
          "new_line_content": "    const int32_t M =",
          "content_same": false
        },
        {
          "line": 1393,
          "old_api": "shape",
          "new_api": null,
          "old_text": "input.shape()",
          "new_text": null,
          "old_line_content": "      TensorShape output_shape = input.shape();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1394,
          "old_api": "SetDimWithStatus",
          "new_api": null,
          "old_text": "output_shape.SetDimWithStatus(0, 0)",
          "new_text": null,
          "old_line_content": "      TF_RETURN_IF_ERROR(output_shape.SetDimWithStatus(0, 0));",
          "new_line_content": "    if (M == 0 || N == 0) {",
          "content_same": false
        },
        {
          "line": 1403,
          "old_api": "input.flat_outer_dims<T>()",
          "new_api": null,
          "old_text": "input.flat_outer_dims<T>()",
          "new_text": null,
          "old_line_content": "    auto input_flat = input.flat_outer_dims<T>();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1404,
          "old_api": "indices.vec<Index>()",
          "new_api": null,
          "old_text": "indices.vec<Index>()",
          "new_text": null,
          "old_line_content": "    const auto indices_vec = indices.vec<Index>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 894,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit SparseSegmentReductionOpBase(OpKernelConstruction* context,",
          "new_line_content": "    : public AsyncOpKernel {",
          "content_same": false
        },
        {
          "line": 1411,
          "old_api": "absl::OkStatus()",
          "new_api": null,
          "old_text": "absl::OkStatus()",
          "new_text": null,
          "old_line_content": "    return absl::OkStatus();",
          "new_line_content": "        dense_output_shape, done);",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": "input",
          "new_api": null,
          "old_text": "context->input(0)",
          "new_text": null,
          "old_line_content": "    const Tensor& input = context->input(0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": "input",
          "new_api": null,
          "old_text": "context->input(1)",
          "new_text": null,
          "old_line_content": "    const Tensor& indices = context->input(1);",
          "new_line_content": "  void ComputeAsync(OpKernelContext* context, DoneCallback done) override {",
          "content_same": false
        },
        {
          "line": 1423,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit SparseSegmentGradV2OpBase(OpKernelConstruction* context,",
          "new_line_content": "    : public OpKernel {",
          "content_same": false
        },
        {
          "line": 1428,
          "old_api": "OP_REQUIRES_OK",
          "new_api": null,
          "old_text": "OP_REQUIRES_OK(\n        context, (SparseSegmentGradV2OpCommon<CPUDevice, T, Index, SegmentId>()(\n                     context, operation_)))",
          "new_text": null,
          "old_line_content": "    OP_REQUIRES_OK(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1429,
          "old_api": "SparseSegmentGradV2OpCommon<CPUDevice, T, Index, SegmentId>()(\n                     context, operation_)",
          "new_api": null,
          "old_text": "SparseSegmentGradV2OpCommon<CPUDevice, T, Index, SegmentId>()(\n                     context, operation_)",
          "new_text": null,
          "old_line_content": "        context, (SparseSegmentGradV2OpCommon<CPUDevice, T, Index, SegmentId>()(",
          "new_line_content": "  void Compute(OpKernelContext* context) override {",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": "op_device_context",
          "new_api": null,
          "old_text": "context->op_device_context()->stream()",
          "new_text": null,
          "old_line_content": "      auto stream = context->op_device_context()->stream();",
          "new_line_content": "      // Ensure that within the callback, the proper GPU settings are",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": "parent",
          "new_api": null,
          "old_text": "stream->parent()",
          "new_text": null,
          "old_line_content": "      ScopedActivateExecutorContext scoped_activation{stream->parent()};",
          "new_line_content": "      // configured.",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": "errors::InvalidArgument(\"segment ids must be >= 0\")",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\"segment ids must be >= 0\")",
          "new_text": null,
          "old_line_content": "                        errors::InvalidArgument(\"segment ids must be >= 0\"),",
          "new_line_content": "      SegmentId output_rows = last_segment_id + 1;",
          "content_same": false
        },
        {
          "line": 929,
          "old_api": "shape",
          "new_api": null,
          "old_text": "input.shape()",
          "new_text": null,
          "old_line_content": "      TensorShape output_shape = input.shape();",
          "new_line_content": "                        done);",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": "set_dim",
          "new_api": null,
          "old_text": "output_shape.set_dim(0, output_rows)",
          "new_text": null,
          "old_line_content": "      output_shape.set_dim(0, output_rows);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1442,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit SparseSegmentGradV2OpBase(OpKernelConstruction* context,",
          "new_line_content": "    : public AsyncOpKernel {",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": "allocate_output",
          "new_api": null,
          "old_text": "OP_REQUIRES_OK_ASYNC(\n          context, context->allocate_output(0, output_shape, &output), done)",
          "new_text": null,
          "old_line_content": "      OP_REQUIRES_OK_ASYNC(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "allocate_output",
          "new_api": null,
          "old_text": "context->allocate_output(0, output_shape, &output)",
          "new_text": null,
          "old_line_content": "          context, context->allocate_output(0, output_shape, &output), done);",
          "new_line_content": "      Tensor* output = nullptr;",
          "content_same": false
        },
        {
          "line": 1447,
          "old_api": "OP_REQUIRES_OK_ASYNC",
          "new_api": null,
          "old_text": "OP_REQUIRES_OK_ASYNC(\n        context,\n        (SparseSegmentGradV2OpCommon<GPUDevice, T, Index, SegmentId>()(\n            context, operation_, done)),\n        done)",
          "new_text": null,
          "old_line_content": "    OP_REQUIRES_OK_ASYNC(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": "indices.vec<Index>()",
          "new_api": null,
          "old_text": "indices.vec<Index>()",
          "new_text": null,
          "old_line_content": "      const auto indices_vec = indices.vec<Index>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": "OP_REQUIRES_OK_ASYNC",
          "new_api": null,
          "old_text": "OP_REQUIRES_OK_ASYNC(\n          context,\n          functor(context, is_mean_, is_sqrtn_, default_value_, input_flat,\n                  indices_vec, segment_ids_vec, output_flat),\n          done)",
          "new_text": null,
          "old_line_content": "      OP_REQUIRES_OK_ASYNC(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": "done",
          "new_api": null,
          "old_text": "done()",
          "new_text": null,
          "old_line_content": "      done();",
          "new_line_content": "                  indices_vec, segment_ids_vec, output_flat),",
          "content_same": false
        },
        {
          "line": 1462,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit SparseSegmentSumGradV2Op(OpKernelConstruction* context)",
          "new_line_content": "    : public SparseSegmentGradV2OpBase<Device, T, Index, SegmentId> {",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": "input",
          "new_api": null,
          "old_text": "context->input(3)",
          "new_text": null,
          "old_line_content": "      const Tensor& num_segments_t = context->input(3);",
          "new_line_content": "    if (has_num_segments_) {",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": "num_segments_t.scalar<int32>()()",
          "new_api": null,
          "old_text": "num_segments_t.scalar<int32>()()",
          "new_text": null,
          "old_line_content": "                                       ? num_segments_t.scalar<int32>()()",
          "new_line_content": "      SegmentId num_segments =",
          "content_same": false
        },
        {
          "line": 1471,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit SparseSegmentMeanGradV2Op(OpKernelConstruction* context)",
          "new_line_content": "    : public SparseSegmentGradV2OpBase<Device, T, Index, SegmentId> {",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": "set_dim",
          "new_api": null,
          "old_text": "output_shape.set_dim(0, 0)",
          "new_text": null,
          "old_line_content": "        output_shape.set_dim(0, 0);",
          "new_line_content": "      if (num_indices == 0) {",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": "allocate_output",
          "new_api": null,
          "old_text": "OP_REQUIRES_OK_ASYNC(\n            context, context->allocate_output(0, output_shape, &output), done)",
          "new_text": null,
          "old_line_content": "        OP_REQUIRES_OK_ASYNC(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": "allocate_output",
          "new_api": null,
          "old_text": "context->allocate_output(0, output_shape, &output)",
          "new_text": null,
          "old_line_content": "            context, context->allocate_output(0, output_shape, &output), done);",
          "new_line_content": "        Tensor* output = nullptr;",
          "content_same": false
        },
        {
          "line": 1480,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit SparseSegmentSqrtNGradV2Op(OpKernelConstruction* context)",
          "new_line_content": "    : public SparseSegmentGradV2OpBase<Device, T, Index, SegmentId> {",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": "data",
          "new_api": null,
          "old_text": "const_cast<Tensor&>(segment_ids).template flat<SegmentId>().data()",
          "new_text": null,
          "old_line_content": "          const_cast<Tensor&>(segment_ids).template flat<SegmentId>().data() +",
          "new_line_content": "      // asynchronously allocate the output and finish the computation.",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "mutable_data",
          "new_api": null,
          "old_text": "OP_REQUIRES_OK_ASYNC(\n          context,\n          stream->Memcpy(last_segment_id_host.mutable_data(),\n                         last_segment_id_device, sizeof(SegmentId)),\n          done)",
          "new_text": null,
          "old_line_content": "      OP_REQUIRES_OK_ASYNC(",
          "new_line_content": "          (num_indices - 1));",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": "device",
          "new_api": null,
          "old_text": "context->device()\n          ->tensorflow_accelerator_device_info()\n          ->event_mgr->ThenExecute(stream, create_and_check_output)",
          "new_text": null,
          "old_line_content": "      context->device()",
          "new_line_content": "                         last_segment_id_device, sizeof(SegmentId)),",
          "content_same": false
        },
        {
          "line": 1002,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit SparseSegmentReductionMeanOp(OpKernelConstruction* context)",
          "new_line_content": "    : public SparseSegmentReductionOpBase<Device, T, Index, SegmentId> {",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": "T",
          "new_api": null,
          "old_text": "T(0)",
          "new_text": null,
          "old_line_content": "            false /* has_num_segments */, T(0) /* default_value */) {}",
          "new_line_content": "      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit SparseSegmentReductionMeanWithNumSegmentsOp(",
          "new_line_content": "    : public SparseSegmentReductionOpBase<Device, T, Index, SegmentId> {",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": "T",
          "new_api": null,
          "old_text": "T(0)",
          "new_text": null,
          "old_line_content": "            true /* has_num_segments */, T(0) /* default_value */) {}",
          "new_line_content": "      : SparseSegmentReductionOpBase<Device, T, Index, SegmentId>(",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit SparseSegmentReductionSqrtNOp(OpKernelConstruction* context)",
          "new_line_content": "    : public SparseSegmentReductionOpBase<Device, T, Index, SegmentId> {",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 80,
      "total_additions": 157,
      "total_deletions": 156,
      "total_api_changes": 393
    },
    "non_api_changes": {
      "has_non_api_changes": false,
      "evidence": {
        "total_diff_lines": 5,
        "api_related_lines": 393,
        "non_api_lines": 0,
        "non_api_line_numbers": []
      }
    },
    "api_calls_before": 588,
    "api_calls_after": 590,
    "diff_info": {
      "added_lines": 4,
      "removed_lines": 2,
      "total_diff_lines": 25
    }
  }
}