{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/af94e801cf90fe8fb70d930d8658c20913d09ca5",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/af94e801cf90fe8fb70d930d8658c20913d09ca5/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/af94e801cf90fe8fb70d930d8658c20913d09ca5/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/af94e801cf90fe8fb70d930d8658c20913d09ca5/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 510,
          "old_api": "pm.addNestedPass<::mlir::FuncOp>(\n        ::mlir::xla::createLegalizeTanhToApproximationPass())",
          "new_api": "empty",
          "old_text": "pm.addNestedPass<::mlir::FuncOp>(\n        ::mlir::xla::createLegalizeTanhToApproximationPass())",
          "new_text": "options.unroll_factors.empty()",
          "old_line_content": "    pm.addNestedPass<::mlir::FuncOp>(",
          "new_line_content": "  if (!options.unroll_factors.empty()) {",
          "content_same": false
        },
        {
          "line": 511,
          "old_api": "::mlir::xla::createLegalizeTanhToApproximationPass()",
          "new_api": "mlir::createForLoopSpecializationPass()",
          "old_text": "::mlir::xla::createLegalizeTanhToApproximationPass()",
          "new_text": "mlir::createForLoopSpecializationPass()",
          "old_line_content": "        ::mlir::xla::createLegalizeTanhToApproximationPass());",
          "new_line_content": "    pm.addNestedPass<::mlir::FuncOp>(mlir::createForLoopSpecializationPass());",
          "content_same": false
        },
        {
          "line": 516,
          "old_api": "::mlir::createGpuKernelOutliningPass()",
          "new_api": "::mlir::xla::createLegalizeTanhToApproximationPass()",
          "old_text": "::mlir::createGpuKernelOutliningPass()",
          "new_text": "::mlir::xla::createLegalizeTanhToApproximationPass()",
          "old_line_content": "  pm.addPass(::mlir::createGpuKernelOutliningPass());",
          "new_line_content": "        ::mlir::xla::createLegalizeTanhToApproximationPass());",
          "content_same": false
        },
        {
          "line": 525,
          "old_api": "Status::OK()",
          "new_api": "absl::make_unique<RewriteKernelSignature>()",
          "old_text": "Status::OK()",
          "new_text": "absl::make_unique<RewriteKernelSignature>()",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "    pm.addPass(absl::make_unique<RewriteKernelSignature>());",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": "::mlir::populateGpuToNVVMConversionPatterns(converter, patterns)",
          "new_api": "getContext",
          "old_text": "::mlir::populateGpuToNVVMConversionPatterns(converter, patterns)",
          "new_text": "m.getContext()",
          "old_line_content": "    ::mlir::populateGpuToNVVMConversionPatterns(converter, patterns);",
          "new_line_content": "    ::mlir::LLVMTypeConverter converter(m.getContext());",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": "getContext",
          "new_api": "::mlir::populateStdToLLVMConversionPatterns(converter, patterns)",
          "old_text": "m.getContext()",
          "new_text": "::mlir::populateStdToLLVMConversionPatterns(converter, patterns)",
          "old_line_content": "    ::mlir::populateAffineToStdConversionPatterns(patterns, m.getContext());",
          "new_line_content": "    ::mlir::populateStdToLLVMConversionPatterns(converter, patterns);",
          "content_same": false
        },
        {
          "line": 548,
          "old_api": "target.addIllegalDialect<::mlir::gpu::GPUDialect>()",
          "new_api": "::mlir::populateLinalgToLLVMConversionPatterns(converter, patterns,\n                                                   &getContext())",
          "old_text": "target.addIllegalDialect<::mlir::gpu::GPUDialect>()",
          "new_text": "::mlir::populateLinalgToLLVMConversionPatterns(converter, patterns,\n                                                   &getContext())",
          "old_line_content": "    target.addIllegalDialect<::mlir::gpu::GPUDialect>();",
          "new_line_content": "    ::mlir::populateLinalgToLLVMConversionPatterns(converter, patterns,",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": "target.addIllegalOp<::mlir::LLVM::ExpOp>()",
          "new_api": "getContext",
          "old_text": "target.addIllegalOp<::mlir::LLVM::ExpOp>()",
          "new_text": "getContext()",
          "old_line_content": "    target.addIllegalOp<::mlir::LLVM::ExpOp>();",
          "new_line_content": "                                                   &getContext());",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": "target.addLegalDialect<::mlir::LLVM::LLVMDialect>()",
          "new_api": "::mlir::populateGpuToNVVMConversionPatterns(converter, patterns)",
          "old_text": "target.addLegalDialect<::mlir::LLVM::LLVMDialect>()",
          "new_text": "::mlir::populateGpuToNVVMConversionPatterns(converter, patterns)",
          "old_line_content": "    target.addLegalDialect<::mlir::LLVM::LLVMDialect>();",
          "new_line_content": "    ::mlir::populateGpuToNVVMConversionPatterns(converter, patterns);",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": "target.addLegalDialect<::mlir::NVVM::NVVMDialect>()",
          "new_api": "getContext",
          "old_text": "target.addLegalDialect<::mlir::NVVM::NVVMDialect>()",
          "new_text": "m.getContext()",
          "old_line_content": "    target.addLegalDialect<::mlir::NVVM::NVVMDialect>();",
          "new_line_content": "    ::mlir::populateAffineToStdConversionPatterns(patterns, m.getContext());",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": "target.addLegalOp<::mlir::gpu::GPUModuleOp, ::mlir::gpu::ModuleEndOp,\n                      ::mlir::gpu::YieldOp>()",
          "new_api": "target.addIllegalDialect<::mlir::gpu::GPUDialect>()",
          "old_text": "target.addLegalOp<::mlir::gpu::GPUModuleOp, ::mlir::gpu::ModuleEndOp,\n                      ::mlir::gpu::YieldOp>()",
          "new_text": "target.addIllegalDialect<::mlir::gpu::GPUDialect>()",
          "old_line_content": "    target.addLegalOp<::mlir::gpu::GPUModuleOp, ::mlir::gpu::ModuleEndOp,",
          "new_line_content": "    target.addIllegalDialect<::mlir::gpu::GPUDialect>();",
          "content_same": false
        },
        {
          "line": 555,
          "old_api": "mlir::applyFullConversion(m, target, patterns)",
          "new_api": "target.addLegalDialect<::mlir::LLVM::LLVMDialect>()",
          "old_text": "mlir::applyFullConversion(m, target, patterns)",
          "new_text": "target.addLegalDialect<::mlir::LLVM::LLVMDialect>()",
          "old_line_content": "    if (failed(mlir::applyFullConversion(m, target, patterns))) {",
          "new_line_content": "    target.addLegalDialect<::mlir::LLVM::LLVMDialect>();",
          "content_same": false
        },
        {
          "line": 556,
          "old_api": "signalPassFailure",
          "new_api": "target.addLegalDialect<::mlir::NVVM::NVVMDialect>()",
          "old_text": "signalPassFailure()",
          "new_text": "target.addLegalDialect<::mlir::NVVM::NVVMDialect>()",
          "old_line_content": "      signalPassFailure();",
          "new_line_content": "    target.addLegalDialect<::mlir::NVVM::NVVMDialect>();",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": "::mlir::createLowerToCFGPass()",
          "new_api": "getContext",
          "old_text": "::mlir::createLowerToCFGPass()",
          "new_text": "module.getContext()",
          "old_line_content": "  kernelPm.addPass(::mlir::createLowerToCFGPass());",
          "new_line_content": "  ::mlir::PassManager pm(module.getContext(), /*verifyPasses=*/false);",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": "absl::make_unique<LowerToNVVMPass>()",
          "new_api": "applyPassManagerCLOptions",
          "old_text": "absl::make_unique<LowerToNVVMPass>()",
          "new_text": "applyPassManagerCLOptions(pm)",
          "old_line_content": "  kernelPm.addPass(absl::make_unique<LowerToNVVMPass>());",
          "new_line_content": "  applyPassManagerCLOptions(pm);",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": "::mlir::createCSEPass()",
          "new_api": "pm.nest<::mlir::gpu::GPUModuleOp>()",
          "old_text": "::mlir::createCSEPass()",
          "new_text": "pm.nest<::mlir::gpu::GPUModuleOp>()",
          "old_line_content": "  kernelPm.addNestedPass<::mlir::FuncOp>(::mlir::createCSEPass());",
          "new_line_content": "  auto& kernelPm = pm.nest<::mlir::gpu::GPUModuleOp>();",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": "::mlir::createStripDebugInfoPass()",
          "new_api": "::mlir::createLowerToCFGPass()",
          "old_text": "::mlir::createStripDebugInfoPass()",
          "new_text": "::mlir::createLowerToCFGPass()",
          "old_line_content": "  kernelPm.addPass(::mlir::createStripDebugInfoPass());",
          "new_line_content": "  kernelPm.addPass(::mlir::createLowerToCFGPass());",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": "InternalError",
          "new_api": "::mlir::createCanonicalizerPass()",
          "old_text": "InternalError(\"Lowering to NVVM IR failed.\")",
          "new_text": "::mlir::createCanonicalizerPass()",
          "old_line_content": "    return InternalError(\"Lowering to NVVM IR failed.\");",
          "new_line_content": "  kernelPm.addNestedPass<::mlir::FuncOp>(::mlir::createCanonicalizerPass());",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": "Status::OK()",
          "new_api": "::mlir::createStripDebugInfoPass()",
          "old_text": "Status::OK()",
          "new_text": "::mlir::createStripDebugInfoPass()",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  kernelPm.addPass(::mlir::createStripDebugInfoPass());",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 515,
          "old_api": null,
          "new_api": "pm.addNestedPass<::mlir::FuncOp>(\n        ::mlir::xla::createLegalizeTanhToApproximationPass())",
          "old_text": null,
          "new_text": "pm.addNestedPass<::mlir::FuncOp>(\n        ::mlir::xla::createLegalizeTanhToApproximationPass())",
          "old_line_content": "  // Take launches to launches with kernels.",
          "new_line_content": "    pm.addNestedPass<::mlir::FuncOp>(",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": null,
          "new_api": "absl::make_unique<MoveScalarComputationsIntoGpuLaunch>()",
          "old_text": null,
          "new_text": "absl::make_unique<MoveScalarComputationsIntoGpuLaunch>()",
          "old_line_content": "  if (options.rewrite_signature) {",
          "new_line_content": "  pm.addPass(absl::make_unique<MoveScalarComputationsIntoGpuLaunch>());",
          "content_same": false
        },
        {
          "line": 521,
          "old_api": null,
          "new_api": "::mlir::createGpuKernelOutliningPass()",
          "old_text": null,
          "new_text": "::mlir::createGpuKernelOutliningPass()",
          "old_line_content": "  }",
          "new_line_content": "  pm.addPass(::mlir::createGpuKernelOutliningPass());",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": null,
          "new_api": "run",
          "old_text": null,
          "new_text": "pm.run(module)",
          "old_line_content": "",
          "new_line_content": "  if (failed(pm.run(module))) {",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": null,
          "new_api": "InternalError",
          "old_text": null,
          "new_text": "InternalError(\"Lowering to GPU kernels failed.\")",
          "old_line_content": "namespace {",
          "new_line_content": "    return InternalError(\"Lowering to GPU kernels failed.\");",
          "content_same": false
        },
        {
          "line": 530,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "/// A pass that does the final lowering to NVVM. It collects all the patterns",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 542,
          "old_api": null,
          "new_api": "getOperation",
          "old_text": null,
          "new_text": "getOperation()",
          "old_line_content": "    // TODO(b/145824979) Remove linalg once sliceop is in std.",
          "new_line_content": "    ::mlir::gpu::GPUModuleOp m = getOperation();",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": null,
          "new_api": "target.addIllegalOp<::mlir::LLVM::ExpOp>()",
          "old_text": null,
          "new_text": "target.addIllegalOp<::mlir::LLVM::ExpOp>()",
          "old_line_content": "                      ::mlir::gpu::YieldOp>();",
          "new_line_content": "    target.addIllegalOp<::mlir::LLVM::ExpOp>();",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": null,
          "new_api": "target.addLegalOp<::mlir::gpu::GPUModuleOp, ::mlir::gpu::ModuleEndOp,\n                      ::mlir::gpu::YieldOp>()",
          "old_text": null,
          "new_text": "target.addLegalOp<::mlir::gpu::GPUModuleOp, ::mlir::gpu::ModuleEndOp,\n                      ::mlir::gpu::YieldOp>()",
          "old_line_content": "  }",
          "new_line_content": "    target.addLegalOp<::mlir::gpu::GPUModuleOp, ::mlir::gpu::ModuleEndOp,",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": null,
          "new_api": "mlir::applyFullConversion(m, target, patterns)",
          "old_text": null,
          "new_text": "mlir::applyFullConversion(m, target, patterns)",
          "old_line_content": "",
          "new_line_content": "    if (failed(mlir::applyFullConversion(m, target, patterns))) {",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": null,
          "new_api": "signalPassFailure",
          "old_text": null,
          "new_text": "signalPassFailure()",
          "old_line_content": "}  // namespace",
          "new_line_content": "      signalPassFailure();",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": null,
          "new_api": "absl::make_unique<LowerToNVVMPass>()",
          "old_text": null,
          "new_text": "absl::make_unique<LowerToNVVMPass>()",
          "old_line_content": "",
          "new_line_content": "  kernelPm.addPass(absl::make_unique<LowerToNVVMPass>());",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": null,
          "new_api": "::mlir::createCSEPass()",
          "old_text": null,
          "new_text": "::mlir::createCSEPass()",
          "old_line_content": "  }",
          "new_line_content": "  kernelPm.addNestedPass<::mlir::FuncOp>(::mlir::createCSEPass());",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": null,
          "new_api": "run",
          "old_text": null,
          "new_text": "pm.run(module)",
          "old_line_content": "",
          "new_line_content": "  if (failed(pm.run(module))) {",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": null,
          "new_api": "InternalError",
          "old_text": null,
          "new_text": "InternalError(\"Lowering to NVVM IR failed.\")",
          "old_line_content": "StatusOr<mlir::ModuleOp> ExtractKernelModule(mlir::ModuleOp module) {",
          "new_line_content": "    return InternalError(\"Lowering to NVVM IR failed.\");",
          "content_same": false
        },
        {
          "line": 585,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "  // TODO(b/137624192): This also needs to resolve naming conflicts.",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": null,
          "new_api": "getLoc",
          "old_text": null,
          "new_text": "module.getLoc()",
          "old_line_content": "    }",
          "new_line_content": "  auto kernelModule = ::mlir::ModuleOp::create(module.getLoc());",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": null,
          "new_api": "walk",
          "old_text": null,
          "new_text": "module.walk([&kernelModule](mlir::gpu::GPUModuleOp nestedModule) {\n    for (auto& fn : nestedModule.body().front()) {\n      kernelModule.push_back(fn.clone());\n    }\n  })",
          "old_line_content": "  return kernelModule;",
          "new_line_content": "  module.walk([&kernelModule](mlir::gpu::GPUModuleOp nestedModule) {",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": null,
          "new_api": "body",
          "old_text": null,
          "new_text": "nestedModule.body().front()",
          "old_line_content": "}",
          "new_line_content": "    for (auto& fn : nestedModule.body().front()) {",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": null,
          "new_api": "clone",
          "old_text": null,
          "new_text": "fn.clone()",
          "old_line_content": "}  // namespace mlir_gpu",
          "new_line_content": "      kernelModule.push_back(fn.clone());",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 544,
          "old_api": "getContext",
          "new_api": null,
          "old_text": "getContext()",
          "new_text": null,
          "old_line_content": "                                                   &getContext());",
          "new_line_content": "    ::mlir::OwningRewritePatternList patterns;",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": "run",
          "new_api": null,
          "old_text": "pm.run(module)",
          "new_text": null,
          "old_line_content": "  if (failed(pm.run(module))) {",
          "new_line_content": "  // Some basic cleanup.",
          "content_same": false
        },
        {
          "line": 514,
          "old_api": "absl::make_unique<MoveScalarComputationsIntoGpuLaunch>()",
          "new_api": null,
          "old_text": "absl::make_unique<MoveScalarComputationsIntoGpuLaunch>()",
          "new_text": null,
          "old_line_content": "  pm.addPass(absl::make_unique<MoveScalarComputationsIntoGpuLaunch>());",
          "new_line_content": "  if (options.use_approximations) {",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": "::mlir::createCanonicalizerPass()",
          "new_api": null,
          "old_text": "::mlir::createCanonicalizerPass()",
          "new_text": null,
          "old_line_content": "  kernelPm.addNestedPass<::mlir::FuncOp>(::mlir::createCanonicalizerPass());",
          "new_line_content": "  // Rewrite kernel functions to LLVM IR.",
          "content_same": false
        },
        {
          "line": 520,
          "old_api": "absl::make_unique<RewriteKernelSignature>()",
          "new_api": null,
          "old_text": "absl::make_unique<RewriteKernelSignature>()",
          "new_text": null,
          "old_line_content": "    pm.addPass(absl::make_unique<RewriteKernelSignature>());",
          "new_line_content": "  // Take launches to launches with kernels.",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": "getLoc",
          "new_api": null,
          "old_text": "module.getLoc()",
          "new_text": null,
          "old_line_content": "  auto kernelModule = ::mlir::ModuleOp::create(module.getLoc());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 522,
          "old_api": "run",
          "new_api": null,
          "old_text": "pm.run(module)",
          "new_text": null,
          "old_line_content": "  if (failed(pm.run(module))) {",
          "new_line_content": "  // Make sure the kernel signature resembled the original function's",
          "content_same": false
        },
        {
          "line": 523,
          "old_api": "InternalError",
          "new_api": null,
          "old_text": "InternalError(\"Lowering to GPU kernels failed.\")",
          "new_text": null,
          "old_line_content": "    return InternalError(\"Lowering to GPU kernels failed.\");",
          "new_line_content": "  // signature",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": "walk",
          "new_api": null,
          "old_text": "module.walk([&kernelModule](mlir::gpu::GPUModuleOp nestedModule) {\n    for (auto& fn : nestedModule.body().front()) {\n      kernelModule.push_back(fn.clone());\n    }\n  })",
          "new_text": null,
          "old_line_content": "  module.walk([&kernelModule](mlir::gpu::GPUModuleOp nestedModule) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": "body",
          "new_api": null,
          "old_text": "nestedModule.body().front()",
          "new_text": null,
          "old_line_content": "    for (auto& fn : nestedModule.body().front()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": "clone",
          "new_api": null,
          "old_text": "fn.clone()",
          "new_text": null,
          "old_line_content": "      kernelModule.push_back(fn.clone());",
          "new_line_content": "StatusOr<mlir::ModuleOp> ExtractKernelModule(mlir::ModuleOp module) {",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": "pm.nest<::mlir::gpu::GPUModuleOp>()",
          "new_api": null,
          "old_text": "pm.nest<::mlir::gpu::GPUModuleOp>()",
          "new_text": null,
          "old_line_content": "  auto& kernelPm = pm.nest<::mlir::gpu::GPUModuleOp>();",
          "new_line_content": "  // We cannot verify as the signature of the kernel is rewritten.",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": "getContext",
          "new_api": null,
          "old_text": "module.getContext()",
          "new_text": null,
          "old_line_content": "  ::mlir::PassManager pm(module.getContext(), /*verifyPasses=*/false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": "applyPassManagerCLOptions",
          "new_api": null,
          "old_text": "applyPassManagerCLOptions(pm)",
          "new_text": null,
          "old_line_content": "  applyPassManagerCLOptions(pm);",
          "new_line_content": "}  // namespace",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": "getOperation",
          "new_api": null,
          "old_text": "getOperation()",
          "new_text": null,
          "old_line_content": "    ::mlir::gpu::GPUModuleOp m = getOperation();",
          "new_line_content": "class LowerToNVVMPass",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": "getContext",
          "new_api": null,
          "old_text": "m.getContext()",
          "new_text": null,
          "old_line_content": "    ::mlir::LLVMTypeConverter converter(m.getContext());",
          "new_line_content": " public:",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": "::mlir::populateStdToLLVMConversionPatterns(converter, patterns)",
          "new_api": null,
          "old_text": "::mlir::populateStdToLLVMConversionPatterns(converter, patterns)",
          "new_text": null,
          "old_line_content": "    ::mlir::populateStdToLLVMConversionPatterns(converter, patterns);",
          "new_line_content": "  void runOnOperation() override {",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": "::mlir::populateLinalgToLLVMConversionPatterns(converter, patterns,\n                                                   &getContext())",
          "new_api": null,
          "old_text": "::mlir::populateLinalgToLLVMConversionPatterns(converter, patterns,\n                                                   &getContext())",
          "new_text": null,
          "old_line_content": "    ::mlir::populateLinalgToLLVMConversionPatterns(converter, patterns,",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 19,
      "total_additions": 20,
      "total_deletions": 18,
      "total_api_changes": 57
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 5,
        "api_related_lines": 57,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          512,
          508,
          509
        ]
      }
    },
    "api_calls_before": 306,
    "api_calls_after": 309,
    "diff_info": {
      "added_lines": 5,
      "removed_lines": 0,
      "total_diff_lines": 17
    }
  }
}