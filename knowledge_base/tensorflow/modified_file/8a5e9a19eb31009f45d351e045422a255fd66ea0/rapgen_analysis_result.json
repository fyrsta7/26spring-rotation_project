{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/8a5e9a19eb31009f45d351e045422a255fd66ea0",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/8a5e9a19eb31009f45d351e045422a255fd66ea0/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/8a5e9a19eb31009f45d351e045422a255fd66ea0/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/8a5e9a19eb31009f45d351e045422a255fd66ea0/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 124,
          "old_api": "absl::c_max_element(candidates, compare)",
          "new_api": "shape",
          "old_text": "absl::c_max_element(candidates, compare)",
          "new_text": "use.instruction->shape()",
          "old_line_content": "  auto best_candidate = absl::c_max_element(candidates, compare);",
          "new_line_content": "          use_size += ShapeUtil::ElementsInRecursive(use.instruction->shape());",
          "content_same": false
        },
        {
          "line": 155,
          "old_api": "GetInstructionElapsedDueToMemory",
          "new_api": "CallGraph::Build(&module)",
          "old_text": "GetInstructionElapsedDueToMemory(instruction)",
          "new_text": "CallGraph::Build(&module)",
          "old_line_content": "      GetInstructionElapsedDueToMemory(instruction);",
          "new_line_content": "  auto call_graph = CallGraph::Build(&module);",
          "content_same": false
        },
        {
          "line": 174,
          "old_api": "CalculateComputationNestLevel",
          "new_api": "find",
          "old_text": "CalculateComputationNestLevel(&instruction,\n                                        /*while_only=*/true)",
          "new_text": "cache->while_nest_multiplier.find(&instruction)",
          "old_line_content": "          CalculateComputationNestLevel(&instruction,",
          "new_line_content": "      auto it = cache->while_nest_multiplier.find(&instruction);",
          "content_same": false
        },
        {
          "line": 203,
          "old_api": "opcode",
          "new_api": "GetAlternateMemoryBenefit",
          "old_text": "use.instruction->opcode()",
          "new_text": "GetAlternateMemoryBenefit(\n      defining_instruction,\n      GetInstructionElapsedDueToMemory(defining_instruction,\n                                       /*operand_in_alternate_mem=*/{},\n                                       /*output_in_alternate_mem=*/true),\n      cache)",
          "old_line_content": "        if (use.instruction->opcode() == HloOpcode::kWhile ||",
          "new_line_content": "  float alternate_mem_benefit = GetAlternateMemoryBenefit(",
          "content_same": false
        },
        {
          "line": 209,
          "old_api": "GetInstructionElapsedDueToMemory",
          "new_api": "ComputeBuffersAt",
          "old_text": "GetInstructionElapsedDueToMemory(\n                                          *use.instruction, use.operand_number)",
          "new_text": "alias_analysis_->ComputeBuffersAt(\n           interval.buffer->defining_position().instruction,\n           interval.buffer->defining_position().index)",
          "old_line_content": "                                      GetInstructionElapsedDueToMemory(",
          "new_line_content": "  for (const HloBuffer* buffer : alias_analysis_->ComputeBuffersAt(",
          "content_same": false
        },
        {
          "line": 250,
          "old_api": "flop_count",
          "new_api": "caller_callsites",
          "old_text": "std::max(\n      cost_analysis_.flop_count(instruction) /\n          cost_analysis_.per_second_rate(HloCostAnalysis::kFlopsKey),\n      cost_analysis_.transcendental_count(instruction) /\n          cost_analysis_.per_second_rate(HloCostAnalysis::kTranscendentalsKey))",
          "new_text": "node.caller_callsites()",
          "old_line_content": "  return std::max(",
          "new_line_content": "    auto callsites = node.caller_callsites();",
          "content_same": false
        },
        {
          "line": 251,
          "old_api": "flop_count",
          "new_api": "size",
          "old_text": "cost_analysis_.flop_count(instruction)",
          "new_text": "callsites.size()",
          "old_line_content": "      cost_analysis_.flop_count(instruction) /",
          "new_line_content": "    CHECK_EQ(callsites.size(), 1) << \"The module is not flattened!\";",
          "content_same": false
        },
        {
          "line": 253,
          "old_api": "transcendental_count",
          "new_api": "instruction",
          "old_text": "cost_analysis_.transcendental_count(instruction)",
          "new_text": "callsite.instruction()->opcode()",
          "old_line_content": "      cost_analysis_.transcendental_count(instruction) /",
          "new_line_content": "    if (!while_only || callsite.instruction()->opcode() == HloOpcode::kWhile) {",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": "per_second_rate",
          "new_api": "flop_count",
          "old_text": "cost_analysis_.per_second_rate(HloCostAnalysis::kBytesAccessedKey)",
          "new_text": "cost_analysis_.flop_count(instruction)",
          "old_line_content": "      cost_analysis_.per_second_rate(HloCostAnalysis::kBytesAccessedKey);",
          "new_line_content": "      cost_analysis_.flop_count(instruction) /",
          "content_same": false
        },
        {
          "line": 318,
          "old_api": "schedule_end_time",
          "new_api": "GetInstructionElapsedDueToCompute",
          "old_text": "hlo_live_range_->schedule_end_time()",
          "new_text": "GetInstructionElapsedDueToCompute(instruction)",
          "old_line_content": "  return hlo_live_range_->schedule_end_time();",
          "new_line_content": "      GetInstructionElapsedDueToCompute(instruction),",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": "size",
          "new_api": "hlo_live_range",
          "old_text": "instructions_elapsed_time.size()",
          "new_text": "cost_analysis_.hlo_live_range().instruction_schedule()",
          "old_line_content": "    if (logical_time >= instructions_elapsed_time.size()) {",
          "new_line_content": "      &cost_analysis_.hlo_live_range().instruction_schedule();",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": "GetInstructionElapsed",
          "new_api": "resize",
          "old_text": "cost_analysis_.GetInstructionElapsed(\n        *instruction_and_logical_time.first)",
          "new_text": "instructions_elapsed_time.resize(logical_time + 1, 0.0)",
          "old_line_content": "    float elapsed_time = cost_analysis_.GetInstructionElapsed(",
          "new_line_content": "      instructions_elapsed_time.resize(logical_time + 1, 0.0);",
          "content_same": false
        },
        {
          "line": 420,
          "old_api": "tensorflow::MathUtil::IPow<float>(kWhileExecutionCount,\n                                                         while_nest_level)",
          "new_api": "CalculateComputationNestLevel",
          "old_text": "tensorflow::MathUtil::IPow<float>(kWhileExecutionCount,\n                                                         while_nest_level)",
          "new_text": "cost_analysis_.CalculateComputationNestLevel(\n        instruction_and_logical_time.first, /*while_only=*/true)",
          "old_line_content": "        elapsed_time * tensorflow::MathUtil::IPow<float>(kWhileExecutionCount,",
          "new_line_content": "    int while_nest_level = cost_analysis_.CalculateComputationNestLevel(",
          "content_same": false
        },
        {
          "line": 449,
          "old_api": "GetAsyncCopyElapsed",
          "new_api": "size",
          "old_text": "std::max(max_overlap_multiplier_ * async_copy_elapsed,\n                  cost_analysis_.GetAsyncCopyElapsed(ShapeUtil::MakeShape(\n                      S32, {buffer_size_for_max_async_copy_ / 4})))",
          "new_text": "while_nest_level_.size()",
          "old_line_content": "         std::max(max_overlap_multiplier_ * async_copy_elapsed,",
          "new_line_content": "  for (int i = 0; i < while_nest_level_.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": "GetMaxElapsedInAlternateMemory",
          "new_api": "GetAsyncCopyElapsed",
          "old_text": "GetMaxElapsedInAlternateMemory(async_copy_elapsed)",
          "new_text": "std::max(max_overlap_multiplier_ * async_copy_elapsed,\n                  cost_analysis_.GetAsyncCopyElapsed(ShapeUtil::MakeShape(\n                      S32, {buffer_size_for_max_async_copy_ / 4})))",
          "old_line_content": "  return GetMaxElapsedInAlternateMemory(async_copy_elapsed) >",
          "new_line_content": "         std::max(max_overlap_multiplier_ * async_copy_elapsed,",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": "GetLogicalIntervalElapsed",
          "new_api": "GetAsyncCopyElapsed",
          "old_text": "GetLogicalIntervalElapsed(start_time, end_time)",
          "new_text": "cost_analysis_.GetAsyncCopyElapsed(shape)",
          "old_line_content": "        GetLogicalIntervalElapsed(start_time, end_time);",
          "new_line_content": "  float async_copy_elapsed = cost_analysis_.GetAsyncCopyElapsed(shape);",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": "GetAsyncCopyElapsed",
          "new_api": "GetLogicalIntervalElapsed",
          "old_text": "cost_analysis_.GetAsyncCopyElapsed(shape)",
          "new_text": "GetLogicalIntervalElapsed(start_time, end_time)",
          "old_line_content": "  float async_copy_elapsed = cost_analysis_.GetAsyncCopyElapsed(shape);",
          "new_line_content": "        GetLogicalIntervalElapsed(start_time, end_time);",
          "content_same": false
        },
        {
          "line": 520,
          "old_api": "GetAsyncCopyElapsed",
          "new_api": "GetLogicalIntervalElapsed",
          "old_text": "cost_analysis_.GetAsyncCopyElapsed(shape)",
          "new_text": "GetLogicalIntervalElapsed(latest_prefetch_time, end_time)",
          "old_line_content": "  float async_copy_elapsed = cost_analysis_.GetAsyncCopyElapsed(shape);",
          "new_line_content": "            GetLogicalIntervalElapsed(latest_prefetch_time, end_time) +",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": "std::abs(preferred_interval - interval)",
          "new_api": "GetAsyncCopyElapsed",
          "old_text": "std::abs(preferred_interval - interval)",
          "new_text": "cost_analysis_.GetAsyncCopyElapsed(shape)",
          "old_line_content": "        std::abs(preferred_interval - interval) <",
          "new_line_content": "  float async_copy_elapsed = cost_analysis_.GetAsyncCopyElapsed(shape);",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": "GetMaxElapsedInAlternateMemory",
          "new_api": "GetInstructionElapsedInAlternateMemory",
          "old_text": "GetMaxElapsedInAlternateMemory(async_copy_elapsed_)",
          "new_text": "cost_analysis_.GetInstructionElapsedInAlternateMemory(\n          *use.instruction, use.operand_number,\n          /*output_in_alternate_mem=*/false)",
          "old_line_content": "  float max_interval = GetMaxElapsedInAlternateMemory(async_copy_elapsed_);",
          "new_line_content": "      cost_analysis_.GetInstructionElapsedInAlternateMemory(",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": "Done",
          "new_api": "GetMaxElapsedInAlternateMemory",
          "old_text": "Done()",
          "new_text": "GetMaxElapsedInAlternateMemory(async_copy_elapsed_)",
          "old_line_content": "    CHECK(Done());",
          "new_line_content": "  float max_interval = GetMaxElapsedInAlternateMemory(async_copy_elapsed_);",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": "PreferredPrefetchStartTime",
          "new_api": "GetLogicalIntervalElapsed",
          "old_text": "PreferredPrefetchStartTime(\n      shape, earliest_prefetch_time_, latest_prefetch_time_, end_logical_time_)",
          "new_text": "GetLogicalIntervalElapsed(earliest_prefetch_time_,\n                                                 end_logical_time_)",
          "old_line_content": "  int64 starting_prefetch_time = PreferredPrefetchStartTime(",
          "new_line_content": "        max_interval < GetLogicalIntervalElapsed(earliest_prefetch_time_,",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": "tensorflow::MathUtil::IPow<float>(kWhileExecutionCount,\n                                           interval_while_nest_level)",
          "new_api": "CHECK_LE",
          "old_text": "tensorflow::MathUtil::IPow<float>(kWhileExecutionCount,\n                                           interval_while_nest_level)",
          "new_text": "CHECK_LE(start_time, end_time)",
          "old_line_content": "         tensorflow::MathUtil::IPow<float>(kWhileExecutionCount,",
          "new_line_content": "  CHECK_LE(start_time, end_time);",
          "content_same": false
        },
        {
          "line": 689,
          "old_api": "absl::StrCat(\n      \"Async copy elapsed (s) = \", async_copy_elapsed_,\n      \", inst elapsed reduction (s) = \", inst_elapsed_reduction_,\n      \", logical interval elapsed (s) = \", logical_interval_elapsed,\n      \", interval = (\", current_logical_prefetch_time, \", \", end_logical_time_,\n      \")\")",
          "new_api": "GetMinWhileNestLevel",
          "old_text": "absl::StrCat(\n      \"Async copy elapsed (s) = \", async_copy_elapsed_,\n      \", inst elapsed reduction (s) = \", inst_elapsed_reduction_,\n      \", logical interval elapsed (s) = \", logical_interval_elapsed,\n      \", interval = (\", current_logical_prefetch_time, \", \", end_logical_time_,\n      \")\")",
          "new_text": "GetMinWhileNestLevel(start_time, end_time)",
          "old_line_content": "  return absl::StrCat(",
          "new_line_content": "  int interval_while_nest_level = GetMinWhileNestLevel(start_time, end_time);",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": "absl::StrCat(\n      \"Async copy elapsed (s) = \", async_copy_elapsed,\n      \", logical interval elapsed (s) = \", logical_interval_elapsed)",
          "new_api": "absl::StrCat(\n      \"Async copy elapsed (s) = \", async_copy_elapsed_,\n      \", inst elapsed reduction (s) = \", inst_elapsed_reduction_,\n      \", logical interval elapsed (s) = \", logical_interval_elapsed,\n      \", interval = (\", current_logical_prefetch_time, \", \", end_logical_time_,\n      \")\")",
          "old_text": "absl::StrCat(\n      \"Async copy elapsed (s) = \", async_copy_elapsed,\n      \", logical interval elapsed (s) = \", logical_interval_elapsed)",
          "new_text": "absl::StrCat(\n      \"Async copy elapsed (s) = \", async_copy_elapsed_,\n      \", inst elapsed reduction (s) = \", inst_elapsed_reduction_,\n      \", logical interval elapsed (s) = \", logical_interval_elapsed,\n      \", interval = (\", current_logical_prefetch_time, \", \", end_logical_time_,\n      \")\")",
          "old_line_content": null,
          "new_line_content": "  return absl::StrCat(",
          "content_same": true
        },
        {
          "line": 729,
          "old_api": "copy_start_schedule_after",
          "new_api": "defining_position",
          "old_text": "other.copy_start_schedule_after()",
          "new_text": "other.defining_position()",
          "old_line_content": "         copy_start_schedule_after() == other.copy_start_schedule_after() &&",
          "new_line_content": "  return defining_position() == other.defining_position() &&",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": "copy_done",
          "new_api": "memory_space",
          "old_text": "other.copy_done()",
          "new_text": "other.memory_space()",
          "old_line_content": "         copy_start() == other.copy_start() && copy_done() == other.copy_done();",
          "new_line_content": "         uses() == other.uses() && memory_space() == other.memory_space() &&",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": "name",
          "new_api": "is_scoped_allocation",
          "old_text": "computation()->name()",
          "new_text": "other.is_scoped_allocation()",
          "old_line_content": "  std::string out = absl::StrCat(\"computation = \", computation()->name());",
          "new_line_content": "         is_scoped_allocation() == other.is_scoped_allocation();",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": "absl::StrAppend(&out, \" uses:\\n\")",
          "new_api": "static_cast<const Allocation&>(*this)",
          "old_text": "absl::StrAppend(&out, \" uses:\\n\")",
          "new_text": "static_cast<const Allocation&>(*this)",
          "old_line_content": "  absl::StrAppend(&out, \" uses:\\n\");",
          "new_line_content": "  return static_cast<const Allocation&>(*this) ==",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": "ToString",
          "new_api": "copy_done_schedule_before",
          "old_text": "use.hlo_use.ToString()",
          "new_text": "other.copy_done_schedule_before()",
          "old_line_content": "    absl::StrAppend(&out, \"  \", use.hlo_use.ToString(), \"\\n\");",
          "new_line_content": "         copy_done_schedule_before() == other.copy_done_schedule_before() &&",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": "ToString",
          "new_api": "absl::StrAppend(&out,\n                  (requires_contiguous_allocation_ ? \" (cont alloc)\" : \"\"))",
          "old_text": "defining_position_.ToString()",
          "new_text": "absl::StrAppend(&out,\n                  (requires_contiguous_allocation_ ? \" (cont alloc)\" : \"\"))",
          "old_line_content": "                      \", position = \", defining_position_.ToString(),",
          "new_line_content": "  absl::StrAppend(&out,",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": "opcode",
          "new_api": "ToString",
          "old_text": "instruction->opcode()",
          "new_text": "value->ToString()",
          "old_line_content": "    if (instruction->opcode() != HloOpcode::kGetTupleElement &&",
          "new_line_content": "  VLOG(3) << \"Creating AllocationValues for: \" << value->ToString();",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": "at",
          "new_api": "instruction_schedule",
          "old_text": "instruction_schedule.at(pos2.instruction)",
          "new_text": "hlo_live_range_.instruction_schedule()",
          "old_line_content": "                               instruction_schedule.at(pos2.instruction);",
          "new_line_content": "      instruction_schedule = hlo_live_range_.instruction_schedule();",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": "size",
          "new_api": "opcode",
          "old_text": "allocation_values.size()",
          "new_text": "instruction->opcode()",
          "old_line_content": "  int beginning_idx = allocation_values.size();",
          "new_line_content": "        instruction->opcode() != HloOpcode::kTuple &&",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": "size",
          "new_api": "opcode",
          "old_text": "positions.size()",
          "new_text": "instruction->opcode()",
          "old_line_content": "  for (int i = 0; i < positions.size(); ++i) {",
          "new_line_content": "        instruction->opcode() != HloOpcode::kBitcast) {",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": "at",
          "new_api": "push_back",
          "old_text": "positions.at(i)",
          "new_text": "positions.push_back(position)",
          "old_line_content": "    const HloPosition& position = positions.at(i);",
          "new_line_content": "      positions.push_back(position);",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": "parent",
          "new_api": "at",
          "old_text": "use.instruction->parent()",
          "new_text": "instruction_schedule.at(use1.instruction)",
          "old_line_content": "    HloComputation* use_computation = use.instruction->parent();",
          "new_line_content": "    return instruction_schedule.at(use1.instruction) <",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": "defining_instruction",
          "new_api": "at",
          "old_text": "allocation_value->defining_instruction()->opcode()",
          "new_text": "instruction_schedule.at(use.instruction)",
          "old_line_content": "                     allocation_value->defining_instruction()->opcode()) &&",
          "new_line_content": "    int64 use_time = instruction_schedule.at(use.instruction);",
          "content_same": false
        },
        {
          "line": 818,
          "old_api": "computation",
          "new_api": "parent",
          "old_text": "allocation_value->computation()",
          "new_text": "use.instruction->parent()",
          "old_line_content": "                 allocation_value->computation() == use_computation &&",
          "new_line_content": "    HloComputation* use_computation = use.instruction->parent();",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": "CHECK",
          "new_api": "defining_instruction",
          "old_text": "CHECK(last_allocation_value != nullptr)",
          "new_text": "allocation_value->defining_instruction()",
          "old_line_content": "    CHECK(last_allocation_value != nullptr);",
          "new_line_content": "        if (allocation_value->defining_instruction() ==",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": "AddUse",
          "new_api": "operand",
          "old_text": "last_allocation_value->AddUse(use, use_time)",
          "new_text": "use.instruction->operand(0)",
          "old_line_content": "    last_allocation_value->AddUse(use, use_time);",
          "new_line_content": "            use.instruction->operand(0)) {",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "size",
          "new_api": "defining_instruction",
          "old_text": "allocation_values.size()",
          "new_text": "HloDataflowAnalysis::IsAsynchronousOperationStart(\n                     allocation_value->defining_instruction()->opcode())",
          "old_line_content": "  for (int i = beginning_idx; i < allocation_values.size(); ++i) {",
          "new_line_content": "      } else if (!HloDataflowAnalysis::IsAsynchronousOperationStart(",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": "at",
          "new_api": "defining_instruction",
          "old_text": "allocation_values.at(i)",
          "new_text": "allocation_value->defining_instruction()->opcode()",
          "old_line_content": "    AllocationValue& allocation_value = allocation_values.at(i);",
          "new_line_content": "                     allocation_value->defining_instruction()->opcode()) &&",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": "defining_instruction",
          "new_api": "computation",
          "old_text": "HloDataflowAnalysis::IsAsynchronousOperationStart(\n            allocation_value.defining_instruction()->opcode())",
          "new_text": "allocation_value->computation()",
          "old_line_content": "    if (HloDataflowAnalysis::IsAsynchronousOperationStart(",
          "new_line_content": "                 allocation_value->computation() == use_computation &&",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": "defining_instruction",
          "new_api": "at",
          "old_text": "allocation_value.defining_instruction()->opcode()",
          "new_text": "instruction_schedule.at(\n                     allocation_value->defining_position().instruction)",
          "old_line_content": "            allocation_value.defining_instruction()->opcode())) {",
          "new_line_content": "                 instruction_schedule.at(",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": "uses",
          "new_api": "defining_position",
          "old_text": "allocation_value.uses().size()",
          "new_text": "allocation_value->defining_position()",
          "old_line_content": "      CHECK_EQ(allocation_value.uses().size(), 1);",
          "new_line_content": "                     allocation_value->defining_position().instruction) <",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": "set_requires_contiguous_allocation",
          "new_api": "CHECK",
          "old_text": "allocation_value.set_requires_contiguous_allocation(true)",
          "new_text": "CHECK(last_allocation_value != nullptr)",
          "old_line_content": "      allocation_value.set_requires_contiguous_allocation(true);",
          "new_line_content": "    CHECK(last_allocation_value != nullptr);",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": "uses",
          "new_api": "defining_instruction",
          "old_text": "value.uses()",
          "new_text": "value.defining_instruction()",
          "old_line_content": "    for (AllocationValue::Use& use : value.uses()) {",
          "new_line_content": "    values_by_defining_inst[value.defining_instruction()] = &value;",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": "called_computations",
          "new_api": "ToShortString",
          "old_text": "use.hlo_use.instruction->called_computations()",
          "new_text": "aliased_value_it->second->ToShortString()",
          "old_line_content": "           use.hlo_use.instruction->called_computations()) {",
          "new_line_content": "              << aliased_value_it->second->ToShortString();",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": "opcode",
          "new_api": "maybe_add_alias_with_instruction",
          "old_text": "use.hlo_use.instruction->opcode()",
          "new_text": "maybe_add_alias_with_instruction(use.hlo_use.instruction, &use)",
          "old_line_content": "      if (use.hlo_use.instruction->opcode() == HloOpcode::kWhile) {",
          "new_line_content": "      maybe_add_alias_with_instruction(use.hlo_use.instruction, &use);",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": "VLOG",
          "new_api": "called_computations",
          "old_text": "VLOG(3)",
          "new_text": "use.hlo_use.instruction->called_computations()",
          "old_line_content": "        VLOG(3) << \"Adding while body root aliasing for use \"",
          "new_line_content": "           use.hlo_use.instruction->called_computations()) {",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": "push_back",
          "new_api": "parameter_instructions",
          "old_text": "use.aliases.push_back(root_alias)",
          "new_text": "called_computation->parameter_instructions()",
          "old_line_content": "        use.aliases.push_back(root_alias);",
          "new_line_content": "             called_computation->parameter_instructions()) {",
          "content_same": false
        },
        {
          "line": 902,
          "old_api": "empty",
          "new_api": "VLOG",
          "old_text": "worklist.empty()",
          "new_text": "VLOG(3)",
          "old_line_content": "  while (!worklist.empty()) {",
          "new_line_content": "        VLOG(3) << \"Adding while body root aliasing for use \"",
          "content_same": false
        },
        {
          "line": 903,
          "old_api": "back",
          "new_api": "ToString",
          "old_text": "worklist.back()",
          "new_text": "use.hlo_use.ToString()",
          "old_line_content": "    const BufferInterval* item = worklist.back();",
          "new_line_content": "                << use.hlo_use.ToString() << \" to \" << root_alias;",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": "pop_back",
          "new_api": "push_back",
          "old_text": "worklist.pop_back()",
          "new_text": "use.aliases.push_back(root_alias)",
          "old_line_content": "    worklist.pop_back();",
          "new_line_content": "        use.aliases.push_back(root_alias);",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": "instruction_schedule",
          "new_api": "at",
          "old_text": "hlo_live_range_.instruction_schedule()",
          "new_text": "buffer_intervals_.at(buffer_colocated)",
          "old_line_content": "  const auto& instruction_schedule = hlo_live_range_.instruction_schedule();",
          "new_line_content": "      worklist.push_back(&buffer_intervals_.at(buffer_colocated));",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": "opcode",
          "new_api": "absl::c_stable_sort(colocated_intervals, [&](const BufferInterval* x,\n                                               const BufferInterval* y) {\n    return std::make_pair(x->start, x->end) < std::make_pair(y->start, y->end);\n  })",
          "old_text": "use.instruction->opcode()",
          "new_text": "absl::c_stable_sort(colocated_intervals, [&](const BufferInterval* x,\n                                               const BufferInterval* y) {\n    return std::make_pair(x->start, x->end) < std::make_pair(y->start, y->end);\n  })",
          "old_line_content": "  if (use.instruction->opcode() == HloOpcode::kWhile) {",
          "new_line_content": "  absl::c_stable_sort(colocated_intervals, [&](const BufferInterval* x,",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "parameter_instruction",
          "new_api": "is_use_allowed_in_alternate_mem_fn",
          "old_text": "while_body->parameter_instruction(0)",
          "new_text": "options_.is_use_allowed_in_alternate_mem_fn(use)",
          "old_line_content": "        instruction_schedule.at(while_body->parameter_instruction(0));",
          "new_line_content": "  if (!options_.is_use_allowed_in_alternate_mem_fn(use)) {",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": "uses",
          "new_api": "opcode",
          "old_text": "parameter_value->uses()",
          "new_text": "use.instruction->opcode()",
          "old_line_content": "    for (const HloUse& parameter_use : parameter_value->uses()) {",
          "new_line_content": "  if (use.instruction->opcode() == HloOpcode::kWhile) {",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": "at",
          "new_api": "while_body",
          "old_text": "instruction_schedule.at(parameter_use.instruction)",
          "new_text": "use.instruction->while_body()",
          "old_line_content": "      int64 use_time = instruction_schedule.at(parameter_use.instruction);",
          "new_line_content": "    HloComputation* while_body = use.instruction->while_body();",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "shape",
          "new_api": "opcode",
          "old_text": "parameter_value->shape()",
          "new_text": "parameter_use.instruction->opcode()",
          "old_line_content": "    const Shape& shape = parameter_value->shape();",
          "new_line_content": "          parameter_use.instruction->opcode() != HloOpcode::kTuple &&",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": "CanAllocateInAlternateMemoryNoCopy",
          "new_api": "std::min(min_use_time, use_time)",
          "old_text": "options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(\n            shape, parameter_time, min_use_time)",
          "new_text": "std::min(min_use_time, use_time)",
          "old_line_content": "    if (!options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(",
          "new_line_content": "        min_use_time = std::min(min_use_time, use_time);",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": "at",
          "new_api": "shape",
          "old_text": "instruction_schedule.at(use.instruction)",
          "new_text": "parameter_value->shape()",
          "old_line_content": "    int64 while_time = instruction_schedule.at(use.instruction);",
          "new_line_content": "    const Shape& shape = parameter_value->shape();",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": "parameter_instruction",
          "new_api": "opcode",
          "old_text": "called_computation->parameter_instruction(0)",
          "new_text": "use.instruction->opcode()",
          "old_line_content": "          called_computation->parameter_instruction(0);",
          "new_line_content": "  } else if (use.instruction->opcode() == HloOpcode::kConditional) {",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": "opcode",
          "new_api": "at",
          "old_text": "parameter_use.instruction->opcode()",
          "new_text": "use.instruction->called_computations().at(\n              other_use.hlo_use.operand_number - 1)",
          "old_line_content": "            parameter_use.instruction->opcode() != HloOpcode::kTuple &&",
          "new_line_content": "          use.instruction->called_computations().at(",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": "at",
          "new_api": "parameter_instruction",
          "old_text": "instruction_schedule.at(parameter_use.instruction)",
          "new_text": "called_computation->parameter_instruction(0)",
          "old_line_content": "              min_use_time, instruction_schedule.at(parameter_use.instruction));",
          "new_line_content": "          called_computation->parameter_instruction(0);",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": "shape",
          "new_api": "at",
          "old_text": "parameter_value->shape()",
          "new_text": "instruction_schedule.at(parameter_instruction)",
          "old_line_content": "              parameter_value->shape(), parameter_time, min_use_time)) {",
          "new_line_content": "      int64 parameter_time = instruction_schedule.at(parameter_instruction);",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": "name",
          "new_api": "parent",
          "old_text": "called_computation->name()",
          "new_text": "parameter_use.instruction->parent()",
          "old_line_content": "                << called_computation->name()",
          "new_line_content": "        if (parameter_use.instruction->parent() == called_computation &&",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": "VLOG",
          "new_api": "at",
          "old_text": "VLOG(4)",
          "new_text": "std::min(\n              min_use_time, instruction_schedule.at(parameter_use.instruction))",
          "old_line_content": "        VLOG(4) << \"Conditional allocation not allowed in alternate memory for \"",
          "new_line_content": "          min_use_time = std::min(",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": "uses",
          "new_api": "empty",
          "old_text": "value->uses()",
          "new_text": "debug_str->empty()",
          "old_line_content": "    for (const HloUse& use : value->uses()) {",
          "new_line_content": "  if (debug_str->empty()) {",
          "content_same": false
        },
        {
          "line": 1057,
          "old_api": "ToString",
          "new_api": "absl::StrAppend(debug_str,\n                    \"buffer_id,buffer_name,alt_mem_benefit,size,\"\n                    \"definition_time,use_times,use_names\\n\")",
          "old_text": "use.ToString()",
          "new_text": "absl::StrAppend(debug_str,\n                    \"buffer_id,buffer_name,alt_mem_benefit,size,\"\n                    \"definition_time,use_times,use_names\\n\")",
          "old_line_content": "          {instruction_schedule.at(use.instruction), use.ToString()});",
          "new_line_content": "    absl::StrAppend(debug_str,",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": "size",
          "new_api": "instruction_schedule",
          "old_text": "uses.size()",
          "new_text": "hlo_live_range_.instruction_schedule()",
          "old_line_content": "  use_times.reserve(uses.size());",
          "new_line_content": "  const auto& instruction_schedule = hlo_live_range_.instruction_schedule();",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": "push_back",
          "new_api": "values",
          "old_text": "use_names.push_back(use.second)",
          "new_text": "buffer.values()",
          "old_line_content": "    use_names.push_back(use.second);",
          "new_line_content": "  for (const HloValue* value : buffer.values()) {",
          "content_same": false
        },
        {
          "line": 1070,
          "old_api": "id",
          "new_api": "ToString",
          "old_text": "buffer.id()",
          "new_text": "use.ToString()",
          "old_line_content": "  absl::StrAppend(debug_str, buffer.id(), \",\");",
          "new_line_content": "          {instruction_schedule.at(use.instruction), use.ToString()});",
          "content_same": false
        },
        {
          "line": 1073,
          "old_api": "BufferIntervalAlternateMemoryBenefit",
          "new_api": "absl::c_sort(uses)",
          "old_text": "options_.prefetch_interval_picker->BufferIntervalAlternateMemoryBenefit(\n          interval)",
          "new_text": "absl::c_sort(uses)",
          "old_line_content": "      options_.prefetch_interval_picker->BufferIntervalAlternateMemoryBenefit(",
          "new_line_content": "  absl::c_sort(uses);",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": "absl::StrAppend(debug_str, interval.size, \",\")",
          "new_api": "size",
          "old_text": "absl::StrAppend(debug_str, interval.size, \",\")",
          "new_text": "uses.size()",
          "old_line_content": "  absl::StrAppend(debug_str, interval.size, \",\");",
          "new_line_content": "  use_names.reserve(uses.size());",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": "absl::StrJoin(use_times, \";\")",
          "new_api": "push_back",
          "old_text": "absl::StrJoin(use_times, \";\")",
          "new_text": "use_times.push_back(use.first)",
          "old_line_content": "  absl::StrAppend(debug_str, \"\\\"\", absl::StrJoin(use_times, \";\"), \"\\\",\");",
          "new_line_content": "    use_times.push_back(use.first);",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": "absl::StrJoin(use_names, \";\")",
          "new_api": "push_back",
          "old_text": "absl::StrJoin(use_names, \";\")",
          "new_text": "use_names.push_back(use.second)",
          "old_line_content": "  absl::StrAppend(debug_str, \"\\\"\", absl::StrJoin(use_names, \";\"), \"\\\"\");",
          "new_line_content": "    use_names.push_back(use.second);",
          "content_same": false
        },
        {
          "line": 1094,
          "old_api": "empty",
          "new_api": "absl::StrAppend(debug_str, \"\\n\")",
          "old_text": "debug_str.empty()",
          "new_text": "absl::StrAppend(debug_str, \"\\n\")",
          "old_line_content": "  if (debug_str.empty()) {",
          "new_line_content": "  absl::StrAppend(debug_str, \"\\n\");",
          "content_same": false
        },
        {
          "line": 1113,
          "old_api": "dump_fn",
          "new_api": "value",
          "old_text": "options_.dump_fn(\"bufferinfo\", buffer_info_str_)",
          "new_text": "value.value()",
          "old_line_content": "  options_.dump_fn(\"bufferinfo\", buffer_info_str_);",
          "new_line_content": "        alias_analysis_.GetBufferContainingValue(*value.value());",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": "dump_fn",
          "new_api": "id",
          "old_text": "options_.dump_fn(\"allocinfo\", allocation_info_str_)",
          "new_text": "buffer.id()",
          "old_line_content": "  options_.dump_fn(\"allocinfo\", allocation_info_str_);",
          "new_line_content": "    absl::StrAppend(&debug_str, buffer.id(), \",\");",
          "content_same": false
        },
        {
          "line": 1118,
          "old_api": "AllocateReservedScopedAllocations",
          "new_api": "end_time",
          "old_text": "AllocateReservedScopedAllocations()",
          "new_text": "allocation.end_time()",
          "old_line_content": "  AllocateReservedScopedAllocations();",
          "new_line_content": "    absl::StrAppend(&debug_str, allocation.end_time(), \"\\n\");",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": "AllocateCrossProgramPrefetchBuffer",
          "new_api": "dump_fn",
          "old_text": "AllocateCrossProgramPrefetchBuffer(module, prefetch_candidate)",
          "new_text": "options_.dump_fn(\"bufferinfo\", buffer_info_str_)",
          "old_line_content": "      AllocateCrossProgramPrefetchBuffer(module, prefetch_candidate);",
          "new_line_content": "  options_.dump_fn(\"bufferinfo\", buffer_info_str_);",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": "GetSortedBufferIntervals",
          "new_api": "AllocateReservedScopedAllocations",
          "old_text": "GetSortedBufferIntervals()",
          "new_text": "AllocateReservedScopedAllocations()",
          "old_line_content": "      GetSortedBufferIntervals();",
          "new_line_content": "  AllocateReservedScopedAllocations();",
          "content_same": false
        },
        {
          "line": 1138,
          "old_api": "VLOG_IS_ON",
          "new_api": "instruction",
          "old_text": "VLOG_IS_ON(3)",
          "new_text": "prefetch_candidate->buffer->instruction()->GetModule()",
          "old_line_content": "  if (VLOG_IS_ON(3)) {",
          "new_line_content": "          prefetch_candidate->buffer->instruction()->GetModule();",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": "VLOG",
          "new_api": "AllocateCrossProgramPrefetchBuffer",
          "old_text": "VLOG(3)",
          "new_text": "AllocateCrossProgramPrefetchBuffer(module, prefetch_candidate)",
          "old_line_content": "    VLOG(3) << \"Flattened instruction sequence:\";",
          "new_line_content": "      AllocateCrossProgramPrefetchBuffer(module, prefetch_candidate);",
          "content_same": false
        },
        {
          "line": 1144,
          "old_api": "name",
          "new_api": "GetSortedBufferIntervals",
          "old_text": "instruction_sequence[i]->name()",
          "new_text": "GetSortedBufferIntervals()",
          "old_line_content": "              << \" \" << instruction_sequence[i]->name();",
          "new_line_content": "      GetSortedBufferIntervals();",
          "content_same": false
        },
        {
          "line": 1149,
          "old_api": "GetSortedColocatedIntervals",
          "new_api": "AddInputAndOutputRequiredAssignments",
          "old_text": "GetSortedColocatedIntervals(interval)",
          "new_text": "AddInputAndOutputRequiredAssignments()",
          "old_line_content": "    auto colocated_intervals = GetSortedColocatedIntervals(interval);",
          "new_line_content": "  AddInputAndOutputRequiredAssignments();",
          "content_same": false
        },
        {
          "line": 1156,
          "old_api": "VLOG",
          "new_api": "parent",
          "old_text": "VLOG(2)",
          "new_text": "instruction_sequence[i]->parent()->name()",
          "old_line_content": "  VLOG(2) << \"Total reserved bytes = \" << reserved_in_bytes_;",
          "new_line_content": "      VLOG(3) << \" \" << i << \": \" << instruction_sequence[i]->parent()->name()",
          "content_same": false
        },
        {
          "line": 1163,
          "old_api": "MemorySpaceAssignmentUtils::IsIntervalAllowedInAlternateMemory(\n            interval)",
          "new_api": "AreIntervalsReservedInAlternateMemory",
          "old_text": "MemorySpaceAssignmentUtils::IsIntervalAllowedInAlternateMemory(\n            interval)",
          "new_text": "AreIntervalsReservedInAlternateMemory(colocated_intervals)",
          "old_line_content": "    if (!MemorySpaceAssignmentUtils::IsIntervalAllowedInAlternateMemory(",
          "new_line_content": "    if (AreIntervalsReservedInAlternateMemory(colocated_intervals)) {",
          "content_same": false
        },
        {
          "line": 1169,
          "old_api": "GetModule",
          "new_api": "VLOG",
          "old_text": "inst->GetModule()",
          "new_text": "VLOG(2)",
          "old_line_content": "    HloModule* module = inst->GetModule();",
          "new_line_content": "  VLOG(2) << \"Total reserved bytes = \" << reserved_in_bytes_;",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": "ToShortString",
          "new_api": "MemorySpaceAssignmentUtils::IsIntervalAllowedInAlternateMemory(\n            interval)",
          "old_text": "interval.buffer->ToShortString()",
          "new_text": "MemorySpaceAssignmentUtils::IsIntervalAllowedInAlternateMemory(\n            interval)",
          "old_line_content": "      VLOG(3) << \"Skip \" << interval.buffer->ToShortString()",
          "new_line_content": "    if (!MemorySpaceAssignmentUtils::IsIntervalAllowedInAlternateMemory(",
          "content_same": false
        },
        {
          "line": 1181,
          "old_api": "available_heap_size",
          "new_api": "instruction",
          "old_text": "available_heap_size()",
          "new_text": "interval.buffer->instruction()",
          "old_line_content": "    if (interval.size > available_heap_size()) {",
          "new_line_content": "    HloInstruction* inst = interval.buffer->instruction();",
          "content_same": false
        },
        {
          "line": 1182,
          "old_api": "ToShortString",
          "new_api": "GetModule",
          "old_text": "interval.buffer->ToShortString()",
          "new_text": "inst->GetModule()",
          "old_line_content": "      VLOG(3) << \"Skip \" << interval.buffer->ToShortString()",
          "new_line_content": "    HloModule* module = inst->GetModule();",
          "content_same": false
        },
        {
          "line": 1187,
          "old_api": "GetSortedColocatedIntervals",
          "new_api": "parameter_number",
          "old_text": "GetSortedColocatedIntervals(interval)",
          "new_text": "inst->parameter_number()",
          "old_line_content": "    auto colocated_intervals = GetSortedColocatedIntervals(interval);",
          "new_line_content": "                      std::make_pair(inst->parameter_number(),",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": "AreIntervalsReservedInAlternateMemory",
          "new_api": "ToShortString",
          "old_text": "AreIntervalsReservedInAlternateMemory(colocated_intervals)",
          "new_text": "interval.buffer->ToShortString()",
          "old_line_content": "    if (AreIntervalsReservedInAlternateMemory(colocated_intervals)) {",
          "new_line_content": "      VLOG(3) << \"Skip \" << interval.buffer->ToShortString()",
          "content_same": false
        },
        {
          "line": 1200,
          "old_api": "mutable_shape",
          "new_api": "GetSortedColocatedIntervals",
          "old_text": "position.instruction->mutable_shape()",
          "new_text": "GetSortedColocatedIntervals(interval)",
          "old_line_content": "              position.instruction->mutable_shape(), position.index);",
          "new_line_content": "    auto colocated_intervals = GetSortedColocatedIntervals(interval);",
          "content_same": false
        },
        {
          "line": 1202,
          "old_api": "ToString",
          "new_api": "AreIntervalsReservedInAlternateMemory",
          "old_text": "position.ToString()",
          "new_text": "AreIntervalsReservedInAlternateMemory(colocated_intervals)",
          "old_line_content": "                                  << position.ToString();",
          "new_line_content": "    if (AreIntervalsReservedInAlternateMemory(colocated_intervals)) {",
          "content_same": false
        },
        {
          "line": 1203,
          "old_api": "mutable_layout",
          "new_api": "ToShortString",
          "old_text": "shape->mutable_layout()->set_memory_space(\n              options_.alternate_memory_space)",
          "new_text": "interval.buffer->ToShortString()",
          "old_line_content": "          shape->mutable_layout()->set_memory_space(",
          "new_line_content": "      VLOG(3) << \"Interval \" << interval.buffer->ToShortString()",
          "content_same": false
        },
        {
          "line": 1210,
          "old_api": "size",
          "new_api": "positions",
          "old_text": "colocated_intervals.size()",
          "new_text": "value->positions()",
          "old_line_content": "    if (colocated_intervals.size() > 1 &&",
          "new_line_content": "        for (auto& position : value->positions()) {",
          "content_same": false
        },
        {
          "line": 1212,
          "old_api": "ToShortString",
          "new_api": "mutable_shape",
          "old_text": "interval.buffer->ToShortString()",
          "new_text": "ShapeUtil::GetMutableSubshape(\n              position.instruction->mutable_shape(), position.index)",
          "old_line_content": "      VLOG(4) << \"Not allocating \" << interval.buffer->ToShortString()",
          "new_line_content": "          Shape* shape = ShapeUtil::GetMutableSubshape(",
          "content_same": false
        },
        {
          "line": 1225,
          "old_api": "AppendBufferInfoDebugString",
          "new_api": "ToShortString",
          "old_text": "AppendBufferInfoDebugString(interval, &buffer_info_str_)",
          "new_text": "interval.buffer->ToShortString()",
          "old_line_content": "    AppendBufferInfoDebugString(interval, &buffer_info_str_);",
          "new_line_content": "      VLOG(4) << \"Not allocating \" << interval.buffer->ToShortString()",
          "content_same": false
        },
        {
          "line": 1241,
          "old_api": "static_cast<int>(result)",
          "new_api": "CreateAllocationValuesFromColocatedIntervals",
          "old_text": "static_cast<int>(result)",
          "new_text": "CreateAllocationValuesFromColocatedIntervals(colocated_intervals,\n                                                 allocation_values)",
          "old_line_content": "              << absl::StrFormat(\"%x\", static_cast<int>(result));",
          "new_line_content": "    CreateAllocationValuesFromColocatedIntervals(colocated_intervals,",
          "content_same": false
        },
        {
          "line": 1252,
          "old_api": "CHECK_NE",
          "new_api": "absl::MakeSpan(allocation_values)",
          "old_text": "CHECK_NE(options_.repacker, nullptr)",
          "new_text": "absl::MakeSpan(allocation_values)",
          "old_line_content": "        CHECK_NE(options_.repacker, nullptr);",
          "new_line_content": "          AllocateAllocationValues(absl::MakeSpan(allocation_values));",
          "content_same": false
        },
        {
          "line": 1255,
          "old_api": "ExportAllocationsForRepacking",
          "new_api": "result_requires_uncommit",
          "old_text": "ExportAllocationsForRepacking(repack_allocation_blocks)",
          "new_text": "result_requires_uncommit(result)",
          "old_line_content": "        ExportAllocationsForRepacking(repack_allocation_blocks);",
          "new_line_content": "      if (result_requires_uncommit(result) ||",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": "VLOG",
          "new_api": "result_failed_because_of_async_copy",
          "old_text": "VLOG(2)",
          "new_text": "result_failed_because_of_async_copy(result)",
          "old_line_content": "        VLOG(2) << \"Repacking.\";",
          "new_line_content": "          (!final_retry && result_failed_because_of_async_copy(result))) {",
          "content_same": false
        },
        {
          "line": 1258,
          "old_api": "absl::MakeSpan(repack_allocation_blocks)",
          "new_api": "VLOG",
          "old_text": "absl::MakeSpan(repack_allocation_blocks)",
          "new_text": "VLOG(2)",
          "old_line_content": "            options_.repacker->Repack(absl::MakeSpan(repack_allocation_blocks));",
          "new_line_content": "        VLOG(2) << \"Couldn't allocate. Retry number \" << retry_number;",
          "content_same": false
        },
        {
          "line": 1259,
          "old_api": "Status::OK()",
          "new_api": "result_is",
          "old_text": "Status::OK()",
          "new_text": "result_is(result, Result::kFailOutOfMemory)",
          "old_line_content": "        CHECK_EQ(repack_status.status(), Status::OK());",
          "new_line_content": "      } else if ((result_is(result, Result::kFailOutOfMemory) ||",
          "content_same": false
        },
        {
          "line": 1262,
          "old_api": "ImportRepackedAllocations",
          "new_api": "absl::MakeSpan(allocation_values)",
          "old_text": "ImportRepackedAllocations()",
          "new_text": "absl::MakeSpan(allocation_values)",
          "old_line_content": "          ImportRepackedAllocations();",
          "new_line_content": "        UncommitPendingChunks(absl::MakeSpan(allocation_values));",
          "content_same": false
        },
        {
          "line": 1272,
          "old_api": "VLOG",
          "new_api": "Status::OK()",
          "old_text": "VLOG(3)",
          "new_text": "Status::OK()",
          "old_line_content": "  VLOG(3) << \"Debug buffer info: \";",
          "new_line_content": "        CHECK_EQ(repack_status.status(), Status::OK());",
          "content_same": false
        },
        {
          "line": 1273,
          "old_api": "XLA_VLOG_LINES",
          "new_api": "VLOG",
          "old_text": "XLA_VLOG_LINES(3, buffer_info_str_)",
          "new_text": "VLOG(2)",
          "old_line_content": "  XLA_VLOG_LINES(3, buffer_info_str_);",
          "new_line_content": "        VLOG(2) << \"Repack complete. Modified = \" << *repack_status;",
          "content_same": false
        },
        {
          "line": 1275,
          "old_api": "XLA_VLOG_LINES",
          "new_api": "ImportRepackedAllocations",
          "old_text": "XLA_VLOG_LINES(3, allocation_info_str_)",
          "new_text": "ImportRepackedAllocations()",
          "old_line_content": "  XLA_VLOG_LINES(3, allocation_info_str_);",
          "new_line_content": "          ImportRepackedAllocations();",
          "content_same": false
        },
        {
          "line": 1293,
          "old_api": "VLOG",
          "new_api": "std::move(result_)",
          "old_text": "VLOG(3)",
          "new_text": "std::move(result_)",
          "old_line_content": "        VLOG(3) << \"Adding required assignment for condition output: \"",
          "new_line_content": "  result.heap_results.emplace_back(std::move(result_));",
          "content_same": false
        },
        {
          "line": 1328,
          "old_api": "uses",
          "new_api": "FindAliases",
          "old_text": "allocation_value.uses()",
          "new_text": "FindAliases(&allocation_values, /*skip_values_with_no_uses=*/true)",
          "old_line_content": "    absl::c_transform(allocation_value.uses(),",
          "new_line_content": "  FindAliases(&allocation_values, /*skip_values_with_no_uses=*/true);",
          "content_same": false
        },
        {
          "line": 1356,
          "old_api": "at",
          "new_api": "defining_instruction",
          "old_text": "instruction_schedule.at(hlo_use.instruction)",
          "new_text": "allocation_value.defining_instruction()",
          "old_line_content": "      int64 use_time = instruction_schedule.at(hlo_use.instruction);",
          "new_line_content": "        instruction_schedule.at(allocation_value.defining_instruction());",
          "content_same": false
        },
        {
          "line": 1367,
          "old_api": "called_computations",
          "new_api": "uses",
          "old_text": "hlo_use.instruction->called_computations()",
          "new_text": "allocation_value.uses().at(use_idx)",
          "old_line_content": "             hlo_use.instruction->called_computations()) {",
          "new_line_content": "      const AllocationValue::Use& use = allocation_value.uses().at(use_idx);",
          "content_same": false
        },
        {
          "line": 1369,
          "old_api": "computation_span_times",
          "new_api": "at",
          "old_text": "hlo_live_range_.computation_span_times().at(called_computation)",
          "new_text": "instruction_schedule.at(hlo_use.instruction)",
          "old_line_content": "              hlo_live_range_.computation_span_times().at(called_computation);",
          "new_line_content": "      int64 use_time = instruction_schedule.at(hlo_use.instruction);",
          "content_same": false
        },
        {
          "line": 1409,
          "old_api": "called_computations",
          "new_api": "root_instruction",
          "old_text": "hlo_use.instruction->called_computations()",
          "new_text": "while_body->root_instruction()",
          "old_line_content": "               hlo_use.instruction->called_computations()) {",
          "new_line_content": "          CHECK_EQ(instruction_schedule.at(while_body->root_instruction()) + 1,",
          "content_same": false
        },
        {
          "line": 1450,
          "old_api": "parent",
          "new_api": "ToString",
          "old_text": "hlo_use.instruction->parent()->root_instruction()",
          "new_text": "previous_use.hlo_use.ToString()",
          "old_line_content": "              hlo_use.instruction->parent()->root_instruction()) {",
          "new_line_content": "          VLOG(3) << \"Previous use (\" << previous_use.hlo_use.ToString()",
          "content_same": false
        },
        {
          "line": 1494,
          "old_api": "GetAliasedOffset",
          "new_api": "allocation_sequence",
          "old_text": "GetAliasedOffset(*aliased_allocation)",
          "new_text": "allocation_value.allocation_sequence()",
          "old_line_content": "            GetAliasedOffset(*aliased_allocation);",
          "new_line_content": "          GetLiveAllocationAt(*allocation_value.allocation_sequence(),",
          "content_same": false
        },
        {
          "line": 1507,
          "old_api": "insert",
          "new_api": "GetAliasedOffset",
          "old_text": "ranges_.insert(copy)",
          "new_text": "GetAliasedOffset(*aliased_allocation)",
          "old_line_content": "  auto it_and_inserted = ranges_.insert(copy);",
          "new_line_content": "            GetAliasedOffset(*aliased_allocation);",
          "content_same": false
        },
        {
          "line": 1526,
          "old_api": "end",
          "new_api": "find",
          "old_text": "ranges_.end()",
          "new_text": "ranges_.find(copy)",
          "old_line_content": "  if (copy_it != ranges_.end() && copy_it->start_time != start_time) {",
          "new_line_content": "  auto copy_it = ranges_.find(copy);",
          "content_same": false
        },
        {
          "line": 1527,
          "old_api": "VLOG",
          "new_api": "end",
          "old_text": "VLOG(4)",
          "new_text": "ranges_.end()",
          "old_line_content": "    VLOG(4) << \"Violates ordering: (\" << start_time << \", \" << end_time",
          "new_line_content": "  CHECK(copy_it != ranges_.end());",
          "content_same": false
        },
        {
          "line": 1552,
          "old_api": "chunk",
          "new_api": "end",
          "old_text": "allocation.chunk()",
          "new_text": "aliased_offset_map_.end()",
          "old_line_content": "  CHECK_EQ(allocation.chunk().offset, aliased_offset->offset);",
          "new_line_content": "  CHECK(aliased_offset_it != aliased_offset_map_.end());",
          "content_same": false
        },
        {
          "line": 1560,
          "old_api": "rbegin",
          "new_api": "contains",
          "old_text": "allocations.rbegin()",
          "new_text": "aliased_offset_map_.contains(&allocation)",
          "old_line_content": "  for (auto allocation_it = allocations.rbegin();",
          "new_line_content": "  CHECK(!aliased_offset_map_.contains(&allocation));",
          "content_same": false
        },
        {
          "line": 1562,
          "old_api": "start_time",
          "new_api": "chunk",
          "old_text": "*allocation_it)->start_time()",
          "new_text": "allocation.chunk()",
          "old_line_content": "    if ((*allocation_it)->start_time() <= time &&",
          "new_line_content": "    aliased_offsets_.push_back({allocation.chunk().offset});",
          "content_same": false
        },
        {
          "line": 1563,
          "old_api": "end_time",
          "new_api": "back",
          "old_text": "*allocation_it)->end_time()",
          "new_text": "aliased_offsets_.back()",
          "old_line_content": "        (*allocation_it)->end_time() >= time) {",
          "new_line_content": "    aliased_offset = &aliased_offsets_.back();",
          "content_same": false
        },
        {
          "line": 1576,
          "old_api": "FindChunkCandidate",
          "new_api": "end_time",
          "old_text": "FindChunkCandidate(*prefetch_candidate)",
          "new_text": "*allocation_it)->end_time()",
          "old_line_content": "  ChunkCandidate chunk_candidate = FindChunkCandidate(*prefetch_candidate);",
          "new_line_content": "        (*allocation_it)->end_time() >= time) {",
          "content_same": false
        },
        {
          "line": 1591,
          "old_api": "defining_position",
          "new_api": "available_heap_size",
          "old_text": "buffer->defining_position()",
          "new_text": "available_heap_size()",
          "old_line_content": "      buffer->defining_position(), MemorySpace::kDefault, kDummyChunk,",
          "new_line_content": "      chunk_candidate.heap_size > available_heap_size()) {",
          "content_same": false
        },
        {
          "line": 1596,
          "old_api": "instruction_schedule",
          "new_api": "AddToPendingChunks",
          "old_text": "hlo_live_range_.instruction_schedule()",
          "new_text": "AddToPendingChunks(*prefetch_candidate, chunk_candidate)",
          "old_line_content": "  const auto& instruction_schedule = hlo_live_range_.instruction_schedule();",
          "new_line_content": "  AddToPendingChunks(*prefetch_candidate, chunk_candidate);",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": "at",
          "new_api": "instruction",
          "old_text": "instruction_schedule.at(lhs.instruction)",
          "new_text": "buffer->instruction()->parameter_number()",
          "old_line_content": "    return instruction_schedule.at(lhs.instruction) <",
          "new_line_content": "  int64 parameter = buffer->instruction()->parameter_number();",
          "content_same": false
        },
        {
          "line": 1600,
          "old_api": "at",
          "new_api": "index",
          "old_text": "instruction_schedule.at(rhs.instruction)",
          "new_text": "buffer->index()",
          "old_line_content": "           instruction_schedule.at(rhs.instruction);",
          "new_line_content": "  module->AddCrossProgramPrefetch(parameter, buffer->index());",
          "content_same": false
        },
        {
          "line": 1603,
          "old_api": "at",
          "new_api": "defining_position",
          "old_text": "instruction_schedule.at(first_use->instruction)",
          "new_text": "absl::make_unique<MemorySpaceAssignment::Allocation>(\n      buffer->defining_position(), MemorySpace::kDefault, kDummyChunk,\n      prefetch_candidate->start, prefetch_candidate->end,\n      /*is_scoped_allocation=*/false)",
          "old_line_content": "  int64 latest_prefetch_time = instruction_schedule.at(first_use->instruction);",
          "new_line_content": "  allocations.push_back(absl::make_unique<MemorySpaceAssignment::Allocation>(",
          "content_same": false
        },
        {
          "line": 1609,
          "old_api": "at",
          "new_api": "instruction_schedule",
          "old_text": "std::max(\n        last_use_time,\n        instruction_schedule.at(\n            absl::c_max_element(colocation->uses(), use_schedule_compare)\n                ->instruction))",
          "new_text": "hlo_live_range_.instruction_schedule()",
          "old_line_content": "    last_use_time = std::max(",
          "new_line_content": "  const auto& instruction_schedule = hlo_live_range_.instruction_schedule();",
          "content_same": false
        },
        {
          "line": 1612,
          "old_api": "uses",
          "new_api": "at",
          "old_text": "colocation->uses()",
          "new_text": "instruction_schedule.at(lhs.instruction)",
          "old_line_content": "            absl::c_max_element(colocation->uses(), use_schedule_compare)",
          "new_line_content": "    return instruction_schedule.at(lhs.instruction) <",
          "content_same": false
        },
        {
          "line": 1616,
          "old_api": "size",
          "new_api": "at",
          "old_text": "instruction_schedule.size()",
          "new_text": "instruction_schedule.at(first_use->instruction)",
          "old_line_content": "  int64 end_of_program_prefetch_end_time = instruction_schedule.size() - 1;",
          "new_line_content": "  int64 latest_prefetch_time = instruction_schedule.at(first_use->instruction);",
          "content_same": false
        },
        {
          "line": 1619,
          "old_api": "shape",
          "new_api": "at",
          "old_text": "buffer->defining_position().shape()",
          "new_text": "instruction_schedule.at(\n      absl::c_max_element(uses, use_schedule_compare)->instruction)",
          "old_line_content": "          buffer->defining_position().shape(), last_use_time,",
          "new_line_content": "  int64 last_use_time = instruction_schedule.at(",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": "std::move(allocation)",
          "new_api": "VLOG",
          "old_text": "std::move(allocation)",
          "new_text": "VLOG(2)",
          "old_line_content": "    allocations_->push_back(std::move(allocation));",
          "new_line_content": "    VLOG(2) << \"Adding an end-of-program prefetch for freed \"",
          "content_same": false
        },
        {
          "line": 1660,
          "old_api": "memory_space",
          "new_api": "back",
          "old_text": "allocation->memory_space()",
          "new_text": "CHECK_EQ(cross_program_prefetch_offset->offset,\n             allocations.back()->chunk().offset)",
          "old_line_content": "    if (allocation->memory_space() == MemorySpace::kAlternate) {",
          "new_line_content": "    CHECK_EQ(cross_program_prefetch_offset->offset,",
          "content_same": false
        },
        {
          "line": 1661,
          "old_api": "size",
          "new_api": "back",
          "old_text": "MakeRepackAllocationBlock(\n          allocation->start_time(), allocation->end_time(),\n          allocation->chunk().size, allocation->chunk().offset,\n          static_cast<int64>(repack_allocation_blocks_.size()),\n          allocation.get())",
          "new_text": "allocations.back()->chunk()",
          "old_line_content": "      repack_allocation_blocks_.push_back(MakeRepackAllocationBlock(",
          "new_line_content": "             allocations.back()->chunk().offset);",
          "content_same": false
        },
        {
          "line": 1666,
          "old_api": "back",
          "new_api": "std::move(allocation)",
          "old_text": "repack_allocation_blocks_.back()",
          "new_text": "std::move(allocation)",
          "old_line_content": "      RepackAllocationBlock* inserted = &repack_allocation_blocks_.back();",
          "new_line_content": "    allocations_->push_back(std::move(allocation));",
          "content_same": false
        },
        {
          "line": 1676,
          "old_api": "ClearPendingChunks",
          "new_api": "chunk",
          "old_text": "ClearPendingChunks()",
          "new_text": "allocation->chunk()",
          "old_line_content": "  ClearPendingChunks();",
          "new_line_content": "          allocation->chunk().size, allocation->chunk().offset,",
          "content_same": false
        },
        {
          "line": 1681,
          "old_api": "flattened_instruction_sequence",
          "new_api": "push_back",
          "old_text": "hlo_live_range_.flattened_instruction_sequence().instructions()",
          "new_text": "colocation.colocations.push_back(inserted)",
          "old_line_content": "      hlo_live_range_.flattened_instruction_sequence().instructions();",
          "new_line_content": "        colocation.colocations.push_back(inserted);",
          "content_same": false
        },
        {
          "line": 1683,
          "old_api": "size",
          "new_api": "push_back",
          "old_text": "instruction_sequence.size()",
          "new_text": "inserted->colocations.push_back(&colocation)",
          "old_line_content": "  for (int i = 0; i < instruction_sequence.size(); ++i) {",
          "new_line_content": "          inserted->colocations.push_back(&colocation);",
          "content_same": false
        },
        {
          "line": 1698,
          "old_api": "FindChunkCandidate",
          "new_api": "reserved_scoped_memory_fn",
          "old_text": "FindChunkCandidate(interval, /*preferred_offset=*/0)",
          "new_text": "options_.reserved_scoped_memory_fn(instruction_sequence[i])",
          "old_line_content": "          FindChunkCandidate(interval, /*preferred_offset=*/0);",
          "new_line_content": "        options_.reserved_scoped_memory_fn(instruction_sequence[i]);",
          "content_same": false
        },
        {
          "line": 1700,
          "old_api": "AddToPendingChunks",
          "new_api": "VLOG",
          "old_text": "AddToPendingChunks(interval, chunk_candidate)",
          "new_text": "VLOG(1)",
          "old_line_content": "      AddToPendingChunks(interval, chunk_candidate);",
          "new_line_content": "      VLOG(1) << \"Allocate reserved scoped memory at \" << i << \" (\"",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": "get",
          "new_api": "FindChunkCandidate",
          "old_text": "allocations_->back().get()",
          "new_text": "FindChunkCandidate(interval, /*preferred_offset=*/0)",
          "old_line_content": "          allocations_->back().get()));",
          "new_line_content": "          FindChunkCandidate(interval, /*preferred_offset=*/0);",
          "content_same": false
        },
        {
          "line": 1712,
          "old_api": "back",
          "new_api": "CHECK_EQ",
          "old_text": "repack_allocation_blocks_.back()",
          "new_text": "CHECK_EQ(chunk_candidate.chunk.offset, 0)",
          "old_line_content": "      colocations.push_back(&repack_allocation_blocks_.back());",
          "new_line_content": "      CHECK_EQ(chunk_candidate.chunk.offset, 0);",
          "content_same": false
        },
        {
          "line": 1774,
          "old_api": "GetAliasedOffset",
          "new_api": "equals_ignoring_time",
          "old_text": "GetAliasedOffset(*aliased_allocation)",
          "new_text": "CHECK(required_assignment_for_alias == absl::nullopt ||\n            required_assignment->equals_ignoring_time(\n                *required_assignment_for_alias))",
          "old_line_content": "    offset = GetAliasedOffset(*aliased_allocation);",
          "new_line_content": "      CHECK(required_assignment_for_alias == absl::nullopt ||",
          "content_same": false
        },
        {
          "line": 1786,
          "old_api": "RequiredMemoryAssignmentAt",
          "new_api": "memory_space",
          "old_text": "RequiredMemoryAssignmentAt(value, time)",
          "new_text": "aliased_allocation->memory_space()",
          "old_line_content": "  auto existing_required_assignment = RequiredMemoryAssignmentAt(value, time);",
          "new_line_content": "  if (aliased_allocation->memory_space() == MemorySpace::kAlternate) {",
          "content_same": false
        },
        {
          "line": 1789,
          "old_api": "ToString",
          "new_api": "memory_space",
          "old_text": "instruction->ToString()",
          "new_text": "aliased_allocation->memory_space()",
          "old_line_content": "        << \"inst = \" << instruction->ToString() << \" at \" << time;",
          "new_line_content": "  AddRequiredAssignment(instruction, index, aliased_allocation->memory_space(),",
          "content_same": false
        },
        {
          "line": 1801,
          "old_api": "push_back",
          "new_api": "CHECK",
          "old_text": "pending_required_assignments_.push_back({value, required_assignment})",
          "new_text": "CHECK(memory_space == existing_required_assignment->memory_space)",
          "old_line_content": "    pending_required_assignments_.push_back({value, required_assignment});",
          "new_line_content": "    CHECK(memory_space == existing_required_assignment->memory_space)",
          "content_same": false
        },
        {
          "line": 1809,
          "old_api": "dataflow_analysis",
          "new_api": "ToShortString",
          "old_text": "alias_analysis_.dataflow_analysis().GetUniqueValueAt(instruction, index)",
          "new_text": "value->ToShortString()",
          "old_line_content": "      &alias_analysis_.dataflow_analysis().GetUniqueValueAt(instruction, index);",
          "new_line_content": "    VLOG(3) << \"Adding required assignment: \" << value->ToShortString()",
          "content_same": false
        },
        {
          "line": 1825,
          "old_api": "at",
          "new_api": "AddRequiredAssignment",
          "old_text": "instruction_schedule.at(parameter_instruction)",
          "new_text": "AddRequiredAssignment(value, instruction, memory_space, instruction_time,\n                        offset)",
          "old_line_content": "        instruction_schedule.at(parameter_instruction);",
          "new_line_content": "  AddRequiredAssignment(value, instruction, memory_space, instruction_time,",
          "content_same": false
        },
        {
          "line": 1836,
          "old_api": "values",
          "new_api": "parameter_instructions",
          "old_text": "buffer->values()",
          "new_text": "entry_computation->parameter_instructions()",
          "old_line_content": "            for (const HloValue* value : buffer->values()) {",
          "new_line_content": "       entry_computation->parameter_instructions()) {",
          "content_same": false
        },
        {
          "line": 1838,
          "old_api": "ToShortString",
          "new_api": "at",
          "old_text": "value->ToShortString()",
          "new_text": "instruction_schedule.at(parameter_instruction)",
          "old_line_content": "                      << value->ToShortString()",
          "new_line_content": "        instruction_schedule.at(parameter_instruction);",
          "content_same": false
        },
        {
          "line": 1848,
          "old_api": "root_instruction",
          "new_api": "ComputeBuffersAt",
          "old_text": "entry_computation->root_instruction()",
          "new_text": "alias_analysis_.ComputeBuffersAt(parameter_instruction, index)",
          "old_line_content": "  HloInstruction* root_instruction = entry_computation->root_instruction();",
          "new_line_content": "               alias_analysis_.ComputeBuffersAt(parameter_instruction, index)) {",
          "content_same": false
        },
        {
          "line": 1849,
          "old_api": "at",
          "new_api": "values",
          "old_text": "instruction_schedule.at(root_instruction)",
          "new_text": "buffer->values()",
          "old_line_content": "  int64 root_instruction_time = instruction_schedule.at(root_instruction);",
          "new_line_content": "            for (const HloValue* value : buffer->values()) {",
          "content_same": false
        },
        {
          "line": 1850,
          "old_api": "has_layout",
          "new_api": "VLOG",
          "old_text": "ShapeUtil::ForEachSubshape(\n      root_instruction->shape(),\n      [&](const Shape& subshape, const ShapeIndex& index) {\n        MemorySpace memory_space = MemorySpace::kDefault;\n        if (subshape.has_layout() && subshape.layout().memory_space() ==\n                                         options_.alternate_memory_space) {\n          memory_space = MemorySpace::kAlternate;\n        }\n        for (const HloBuffer* buffer :\n             alias_analysis_.ComputeBuffersAt(root_instruction, index)) {\n          for (const HloValue* value : buffer->values()) {\n            VLOG(3) << \"Adding required assignment for output value = \"\n                    << value->ToShortString()\n                    << \" time = \" << root_instruction_time << \" space = \"\n                    << (memory_space == MemorySpace::kDefault ? \"def\" : \"alt\");\n            required_assignments_[value].push_back(\n                {memory_space, /*time=*/root_instruction_time});\n          }\n        }\n      })",
          "new_text": "VLOG(3)",
          "old_line_content": "  ShapeUtil::ForEachSubshape(",
          "new_line_content": "              VLOG(3) << \"Adding required assignment for parameter value = \"",
          "content_same": false
        },
        {
          "line": 1851,
          "old_api": "shape",
          "new_api": "ToShortString",
          "old_text": "root_instruction->shape()",
          "new_text": "value->ToShortString()",
          "old_line_content": "      root_instruction->shape(),",
          "new_line_content": "                      << value->ToShortString()",
          "content_same": false
        },
        {
          "line": 1861,
          "old_api": "VLOG",
          "new_api": "root_instruction",
          "old_text": "VLOG(3)",
          "new_text": "entry_computation->root_instruction()",
          "old_line_content": "            VLOG(3) << \"Adding required assignment for output value = \"",
          "new_line_content": "  HloInstruction* root_instruction = entry_computation->root_instruction();",
          "content_same": false
        },
        {
          "line": 1862,
          "old_api": "ToShortString",
          "new_api": "at",
          "old_text": "value->ToShortString()",
          "new_text": "instruction_schedule.at(root_instruction)",
          "old_line_content": "                    << value->ToShortString()",
          "new_line_content": "  int64 root_instruction_time = instruction_schedule.at(root_instruction);",
          "content_same": false
        },
        {
          "line": 1875,
          "old_api": "shape",
          "new_api": "ToShortString",
          "old_text": "position.shape()",
          "new_text": "value->ToShortString()",
          "old_line_content": "    const Shape& shape = position.shape();",
          "new_line_content": "                    << value->ToShortString()",
          "content_same": false
        },
        {
          "line": 1888,
          "old_api": "defining_position",
          "new_api": "shape",
          "old_text": "value->defining_position()",
          "new_text": "position.shape()",
          "old_line_content": "        is_position_in_alternate_memory(value->defining_position())) {",
          "new_line_content": "    const Shape& shape = position.shape();",
          "content_same": false
        },
        {
          "line": 1894,
          "old_api": "is_position_in_alternate_memory",
          "new_api": "entry_computation",
          "old_text": "is_position_in_alternate_memory(position)",
          "new_text": "module.entry_computation()",
          "old_line_content": "          is_position_in_alternate_memory(position)) {",
          "new_line_content": "  const HloComputation* entry_computation = module.entry_computation();",
          "content_same": false
        },
        {
          "line": 1905,
          "old_api": "push_back",
          "new_api": "positions",
          "old_text": "allocations.push_back(&allocation_block)",
          "new_text": "value->positions()",
          "old_line_content": "    allocations.push_back(&allocation_block);",
          "new_line_content": "    for (const HloPosition& position : value->positions()) {",
          "content_same": false
        },
        {
          "line": 1918,
          "old_api": "mutable_chunk",
          "new_api": "push_back",
          "old_text": "allocation_block.allocation->mutable_chunk()",
          "new_text": "allocations.push_back(&allocation_block)",
          "old_line_content": "    allocation_block.allocation->mutable_chunk()->offset =",
          "new_line_content": "    allocations.push_back(&allocation_block);",
          "content_same": false
        },
        {
          "line": 1945,
          "old_api": "RemoveCopy",
          "new_api": "allocation_sequence",
          "old_text": "async_copy_ordering_.RemoveCopy(interval)",
          "new_text": "allocation_value.allocation_sequence()->clear()",
          "old_line_content": "      async_copy_ordering_.RemoveCopy(interval);",
          "new_line_content": "    allocation_value.allocation_sequence()->clear();",
          "content_same": false
        },
        {
          "line": 2000,
          "old_api": "size",
          "new_api": "memory_space",
          "old_text": "MakeRepackAllocationBlock(\n          colocated_allocation->start_time(), colocated_allocation->end_time(),\n          colocated_allocation->chunk().size,\n          colocated_allocation->chunk().offset,\n          static_cast<int64>(repack_allocation_blocks_.size()),\n          colocated_allocation)",
          "new_text": "inserted_allocation->memory_space()",
          "old_line_content": "      repack_allocation_blocks_.push_back(MakeRepackAllocationBlock(",
          "new_line_content": "      if (inserted_allocation->memory_space() == MemorySpace::kAlternate) {",
          "content_same": false
        },
        {
          "line": 2001,
          "old_api": "end_time",
          "new_api": "GetAliasedOffset",
          "old_text": "colocated_allocation->end_time()",
          "new_text": "GetAliasedOffset(*inserted_allocation)",
          "old_line_content": "          colocated_allocation->start_time(), colocated_allocation->end_time(),",
          "new_line_content": "        colocation_map[GetAliasedOffset(*inserted_allocation)].push_back(",
          "content_same": false
        },
        {
          "line": 2013,
          "old_api": "ClearPendingChunks",
          "new_api": "size",
          "old_text": "ClearPendingChunks()",
          "new_text": "MakeRepackAllocationBlock(\n          colocated_allocation->start_time(), colocated_allocation->end_time(),\n          colocated_allocation->chunk().size,\n          colocated_allocation->chunk().offset,\n          static_cast<int64>(repack_allocation_blocks_.size()),\n          colocated_allocation)",
          "old_line_content": "  ClearPendingChunks();",
          "new_line_content": "      repack_allocation_blocks_.push_back(MakeRepackAllocationBlock(",
          "content_same": false
        },
        {
          "line": 2017,
          "old_api": "clear",
          "new_api": "size",
          "old_text": "pending_chunks_.clear()",
          "new_text": "repack_allocation_blocks_.size()",
          "old_line_content": "  pending_chunks_.clear();",
          "new_line_content": "          static_cast<int64>(repack_allocation_blocks_.size()),",
          "content_same": false
        },
        {
          "line": 2019,
          "old_api": "clear",
          "new_api": "back",
          "old_text": "pending_required_assignments_.clear()",
          "new_text": "repack_allocation_blocks_.back()",
          "old_line_content": "  pending_required_assignments_.clear();",
          "new_line_content": "      colocations.push_back(&repack_allocation_blocks_.back());",
          "content_same": false
        },
        {
          "line": 2030,
          "old_api": "emplace_back",
          "new_api": "clear",
          "old_text": "pending_chunks_.emplace_back(buffer_interval, chunk_candidate)",
          "new_text": "pending_chunks_.clear()",
          "old_line_content": "  pending_chunks_.emplace_back(buffer_interval, chunk_candidate);",
          "new_line_content": "  pending_chunks_.clear();",
          "content_same": false
        },
        {
          "line": 2031,
          "old_api": "CommitChunk",
          "new_api": "clear",
          "old_text": "CommitChunk(buffer_interval, chunk_candidate)",
          "new_text": "pending_async_copies_.clear()",
          "old_line_content": "  CommitChunk(buffer_interval, chunk_candidate);",
          "new_line_content": "  pending_async_copies_.clear();",
          "content_same": false
        },
        {
          "line": 2043,
          "old_api": "CHECK_NE",
          "new_api": "emplace_back",
          "old_text": "CHECK_NE(allocation, nullptr)",
          "new_text": "pending_chunks_.emplace_back(buffer_interval, chunk_candidate)",
          "old_line_content": "    CHECK_NE(allocation, nullptr);",
          "new_line_content": "  pending_chunks_.emplace_back(buffer_interval, chunk_candidate);",
          "content_same": false
        },
        {
          "line": 2044,
          "old_api": "AddUse",
          "new_api": "CommitChunk",
          "old_text": "allocation->AddUse(request.use->hlo_use)",
          "new_text": "CommitChunk(buffer_interval, chunk_candidate)",
          "old_line_content": "    allocation->AddUse(request.use->hlo_use);",
          "new_line_content": "  CommitChunk(buffer_interval, chunk_candidate);",
          "content_same": false
        },
        {
          "line": 2049,
          "old_api": "defining_position",
          "new_api": "allocation_sequence",
          "old_text": "request.allocation_value->defining_position()",
          "new_text": "request.allocation_value->allocation_sequence()",
          "old_line_content": "      request.allocation_value->defining_position();",
          "new_line_content": "  auto allocation_sequence = request.allocation_value->allocation_sequence();",
          "content_same": false
        },
        {
          "line": 2055,
          "old_api": "ToString",
          "new_api": "GetLiveAllocationAt",
          "old_text": "request.use->hlo_use.ToString()",
          "new_text": "GetLiveAllocationAt(*allocation_sequence, request.end_time)",
          "old_line_content": "          << \" use = \" << request.use->hlo_use.ToString()",
          "new_line_content": "        GetLiveAllocationAt(*allocation_sequence, request.end_time);",
          "content_same": false
        },
        {
          "line": 2057,
          "old_api": "ToString",
          "new_api": "AddUse",
          "old_text": "defining_position.ToString()",
          "new_text": "allocation->AddUse(request.use->hlo_use)",
          "old_line_content": "          << \", def pos = \" << defining_position.ToString();",
          "new_line_content": "    allocation->AddUse(request.use->hlo_use);",
          "content_same": false
        },
        {
          "line": 2094,
          "old_api": "rend",
          "new_api": "equals_ignoring_time",
          "old_text": "allocation_sequence->rend()",
          "new_text": "CHECK(aliased_required_assignment_at_end == absl::nullopt ||\n            aliased_required_assignment_at_end->equals_ignoring_time(\n                *required_assignment_at_end))",
          "old_line_content": "          allocation_sequence->rbegin(), allocation_sequence->rend(),",
          "new_line_content": "      CHECK(aliased_required_assignment_at_end == absl::nullopt ||",
          "content_same": false
        },
        {
          "line": 2109,
          "old_api": "push_back",
          "new_api": "memory_space",
          "old_text": "allocation_sequence->push_back(\n          absl::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, required_assignment_at_start->memory_space,\n              aliased_chunk, request.start_time, request.start_time,\n              /*is_scoped_allocation=*/false))",
          "new_text": "allocation->memory_space()",
          "old_line_content": "      allocation_sequence->push_back(",
          "new_line_content": "            return allocation->memory_space() ==",
          "content_same": false
        },
        {
          "line": 2140,
          "old_api": "defining_position",
          "new_api": "AllocateInAlternateMemoryNoCopy",
          "old_text": "allocation->defining_position()",
          "new_text": "AllocateInAlternateMemoryNoCopy(request)",
          "old_line_content": "               allocation->defining_position() == defining_position;",
          "new_line_content": "    allocation_result = AllocateInAlternateMemoryNoCopy(request);",
          "content_same": false
        },
        {
          "line": 2146,
          "old_api": "defining_position",
          "new_api": "rbegin",
          "old_text": "*prev_allocation_it)->defining_position()",
          "new_text": "allocation_sequence->rbegin()",
          "old_line_content": "      (*prev_allocation_it)->defining_position() == defining_position &&",
          "new_line_content": "  auto prev_allocation_it = allocation_sequence->rbegin();",
          "content_same": false
        },
        {
          "line": 2150,
          "old_api": "Evict",
          "new_api": "rend",
          "old_text": "Evict(request)",
          "new_text": "allocation_sequence->rend()",
          "old_line_content": "    Result eviction_result = Evict(request);",
          "new_line_content": "      allocation_sequence->rbegin(), allocation_sequence->rend(),",
          "content_same": false
        },
        {
          "line": 2153,
          "old_api": "result_mark",
          "new_api": "defining_position",
          "old_text": "result_mark(Result::kFailRequiresUncommit, eviction_result)",
          "new_text": "allocation->defining_position()",
          "old_line_content": "      return result_mark(Result::kFailRequiresUncommit, eviction_result);",
          "new_line_content": "               allocation->defining_position() == defining_position;",
          "content_same": false
        },
        {
          "line": 2157,
          "old_api": "push_back",
          "new_api": "rend",
          "old_text": "allocation_sequence->push_back(\n        absl::make_unique<MemorySpaceAssignment::Allocation>(\n            defining_position, MemorySpace::kDefault, /*chunk=*/absl::nullopt,\n            request.start_time, request.end_time,\n            /*is_scoped_allocation=*/false))",
          "new_text": "allocation_sequence->rend()",
          "old_line_content": "    allocation_sequence->push_back(",
          "new_line_content": "      prev_allocation_it != allocation_sequence->rend() &&",
          "content_same": false
        },
        {
          "line": 2158,
          "old_api": "absl::make_unique<MemorySpaceAssignment::Allocation>(\n            defining_position, MemorySpace::kDefault, /*chunk=*/absl::nullopt,\n            request.start_time, request.end_time,\n            /*is_scoped_allocation=*/false)",
          "new_api": "memory_space",
          "old_text": "absl::make_unique<MemorySpaceAssignment::Allocation>(\n            defining_position, MemorySpace::kDefault, /*chunk=*/absl::nullopt,\n            request.start_time, request.end_time,\n            /*is_scoped_allocation=*/false)",
          "new_text": "*prev_allocation_it)->memory_space()",
          "old_line_content": "        absl::make_unique<MemorySpaceAssignment::Allocation>(",
          "new_line_content": "      (*prev_allocation_it)->memory_space() == MemorySpace::kAlternate &&",
          "content_same": false
        },
        {
          "line": 2166,
          "old_api": "memory_space",
          "new_api": "result_mark",
          "old_text": "*prev_allocation_in_default_mem_it)->memory_space()",
          "new_text": "result_mark(Result::kFailRequiresUncommit, eviction_result)",
          "old_line_content": "  CHECK((*prev_allocation_in_default_mem_it)->memory_space() ==",
          "new_line_content": "      return result_mark(Result::kFailRequiresUncommit, eviction_result);",
          "content_same": false
        },
        {
          "line": 2171,
          "old_api": "VLOG",
          "new_api": "absl::make_unique<MemorySpaceAssignment::Allocation>(\n            defining_position, MemorySpace::kDefault, /*chunk=*/absl::nullopt,\n            request.start_time, request.end_time,\n            /*is_scoped_allocation=*/false)",
          "old_text": "VLOG(3)",
          "new_text": "absl::make_unique<MemorySpaceAssignment::Allocation>(\n            defining_position, MemorySpace::kDefault, /*chunk=*/absl::nullopt,\n            request.start_time, request.end_time,\n            /*is_scoped_allocation=*/false)",
          "old_line_content": "    VLOG(3)",
          "new_line_content": "        absl::make_unique<MemorySpaceAssignment::Allocation>(",
          "content_same": false
        },
        {
          "line": 2179,
          "old_api": "requires_contiguous_allocation",
          "new_api": "memory_space",
          "old_text": "request.allocation_value->requires_contiguous_allocation()",
          "new_text": "*prev_allocation_in_default_mem_it)->memory_space()",
          "old_line_content": "  if (!request.allocation_value->requires_contiguous_allocation()) {",
          "new_line_content": "  CHECK((*prev_allocation_in_default_mem_it)->memory_space() ==",
          "content_same": false
        },
        {
          "line": 2198,
          "old_api": "requires_contiguous_allocation",
          "new_api": "result_mark",
          "old_text": "request.allocation_value->requires_contiguous_allocation()",
          "new_text": "result_mark(prefetch_result, allocation_result)",
          "old_line_content": "      request.allocation_value->requires_contiguous_allocation()) {",
          "new_line_content": "    result_mark(prefetch_result, allocation_result);",
          "content_same": false
        },
        {
          "line": 2204,
          "old_api": "Extend",
          "new_api": "result_mark",
          "old_text": "*prev_allocation_in_default_mem_it)->Extend(request.end_time)",
          "new_text": "result_mark(Result::kFailRequiresUncommit, allocation_result)",
          "old_line_content": "  (*prev_allocation_in_default_mem_it)->Extend(request.end_time);",
          "new_line_content": "    return result_mark(Result::kFailRequiresUncommit, allocation_result);",
          "content_same": false
        },
        {
          "line": 2236,
          "old_api": "back",
          "new_api": "push_back",
          "old_text": "allocations->back()",
          "new_text": "allocations->push_back(\n      absl::make_unique<MemorySpaceAssignment::CopyAllocation>(\n          prev_allocation, memory_space, chunk, start_time, end_time,\n          copy_done_schedule_before_time, is_cross_program_prefetch))",
          "old_line_content": "    CreateOrAddToAliasedOffset(*allocations->back(), aliased_offset);",
          "new_line_content": "  allocations->push_back(",
          "content_same": false
        },
        {
          "line": 2366,
          "old_api": "AddToPendingChunks",
          "new_api": "FindBestChunkCandidate",
          "old_text": "AddToPendingChunks(alternate_mem_interval, *chunk_candidate)",
          "new_text": "FindBestChunkCandidate(\n      request, preferred_offset, &alternate_mem_interval)",
          "old_line_content": "    AddToPendingChunks(alternate_mem_interval, *chunk_candidate);",
          "new_line_content": "  absl::optional<ChunkCandidate> chunk_candidate = FindBestChunkCandidate(",
          "content_same": false
        },
        {
          "line": 2371,
          "old_api": "is_copy_allocation",
          "new_api": "VLOG",
          "old_text": "prev_allocation->is_copy_allocation()",
          "new_text": "VLOG(3)",
          "old_line_content": "        (prev_allocation->is_copy_allocation() ||",
          "new_line_content": "    VLOG(3) << \"Keep the buffer in alternate memory. Offset = \"",
          "content_same": false
        },
        {
          "line": 2376,
          "old_api": "absl::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, MemorySpace::kAlternate,\n              chunk_candidate->chunk, request.start_time, request.end_time,\n              /*is_scoped_allocation=*/false)",
          "new_api": "shape",
          "old_text": "absl::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, MemorySpace::kAlternate,\n              chunk_candidate->chunk, request.start_time, request.end_time,\n              /*is_scoped_allocation=*/false)",
          "new_text": "options_.prefetch_interval_picker->ToNoCopyDebugString(\n                   defining_position.shape(), request.start_time,\n                   request.end_time)",
          "old_line_content": "          absl::make_unique<MemorySpaceAssignment::Allocation>(",
          "new_line_content": "            << options_.prefetch_interval_picker->ToNoCopyDebugString(",
          "content_same": false
        },
        {
          "line": 2384,
          "old_api": "allocation_sequence",
          "new_api": "is_copy_allocation",
          "old_text": "request.allocation_value->allocation_sequence()->back()->AddUse(\n        request.use->hlo_use)",
          "new_text": "prev_allocation->is_copy_allocation()",
          "old_line_content": "    request.allocation_value->allocation_sequence()->back()->AddUse(",
          "new_line_content": "        (prev_allocation->is_copy_allocation() ||",
          "content_same": false
        },
        {
          "line": 2397,
          "old_api": "end_time",
          "new_api": "allocation_sequence",
          "old_text": "prev_allocation->end_time()",
          "new_text": "request.allocation_value->allocation_sequence()->back()->AddUse(\n        request.use->hlo_use)",
          "old_line_content": "  int64 eviction_end_time = prev_allocation->end_time();",
          "new_line_content": "    request.allocation_value->allocation_sequence()->back()->AddUse(",
          "content_same": false
        },
        {
          "line": 2410,
          "old_api": "value",
          "new_api": "end_time",
          "old_text": "request.allocation_value->value()",
          "new_text": "prev_allocation->end_time()",
          "old_line_content": "  eviction_mem_interval.buffer = request.allocation_value->value();",
          "new_line_content": "  int64 eviction_end_time = prev_allocation->end_time();",
          "content_same": false
        },
        {
          "line": 2423,
          "old_api": "FindChunkCandidate",
          "new_api": "value",
          "old_text": "FindChunkCandidate(eviction_mem_interval, preferred_offset)",
          "new_text": "request.allocation_value->value()",
          "old_line_content": "        FindChunkCandidate(eviction_mem_interval, preferred_offset);",
          "new_line_content": "  eviction_mem_interval.buffer = request.allocation_value->value();",
          "content_same": false
        },
        {
          "line": 2436,
          "old_api": "ViolatesMaximumOutstandingAsyncCopies",
          "new_api": "FindChunkCandidate",
          "old_text": "ViolatesMaximumOutstandingAsyncCopies(eviction_start_time,\n                                            eviction_end_time,\n                                            /*is_prefetch=*/false)",
          "new_text": "FindChunkCandidate(eviction_mem_interval, preferred_offset)",
          "old_line_content": "      ViolatesMaximumOutstandingAsyncCopies(eviction_start_time,",
          "new_line_content": "        FindChunkCandidate(eviction_mem_interval, preferred_offset);",
          "content_same": false
        },
        {
          "line": 2459,
          "old_api": "VLOG",
          "new_api": "allocation_sequence",
          "old_text": "VLOG(4)",
          "new_text": "request.allocation_value->allocation_sequence()",
          "old_line_content": "      VLOG(4) << \"Try evicting (\" << time << \", \" << time + 1 << \")\";",
          "new_line_content": "                 request.allocation_value->allocation_sequence(),",
          "content_same": false
        },
        {
          "line": 2463,
          "old_api": "allocation_sequence",
          "new_api": "VLOG",
          "old_text": "AddAsyncCopy(*prev_allocation, MemorySpace::kDefault,\n                     /*chunk=*/absl::nullopt, time, time + 1, time + 1,\n                     request.allocation_value->allocation_sequence(),\n                     /*aliased_offset=*/nullptr)",
          "new_text": "VLOG(3)",
          "old_line_content": "        AddAsyncCopy(*prev_allocation, MemorySpace::kDefault,",
          "new_line_content": "      VLOG(3) << \"This violates the maximum async copies.\";",
          "content_same": false
        },
        {
          "line": 2465,
          "old_api": "allocation_sequence",
          "new_api": "VLOG",
          "old_text": "request.allocation_value->allocation_sequence()",
          "new_text": "VLOG(3)",
          "old_line_content": "                     request.allocation_value->allocation_sequence(),",
          "new_line_content": "      VLOG(3) << \"Eviction interval is too short (\" << eviction_start_time",
          "content_same": false
        },
        {
          "line": 2475,
          "old_api": "ToString",
          "new_api": "VLOG",
          "old_text": "request.use->hlo_use.ToString()",
          "new_text": "VLOG(3)",
          "old_line_content": "      VLOG(3) << \"Bailing: Could not evict \" << request.use->hlo_use.ToString()",
          "new_line_content": "        VLOG(3) << \"Eviction successful.\";",
          "content_same": false
        },
        {
          "line": 2478,
          "old_api": "flattened_instruction_sequence",
          "new_api": "allocation_sequence",
          "old_text": "hlo_live_range_.flattened_instruction_sequence()\n                     .instructions()",
          "new_text": "request.allocation_value->allocation_sequence()",
          "old_line_content": "              << hlo_live_range_.flattened_instruction_sequence()",
          "new_line_content": "                     request.allocation_value->allocation_sequence(),",
          "content_same": false
        },
        {
          "line": 2573,
          "old_api": "value",
          "new_api": "std::max(earliest_prefetch_time, *request.earliest_prefetch_time)",
          "old_text": "request.allocation_value->value()",
          "new_text": "std::max(earliest_prefetch_time, *request.earliest_prefetch_time)",
          "old_line_content": "  alternate_mem_interval.buffer = request.allocation_value->value();",
          "new_line_content": "        std::max(earliest_prefetch_time, *request.earliest_prefetch_time);",
          "content_same": false
        },
        {
          "line": 2581,
          "old_api": "Done",
          "new_api": "ToDebugString",
          "old_text": "options_.prefetch_interval_picker->Done()",
          "new_text": "options_.prefetch_interval_picker->ToDebugString()",
          "old_line_content": "  while (!options_.prefetch_interval_picker->Done()) {",
          "new_line_content": "          << options_.prefetch_interval_picker->ToDebugString();",
          "content_same": false
        },
        {
          "line": 2590,
          "old_api": "VLOG",
          "new_api": "opcode",
          "old_text": "VLOG(4)",
          "new_text": "request.use->hlo_use.instruction->opcode()",
          "old_line_content": "      VLOG(4) << \"This would violate asynchronous copy ordering.\";",
          "new_line_content": "      request.use->hlo_use.instruction->opcode() == HloOpcode::kWhile",
          "content_same": false
        },
        {
          "line": 2594,
          "old_api": "ViolatesMaximumOutstandingAsyncCopies",
          "new_api": "Done",
          "old_text": "ViolatesMaximumOutstandingAsyncCopies(\n            alternate_mem_interval.start, prefetch_end_time,\n            /*is_prefetch=*/true, extra_async_copy_limit)",
          "new_text": "options_.prefetch_interval_picker->Done()",
          "old_line_content": "    if (ViolatesMaximumOutstandingAsyncCopies(",
          "new_line_content": "  while (!options_.prefetch_interval_picker->Done()) {",
          "content_same": false
        },
        {
          "line": 2615,
          "old_api": "allocation_sequence",
          "new_api": "FindBestChunkCandidate",
          "old_text": "AddAsyncCopy(prev_allocation_in_default_mem, MemorySpace::kAlternate,\n                   chunk_candidate->chunk, alternate_mem_interval.start,\n                   request.end_time, prefetch_end_time,\n                   request.allocation_value->allocation_sequence(),\n                   request.preferred_offset)",
          "new_text": "FindBestChunkCandidate(\n        request, request.preferred_offset, &alternate_mem_interval)",
          "old_line_content": "      AddAsyncCopy(prev_allocation_in_default_mem, MemorySpace::kAlternate,",
          "new_line_content": "    auto chunk_candidate = FindBestChunkCandidate(",
          "content_same": false
        },
        {
          "line": 2625,
          "old_api": "result_mark",
          "new_api": "ToDebugString",
          "old_text": "result_mark(Result::kFailOutOfMemory, result)",
          "new_text": "options_.prefetch_interval_picker->ToDebugString()",
          "old_line_content": "    result_mark(Result::kFailOutOfMemory, result);",
          "new_line_content": "              << options_.prefetch_interval_picker->ToDebugString();",
          "content_same": false
        },
        {
          "line": 2668,
          "old_api": "FindChunkCandidate",
          "new_api": "CanAllocateInAlternateMemoryNoCopy",
          "old_text": "FindChunkCandidate(*alternate_mem_interval)",
          "new_text": "options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(\n             shape, *use_time_it, *(use_time_it + 1))",
          "old_line_content": "          FindChunkCandidate(*alternate_mem_interval);",
          "new_line_content": "         options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(",
          "content_same": false
        },
        {
          "line": 2735,
          "old_api": "GetMemoryBoundedness",
          "new_api": "std::max(stats.max_outstanding_async_copies, current_copies)",
          "old_text": "cost_analysis.GetMemoryBoundedness(y, cache)",
          "new_text": "std::max(stats.max_outstanding_async_copies, current_copies)",
          "old_line_content": "    float y_memory_boundedness = cost_analysis.GetMemoryBoundedness(y, cache);",
          "new_line_content": "          std::max(stats.max_outstanding_async_copies, current_copies);",
          "content_same": false
        },
        {
          "line": 2753,
          "old_api": "ToString",
          "new_api": "GlobalDecreasingSizeBestFitHeap<\n        HloValue>::GetSpatialBufferIntervalCompare()(x, y)",
          "old_text": "module->ToString()",
          "new_text": "GlobalDecreasingSizeBestFitHeap<\n        HloValue>::GetSpatialBufferIntervalCompare()(x, y)",
          "old_line_content": "  XLA_VLOG_LINES(3, module->ToString());",
          "new_line_content": "    return GlobalDecreasingSizeBestFitHeap<",
          "content_same": false
        },
        {
          "line": 2766,
          "old_api": "FindAllocationSequence",
          "new_api": "ToString",
          "old_text": "FindAllocationSequence(hlo_live_range, alias_analysis)",
          "new_text": "module->ToString()",
          "old_line_content": "  TF_RETURN_IF_ERROR(FindAllocationSequence(hlo_live_range, alias_analysis));",
          "new_line_content": "  XLA_VLOG_LINES(3, module->ToString());",
          "content_same": false
        },
        {
          "line": 2767,
          "old_api": "Process",
          "new_api": "ToString",
          "old_text": "Process()",
          "new_text": "module->schedule().ToString()",
          "old_line_content": "  TF_RETURN_IF_ERROR(Process());",
          "new_line_content": "  VLOG(3) << \"Schedule: \" << module->schedule().ToString();",
          "content_same": false
        },
        {
          "line": 2771,
          "old_api": "ExportAndColorBuffers",
          "new_api": "RunMemorySpaceAssignment",
          "old_text": "ExportAndColorBuffers()",
          "new_text": "memory_space_assignment.RunMemorySpaceAssignment(hlo_live_range,\n                                                          alias_analysis)",
          "old_line_content": "  TF_RETURN_IF_ERROR(ExportAndColorBuffers());",
          "new_line_content": "  return memory_space_assignment.RunMemorySpaceAssignment(hlo_live_range,",
          "content_same": false
        },
        {
          "line": 2779,
          "old_api": "VLOG",
          "new_api": "FindAllocationSequence",
          "old_text": "VLOG(1)",
          "new_text": "FindAllocationSequence(hlo_live_range, alias_analysis)",
          "old_line_content": "  VLOG(1) << \"Number of prefetches: \" << stats.num_prefetches",
          "new_line_content": "  TF_RETURN_IF_ERROR(FindAllocationSequence(hlo_live_range, alias_analysis));",
          "content_same": false
        },
        {
          "line": 2781,
          "old_api": "VLOG",
          "new_api": "ScheduleAsynchronousCopies",
          "old_text": "VLOG(1)",
          "new_text": "ScheduleAsynchronousCopies()",
          "old_line_content": "  VLOG(1) << \"Number of evictions: \" << stats.num_evictions",
          "new_line_content": "  ScheduleAsynchronousCopies();",
          "content_same": false
        },
        {
          "line": 2784,
          "old_api": "VerifyAndExportHeapSimulatorTrace",
          "new_api": "ExportAndColorBuffers",
          "old_text": "VerifyAndExportHeapSimulatorTrace()",
          "new_text": "ExportAndColorBuffers()",
          "old_line_content": "  TF_RETURN_IF_ERROR(VerifyAndExportHeapSimulatorTrace());",
          "new_line_content": "  TF_RETURN_IF_ERROR(ExportAndColorBuffers());",
          "content_same": false
        },
        {
          "line": 2786,
          "old_api": "std::move(preset_assignments_)",
          "new_api": "VLOG",
          "old_text": "std::move(preset_assignments_)",
          "new_text": "VLOG(3)",
          "old_line_content": "  return std::move(preset_assignments_);",
          "new_line_content": "  VLOG(3) << \"Module after memory space assignment: \";",
          "content_same": false
        },
        {
          "line": 2792,
          "old_api": "absl::make_unique<AlternateMemoryBestFitHeap>(\n      &allocations_, options_, alias_analysis, hlo_live_range)",
          "new_api": "VLOG",
          "old_text": "absl::make_unique<AlternateMemoryBestFitHeap>(\n      &allocations_, options_, alias_analysis, hlo_live_range)",
          "new_text": "VLOG(1)",
          "old_line_content": "  auto algorithm = absl::make_unique<AlternateMemoryBestFitHeap>(",
          "new_line_content": "  VLOG(1) << \"Number of prefetches: \" << stats.num_prefetches",
          "content_same": false
        },
        {
          "line": 2797,
          "old_api": "std::move(algorithm)",
          "new_api": "VerifyAndExportHeapSimulatorTrace",
          "old_text": "std::move(algorithm)",
          "new_text": "VerifyAndExportHeapSimulatorTrace()",
          "old_line_content": "  TF_RETURN_IF_ERROR(HeapSimulator::Run(std::move(algorithm), *module_,",
          "new_line_content": "  TF_RETURN_IF_ERROR(VerifyAndExportHeapSimulatorTrace());",
          "content_same": false
        },
        {
          "line": 2810,
          "old_api": "opcode",
          "new_api": "std::move(algorithm)",
          "old_text": "operand->opcode()",
          "new_text": "std::move(algorithm)",
          "old_line_content": "    if (operand->opcode() != HloOpcode::kTuple) {",
          "new_line_content": "  TF_RETURN_IF_ERROR(HeapSimulator::Run(std::move(algorithm), *module_,",
          "content_same": false
        },
        {
          "line": 2823,
          "old_api": "tuple_index",
          "new_api": "opcode",
          "old_text": "instruction->tuple_index()",
          "new_text": "operand->opcode()",
          "old_line_content": "        instruction = operand->mutable_operand(instruction->tuple_index());",
          "new_line_content": "    if (operand->opcode() != HloOpcode::kTuple) {",
          "content_same": false
        },
        {
          "line": 2832,
          "old_api": "push_back",
          "new_api": "opcode",
          "old_text": "uses_.push_back(use)",
          "new_text": "instruction->opcode()",
          "old_line_content": "  uses_.push_back(use);",
          "new_line_content": "    while (instruction->opcode() == HloOpcode::kGetTupleElement) {",
          "content_same": false
        },
        {
          "line": 2850,
          "old_api": "mutable_operand",
          "new_api": "is_scoped_allocation",
          "old_text": "use.instruction->mutable_operand(use.operand_number)",
          "new_text": "is_scoped_allocation()",
          "old_line_content": "                           use.instruction->mutable_operand(use.operand_number),",
          "new_line_content": "  if (is_scoped_allocation()) {",
          "content_same": false
        },
        {
          "line": 2852,
          "old_api": "shape",
          "new_api": "Status::OK()",
          "old_text": "producing_instruction->shape()",
          "new_text": "Status::OK()",
          "old_line_content": "    } else if (operand_shape != producing_instruction->shape()) {",
          "new_line_content": "    return Status::OK();",
          "content_same": false
        },
        {
          "line": 2854,
          "old_api": "ToString",
          "new_api": "AddGetTupleElements",
          "old_text": "producing_instruction->shape().ToString()",
          "new_text": "AddGetTupleElements()",
          "old_line_content": "              << \", new shape = \" << producing_instruction->shape().ToString()",
          "new_line_content": "  HloInstruction* producing_instruction = AddGetTupleElements();",
          "content_same": false
        },
        {
          "line": 2857,
          "old_api": "HloInstruction::CreateBitcast(operand_shape, producing_instruction)",
          "new_api": "operand",
          "old_text": "HloInstruction::CreateBitcast(operand_shape, producing_instruction)",
          "new_text": "use.instruction->operand(use.operand_number)->shape()",
          "old_line_content": "          HloInstruction::CreateBitcast(operand_shape, producing_instruction));",
          "new_line_content": "    Shape operand_shape = use.instruction->operand(use.operand_number)->shape();",
          "content_same": false
        },
        {
          "line": 2859,
          "old_api": "ReplaceOperandWith",
          "new_api": "IsTuple",
          "old_text": "use.instruction->ReplaceOperandWith(\n        use.operand_number, replacement_instruction)",
          "new_text": "operand_shape.IsTuple()",
          "old_line_content": "    TF_RETURN_IF_ERROR(use.instruction->ReplaceOperandWith(",
          "new_line_content": "    if (operand_shape.IsTuple()) {",
          "content_same": false
        },
        {
          "line": 2862,
          "old_api": "Status::OK()",
          "new_api": "mutable_operand",
          "old_text": "Status::OK()",
          "new_text": "ReplaceTupleWith(producing_instruction,\n                           use.instruction->mutable_operand(use.operand_number),\n                           use.operand_index)",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "          ReplaceTupleWith(producing_instruction,",
          "content_same": false
        },
        {
          "line": 2869,
          "old_api": "IsTuple",
          "new_api": "AddInstruction",
          "old_text": "tuple->shape().IsTuple()",
          "new_text": "computation->AddInstruction(\n          HloInstruction::CreateBitcast(operand_shape, producing_instruction))",
          "old_line_content": "  CHECK(tuple->shape().IsTuple())",
          "new_line_content": "      replacement_instruction = computation->AddInstruction(",
          "content_same": false
        },
        {
          "line": 2872,
          "old_api": "ToString",
          "new_api": "ReplaceOperandWith",
          "old_text": "new_instruction->ToString()",
          "new_text": "use.instruction->ReplaceOperandWith(\n        use.operand_number, replacement_instruction)",
          "old_line_content": "      << \", new_instruction = \" << new_instruction->ToString()",
          "new_line_content": "    TF_RETURN_IF_ERROR(use.instruction->ReplaceOperandWith(",
          "content_same": false
        },
        {
          "line": 2875,
          "old_api": "parent",
          "new_api": "Status::OK()",
          "old_text": "new_instruction->parent()",
          "new_text": "Status::OK()",
          "old_line_content": "  HloComputation* computation = new_instruction->parent();",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2884,
          "old_api": "mutable_operand",
          "new_api": "ToString",
          "old_text": "tuple->mutable_operand(i)",
          "new_text": "tuple->ToString()",
          "old_line_content": "        return tuple->mutable_operand(i);",
          "new_line_content": "      << tuple->ToString()",
          "content_same": false
        },
        {
          "line": 2886,
          "old_api": "AddInstruction",
          "new_api": "ToString",
          "old_text": "computation->AddInstruction(\n            HloInstruction::CreateGetTupleElement(subshape, tuple, i))",
          "new_text": "shape_index.ToString()",
          "old_line_content": "        return computation->AddInstruction(",
          "new_line_content": "      << \", shape_index = \" << shape_index.ToString();",
          "content_same": false
        },
        {
          "line": 2896,
          "old_api": "begin",
          "new_api": "opcode",
          "old_text": "shape_index.begin()",
          "new_text": "tuple->opcode()",
          "old_line_content": "                                             ShapeIndex(shape_index.begin() + 1,",
          "new_line_content": "      if (tuple->opcode() == HloOpcode::kTuple) {",
          "content_same": false
        },
        {
          "line": 2897,
          "old_api": "end",
          "new_api": "mutable_operand",
          "old_text": "shape_index.end()",
          "new_text": "tuple->mutable_operand(i)",
          "old_line_content": "                                                        shape_index.end())));",
          "new_line_content": "        return tuple->mutable_operand(i);",
          "content_same": false
        },
        {
          "line": 2899,
          "old_api": "shape",
          "new_api": "AddInstruction",
          "old_text": "new_instruction->shape()",
          "new_text": "computation->AddInstruction(\n            HloInstruction::CreateGetTupleElement(subshape, tuple, i))",
          "old_line_content": "        if (subshape != new_instruction->shape()) {",
          "new_line_content": "        return computation->AddInstruction(",
          "content_same": false
        },
        {
          "line": 2900,
          "old_api": "ToString",
          "new_api": "HloInstruction::CreateGetTupleElement(subshape, tuple, i)",
          "old_text": "subshape.ToString()",
          "new_text": "HloInstruction::CreateGetTupleElement(subshape, tuple, i)",
          "old_line_content": "          VLOG(4) << \"Old shape = \" << subshape.ToString()",
          "new_line_content": "            HloInstruction::CreateGetTupleElement(subshape, tuple, i));",
          "content_same": false
        },
        {
          "line": 2906,
          "old_api": "operand",
          "new_api": "IsTuple",
          "old_text": "tuple->operand(i)",
          "new_text": "subshape.IsTuple()",
          "old_line_content": "                   tuple->operand(i) == new_instruction) {",
          "new_line_content": "      if (subshape.IsTuple()) {",
          "content_same": false
        },
        {
          "line": 2910,
          "old_api": "VLOG",
          "new_api": "end",
          "old_text": "VLOG(4)",
          "new_text": "shape_index.end()",
          "old_line_content": "          VLOG(4) << \"Tuple already contains the new instruction = \"",
          "new_line_content": "                                                        shape_index.end())));",
          "content_same": false
        },
        {
          "line": 2912,
          "old_api": "ToShortString",
          "new_api": "shape",
          "old_text": "tuple->ToShortString()",
          "new_text": "new_instruction->shape()",
          "old_line_content": "                  << \" tuple = \" << tuple->ToShortString();",
          "new_line_content": "        if (subshape != new_instruction->shape()) {",
          "content_same": false
        },
        {
          "line": 2918,
          "old_api": "get_operand",
          "new_api": "opcode",
          "old_text": "get_operand()",
          "new_text": "tuple->opcode()",
          "old_line_content": "      tuple_args[i] = get_operand();",
          "new_line_content": "        } else if (tuple->opcode() == HloOpcode::kTuple &&",
          "content_same": false
        },
        {
          "line": 2925,
          "old_api": "defining_position",
          "new_api": "ToShortString",
          "old_text": "defining_position()",
          "new_text": "tuple->ToShortString()",
          "old_line_content": "  HloInstruction* producing_instruction = defining_position().instruction;",
          "new_line_content": "                  << \" tuple = \" << tuple->ToShortString();",
          "content_same": false
        },
        {
          "line": 2931,
          "old_api": "shape",
          "new_api": "get_operand",
          "old_text": "defining_position().shape()",
          "new_text": "get_operand()",
          "old_line_content": "                         << \" position = \" << defining_position().shape();",
          "new_line_content": "      tuple_args[i] = get_operand();",
          "content_same": false
        },
        {
          "line": 2941,
          "old_api": "users",
          "new_api": "shape",
          "old_text": "producing_instruction->users()",
          "new_text": "defining_position().shape()",
          "old_line_content": "        producing_instruction->users(), [index](const HloInstruction* use) {",
          "new_line_content": "  Shape shape = defining_position().shape();",
          "content_same": false
        },
        {
          "line": 2942,
          "old_api": "parent",
          "new_api": "IsArray",
          "old_text": "use->parent()->root_instruction()",
          "new_text": "shape.IsArray()",
          "old_line_content": "          return use != use->parent()->root_instruction() &&",
          "new_line_content": "  CHECK(shape.IsArray()) << \"Allocation shape is not an array. Shape = \"",
          "content_same": false
        },
        {
          "line": 2943,
          "old_api": "opcode",
          "new_api": "ToString",
          "old_text": "use->opcode()",
          "new_text": "shape.ToString()",
          "old_line_content": "                 use->opcode() == HloOpcode::kGetTupleElement &&",
          "new_line_content": "                         << shape.ToString()",
          "content_same": false
        },
        {
          "line": 2944,
          "old_api": "tuple_index",
          "new_api": "shape",
          "old_text": "use->tuple_index()",
          "new_text": "defining_position().shape()",
          "old_line_content": "                 use->tuple_index() == index;",
          "new_line_content": "                         << \" position = \" << defining_position().shape();",
          "content_same": false
        },
        {
          "line": 2950,
          "old_api": "tuple_shapes",
          "new_api": "defining_position",
          "old_text": "HloInstruction::CreateGetTupleElement(\n              producing_instruction->shape().tuple_shapes(index),\n              producing_instruction, index)",
          "new_text": "defining_position()",
          "old_line_content": "          computation->AddInstruction(HloInstruction::CreateGetTupleElement(",
          "new_line_content": "  for (int64 index : defining_position().index) {",
          "content_same": false
        },
        {
          "line": 2963,
          "old_api": "is_scoped_allocation",
          "new_api": "tuple_shapes",
          "old_text": "is_scoped_allocation()",
          "new_text": "HloInstruction::CreateGetTupleElement(\n              producing_instruction->shape().tuple_shapes(index),\n              producing_instruction, index)",
          "old_line_content": "  return absl::StrCat((is_scoped_allocation() ? \"Scoped \" : \"\"),",
          "new_line_content": "          computation->AddInstruction(HloInstruction::CreateGetTupleElement(",
          "content_same": false
        },
        {
          "line": 2974,
          "old_api": "ToString",
          "new_api": "absl::StrCat(\"alt (off: \", chunk_->offset, \")\")",
          "old_text": "prev_allocation_.ToString()",
          "new_text": "absl::StrCat(\"alt (off: \", chunk_->offset, \")\")",
          "old_line_content": "                      prev_allocation_.ToString());",
          "new_line_content": "    memory_space_str = absl::StrCat(\"alt (off: \", chunk_->offset, \")\");",
          "content_same": false
        },
        {
          "line": 2984,
          "old_api": "ShapeUtil::MakeShape(U32, {})",
          "new_api": "absl::StrCat(\"alt (off: \", chunk_->offset, \")\")",
          "old_text": "ShapeUtil::MakeShape(U32, {})",
          "new_text": "absl::StrCat(\"alt (off: \", chunk_->offset, \")\")",
          "old_line_content": "      ShapeUtil::MakeTupleShape({shape, shape, ShapeUtil::MakeShape(U32, {})}),",
          "new_line_content": "    memory_space_str = absl::StrCat(\"alt (off: \", chunk_->offset, \")\");",
          "content_same": false
        },
        {
          "line": 2986,
          "old_api": "AddInstruction",
          "new_api": "ToString",
          "old_text": "computation->AddInstruction(\n      HloInstruction::CreateUnary(shape, HloOpcode::kCopyDone, copy_start_))",
          "new_text": "absl::StrCat(\"Copy Allocation in \", memory_space_str, \" from \",\n                      prev_allocation_.ToString())",
          "old_line_content": "  copy_done_ = computation->AddInstruction(",
          "new_line_content": "  return absl::StrCat(\"Copy Allocation in \", memory_space_str, \" from \",",
          "content_same": false
        },
        {
          "line": 2987,
          "old_api": "HloInstruction::CreateUnary(shape, HloOpcode::kCopyDone, copy_start_)",
          "new_api": "ToString",
          "old_text": "HloInstruction::CreateUnary(shape, HloOpcode::kCopyDone, copy_start_)",
          "new_text": "prev_allocation_.ToString()",
          "old_line_content": "      HloInstruction::CreateUnary(shape, HloOpcode::kCopyDone, copy_start_));",
          "new_line_content": "                      prev_allocation_.ToString());",
          "content_same": false
        },
        {
          "line": 2999,
          "old_api": "operand",
          "new_api": "AddInstruction",
          "old_text": "use.instruction->operand(use.operand_number)->shape()",
          "new_text": "computation->AddInstruction(\n      HloInstruction::CreateUnary(shape, HloOpcode::kCopyDone, copy_start_))",
          "old_line_content": "    Shape operand_shape = use.instruction->operand(use.operand_number)->shape();",
          "new_line_content": "  copy_done_ = computation->AddInstruction(",
          "content_same": false
        },
        {
          "line": 3000,
          "old_api": "IsTuple",
          "new_api": "HloInstruction::CreateUnary(shape, HloOpcode::kCopyDone, copy_start_)",
          "old_text": "operand_shape.IsTuple()",
          "new_text": "HloInstruction::CreateUnary(shape, HloOpcode::kCopyDone, copy_start_)",
          "old_line_content": "    if (operand_shape.IsTuple()) {",
          "new_line_content": "      HloInstruction::CreateUnary(shape, HloOpcode::kCopyDone, copy_start_));",
          "content_same": false
        },
        {
          "line": 3001,
          "old_api": "mutable_operand",
          "new_api": "name",
          "old_text": "TF_ASSIGN_OR_RETURN(\n          replacement_instruction,\n          ReplaceTupleWith(copy_done_,\n                           use.instruction->mutable_operand(use.operand_number),\n                           use.operand_index))",
          "new_text": "copy_start_->name()",
          "old_line_content": "      TF_ASSIGN_OR_RETURN(",
          "new_line_content": "  VLOG(4) << \"Created \" << copy_start_->name()",
          "content_same": false
        },
        {
          "line": 3019,
          "old_api": "Status::OK()",
          "new_api": "shape",
          "old_text": "Status::OK()",
          "new_text": "copy_done_->shape()",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "    } else if (operand_shape != copy_done_->shape()) {",
          "content_same": false
        },
        {
          "line": 3023,
          "old_api": "VLOG",
          "new_api": "AddInstruction",
          "old_text": "VLOG(1)",
          "new_text": "computation->AddInstruction(\n          HloInstruction::CreateBitcast(operand_shape, copy_done_))",
          "old_line_content": "  VLOG(1) << \"Processing assigned buffers...\";",
          "new_line_content": "      replacement_instruction = computation->AddInstruction(",
          "content_same": false
        },
        {
          "line": 3032,
          "old_api": "emplace_back",
          "new_api": "Status::OK()",
          "old_text": "scoped_memory_assignments_.emplace_back(\n          allocation->defining_position().instruction, allocation->chunk())",
          "new_text": "Status::OK()",
          "old_line_content": "      scoped_memory_assignments_.emplace_back(",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3036,
          "old_api": "memory_space",
          "new_api": "VLOG",
          "old_text": "allocation->memory_space()",
          "new_text": "VLOG(1)",
          "old_line_content": "    } else if (allocation->memory_space() == MemorySpace::kAlternate) {",
          "new_line_content": "  VLOG(1) << \"Processing assigned buffers...\";",
          "content_same": false
        },
        {
          "line": 3040,
          "old_api": "chunk_end",
          "new_api": "Process",
          "old_text": "allocation->chunk().chunk_end()",
          "new_text": "allocation->Process(this)",
          "old_line_content": "          std::max(alternate_memory_size_, allocation->chunk().chunk_end());",
          "new_line_content": "    TF_RETURN_IF_ERROR(allocation->Process(this));",
          "content_same": false
        },
        {
          "line": 3043,
          "old_api": "Status::OK()",
          "new_api": "is_scoped_allocation",
          "old_text": "Status::OK()",
          "new_text": "allocation->is_scoped_allocation()",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "    if (allocation->is_scoped_allocation()) {",
          "content_same": false
        },
        {
          "line": 3050,
          "old_api": "VLOG",
          "new_api": "emplace_back",
          "old_text": "VLOG(3)",
          "new_text": "alternate_memory_assignments_.emplace_back(\n          allocation->defining_position(), allocation->chunk())",
          "old_line_content": "  VLOG(3) << \"Exported alternate memory allocations:\";",
          "new_line_content": "      alternate_memory_assignments_.emplace_back(",
          "content_same": false
        },
        {
          "line": 3056,
          "old_api": "id",
          "new_api": "Status::OK()",
          "old_text": "buffer.id()",
          "new_text": "Status::OK()",
          "old_line_content": "    auto seen_buffer_offset_it = seen_buffer_offsets.find(buffer.id());",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3060,
          "old_api": "ToString",
          "new_api": "VLOG",
          "old_text": "defining_position.ToString()",
          "new_text": "VLOG(1)",
          "old_line_content": "          << buffer.ToString() << \", pos: \" << defining_position.ToString();",
          "new_line_content": "  VLOG(1) << \"Exporting buffers...\";",
          "content_same": false
        },
        {
          "line": 3063,
          "old_api": "ToString",
          "new_api": "VLOG",
          "old_text": "defining_position.ToString()",
          "new_text": "VLOG(3)",
          "old_line_content": "              << \"] : \" << defining_position.ToString() << \" (\"",
          "new_line_content": "  VLOG(3) << \"Exported alternate memory allocations:\";",
          "content_same": false
        },
        {
          "line": 3070,
          "old_api": "VLOG",
          "new_api": "end",
          "old_text": "VLOG(3)",
          "new_text": "seen_buffer_offsets.end()",
          "old_line_content": "  VLOG(3) << \"Exported scoped allocations in alternate memory:\";",
          "new_line_content": "    if (seen_buffer_offset_it != seen_buffer_offsets.end()) {",
          "content_same": false
        },
        {
          "line": 3075,
          "old_api": "name",
          "new_api": "VLOG",
          "old_text": "instruction->name()",
          "new_text": "VLOG(3)",
          "old_line_content": "            << \"] : \" << instruction->name();",
          "new_line_content": "      VLOG(3) << \" [\" << chunk.offset << \", \" << chunk.size",
          "content_same": false
        },
        {
          "line": 3076,
          "old_api": "add_scoped_allocation_chunk",
          "new_api": "ToString",
          "old_text": "preset_assignments_->add_scoped_allocation_chunk(instruction, chunk)",
          "new_text": "defining_position.ToString()",
          "old_line_content": "    preset_assignments_->add_scoped_allocation_chunk(instruction, chunk);",
          "new_line_content": "              << \"] : \" << defining_position.ToString() << \" (\"",
          "content_same": false
        },
        {
          "line": 3079,
          "old_api": "empty",
          "new_api": "id",
          "old_text": "preset_assignments_->chunks().empty()",
          "new_text": "buffer.id()",
          "old_line_content": "  if (!preset_assignments_->chunks().empty() ||",
          "new_line_content": "      seen_buffer_offsets[buffer.id()] = chunk.offset;",
          "content_same": false
        },
        {
          "line": 3087,
          "old_api": "assignment_informations",
          "new_api": "VLOG",
          "old_text": "preset_assignments_->assignment_informations()",
          "new_text": "VLOG(3)",
          "old_line_content": "  for (auto& pair : preset_assignments_->assignment_informations()) {",
          "new_line_content": "    VLOG(3) << \" [\" << chunk.offset << \", \" << chunk.size",
          "content_same": false
        },
        {
          "line": 3088,
          "old_api": "VLOG",
          "new_api": "name",
          "old_text": "VLOG(3)",
          "new_text": "instruction->name()",
          "old_line_content": "    VLOG(3) << \"  space: \" << pair.first << \", size: \" << pair.second.size;",
          "new_line_content": "            << \"] : \" << instruction->name();",
          "content_same": false
        },
        {
          "line": 3094,
          "old_api": "chunks",
          "new_api": "assignment_information_for_space",
          "old_text": "preset_assignments_->chunks()",
          "new_text": "preset_assignments_\n        ->assignment_information_for_space(options_.alternate_memory_space)",
          "old_line_content": "       preset_assignments_->chunks()) {",
          "new_line_content": "    preset_assignments_",
          "content_same": false
        },
        {
          "line": 3099,
          "old_api": "positions",
          "new_api": "VLOG",
          "old_text": "value->positions()",
          "new_text": "VLOG(3)",
          "old_line_content": "        for (auto& position : value->positions()) {",
          "new_line_content": "  VLOG(3) << \"Exported alternate memory sizes:\";",
          "content_same": false
        },
        {
          "line": 3100,
          "old_api": "ToString",
          "new_api": "assignment_informations",
          "old_text": "position.ToString()",
          "new_text": "preset_assignments_->assignment_informations()",
          "old_line_content": "          VLOG(4) << \"Coloring \" << position.ToString();",
          "new_line_content": "  for (auto& pair : preset_assignments_->assignment_informations()) {",
          "content_same": false
        },
        {
          "line": 3101,
          "old_api": "mutable_shape",
          "new_api": "VLOG",
          "old_text": "ShapeUtil::GetMutableSubshape(\n              position.instruction->mutable_shape(), position.index)",
          "new_text": "VLOG(3)",
          "old_line_content": "          Shape* shape = ShapeUtil::GetMutableSubshape(",
          "new_line_content": "    VLOG(3) << \"  space: \" << pair.first << \", size: \" << pair.second.size;",
          "content_same": false
        },
        {
          "line": 3104,
          "old_api": "ToString",
          "new_api": "VLOG",
          "old_text": "position.ToString()",
          "new_text": "VLOG(1)",
          "old_line_content": "                                  << position.ToString();",
          "new_line_content": "  VLOG(1) << \"Coloring buffers...\";",
          "content_same": false
        },
        {
          "line": 3111,
          "old_api": "Status::OK()",
          "new_api": "values",
          "old_text": "Status::OK()",
          "new_text": "buffer->values()",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "      for (auto& value : buffer->values()) {",
          "content_same": false
        },
        {
          "line": 3134,
          "old_api": "name",
          "new_api": "back",
          "old_text": "computation->name()",
          "new_text": "alternate_memory_assignments_.back()",
          "old_line_content": "      VLOG(4) << \"Not simplifying \" << computation->name()",
          "new_line_content": "      position_and_chunk = alternate_memory_assignments_.back();",
          "content_same": false
        },
        {
          "line": 3158,
          "old_api": "IsSafelyRemovable",
          "new_api": "DropAllControlDeps",
          "old_text": "computation->IsSafelyRemovable(instruction)",
          "new_text": "instruction->DropAllControlDeps()",
          "old_line_content": "        if (computation->IsSafelyRemovable(instruction) &&",
          "new_line_content": "      TF_RETURN_IF_ERROR(instruction->DropAllControlDeps());",
          "content_same": false
        },
        {
          "line": 3172,
          "old_api": "absl::c_find(flattened_instructions_, instruction)",
          "new_api": "HasSideEffect",
          "old_text": "absl::c_find(flattened_instructions_, instruction)",
          "new_text": "instruction->HasSideEffect()",
          "old_line_content": "              absl::c_find(flattened_instructions_, instruction);",
          "new_line_content": "            instruction->user_count() == 0 && !instruction->HasSideEffect() &&",
          "content_same": false
        },
        {
          "line": 3173,
          "old_api": "end",
          "new_api": "root_instruction",
          "old_text": "flattened_instructions_.end()",
          "new_text": "computation->root_instruction()",
          "old_line_content": "          if (instruction_it != flattened_instructions_.end()) {",
          "new_line_content": "            instruction != computation->root_instruction() &&",
          "content_same": false
        },
        {
          "line": 3176,
          "old_api": "RemoveInstruction",
          "new_api": "ToString",
          "old_text": "computation->RemoveInstruction(instruction)",
          "new_text": "instruction->ToString()",
          "old_line_content": "          TF_RETURN_IF_ERROR(computation->RemoveInstruction(instruction));",
          "new_line_content": "          VLOG(4) << \"Instruction removed: \" << instruction->ToString();",
          "content_same": false
        },
        {
          "line": 3179,
          "old_api": "mutable_operand",
          "new_api": "RemoveAssignmentForInstruction",
          "old_text": "instruction->mutable_operand(0)",
          "new_text": "RemoveAssignmentForInstruction(instruction)",
          "old_line_content": "          HloInstruction* operand = instruction->mutable_operand(0);",
          "new_line_content": "          RemoveAssignmentForInstruction(instruction);",
          "content_same": false
        },
        {
          "line": 3185,
          "old_api": "ReplaceAllUsesWith",
          "new_api": "absl::c_find(flattened_instructions_, instruction)",
          "old_text": "TF_RETURN_IF_ERROR(\n                instruction->ReplaceAllUsesWith(forwarded_instruction))",
          "new_text": "absl::c_find(flattened_instructions_, instruction)",
          "old_line_content": "            TF_RETURN_IF_ERROR(",
          "new_line_content": "              absl::c_find(flattened_instructions_, instruction);",
          "content_same": false
        },
        {
          "line": 3186,
          "old_api": "ReplaceAllUsesWith",
          "new_api": "end",
          "old_text": "instruction->ReplaceAllUsesWith(forwarded_instruction)",
          "new_text": "flattened_instructions_.end()",
          "old_line_content": "                instruction->ReplaceAllUsesWith(forwarded_instruction));",
          "new_line_content": "          if (instruction_it != flattened_instructions_.end()) {",
          "content_same": false
        },
        {
          "line": 3189,
          "old_api": "opcode",
          "new_api": "RemoveInstruction",
          "old_text": "instruction->opcode()",
          "new_text": "computation->RemoveInstruction(instruction)",
          "old_line_content": "        } else if (instruction->opcode() == HloOpcode::kTuple) {",
          "new_line_content": "          TF_RETURN_IF_ERROR(computation->RemoveInstruction(instruction));",
          "content_same": false
        },
        {
          "line": 3193,
          "old_api": "operand_count",
          "new_api": "opcode",
          "old_text": "instruction->operand_count()",
          "new_text": "operand->opcode()",
          "old_line_content": "              instruction->operand_count() > 0 &&",
          "new_line_content": "          if (operand->opcode() == HloOpcode::kTuple) {",
          "content_same": false
        },
        {
          "line": 3196,
          "old_api": "tuple_shapes_size",
          "new_api": "ToString",
          "old_text": "instruction->operand(0)\n                      ->operand(0)\n                      ->shape()\n                      .tuple_shapes_size()",
          "new_text": "instruction->ToString()",
          "old_line_content": "              instruction->operand(0)",
          "new_line_content": "            VLOG(4) << \"Replacing uses of \" << instruction->ToString()",
          "content_same": false
        },
        {
          "line": 3199,
          "old_api": "operand_count",
          "new_api": "ReplaceAllUsesWith",
          "old_text": "instruction->operand_count()",
          "new_text": "instruction->ReplaceAllUsesWith(forwarded_instruction)",
          "old_line_content": "                      .tuple_shapes_size() == instruction->operand_count();",
          "new_line_content": "                instruction->ReplaceAllUsesWith(forwarded_instruction));",
          "content_same": false
        },
        {
          "line": 3206,
          "old_api": "tuple_index",
          "new_api": "operand_count",
          "old_text": "operand->tuple_index()",
          "new_text": "instruction->operand_count()",
          "old_line_content": "                operand->tuple_index() != operand_number ||",
          "new_line_content": "              instruction->operand_count() > 0 &&",
          "content_same": false
        },
        {
          "line": 3214,
          "old_api": "mutable_operand",
          "new_api": "operand_count",
          "old_text": "instruction->mutable_operand(0)->mutable_operand(0)",
          "new_text": "instruction->operand_count()",
          "old_line_content": "                instruction->mutable_operand(0)->mutable_operand(0);",
          "new_line_content": "               operand_number < instruction->operand_count();",
          "content_same": false
        },
        {
          "line": 3217,
          "old_api": "ReplaceAllUsesWith",
          "new_api": "operand",
          "old_text": "TF_RETURN_IF_ERROR(\n                instruction->ReplaceAllUsesWith(forwarded_instruction))",
          "new_text": "instruction->operand(operand_number)",
          "old_line_content": "            TF_RETURN_IF_ERROR(",
          "new_line_content": "                instruction->operand(operand_number);",
          "content_same": false
        },
        {
          "line": 3218,
          "old_api": "ReplaceAllUsesWith",
          "new_api": "opcode",
          "old_text": "instruction->ReplaceAllUsesWith(forwarded_instruction)",
          "new_text": "operand->opcode()",
          "old_line_content": "                instruction->ReplaceAllUsesWith(forwarded_instruction));",
          "new_line_content": "            if (operand->opcode() != HloOpcode::kGetTupleElement ||",
          "content_same": false
        },
        {
          "line": 3239,
          "old_api": "opcode",
          "new_api": "Status::OK()",
          "old_text": "operand->opcode()",
          "new_text": "Status::OK()",
          "old_line_content": "           operand->opcode() != HloOpcode::kCopyDone) ||",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3248,
          "old_api": "insert",
          "new_api": "operands",
          "old_text": "inserted_instructions->insert(new_instruction)",
          "new_text": "new_instruction->operands()",
          "old_line_content": "  inserted_instructions->insert(new_instruction);",
          "new_line_content": "  for (HloInstruction* operand : new_instruction->operands()) {",
          "content_same": false
        },
        {
          "line": 3252,
          "old_api": "VLOG",
          "new_api": "opcode",
          "old_text": "VLOG(1)",
          "new_text": "operand->opcode()",
          "old_line_content": "  VLOG(1) << \"Scheduling asynchronous copies...\";",
          "new_line_content": "           operand->opcode() != HloOpcode::kCopyDone) ||",
          "content_same": false
        },
        {
          "line": 3259,
          "old_api": "memory_space",
          "new_api": "ToShortString",
          "old_text": "copy_allocation->memory_space()",
          "new_text": "new_instruction->ToShortString()",
          "old_line_content": "        if (copy_allocation->memory_space() == memory_space) {",
          "new_line_content": "  VLOG(4) << \"inserting: \" << new_instruction->ToShortString();",
          "content_same": false
        },
        {
          "line": 3265,
          "old_api": "copy_done_schedule_before",
          "new_api": "VLOG",
          "old_text": "absl::c_stable_sort(\n        copy_allocations, [](CopyAllocation* first, CopyAllocation* second) {\n          return std::forward_as_tuple(first->copy_done_schedule_before(),\n                                       first->copy_start_schedule_after()) <\n                 std::forward_as_tuple(second->copy_done_schedule_before(),\n                                       second->copy_start_schedule_after());\n        })",
          "new_text": "VLOG(1)",
          "old_line_content": "    absl::c_stable_sort(",
          "new_line_content": "  VLOG(1) << \"Scheduling asynchronous copies...\";",
          "content_same": false
        },
        {
          "line": 3270,
          "old_api": "copy_start_schedule_after",
          "new_api": "is_copy_allocation",
          "old_text": "second->copy_start_schedule_after()",
          "new_text": "allocation->is_copy_allocation()",
          "old_line_content": "                                       second->copy_start_schedule_after());",
          "new_line_content": "      if (allocation->is_copy_allocation()) {",
          "content_same": false
        },
        {
          "line": 3278,
          "old_api": "copy_start_schedule_after",
          "new_api": "copy_done_schedule_before",
          "old_text": "copy_allocation->copy_start_schedule_after()",
          "new_text": "absl::c_stable_sort(\n        copy_allocations, [](CopyAllocation* first, CopyAllocation* second) {\n          return std::forward_as_tuple(first->copy_done_schedule_before(),\n                                       first->copy_start_schedule_after()) <\n                 std::forward_as_tuple(second->copy_done_schedule_before(),\n                                       second->copy_start_schedule_after());\n        })",
          "old_line_content": "          copy_allocation->copy_start_schedule_after();",
          "new_line_content": "    absl::c_stable_sort(",
          "content_same": false
        },
        {
          "line": 3281,
          "old_api": "defining_position",
          "new_api": "copy_start_schedule_after",
          "old_text": "copy_allocation->defining_position().instruction->parent()",
          "new_text": "first->copy_start_schedule_after()",
          "old_line_content": "      while (copy_allocation->defining_position().instruction->parent() !=",
          "new_line_content": "                                       first->copy_start_schedule_after()) <",
          "content_same": false
        },
        {
          "line": 3282,
          "old_api": "parent",
          "new_api": "copy_done_schedule_before",
          "old_text": "flattened_instructions_[copy_start_schedule_after]->parent()",
          "new_text": "second->copy_done_schedule_before()",
          "old_line_content": "             flattened_instructions_[copy_start_schedule_after]->parent()) {",
          "new_line_content": "                 std::forward_as_tuple(second->copy_done_schedule_before(),",
          "content_same": false
        },
        {
          "line": 3283,
          "old_api": "VLOG",
          "new_api": "copy_start_schedule_after",
          "old_text": "VLOG(4)",
          "new_text": "second->copy_start_schedule_after()",
          "old_line_content": "        VLOG(4) << \"Delaying CopyStart (\" << copy_start_schedule_after << \" to \"",
          "new_line_content": "                                       second->copy_start_schedule_after());",
          "content_same": false
        },
        {
          "line": 3294,
          "old_api": "copy_done",
          "new_api": "defining_position",
          "old_text": "copy_allocation->copy_done()",
          "new_text": "copy_allocation->defining_position().instruction->parent()",
          "old_line_content": "          copy_allocation->copy_done());",
          "new_line_content": "      while (copy_allocation->defining_position().instruction->parent() !=",
          "content_same": false
        },
        {
          "line": 3305,
          "old_api": "MakeNonfusionComputations",
          "new_api": "copy_start",
          "old_text": "module_->MakeNonfusionComputations()",
          "new_text": "copy_allocation->copy_start()",
          "old_line_content": "       module_->MakeNonfusionComputations()) {",
          "new_line_content": "          copy_allocation->copy_start());",
          "content_same": false
        },
        {
          "line": 3318,
          "old_api": "ToString",
          "new_api": "MakeNonfusionComputations",
          "old_text": "computation->ToString()",
          "new_text": "module_->MakeNonfusionComputations()",
          "old_line_content": "    VLOG(4) << \"Scheduling: \" << computation->ToString();",
          "new_line_content": "       module_->MakeNonfusionComputations()) {",
          "content_same": false
        },
        {
          "line": 3321,
          "old_api": "size",
          "new_api": "contains",
          "old_text": "flattened_instructions_.size()",
          "new_text": "computations_in_schedule_.contains(computation)",
          "old_line_content": "         instruction_index < flattened_instructions_.size();",
          "new_line_content": "    if (!computations_in_schedule_.contains(computation)) {",
          "content_same": false
        },
        {
          "line": 3326,
          "old_api": "parent",
          "new_api": "is_computation_scheduled",
          "old_text": "new_instruction->parent()",
          "new_text": "schedule.is_computation_scheduled(computation)",
          "old_line_content": "          if (new_instruction->parent() == computation) {",
          "new_line_content": "    CHECK(schedule.is_computation_scheduled(computation));",
          "content_same": false
        },
        {
          "line": 3340,
          "old_api": "contains",
          "new_api": "VLOG",
          "old_text": "inserted_instructions.contains(instruction)",
          "new_text": "VLOG(4)",
          "old_line_content": "          !inserted_instructions.contains(instruction) &&",
          "new_line_content": "            VLOG(4) << \"before \" << instruction_index << \": \"",
          "content_same": false
        },
        {
          "line": 3341,
          "old_api": "parent",
          "new_api": "name",
          "old_text": "instruction->parent()",
          "new_text": "new_instruction->name()",
          "old_line_content": "          instruction->parent() == computation &&",
          "new_line_content": "                    << new_instruction->name();",
          "content_same": false
        },
        {
          "line": 3342,
          "old_api": "opcode",
          "new_api": "EnsureInstructionAndOperandsInserted",
          "old_text": "instruction->opcode()",
          "new_text": "EnsureInstructionAndOperandsInserted(new_instruction, &new_sequence,\n                                                 &inserted_instructions)",
          "old_line_content": "          instruction->opcode() != HloOpcode::kBitcast &&",
          "new_line_content": "            EnsureInstructionAndOperandsInserted(new_instruction, &new_sequence,",
          "content_same": false
        },
        {
          "line": 3353,
          "old_api": "name",
          "new_api": "contains",
          "old_text": "new_instruction->name()",
          "new_text": "inserted_instructions.contains(instruction)",
          "old_line_content": "                    << new_instruction->name();",
          "new_line_content": "          !inserted_instructions.contains(instruction) &&",
          "content_same": false
        },
        {
          "line": 3354,
          "old_api": "EnsureInstructionAndOperandsInserted",
          "new_api": "parent",
          "old_text": "EnsureInstructionAndOperandsInserted(new_instruction, &new_sequence,\n                                                 &inserted_instructions)",
          "new_text": "instruction->parent()",
          "old_line_content": "            EnsureInstructionAndOperandsInserted(new_instruction, &new_sequence,",
          "new_line_content": "          instruction->parent() == computation &&",
          "content_same": false
        },
        {
          "line": 3362,
          "old_api": "root_instruction",
          "new_api": "end",
          "old_text": "computation->root_instruction()",
          "new_text": "schedule_after_.end()",
          "old_line_content": "    EnsureInstructionAndOperandsInserted(computation->root_instruction(),",
          "new_line_content": "      if (insts_after_iter != schedule_after_.end()) {",
          "content_same": false
        },
        {
          "line": 3364,
          "old_api": "instruction_count",
          "new_api": "parent",
          "old_text": "computation->instruction_count()",
          "new_text": "new_instruction->parent()",
          "old_line_content": "    CHECK_EQ(new_sequence.size(), computation->instruction_count())",
          "new_line_content": "          if (new_instruction->parent() == computation) {",
          "content_same": false
        },
        {
          "line": 3365,
          "old_api": "name",
          "new_api": "VLOG",
          "old_text": "computation->name()",
          "new_text": "VLOG(4)",
          "old_line_content": "        << \"New sequence for computation \" << computation->name() << \" has \"",
          "new_line_content": "            VLOG(4) << \"after \" << instruction_index << \": \"",
          "content_same": false
        },
        {
          "line": 3366,
          "old_api": "size",
          "new_api": "name",
          "old_text": "new_sequence.size()",
          "new_text": "new_instruction->name()",
          "old_line_content": "        << new_sequence.size() << \" instructions, expects \"",
          "new_line_content": "                    << new_instruction->name();",
          "content_same": false
        },
        {
          "line": 3367,
          "old_api": "instruction_count",
          "new_api": "EnsureInstructionAndOperandsInserted",
          "old_text": "computation->instruction_count()",
          "new_text": "EnsureInstructionAndOperandsInserted(new_instruction, &new_sequence,\n                                                 &inserted_instructions)",
          "old_line_content": "        << computation->instruction_count() << \".\";",
          "new_line_content": "            EnsureInstructionAndOperandsInserted(new_instruction, &new_sequence,",
          "content_same": false
        },
        {
          "line": 3375,
          "old_api": "VLOG",
          "new_api": "root_instruction",
          "old_text": "VLOG(1)",
          "new_text": "computation->root_instruction()",
          "old_line_content": "  VLOG(1) << \"Verifying...\";",
          "new_line_content": "    EnsureInstructionAndOperandsInserted(computation->root_instruction(),",
          "content_same": false
        },
        {
          "line": 3377,
          "old_api": "HloAliasAnalysis::Run(module_)",
          "new_api": "instruction_count",
          "old_text": "HloAliasAnalysis::Run(module_)",
          "new_text": "computation->instruction_count()",
          "old_line_content": "                      HloAliasAnalysis::Run(module_));",
          "new_line_content": "    CHECK_EQ(new_sequence.size(), computation->instruction_count())",
          "content_same": false
        },
        {
          "line": 3378,
          "old_api": "schedule",
          "new_api": "name",
          "old_text": "TF_ASSIGN_OR_RETURN(std::unique_ptr<HloLiveRange> hlo_live_range,\n                      HloLiveRange::Run(module_->schedule(), *alias_analysis,\n                                        module_->entry_computation()))",
          "new_text": "computation->name()",
          "old_line_content": "  TF_ASSIGN_OR_RETURN(std::unique_ptr<HloLiveRange> hlo_live_range,",
          "new_line_content": "        << \"New sequence for computation \" << computation->name() << \" has \"",
          "content_same": false
        },
        {
          "line": 3379,
          "old_api": "schedule",
          "new_api": "size",
          "old_text": "module_->schedule()",
          "new_text": "new_sequence.size()",
          "old_line_content": "                      HloLiveRange::Run(module_->schedule(), *alias_analysis,",
          "new_line_content": "        << new_sequence.size() << \" instructions, expects \"",
          "content_same": false
        },
        {
          "line": 3380,
          "old_api": "entry_computation",
          "new_api": "instruction_count",
          "old_text": "module_->entry_computation()",
          "new_text": "computation->instruction_count()",
          "old_line_content": "                                        module_->entry_computation()));",
          "new_line_content": "        << computation->instruction_count() << \".\";",
          "content_same": false
        },
        {
          "line": 3407,
          "old_api": "OverlapsWith",
          "new_api": "id",
          "old_text": "chunk.OverlapsWith(overlapping_chunk)",
          "new_text": "value->id()",
          "old_line_content": "      if (chunk.OverlapsWith(overlapping_chunk)) {",
          "new_line_content": "    events[std::make_tuple(start_time, /*is_free=*/false, value->id())] =",
          "content_same": false
        },
        {
          "line": 3408,
          "old_api": "ToShortString",
          "new_api": "std::make_tuple(value, chunk, HeapSimulatorTrace::Event::ALLOC)",
          "old_text": "InternalError(\n            (\"Value %s (%d, %d) off: %d size: %d overlaps with another chunk\"\n             \" off: %d size: %d\"),\n            value->ToShortString(), start_time, end_time, chunk.offset,\n            chunk.size, overlapping_chunk.offset, overlapping_chunk.size)",
          "new_text": "std::make_tuple(value, chunk, HeapSimulatorTrace::Event::ALLOC)",
          "old_line_content": "        return InternalError(",
          "new_line_content": "        std::make_tuple(value, chunk, HeapSimulatorTrace::Event::ALLOC);",
          "content_same": false
        },
        {
          "line": 3424,
          "old_api": "opcode",
          "new_api": "ToShortString",
          "old_text": "instruction->opcode()",
          "new_text": "value->ToShortString()",
          "old_line_content": "      if (instruction->opcode() == HloOpcode::kCopyStart) {",
          "new_line_content": "            value->ToShortString(), start_time, end_time, chunk.offset,",
          "content_same": false
        },
        {
          "line": 3435,
          "old_api": "ToString",
          "new_api": "MakeNonfusionComputations",
          "old_text": "instruction->ToString()",
          "new_text": "module_->MakeNonfusionComputations()",
          "old_line_content": "            << instruction->ToString();",
          "new_line_content": "       module_->MakeNonfusionComputations()) {",
          "content_same": false
        },
        {
          "line": 3453,
          "old_api": "at",
          "new_api": "chunks",
          "old_text": "hlo_live_range->buffer_live_ranges().at(value)",
          "new_text": "preset_assignments_->chunks()",
          "old_line_content": "          hlo_live_range->buffer_live_ranges().at(value);",
          "new_line_content": "  for (const auto& position_and_chunk : preset_assignments_->chunks()) {",
          "content_same": false
        },
        {
          "line": 3458,
          "old_api": "at",
          "new_api": "id",
          "old_text": "hlo_live_range->instruction_schedule().at(use.instruction)",
          "new_text": "buffer.id()",
          "old_line_content": "            hlo_live_range->instruction_schedule().at(use.instruction);",
          "new_line_content": "    CHECK(!seen_buffers.contains(buffer.id()))",
          "content_same": false
        },
        {
          "line": 3513,
          "old_api": "opcode",
          "new_api": "at",
          "old_text": "last_use_instruction->opcode()",
          "new_text": "hlo_live_range->instruction_schedule().at(use.instruction)",
          "old_line_content": "            if (last_use_instruction->opcode() == HloOpcode::kConditional) {",
          "new_line_content": "                hlo_live_range->instruction_schedule().at(use.instruction);",
          "content_same": false
        },
        {
          "line": 3521,
          "old_api": "add_allocation_and_verify",
          "new_api": "CHECK_NE",
          "old_text": "add_allocation_and_verify(\n                  parameter_time, last_use_time, chunk, value)",
          "new_text": "CHECK_NE(parameter_time, -1)",
          "old_line_content": "              TF_RETURN_IF_ERROR(add_allocation_and_verify(",
          "new_line_content": "            CHECK_NE(parameter_time, -1);",
          "content_same": false
        },
        {
          "line": 3526,
          "old_api": "VLOG",
          "new_api": "opcode",
          "old_text": "VLOG(3)",
          "new_text": "last_use_instruction->opcode()",
          "old_line_content": "        VLOG(3) << indent_string << \" from beginning until first computation: (\"",
          "new_line_content": "            if (last_use_instruction->opcode() == HloOpcode::kConditional) {",
          "content_same": false
        },
        {
          "line": 3529,
          "old_api": "add_allocation_and_verify",
          "new_api": "split_conditional_buffer",
          "old_text": "add_allocation_and_verify(\n            start_time, earliest_computation_start_time - 1, chunk, value)",
          "new_text": "split_conditional_buffer(\n                  last_use_instruction, parameter_time, last_use_time,\n                  absl::StrCat(indent_string, \"  \"))",
          "old_line_content": "        TF_RETURN_IF_ERROR(add_allocation_and_verify(",
          "new_line_content": "              TF_RETURN_IF_ERROR(split_conditional_buffer(",
          "content_same": false
        },
        {
          "line": 3531,
          "old_api": "Status::OK()",
          "new_api": "absl::StrCat(indent_string, \"  \")",
          "old_text": "Status::OK()",
          "new_text": "absl::StrCat(indent_string, \"  \")",
          "old_line_content": "        return Status::OK();",
          "new_line_content": "                  absl::StrCat(indent_string, \"  \")));",
          "content_same": false
        },
        {
          "line": 3539,
          "old_api": "std::min(last_use_time, time_bound.end)",
          "new_api": "VLOG",
          "old_text": "std::min(last_use_time, time_bound.end)",
          "new_text": "VLOG(3)",
          "old_line_content": "        last_use_time = std::min(last_use_time, time_bound.end);",
          "new_line_content": "        VLOG(3) << indent_string << \" from beginning until first computation: (\"",
          "content_same": false
        },
        {
          "line": 3544,
          "old_api": "add_allocation_and_verify",
          "new_api": "Status::OK()",
          "old_text": "add_allocation_and_verify(\n            time_bound.start, last_use_time, chunk, value)",
          "new_text": "Status::OK()",
          "old_line_content": "        TF_RETURN_IF_ERROR(add_allocation_and_verify(",
          "new_line_content": "        return Status::OK();",
          "content_same": false
        },
        {
          "line": 3551,
          "old_api": "assignment_information_for_space",
          "new_api": "empty",
          "old_text": "preset_assignments_\n           ->assignment_information_for_space(options_.alternate_memory_space)",
          "new_text": "value->uses().empty()",
          "old_line_content": "      &preset_assignments_",
          "new_line_content": "      } else if (!value->uses().empty()) {",
          "content_same": false
        },
        {
          "line": 3564,
          "old_api": "std::tie(value, chunk, kind)",
          "new_api": "assignment_information_for_space",
          "old_text": "std::tie(value, chunk, kind)",
          "new_text": "preset_assignments_\n           ->assignment_information_for_space(options_.alternate_memory_space)",
          "old_line_content": "    std::tie(value, chunk, kind) = event.second;",
          "new_line_content": "      &preset_assignments_",
          "content_same": false
        },
        {
          "line": 3578,
          "old_api": "std::max(max_memory_usage, memory_usage)",
          "new_api": "add_events",
          "old_text": "std::max(max_memory_usage, memory_usage)",
          "new_text": "heap_trace->add_events()",
          "old_line_content": "    max_memory_usage = std::max(max_memory_usage, memory_usage);",
          "new_line_content": "    HeapSimulatorTrace::Event* heap_trace_event = heap_trace->add_events();",
          "content_same": false
        },
        {
          "line": 3579,
          "old_api": "VLOG",
          "new_api": "set_kind",
          "old_text": "VLOG(4)",
          "new_text": "heap_trace_event->set_kind(kind)",
          "old_line_content": "    VLOG(4) << \"Memory usage: \" << memory_usage << \" at time: \" << time;",
          "new_line_content": "    heap_trace_event->set_kind(kind);",
          "content_same": false
        },
        {
          "line": 3581,
          "old_api": "VLOG",
          "new_api": "instruction",
          "old_text": "VLOG(1)",
          "new_text": "value->instruction()->name()",
          "old_line_content": "  VLOG(1) << \"Max memory usage ignoring fragmentation: \" << max_memory_usage;",
          "new_line_content": "    heap_trace_event->set_instruction_name(value->instruction()->name());",
          "content_same": false
        },
        {
          "line": 3583,
          "old_api": "Status::OK()",
          "new_api": "instruction",
          "old_text": "Status::OK()",
          "new_text": "value->instruction()->parent()->name()",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "        value->instruction()->parent()->name());",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2056,
          "old_api": null,
          "new_api": "CHECK_NE",
          "old_text": null,
          "new_text": "CHECK_NE(allocation, nullptr)",
          "old_line_content": "          << \". Size = \" << request.size",
          "new_line_content": "    CHECK_NE(allocation, nullptr);",
          "content_same": false
        },
        {
          "line": 2062,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "request.allocation_value->defining_position()",
          "old_line_content": "  // we're allowed to prefetch. If the use expects the output to be in default",
          "new_line_content": "      request.allocation_value->defining_position();",
          "content_same": false
        },
        {
          "line": 2063,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(2)",
          "old_line_content": "  // memory, we cannot prefetch it because if we did, it would be in alternate",
          "new_line_content": "  VLOG(2) << \"Finding allocation for \"",
          "content_same": false
        },
        {
          "line": 2064,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "request.allocation_value->ToShortString()",
          "old_line_content": "  // memory instead.",
          "new_line_content": "          << request.allocation_value->ToShortString() << \" (\"",
          "content_same": false
        },
        {
          "line": 2067,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "request.allocation_value->uses().back()",
          "old_line_content": "  absl::optional<MemorySpace> required_memory_space_at_start;",
          "new_line_content": "          << \" last use = \" << request.allocation_value->uses().back().time",
          "content_same": false
        },
        {
          "line": 2068,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "request.use->hlo_use.ToString()",
          "old_line_content": "  if (required_assignment_at_start) {",
          "new_line_content": "          << \" use = \" << request.use->hlo_use.ToString()",
          "content_same": false
        },
        {
          "line": 2070,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "defining_position.ToString()",
          "old_line_content": "  }",
          "new_line_content": "          << \", def pos = \" << defining_position.ToString();",
          "content_same": false
        },
        {
          "line": 2071,
          "old_api": null,
          "new_api": "CHECK_LE",
          "old_text": null,
          "new_text": "CHECK_LE(request.start_time, request.end_time)",
          "old_line_content": "  // Find required assignment both for the use and its aliases. If they are both",
          "new_line_content": "  CHECK_LE(request.start_time, request.end_time);",
          "content_same": false
        },
        {
          "line": 2078,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "RequiredMemoryAssignmentAt(\n      request.allocation_value->value(), request.start_time)",
          "old_line_content": "    if (required_assignment_at_end == absl::nullopt) {",
          "new_line_content": "  auto required_assignment_at_start = RequiredMemoryAssignmentAt(",
          "content_same": false
        },
        {
          "line": 2079,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "request.allocation_value->value()",
          "old_line_content": "      required_assignment_at_end = aliased_required_assignment_at_end;",
          "new_line_content": "      request.allocation_value->value(), request.start_time);",
          "content_same": false
        },
        {
          "line": 2086,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "RequiredMemoryAssignmentAt(\n      request.allocation_value->value(), request.end_time)",
          "old_line_content": "  absl::optional<MemorySpace> required_memory_space_at_end;",
          "new_line_content": "  auto required_assignment_at_end = RequiredMemoryAssignmentAt(",
          "content_same": false
        },
        {
          "line": 2087,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "request.allocation_value->value()",
          "old_line_content": "  if (required_assignment_at_end) {",
          "new_line_content": "      request.allocation_value->value(), request.end_time);",
          "content_same": false
        },
        {
          "line": 2089,
          "old_api": null,
          "new_api": "AliasedRequiredAssignmentForUse",
          "old_text": null,
          "new_text": "AliasedRequiredAssignmentForUse(*request.use)",
          "old_line_content": "  }",
          "new_line_content": "      AliasedRequiredAssignmentForUse(*request.use);",
          "content_same": false
        },
        {
          "line": 2095,
          "old_api": null,
          "new_api": "equals_ignoring_time",
          "old_text": null,
          "new_text": "aliased_required_assignment_at_end->equals_ignoring_time(\n                *required_assignment_at_end)",
          "old_line_content": "          [&](const auto& allocation) {",
          "new_line_content": "            aliased_required_assignment_at_end->equals_ignoring_time(",
          "content_same": false
        },
        {
          "line": 2105,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "allocation_sequence->empty()",
          "old_line_content": "          MemorySpace::kAlternate) {",
          "new_line_content": "    if (!allocation_sequence->empty()) {",
          "content_same": false
        },
        {
          "line": 2106,
          "old_api": null,
          "new_api": "rbegin",
          "old_text": null,
          "new_text": "std::find_if(\n          allocation_sequence->rbegin(), allocation_sequence->rend(),\n          [&](const auto& allocation) {\n            return allocation->memory_space() ==\n                       required_memory_space_at_start &&\n                   allocation->defining_position() == defining_position;\n          })",
          "old_line_content": "        aliased_chunk =",
          "new_line_content": "      auto prev_allocation_it = std::find_if(",
          "content_same": false
        },
        {
          "line": 2107,
          "old_api": null,
          "new_api": "rend",
          "old_text": null,
          "new_text": "allocation_sequence->rend()",
          "old_line_content": "            Chunk{required_assignment_at_start->offset->offset, request.size};",
          "new_line_content": "          allocation_sequence->rbegin(), allocation_sequence->rend(),",
          "content_same": false
        },
        {
          "line": 2111,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "allocation->defining_position()",
          "old_line_content": "              defining_position, required_assignment_at_start->memory_space,",
          "new_line_content": "                   allocation->defining_position() == defining_position;",
          "content_same": false
        },
        {
          "line": 2113,
          "old_api": null,
          "new_api": "rend",
          "old_text": null,
          "new_text": "allocation_sequence->rend()",
          "old_line_content": "              /*is_scoped_allocation=*/false));",
          "new_line_content": "      CHECK(prev_allocation_it != allocation_sequence->rend());",
          "content_same": false
        },
        {
          "line": 2114,
          "old_api": null,
          "new_api": "Extend",
          "old_text": null,
          "new_text": "*prev_allocation_it)->Extend(request.start_time)",
          "old_line_content": "      if (required_assignment_at_start->memory_space ==",
          "new_line_content": "      (*prev_allocation_it)->Extend(request.start_time);",
          "content_same": false
        },
        {
          "line": 2122,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "allocation_sequence->push_back(\n          absl::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, required_assignment_at_start->memory_space,\n              aliased_chunk, request.start_time, request.start_time,\n              /*is_scoped_allocation=*/false))",
          "old_line_content": "  Result allocation_result = Result::kSuccess;",
          "new_line_content": "      allocation_sequence->push_back(",
          "content_same": false
        },
        {
          "line": 2123,
          "old_api": null,
          "new_api": "absl::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, required_assignment_at_start->memory_space,\n              aliased_chunk, request.start_time, request.start_time,\n              /*is_scoped_allocation=*/false)",
          "old_text": null,
          "new_text": "absl::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, required_assignment_at_start->memory_space,\n              aliased_chunk, request.start_time, request.start_time,\n              /*is_scoped_allocation=*/false)",
          "old_line_content": "  // First try keeping the allocation entirely in the alternate memory.",
          "new_line_content": "          absl::make_unique<MemorySpaceAssignment::Allocation>(",
          "content_same": false
        },
        {
          "line": 2129,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "allocation_sequence->back()",
          "old_line_content": "      return Result::kSuccess;",
          "new_line_content": "        CreateOrAddToAliasedOffset(*allocation_sequence->back(),",
          "content_same": false
        },
        {
          "line": 2149,
          "old_api": null,
          "new_api": "rbegin",
          "old_text": null,
          "new_text": "std::find_if(\n      allocation_sequence->rbegin(), allocation_sequence->rend(),\n      [&](const auto& allocation) {\n        return allocation->memory_space() == MemorySpace::kDefault &&\n               allocation->defining_position() == defining_position;\n      })",
          "old_line_content": "    // memory space, we also need to perform an eviction.",
          "new_line_content": "  auto prev_allocation_in_default_mem_it = std::find_if(",
          "content_same": false
        },
        {
          "line": 2152,
          "old_api": null,
          "new_api": "memory_space",
          "old_text": null,
          "new_text": "allocation->memory_space()",
          "old_line_content": "      // A non-success eviction requires us to uncommit previous allocations.",
          "new_line_content": "        return allocation->memory_space() == MemorySpace::kDefault &&",
          "content_same": false
        },
        {
          "line": 2159,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "*prev_allocation_it)->defining_position()",
          "old_line_content": "            defining_position, MemorySpace::kDefault, /*chunk=*/absl::nullopt,",
          "new_line_content": "      (*prev_allocation_it)->defining_position() == defining_position &&",
          "content_same": false
        },
        {
          "line": 2160,
          "old_api": null,
          "new_api": "requires_contiguous_allocation",
          "old_text": null,
          "new_text": "request.allocation_value->requires_contiguous_allocation()",
          "old_line_content": "            request.start_time, request.end_time,",
          "new_line_content": "      !request.allocation_value->requires_contiguous_allocation()) {",
          "content_same": false
        },
        {
          "line": 2163,
          "old_api": null,
          "new_api": "Evict",
          "old_text": null,
          "new_text": "Evict(request)",
          "old_line_content": "  }",
          "new_line_content": "    Result eviction_result = Evict(request);",
          "content_same": false
        },
        {
          "line": 2168,
          "old_api": null,
          "new_api": "rbegin",
          "old_text": null,
          "new_text": "allocation_sequence->rbegin()",
          "old_line_content": "",
          "new_line_content": "    prev_allocation_in_default_mem_it = allocation_sequence->rbegin();",
          "content_same": false
        },
        {
          "line": 2169,
          "old_api": null,
          "new_api": "rend",
          "old_text": null,
          "new_text": "allocation_sequence->rend()",
          "old_line_content": "  // If the buffer must be in default memory at the end_time, don't prefetch.",
          "new_line_content": "  } else if (prev_allocation_in_default_mem_it == allocation_sequence->rend()) {",
          "content_same": false
        },
        {
          "line": 2170,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "allocation_sequence->push_back(\n        absl::make_unique<MemorySpaceAssignment::Allocation>(\n            defining_position, MemorySpace::kDefault, /*chunk=*/absl::nullopt,\n            request.start_time, request.end_time,\n            /*is_scoped_allocation=*/false))",
          "old_line_content": "  if (required_memory_space_at_end == MemorySpace::kDefault) {",
          "new_line_content": "    allocation_sequence->push_back(",
          "content_same": false
        },
        {
          "line": 123,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "bi.buffer->uses()",
          "old_line_content": "",
          "new_line_content": "        for (const auto& use : bi.buffer->uses()) {",
          "content_same": false
        },
        {
          "line": 2175,
          "old_api": null,
          "new_api": "rbegin",
          "old_text": null,
          "new_text": "allocation_sequence->rbegin()",
          "old_line_content": "    return Result::kSuccess;",
          "new_line_content": "    prev_allocation_in_default_mem_it = allocation_sequence->rbegin();",
          "content_same": false
        },
        {
          "line": 128,
          "old_api": null,
          "new_api": "get_use_size",
          "old_text": null,
          "new_text": "get_use_size(y)",
          "old_line_content": "  return *best_candidate;",
          "new_line_content": "      return get_use_size(x) < get_use_size(y);",
          "content_same": false
        },
        {
          "line": 2178,
          "old_api": null,
          "new_api": "rend",
          "old_text": null,
          "new_text": "allocation_sequence->rend()",
          "old_line_content": "  // Finally, try to prefetch the buffer into alternate memory.",
          "new_line_content": "  CHECK(prev_allocation_in_default_mem_it != allocation_sequence->rend());",
          "content_same": false
        },
        {
          "line": 2184,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "    }",
          "new_line_content": "    VLOG(3)",
          "content_same": false
        },
        {
          "line": 137,
          "old_api": null,
          "new_api": "absl::c_max_element(candidates, compare)",
          "old_text": null,
          "new_text": "absl::c_max_element(candidates, compare)",
          "old_line_content": "    float alternate_mem_bandwidth_bytes_per_second, const HloModule& module) {",
          "new_line_content": "  auto best_candidate = absl::c_max_element(candidates, compare);",
          "content_same": false
        },
        {
          "line": 138,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "candidates.end()",
          "old_line_content": "  TF_ASSIGN_OR_RETURN(auto alias_analysis, HloAliasAnalysis::Run(&module));",
          "new_line_content": "  if (best_candidate == candidates.end()) {",
          "content_same": false
        },
        {
          "line": 2186,
          "old_api": null,
          "new_api": "Extend",
          "old_text": null,
          "new_text": "*prev_allocation_in_default_mem_it)->Extend(request.end_time)",
          "old_line_content": "  }",
          "new_line_content": "    (*prev_allocation_in_default_mem_it)->Extend(request.end_time);",
          "content_same": false
        },
        {
          "line": 2187,
          "old_api": null,
          "new_api": "AddUse",
          "old_text": null,
          "new_text": "*prev_allocation_in_default_mem_it)->AddUse(request.use->hlo_use)",
          "old_line_content": "",
          "new_line_content": "    (*prev_allocation_in_default_mem_it)->AddUse(request.use->hlo_use);",
          "content_same": false
        },
        {
          "line": 2192,
          "old_api": null,
          "new_api": "requires_contiguous_allocation",
          "old_text": null,
          "new_text": "request.allocation_value->requires_contiguous_allocation()",
          "old_line_content": "  }",
          "new_line_content": "  if (!request.allocation_value->requires_contiguous_allocation()) {",
          "content_same": false
        },
        {
          "line": 2194,
          "old_api": null,
          "new_api": "Prefetch",
          "old_text": null,
          "new_text": "Prefetch(request, **prev_allocation_in_default_mem_it)",
          "old_line_content": "  // If the start assignment was required to be in alternate memory and the",
          "new_line_content": "        Prefetch(request, **prev_allocation_in_default_mem_it);",
          "content_same": false
        },
        {
          "line": 156,
          "old_api": null,
          "new_api": "absl::WrapUnique(new MemorySpaceAssignmentCostAnalysis(\n      cost_analysis, async_copy_bandwidth_bytes_per_second,\n      alternate_mem_bandwidth_bytes_per_second, std::move(alias_analysis),\n      std::move(hlo_live_range), std::move(call_graph)))",
          "old_text": null,
          "new_text": "absl::WrapUnique(new MemorySpaceAssignmentCostAnalysis(\n      cost_analysis, async_copy_bandwidth_bytes_per_second,\n      alternate_mem_bandwidth_bytes_per_second, std::move(alias_analysis),\n      std::move(hlo_live_range), std::move(call_graph)))",
          "old_line_content": "  if (elapsed_time_due_to_memory > elapsed_time_due_to_compute) {",
          "new_line_content": "  return absl::WrapUnique(new MemorySpaceAssignmentCostAnalysis(",
          "content_same": false
        },
        {
          "line": 158,
          "old_api": null,
          "new_api": "std::move(alias_analysis)",
          "old_text": null,
          "new_text": "std::move(alias_analysis)",
          "old_line_content": "    float while_nest_multiplier;",
          "new_line_content": "      alternate_mem_bandwidth_bytes_per_second, std::move(alias_analysis),",
          "content_same": false
        },
        {
          "line": 159,
          "old_api": null,
          "new_api": "std::move(call_graph)",
          "old_text": null,
          "new_text": "std::move(call_graph)",
          "old_line_content": "    if (cache) {",
          "new_line_content": "      std::move(hlo_live_range), std::move(call_graph)));",
          "content_same": false
        },
        {
          "line": 2211,
          "old_api": null,
          "new_api": "requires_contiguous_allocation",
          "old_text": null,
          "new_text": "request.allocation_value->requires_contiguous_allocation()",
          "old_line_content": "    MemorySpace memory_space, absl::optional<Chunk> chunk, int64 start_time,",
          "new_line_content": "      request.allocation_value->requires_contiguous_allocation()) {",
          "content_same": false
        },
        {
          "line": 2212,
          "old_api": null,
          "new_api": "result_mark",
          "old_text": null,
          "new_text": "result_mark(Result::kFailRequiresUncommit, allocation_result)",
          "old_line_content": "    int64 end_time, int64 copy_done_schedule_before_time,",
          "new_line_content": "    return result_mark(Result::kFailRequiresUncommit, allocation_result);",
          "content_same": false
        },
        {
          "line": 166,
          "old_api": null,
          "new_api": "GetInstructionElapsedDueToCompute",
          "old_text": null,
          "new_text": "GetInstructionElapsedDueToCompute(instruction)",
          "old_line_content": "            kWhileExecutionCount,",
          "new_line_content": "      GetInstructionElapsedDueToCompute(instruction);",
          "content_same": false
        },
        {
          "line": 168,
          "old_api": null,
          "new_api": "GetInstructionElapsedDueToMemory",
          "old_text": null,
          "new_text": "GetInstructionElapsedDueToMemory(instruction)",
          "old_line_content": "                                          /*while_only=*/true));",
          "new_line_content": "      GetInstructionElapsedDueToMemory(instruction);",
          "content_same": false
        },
        {
          "line": 2217,
          "old_api": null,
          "new_api": "Extend",
          "old_text": null,
          "new_text": "*prev_allocation_in_default_mem_it)->Extend(request.end_time)",
          "old_line_content": "                  ? \"default\"",
          "new_line_content": "  (*prev_allocation_in_default_mem_it)->Extend(request.end_time);",
          "content_same": false
        },
        {
          "line": 2218,
          "old_api": null,
          "new_api": "AddUse",
          "old_text": null,
          "new_text": "*prev_allocation_in_default_mem_it)->AddUse(request.use->hlo_use)",
          "old_line_content": "                  : \"alternate\")",
          "new_line_content": "  (*prev_allocation_in_default_mem_it)->AddUse(request.use->hlo_use);",
          "content_same": false
        },
        {
          "line": 175,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "cache->while_nest_multiplier.end()",
          "old_line_content": "                                        /*while_only=*/true));",
          "new_line_content": "      if (it != cache->while_nest_multiplier.end()) {",
          "content_same": false
        },
        {
          "line": 178,
          "old_api": null,
          "new_api": "tensorflow::MathUtil::IPow<float>(\n            kWhileExecutionCount,\n            CalculateComputationNestLevel(&instruction,\n                                          /*while_only=*/true))",
          "old_text": null,
          "new_text": "tensorflow::MathUtil::IPow<float>(\n            kWhileExecutionCount,\n            CalculateComputationNestLevel(&instruction,\n                                          /*while_only=*/true))",
          "old_line_content": "           while_nest_multiplier;",
          "new_line_content": "        while_nest_multiplier = tensorflow::MathUtil::IPow<float>(",
          "content_same": false
        },
        {
          "line": 180,
          "old_api": null,
          "new_api": "CalculateComputationNestLevel",
          "old_text": null,
          "new_text": "CalculateComputationNestLevel(&instruction,\n                                          /*while_only=*/true)",
          "old_line_content": "    // Compute bound, return how far off are we to memory boundedness.",
          "new_line_content": "            CalculateComputationNestLevel(&instruction,",
          "content_same": false
        },
        {
          "line": 2228,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "  // Register the additional async copy with the interval tree to keep track of",
          "new_line_content": "  VLOG(3) << \"Copy to \"",
          "content_same": false
        },
        {
          "line": 185,
          "old_api": null,
          "new_api": "tensorflow::MathUtil::IPow<float>(\n          kWhileExecutionCount,\n          CalculateComputationNestLevel(&instruction,\n                                        /*while_only=*/true))",
          "old_text": null,
          "new_text": "tensorflow::MathUtil::IPow<float>(\n          kWhileExecutionCount,\n          CalculateComputationNestLevel(&instruction,\n                                        /*while_only=*/true))",
          "old_line_content": "float MemorySpaceAssignmentCostAnalysis::GetMemoryBoundedness(",
          "new_line_content": "      while_nest_multiplier = tensorflow::MathUtil::IPow<float>(",
          "content_same": false
        },
        {
          "line": 2234,
          "old_api": null,
          "new_api": "CHECK_LT",
          "old_text": null,
          "new_text": "CHECK_LT(start_time, copy_done_schedule_before_time)",
          "old_line_content": "                                kDummyChunk);",
          "new_line_content": "  CHECK_LT(start_time, copy_done_schedule_before_time);",
          "content_same": false
        },
        {
          "line": 187,
          "old_api": null,
          "new_api": "CalculateComputationNestLevel",
          "old_text": null,
          "new_text": "CalculateComputationNestLevel(&instruction,\n                                        /*while_only=*/true)",
          "old_line_content": "    MemorySpaceAssignmentCostAnalysis::Cache* cache) const {",
          "new_line_content": "          CalculateComputationNestLevel(&instruction,",
          "content_same": false
        },
        {
          "line": 2237,
          "old_api": null,
          "new_api": "absl::make_unique<MemorySpaceAssignment::CopyAllocation>(\n          prev_allocation, memory_space, chunk, start_time, end_time,\n          copy_done_schedule_before_time, is_cross_program_prefetch)",
          "old_text": null,
          "new_text": "absl::make_unique<MemorySpaceAssignment::CopyAllocation>(\n          prev_allocation, memory_space, chunk, start_time, end_time,\n          copy_done_schedule_before_time, is_cross_program_prefetch)",
          "old_line_content": "  } else {",
          "new_line_content": "      absl::make_unique<MemorySpaceAssignment::CopyAllocation>(",
          "content_same": false
        },
        {
          "line": 2243,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "pending_async_copies_.push_back(\n      {start_time, copy_done_schedule_before_time, memory_space})",
          "old_line_content": "bool AlternateMemoryBestFitHeap::ViolatesMaximumOutstandingAsyncCopies(",
          "new_line_content": "  pending_async_copies_.push_back(",
          "content_same": false
        },
        {
          "line": 2246,
          "old_api": null,
          "new_api": "Add",
          "old_text": null,
          "new_text": "prefetch_interval_tree_.Add(start_time, copy_done_schedule_before_time,\n                                kDummyChunk)",
          "old_line_content": "  if (options_.max_outstanding_prefetches < 0 && is_prefetch) {",
          "new_line_content": "    prefetch_interval_tree_.Add(start_time, copy_done_schedule_before_time,",
          "content_same": false
        },
        {
          "line": 2248,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "pending_async_copies_.back()",
          "old_line_content": "  }",
          "new_line_content": "    async_copy_ordering_.AddCopy(pending_async_copies_.back());",
          "content_same": false
        },
        {
          "line": 2249,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "allocations->back()",
          "old_line_content": "  if (options_.max_outstanding_evictions < 0 && !is_prefetch) {",
          "new_line_content": "    CreateOrAddToAliasedOffset(*allocations->back(), aliased_offset);",
          "content_same": false
        },
        {
          "line": 202,
          "old_api": null,
          "new_api": "defining_instruction",
          "old_text": null,
          "new_text": "interval.buffer->defining_instruction()",
          "old_line_content": "        // don't use the benefit of while and conditional directly.",
          "new_line_content": "      *interval.buffer->defining_instruction();",
          "content_same": false
        },
        {
          "line": 2251,
          "old_api": null,
          "new_api": "Add",
          "old_text": null,
          "new_text": "eviction_interval_tree_.Add(start_time, copy_done_schedule_before_time,\n                                kDummyChunk)",
          "old_line_content": "  }",
          "new_line_content": "    eviction_interval_tree_.Add(start_time, copy_done_schedule_before_time,",
          "content_same": false
        },
        {
          "line": 205,
          "old_api": null,
          "new_api": "GetInstructionElapsedDueToMemory",
          "old_text": null,
          "new_text": "GetInstructionElapsedDueToMemory(defining_instruction,\n                                       /*operand_in_alternate_mem=*/{},\n                                       /*output_in_alternate_mem=*/true)",
          "old_line_content": "          continue;",
          "new_line_content": "      GetInstructionElapsedDueToMemory(defining_instruction,",
          "content_same": false
        },
        {
          "line": 210,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "interval.buffer->defining_position()",
          "old_line_content": "                                          *use.instruction, use.operand_number),",
          "new_line_content": "           interval.buffer->defining_position().instruction,",
          "content_same": false
        },
        {
          "line": 211,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "interval.buffer->defining_position()",
          "old_line_content": "                                      cache);",
          "new_line_content": "           interval.buffer->defining_position().index)) {",
          "content_same": false
        },
        {
          "line": 212,
          "old_api": null,
          "new_api": "values",
          "old_text": null,
          "new_text": "buffer->values()",
          "old_line_content": "        // If the benefit is positive (memory bound), add it to this buffer's",
          "new_line_content": "    for (const HloValue* value : buffer->values()) {",
          "content_same": false
        },
        {
          "line": 213,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "value->uses()",
          "old_line_content": "        // benefit. If the benefit is negative (compute bound), calculate the",
          "new_line_content": "      for (const HloUse& use : value->uses()) {",
          "content_same": false
        },
        {
          "line": 216,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "use.instruction->opcode()",
          "old_line_content": "          alternate_mem_benefit += use_alternate_mem_benefit;",
          "new_line_content": "        if (use.instruction->opcode() == HloOpcode::kWhile ||",
          "content_same": false
        },
        {
          "line": 217,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "use.instruction->opcode()",
          "old_line_content": "        } else {",
          "new_line_content": "            use.instruction->opcode() == HloOpcode::kConditional) {",
          "content_same": false
        },
        {
          "line": 221,
          "old_api": null,
          "new_api": "GetAlternateMemoryBenefit",
          "old_text": null,
          "new_text": "GetAlternateMemoryBenefit(*use.instruction,\n                                      GetInstructionElapsedDueToMemory(\n                                          *use.instruction, use.operand_number),\n                                      cache)",
          "old_line_content": "      }",
          "new_line_content": "            GetAlternateMemoryBenefit(*use.instruction,",
          "content_same": false
        },
        {
          "line": 222,
          "old_api": null,
          "new_api": "GetInstructionElapsedDueToMemory",
          "old_text": null,
          "new_text": "GetInstructionElapsedDueToMemory(\n                                          *use.instruction, use.operand_number)",
          "old_line_content": "    }",
          "new_line_content": "                                      GetInstructionElapsedDueToMemory(",
          "content_same": false
        },
        {
          "line": 2269,
          "old_api": null,
          "new_api": "ChunksOverlappingInTime",
          "old_text": null,
          "new_text": "prefetch_interval_tree_.ChunksOverlappingInTime(start_time, end_time)\n            .size()",
          "old_line_content": "absl::optional<AsynchronousCopy>",
          "new_line_content": "        prefetch_interval_tree_.ChunksOverlappingInTime(start_time, end_time)",
          "content_same": false
        },
        {
          "line": 2275,
          "old_api": null,
          "new_api": "ChunksOverlappingInTime",
          "old_text": null,
          "new_text": "eviction_interval_tree_.ChunksOverlappingInTime(start_time, end_time)\n            .size()",
          "old_line_content": "AlternateMemoryBestFitHeap::Result",
          "new_line_content": "        eviction_interval_tree_.ChunksOverlappingInTime(start_time, end_time)",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": null,
          "new_api": "std::max(alternate_mem_benefit, use_alternate_mem_benefit)",
          "old_text": null,
          "new_text": "std::max(alternate_mem_benefit, use_alternate_mem_benefit)",
          "old_line_content": "    const HloInstruction* instruction, bool while_only) const {",
          "new_line_content": "              std::max(alternate_mem_benefit, use_alternate_mem_benefit);",
          "content_same": false
        },
        {
          "line": 2285,
          "old_api": null,
          "new_api": "ViolatesOrdering",
          "old_text": null,
          "new_text": "async_copy_ordering_.ViolatesOrdering(start_time, end_time)",
          "old_line_content": "  } else {",
          "new_line_content": "  return async_copy_ordering_.ViolatesOrdering(start_time, end_time);",
          "content_same": false
        },
        {
          "line": 241,
          "old_api": null,
          "new_api": "std::sqrt(interval.size)",
          "old_text": null,
          "new_text": "std::sqrt(interval.size)",
          "old_line_content": "      ++nest_level;",
          "new_line_content": "  return alternate_mem_benefit / std::sqrt(interval.size);",
          "content_same": false
        },
        {
          "line": 2293,
          "old_api": null,
          "new_api": "allocation_sequence",
          "old_text": null,
          "new_text": "request.allocation_value->allocation_sequence()->empty()",
          "old_line_content": "",
          "new_line_content": "  if (request.allocation_value->allocation_sequence()->empty()) {",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "instruction->parent()",
          "old_line_content": "",
          "new_line_content": "  const HloComputation* computation = instruction->parent();",
          "content_same": false
        },
        {
          "line": 248,
          "old_api": null,
          "new_api": "IsEntryComputation",
          "old_text": null,
          "new_text": "computation->IsEntryComputation()",
          "old_line_content": "float MemorySpaceAssignmentCostAnalysis::GetInstructionElapsedDueToCompute(",
          "new_line_content": "  while (!computation->IsEntryComputation()) {",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": null,
          "new_api": "GetNode",
          "old_text": null,
          "new_text": "call_graph_->GetNode(computation)",
          "old_line_content": "    const HloInstruction& instruction) const {",
          "new_line_content": "    auto node = call_graph_->GetNode(computation);",
          "content_same": false
        },
        {
          "line": 2296,
          "old_api": null,
          "new_api": "is_allowed_in_alternate_mem_fn",
          "old_text": null,
          "new_text": "options_.is_allowed_in_alternate_mem_fn(\n        *request.allocation_value->value())",
          "old_line_content": "  }",
          "new_line_content": "    can_eliminate_copy = options_.is_allowed_in_alternate_mem_fn(",
          "content_same": false
        },
        {
          "line": 2297,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "request.allocation_value->value()",
          "old_line_content": "",
          "new_line_content": "        *request.allocation_value->value());",
          "content_same": false
        },
        {
          "line": 2302,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "request.allocation_value->allocation_sequence()->back().get()",
          "old_line_content": "          request.end_time)) {",
          "new_line_content": "        request.allocation_value->allocation_sequence()->back().get();",
          "content_same": false
        },
        {
          "line": 256,
          "old_api": null,
          "new_api": "instruction",
          "old_text": null,
          "new_text": "callsite.instruction()->parent()",
          "old_line_content": "",
          "new_line_content": "    computation = callsite.instruction()->parent();",
          "content_same": false
        },
        {
          "line": 2304,
          "old_api": null,
          "new_api": "memory_space",
          "old_text": null,
          "new_text": "prev_allocation->memory_space()",
          "old_line_content": "  }",
          "new_line_content": "        (prev_allocation->memory_space() == MemorySpace::kAlternate);",
          "content_same": false
        },
        {
          "line": 263,
          "old_api": null,
          "new_api": "flop_count",
          "old_text": null,
          "new_text": "std::max(\n      cost_analysis_.flop_count(instruction) /\n          cost_analysis_.per_second_rate(HloCostAnalysis::kFlopsKey),\n      cost_analysis_.transcendental_count(instruction) /\n          cost_analysis_.per_second_rate(HloCostAnalysis::kTranscendentalsKey))",
          "old_line_content": "      bytes_accessed /",
          "new_line_content": "  return std::max(",
          "content_same": false
        },
        {
          "line": 2312,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "request.allocation_value->defining_position()",
          "old_line_content": "  // Prefer the offset that was previously used for the previous allocation.",
          "new_line_content": "      request.allocation_value->defining_position();",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": null,
          "new_api": "per_second_rate",
          "old_text": null,
          "new_text": "cost_analysis_.per_second_rate(HloCostAnalysis::kFlopsKey)",
          "old_line_content": "  if (operand_in_alternate_mem) {",
          "new_line_content": "          cost_analysis_.per_second_rate(HloCostAnalysis::kFlopsKey),",
          "content_same": false
        },
        {
          "line": 266,
          "old_api": null,
          "new_api": "transcendental_count",
          "old_text": null,
          "new_text": "cost_analysis_.transcendental_count(instruction)",
          "old_line_content": "    // Estimate the elapsed time due to the operand being in the alternate",
          "new_line_content": "      cost_analysis_.transcendental_count(instruction) /",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": null,
          "new_api": "per_second_rate",
          "old_text": null,
          "new_text": "cost_analysis_.per_second_rate(HloCostAnalysis::kTranscendentalsKey)",
          "old_line_content": "    // memory space.",
          "new_line_content": "          cost_analysis_.per_second_rate(HloCostAnalysis::kTranscendentalsKey));",
          "content_same": false
        },
        {
          "line": 2313,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(\n          defining_position.shape(), request.start_time + 1,\n          request.end_time)",
          "old_line_content": "  AliasedOffset* preferred_offset = nullptr;",
          "new_line_content": "  if (!options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(",
          "content_same": false
        },
        {
          "line": 2314,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "defining_position.shape()",
          "old_line_content": "  if (prev_allocation != nullptr) {",
          "new_line_content": "          defining_position.shape(), request.start_time + 1,",
          "content_same": false
        },
        {
          "line": 2320,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "request.allocation_value->value()",
          "old_line_content": "",
          "new_line_content": "  alternate_mem_interval.buffer = request.allocation_value->value();",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": null,
          "new_api": "bytes_accessed",
          "old_text": null,
          "new_text": "cost_analysis_.bytes_accessed(instruction)",
          "old_line_content": "        elapsed_due_to_operand_bytes +",
          "new_line_content": "  float bytes_accessed = cost_analysis_.bytes_accessed(instruction);",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": null,
          "new_api": "per_second_rate",
          "old_text": null,
          "new_text": "cost_analysis_.per_second_rate(HloCostAnalysis::kBytesAccessedKey)",
          "old_line_content": "  }",
          "new_line_content": "      cost_analysis_.per_second_rate(HloCostAnalysis::kBytesAccessedKey);",
          "content_same": false
        },
        {
          "line": 2328,
          "old_api": null,
          "new_api": "GetAliasedOffset",
          "old_text": null,
          "new_text": "GetAliasedOffset(*prev_allocation)",
          "old_line_content": "  }",
          "new_line_content": "    preferred_offset = GetAliasedOffset(*prev_allocation);",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": null,
          "new_api": "operand_bytes_accessed",
          "old_text": null,
          "new_text": "cost_analysis_.operand_bytes_accessed(\n        instruction, *operand_in_alternate_mem)",
          "old_line_content": "    float output_bytes_accessed =",
          "new_line_content": "    float operand_bytes_accessed = cost_analysis_.operand_bytes_accessed(",
          "content_same": false
        },
        {
          "line": 2331,
          "old_api": null,
          "new_api": "end_time",
          "old_text": null,
          "new_text": "prev_allocation->end_time()",
          "old_line_content": "          << (preferred_offset ? preferred_offset->offset : -1);",
          "new_line_content": "    alternate_mem_interval.start = prev_allocation->end_time() + 1;",
          "content_same": false
        },
        {
          "line": 2337,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(!preferred_offset || request.preferred_offset == preferred_offset)",
          "old_line_content": "  //                           /         \\",
          "new_line_content": "    CHECK(!preferred_offset || request.preferred_offset == preferred_offset)",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": null,
          "new_api": "output_bytes_accessed",
          "old_text": null,
          "new_text": "cost_analysis_.output_bytes_accessed(instruction)",
          "old_line_content": "    const HloInstruction& instruction) const {",
          "new_line_content": "        cost_analysis_.output_bytes_accessed(instruction);",
          "content_same": false
        },
        {
          "line": 2343,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "  //                                     +-----------+",
          "new_line_content": "  VLOG(3) << \"We can eliminate copy to alternate memory. Preferred offset = \"",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": null,
          "new_api": "per_second_rate",
          "old_text": null,
          "new_text": "cost_analysis_.per_second_rate(HloCostAnalysis::kBytesAccessedKey)",
          "old_line_content": "    absl::optional<int64> operand_in_alternate_mem,",
          "new_line_content": "            cost_analysis_.per_second_rate(HloCostAnalysis::kBytesAccessedKey);",
          "content_same": false
        },
        {
          "line": 309,
          "old_api": null,
          "new_api": "GetInstructionElapsedDueToCompute",
          "old_text": null,
          "new_text": "GetInstructionElapsedDueToCompute(instruction)",
          "old_line_content": "",
          "new_line_content": "  return std::max(GetInstructionElapsedDueToCompute(instruction),",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": null,
          "new_api": "GetInstructionElapsedDueToMemory",
          "old_text": null,
          "new_text": "GetInstructionElapsedDueToMemory(instruction)",
          "old_line_content": "float MemorySpaceAssignmentCostAnalysis::GetAsyncCopyElapsed(",
          "new_line_content": "                  GetInstructionElapsedDueToMemory(instruction));",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": null,
          "new_api": "std::max(\n      GetInstructionElapsedDueToCompute(instruction),\n      GetInstructionElapsedDueToMemory(instruction, operand_in_alternate_mem,\n                                       output_in_alternate_mem))",
          "old_text": null,
          "new_text": "std::max(\n      GetInstructionElapsedDueToCompute(instruction),\n      GetInstructionElapsedDueToMemory(instruction, operand_in_alternate_mem,\n                                       output_in_alternate_mem))",
          "old_line_content": "int64 MemorySpaceAssignmentCostAnalysis::GetScheduleEndTime() const {",
          "new_line_content": "  return std::max(",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": null,
          "new_api": "GetInstructionElapsedDueToMemory",
          "old_text": null,
          "new_text": "GetInstructionElapsedDueToMemory(instruction, operand_in_alternate_mem,\n                                       output_in_alternate_mem)",
          "old_line_content": "}",
          "new_line_content": "      GetInstructionElapsedDueToMemory(instruction, operand_in_alternate_mem,",
          "content_same": false
        },
        {
          "line": 325,
          "old_api": null,
          "new_api": "GetShapeSize",
          "old_text": null,
          "new_text": "cost_analysis_.GetShapeSize(shape)",
          "old_line_content": "",
          "new_line_content": "  int64 size_in_bytes = cost_analysis_.GetShapeSize(shape);",
          "content_same": false
        },
        {
          "line": 326,
          "old_api": null,
          "new_api": "static_cast<float>(size_in_bytes)",
          "old_text": null,
          "new_text": "static_cast<float>(size_in_bytes)",
          "old_line_content": "int64 InstructionCountPrefetchIntervalPicker::PreferredEvictionEndTime(",
          "new_line_content": "  return static_cast<float>(size_in_bytes) /",
          "content_same": false
        },
        {
          "line": 2377,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "defining_position.shape()",
          "old_line_content": "              defining_position, MemorySpace::kAlternate,",
          "new_line_content": "                   defining_position.shape(), request.start_time,",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": null,
          "new_api": "schedule_end_time",
          "old_text": null,
          "new_text": "hlo_live_range_->schedule_end_time()",
          "old_line_content": "int64 InstructionCountPrefetchIntervalPicker::LatestPrefetchStartTime(",
          "new_line_content": "  return hlo_live_range_->schedule_end_time();",
          "content_same": false
        },
        {
          "line": 2379,
          "old_api": null,
          "new_api": "AddToPendingChunks",
          "old_text": null,
          "new_text": "AddToPendingChunks(alternate_mem_interval, *chunk_candidate)",
          "old_line_content": "              /*is_scoped_allocation=*/false));",
          "new_line_content": "    AddToPendingChunks(alternate_mem_interval, *chunk_candidate);",
          "content_same": false
        },
        {
          "line": 2385,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "prev_allocation->defining_position()",
          "old_line_content": "        request.use->hlo_use);",
          "new_line_content": "         prev_allocation->defining_position() == defining_position)) {",
          "content_same": false
        },
        {
          "line": 2386,
          "old_api": null,
          "new_api": "Extend",
          "old_text": null,
          "new_text": "prev_allocation->Extend(request.end_time)",
          "old_line_content": "    return Result::kSuccess;",
          "new_line_content": "      prev_allocation->Extend(request.end_time);",
          "content_same": false
        },
        {
          "line": 2388,
          "old_api": null,
          "new_api": "allocation_sequence",
          "old_text": null,
          "new_text": "request.allocation_value->allocation_sequence()->push_back(\n          absl::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, MemorySpace::kAlternate,\n              chunk_candidate->chunk, request.start_time, request.end_time,\n              /*is_scoped_allocation=*/false))",
          "old_line_content": "  return Result::kFailOutOfMemory;",
          "new_line_content": "      request.allocation_value->allocation_sequence()->push_back(",
          "content_same": false
        },
        {
          "line": 341,
          "old_api": null,
          "new_api": "std::min(start_time + min_overlap_count_, latest_end_time)",
          "old_text": null,
          "new_text": "std::min(start_time + min_overlap_count_, latest_end_time)",
          "old_line_content": "                  prefetch_end_time - max_overlap_count_);",
          "new_line_content": "  return std::min(start_time + min_overlap_count_, latest_end_time);",
          "content_same": false
        },
        {
          "line": 2389,
          "old_api": null,
          "new_api": "absl::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, MemorySpace::kAlternate,\n              chunk_candidate->chunk, request.start_time, request.end_time,\n              /*is_scoped_allocation=*/false)",
          "old_text": null,
          "new_text": "absl::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, MemorySpace::kAlternate,\n              chunk_candidate->chunk, request.start_time, request.end_time,\n              /*is_scoped_allocation=*/false)",
          "old_line_content": "}",
          "new_line_content": "          absl::make_unique<MemorySpaceAssignment::Allocation>(",
          "content_same": false
        },
        {
          "line": 2394,
          "old_api": null,
          "new_api": "allocation_sequence",
          "old_text": null,
          "new_text": "request.allocation_value->allocation_sequence()->back()",
          "old_line_content": "  MemorySpaceAssignment::Allocation* prev_allocation =",
          "new_line_content": "          *request.allocation_value->allocation_sequence()->back(),",
          "content_same": false
        },
        {
          "line": 353,
          "old_api": null,
          "new_api": "std::max(earliest_prefetch_start_time,\n                  prefetch_end_time - max_overlap_count_)",
          "old_text": null,
          "new_text": "std::max(earliest_prefetch_start_time,\n                  prefetch_end_time - max_overlap_count_)",
          "old_line_content": "",
          "new_line_content": "  return std::max(earliest_prefetch_start_time,",
          "content_same": false
        },
        {
          "line": 2406,
          "old_api": null,
          "new_api": "allocation_sequence",
          "old_text": null,
          "new_text": "request.allocation_value->allocation_sequence()->size()",
          "old_line_content": "  preferred_eviction_end_time =",
          "new_line_content": "  CHECK_GT(request.allocation_value->allocation_sequence()->size(), 0);",
          "content_same": false
        },
        {
          "line": 2408,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "request.allocation_value->allocation_sequence()->back().get()",
          "old_line_content": "",
          "new_line_content": "      request.allocation_value->allocation_sequence()->back().get();",
          "content_same": false
        },
        {
          "line": 361,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "ShapeUtil::GetSubshape(\n      use.instruction->operand(use.operand_number)->shape(), use.operand_index)",
          "old_line_content": "  return end_time_ - current_prefetch_time_ <= min_overlap_count_;",
          "new_line_content": "  const Shape& shape = ShapeUtil::GetSubshape(",
          "content_same": false
        },
        {
          "line": 362,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "use.instruction->operand(use.operand_number)->shape()",
          "old_line_content": "}",
          "new_line_content": "      use.instruction->operand(use.operand_number)->shape(), use.operand_index);",
          "content_same": false
        },
        {
          "line": 2409,
          "old_api": null,
          "new_api": "start_time",
          "old_text": null,
          "new_text": "prev_allocation->start_time()",
          "old_line_content": "  BufferInterval eviction_mem_interval;",
          "new_line_content": "  int64 eviction_start_time = prev_allocation->start_time();",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": null,
          "new_api": "PreferredPrefetchStartTime",
          "old_text": null,
          "new_text": "PreferredPrefetchStartTime(shape, start_time, end_time, end_time)",
          "old_line_content": "std::string InstructionCountPrefetchIntervalPicker::ToDebugString() const {",
          "new_line_content": "      PreferredPrefetchStartTime(shape, start_time, end_time, end_time);",
          "content_same": false
        },
        {
          "line": 2411,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(eviction_start_time <= eviction_end_time)",
          "old_line_content": "  eviction_mem_interval.size = request.size;",
          "new_line_content": "  CHECK(eviction_start_time <= eviction_end_time);",
          "content_same": false
        },
        {
          "line": 2414,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->PreferredEvictionEndTime(\n                   request.allocation_value->defining_position().shape(),\n                   eviction_start_time, request.end_time)",
          "old_line_content": "  eviction_mem_interval.start = eviction_end_time + 1;",
          "new_line_content": "      std::max(options_.prefetch_interval_picker->PreferredEvictionEndTime(",
          "content_same": false
        },
        {
          "line": 2415,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "request.allocation_value->defining_position().shape()",
          "old_line_content": "  eviction_mem_interval.end = preferred_eviction_end_time;",
          "new_line_content": "                   request.allocation_value->defining_position().shape(),",
          "content_same": false
        },
        {
          "line": 368,
          "old_api": null,
          "new_api": "Done",
          "old_text": null,
          "new_text": "Done()",
          "old_line_content": "std::string InstructionCountPrefetchIntervalPicker::ToNoCopyDebugString(",
          "new_line_content": "  CHECK(!Done()) << \"Prefetch interval picker's Next() is called even though \"",
          "content_same": false
        },
        {
          "line": 2420,
          "old_api": null,
          "new_api": "std::min(preferred_eviction_end_time, request.latest_prefetch_time)",
          "old_text": null,
          "new_text": "std::min(preferred_eviction_end_time, request.latest_prefetch_time)",
          "old_line_content": "  for (; eviction_mem_interval.end > eviction_end_time;",
          "new_line_content": "      std::min(preferred_eviction_end_time, request.latest_prefetch_time);",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": null,
          "new_api": "absl::StrCat(\"Overlapped HLOs = \", end_time_ - current_prefetch_time_)",
          "old_text": null,
          "new_text": "absl::StrCat(\"Overlapped HLOs = \", end_time_ - current_prefetch_time_)",
          "old_line_content": "    int64_t buffer_size_for_max_async_copy)",
          "new_line_content": "  return absl::StrCat(\"Overlapped HLOs = \", end_time_ - current_prefetch_time_);",
          "content_same": false
        },
        {
          "line": 2429,
          "old_api": null,
          "new_api": "chunk",
          "old_text": null,
          "new_text": "prev_allocation->chunk()",
          "old_line_content": "  eviction_end_time = eviction_mem_interval.end;",
          "new_line_content": "  int64 preferred_offset = prev_allocation->chunk().offset;",
          "content_same": false
        },
        {
          "line": 2430,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "",
          "new_line_content": "  VLOG(3) << \"Eviction (\" << eviction_start_time << \", \" << eviction_end_time",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": null,
          "new_api": "absl::StrCat(\"Overlapped HLOs = \", end_time - start_time)",
          "old_text": null,
          "new_text": "absl::StrCat(\"Overlapped HLOs = \", end_time - start_time)",
          "old_line_content": "      cost_analysis_(cost_analysis),",
          "new_line_content": "  return absl::StrCat(\"Overlapped HLOs = \", end_time - start_time);",
          "content_same": false
        },
        {
          "line": 2438,
          "old_api": null,
          "new_api": "AddToPendingChunks",
          "old_text": null,
          "new_text": "AddToPendingChunks(eviction_mem_interval, chunk_candidate)",
          "old_line_content": "                                            /*is_prefetch=*/false);",
          "new_line_content": "      AddToPendingChunks(eviction_mem_interval, chunk_candidate);",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": null,
          "new_api": "hlo_live_range",
          "old_text": null,
          "new_text": "cost_analysis.hlo_live_range().instruction_schedule().size()",
          "old_line_content": "  // instructions. The elapsed times are multiplied by pow(kWhileExecutionCount,",
          "new_line_content": "          cost_analysis.hlo_live_range().instruction_schedule().size(), 0),",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": null,
          "new_api": "hlo_live_range",
          "old_text": null,
          "new_text": "cost_analysis.hlo_live_range().instruction_schedule().size()",
          "old_line_content": "  // loops.",
          "new_line_content": "          cost_analysis.hlo_live_range().instruction_schedule().size(), 0),",
          "content_same": false
        },
        {
          "line": 2444,
          "old_api": null,
          "new_api": "chunk",
          "old_text": null,
          "new_text": "prev_allocation->chunk()",
          "old_line_content": "                 /*chunk=*/absl::nullopt, eviction_start_time,",
          "new_line_content": "  VLOG(3) << \"Evicting buffer at \" << prev_allocation->chunk().offset << \" (\"",
          "content_same": false
        },
        {
          "line": 2449,
          "old_api": null,
          "new_api": "ViolatesMaximumOutstandingAsyncCopies",
          "old_text": null,
          "new_text": "ViolatesMaximumOutstandingAsyncCopies(eviction_start_time,\n                                            eviction_end_time,\n                                            /*is_prefetch=*/false)",
          "old_line_content": "    if (eviction_violates_outstanding_copies) {",
          "new_line_content": "      ViolatesMaximumOutstandingAsyncCopies(eviction_start_time,",
          "content_same": false
        },
        {
          "line": 2455,
          "old_api": null,
          "new_api": "Extend",
          "old_text": null,
          "new_text": "prev_allocation->Extend(eviction_end_time)",
          "old_line_content": "    // If the original interval violated the limit, try sub-intervals within",
          "new_line_content": "    prev_allocation->Extend(eviction_end_time);",
          "content_same": false
        },
        {
          "line": 2456,
          "old_api": null,
          "new_api": "end_time",
          "old_text": null,
          "new_text": "AddAsyncCopy(*prev_allocation, MemorySpace::kDefault,\n                 /*chunk=*/absl::nullopt, eviction_start_time,\n                 prev_allocation->end_time(), eviction_end_time,\n                 request.allocation_value->allocation_sequence(),\n                 /*aliased_offset=*/nullptr)",
          "old_line_content": "    // this interval.",
          "new_line_content": "    AddAsyncCopy(*prev_allocation, MemorySpace::kDefault,",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "instruction_schedule_->size()",
          "old_line_content": "    while_nest_level_[logical_time] = while_nest_level;",
          "new_line_content": "  std::vector<float> instructions_elapsed_time(instruction_schedule_->size(),",
          "content_same": false
        },
        {
          "line": 2458,
          "old_api": null,
          "new_api": "end_time",
          "old_text": null,
          "new_text": "prev_allocation->end_time()",
          "old_line_content": "    for (int64 time = eviction_start_time; time < eviction_end_time; ++time) {",
          "new_line_content": "                 prev_allocation->end_time(), eviction_end_time,",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "instructions_elapsed_time.size()",
          "old_line_content": "    }",
          "new_line_content": "    if (logical_time >= instructions_elapsed_time.size()) {",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "while_nest_level_.resize(logical_time + 1, 0)",
          "old_line_content": "        *instruction_and_logical_time.first);",
          "new_line_content": "      while_nest_level_.resize(logical_time + 1, 0);",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": null,
          "new_api": "CalculateComputationNestLevel",
          "old_text": null,
          "new_text": "cost_analysis_.CalculateComputationNestLevel(\n        instruction_and_logical_time.first, /*while_only=*/false)",
          "old_line_content": "  // As an optimization, create a cumulative sum vector of elapsed time.",
          "new_line_content": "    int computation_nest_level = cost_analysis_.CalculateComputationNestLevel(",
          "content_same": false
        },
        {
          "line": 2472,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "    if (!eviction_scheduled) {",
          "new_line_content": "      VLOG(4) << \"Try evicting (\" << time << \", \" << time + 1 << \")\";",
          "content_same": false
        },
        {
          "line": 2473,
          "old_api": null,
          "new_api": "ViolatesMaximumOutstandingAsyncCopies",
          "old_text": null,
          "new_text": "ViolatesMaximumOutstandingAsyncCopies(time, time + 1,\n                                                 /*is_prefetch=*/false)",
          "old_line_content": "      // If the eviction couldn't be scheduled, then fail. This buffer will be",
          "new_line_content": "      if (!ViolatesMaximumOutstandingAsyncCopies(time, time + 1,",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "  for (float elapsed_time : instructions_elapsed_time) {",
          "new_line_content": "    if (instruction->opcode() == HloOpcode::kWhile ||",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "    cumsum += elapsed_time;",
          "new_line_content": "        instruction->opcode() == HloOpcode::kConditional) {",
          "content_same": false
        },
        {
          "line": 2476,
          "old_api": null,
          "new_api": "allocation_sequence",
          "old_text": null,
          "new_text": "AddAsyncCopy(*prev_allocation, MemorySpace::kDefault,\n                     /*chunk=*/absl::nullopt, time, time + 1, time + 1,\n                     request.allocation_value->allocation_sequence(),\n                     /*aliased_offset=*/nullptr)",
          "old_line_content": "              << \" because we hit the limit of maximum asynchronous copies \"",
          "new_line_content": "        AddAsyncCopy(*prev_allocation, MemorySpace::kDefault,",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": null,
          "new_api": "GetInstructionElapsed",
          "old_text": null,
          "new_text": "cost_analysis_.GetInstructionElapsed(\n        *instruction_and_logical_time.first)",
          "old_line_content": "  // To be able to accurately determine the minimum nest level between a start",
          "new_line_content": "    float elapsed_time = cost_analysis_.GetInstructionElapsed(",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": null,
          "new_api": "tensorflow::MathUtil::IPow<float>(kWhileExecutionCount,\n                                                         while_nest_level)",
          "old_text": null,
          "new_text": "tensorflow::MathUtil::IPow<float>(kWhileExecutionCount,\n                                                         while_nest_level)",
          "old_line_content": "  int prev_nest_level = 0;",
          "new_line_content": "        elapsed_time * tensorflow::MathUtil::IPow<float>(kWhileExecutionCount,",
          "content_same": false
        },
        {
          "line": 438,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "instructions_elapsed_time.size()",
          "old_line_content": "    if (nest_level != prev_nest_level) {",
          "new_line_content": "  elapsed_time_cumsum_.reserve(instructions_elapsed_time.size());",
          "content_same": false
        },
        {
          "line": 2488,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "request.use->hlo_use.ToString()",
          "old_line_content": "  return Result::kSuccess;",
          "new_line_content": "      VLOG(3) << \"Bailing: Could not evict \" << request.use->hlo_use.ToString()",
          "content_same": false
        },
        {
          "line": 441,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "elapsed_time_cumsum_.push_back(cumsum)",
          "old_line_content": "    }",
          "new_line_content": "    elapsed_time_cumsum_.push_back(cumsum);",
          "content_same": false
        },
        {
          "line": 2491,
          "old_api": null,
          "new_api": "flattened_instruction_sequence",
          "old_text": null,
          "new_text": "hlo_live_range_.flattened_instruction_sequence()\n                     .instructions()",
          "old_line_content": "int64 AlternateMemoryBestFitHeap::FindPrefetchEndTime(",
          "new_line_content": "              << hlo_live_range_.flattened_instruction_sequence()",
          "content_same": false
        },
        {
          "line": 2494,
          "old_api": null,
          "new_api": "flattened_instruction_sequence",
          "old_text": null,
          "new_text": "hlo_live_range_.flattened_instruction_sequence()\n                     .instructions()",
          "old_line_content": "",
          "new_line_content": "              << hlo_live_range_.flattened_instruction_sequence()",
          "content_same": false
        },
        {
          "line": 448,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "instructions_elapsed_time.size()",
          "old_line_content": "  return max_async_copy_to_overlap_ratio_ *",
          "new_line_content": "  while_nest_level_change_.reserve(instructions_elapsed_time.size());",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "while_nest_level_change_.push_back(change_idx)",
          "old_line_content": "    const Shape& shape, int64 start_time, int64 end_time) const {",
          "new_line_content": "    while_nest_level_change_.push_back(change_idx);",
          "content_same": false
        },
        {
          "line": 2509,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "ShapeUtil::GetSubshape(\n      use.instruction->operand(use.operand_number)->shape(), use.operand_index)",
          "old_line_content": "      break;",
          "new_line_content": "  const Shape& shape = ShapeUtil::GetSubshape(",
          "content_same": false
        },
        {
          "line": 2510,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "use.instruction->operand(use.operand_number)->shape()",
          "old_line_content": "    }",
          "new_line_content": "      use.instruction->operand(use.operand_number)->shape(), use.operand_index);",
          "content_same": false
        },
        {
          "line": 463,
          "old_api": null,
          "new_api": "ShapeUtil::MakeShape(\n                      S32, {buffer_size_for_max_async_copy_ / 4})",
          "old_text": null,
          "new_text": "ShapeUtil::MakeShape(\n                      S32, {buffer_size_for_max_async_copy_ / 4})",
          "old_line_content": "         logical_interval_elapsed;",
          "new_line_content": "                  cost_analysis_.GetAsyncCopyElapsed(ShapeUtil::MakeShape(",
          "content_same": false
        },
        {
          "line": 2515,
          "old_api": null,
          "new_api": "LatestPrefetchStartTime",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->LatestPrefetchStartTime(\n            shape, earliest_prefetch_time, prefetch_end_time, &use)",
          "old_line_content": "    auto violating_async_copy =",
          "new_line_content": "        options_.prefetch_interval_picker->LatestPrefetchStartTime(",
          "content_same": false
        },
        {
          "line": 2517,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "    if (!violating_async_copy ||",
          "new_line_content": "    VLOG(4) << \"Latest prefetch start time = \" << latest_prefetch_time",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": null,
          "new_api": "GetLogicalIntervalElapsed",
          "old_text": null,
          "new_text": "GetLogicalIntervalElapsed(start_time, end_time)",
          "old_line_content": "        min_async_copy_to_overlap_ratio_ * async_copy_elapsed) {",
          "new_line_content": "      GetLogicalIntervalElapsed(start_time, end_time);",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": null,
          "new_api": "GetMaxElapsedInAlternateMemory",
          "old_text": null,
          "new_text": "GetMaxElapsedInAlternateMemory(async_copy_elapsed)",
          "old_line_content": "      break;",
          "new_line_content": "  return GetMaxElapsedInAlternateMemory(async_copy_elapsed) >",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": null,
          "new_api": "GetAsyncCopyElapsed",
          "old_text": null,
          "new_text": "cost_analysis_.GetAsyncCopyElapsed(shape)",
          "old_line_content": "int64 CostAnalysisPrefetchIntervalPicker::LatestPrefetchStartTime(",
          "new_line_content": "  float async_copy_elapsed = cost_analysis_.GetAsyncCopyElapsed(shape);",
          "content_same": false
        },
        {
          "line": 2529,
          "old_api": null,
          "new_api": "ViolatesAsyncCopyOrdering",
          "old_text": null,
          "new_text": "ViolatesAsyncCopyOrdering(latest_prefetch_time, prefetch_end_time)",
          "old_line_content": "      prefetch_end_time = new_prefetch_end_time;",
          "new_line_content": "        ViolatesAsyncCopyOrdering(latest_prefetch_time, prefetch_end_time);",
          "content_same": false
        },
        {
          "line": 2534,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "      break;",
          "new_line_content": "    VLOG(4) << \"Violating async copy: (\" << violating_async_copy->start_time",
          "content_same": false
        },
        {
          "line": 2538,
          "old_api": null,
          "new_api": "LatestPrefetchEndTime",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->LatestPrefetchEndTime(\n            prefetch_end_time, violating_async_copy->end_time)",
          "old_line_content": "  return prefetch_end_time;",
          "new_line_content": "        options_.prefetch_interval_picker->LatestPrefetchEndTime(",
          "content_same": false
        },
        {
          "line": 2541,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "AlternateMemoryBestFitHeap::Result AlternateMemoryBestFitHeap::Prefetch(",
          "new_line_content": "      VLOG(3) << \"Update prefetch end time = \" << new_prefetch_end_time;",
          "content_same": false
        },
        {
          "line": 2544,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "  // Try partially placing the buffer in the alternate space. The time that is",
          "new_line_content": "      VLOG(3) << \"Can't update prefetch end time = \" << new_prefetch_end_time",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": null,
          "new_api": "GetAsyncCopyElapsed",
          "old_text": null,
          "new_text": "cost_analysis_.GetAsyncCopyElapsed(shape)",
          "old_line_content": "  int end_nest_level = computation_nest_level_[end_time];",
          "new_line_content": "  float async_copy_elapsed = cost_analysis_.GetAsyncCopyElapsed(shape);",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": null,
          "new_api": "GetInstructionElapsed",
          "old_text": null,
          "new_text": "cost_analysis_.GetInstructionElapsed(*use->instruction)",
          "old_line_content": "       latest_prefetch_time >= start_time &&",
          "new_line_content": "        cost_analysis_.GetInstructionElapsed(*use->instruction);",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": null,
          "new_api": "GetInstructionElapsedInAlternateMemory",
          "old_text": null,
          "new_text": "cost_analysis_.GetInstructionElapsedInAlternateMemory(\n            *use->instruction, use->operand_number,\n            /*output_in_alternate_mem=*/false)",
          "old_line_content": "        min_interval >",
          "new_line_content": "        cost_analysis_.GetInstructionElapsedInAlternateMemory(",
          "content_same": false
        },
        {
          "line": 2570,
          "old_api": null,
          "new_api": "earliest_available_time",
          "old_text": null,
          "new_text": "prev_allocation_in_default_mem.earliest_available_time()",
          "old_line_content": "  // Create an alternate memory interval that starts at the earliest",
          "new_line_content": "      prev_allocation_in_default_mem.earliest_available_time();",
          "content_same": false
        },
        {
          "line": 2576,
          "old_api": null,
          "new_api": "FindPrefetchEndTime",
          "old_text": null,
          "new_text": "FindPrefetchEndTime(request, earliest_prefetch_time)",
          "old_line_content": "  int64 extra_async_copy_limit =",
          "new_line_content": "      FindPrefetchEndTime(request, earliest_prefetch_time);",
          "content_same": false
        },
        {
          "line": 2578,
          "old_api": null,
          "new_api": "Begin",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->Begin(\n      request.use->hlo_use, earliest_prefetch_time, prefetch_end_time)",
          "old_line_content": "          ? options_.while_use_extra_outstanding_prefetch_limit",
          "new_line_content": "  options_.prefetch_interval_picker->Begin(",
          "content_same": false
        },
        {
          "line": 2580,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "  Result result = Result::kSuccess;",
          "new_line_content": "  VLOG(3) << \"Trying prefetch picker = \"",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": null,
          "new_api": "GetLogicalIntervalElapsed",
          "old_text": null,
          "new_text": "GetLogicalIntervalElapsed(earliest_prefetch_start_time,\n                                                  prefetch_end_time)",
          "old_line_content": "    }",
          "new_line_content": "  float best_interval = GetLogicalIntervalElapsed(earliest_prefetch_start_time,",
          "content_same": false
        },
        {
          "line": 2586,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "request.allocation_value->value()",
          "old_line_content": "    // If this additional asynchronous copy would violate the limit, try a",
          "new_line_content": "  alternate_mem_interval.buffer = request.allocation_value->value();",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": null,
          "new_api": "GetLogicalIntervalElapsed",
          "old_text": null,
          "new_text": "GetLogicalIntervalElapsed(prefetch_start_time, prefetch_end_time)",
          "old_line_content": "  // Iterate towards the beginning until we find a suitable end time that is the",
          "new_line_content": "        GetLogicalIntervalElapsed(prefetch_start_time, prefetch_end_time);",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": null,
          "new_api": "std::abs(preferred_interval - interval)",
          "old_text": null,
          "new_text": "std::abs(preferred_interval - interval)",
          "old_line_content": "  int64 original_nest_level =",
          "new_line_content": "        std::abs(preferred_interval - interval) <",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": null,
          "new_api": "std::abs(preferred_interval - best_interval)",
          "old_text": null,
          "new_text": "std::abs(preferred_interval - best_interval)",
          "old_line_content": "      computation_nest_level_[original_prefetch_end_time];",
          "new_line_content": "            std::abs(preferred_interval - best_interval)) {",
          "content_same": false
        },
        {
          "line": 2595,
          "old_api": null,
          "new_api": "Next",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->Next()",
          "old_line_content": "            alternate_mem_interval.start, prefetch_end_time,",
          "new_line_content": "    alternate_mem_interval.start = options_.prefetch_interval_picker->Next();",
          "content_same": false
        },
        {
          "line": 2596,
          "old_api": null,
          "new_api": "CHECK_LT",
          "old_text": null,
          "new_text": "CHECK_LT(alternate_mem_interval.start, prefetch_end_time)",
          "old_line_content": "            /*is_prefetch=*/true, extra_async_copy_limit)) {",
          "new_line_content": "    CHECK_LT(alternate_mem_interval.start, prefetch_end_time);",
          "content_same": false
        },
        {
          "line": 2601,
          "old_api": null,
          "new_api": "ViolatesAsyncCopyOrdering",
          "old_text": null,
          "new_text": "ViolatesAsyncCopyOrdering(alternate_mem_interval.start,\n                                  prefetch_end_time)",
          "old_line_content": "",
          "new_line_content": "    if (ViolatesAsyncCopyOrdering(alternate_mem_interval.start,",
          "content_same": false
        },
        {
          "line": 2603,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "        request, request.preferred_offset, &alternate_mem_interval);",
          "new_line_content": "      VLOG(4) << \"This would violate asynchronous copy ordering.\";",
          "content_same": false
        },
        {
          "line": 2604,
          "old_api": null,
          "new_api": "result_mark",
          "old_text": null,
          "new_text": "result_mark(Result::kFailViolatesAsyncCopyOrdering, result)",
          "old_line_content": "    // Check if we could find a suitable chunk.",
          "new_line_content": "      result_mark(Result::kFailViolatesAsyncCopyOrdering, result);",
          "content_same": false
        },
        {
          "line": 2607,
          "old_api": null,
          "new_api": "ViolatesMaximumOutstandingAsyncCopies",
          "old_text": null,
          "new_text": "ViolatesMaximumOutstandingAsyncCopies(\n            alternate_mem_interval.start, prefetch_end_time,\n            /*is_prefetch=*/true, extra_async_copy_limit)",
          "old_line_content": "              << alternate_mem_interval.start",
          "new_line_content": "    if (ViolatesMaximumOutstandingAsyncCopies(",
          "content_same": false
        },
        {
          "line": 2610,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "              << \", heap_size = \" << chunk_candidate->heap_size",
          "new_line_content": "      VLOG(4) << \"This would violate the outstanding async copy limit.\";",
          "content_same": false
        },
        {
          "line": 2611,
          "old_api": null,
          "new_api": "result_mark",
          "old_text": null,
          "new_text": "result_mark(Result::kFailOutOfAsyncCopies, result)",
          "old_line_content": "              << \", prefetch picker = \"",
          "new_line_content": "      result_mark(Result::kFailOutOfAsyncCopies, result);",
          "content_same": false
        },
        {
          "line": 2619,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "                   request.preferred_offset);",
          "new_line_content": "      VLOG(3) << \"Move the buffer to alternate memory at \"",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "ShapeUtil::GetSubshape(\n      use.instruction->operand(use.operand_number)->shape(), use.operand_index)",
          "old_line_content": "",
          "new_line_content": "  const Shape& shape = ShapeUtil::GetSubshape(",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "use.instruction->operand(use.operand_number)->shape()",
          "old_line_content": "  // Find the latest time we're allowed to start prefetching.",
          "new_line_content": "      use.instruction->operand(use.operand_number)->shape(), use.operand_index);",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": null,
          "new_api": "GetAsyncCopyElapsed",
          "old_text": null,
          "new_text": "cost_analysis_.GetAsyncCopyElapsed(shape)",
          "old_line_content": "  latest_prefetch_time_ =",
          "new_line_content": "  async_copy_elapsed_ = cost_analysis_.GetAsyncCopyElapsed(shape);",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": null,
          "new_api": "GetInstructionElapsed",
          "old_text": null,
          "new_text": "cost_analysis_.GetInstructionElapsed(*use.instruction)",
          "old_line_content": "",
          "new_line_content": "  float elapsed_time = cost_analysis_.GetInstructionElapsed(*use.instruction);",
          "content_same": false
        },
        {
          "line": 2626,
          "old_api": null,
          "new_api": "AddToPendingChunks",
          "old_text": null,
          "new_text": "AddToPendingChunks(alternate_mem_interval, *chunk_candidate)",
          "old_line_content": "  }",
          "new_line_content": "      AddToPendingChunks(alternate_mem_interval, *chunk_candidate);",
          "content_same": false
        },
        {
          "line": 2628,
          "old_api": null,
          "new_api": "allocation_sequence",
          "old_text": null,
          "new_text": "AddAsyncCopy(prev_allocation_in_default_mem, MemorySpace::kAlternate,\n                   chunk_candidate->chunk, alternate_mem_interval.start,\n                   request.end_time, prefetch_end_time,\n                   request.allocation_value->allocation_sequence(),\n                   request.preferred_offset)",
          "old_line_content": "  // short.",
          "new_line_content": "      AddAsyncCopy(prev_allocation_in_default_mem, MemorySpace::kAlternate,",
          "content_same": false
        },
        {
          "line": 2631,
          "old_api": null,
          "new_api": "allocation_sequence",
          "old_text": null,
          "new_text": "request.allocation_value->allocation_sequence()",
          "old_line_content": "  } else {",
          "new_line_content": "                   request.allocation_value->allocation_sequence(),",
          "content_same": false
        },
        {
          "line": 2634,
          "old_api": null,
          "new_api": "allocation_sequence",
          "old_text": null,
          "new_text": "request.allocation_value->allocation_sequence()->back()->AddUse(\n          request.use->hlo_use)",
          "old_line_content": "}",
          "new_line_content": "      request.allocation_value->allocation_sequence()->back()->AddUse(",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": null,
          "new_api": "LatestPrefetchStartTime",
          "old_text": null,
          "new_text": "LatestPrefetchStartTime(shape, start_time, end_time, &use)",
          "old_line_content": "    // times. Set the iterators accordingly to ensure Done() returns true.",
          "new_line_content": "      LatestPrefetchStartTime(shape, start_time, end_time, &use);",
          "content_same": false
        },
        {
          "line": 2638,
          "old_api": null,
          "new_api": "result_mark",
          "old_text": null,
          "new_text": "result_mark(Result::kFailOutOfMemory, result)",
          "old_line_content": "    const AllocationRequest& request, const AliasedOffset* preferred_offset,",
          "new_line_content": "    result_mark(Result::kFailOutOfMemory, result);",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": null,
          "new_api": "Done",
          "old_text": null,
          "new_text": "Done()",
          "old_line_content": "",
          "new_line_content": "    CHECK(Done());",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": null,
          "new_api": "PreferredPrefetchStartTime",
          "old_text": null,
          "new_text": "PreferredPrefetchStartTime(\n      shape, earliest_prefetch_time_, latest_prefetch_time_, end_logical_time_)",
          "old_line_content": "  // Since both iterators start at the same position, call Next() once to",
          "new_line_content": "  int64 starting_prefetch_time = PreferredPrefetchStartTime(",
          "content_same": false
        },
        {
          "line": 2657,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "use_times.begin()",
          "old_line_content": "         ++use_time_it) {",
          "new_line_content": "    auto use_time_it = use_times.begin();",
          "content_same": false
        },
        {
          "line": 2660,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "use_times.end()",
          "old_line_content": "    int64 latest_contiguous_use_time = *use_time_it;",
          "new_line_content": "    CHECK(use_time_it != use_times.end());",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "",
          "new_line_content": "  VLOG(4) << \"Interval min/max/preferred = \" << min_interval << \" \"",
          "content_same": false
        },
        {
          "line": 2665,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "request.allocation_value->defining_position().shape()",
          "old_line_content": "         --use_time_it) {",
          "new_line_content": "    const Shape& shape = request.allocation_value->defining_position().shape();",
          "content_same": false
        },
        {
          "line": 2667,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "use_times.end()",
          "old_line_content": "      ChunkCandidate chunk_candidate =",
          "new_line_content": "         (use_time_it + 1) != use_times.end() &&",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": null,
          "new_api": "Next",
          "old_text": null,
          "new_text": "Next()",
          "old_line_content": "    if (decreasing_prefetch_time_iterator_ >= earliest_prefetch_time_) {",
          "new_line_content": "  Next();",
          "content_same": false
        },
        {
          "line": 2672,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "use_times.end()",
          "old_line_content": "                << \", latest contiguous use = \" << latest_contiguous_use_time",
          "new_line_content": "    CHECK(use_time_it != use_times.end());",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": null,
          "new_api": "Done",
          "old_text": null,
          "new_text": "Done()",
          "old_line_content": "  } else {",
          "new_line_content": "  CHECK(!Done()) << \"Prefetch interval picker's Next() is called even though \"",
          "content_same": false
        },
        {
          "line": 2677,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "use_times.begin()",
          "old_line_content": "    }",
          "new_line_content": "    for (; use_time_it >= use_times.begin() && *use_time_it >= end_time;",
          "content_same": false
        },
        {
          "line": 2681,
          "old_api": null,
          "new_api": "FindChunkCandidate",
          "old_text": null,
          "new_text": "FindChunkCandidate(*alternate_mem_interval)",
          "old_line_content": "  // If a preferred offset is given, try to find an allocation at that offset",
          "new_line_content": "          FindChunkCandidate(*alternate_mem_interval);",
          "content_same": false
        },
        {
          "line": 2682,
          "old_api": null,
          "new_api": "available_heap_size",
          "old_text": null,
          "new_text": "available_heap_size()",
          "old_line_content": "  // only.",
          "new_line_content": "      if (chunk_candidate.heap_size <= available_heap_size()) {",
          "content_same": false
        },
        {
          "line": 2684,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "  ChunkCandidate chunk_candidate =",
          "new_line_content": "        VLOG(3) << \"FindBestChunkCandidate earliest use = \" << earliest_use",
          "content_same": false
        },
        {
          "line": 2698,
          "old_api": null,
          "new_api": "FindChunkCandidate",
          "old_text": null,
          "new_text": "FindChunkCandidate(*alternate_mem_interval, preferred_offset->offset)",
          "old_line_content": "  stats.num_evictions = 0;",
          "new_line_content": "      FindChunkCandidate(*alternate_mem_interval, preferred_offset->offset);",
          "content_same": false
        },
        {
          "line": 2714,
          "old_api": null,
          "new_api": "TF_ASSIGN_OR_RETURN",
          "old_text": null,
          "new_text": "TF_ASSIGN_OR_RETURN(std::unique_ptr<HloDataflowAnalysis> dataflow_analysis,\n                      HloDataflowAnalysis::Run(*module_))",
          "old_line_content": "          ++stats.num_prefetches;",
          "new_line_content": "  TF_ASSIGN_OR_RETURN(std::unique_ptr<HloDataflowAnalysis> dataflow_analysis,",
          "content_same": false
        },
        {
          "line": 2715,
          "old_api": null,
          "new_api": "HloDataflowAnalysis::Run(*module_)",
          "old_text": null,
          "new_text": "HloDataflowAnalysis::Run(*module_)",
          "old_line_content": "          stats.prefetch_bytes += size;",
          "new_line_content": "                      HloDataflowAnalysis::Run(*module_));",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": null,
          "new_api": "std::min(while_nest_level_[start_time], while_nest_level_[end_time])",
          "old_text": null,
          "new_text": "std::min(while_nest_level_[start_time], while_nest_level_[end_time])",
          "old_line_content": "    return 0.0;",
          "new_line_content": "      std::min(while_nest_level_[start_time], while_nest_level_[end_time]);",
          "content_same": false
        },
        {
          "line": 2717,
          "old_api": null,
          "new_api": "MakeNonfusionComputations",
          "old_text": null,
          "new_text": "module_->MakeNonfusionComputations()",
          "old_line_content": "          ++stats.num_evictions;",
          "new_line_content": "       module_->MakeNonfusionComputations()) {",
          "content_same": false
        },
        {
          "line": 2718,
          "old_api": null,
          "new_api": "instructions",
          "old_text": null,
          "new_text": "computation->instructions()",
          "old_line_content": "          stats.eviction_bytes += size;",
          "new_line_content": "    for (HloInstruction* instruction : computation->instructions()) {",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": null,
          "new_api": "std::min(min_nest_level, while_nest_level_[change_idx])",
          "old_text": null,
          "new_text": "std::min(min_nest_level, while_nest_level_[change_idx])",
          "old_line_content": "    start_time = 0;",
          "new_line_content": "    min_nest_level = std::min(min_nest_level, while_nest_level_[change_idx]);",
          "content_same": false
        },
        {
          "line": 2719,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "        }",
          "new_line_content": "      if (instruction->opcode() == HloOpcode::kCopyStart) {",
          "content_same": false
        },
        {
          "line": 2721,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "      stats.max_outstanding_async_copies =",
          "new_line_content": "      } else if (instruction->opcode() == HloOpcode::kCopyDone) {",
          "content_same": false
        },
        {
          "line": 2724,
          "old_api": null,
          "new_api": "GetUniqueValueAt",
          "old_text": null,
          "new_text": "dataflow_analysis->GetUniqueValueAt(instruction)",
          "old_line_content": "  }",
          "new_line_content": "            options_.size_fn(dataflow_analysis->GetUniqueValueAt(instruction));",
          "content_same": false
        },
        {
          "line": 2725,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "instruction->shape().layout().memory_space()",
          "old_line_content": "  return stats;",
          "new_line_content": "        if (instruction->shape().layout().memory_space() ==",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": null,
          "new_api": "tensorflow::MathUtil::IPow<float>(kWhileExecutionCount,\n                                           interval_while_nest_level)",
          "old_text": null,
          "new_text": "tensorflow::MathUtil::IPow<float>(kWhileExecutionCount,\n                                           interval_while_nest_level)",
          "old_line_content": "      \", logical interval elapsed (s) = \", logical_interval_elapsed,",
          "new_line_content": "         tensorflow::MathUtil::IPow<float>(kWhileExecutionCount,",
          "content_same": false
        },
        {
          "line": 2747,
          "old_api": null,
          "new_api": "GetMemoryBoundedness",
          "old_text": null,
          "new_text": "cost_analysis.GetMemoryBoundedness(x, cache)",
          "old_line_content": "MemorySpaceAssignment::Run(HloModule* module,",
          "new_line_content": "    float x_memory_boundedness = cost_analysis.GetMemoryBoundedness(x, cache);",
          "content_same": false
        },
        {
          "line": 700,
          "old_api": null,
          "new_api": "GetLogicalIntervalElapsed",
          "old_text": null,
          "new_text": "GetLogicalIntervalElapsed(\n      current_logical_prefetch_time, end_logical_time_)",
          "old_line_content": "  float logical_interval_elapsed =",
          "new_line_content": "  float logical_interval_elapsed = GetLogicalIntervalElapsed(",
          "content_same": false
        },
        {
          "line": 2748,
          "old_api": null,
          "new_api": "GetMemoryBoundedness",
          "old_text": null,
          "new_text": "cost_analysis.GetMemoryBoundedness(y, cache)",
          "old_line_content": "                           const HloLiveRange& hlo_live_range,",
          "new_line_content": "    float y_memory_boundedness = cost_analysis.GetMemoryBoundedness(y, cache);",
          "content_same": false
        },
        {
          "line": 712,
          "old_api": null,
          "new_api": "GetAsyncCopyElapsed",
          "old_text": null,
          "new_text": "cost_analysis_.GetAsyncCopyElapsed(shape)",
          "old_line_content": "}",
          "new_line_content": "  float async_copy_elapsed = cost_analysis_.GetAsyncCopyElapsed(shape);",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": null,
          "new_api": "GetLogicalIntervalElapsed",
          "old_text": null,
          "new_text": "GetLogicalIntervalElapsed(start_time, end_time)",
          "old_line_content": "bool MemorySpaceAssignment::Allocation::operator==(",
          "new_line_content": "      GetLogicalIntervalElapsed(start_time, end_time);",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": null,
          "new_api": "absl::StrCat(\n      \"Async copy elapsed (s) = \", async_copy_elapsed,\n      \", logical interval elapsed (s) = \", logical_interval_elapsed)",
          "old_text": null,
          "new_text": "absl::StrCat(\n      \"Async copy elapsed (s) = \", async_copy_elapsed,\n      \", logical interval elapsed (s) = \", logical_interval_elapsed)",
          "old_line_content": "    const MemorySpaceAssignment::Allocation& other) const {",
          "new_line_content": "  return absl::StrCat(",
          "content_same": false
        },
        {
          "line": 2764,
          "old_api": null,
          "new_api": "has_schedule",
          "old_text": null,
          "new_text": "module->has_schedule()",
          "old_line_content": "    const HloLiveRange& hlo_live_range,",
          "new_line_content": "  CHECK(module->has_schedule());",
          "content_same": false
        },
        {
          "line": 2765,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "    const HloAliasAnalysis& alias_analysis) {",
          "new_line_content": "  VLOG(3) << \"Module before memory space assignment: \";",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": null,
          "new_api": "GetMemoryBoundedness",
          "old_text": null,
          "new_text": "cost_analysis_.GetMemoryBoundedness(interval)",
          "old_line_content": "bool MemorySpaceAssignment::CopyAllocation::operator==(",
          "new_line_content": "  return cost_analysis_.GetMemoryBoundedness(interval);",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": null,
          "new_api": "start_time",
          "old_text": null,
          "new_text": "other.start_time()",
          "old_line_content": "}",
          "new_line_content": "         chunk() == other.chunk() && start_time() == other.start_time() &&",
          "content_same": false
        },
        {
          "line": 732,
          "old_api": null,
          "new_api": "end_time",
          "old_text": null,
          "new_text": "other.end_time()",
          "old_line_content": "",
          "new_line_content": "         end_time() == other.end_time() &&",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": null,
          "new_api": "is_copy_allocation",
          "old_text": null,
          "new_text": "other.is_copy_allocation()",
          "old_line_content": "std::string MemorySpaceAssignment::AllocationValue::ToString() const {",
          "new_line_content": "         is_copy_allocation() == other.is_copy_allocation() &&",
          "content_same": false
        },
        {
          "line": 2780,
          "old_api": null,
          "new_api": "Process",
          "old_text": null,
          "new_text": "Process()",
          "old_line_content": "          << \", in bytes: \" << stats.prefetch_bytes;",
          "new_line_content": "  TF_RETURN_IF_ERROR(Process());",
          "content_same": false
        },
        {
          "line": 2782,
          "old_api": null,
          "new_api": "SimplifyGraph",
          "old_text": null,
          "new_text": "SimplifyGraph()",
          "old_line_content": "          << \", in bytes: \" << stats.eviction_bytes;",
          "new_line_content": "  TF_RETURN_IF_ERROR(SimplifyGraph());",
          "content_same": false
        },
        {
          "line": 2783,
          "old_api": null,
          "new_api": "FixSchedule",
          "old_text": null,
          "new_text": "FixSchedule()",
          "old_line_content": "",
          "new_line_content": "  TF_RETURN_IF_ERROR(FixSchedule());",
          "content_same": false
        },
        {
          "line": 2787,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "module_->ToString()",
          "old_line_content": "}",
          "new_line_content": "  XLA_VLOG_LINES(3, module_->ToString());",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": null,
          "new_api": "static_cast<const Allocation&>(other)",
          "old_text": null,
          "new_text": "static_cast<const Allocation&>(other)",
          "old_line_content": "  for (const Use& use : uses_) {",
          "new_line_content": "             static_cast<const Allocation&>(other) &&",
          "content_same": false
        },
        {
          "line": 2788,
          "old_api": null,
          "new_api": "Verify",
          "old_text": null,
          "new_text": "module_->schedule().Verify()",
          "old_line_content": "",
          "new_line_content": "  TF_CHECK_OK(module_->schedule().Verify());",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": null,
          "new_api": "copy_start_schedule_after",
          "old_text": null,
          "new_text": "other.copy_start_schedule_after()",
          "old_line_content": "  }",
          "new_line_content": "         copy_start_schedule_after() == other.copy_start_schedule_after() &&",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": null,
          "new_api": "copy_done",
          "old_text": null,
          "new_text": "other.copy_done()",
          "old_line_content": "  return out;",
          "new_line_content": "         copy_start() == other.copy_start() && copy_done() == other.copy_done();",
          "content_same": false
        },
        {
          "line": 2790,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "    const HloLiveRange& hlo_live_range,",
          "new_line_content": "  VLOG(1) << \"Maximum number of outstanding async copies: \"",
          "content_same": false
        },
        {
          "line": 2794,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "",
          "new_line_content": "  VLOG(1) << \"Number of evictions: \" << stats.num_evictions",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": null,
          "new_api": "absl::StrAppend(&out, \"\\n position:\\n\")",
          "old_text": null,
          "new_text": "absl::StrAppend(&out, \"\\n position:\\n\")",
          "old_line_content": "                      (requires_contiguous_allocation_ ? \" (cont alloc)\" : \"\"));",
          "new_line_content": "  absl::StrAppend(&out, \"\\n position:\\n\");",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "defining_position_.ToString()",
          "old_line_content": "}",
          "new_line_content": "  absl::StrAppend(&out, \"  \", defining_position_.ToString(), \"\\n\");",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": null,
          "new_api": "absl::StrAppend(&out, \" uses:\\n\")",
          "old_text": null,
          "new_text": "absl::StrAppend(&out, \" uses:\\n\")",
          "old_line_content": "",
          "new_line_content": "  absl::StrAppend(&out, \" uses:\\n\");",
          "content_same": false
        },
        {
          "line": 2799,
          "old_api": null,
          "new_api": "std::move(preset_assignments_)",
          "old_text": null,
          "new_text": "std::move(preset_assignments_)",
          "old_line_content": "                                        options_.size_fn,",
          "new_line_content": "  return std::move(preset_assignments_);",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "use.hlo_use.ToString()",
          "old_line_content": "    const AlternateMemoryBestFitHeap::BufferInterval& buffer_interval,",
          "new_line_content": "    absl::StrAppend(&out, \"  \", use.hlo_use.ToString(), \"\\n\");",
          "content_same": false
        },
        {
          "line": 2805,
          "old_api": null,
          "new_api": "absl::make_unique<AlternateMemoryBestFitHeap>(\n      &allocations_, options_, alias_analysis, hlo_live_range)",
          "old_text": null,
          "new_text": "absl::make_unique<AlternateMemoryBestFitHeap>(\n      &allocations_, options_, alias_analysis, hlo_live_range)",
          "old_line_content": "void MemorySpaceAssignment::Allocation::AddUse(HloUse use) {",
          "new_line_content": "  auto algorithm = absl::make_unique<AlternateMemoryBestFitHeap>(",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "computation()->name()",
          "old_line_content": "  // positions. We create an AllocationValue object for each non-trivial",
          "new_line_content": "  return absl::StrCat(\"computation = \", computation()->name(),",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "defining_position_.ToString()",
          "old_line_content": "  // position. And for each AllocationValue object, we create an",
          "new_line_content": "                      \", position = \", defining_position_.ToString(),",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "value_->ToShortString()",
          "old_line_content": "  // AllocationSequence consisting of one or more Allocation objects.The reason",
          "new_line_content": "                      \", value = \", value_->ToShortString(),",
          "content_same": false
        },
        {
          "line": 2811,
          "old_api": null,
          "new_api": "schedule",
          "old_text": null,
          "new_text": "module_->schedule()",
          "old_line_content": "      break;",
          "new_line_content": "                                        module_->schedule(), alias_analysis,",
          "content_same": false
        },
        {
          "line": 2815,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2820,
          "old_api": null,
          "new_api": "mutable_operand",
          "old_text": null,
          "new_text": "use.instruction->mutable_operand(use.operand_number)",
          "old_line_content": "      HloInstruction* operand =",
          "new_line_content": "      use.instruction->mutable_operand(use.operand_number);",
          "content_same": false
        },
        {
          "line": 2826,
          "old_api": null,
          "new_api": "mutable_operand",
          "old_text": null,
          "new_text": "operand->mutable_operand(index)",
          "old_line_content": "      }",
          "new_line_content": "    operand = operand->mutable_operand(index);",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": null,
          "new_api": "positions",
          "old_text": null,
          "new_text": "value->positions()",
          "old_line_content": "",
          "new_line_content": "  for (const HloPosition& position : value->positions()) {",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "  absl::flat_hash_set<const HloComputation*> computations;",
          "new_line_content": "    if (instruction->opcode() != HloOpcode::kGetTupleElement &&",
          "content_same": false
        },
        {
          "line": 2834,
          "old_api": null,
          "new_api": "mutable_operand",
          "old_text": null,
          "new_text": "instruction->mutable_operand(0)",
          "old_line_content": "",
          "new_line_content": "          get_simplified_operand(instruction->mutable_operand(0));",
          "content_same": false
        },
        {
          "line": 2835,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "operand->opcode()",
          "old_line_content": "Status MemorySpaceAssignment::Allocation::Process(",
          "new_line_content": "      if (operand->opcode() == HloOpcode::kTuple) {",
          "content_same": false
        },
        {
          "line": 2836,
          "old_api": null,
          "new_api": "tuple_index",
          "old_text": null,
          "new_text": "instruction->tuple_index()",
          "old_line_content": "    MemorySpaceAssignment* memory_space_assignment) {",
          "new_line_content": "        instruction = operand->mutable_operand(instruction->tuple_index());",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "absl::c_stable_sort(positions,\n                      [&](const HloPosition& pos1, const HloPosition& pos2) {\n                        return instruction_schedule.at(pos1.instruction) <\n                               instruction_schedule.at(pos2.instruction);\n                      })",
          "old_line_content": "",
          "new_line_content": "  absl::c_stable_sort(positions,",
          "content_same": false
        },
        {
          "line": 2843,
          "old_api": null,
          "new_api": "get_simplified_operand",
          "old_text": null,
          "new_text": "get_simplified_operand(operand)",
          "old_line_content": "  for (const HloUse& use : uses_) {",
          "new_line_content": "  operand = get_simplified_operand(operand);",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "allocation_values.size()",
          "old_line_content": "  // position and uses in the same computation. Furthermore, if the original",
          "new_line_content": "  int beginning_idx = allocation_values.size();",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "positions.size()",
          "old_line_content": "  // HloValue had multiple non-trivial positions in the same computation, those",
          "new_line_content": "  for (int i = 0; i < positions.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 799,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "positions.at(i)",
          "old_line_content": "  // will get their own AllocationValue as well. We split these HloValues so",
          "new_line_content": "    const HloPosition& position = positions.at(i);",
          "content_same": false
        },
        {
          "line": 800,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "allocation_values.emplace_back(value, position, buffer_interval.size)",
          "old_line_content": "  // that when we insert CopyStart/CopyDone in CopyAllocation::Process, they",
          "new_line_content": "    allocation_values.emplace_back(value, position, buffer_interval.size);",
          "content_same": false
        },
        {
          "line": 2845,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "uses_.push_back(use)",
          "old_line_content": "    HloInstruction* replacement_instruction = producing_instruction;",
          "new_line_content": "  uses_.push_back(use);",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "value->uses()",
          "old_line_content": "  for (const HloUse& use : uses) {",
          "new_line_content": "  std::vector<HloUse> uses(value->uses());",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "instruction_schedule.at(use2.instruction)",
          "old_line_content": "",
          "new_line_content": "           instruction_schedule.at(use2.instruction);",
          "content_same": false
        },
        {
          "line": 2855,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "producing_instruction->parent()",
          "old_line_content": "              << \"; inserting a bitcast.\";",
          "new_line_content": "  HloComputation* computation = producing_instruction->parent();",
          "content_same": false
        },
        {
          "line": 2860,
          "old_api": null,
          "new_api": "mutable_operand",
          "old_text": null,
          "new_text": "TF_ASSIGN_OR_RETURN(\n          replacement_instruction,\n          ReplaceTupleWith(producing_instruction,\n                           use.instruction->mutable_operand(use.operand_number),\n                           use.operand_index))",
          "old_line_content": "        use.operand_number, replacement_instruction));",
          "new_line_content": "      TF_ASSIGN_OR_RETURN(",
          "content_same": false
        },
        {
          "line": 2863,
          "old_api": null,
          "new_api": "mutable_operand",
          "old_text": null,
          "new_text": "use.instruction->mutable_operand(use.operand_number)",
          "old_line_content": "}",
          "new_line_content": "                           use.instruction->mutable_operand(use.operand_number),",
          "content_same": false
        },
        {
          "line": 2865,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "producing_instruction->shape()",
          "old_line_content": "StatusOr<HloInstruction*> MemorySpaceAssignment::Allocation::ReplaceTupleWith(",
          "new_line_content": "    } else if (operand_shape != producing_instruction->shape()) {",
          "content_same": false
        },
        {
          "line": 2866,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "operand_shape.ToString()",
          "old_line_content": "    HloInstruction* new_instruction, HloInstruction* tuple,",
          "new_line_content": "      VLOG(4) << \"Old shape = \" << operand_shape.ToString()",
          "content_same": false
        },
        {
          "line": 2867,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "producing_instruction->shape().ToString()",
          "old_line_content": "    ShapeIndex shape_index) {",
          "new_line_content": "              << \", new shape = \" << producing_instruction->shape().ToString()",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "allocation_values.size()",
          "old_line_content": "                     use_time) {",
          "new_line_content": "    for (int i = beginning_idx; i < allocation_values.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2870,
          "old_api": null,
          "new_api": "HloInstruction::CreateBitcast(operand_shape, producing_instruction)",
          "old_text": null,
          "new_text": "HloInstruction::CreateBitcast(operand_shape, producing_instruction)",
          "old_line_content": "      << \"ReplaceTupleWith was called for a non-tuple. Tuple = \"",
          "new_line_content": "          HloInstruction::CreateBitcast(operand_shape, producing_instruction));",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "allocation_values.at(i)",
          "old_line_content": "        last_allocation_value = allocation_value;",
          "new_line_content": "      AllocationValue* allocation_value = &allocation_values.at(i);",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "HloDataflowAnalysis::IsAsynchronousOperationDone(\n              use.instruction->opcode())",
          "old_line_content": "      }",
          "new_line_content": "      if (HloDataflowAnalysis::IsAsynchronousOperationDone(",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "use.instruction->opcode()",
          "old_line_content": "    }",
          "new_line_content": "              use.instruction->opcode())) {",
          "content_same": false
        },
        {
          "line": 2881,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "tuple->shape()",
          "old_line_content": "    // performance.",
          "new_line_content": "  const Shape& tuple_shape = tuple->shape();",
          "content_same": false
        },
        {
          "line": 2882,
          "old_api": null,
          "new_api": "IsTuple",
          "old_text": null,
          "new_text": "tuple->shape().IsTuple()",
          "old_line_content": "    auto get_operand = [&]() {",
          "new_line_content": "  CHECK(tuple->shape().IsTuple())",
          "content_same": false
        },
        {
          "line": 2885,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "new_instruction->ToString()",
          "old_line_content": "      } else {",
          "new_line_content": "      << \", new_instruction = \" << new_instruction->ToString()",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": null,
          "new_api": "AddUse",
          "old_text": null,
          "new_text": "last_allocation_value->AddUse(use, use_time)",
          "old_line_content": "    }",
          "new_line_content": "    last_allocation_value->AddUse(use, use_time);",
          "content_same": false
        },
        {
          "line": 2888,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "new_instruction->parent()",
          "old_line_content": "      }",
          "new_line_content": "  HloComputation* computation = new_instruction->parent();",
          "content_same": false
        },
        {
          "line": 2889,
          "old_api": null,
          "new_api": "tuple_shapes_size",
          "old_text": null,
          "new_text": "tuple_shape.tuple_shapes_size()",
          "old_line_content": "    };",
          "new_line_content": "  std::vector<HloInstruction*> tuple_args(tuple_shape.tuple_shapes_size());",
          "content_same": false
        },
        {
          "line": 2890,
          "old_api": null,
          "new_api": "tuple_shapes_size",
          "old_text": null,
          "new_text": "tuple_shape.tuple_shapes_size()",
          "old_line_content": "    if (i == shape_index[0]) {",
          "new_line_content": "  for (int64 i = 0; i < tuple_shape.tuple_shapes_size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2891,
          "old_api": null,
          "new_api": "tuple_shapes",
          "old_text": null,
          "new_text": "tuple_shape.tuple_shapes(i)",
          "old_line_content": "      // If the subshape is still a tuple, recurse and pass a new shape index",
          "new_line_content": "    const Shape& subshape = tuple_shape.tuple_shapes(i);",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "allocation_values.size()",
          "old_line_content": "  }",
          "new_line_content": "  for (int i = beginning_idx; i < allocation_values.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "allocation_values.at(i)",
          "old_line_content": "}",
          "new_line_content": "    AllocationValue& allocation_value = allocation_values.at(i);",
          "content_same": false
        },
        {
          "line": 844,
          "old_api": null,
          "new_api": "defining_instruction",
          "old_text": null,
          "new_text": "HloDataflowAnalysis::IsAsynchronousOperationStart(\n            allocation_value.defining_instruction()->opcode())",
          "old_line_content": "",
          "new_line_content": "    if (HloDataflowAnalysis::IsAsynchronousOperationStart(",
          "content_same": false
        },
        {
          "line": 845,
          "old_api": null,
          "new_api": "defining_instruction",
          "old_text": null,
          "new_text": "allocation_value.defining_instruction()->opcode()",
          "old_line_content": "void AlternateMemoryBestFitHeap::FindAliases(",
          "new_line_content": "            allocation_value.defining_instruction()->opcode())) {",
          "content_same": false
        },
        {
          "line": 846,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "allocation_value.uses().size()",
          "old_line_content": "    std::vector<AllocationValue>* allocation_values,",
          "new_line_content": "      CHECK_EQ(allocation_value.uses().size(), 1);",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "allocation_value.ToShortString()",
          "old_line_content": "      values_by_defining_inst;",
          "new_line_content": "      VLOG(3) << \"Mark \" << allocation_value.ToShortString()",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "HloDataflowAnalysis::IsAsynchronousOperationDone(\n          allocation_value.uses().at(0).hlo_use.instruction->opcode())",
          "old_line_content": "    bool skip_values_with_no_uses) const {",
          "new_line_content": "      CHECK(HloDataflowAnalysis::IsAsynchronousOperationDone(",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "allocation_value.uses().at(0).hlo_use.instruction->opcode()",
          "old_line_content": "  absl::flat_hash_map<const HloInstruction*, const AllocationValue*>",
          "new_line_content": "          allocation_value.uses().at(0).hlo_use.instruction->opcode()));",
          "content_same": false
        },
        {
          "line": 851,
          "old_api": null,
          "new_api": "set_requires_contiguous_allocation",
          "old_text": null,
          "new_text": "allocation_value.set_requires_contiguous_allocation(true)",
          "old_line_content": "    // Skip the value if it doesn't have any uses.",
          "new_line_content": "      allocation_value.set_requires_contiguous_allocation(true);",
          "content_same": false
        },
        {
          "line": 853,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "      continue;",
          "new_line_content": "    VLOG(3) << \"Created allocation value: \"",
          "content_same": false
        },
        {
          "line": 854,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "allocation_values.at(i).ToString()",
          "old_line_content": "    }",
          "new_line_content": "            << allocation_values.at(i).ToString();",
          "content_same": false
        },
        {
          "line": 2907,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "TF_ASSIGN_OR_RETURN(tuple_args[i],\n                            ReplaceTupleWith(new_instruction, get_operand(),\n                                             ShapeIndex(shape_index.begin() + 1,\n                                                        shape_index.end())))",
          "old_line_content": "          // If the tuple element is the same as the new instruction, we",
          "new_line_content": "        TF_ASSIGN_OR_RETURN(tuple_args[i],",
          "content_same": false
        },
        {
          "line": 2908,
          "old_api": null,
          "new_api": "get_operand",
          "old_text": null,
          "new_text": "get_operand()",
          "old_line_content": "          // actually don't have to create a new tuple, just return the original",
          "new_line_content": "                            ReplaceTupleWith(new_instruction, get_operand(),",
          "content_same": false
        },
        {
          "line": 2909,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "shape_index.begin()",
          "old_line_content": "          // tuple.",
          "new_line_content": "                                             ShapeIndex(shape_index.begin() + 1,",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "value.uses().empty()",
          "old_line_content": "    }",
          "new_line_content": "    if (value.uses().empty() && skip_values_with_no_uses) {",
          "content_same": false
        },
        {
          "line": 2913,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "subshape.ToString()",
          "old_line_content": "          return tuple;",
          "new_line_content": "          VLOG(4) << \"Old shape = \" << subshape.ToString()",
          "content_same": false
        },
        {
          "line": 2914,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "new_instruction->shape().ToString()",
          "old_line_content": "        }",
          "new_line_content": "                  << \", new shape = \" << new_instruction->shape().ToString()",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": null,
          "new_api": "defining_instruction",
          "old_text": null,
          "new_text": "value.defining_instruction()",
          "old_line_content": "  for (AllocationValue& value : *allocation_values) {",
          "new_line_content": "    CHECK_EQ(values_by_defining_inst.count(value.defining_instruction()), 0);",
          "content_same": false
        },
        {
          "line": 2916,
          "old_api": null,
          "new_api": "AddInstruction",
          "old_text": null,
          "new_text": "computation->AddInstruction(\n              HloInstruction::CreateBitcast(subshape, new_instruction))",
          "old_line_content": "      }",
          "new_line_content": "          new_instruction = computation->AddInstruction(",
          "content_same": false
        },
        {
          "line": 2917,
          "old_api": null,
          "new_api": "HloInstruction::CreateBitcast(subshape, new_instruction)",
          "old_text": null,
          "new_text": "HloInstruction::CreateBitcast(subshape, new_instruction)",
          "old_line_content": "    } else {",
          "new_line_content": "              HloInstruction::CreateBitcast(subshape, new_instruction));",
          "content_same": false
        },
        {
          "line": 2919,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "tuple->operand(i)",
          "old_line_content": "    }",
          "new_line_content": "                   tuple->operand(i) == new_instruction) {",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "values_by_defining_inst.find(instruction)",
          "old_line_content": "",
          "new_line_content": "    auto aliased_value_it = values_by_defining_inst.find(instruction);",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "values_by_defining_inst.end()",
          "old_line_content": "      // Find any aliases with the parameters of called computations.",
          "new_line_content": "    if (aliased_value_it != values_by_defining_inst.end()) {",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "use->hlo_use.ToString()",
          "old_line_content": "      for (const HloComputation* called_computation :",
          "new_line_content": "      VLOG(3) << \"Adding aliasing for use \" << use->hlo_use.ToString() << \" to \"",
          "content_same": false
        },
        {
          "line": 2923,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "",
          "new_line_content": "          VLOG(4) << \"Tuple already contains the new instruction = \"",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "aliased_value_it->second->defining_position()",
          "old_line_content": "        for (const HloInstruction* parameter_instruction :",
          "new_line_content": "      use->aliases.push_back(aliased_value_it->second->defining_position());",
          "content_same": false
        },
        {
          "line": 2924,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "new_instruction->ToShortString()",
          "old_line_content": "HloInstruction* MemorySpaceAssignment::Allocation::AddGetTupleElements() {",
          "new_line_content": "                  << new_instruction->ToShortString()",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "value.uses()",
          "old_line_content": "",
          "new_line_content": "    for (AllocationValue::Use& use : value.uses()) {",
          "content_same": false
        },
        {
          "line": 2934,
          "old_api": null,
          "new_api": "HloInstruction::CreateTuple(tuple_args)",
          "old_text": null,
          "new_text": "HloInstruction::CreateTuple(tuple_args)",
          "old_line_content": "  // If the instruction we're processing is a tuple, we (recursively) search or",
          "new_line_content": "  return computation->AddInstruction(HloInstruction::CreateTuple(tuple_args));",
          "content_same": false
        },
        {
          "line": 2938,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "defining_position()",
          "old_line_content": "    // We first search if there already is a get-tuple-element with the correct",
          "new_line_content": "  HloInstruction* producing_instruction = defining_position().instruction;",
          "content_same": false
        },
        {
          "line": 2939,
          "old_api": null,
          "new_api": "CHECK_NE",
          "old_text": null,
          "new_text": "CHECK_NE(producing_instruction, nullptr)",
          "old_line_content": "    // index. If there is no such get-tuple-element, we create one.",
          "new_line_content": "  CHECK_NE(producing_instruction, nullptr);",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": null,
          "new_api": "maybe_add_alias_with_instruction",
          "old_text": null,
          "new_text": "maybe_add_alias_with_instruction(parameter_instruction, &use)",
          "old_line_content": "      }",
          "new_line_content": "          maybe_add_alias_with_instruction(parameter_instruction, &use);",
          "content_same": false
        },
        {
          "line": 2945,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "producing_instruction->parent()",
          "old_line_content": "        });",
          "new_line_content": "  HloComputation* computation = producing_instruction->parent();",
          "content_same": false
        },
        {
          "line": 898,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "use.hlo_use.instruction->opcode()",
          "old_line_content": "AlternateMemoryBestFitHeap::GetSortedColocatedIntervals(",
          "new_line_content": "      if (use.hlo_use.instruction->opcode() == HloOpcode::kWhile) {",
          "content_same": false
        },
        {
          "line": 900,
          "old_api": null,
          "new_api": "while_body",
          "old_text": null,
          "new_text": "use.hlo_use.instruction->while_body()->root_instruction()",
          "old_line_content": "  std::vector<const BufferInterval*> colocated_intervals;",
          "new_line_content": "            use.hlo_use.instruction->while_body()->root_instruction(),",
          "content_same": false
        },
        {
          "line": 2953,
          "old_api": null,
          "new_api": "users",
          "old_text": null,
          "new_text": "absl::c_find_if(\n        producing_instruction->users(), [index](const HloInstruction* use) {\n          return use != use->parent()->root_instruction() &&\n                 use->opcode() == HloOpcode::kGetTupleElement &&\n                 use->tuple_index() == index;\n        })",
          "old_line_content": "    }",
          "new_line_content": "    auto gte_it = absl::c_find_if(",
          "content_same": false
        },
        {
          "line": 2954,
          "old_api": null,
          "new_api": "users",
          "old_text": null,
          "new_text": "producing_instruction->users()",
          "old_line_content": "  }",
          "new_line_content": "        producing_instruction->users(), [index](const HloInstruction* use) {",
          "content_same": false
        },
        {
          "line": 2955,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "use->parent()->root_instruction()",
          "old_line_content": "  return producing_instruction;",
          "new_line_content": "          return use != use->parent()->root_instruction() &&",
          "content_same": false
        },
        {
          "line": 2956,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "use->opcode()",
          "old_line_content": "}",
          "new_line_content": "                 use->opcode() == HloOpcode::kGetTupleElement &&",
          "content_same": false
        },
        {
          "line": 2957,
          "old_api": null,
          "new_api": "tuple_index",
          "old_text": null,
          "new_text": "use->tuple_index()",
          "old_line_content": "",
          "new_line_content": "                 use->tuple_index() == index;",
          "content_same": false
        },
        {
          "line": 2959,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "producing_instruction->users().end()",
          "old_line_content": "  std::string memory_space_str = \"def\";",
          "new_line_content": "    if (gte_it != producing_instruction->users().end()) {",
          "content_same": false
        },
        {
          "line": 915,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "worklist.empty()",
          "old_line_content": "  return colocated_intervals;",
          "new_line_content": "  while (!worklist.empty()) {",
          "content_same": false
        },
        {
          "line": 916,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "worklist.back()",
          "old_line_content": "}",
          "new_line_content": "    const BufferInterval* item = worklist.back();",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": null,
          "new_api": "pop_back",
          "old_text": null,
          "new_text": "worklist.pop_back()",
          "old_line_content": "",
          "new_line_content": "    worklist.pop_back();",
          "content_same": false
        },
        {
          "line": 918,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "colocated_intervals.push_back(item)",
          "old_line_content": "bool AlternateMemoryBestFitHeap::IsUseAllowedInAlternateMemory(",
          "new_line_content": "    colocated_intervals.push_back(item);",
          "content_same": false
        },
        {
          "line": 2964,
          "old_api": null,
          "new_api": "tuple_shapes",
          "old_text": null,
          "new_text": "producing_instruction->shape().tuple_shapes(index)",
          "old_line_content": "                      \"Allocation in \", memory_space_str, \" defined at \",",
          "new_line_content": "              producing_instruction->shape().tuple_shapes(index),",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": null,
          "new_api": "std::make_pair(y->start, y->end)",
          "old_text": null,
          "new_text": "std::make_pair(y->start, y->end)",
          "old_line_content": "",
          "new_line_content": "    return std::make_pair(x->start, x->end) < std::make_pair(y->start, y->end);",
          "content_same": false
        },
        {
          "line": 2976,
          "old_api": null,
          "new_api": "is_scoped_allocation",
          "old_text": null,
          "new_text": "is_scoped_allocation()",
          "old_line_content": "",
          "new_line_content": "  return absl::StrCat((is_scoped_allocation() ? \"Scoped \" : \"\"),",
          "content_same": false
        },
        {
          "line": 2978,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "defining_position_.ToString()",
          "old_line_content": "    MemorySpaceAssignment* memory_space_assignment) {",
          "new_line_content": "                      defining_position_.ToString());",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": null,
          "new_api": "instruction_schedule",
          "old_text": null,
          "new_text": "hlo_live_range_.instruction_schedule()",
          "old_line_content": "    int64 parameter_time =",
          "new_line_content": "  const auto& instruction_schedule = hlo_live_range_.instruction_schedule();",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": null,
          "new_api": "dataflow_analysis",
          "old_text": null,
          "new_text": "alias_analysis_.dataflow_analysis().GetUniqueValueAt(\n            while_body->parameter_instruction(0), use.operand_index)",
          "old_line_content": "      }",
          "new_line_content": "        &alias_analysis_.dataflow_analysis().GetUniqueValueAt(",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": null,
          "new_api": "parameter_instruction",
          "old_text": null,
          "new_text": "while_body->parameter_instruction(0)",
          "old_line_content": "    }",
          "new_line_content": "            while_body->parameter_instruction(0), use.operand_index);",
          "content_same": false
        },
        {
          "line": 2993,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "defining_position().shape()",
          "old_line_content": "",
          "new_line_content": "  Shape shape = defining_position().shape();",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": null,
          "new_api": "parameter_instruction",
          "old_text": null,
          "new_text": "while_body->parameter_instruction(0)",
          "old_line_content": "    // to allocate it in the loop.",
          "new_line_content": "        instruction_schedule.at(while_body->parameter_instruction(0));",
          "content_same": false
        },
        {
          "line": 948,
          "old_api": null,
          "new_api": "root_instruction",
          "old_text": null,
          "new_text": "while_body->root_instruction()",
          "old_line_content": "    if (min_use_time == root_time) {",
          "new_line_content": "    int64 root_time = instruction_schedule.at(while_body->root_instruction());",
          "content_same": false
        },
        {
          "line": 2994,
          "old_api": null,
          "new_api": "AddGetTupleElements",
          "old_text": null,
          "new_text": "AddGetTupleElements()",
          "old_line_content": "  // Replace all the uses with the new copy instruction.",
          "new_line_content": "  HloInstruction* producing_instruction = AddGetTupleElements();",
          "content_same": false
        },
        {
          "line": 950,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "parameter_value->uses()",
          "old_line_content": "              << \"use time = \" << min_use_time << \", root time = \" << root_time;",
          "new_line_content": "    for (const HloUse& parameter_use : parameter_value->uses()) {",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "instruction_schedule.at(parameter_use.instruction)",
          "old_line_content": "      return false;",
          "new_line_content": "      int64 use_time = instruction_schedule.at(parameter_use.instruction);",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "parameter_use.instruction->opcode()",
          "old_line_content": "    }",
          "new_line_content": "      if (parameter_use.instruction->opcode() != HloOpcode::kGetTupleElement &&",
          "content_same": false
        },
        {
          "line": 2995,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "producing_instruction->parent()",
          "old_line_content": "  for (HloUse use : uses_) {",
          "new_line_content": "  HloComputation* computation = producing_instruction->parent();",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "parameter_use.instruction->opcode()",
          "old_line_content": "    // Allow the buffer in alternate memory if the buffer has a short live range",
          "new_line_content": "          parameter_use.instruction->opcode() != HloOpcode::kBitcast &&",
          "content_same": false
        },
        {
          "line": 2996,
          "old_api": null,
          "new_api": "HloInstruction::CreateCopyStart(\n      ShapeUtil::MakeTupleShape({shape, shape, ShapeUtil::MakeShape(U32, {})}),\n      producing_instruction, is_cross_program_prefetch_)",
          "old_text": null,
          "new_text": "HloInstruction::CreateCopyStart(\n      ShapeUtil::MakeTupleShape({shape, shape, ShapeUtil::MakeShape(U32, {})}),\n      producing_instruction, is_cross_program_prefetch_)",
          "old_line_content": "    // If the operand is a tuple, we need to descend to the actual instruction",
          "new_line_content": "  copy_start_ = computation->AddInstruction(HloInstruction::CreateCopyStart(",
          "content_same": false
        },
        {
          "line": 2997,
          "old_api": null,
          "new_api": "ShapeUtil::MakeShape(U32, {})",
          "old_text": null,
          "new_text": "ShapeUtil::MakeShape(U32, {})",
          "old_line_content": "    // we want to replace.",
          "new_line_content": "      ShapeUtil::MakeTupleShape({shape, shape, ShapeUtil::MakeShape(U32, {})}),",
          "content_same": false
        },
        {
          "line": 3002,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "defining_position().ToString()",
          "old_line_content": "          replacement_instruction,",
          "new_line_content": "          << \" for position: \" << defining_position().ToString();",
          "content_same": false
        },
        {
          "line": 962,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "    // Check if there is a required assignment for the while loop output.",
          "new_line_content": "      VLOG(4) << \"While allocation not allowed in alternate memory. \"",
          "content_same": false
        },
        {
          "line": 3012,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "use.instruction->operand(use.operand_number)->shape()",
          "old_line_content": "    } else {",
          "new_line_content": "    Shape operand_shape = use.instruction->operand(use.operand_number)->shape();",
          "content_same": false
        },
        {
          "line": 3013,
          "old_api": null,
          "new_api": "IsTuple",
          "old_text": null,
          "new_text": "operand_shape.IsTuple()",
          "old_line_content": "      replacement_instruction = copy_done_;",
          "new_line_content": "    if (operand_shape.IsTuple()) {",
          "content_same": false
        },
        {
          "line": 3014,
          "old_api": null,
          "new_api": "mutable_operand",
          "old_text": null,
          "new_text": "TF_ASSIGN_OR_RETURN(\n          replacement_instruction,\n          ReplaceTupleWith(copy_done_,\n                           use.instruction->mutable_operand(use.operand_number),\n                           use.operand_index))",
          "old_line_content": "    }",
          "new_line_content": "      TF_ASSIGN_OR_RETURN(",
          "content_same": false
        },
        {
          "line": 3016,
          "old_api": null,
          "new_api": "mutable_operand",
          "old_text": null,
          "new_text": "ReplaceTupleWith(copy_done_,\n                           use.instruction->mutable_operand(use.operand_number),\n                           use.operand_index)",
          "old_line_content": "        use.operand_number, replacement_instruction));",
          "new_line_content": "          ReplaceTupleWith(copy_done_,",
          "content_same": false
        },
        {
          "line": 969,
          "old_api": null,
          "new_api": "CanAllocateInAlternateMemoryNoCopy",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(\n            shape, parameter_time, min_use_time)",
          "old_line_content": "    if (existing_required_assignment &&",
          "new_line_content": "    if (!options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(",
          "content_same": false
        },
        {
          "line": 3017,
          "old_api": null,
          "new_api": "mutable_operand",
          "old_text": null,
          "new_text": "use.instruction->mutable_operand(use.operand_number)",
          "old_line_content": "  }",
          "new_line_content": "                           use.instruction->mutable_operand(use.operand_number),",
          "content_same": false
        },
        {
          "line": 3020,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "operand_shape.ToString()",
          "old_line_content": "}",
          "new_line_content": "      VLOG(4) << \"Old shape = \" << operand_shape.ToString()",
          "content_same": false
        },
        {
          "line": 3021,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "copy_done_->shape().ToString()",
          "old_line_content": "",
          "new_line_content": "              << \", new shape = \" << copy_done_->shape().ToString()",
          "content_same": false
        },
        {
          "line": 3024,
          "old_api": null,
          "new_api": "HloInstruction::CreateBitcast(operand_shape, copy_done_)",
          "old_text": null,
          "new_text": "HloInstruction::CreateBitcast(operand_shape, copy_done_)",
          "old_line_content": "  // Insert CopyStart/CopyDone pairs.",
          "new_line_content": "          HloInstruction::CreateBitcast(operand_shape, copy_done_));",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": null,
          "new_api": "dataflow_analysis",
          "old_text": null,
          "new_text": "alias_analysis_.dataflow_analysis().GetUniqueValueAt(\n            use.instruction, use.operand_index)",
          "old_line_content": "    // multiple called computations), determine if the parameter->first use",
          "new_line_content": "        &alias_analysis_.dataflow_analysis().GetUniqueValueAt(",
          "content_same": false
        },
        {
          "line": 3028,
          "old_api": null,
          "new_api": "ReplaceOperandWith",
          "old_text": null,
          "new_text": "use.instruction->ReplaceOperandWith(\n        use.operand_number, replacement_instruction)",
          "old_line_content": "    // Add the offset and size of the allocation in the alternate memory to",
          "new_line_content": "    TF_RETURN_IF_ERROR(use.instruction->ReplaceOperandWith(",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": null,
          "new_api": "RequiredMemoryAssignmentAt",
          "old_text": null,
          "new_text": "RequiredMemoryAssignmentAt(while_value, while_time)",
          "old_line_content": "      if (other_use.hlo_use.instruction != use.instruction) {",
          "new_line_content": "        RequiredMemoryAssignmentAt(while_value, while_time);",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "      HloComputation* called_computation =",
          "new_line_content": "      VLOG(4) << \"While allocation not allowed in alternate memory because \"",
          "content_same": false
        },
        {
          "line": 3039,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "allocation->ToString()",
          "old_line_content": "      alternate_memory_size_ =",
          "new_line_content": "    VLOG(3) << \"Processing: \" << allocation->ToString();",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "value.uses()",
          "old_line_content": "      int64 min_use_time = conditional_time;",
          "new_line_content": "    for (const AllocationValue::Use& other_use : value.uses()) {",
          "content_same": false
        },
        {
          "line": 3044,
          "old_api": null,
          "new_api": "memory_space",
          "old_text": null,
          "new_text": "allocation->memory_space()",
          "old_line_content": "}",
          "new_line_content": "      CHECK(allocation->memory_space() == MemorySpace::kAlternate);",
          "content_same": false
        },
        {
          "line": 3045,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "scoped_memory_assignments_.emplace_back(\n          allocation->defining_position().instruction, allocation->chunk())",
          "old_line_content": "",
          "new_line_content": "      scoped_memory_assignments_.emplace_back(",
          "content_same": false
        },
        {
          "line": 3046,
          "old_api": null,
          "new_api": "chunk",
          "old_text": null,
          "new_text": "allocation->chunk()",
          "old_line_content": "Status MemorySpaceAssignment::ExportAndColorBuffers() {",
          "new_line_content": "          allocation->defining_position().instruction, allocation->chunk());",
          "content_same": false
        },
        {
          "line": 3048,
          "old_api": null,
          "new_api": "chunk_end",
          "old_text": null,
          "new_text": "allocation->chunk().chunk_end()",
          "old_line_content": "  TF_ASSIGN_OR_RETURN(auto alias_analysis, HloAliasAnalysis::Run(module_));",
          "new_line_content": "          std::max(alternate_memory_size_, allocation->chunk().chunk_end());",
          "content_same": false
        },
        {
          "line": 3049,
          "old_api": null,
          "new_api": "memory_space",
          "old_text": null,
          "new_text": "allocation->memory_space()",
          "old_line_content": "  absl::flat_hash_map<int64, int64> seen_buffer_offsets;",
          "new_line_content": "    } else if (allocation->memory_space() == MemorySpace::kAlternate) {",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": null,
          "new_api": "dataflow_analysis",
          "old_text": null,
          "new_text": "alias_analysis_.dataflow_analysis().GetUniqueValueAt(\n              parameter_instruction, other_use.hlo_use.operand_index)",
          "old_line_content": "      }",
          "new_line_content": "          &alias_analysis_.dataflow_analysis().GetUniqueValueAt(",
          "content_same": false
        },
        {
          "line": 3051,
          "old_api": null,
          "new_api": "chunk",
          "old_text": null,
          "new_text": "allocation->chunk()",
          "old_line_content": "  for (const auto& position_and_chunk : alternate_memory_assignments_) {",
          "new_line_content": "          allocation->defining_position(), allocation->chunk());",
          "content_same": false
        },
        {
          "line": 3053,
          "old_api": null,
          "new_api": "chunk_end",
          "old_text": null,
          "new_text": "allocation->chunk().chunk_end()",
          "old_line_content": "    const Chunk& chunk = position_and_chunk.second;",
          "new_line_content": "          std::max(alternate_memory_size_, allocation->chunk().chunk_end());",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "parameter_value->uses()",
          "old_line_content": "                   \"computation = \"",
          "new_line_content": "      for (const HloUse& parameter_use : parameter_value->uses()) {",
          "content_same": false
        },
        {
          "line": 1009,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "parameter_use.instruction->opcode()",
          "old_line_content": "                << \", parameter time = \" << parameter_time",
          "new_line_content": "            parameter_use.instruction->opcode() !=",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "parameter_use.instruction->opcode()",
          "old_line_content": "        return true;",
          "new_line_content": "            parameter_use.instruction->opcode() != HloOpcode::kTuple &&",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "parameter_use.instruction->opcode()",
          "old_line_content": "      } else {",
          "new_line_content": "            parameter_use.instruction->opcode() != HloOpcode::kBitcast) {",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "instruction_schedule.at(parameter_use.instruction)",
          "old_line_content": "                   \"computation = \"",
          "new_line_content": "              min_use_time, instruction_schedule.at(parameter_use.instruction));",
          "content_same": false
        },
        {
          "line": 1017,
          "old_api": null,
          "new_api": "CanAllocateInAlternateMemoryNoCopy",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(\n              parameter_value->shape(), parameter_time, min_use_time)",
          "old_line_content": "                << \", min use time = \" << min_use_time;",
          "new_line_content": "      if (options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "parameter_value->shape()",
          "old_line_content": "      }",
          "new_line_content": "              parameter_value->shape(), parameter_time, min_use_time)) {",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "    }",
          "new_line_content": "        VLOG(4) << \"Conditional allocation allowed in alternate memory for \"",
          "content_same": false
        },
        {
          "line": 3067,
          "old_api": null,
          "new_api": "GetUniqueBufferAt",
          "old_text": null,
          "new_text": "alias_analysis->GetUniqueBufferAt(\n        defining_position.instruction, defining_position.index)",
          "old_line_content": "    }",
          "new_line_content": "    const HloBuffer& buffer = alias_analysis->GetUniqueBufferAt(",
          "content_same": false
        },
        {
          "line": 1021,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "called_computation->name()",
          "old_line_content": "  }",
          "new_line_content": "                << called_computation->name()",
          "content_same": false
        },
        {
          "line": 3069,
          "old_api": null,
          "new_api": "id",
          "old_text": null,
          "new_text": "buffer.id()",
          "old_line_content": "",
          "new_line_content": "    auto seen_buffer_offset_it = seen_buffer_offsets.find(buffer.id());",
          "content_same": false
        },
        {
          "line": 3071,
          "old_api": null,
          "new_api": "CHECK_EQ",
          "old_text": null,
          "new_text": "CHECK_EQ(chunk.offset, seen_buffer_offset_it->second)",
          "old_line_content": "  for (const auto& instruction_and_chunk : scoped_memory_assignments_) {",
          "new_line_content": "      CHECK_EQ(chunk.offset, seen_buffer_offset_it->second)",
          "content_same": false
        },
        {
          "line": 3073,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "defining_position.ToString()",
          "old_line_content": "    const Chunk& chunk = instruction_and_chunk.second;",
          "new_line_content": "          << buffer.ToString() << \", pos: \" << defining_position.ToString();",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "void AlternateMemoryBestFitHeap::AppendBufferInfoDebugString(",
          "new_line_content": "        VLOG(4) << \"Conditional allocation not allowed in alternate memory for \"",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "called_computation->name()",
          "old_line_content": "    std::string* debug_str) const {",
          "new_line_content": "                << called_computation->name()",
          "content_same": false
        },
        {
          "line": 3077,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "buffer.ToString()",
          "old_line_content": "  }",
          "new_line_content": "              << buffer.ToString() << \")\";",
          "content_same": false
        },
        {
          "line": 3078,
          "old_api": null,
          "new_api": "add_chunk",
          "old_text": null,
          "new_text": "preset_assignments_->add_chunk(defining_position, chunk)",
          "old_line_content": "",
          "new_line_content": "      preset_assignments_->add_chunk(defining_position, chunk);",
          "content_same": false
        },
        {
          "line": 3083,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "        ->size = alternate_memory_size_;",
          "new_line_content": "  VLOG(3) << \"Exported scoped allocations in alternate memory:\";",
          "content_same": false
        },
        {
          "line": 3089,
          "old_api": null,
          "new_api": "add_scoped_allocation_chunk",
          "old_text": null,
          "new_text": "preset_assignments_->add_scoped_allocation_chunk(instruction, chunk)",
          "old_line_content": "  }",
          "new_line_content": "    preset_assignments_->add_scoped_allocation_chunk(instruction, chunk);",
          "content_same": false
        },
        {
          "line": 3092,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "preset_assignments_->chunks().empty()",
          "old_line_content": "  // Color the pending positions and all of their aliased buffers.",
          "new_line_content": "  if (!preset_assignments_->chunks().empty() ||",
          "content_same": false
        },
        {
          "line": 3093,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "preset_assignments_->scoped_allocation_chunks().empty()",
          "old_line_content": "  for (const auto& defining_position_and_chunk :",
          "new_line_content": "      !preset_assignments_->scoped_allocation_chunks().empty()) {",
          "content_same": false
        },
        {
          "line": 3107,
          "old_api": null,
          "new_api": "chunks",
          "old_text": null,
          "new_text": "preset_assignments_->chunks()",
          "old_line_content": "        }",
          "new_line_content": "       preset_assignments_->chunks()) {",
          "content_same": false
        },
        {
          "line": 3109,
          "old_api": null,
          "new_api": "ComputeBuffersAt",
          "old_text": null,
          "new_text": "alias_analysis->ComputeBuffersAt(\n             defining_position.instruction, defining_position.index)",
          "old_line_content": "    }",
          "new_line_content": "    for (auto& buffer : alias_analysis->ComputeBuffersAt(",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": null,
          "new_api": "GetBufferContainingValue",
          "old_text": null,
          "new_text": "alias_analysis_.GetBufferContainingValue(*interval.buffer)",
          "old_line_content": "  std::vector<std::string> use_names;",
          "new_line_content": "      alias_analysis_.GetBufferContainingValue(*interval.buffer);",
          "content_same": false
        },
        {
          "line": 3112,
          "old_api": null,
          "new_api": "positions",
          "old_text": null,
          "new_text": "value->positions()",
          "old_line_content": "}",
          "new_line_content": "        for (auto& position : value->positions()) {",
          "content_same": false
        },
        {
          "line": 1065,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "interval.buffer->defining_position()",
          "old_line_content": "  for (const auto& use : uses) {",
          "new_line_content": "      instruction_schedule.at(interval.buffer->defining_position().instruction);",
          "content_same": false
        },
        {
          "line": 3113,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "position.ToString()",
          "old_line_content": "",
          "new_line_content": "          VLOG(4) << \"Coloring \" << position.ToString();",
          "content_same": false
        },
        {
          "line": 3114,
          "old_api": null,
          "new_api": "mutable_shape",
          "old_text": null,
          "new_text": "ShapeUtil::GetMutableSubshape(\n              position.instruction->mutable_shape(), position.index)",
          "old_line_content": "void MemorySpaceAssignment::RemoveAssignmentForInstruction(",
          "new_line_content": "          Shape* shape = ShapeUtil::GetMutableSubshape(",
          "content_same": false
        },
        {
          "line": 1068,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "value->uses()",
          "old_line_content": "  }",
          "new_line_content": "    for (const HloUse& use : value->uses()) {",
          "content_same": false
        },
        {
          "line": 1069,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "uses.push_back(\n          {instruction_schedule.at(use.instruction), use.ToString()})",
          "old_line_content": "",
          "new_line_content": "      uses.push_back(",
          "content_same": false
        },
        {
          "line": 3115,
          "old_api": null,
          "new_api": "mutable_shape",
          "old_text": null,
          "new_text": "position.instruction->mutable_shape()",
          "old_line_content": "    const HloInstruction* instruction) {",
          "new_line_content": "              position.instruction->mutable_shape(), position.index);",
          "content_same": false
        },
        {
          "line": 3116,
          "old_api": null,
          "new_api": "IsArray",
          "old_text": null,
          "new_text": "shape->IsArray()",
          "old_line_content": "  for (auto& position_and_chunk : alternate_memory_assignments_) {",
          "new_line_content": "          CHECK(shape->IsArray()) << \"Coloring a shape that is not an array: \"",
          "content_same": false
        },
        {
          "line": 3117,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "position.ToString()",
          "old_line_content": "    const HloPosition& position = position_and_chunk.first;",
          "new_line_content": "                                  << position.ToString();",
          "content_same": false
        },
        {
          "line": 3118,
          "old_api": null,
          "new_api": "mutable_layout",
          "old_text": null,
          "new_text": "shape->mutable_layout()->set_memory_space(\n              options_.alternate_memory_space)",
          "old_line_content": "    if (position.instruction == instruction) {",
          "new_line_content": "          shape->mutable_layout()->set_memory_space(",
          "content_same": false
        },
        {
          "line": 1076,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "uses.size()",
          "old_line_content": "      debug_str, alternate_memory_benefit ? *alternate_memory_benefit : 0, \",\");",
          "new_line_content": "  use_times.reserve(uses.size());",
          "content_same": false
        },
        {
          "line": 3124,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "    }",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 1083,
          "old_api": null,
          "new_api": "id",
          "old_text": null,
          "new_text": "buffer.id()",
          "old_line_content": "",
          "new_line_content": "  absl::StrAppend(debug_str, buffer.id(), \",\");",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "interval.buffer->ToShortString()",
          "old_line_content": "void AlternateMemoryBestFitHeap::AppendAllocationInfoDebugString(",
          "new_line_content": "  absl::StrAppend(debug_str, \"\\\"\", interval.buffer->ToShortString(), \"\\\",\");",
          "content_same": false
        },
        {
          "line": 3132,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "    // modified.",
          "new_line_content": "      VLOG(3) << \"Removing instruction from alternate memory assignments.\";",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": null,
          "new_api": "BufferIntervalAlternateMemoryBenefit",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->BufferIntervalAlternateMemoryBenefit(\n          interval)",
          "old_line_content": "    const MemorySpaceAssignment::Allocation& allocation,",
          "new_line_content": "      options_.prefetch_interval_picker->BufferIntervalAlternateMemoryBenefit(",
          "content_same": false
        },
        {
          "line": 3135,
          "old_api": null,
          "new_api": "pop_back",
          "old_text": null,
          "new_text": "alternate_memory_assignments_.pop_back()",
          "old_line_content": "              << \" because it's not in the schedule.\";",
          "new_line_content": "      alternate_memory_assignments_.pop_back();",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": null,
          "new_api": "absl::StrAppend(\n      debug_str, alternate_memory_benefit ? *alternate_memory_benefit : 0, \",\")",
          "old_text": null,
          "new_text": "absl::StrAppend(\n      debug_str, alternate_memory_benefit ? *alternate_memory_benefit : 0, \",\")",
          "old_line_content": "  // Columns in allocation information:",
          "new_line_content": "  absl::StrAppend(",
          "content_same": false
        },
        {
          "line": 1090,
          "old_api": null,
          "new_api": "absl::StrAppend(debug_str, interval.size, \",\")",
          "old_text": null,
          "new_text": "absl::StrAppend(debug_str, interval.size, \",\")",
          "old_line_content": "  // size: int. In bytes.",
          "new_line_content": "  absl::StrAppend(debug_str, interval.size, \",\");",
          "content_same": false
        },
        {
          "line": 1091,
          "old_api": null,
          "new_api": "absl::StrAppend(debug_str, definition_time, \",\")",
          "old_text": null,
          "new_text": "absl::StrAppend(debug_str, definition_time, \",\")",
          "old_line_content": "  // offset: int. In bytes.",
          "new_line_content": "  absl::StrAppend(debug_str, definition_time, \",\");",
          "content_same": false
        },
        {
          "line": 1092,
          "old_api": null,
          "new_api": "absl::StrJoin(use_times, \";\")",
          "old_text": null,
          "new_text": "absl::StrJoin(use_times, \";\")",
          "old_line_content": "  // start_time: int. Logical start time of the allocation.",
          "new_line_content": "  absl::StrAppend(debug_str, \"\\\"\", absl::StrJoin(use_times, \";\"), \"\\\",\");",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": null,
          "new_api": "absl::StrJoin(use_names, \";\")",
          "old_text": null,
          "new_text": "absl::StrJoin(use_names, \";\")",
          "old_line_content": "  // end_time: int. Logical end time of the allocation.",
          "new_line_content": "  absl::StrAppend(debug_str, \"\\\"\", absl::StrJoin(use_names, \";\"), \"\\\"\");",
          "content_same": false
        },
        {
          "line": 3142,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "    // control dependencies).",
          "new_line_content": "  VLOG(1) << \"Simplifying graph...\";",
          "content_same": false
        },
        {
          "line": 3143,
          "old_api": null,
          "new_api": "MakeNonfusionComputations",
          "old_text": null,
          "new_text": "module_->MakeNonfusionComputations()",
          "old_line_content": "    for (HloInstruction* instruction :",
          "new_line_content": "  for (HloComputation* computation : module_->MakeNonfusionComputations()) {",
          "content_same": false
        },
        {
          "line": 3146,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "computations_in_schedule_.contains(computation)",
          "old_line_content": "    }",
          "new_line_content": "    if (!computations_in_schedule_.contains(computation)) {",
          "content_same": false
        },
        {
          "line": 3147,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "computation->name()",
          "old_line_content": "    // We perform limited DCE and forward the tuple operand in patterns like",
          "new_line_content": "      VLOG(4) << \"Not simplifying \" << computation->name()",
          "content_same": false
        },
        {
          "line": 1107,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "debug_str.empty()",
          "old_line_content": "}",
          "new_line_content": "  if (debug_str.empty()) {",
          "content_same": false
        },
        {
          "line": 1109,
          "old_api": null,
          "new_api": "absl::StrAppend(&debug_str, \"buffer_id,size,offset,start_time,end_time\\n\")",
          "old_text": null,
          "new_text": "absl::StrAppend(&debug_str, \"buffer_id,size,offset,start_time,end_time\\n\")",
          "old_line_content": "void AlternateMemoryBestFitHeap::DumpDebugStringsIfEnabled() const {",
          "new_line_content": "    absl::StrAppend(&debug_str, \"buffer_id,size,offset,start_time,end_time\\n\");",
          "content_same": false
        },
        {
          "line": 1111,
          "old_api": null,
          "new_api": "memory_space",
          "old_text": null,
          "new_text": "allocation.memory_space()",
          "old_line_content": "    return;",
          "new_line_content": "  if (allocation.memory_space() == MemorySpace::kAlternate) {",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "value.size()",
          "old_line_content": "}",
          "new_line_content": "    absl::StrAppend(&debug_str, value.size(), \",\");",
          "content_same": false
        },
        {
          "line": 1116,
          "old_api": null,
          "new_api": "chunk",
          "old_text": null,
          "new_text": "allocation.chunk()",
          "old_line_content": "",
          "new_line_content": "    absl::StrAppend(&debug_str, allocation.chunk().offset, \",\");",
          "content_same": false
        },
        {
          "line": 1117,
          "old_api": null,
          "new_api": "start_time",
          "old_text": null,
          "new_text": "allocation.start_time()",
          "old_line_content": "HeapSimulator::Result<HloValue> AlternateMemoryBestFitHeap::Finish() {",
          "new_line_content": "    absl::StrAppend(&debug_str, allocation.start_time(), \",\");",
          "content_same": false
        },
        {
          "line": 3168,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "computation->name()",
          "old_line_content": "          // with a nullptr. This is needed because FixSchedule relies on the",
          "new_line_content": "      VLOG(4) << \"Running simplify graph loop over \" << computation->name();",
          "content_same": false
        },
        {
          "line": 3170,
          "old_api": null,
          "new_api": "MakeInstructionPostOrder",
          "old_text": null,
          "new_text": "computation->MakeInstructionPostOrder()",
          "old_line_content": "          // scheduling asynchronous copies.",
          "new_line_content": "           computation->MakeInstructionPostOrder()) {",
          "content_same": false
        },
        {
          "line": 3171,
          "old_api": null,
          "new_api": "IsSafelyRemovable",
          "old_text": null,
          "new_text": "computation->IsSafelyRemovable(instruction)",
          "old_line_content": "          auto instruction_it =",
          "new_line_content": "        if (computation->IsSafelyRemovable(instruction) &&",
          "content_same": false
        },
        {
          "line": 3174,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "            *instruction_it = nullptr;",
          "new_line_content": "            instruction->opcode() != HloOpcode::kCopyStart &&",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": null,
          "new_api": "dump_fn",
          "old_text": null,
          "new_text": "options_.dump_fn(\"allocinfo\", allocation_info_str_)",
          "old_line_content": "    }",
          "new_line_content": "  options_.dump_fn(\"allocinfo\", allocation_info_str_);",
          "content_same": false
        },
        {
          "line": 3175,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "          }",
          "new_line_content": "            instruction->opcode() != HloOpcode::kCopyDone) {",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": null,
          "new_api": "FindCrossProgramPrefetchCandidate",
          "old_text": null,
          "new_text": "FindCrossProgramPrefetchCandidate(\n            alias_analysis_, hlo_live_range_, options_)",
          "old_line_content": "          << options_.max_size_in_bytes;",
          "new_line_content": "        prefetch_candidate = FindCrossProgramPrefetchCandidate(",
          "content_same": false
        },
        {
          "line": 3191,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "          // with x.",
          "new_line_content": "        } else if (instruction->opcode() == HloOpcode::kGetTupleElement) {",
          "content_same": false
        },
        {
          "line": 3192,
          "old_api": null,
          "new_api": "mutable_operand",
          "old_text": null,
          "new_text": "instruction->mutable_operand(0)",
          "old_line_content": "          bool can_replace =",
          "new_line_content": "          HloInstruction* operand = instruction->mutable_operand(0);",
          "content_same": false
        },
        {
          "line": 1146,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "  }",
          "new_line_content": "  VLOG(1) << \"Assigning buffers to alternate memory. Max heap size = \"",
          "content_same": false
        },
        {
          "line": 3195,
          "old_api": null,
          "new_api": "tuple_index",
          "old_text": null,
          "new_text": "instruction->tuple_index()",
          "old_line_content": "                  HloOpcode::kGetTupleElement &&",
          "new_line_content": "                operand->mutable_operand(instruction->tuple_index());",
          "content_same": false
        },
        {
          "line": 3197,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "forwarded_instruction->ToString()",
          "old_line_content": "                      ->operand(0)",
          "new_line_content": "                    << \" with \" << forwarded_instruction->ToString();",
          "content_same": false
        },
        {
          "line": 3198,
          "old_api": null,
          "new_api": "ReplaceAllUsesWith",
          "old_text": null,
          "new_text": "TF_RETURN_IF_ERROR(\n                instruction->ReplaceAllUsesWith(forwarded_instruction))",
          "old_line_content": "                      ->shape()",
          "new_line_content": "            TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 1151,
          "old_api": null,
          "new_api": "VLOG_IS_ON",
          "old_text": null,
          "new_text": "VLOG_IS_ON(3)",
          "old_line_content": "      // Increment the reserved part of alternate memory so that it is not",
          "new_line_content": "  if (VLOG_IS_ON(3)) {",
          "content_same": false
        },
        {
          "line": 1152,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "      // available for other buffers.",
          "new_line_content": "    VLOG(3) << \"Flattened instruction sequence:\";",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": null,
          "new_api": "flattened_instruction_sequence",
          "old_text": null,
          "new_text": "hlo_live_range_.flattened_instruction_sequence().instructions()",
          "old_line_content": "    }",
          "new_line_content": "        hlo_live_range_.flattened_instruction_sequence().instructions();",
          "content_same": false
        },
        {
          "line": 1155,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "instruction_sequence.size()",
          "old_line_content": "  }",
          "new_line_content": "    for (int i = 0; i < instruction_sequence.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 3202,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "               ++operand_number) {",
          "new_line_content": "        } else if (instruction->opcode() == HloOpcode::kTuple) {",
          "content_same": false
        },
        {
          "line": 1157,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "instruction_sequence[i]->name()",
          "old_line_content": "",
          "new_line_content": "              << \" \" << instruction_sequence[i]->name();",
          "content_same": false
        },
        {
          "line": 3209,
          "old_api": null,
          "new_api": "tuple_shapes_size",
          "old_text": null,
          "new_text": "instruction->operand(0)\n                      ->operand(0)\n                      ->shape()\n                      .tuple_shapes_size()",
          "old_line_content": "              break;",
          "new_line_content": "              instruction->operand(0)",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": null,
          "new_api": "GetSortedColocatedIntervals",
          "old_text": null,
          "new_text": "GetSortedColocatedIntervals(interval)",
          "old_line_content": "",
          "new_line_content": "    auto colocated_intervals = GetSortedColocatedIntervals(interval);",
          "content_same": false
        },
        {
          "line": 3212,
          "old_api": null,
          "new_api": "operand_count",
          "old_text": null,
          "new_text": "instruction->operand_count()",
          "old_line_content": "          if (can_replace) {",
          "new_line_content": "                      .tuple_shapes_size() == instruction->operand_count();",
          "content_same": false
        },
        {
          "line": 1166,
          "old_api": null,
          "new_api": "size_fn",
          "old_text": null,
          "new_text": "options_.size_fn(*interval.buffer)",
          "old_line_content": "    }",
          "new_line_content": "      reserved_in_bytes_ += options_.size_fn(*interval.buffer);",
          "content_same": false
        },
        {
          "line": 3219,
          "old_api": null,
          "new_api": "tuple_index",
          "old_text": null,
          "new_text": "operand->tuple_index()",
          "old_line_content": "            computation_modified = true;",
          "new_line_content": "                operand->tuple_index() != operand_number ||",
          "content_same": false
        },
        {
          "line": 3220,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "instruction->operand(0)->operand(0)",
          "old_line_content": "          }",
          "new_line_content": "                operand->operand(0) != instruction->operand(0)->operand(0)) {",
          "content_same": false
        },
        {
          "line": 3227,
          "old_api": null,
          "new_api": "mutable_operand",
          "old_text": null,
          "new_text": "instruction->mutable_operand(0)->mutable_operand(0)",
          "old_line_content": "}",
          "new_line_content": "                instruction->mutable_operand(0)->mutable_operand(0);",
          "content_same": false
        },
        {
          "line": 3228,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "instruction->ToString()",
          "old_line_content": "",
          "new_line_content": "            VLOG(4) << \"Replacing uses of \" << instruction->ToString()",
          "content_same": false
        },
        {
          "line": 3229,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "forwarded_instruction->ToString()",
          "old_line_content": "void MemorySpaceAssignment::EnsureInstructionAndOperandsInserted(",
          "new_line_content": "                    << \" with \" << forwarded_instruction->ToString();",
          "content_same": false
        },
        {
          "line": 3230,
          "old_api": null,
          "new_api": "ReplaceAllUsesWith",
          "old_text": null,
          "new_text": "TF_RETURN_IF_ERROR(\n                instruction->ReplaceAllUsesWith(forwarded_instruction))",
          "old_line_content": "    HloInstruction* new_instruction, HloInstructionSequence* new_sequence,",
          "new_line_content": "            TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 3231,
          "old_api": null,
          "new_api": "ReplaceAllUsesWith",
          "old_text": null,
          "new_text": "instruction->ReplaceAllUsesWith(forwarded_instruction)",
          "old_line_content": "    absl::flat_hash_set<HloInstruction*>* inserted_instructions) const {",
          "new_line_content": "                instruction->ReplaceAllUsesWith(forwarded_instruction));",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "inst->opcode()",
          "old_line_content": "    }",
          "new_line_content": "    if (inst->opcode() == HloOpcode::kParameter &&",
          "content_same": false
        },
        {
          "line": 1186,
          "old_api": null,
          "new_api": "CrossProgramPrefetches",
          "old_text": null,
          "new_text": "module->CrossProgramPrefetches()",
          "old_line_content": "",
          "new_line_content": "        absl::c_count(module->CrossProgramPrefetches(),",
          "content_same": false
        },
        {
          "line": 1188,
          "old_api": null,
          "new_api": "index",
          "old_text": null,
          "new_text": "interval.buffer->index()",
          "old_line_content": "",
          "new_line_content": "                                     interval.buffer->index())) > 0) {",
          "content_same": false
        },
        {
          "line": 1194,
          "old_api": null,
          "new_api": "available_heap_size",
          "old_text": null,
          "new_text": "available_heap_size()",
          "old_line_content": "        // Color all of the aliased reserved buffers here because reserved",
          "new_line_content": "    if (interval.size > available_heap_size()) {",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "interval.buffer->ToShortString()",
          "old_line_content": "        // alternate memory allocations will not have an entry in preset",
          "new_line_content": "      VLOG(3) << \"Skip \" << interval.buffer->ToShortString()",
          "content_same": false
        },
        {
          "line": 3245,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "inserted_instructions->contains(new_instruction)",
          "old_line_content": "  }",
          "new_line_content": "  if (inserted_instructions->contains(new_instruction)) {",
          "content_same": false
        },
        {
          "line": 3251,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "operand->opcode()",
          "old_line_content": "void MemorySpaceAssignment::ScheduleAsynchronousCopies() {",
          "new_line_content": "    CHECK((operand->opcode() != HloOpcode::kCopyStart &&",
          "content_same": false
        },
        {
          "line": 3253,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "inserted_instructions->contains(operand)",
          "old_line_content": "  for (MemorySpace memory_space :",
          "new_line_content": "          inserted_instructions->contains(operand))",
          "content_same": false
        },
        {
          "line": 3254,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "new_instruction->ToString()",
          "old_line_content": "       {MemorySpace::kDefault, MemorySpace::kAlternate}) {",
          "new_line_content": "        << \"Inserted instruction \" << new_instruction->ToString()",
          "content_same": false
        },
        {
          "line": 3255,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "operand->ToString()",
          "old_line_content": "    std::vector<CopyAllocation*> copy_allocations;",
          "new_line_content": "        << \" has un-inserted dependency: \" << operand->ToString();",
          "content_same": false
        },
        {
          "line": 3256,
          "old_api": null,
          "new_api": "EnsureInstructionAndOperandsInserted",
          "old_text": null,
          "new_text": "EnsureInstructionAndOperandsInserted(operand, new_sequence,\n                                         inserted_instructions)",
          "old_line_content": "    for (auto& allocation : allocations_) {",
          "new_line_content": "    EnsureInstructionAndOperandsInserted(operand, new_sequence,",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "position.ToString()",
          "old_line_content": "        !options_.allocate_across_sequential_calls) {",
          "new_line_content": "          VLOG(4) << \"Coloring \" << position.ToString();",
          "content_same": false
        },
        {
          "line": 1213,
          "old_api": null,
          "new_api": "mutable_shape",
          "old_text": null,
          "new_text": "position.instruction->mutable_shape()",
          "old_line_content": "              << \" because it aliases with another interval and \"",
          "new_line_content": "              position.instruction->mutable_shape(), position.index);",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": null,
          "new_api": "IsArray",
          "old_text": null,
          "new_text": "shape->IsArray()",
          "old_line_content": "              << \" allocate_across_sequential_calls is false.\";",
          "new_line_content": "          CHECK(shape->IsArray()) << \"Coloring a shape that is not an array: \"",
          "content_same": false
        },
        {
          "line": 1215,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "position.ToString()",
          "old_line_content": "      continue;",
          "new_line_content": "                                  << position.ToString();",
          "content_same": false
        },
        {
          "line": 1216,
          "old_api": null,
          "new_api": "mutable_layout",
          "old_text": null,
          "new_text": "shape->mutable_layout()->set_memory_space(\n              options_.alternate_memory_space)",
          "old_line_content": "    }",
          "new_line_content": "          shape->mutable_layout()->set_memory_space(",
          "content_same": false
        },
        {
          "line": 3261,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "inserted_instructions->insert(new_instruction)",
          "old_line_content": "        }",
          "new_line_content": "  inserted_instructions->insert(new_instruction);",
          "content_same": false
        },
        {
          "line": 1223,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "colocated_intervals.size()",
          "old_line_content": "    }",
          "new_line_content": "    if (colocated_intervals.size() > 1 &&",
          "content_same": false
        },
        {
          "line": 3271,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "allocation.get()",
          "old_line_content": "        });",
          "new_line_content": "        auto copy_allocation = static_cast<CopyAllocation*>(allocation.get());",
          "content_same": false
        },
        {
          "line": 3272,
          "old_api": null,
          "new_api": "memory_space",
          "old_text": null,
          "new_text": "copy_allocation->memory_space()",
          "old_line_content": "",
          "new_line_content": "        if (copy_allocation->memory_space() == memory_space) {",
          "content_same": false
        },
        {
          "line": 3273,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "copy_allocations.push_back(copy_allocation)",
          "old_line_content": "    CopyAllocation* prev_copy_allocation = nullptr;",
          "new_line_content": "          copy_allocations.push_back(copy_allocation);",
          "content_same": false
        },
        {
          "line": 1231,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "ConsumeFuel(\"memory_space_assignment\", [&] {\n          return absl::StrCat(\"Ran out of fuel at buffer: \",\n                              colocated_intervals[0]->buffer->ToShortString());\n        })",
          "old_line_content": "    // Retry allocating this value with larger limits if allocation fails.",
          "new_line_content": "    if (!ConsumeFuel(\"memory_space_assignment\", [&] {",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "absl::StrCat(\"Ran out of fuel at buffer: \",\n                              colocated_intervals[0]->buffer->ToShortString())",
          "old_line_content": "    bool repacked = false;",
          "new_line_content": "          return absl::StrCat(\"Ran out of fuel at buffer: \",",
          "content_same": false
        },
        {
          "line": 1233,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "colocated_intervals[0]->buffer->ToShortString()",
          "old_line_content": "    for (int retry_number = 0; retry_number < options_.max_retries;",
          "new_line_content": "                              colocated_intervals[0]->buffer->ToShortString());",
          "content_same": false
        },
        {
          "line": 3280,
          "old_api": null,
          "new_api": "copy_done_schedule_before",
          "old_text": null,
          "new_text": "first->copy_done_schedule_before()",
          "old_line_content": "      // nullptr is safe because this method is called before SimplifyGraph.",
          "new_line_content": "          return std::forward_as_tuple(first->copy_done_schedule_before(),",
          "content_same": false
        },
        {
          "line": 1238,
          "old_api": null,
          "new_api": "AppendBufferInfoDebugString",
          "old_text": null,
          "new_text": "AppendBufferInfoDebugString(interval, &buffer_info_str_)",
          "old_line_content": "      Result result =",
          "new_line_content": "    AppendBufferInfoDebugString(interval, &buffer_info_str_);",
          "content_same": false
        },
        {
          "line": 3295,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "flattened_instructions_[copy_start_schedule_after]->parent()",
          "old_line_content": "      prev_copy_allocation = copy_allocation;",
          "new_line_content": "             flattened_instructions_[copy_start_schedule_after]->parent()) {",
          "content_same": false
        },
        {
          "line": 1248,
          "old_api": null,
          "new_api": "AddRequiredAssignmentsForColocatedIntervals",
          "old_text": null,
          "new_text": "AddRequiredAssignmentsForColocatedIntervals(colocated_intervals)",
          "old_line_content": "                 num_repacks_ < options_.max_repacks && !repacked) {",
          "new_line_content": "      AddRequiredAssignmentsForColocatedIntervals(colocated_intervals);",
          "content_same": false
        },
        {
          "line": 3296,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "    }",
          "new_line_content": "        VLOG(4) << \"Delaying CopyStart (\" << copy_start_schedule_after << \" to \"",
          "content_same": false
        },
        {
          "line": 1250,
          "old_api": null,
          "new_api": "SetRetryNumber",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->SetRetryNumber(retry_number)",
          "old_line_content": "        ++num_repacks_;",
          "new_line_content": "      options_.prefetch_interval_picker->SetRetryNumber(retry_number);",
          "content_same": false
        },
        {
          "line": 3298,
          "old_api": null,
          "new_api": "copy_start",
          "old_text": null,
          "new_text": "copy_allocation->copy_start()->ToString()",
          "old_line_content": "}",
          "new_line_content": "                << copy_allocation->copy_start()->ToString()",
          "content_same": false
        },
        {
          "line": 3300,
          "old_api": null,
          "new_api": "set_copy_start_schedule_after",
          "old_text": null,
          "new_text": "copy_allocation->set_copy_start_schedule_after(\n            ++copy_start_schedule_after)",
          "old_line_content": "Status MemorySpaceAssignment::FixSchedule() {",
          "new_line_content": "        copy_allocation->set_copy_start_schedule_after(",
          "content_same": false
        },
        {
          "line": 1253,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(2)",
          "old_line_content": "        std::vector<MemorySpaceAssignmentRepacker::AllocationBlock*>",
          "new_line_content": "      VLOG(2) << \"Allocation result = \"",
          "content_same": false
        },
        {
          "line": 1254,
          "old_api": null,
          "new_api": "static_cast<int>(result)",
          "old_text": null,
          "new_text": "static_cast<int>(result)",
          "old_line_content": "            repack_allocation_blocks;",
          "new_line_content": "              << absl::StrFormat(\"%x\", static_cast<int>(result));",
          "content_same": false
        },
        {
          "line": 3304,
          "old_api": null,
          "new_api": "copy_start_schedule_after",
          "old_text": null,
          "new_text": "copy_allocation->copy_start_schedule_after()",
          "old_line_content": "  for (const HloComputation* computation :",
          "new_line_content": "      schedule_after_[copy_allocation->copy_start_schedule_after()].push_back(",
          "content_same": false
        },
        {
          "line": 1257,
          "old_api": null,
          "new_api": "absl::MakeSpan(allocation_values)",
          "old_text": null,
          "new_text": "absl::MakeSpan(allocation_values)",
          "old_line_content": "        auto repack_status =",
          "new_line_content": "        UncommitPendingChunks(absl::MakeSpan(allocation_values));",
          "content_same": false
        },
        {
          "line": 3306,
          "old_api": null,
          "new_api": "copy_done_schedule_before",
          "old_text": null,
          "new_text": "copy_allocation->copy_done_schedule_before()",
          "old_line_content": "    // Parallel computations aren't in the schedule and don't need to be",
          "new_line_content": "      schedule_before_[copy_allocation->copy_done_schedule_before()].push_back(",
          "content_same": false
        },
        {
          "line": 3307,
          "old_api": null,
          "new_api": "copy_done",
          "old_text": null,
          "new_text": "copy_allocation->copy_done()",
          "old_line_content": "    // modified.",
          "new_line_content": "          copy_allocation->copy_done());",
          "content_same": false
        },
        {
          "line": 1265,
          "old_api": null,
          "new_api": "CHECK_NE",
          "old_text": null,
          "new_text": "CHECK_NE(options_.repacker, nullptr)",
          "old_line_content": "      } else {",
          "new_line_content": "        CHECK_NE(options_.repacker, nullptr);",
          "content_same": false
        },
        {
          "line": 3314,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "    HloInstructionSequence new_sequence;",
          "new_line_content": "  VLOG(1) << \"Fixing schedule...\";",
          "content_same": false
        },
        {
          "line": 3315,
          "old_api": null,
          "new_api": "has_schedule",
          "old_text": null,
          "new_text": "module_->has_schedule()",
          "old_line_content": "",
          "new_line_content": "  CHECK(module_->has_schedule());",
          "content_same": false
        },
        {
          "line": 1268,
          "old_api": null,
          "new_api": "ExportAllocationsForRepacking",
          "old_text": null,
          "new_text": "ExportAllocationsForRepacking(repack_allocation_blocks)",
          "old_line_content": "      }",
          "new_line_content": "        ExportAllocationsForRepacking(repack_allocation_blocks);",
          "content_same": false
        },
        {
          "line": 1269,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(2)",
          "old_line_content": "    }",
          "new_line_content": "        VLOG(2) << \"Repacking.\";",
          "content_same": false
        },
        {
          "line": 3316,
          "old_api": null,
          "new_api": "schedule",
          "old_text": null,
          "new_text": "module_->schedule()",
          "old_line_content": "    absl::flat_hash_set<HloInstruction*> inserted_instructions;",
          "new_line_content": "  HloSchedule& schedule = module_->schedule();",
          "content_same": false
        },
        {
          "line": 1271,
          "old_api": null,
          "new_api": "absl::MakeSpan(repack_allocation_blocks)",
          "old_text": null,
          "new_text": "absl::MakeSpan(repack_allocation_blocks)",
          "old_line_content": "",
          "new_line_content": "            options_.repacker->Repack(absl::MakeSpan(repack_allocation_blocks));",
          "content_same": false
        },
        {
          "line": 3322,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "computation->name()",
          "old_line_content": "         ++instruction_index) {",
          "new_line_content": "      VLOG(4) << \"Not scheduling \" << computation->name()",
          "content_same": false
        },
        {
          "line": 1279,
          "old_api": null,
          "new_api": "absl::MakeSpan(allocation_values)",
          "old_text": null,
          "new_text": "absl::MakeSpan(allocation_values)",
          "old_line_content": "  result.heap_size = result_.heap_size;",
          "new_line_content": "        FinalizeAllocations(absl::MakeSpan(allocation_values));",
          "content_same": false
        },
        {
          "line": 3331,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "computation->ToString()",
          "old_line_content": "          }",
          "new_line_content": "    VLOG(4) << \"Scheduling: \" << computation->ToString();",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "    absl::Span<const AlternateMemoryBestFitHeap::BufferInterval* const>",
          "new_line_content": "  VLOG(3) << \"Debug buffer info: \";",
          "content_same": false
        },
        {
          "line": 1286,
          "old_api": null,
          "new_api": "XLA_VLOG_LINES",
          "old_text": null,
          "new_text": "XLA_VLOG_LINES(3, buffer_info_str_)",
          "old_line_content": "        colocated_intervals) {",
          "new_line_content": "  XLA_VLOG_LINES(3, buffer_info_str_);",
          "content_same": false
        },
        {
          "line": 1287,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "  // TODO(berkin): For now, place the phi values due to conditionals in",
          "new_line_content": "  VLOG(3) << \"Debug allocation info: \";",
          "content_same": false
        },
        {
          "line": 1288,
          "old_api": null,
          "new_api": "XLA_VLOG_LINES",
          "old_text": null,
          "new_text": "XLA_VLOG_LINES(3, allocation_info_str_)",
          "old_line_content": "  // default memory.",
          "new_line_content": "  XLA_VLOG_LINES(3, allocation_info_str_);",
          "content_same": false
        },
        {
          "line": 1289,
          "old_api": null,
          "new_api": "DumpDebugStringsIfEnabled",
          "old_text": null,
          "new_text": "DumpDebugStringsIfEnabled()",
          "old_line_content": "  for (const BufferInterval* colocated_interval : colocated_intervals) {",
          "new_line_content": "  DumpDebugStringsIfEnabled();",
          "content_same": false
        },
        {
          "line": 3334,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "flattened_instructions_.size()",
          "old_line_content": "      HloInstruction* instruction = flattened_instructions_[instruction_index];",
          "new_line_content": "         instruction_index < flattened_instructions_.size();",
          "content_same": false
        },
        {
          "line": 3336,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "schedule_before_.find(instruction_index)",
          "old_line_content": "      // it was deleted) and not previously inserted. Also bitcasts and tuples",
          "new_line_content": "      auto insts_before_iter = schedule_before_.find(instruction_index);",
          "content_same": false
        },
        {
          "line": 3337,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "schedule_before_.end()",
          "old_line_content": "      // are treated specially and only inserted as a result of operand",
          "new_line_content": "      if (insts_before_iter != schedule_before_.end()) {",
          "content_same": false
        },
        {
          "line": 3339,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "new_instruction->parent()",
          "old_line_content": "      if (instruction != nullptr &&",
          "new_line_content": "          if (new_instruction->parent() == computation) {",
          "content_same": false
        },
        {
          "line": 1304,
          "old_api": null,
          "new_api": "positions",
          "old_text": null,
          "new_text": "value->positions()",
          "old_line_content": "  }",
          "new_line_content": "    for (const auto& position : value->positions()) {",
          "content_same": false
        },
        {
          "line": 1305,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "position.instruction->opcode()",
          "old_line_content": "}",
          "new_line_content": "      if (position.instruction->opcode() == HloOpcode::kConditional) {",
          "content_same": false
        },
        {
          "line": 1306,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "",
          "new_line_content": "        VLOG(3) << \"Adding required assignment for condition output: \"",
          "content_same": false
        },
        {
          "line": 1307,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "value->ToShortString()",
          "old_line_content": "void AlternateMemoryBestFitHeap::CreateAllocationValuesFromColocatedIntervals(",
          "new_line_content": "                << value->ToShortString();",
          "content_same": false
        },
        {
          "line": 1308,
          "old_api": null,
          "new_api": "AddRequiredAssignment",
          "old_text": null,
          "new_text": "AddRequiredAssignment(position.instruction, position.index,\n                              MemorySpace::kDefault)",
          "old_line_content": "    absl::Span<const AlternateMemoryBestFitHeap::BufferInterval* const>",
          "new_line_content": "        AddRequiredAssignment(position.instruction, position.index,",
          "content_same": false
        },
        {
          "line": 3355,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "                                                 &inserted_instructions);",
          "new_line_content": "          instruction->opcode() != HloOpcode::kBitcast &&",
          "content_same": false
        },
        {
          "line": 3356,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "          }",
          "new_line_content": "          instruction->opcode() != HloOpcode::kTuple) {",
          "content_same": false
        },
        {
          "line": 1311,
          "old_api": null,
          "new_api": "called_computations",
          "old_text": null,
          "new_text": "position.instruction->called_computations()",
          "old_line_content": "  // Create AllocationValues for all the colocated intervals.",
          "new_line_content": "             position.instruction->called_computations()) {",
          "content_same": false
        },
        {
          "line": 1312,
          "old_api": null,
          "new_api": "root_instruction",
          "old_text": null,
          "new_text": "called_computation->root_instruction()",
          "old_line_content": "  for (const auto& colocated_interval : colocated_intervals) {",
          "new_line_content": "          AddRequiredAssignment(called_computation->root_instruction(),",
          "content_same": false
        },
        {
          "line": 3357,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "instruction->name()",
          "old_line_content": "        }",
          "new_line_content": "        VLOG(4) << \"inst \" << instruction_index << \": \" << instruction->name();",
          "content_same": false
        },
        {
          "line": 3358,
          "old_api": null,
          "new_api": "EnsureInstructionAndOperandsInserted",
          "old_text": null,
          "new_text": "EnsureInstructionAndOperandsInserted(instruction, &new_sequence,\n                                             &inserted_instructions)",
          "old_line_content": "      }",
          "new_line_content": "        EnsureInstructionAndOperandsInserted(instruction, &new_sequence,",
          "content_same": false
        },
        {
          "line": 3361,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "schedule_after_.find(instruction_index)",
          "old_line_content": "    // instruction and its dependencies are scheduled.",
          "new_line_content": "      auto insts_after_iter = schedule_after_.find(instruction_index);",
          "content_same": false
        },
        {
          "line": 1326,
          "old_api": null,
          "new_api": "CreateAllocationValues",
          "old_text": null,
          "new_text": "CreateAllocationValues(*colocated_interval, allocation_values)",
          "old_line_content": "  std::vector<int64_t> all_use_times;",
          "new_line_content": "    CreateAllocationValues(*colocated_interval, allocation_values);",
          "content_same": false
        },
        {
          "line": 3381,
          "old_api": null,
          "new_api": "set_sequence",
          "old_text": null,
          "new_text": "schedule.set_sequence(computation, new_sequence)",
          "old_line_content": "",
          "new_line_content": "    schedule.set_sequence(computation, new_sequence);",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": null,
          "new_api": "instruction_schedule",
          "old_text": null,
          "new_text": "hlo_live_range_.instruction_schedule()",
          "old_line_content": "  // Data structure to contain the preferred offset for a given computation.",
          "new_line_content": "  const auto& instruction_schedule = hlo_live_range_.instruction_schedule();",
          "content_same": false
        },
        {
          "line": 3384,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "  // The key for events is: time, is_free, value_id. This is so that the events",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3388,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "           std::tuple<const HloValue*, Chunk, HeapSimulatorTrace::Event::Kind>>",
          "new_line_content": "  VLOG(1) << \"Verifying...\";",
          "content_same": false
        },
        {
          "line": 1341,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "allocation_value.uses()",
          "old_line_content": "  for (AllocationValue& allocation_value : allocation_values) {",
          "new_line_content": "    absl::c_transform(allocation_value.uses(),",
          "content_same": false
        },
        {
          "line": 1342,
          "old_api": null,
          "new_api": "std::back_inserter(all_use_times)",
          "old_text": null,
          "new_text": "std::back_inserter(all_use_times)",
          "old_line_content": "    int64 definition_time =",
          "new_line_content": "                      std::back_inserter(all_use_times),",
          "content_same": false
        },
        {
          "line": 3389,
          "old_api": null,
          "new_api": "TF_ASSIGN_OR_RETURN",
          "old_text": null,
          "new_text": "TF_ASSIGN_OR_RETURN(std::unique_ptr<HloAliasAnalysis> alias_analysis,\n                      HloAliasAnalysis::Run(module_))",
          "old_line_content": "      events;",
          "new_line_content": "  TF_ASSIGN_OR_RETURN(std::unique_ptr<HloAliasAnalysis> alias_analysis,",
          "content_same": false
        },
        {
          "line": 3390,
          "old_api": null,
          "new_api": "HloAliasAnalysis::Run(module_)",
          "old_text": null,
          "new_text": "HloAliasAnalysis::Run(module_)",
          "old_line_content": "",
          "new_line_content": "                      HloAliasAnalysis::Run(module_));",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": null,
          "new_api": "absl::c_sort(all_use_times)",
          "old_text": null,
          "new_text": "absl::c_sort(all_use_times)",
          "old_line_content": "    AliasedOffset* preferred_offset = nullptr;",
          "new_line_content": "  absl::c_sort(all_use_times);",
          "content_same": false
        },
        {
          "line": 3391,
          "old_api": null,
          "new_api": "schedule",
          "old_text": null,
          "new_text": "TF_ASSIGN_OR_RETURN(std::unique_ptr<HloLiveRange> hlo_live_range,\n                      HloLiveRange::Run(module_->schedule(), *alias_analysis,\n                                        module_->entry_computation()))",
          "old_line_content": "  auto add_allocation_and_verify = [&](int64 start_time, int64 end_time,",
          "new_line_content": "  TF_ASSIGN_OR_RETURN(std::unique_ptr<HloLiveRange> hlo_live_range,",
          "content_same": false
        },
        {
          "line": 3392,
          "old_api": null,
          "new_api": "schedule",
          "old_text": null,
          "new_text": "module_->schedule()",
          "old_line_content": "                                       const Chunk& chunk,",
          "new_line_content": "                      HloLiveRange::Run(module_->schedule(), *alias_analysis,",
          "content_same": false
        },
        {
          "line": 3393,
          "old_api": null,
          "new_api": "entry_computation",
          "old_text": null,
          "new_text": "module_->entry_computation()",
          "old_line_content": "                                       const HloValue* value) {",
          "new_line_content": "                                        module_->entry_computation()));",
          "content_same": false
        },
        {
          "line": 1360,
          "old_api": null,
          "new_api": "computation",
          "old_text": null,
          "new_text": "allocation_value.computation()",
          "old_line_content": "",
          "new_line_content": "        preferred_offset_for_computation.find(allocation_value.computation());",
          "content_same": false
        },
        {
          "line": 1361,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "preferred_offset_for_computation.end()",
          "old_line_content": "      // Sequential calls include kWhile, kCall, and kConditional opcodes.",
          "new_line_content": "    if (preferred_offset_it != preferred_offset_for_computation.end()) {",
          "content_same": false
        },
        {
          "line": 3409,
          "old_api": null,
          "new_api": "id",
          "old_text": null,
          "new_text": "value->id()",
          "old_line_content": "            (\"Value %s (%d, %d) off: %d size: %d overlaps with another chunk\"",
          "new_line_content": "    events[std::make_tuple(end_time, /*is_free=*/true, value->id())] =",
          "content_same": false
        },
        {
          "line": 3410,
          "old_api": null,
          "new_api": "std::make_tuple(value, chunk, HeapSimulatorTrace::Event::FREE)",
          "old_text": null,
          "new_text": "std::make_tuple(value, chunk, HeapSimulatorTrace::Event::FREE)",
          "old_line_content": "             \" off: %d size: %d\"),",
          "new_line_content": "        std::make_tuple(value, chunk, HeapSimulatorTrace::Event::FREE);",
          "content_same": false
        },
        {
          "line": 1366,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "allocation_value.uses().size()",
          "old_line_content": "        for (const HloComputation* called_computation :",
          "new_line_content": "    for (int use_idx = 0; use_idx < allocation_value.uses().size(); ++use_idx) {",
          "content_same": false
        },
        {
          "line": 3419,
          "old_api": null,
          "new_api": "ChunksOverlappingInTime",
          "old_text": null,
          "new_text": "interval_tree.ChunksOverlappingInTime(start_time, end_time - 1)",
          "old_line_content": "  // Go through all instructions in the module to ensure CopyStart/CopyDone",
          "new_line_content": "         interval_tree.ChunksOverlappingInTime(start_time, end_time - 1)) {",
          "content_same": false
        },
        {
          "line": 3420,
          "old_api": null,
          "new_api": "OverlapsWith",
          "old_text": null,
          "new_text": "chunk.OverlapsWith(overlapping_chunk)",
          "old_line_content": "  // instructions copy between alternate memory and default memory.",
          "new_line_content": "      if (chunk.OverlapsWith(overlapping_chunk)) {",
          "content_same": false
        },
        {
          "line": 3421,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "InternalError(\n            (\"Value %s (%d, %d) off: %d size: %d overlaps with another chunk\"\n             \" off: %d size: %d\"),\n            value->ToShortString(), start_time, end_time, chunk.offset,\n            chunk.size, overlapping_chunk.offset, overlapping_chunk.size)",
          "old_line_content": "  for (const HloComputation* computation :",
          "new_line_content": "        return InternalError(",
          "content_same": false
        },
        {
          "line": 1376,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "hlo_use.instruction->opcode()",
          "old_line_content": "          //",
          "new_line_content": "          (GetInstructionCallContext(hlo_use.instruction->opcode()) ==",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": null,
          "new_api": "called_computations",
          "old_text": null,
          "new_text": "hlo_use.instruction->called_computations()",
          "old_line_content": "          // 2:   p = param(0)",
          "new_line_content": "             hlo_use.instruction->called_computations()) {",
          "content_same": false
        },
        {
          "line": 3428,
          "old_api": null,
          "new_api": "Add",
          "old_text": null,
          "new_text": "interval_tree.Add(start_time, end_time - 1, chunk)",
          "old_line_content": "                .memory_space();",
          "new_line_content": "    interval_tree.Add(start_time, end_time - 1, chunk);",
          "content_same": false
        },
        {
          "line": 1382,
          "old_api": null,
          "new_api": "computation_span_times",
          "old_text": null,
          "new_text": "hlo_live_range_.computation_span_times().at(called_computation)",
          "old_line_content": "          //     }",
          "new_line_content": "              hlo_live_range_.computation_span_times().at(called_computation);",
          "content_same": false
        },
        {
          "line": 3429,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "        int64 to_memory_space =",
          "new_line_content": "    return Status::OK();",
          "content_same": false
        },
        {
          "line": 1384,
          "old_api": null,
          "new_api": "std::min(computation_span.start - 1, latest_prefetch_time)",
          "old_text": null,
          "new_text": "std::min(computation_span.start - 1, latest_prefetch_time)",
          "old_line_content": "          // 4:   p = param(0)",
          "new_line_content": "              std::min(computation_span.start - 1, latest_prefetch_time);",
          "content_same": false
        },
        {
          "line": 1386,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "hlo_use.instruction->opcode()",
          "old_line_content": "          // 6:   ROOT ...",
          "new_line_content": "        if (hlo_use.instruction->opcode() == HloOpcode::kWhile) {",
          "content_same": false
        },
        {
          "line": 3436,
          "old_api": null,
          "new_api": "instructions",
          "old_text": null,
          "new_text": "computation->instructions()",
          "old_line_content": "      }",
          "new_line_content": "    for (const HloInstruction* instruction : computation->instructions()) {",
          "content_same": false
        },
        {
          "line": 3437,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "    }",
          "new_line_content": "      if (instruction->opcode() == HloOpcode::kCopyStart) {",
          "content_same": false
        },
        {
          "line": 3439,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "instruction->shape()",
          "old_line_content": "",
          "new_line_content": "            ShapeUtil::GetSubshape(instruction->shape(), {1})",
          "content_same": false
        },
        {
          "line": 3443,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "instruction->shape()",
          "old_line_content": "    const HloBuffer& buffer =",
          "new_line_content": "            ShapeUtil::GetSubshape(instruction->shape(), {0})",
          "content_same": false
        },
        {
          "line": 3446,
          "old_api": null,
          "new_api": "CHECK_NE",
          "old_text": null,
          "new_text": "CHECK_NE(from_memory_space, to_memory_space)",
          "old_line_content": "        << \"Multiple preset assignments for the same buffer: \"",
          "new_line_content": "        CHECK_NE(from_memory_space, to_memory_space)",
          "content_same": false
        },
        {
          "line": 3448,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "instruction->ToString()",
          "old_line_content": "        << \", off: \" << chunk.offset << \", size: \" << chunk.size;",
          "new_line_content": "            << instruction->ToString();",
          "content_same": false
        },
        {
          "line": 1407,
          "old_api": null,
          "new_api": "while_body",
          "old_text": null,
          "new_text": "hlo_use.instruction->while_body()",
          "old_line_content": "          // computations.",
          "new_line_content": "          HloComputation* while_body = hlo_use.instruction->while_body();",
          "content_same": false
        },
        {
          "line": 3457,
          "old_api": null,
          "new_api": "GetUniqueBufferAt",
          "old_text": null,
          "new_text": "alias_analysis->GetUniqueBufferAt(position.instruction, position.index)",
          "old_line_content": "        int64 use_time =",
          "new_line_content": "        alias_analysis->GetUniqueBufferAt(position.instruction, position.index);",
          "content_same": false
        },
        {
          "line": 3460,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "position.ToString()",
          "old_line_content": "          last_use_time = use_time;",
          "new_line_content": "        << buffer.ToString() << \", pos: \" << position.ToString()",
          "content_same": false
        },
        {
          "line": 3462,
          "old_api": null,
          "new_api": "id",
          "old_text": null,
          "new_text": "buffer.id()",
          "old_line_content": "        }",
          "new_line_content": "    seen_buffers.insert(buffer.id());",
          "content_same": false
        },
        {
          "line": 3464,
          "old_api": null,
          "new_api": "values",
          "old_text": null,
          "new_text": "buffer.values()",
          "old_line_content": "",
          "new_line_content": "    for (const HloValue* value : buffer.values()) {",
          "content_same": false
        },
        {
          "line": 1417,
          "old_api": null,
          "new_api": "parameter_instruction",
          "old_text": null,
          "new_text": "while_body->parameter_instruction(0)",
          "old_line_content": "      // Add a required assignment in default memory if the use not allowed in",
          "new_line_content": "              instruction_schedule.at(while_body->parameter_instruction(0));",
          "content_same": false
        },
        {
          "line": 1418,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "hlo_use.instruction->opcode()",
          "old_line_content": "      // alternate memory.",
          "new_line_content": "        } else if (hlo_use.instruction->opcode() == HloOpcode::kConditional) {",
          "content_same": false
        },
        {
          "line": 3466,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "hlo_live_range->buffer_live_ranges().at(value)",
          "old_line_content": "                           absl::string_view)>",
          "new_line_content": "          hlo_live_range->buffer_live_ranges().at(value);",
          "content_same": false
        },
        {
          "line": 3469,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "value->uses()",
          "old_line_content": "                                     int64 start_time, int64 end_time,",
          "new_line_content": "      for (const HloUse& use : value->uses()) {",
          "content_same": false
        },
        {
          "line": 1422,
          "old_api": null,
          "new_api": "called_computations",
          "old_text": null,
          "new_text": "hlo_use.instruction->called_computations()",
          "old_line_content": "      } else if (use_idx > 0) {",
          "new_line_content": "               hlo_use.instruction->called_computations()) {",
          "content_same": false
        },
        {
          "line": 1423,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "std::min(\n                use_time, instruction_schedule.at(\n                              called_computation->parameter_instruction(0)))",
          "old_line_content": "        // We allow buffers in alternate memory that are passed into",
          "new_line_content": "            use_time = std::min(",
          "content_same": false
        },
        {
          "line": 1424,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "instruction_schedule.at(\n                              called_computation->parameter_instruction(0))",
          "old_line_content": "        // conditionals to give up their alternate memory allocation inside the",
          "new_line_content": "                use_time, instruction_schedule.at(",
          "content_same": false
        },
        {
          "line": 1425,
          "old_api": null,
          "new_api": "parameter_instruction",
          "old_text": null,
          "new_text": "called_computation->parameter_instruction(0)",
          "old_line_content": "        // called computation. This means that if a conditional operator has an",
          "new_line_content": "                              called_computation->parameter_instruction(0)));",
          "content_same": false
        },
        {
          "line": 3471,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "hlo_live_range->instruction_schedule().at(use.instruction)",
          "old_line_content": "        // Special case when verifying conditional: we internally split the use",
          "new_line_content": "            hlo_live_range->instruction_schedule().at(use.instruction);",
          "content_same": false
        },
        {
          "line": 1432,
          "old_api": null,
          "new_api": "IsUseAllowedInAlternateMemory",
          "old_text": null,
          "new_text": "IsUseAllowedInAlternateMemory(allocation_value, hlo_use)",
          "old_line_content": "                HloOpcode::kConditional &&",
          "new_line_content": "      if (!IsUseAllowedInAlternateMemory(allocation_value, hlo_use)) {",
          "content_same": false
        },
        {
          "line": 1433,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "allocation_value.value()",
          "old_line_content": "            previous_use.hlo_use.instruction != hlo_use.instruction) {",
          "new_line_content": "        AddRequiredAssignment(allocation_value.value(), hlo_use.instruction,",
          "content_same": false
        },
        {
          "line": 3487,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "          int64 parameter_time = -1;",
          "new_line_content": "        VLOG(3) << indent_string",
          "content_same": false
        },
        {
          "line": 3488,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "buffer.ToString()",
          "old_line_content": "          int64 last_use_time = -1;",
          "new_line_content": "                << \"Splitting conditional buffer: \" << buffer.ToString()",
          "content_same": false
        },
        {
          "line": 3489,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "value->ToShortString()",
          "old_line_content": "          const HloInstruction* last_use_instruction = nullptr;",
          "new_line_content": "                << \" value: \" << value->ToShortString() << \": (\" << start_time",
          "content_same": false
        },
        {
          "line": 1443,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "allocation_value.uses().at(use_idx - 1)",
          "old_line_content": "",
          "new_line_content": "            allocation_value.uses().at(use_idx - 1);",
          "content_same": false
        },
        {
          "line": 1444,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "previous_use.hlo_use.instruction->opcode()",
          "old_line_content": "      // Bitcasts don't define buffers and don't directly consume buffers. Skip",
          "new_line_content": "        if (previous_use.hlo_use.instruction->opcode() ==",
          "content_same": false
        },
        {
          "line": 3494,
          "old_api": null,
          "new_api": "called_computations",
          "old_text": null,
          "new_text": "use_instruction->called_computations()",
          "old_line_content": "                  position.instruction);",
          "new_line_content": "             use_instruction->called_computations()) {",
          "content_same": false
        },
        {
          "line": 3496,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "std::min(earliest_computation_start_time,\n                       hlo_live_range->computation_span_times()\n                           .at(called_computation)\n                           .start)",
          "old_line_content": "            }",
          "new_line_content": "              std::min(earliest_computation_start_time,",
          "content_same": false
        },
        {
          "line": 1449,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "instruction_schedule.at(previous_use.hlo_use.instruction)",
          "old_line_content": "          hlo_use.instruction ==",
          "new_line_content": "              instruction_schedule.at(previous_use.hlo_use.instruction);",
          "content_same": false
        },
        {
          "line": 3497,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "hlo_live_range->computation_span_times()\n                           .at(called_computation)",
          "old_line_content": "          }",
          "new_line_content": "                       hlo_live_range->computation_span_times()",
          "content_same": false
        },
        {
          "line": 1451,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "hlo_use.ToString()",
          "old_line_content": "        AllocationRequest request;",
          "new_line_content": "                  << \") of use (\" << hlo_use.ToString()",
          "content_same": false
        },
        {
          "line": 3503,
          "old_api": null,
          "new_api": "positions",
          "old_text": null,
          "new_text": "value->positions()",
          "old_line_content": "              last_use_time = use_time;",
          "new_line_content": "          for (const HloPosition& position : value->positions()) {",
          "content_same": false
        },
        {
          "line": 3504,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "position.instruction->opcode()",
          "old_line_content": "              last_use_instruction = use.instruction;",
          "new_line_content": "            if (position.instruction->opcode() == HloOpcode::kParameter &&",
          "content_same": false
        },
        {
          "line": 3505,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "position.instruction->parent()",
          "old_line_content": "            }",
          "new_line_content": "                position.instruction->parent() == called_computation) {",
          "content_same": false
        },
        {
          "line": 3506,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "hlo_live_range->instruction_schedule().at(\n                  position.instruction)",
          "old_line_content": "          }",
          "new_line_content": "              parameter_time = hlo_live_range->instruction_schedule().at(",
          "content_same": false
        },
        {
          "line": 1461,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "hlo_use.instruction->opcode()",
          "old_line_content": "        request.earliest_prefetch_time = earliest_prefetch_time;",
          "new_line_content": "      if (hlo_use.instruction->opcode() != HloOpcode::kBitcast ||",
          "content_same": false
        },
        {
          "line": 1463,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "hlo_use.instruction->parent()->root_instruction()",
          "old_line_content": "        request.use = &use;",
          "new_line_content": "              hlo_use.instruction->parent()->root_instruction()) {",
          "content_same": false
        },
        {
          "line": 3511,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "value->uses()",
          "old_line_content": "                    << parameter_time << \", \" << last_use_time << \")\";",
          "new_line_content": "          for (const HloUse& use : value->uses()) {",
          "content_same": false
        },
        {
          "line": 3514,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "use.instruction->parent()",
          "old_line_content": "              // The last use is another (nested) conditional. Call this",
          "new_line_content": "            if (use.instruction->parent() == called_computation &&",
          "content_same": false
        },
        {
          "line": 1468,
          "old_api": null,
          "new_api": "std::min(definition_time, use_time)",
          "old_text": null,
          "new_text": "std::min(definition_time, use_time)",
          "old_line_content": "          // If the allocation finding failed (e.g., due to running out of",
          "new_line_content": "        request.start_time = std::min(definition_time, use_time);",
          "content_same": false
        },
        {
          "line": 1471,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "allocation_value.size()",
          "old_line_content": "          return result;",
          "new_line_content": "        request.size = allocation_value.size();",
          "content_same": false
        },
        {
          "line": 3522,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "                  parameter_time, last_use_time, chunk, value));",
          "new_line_content": "            VLOG(3) << indent_string",
          "content_same": false
        },
        {
          "line": 3523,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "called_computation->name()",
          "old_line_content": "            }",
          "new_line_content": "                    << \" computation: \" << called_computation->name() << \": (\"",
          "content_same": false
        },
        {
          "line": 3525,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(last_use_instruction)",
          "old_line_content": "        }",
          "new_line_content": "            CHECK(last_use_instruction);",
          "content_same": false
        },
        {
          "line": 1479,
          "old_api": null,
          "new_api": "AllocateSegment",
          "old_text": null,
          "new_text": "AllocateSegment(request)",
          "old_line_content": "      // Propagate the allocation to any aliases this use might have had.",
          "new_line_content": "        result_mark(AllocateSegment(request), result);",
          "content_same": false
        },
        {
          "line": 1480,
          "old_api": null,
          "new_api": "result_requires_uncommit",
          "old_text": null,
          "new_text": "result_requires_uncommit(result)",
          "old_line_content": "      MemorySpaceAssignment::Allocation* aliased_allocation =",
          "new_line_content": "        if (result_requires_uncommit(result)) {",
          "content_same": false
        },
        {
          "line": 3533,
          "old_api": null,
          "new_api": "std::min(last_use_time, end_time)",
          "old_text": null,
          "new_text": "std::min(last_use_time, end_time)",
          "old_line_content": "",
          "new_line_content": "              last_use_time = std::min(last_use_time, end_time);",
          "content_same": false
        },
        {
          "line": 3534,
          "old_api": null,
          "new_api": "add_allocation_and_verify",
          "old_text": null,
          "new_text": "add_allocation_and_verify(\n                  parameter_time, last_use_time, chunk, value)",
          "old_line_content": "      if (last_use_instruction &&",
          "new_line_content": "              TF_RETURN_IF_ERROR(add_allocation_and_verify(",
          "content_same": false
        },
        {
          "line": 1489,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "instruction_schedule.at(hlo_use.instruction)",
          "old_line_content": "      // Special case for while loops since the root offset must agree with",
          "new_line_content": "        definition_time = instruction_schedule.at(hlo_use.instruction);",
          "content_same": false
        },
        {
          "line": 3542,
          "old_api": null,
          "new_api": "add_allocation_and_verify",
          "old_text": null,
          "new_text": "add_allocation_and_verify(\n            start_time, earliest_computation_start_time - 1, chunk, value)",
          "old_line_content": "                << time_bound.start << \", \" << last_use_time",
          "new_line_content": "        TF_RETURN_IF_ERROR(add_allocation_and_verify(",
          "content_same": false
        },
        {
          "line": 1497,
          "old_api": null,
          "new_api": "AddAliasedRequiredAssignment",
          "old_text": null,
          "new_text": "AddAliasedRequiredAssignment(aliased_position.instruction,\n                                     aliased_position.index,\n                                     aliased_allocation)",
          "old_line_content": "  }",
          "new_line_content": "        AddAliasedRequiredAssignment(aliased_position.instruction,",
          "content_same": false
        },
        {
          "line": 3548,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "last_use_instruction->opcode()",
          "old_line_content": "  }",
          "new_line_content": "          last_use_instruction->opcode() == HloOpcode::kConditional) {",
          "content_same": false
        },
        {
          "line": 3549,
          "old_api": null,
          "new_api": "split_conditional_buffer",
          "old_text": null,
          "new_text": "split_conditional_buffer(\n            last_use_instruction, time_bound.start, time_bound.end, \" \")",
          "old_line_content": "",
          "new_line_content": "        TF_RETURN_IF_ERROR(split_conditional_buffer(",
          "content_same": false
        },
        {
          "line": 1504,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "hlo_use.instruction->opcode()",
          "old_line_content": "}",
          "new_line_content": "      if (hlo_use.instruction->opcode() == HloOpcode::kWhile &&",
          "content_same": false
        },
        {
          "line": 1505,
          "old_api": null,
          "new_api": "memory_space",
          "old_text": null,
          "new_text": "aliased_allocation->memory_space()",
          "old_line_content": "",
          "new_line_content": "          aliased_allocation->memory_space() == MemorySpace::kAlternate) {",
          "content_same": false
        },
        {
          "line": 1506,
          "old_api": null,
          "new_api": "while_body",
          "old_text": null,
          "new_text": "hlo_use.instruction->while_body()",
          "old_line_content": "void AsynchronousCopyOrdering::AddCopy(const AsynchronousCopy& copy) {",
          "new_line_content": "        preferred_offset_for_computation[hlo_use.instruction->while_body()] =",
          "content_same": false
        },
        {
          "line": 3552,
          "old_api": null,
          "new_api": "std::min(last_use_time, time_bound.end)",
          "old_text": null,
          "new_text": "std::min(last_use_time, time_bound.end)",
          "old_line_content": "           ->assignment_information_for_space(options_.alternate_memory_space)",
          "new_line_content": "        last_use_time = std::min(last_use_time, time_bound.end);",
          "content_same": false
        },
        {
          "line": 3553,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "buffer.ToString()",
          "old_line_content": "           ->heap_simulator_trace;",
          "new_line_content": "        VLOG(3) << \" buffer: \" << buffer.ToString()",
          "content_same": false
        },
        {
          "line": 3554,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "value->ToShortString()",
          "old_line_content": "  int64 memory_usage = 0;",
          "new_line_content": "                << \" value: \" << value->ToShortString() << \": (\"",
          "content_same": false
        },
        {
          "line": 3557,
          "old_api": null,
          "new_api": "add_allocation_and_verify",
          "old_text": null,
          "new_text": "add_allocation_and_verify(\n            time_bound.start, last_use_time, chunk, value)",
          "old_line_content": "    int64 time;",
          "new_line_content": "        TF_RETURN_IF_ERROR(add_allocation_and_verify(",
          "content_same": false
        },
        {
          "line": 1520,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "ranges_.insert(copy)",
          "old_line_content": "  // We allow identical start and end times. It is enough to check for just the",
          "new_line_content": "  auto it_and_inserted = ranges_.insert(copy);",
          "content_same": false
        },
        {
          "line": 1521,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(it_and_inserted.second ||\n        it_and_inserted.first->start_time == copy.start_time)",
          "old_line_content": "  // start time in case we find a match in ranges_ because the found value will",
          "new_line_content": "  CHECK(it_and_inserted.second ||",
          "content_same": false
        },
        {
          "line": 3573,
          "old_api": null,
          "new_api": "std::tie(time, is_free, buffer_id)",
          "old_text": null,
          "new_text": "std::tie(time, is_free, buffer_id)",
          "old_line_content": "      memory_usage += chunk.size;",
          "new_line_content": "    std::tie(time, is_free, buffer_id) = event.first;",
          "content_same": false
        },
        {
          "line": 1528,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "ranges_.erase(copy_it)",
          "old_line_content": "            << \") and (\" << copy_it->start_time << \", \" << copy_it->end_time",
          "new_line_content": "  ranges_.erase(copy_it);",
          "content_same": false
        },
        {
          "line": 3577,
          "old_api": null,
          "new_api": "std::tie(value, chunk, kind)",
          "old_text": null,
          "new_text": "std::tie(value, chunk, kind)",
          "old_line_content": "    }",
          "new_line_content": "    std::tie(value, chunk, kind) = event.second;",
          "content_same": false
        },
        {
          "line": 3580,
          "old_api": null,
          "new_api": "set_buffer_id",
          "old_text": null,
          "new_text": "heap_trace_event->set_buffer_id(buffer_id)",
          "old_line_content": "  }",
          "new_line_content": "    heap_trace_event->set_buffer_id(buffer_id);",
          "content_same": false
        },
        {
          "line": 3582,
          "old_api": null,
          "new_api": "set_computation_name",
          "old_text": null,
          "new_text": "heap_trace_event->set_computation_name(\n        value->instruction()->parent()->name())",
          "old_line_content": "",
          "new_line_content": "    heap_trace_event->set_computation_name(",
          "content_same": false
        },
        {
          "line": 1537,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "ranges_.find(\n      {start_time, end_time, MemorySpaceAssignment::MemorySpace::kAlternate})",
          "old_line_content": "    const MemorySpaceAssignment::Allocation& allocation) {",
          "new_line_content": "  auto copy_it = ranges_.find(",
          "content_same": false
        },
        {
          "line": 1540,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "  return aliased_offset_it->second;",
          "new_line_content": "    VLOG(4) << \"Violates ordering: (\" << start_time << \", \" << end_time",
          "content_same": false
        },
        {
          "line": 3588,
          "old_api": null,
          "new_api": "CHECK_EQ",
          "old_text": null,
          "new_text": "CHECK_EQ(kind, HeapSimulatorTrace::Event::FREE)",
          "old_line_content": "",
          "new_line_content": "      CHECK_EQ(kind, HeapSimulatorTrace::Event::FREE);",
          "content_same": false
        },
        {
          "line": 3591,
          "old_api": null,
          "new_api": "std::max(max_memory_usage, memory_usage)",
          "old_text": null,
          "new_text": "std::max(max_memory_usage, memory_usage)",
          "old_line_content": "",
          "new_line_content": "    max_memory_usage = std::max(max_memory_usage, memory_usage);",
          "content_same": false
        },
        {
          "line": 3592,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "",
          "new_line_content": "    VLOG(4) << \"Memory usage: \" << memory_usage << \" at time: \" << time;",
          "content_same": false
        },
        {
          "line": 3594,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "",
          "new_line_content": "  VLOG(1) << \"Max memory usage ignoring fragmentation: \" << max_memory_usage;",
          "content_same": false
        },
        {
          "line": 3596,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 1551,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "aliased_offset_map_.find(&allocation)",
          "old_line_content": "  }",
          "new_line_content": "  auto aliased_offset_it = aliased_offset_map_.find(&allocation);",
          "content_same": false
        },
        {
          "line": 1559,
          "old_api": null,
          "new_api": "memory_space",
          "old_text": null,
          "new_text": "allocation.memory_space()",
          "old_line_content": "    const MemorySpaceAssignment::AllocationSequence& allocations, int64 time) {",
          "new_line_content": "  CHECK(allocation.memory_space() == MemorySpace::kAlternate);",
          "content_same": false
        },
        {
          "line": 1565,
          "old_api": null,
          "new_api": "chunk",
          "old_text": null,
          "new_text": "allocation.chunk()",
          "old_line_content": "    }",
          "new_line_content": "  CHECK_EQ(allocation.chunk().offset, aliased_offset->offset);",
          "content_same": false
        },
        {
          "line": 1566,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "aliased_offset->allocations.insert(&allocation)",
          "old_line_content": "  }",
          "new_line_content": "  CHECK(aliased_offset->allocations.insert(&allocation).second);",
          "content_same": false
        },
        {
          "line": 1573,
          "old_api": null,
          "new_api": "rbegin",
          "old_text": null,
          "new_text": "allocations.rbegin()",
          "old_line_content": "    return;",
          "new_line_content": "  for (auto allocation_it = allocations.rbegin();",
          "content_same": false
        },
        {
          "line": 1574,
          "old_api": null,
          "new_api": "rend",
          "old_text": null,
          "new_text": "allocations.rend()",
          "old_line_content": "  }",
          "new_line_content": "       allocation_it != allocations.rend(); ++allocation_it) {",
          "content_same": false
        },
        {
          "line": 1575,
          "old_api": null,
          "new_api": "start_time",
          "old_text": null,
          "new_text": "*allocation_it)->start_time()",
          "old_line_content": "",
          "new_line_content": "    if ((*allocation_it)->start_time() <= time &&",
          "content_same": false
        },
        {
          "line": 1577,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "allocation_it->get()",
          "old_line_content": "  if (chunk_candidate.chunk.offset != 0 ||",
          "new_line_content": "      return allocation_it->get();",
          "content_same": false
        },
        {
          "line": 1589,
          "old_api": null,
          "new_api": "FindChunkCandidate",
          "old_text": null,
          "new_text": "FindChunkCandidate(*prefetch_candidate)",
          "old_line_content": "  MemorySpaceAssignment::AllocationSequence allocations;",
          "new_line_content": "  ChunkCandidate chunk_candidate = FindChunkCandidate(*prefetch_candidate);",
          "content_same": false
        },
        {
          "line": 1592,
          "old_api": null,
          "new_api": "LOG",
          "old_text": null,
          "new_text": "LOG(WARNING)",
          "old_line_content": "      prefetch_candidate->start, prefetch_candidate->end,",
          "new_line_content": "    LOG(WARNING)",
          "content_same": false
        },
        {
          "line": 1604,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "buffer->defining_position()",
          "old_line_content": "",
          "new_line_content": "      buffer->defining_position(), MemorySpace::kDefault, kDummyChunk,",
          "content_same": false
        },
        {
          "line": 1610,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "buffer->uses()",
          "old_line_content": "        last_use_time,",
          "new_line_content": "  auto uses = buffer->uses();",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "instruction_schedule.at(rhs.instruction)",
          "old_line_content": "                ->instruction));",
          "new_line_content": "           instruction_schedule.at(rhs.instruction);",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": null,
          "new_api": "absl::c_min_element(uses, use_schedule_compare)",
          "old_text": null,
          "new_text": "absl::c_min_element(uses, use_schedule_compare)",
          "old_line_content": "",
          "new_line_content": "  auto first_use = absl::c_min_element(uses, use_schedule_compare);",
          "content_same": false
        },
        {
          "line": 1620,
          "old_api": null,
          "new_api": "absl::c_max_element(uses, use_schedule_compare)",
          "old_text": null,
          "new_text": "absl::c_max_element(uses, use_schedule_compare)",
          "old_line_content": "          end_of_program_prefetch_end_time, end_of_program_prefetch_end_time);",
          "new_line_content": "      absl::c_max_element(uses, use_schedule_compare)->instruction);",
          "content_same": false
        },
        {
          "line": 1622,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "std::max(\n        last_use_time,\n        instruction_schedule.at(\n            absl::c_max_element(colocation->uses(), use_schedule_compare)\n                ->instruction))",
          "old_line_content": "          << \", end-of-program prefetch start time = \"",
          "new_line_content": "    last_use_time = std::max(",
          "content_same": false
        },
        {
          "line": 1624,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "instruction_schedule.at(\n            absl::c_max_element(colocation->uses(), use_schedule_compare)\n                ->instruction)",
          "old_line_content": "  bool free_buffer =",
          "new_line_content": "        instruction_schedule.at(",
          "content_same": false
        },
        {
          "line": 1625,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "colocation->uses()",
          "old_line_content": "      (end_of_program_prefetch_start_time > last_use_time &&",
          "new_line_content": "            absl::c_max_element(colocation->uses(), use_schedule_compare)",
          "content_same": false
        },
        {
          "line": 1629,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "instruction_schedule.size()",
          "old_line_content": "",
          "new_line_content": "  int64 end_of_program_prefetch_end_time = instruction_schedule.size() - 1;",
          "content_same": false
        },
        {
          "line": 1631,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->PreferredPrefetchStartTime(\n          buffer->defining_position().shape(), last_use_time,\n          end_of_program_prefetch_end_time, end_of_program_prefetch_end_time)",
          "old_line_content": "               chunk_candidate.chunk, prefetch_candidate->start,",
          "new_line_content": "      options_.prefetch_interval_picker->PreferredPrefetchStartTime(",
          "content_same": false
        },
        {
          "line": 1632,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "buffer->defining_position().shape()",
          "old_line_content": "               cross_program_prefetch_end_time, latest_prefetch_time,",
          "new_line_content": "          buffer->defining_position().shape(), last_use_time,",
          "content_same": false
        },
        {
          "line": 1634,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(2)",
          "old_line_content": "               /*is_cross_program_prefetch=*/true);",
          "new_line_content": "  VLOG(2) << \"last use time = \" << last_use_time",
          "content_same": false
        },
        {
          "line": 1643,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "allocations.back()",
          "old_line_content": "                 chunk_candidate.chunk, end_of_program_prefetch_start_time,",
          "new_line_content": "  AddAsyncCopy(*allocations.back(), MemorySpace::kAlternate,",
          "content_same": false
        },
        {
          "line": 1650,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "allocations.back()",
          "old_line_content": "",
          "new_line_content": "      GetAliasedOffset(*allocations.back());",
          "content_same": false
        },
        {
          "line": 1655,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "allocations.front()",
          "old_line_content": "",
          "new_line_content": "    AddAsyncCopy(*allocations.front(), MemorySpace::kAlternate,",
          "content_same": false
        },
        {
          "line": 1671,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "allocations_->size()",
          "old_line_content": "        }",
          "new_line_content": "  for (int i = allocations_initial_size; i < allocations_->size(); ++i) {",
          "content_same": false
        },
        {
          "line": 1672,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "allocations_->at(i)",
          "old_line_content": "      }",
          "new_line_content": "    const auto& allocation = allocations_->at(i);",
          "content_same": false
        },
        {
          "line": 1673,
          "old_api": null,
          "new_api": "memory_space",
          "old_text": null,
          "new_text": "allocation->memory_space()",
          "old_line_content": "    }",
          "new_line_content": "    if (allocation->memory_space() == MemorySpace::kAlternate) {",
          "content_same": false
        },
        {
          "line": 1674,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "MakeRepackAllocationBlock(\n          allocation->start_time(), allocation->end_time(),\n          allocation->chunk().size, allocation->chunk().offset,\n          static_cast<int64>(repack_allocation_blocks_.size()),\n          allocation.get())",
          "old_line_content": "  }",
          "new_line_content": "      repack_allocation_blocks_.push_back(MakeRepackAllocationBlock(",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": null,
          "new_api": "end_time",
          "old_text": null,
          "new_text": "allocation->end_time()",
          "old_line_content": "",
          "new_line_content": "          allocation->start_time(), allocation->end_time(),",
          "content_same": false
        },
        {
          "line": 1677,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "repack_allocation_blocks_.size()",
          "old_line_content": "}",
          "new_line_content": "          static_cast<int64>(repack_allocation_blocks_.size()),",
          "content_same": false
        },
        {
          "line": 1678,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "allocation.get()",
          "old_line_content": "",
          "new_line_content": "          allocation.get()));",
          "content_same": false
        },
        {
          "line": 1679,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "repack_allocation_blocks_.back()",
          "old_line_content": "void AlternateMemoryBestFitHeap::AllocateReservedScopedAllocations() {",
          "new_line_content": "      RepackAllocationBlock* inserted = &repack_allocation_blocks_.back();",
          "content_same": false
        },
        {
          "line": 1689,
          "old_api": null,
          "new_api": "ClearPendingChunks",
          "old_text": null,
          "new_text": "ClearPendingChunks()",
          "old_line_content": "              << \"): \" << reserved_scoped_memory;",
          "new_line_content": "  ClearPendingChunks();",
          "content_same": false
        },
        {
          "line": 1694,
          "old_api": null,
          "new_api": "flattened_instruction_sequence",
          "old_text": null,
          "new_text": "hlo_live_range_.flattened_instruction_sequence().instructions()",
          "old_line_content": "      interval.end = i;",
          "new_line_content": "      hlo_live_range_.flattened_instruction_sequence().instructions();",
          "content_same": false
        },
        {
          "line": 1696,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "instruction_sequence.size()",
          "old_line_content": "      interval.colocations = {};",
          "new_line_content": "  for (int i = 0; i < instruction_sequence.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 1701,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "instruction_sequence[i]->name()",
          "old_line_content": "",
          "new_line_content": "              << instruction_sequence[i]->name()",
          "content_same": false
        },
        {
          "line": 1713,
          "old_api": null,
          "new_api": "AddToPendingChunks",
          "old_text": null,
          "new_text": "AddToPendingChunks(interval, chunk_candidate)",
          "old_line_content": "    }",
          "new_line_content": "      AddToPendingChunks(interval, chunk_candidate);",
          "content_same": false
        },
        {
          "line": 1715,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "allocations_->push_back(\n          absl::make_unique<MemorySpaceAssignment::Allocation>(\n              HloPosition{instruction_sequence[i], {}}, MemorySpace::kAlternate,\n              chunk_candidate.chunk, i, i, /*is_scoped_allocation=*/true))",
          "old_line_content": "  // If requested, make all scoped allocations to colocate with each other so",
          "new_line_content": "      allocations_->push_back(",
          "content_same": false
        },
        {
          "line": 1716,
          "old_api": null,
          "new_api": "absl::make_unique<MemorySpaceAssignment::Allocation>(\n              HloPosition{instruction_sequence[i], {}}, MemorySpace::kAlternate,\n              chunk_candidate.chunk, i, i, /*is_scoped_allocation=*/true)",
          "old_text": null,
          "new_text": "absl::make_unique<MemorySpaceAssignment::Allocation>(\n              HloPosition{instruction_sequence[i], {}}, MemorySpace::kAlternate,\n              chunk_candidate.chunk, i, i, /*is_scoped_allocation=*/true)",
          "old_line_content": "  // that when we repack, all scoped allocations get the same offsets. Since",
          "new_line_content": "          absl::make_unique<MemorySpaceAssignment::Allocation>(",
          "content_same": false
        },
        {
          "line": 1720,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "MakeRepackAllocationBlock(\n          i, i, reserved_scoped_memory,\n          /*initial_offset=*/0,\n          static_cast<int64>(repack_allocation_blocks_.size()),\n          allocations_->back().get())",
          "old_line_content": "  if (options_.allocate_reserved_scoped_memory_at_same_offset) {",
          "new_line_content": "      repack_allocation_blocks_.push_back(MakeRepackAllocationBlock(",
          "content_same": false
        },
        {
          "line": 1723,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "repack_allocation_blocks_.size()",
          "old_line_content": "      repack_block->colocations = colocations;",
          "new_line_content": "          static_cast<int64>(repack_allocation_blocks_.size()),",
          "content_same": false
        },
        {
          "line": 1724,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "allocations_->back().get()",
          "old_line_content": "    }",
          "new_line_content": "          allocations_->back().get()));",
          "content_same": false
        },
        {
          "line": 1725,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "repack_allocation_blocks_.back()",
          "old_line_content": "  }",
          "new_line_content": "      colocations.push_back(&repack_allocation_blocks_.back());",
          "content_same": false
        },
        {
          "line": 1744,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "required_assignments_.find(buffer)",
          "old_line_content": "}",
          "new_line_content": "  auto required_assignment_it = required_assignments_.find(buffer);",
          "content_same": false
        },
        {
          "line": 1746,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "required_assignments_.end()",
          "old_line_content": "absl::optional<AlternateMemoryBestFitHeap::RequiredMemoryAssignment>",
          "new_line_content": "  if (required_assignment_it != required_assignments_.end()) {",
          "content_same": false
        },
        {
          "line": 1751,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(!required_assignment_at_time)",
          "old_line_content": "    const HloValue* value =",
          "new_line_content": "        CHECK(!required_assignment_at_time);",
          "content_same": false
        },
        {
          "line": 1765,
          "old_api": null,
          "new_api": "dataflow_analysis",
          "old_text": null,
          "new_text": "alias_analysis_.dataflow_analysis().GetUniqueValueAt(\n            position.instruction, position.index)",
          "old_line_content": "  }",
          "new_line_content": "        &alias_analysis_.dataflow_analysis().GetUniqueValueAt(",
          "content_same": false
        },
        {
          "line": 1768,
          "old_api": null,
          "new_api": "instruction_schedule",
          "old_text": null,
          "new_text": "hlo_live_range_.instruction_schedule().at(position.instruction)",
          "old_line_content": "",
          "new_line_content": "        hlo_live_range_.instruction_schedule().at(position.instruction);",
          "content_same": false
        },
        {
          "line": 1770,
          "old_api": null,
          "new_api": "RequiredMemoryAssignmentAt",
          "old_text": null,
          "new_text": "RequiredMemoryAssignmentAt(value, time)",
          "old_line_content": "    const HloInstruction* instruction, ShapeIndex index,",
          "new_line_content": "        RequiredMemoryAssignmentAt(value, time);",
          "content_same": false
        },
        {
          "line": 1775,
          "old_api": null,
          "new_api": "equals_ignoring_time",
          "old_text": null,
          "new_text": "required_assignment->equals_ignoring_time(\n                *required_assignment_for_alias)",
          "old_line_content": "  }",
          "new_line_content": "            required_assignment->equals_ignoring_time(",
          "content_same": false
        },
        {
          "line": 1787,
          "old_api": null,
          "new_api": "GetAliasedOffset",
          "old_text": null,
          "new_text": "GetAliasedOffset(*aliased_allocation)",
          "old_line_content": "  if (existing_required_assignment) {",
          "new_line_content": "    offset = GetAliasedOffset(*aliased_allocation);",
          "content_same": false
        },
        {
          "line": 1799,
          "old_api": null,
          "new_api": "RequiredMemoryAssignmentAt",
          "old_text": null,
          "new_text": "RequiredMemoryAssignmentAt(value, time)",
          "old_line_content": "    RequiredMemoryAssignment required_assignment{memory_space, time, offset};",
          "new_line_content": "  auto existing_required_assignment = RequiredMemoryAssignmentAt(value, time);",
          "content_same": false
        },
        {
          "line": 1802,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "instruction->ToString()",
          "old_line_content": "  }",
          "new_line_content": "        << \"inst = \" << instruction->ToString() << \" at \" << time;",
          "content_same": false
        },
        {
          "line": 1803,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK((!offset && !existing_required_assignment->offset) ||\n          offset == existing_required_assignment->offset)",
          "old_line_content": "}",
          "new_line_content": "    CHECK((!offset && !existing_required_assignment->offset) ||",
          "content_same": false
        },
        {
          "line": 1805,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "void AlternateMemoryBestFitHeap::AddRequiredAssignment(",
          "new_line_content": "    VLOG(3) << \"Not adding required assignment because there is one already: \"",
          "content_same": false
        },
        {
          "line": 1806,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "value->ToShortString()",
          "old_line_content": "    const HloInstruction* instruction, ShapeIndex index,",
          "new_line_content": "            << value->ToShortString() << \" at \" << time << \" at \"",
          "content_same": false
        },
        {
          "line": 1813,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "required_assignments_[value].push_back(required_assignment)",
          "old_line_content": "                        offset);",
          "new_line_content": "    required_assignments_[value].push_back(required_assignment);",
          "content_same": false
        },
        {
          "line": 1814,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "pending_required_assignments_.push_back({value, required_assignment})",
          "old_line_content": "}",
          "new_line_content": "    pending_required_assignments_.push_back({value, required_assignment});",
          "content_same": false
        },
        {
          "line": 1822,
          "old_api": null,
          "new_api": "dataflow_analysis",
          "old_text": null,
          "new_text": "alias_analysis_.dataflow_analysis().GetUniqueValueAt(instruction, index)",
          "old_line_content": "  for (HloInstruction* parameter_instruction :",
          "new_line_content": "      &alias_analysis_.dataflow_analysis().GetUniqueValueAt(instruction, index);",
          "content_same": false
        },
        {
          "line": 1824,
          "old_api": null,
          "new_api": "instruction_schedule",
          "old_text": null,
          "new_text": "hlo_live_range_.instruction_schedule().at(instruction)",
          "old_line_content": "    int64 parameter_instruction_time =",
          "new_line_content": "      hlo_live_range_.instruction_schedule().at(instruction);",
          "content_same": false
        },
        {
          "line": 1832,
          "old_api": null,
          "new_api": "dataflow_analysis",
          "old_text": null,
          "new_text": "alias_analysis_.dataflow_analysis().module()",
          "old_line_content": "            memory_space = MemorySpace::kAlternate;",
          "new_line_content": "  const HloModule& module = alias_analysis_.dataflow_analysis().module();",
          "content_same": false
        },
        {
          "line": 1833,
          "old_api": null,
          "new_api": "instruction_schedule",
          "old_text": null,
          "new_text": "hlo_live_range_.instruction_schedule()",
          "old_line_content": "          }",
          "new_line_content": "  const auto& instruction_schedule = hlo_live_range_.instruction_schedule();",
          "content_same": false
        },
        {
          "line": 1834,
          "old_api": null,
          "new_api": "entry_computation",
          "old_text": null,
          "new_text": "module.entry_computation()",
          "old_line_content": "          for (const HloBuffer* buffer :",
          "new_line_content": "  HloComputation* entry_computation = module.entry_computation();",
          "content_same": false
        },
        {
          "line": 1839,
          "old_api": null,
          "new_api": "has_layout",
          "old_text": null,
          "new_text": "ShapeUtil::ForEachSubshape(\n        parameter_instruction->shape(),\n        [&](const Shape& subshape, const ShapeIndex& index) {\n          MemorySpace memory_space = MemorySpace::kDefault;\n          if (subshape.has_layout() && subshape.layout().memory_space() ==\n                                           options_.alternate_memory_space) {\n            memory_space = MemorySpace::kAlternate;\n          }\n          for (const HloBuffer* buffer :\n               alias_analysis_.ComputeBuffersAt(parameter_instruction, index)) {\n            for (const HloValue* value : buffer->values()) {\n              VLOG(3) << \"Adding required assignment for parameter value = \"\n                      << value->ToShortString()\n                      << \" time = \" << parameter_instruction_time << \" space = \"\n                      << (memory_space == MemorySpace::kDefault ? \"def\"\n                                                                : \"alt\");\n              required_assignments_[value].push_back(\n                  {memory_space, /*time=*/parameter_instruction_time});\n            }\n          }\n        })",
          "old_line_content": "                      << \" time = \" << parameter_instruction_time << \" space = \"",
          "new_line_content": "    ShapeUtil::ForEachSubshape(",
          "content_same": false
        },
        {
          "line": 1840,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "parameter_instruction->shape()",
          "old_line_content": "                      << (memory_space == MemorySpace::kDefault ? \"def\"",
          "new_line_content": "        parameter_instruction->shape(),",
          "content_same": false
        },
        {
          "line": 1843,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "subshape.layout().memory_space()",
          "old_line_content": "                  {memory_space, /*time=*/parameter_instruction_time});",
          "new_line_content": "          if (subshape.has_layout() && subshape.layout().memory_space() ==",
          "content_same": false
        },
        {
          "line": 1855,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "required_assignments_[value].push_back(\n                  {memory_space, /*time=*/parameter_instruction_time})",
          "old_line_content": "                                         options_.alternate_memory_space) {",
          "new_line_content": "              required_assignments_[value].push_back(",
          "content_same": false
        },
        {
          "line": 1863,
          "old_api": null,
          "new_api": "has_layout",
          "old_text": null,
          "new_text": "ShapeUtil::ForEachSubshape(\n      root_instruction->shape(),\n      [&](const Shape& subshape, const ShapeIndex& index) {\n        MemorySpace memory_space = MemorySpace::kDefault;\n        if (subshape.has_layout() && subshape.layout().memory_space() ==\n                                         options_.alternate_memory_space) {\n          memory_space = MemorySpace::kAlternate;\n        }\n        for (const HloBuffer* buffer :\n             alias_analysis_.ComputeBuffersAt(root_instruction, index)) {\n          for (const HloValue* value : buffer->values()) {\n            VLOG(3) << \"Adding required assignment for output value = \"\n                    << value->ToShortString()\n                    << \" time = \" << root_instruction_time << \" space = \"\n                    << (memory_space == MemorySpace::kDefault ? \"def\" : \"alt\");\n            required_assignments_[value].push_back(\n                {memory_space, /*time=*/root_instruction_time});\n          }\n        }\n      })",
          "old_line_content": "                    << \" time = \" << root_instruction_time << \" space = \"",
          "new_line_content": "  ShapeUtil::ForEachSubshape(",
          "content_same": false
        },
        {
          "line": 1864,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "root_instruction->shape()",
          "old_line_content": "                    << (memory_space == MemorySpace::kDefault ? \"def\" : \"alt\");",
          "new_line_content": "      root_instruction->shape(),",
          "content_same": false
        },
        {
          "line": 1867,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "subshape.layout().memory_space()",
          "old_line_content": "          }",
          "new_line_content": "        if (subshape.has_layout() && subshape.layout().memory_space() ==",
          "content_same": false
        },
        {
          "line": 1872,
          "old_api": null,
          "new_api": "ComputeBuffersAt",
          "old_text": null,
          "new_text": "alias_analysis_.ComputeBuffersAt(root_instruction, index)",
          "old_line_content": "bool AlternateMemoryBestFitHeap::AreIntervalsReservedInAlternateMemory(",
          "new_line_content": "             alias_analysis_.ComputeBuffersAt(root_instruction, index)) {",
          "content_same": false
        },
        {
          "line": 1873,
          "old_api": null,
          "new_api": "values",
          "old_text": null,
          "new_text": "buffer->values()",
          "old_line_content": "    absl::Span<const BufferInterval* const> colocated_intervals) const {",
          "new_line_content": "          for (const HloValue* value : buffer->values()) {",
          "content_same": false
        },
        {
          "line": 1874,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "  auto is_position_in_alternate_memory = [&](const HloPosition& position) {",
          "new_line_content": "            VLOG(3) << \"Adding required assignment for output value = \"",
          "content_same": false
        },
        {
          "line": 1878,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "required_assignments_[value].push_back(\n                {memory_space, /*time=*/root_instruction_time})",
          "old_line_content": "  };",
          "new_line_content": "            required_assignments_[value].push_back(",
          "content_same": false
        },
        {
          "line": 1889,
          "old_api": null,
          "new_api": "has_layout",
          "old_text": null,
          "new_text": "shape.has_layout()",
          "old_line_content": "      return true;",
          "new_line_content": "    return shape.has_layout() &&",
          "content_same": false
        },
        {
          "line": 1890,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "shape.layout().memory_space()",
          "old_line_content": "    }",
          "new_line_content": "           shape.layout().memory_space() == options_.alternate_memory_space;",
          "content_same": false
        },
        {
          "line": 1893,
          "old_api": null,
          "new_api": "dataflow_analysis",
          "old_text": null,
          "new_text": "alias_analysis_.dataflow_analysis().module()",
          "old_line_content": "      if (position.instruction == root_instruction &&",
          "new_line_content": "  const HloModule& module = alias_analysis_.dataflow_analysis().module();",
          "content_same": false
        },
        {
          "line": 1896,
          "old_api": null,
          "new_api": "root_instruction",
          "old_text": null,
          "new_text": "entry_computation->root_instruction()",
          "old_line_content": "      }",
          "new_line_content": "      entry_computation->root_instruction();",
          "content_same": false
        },
        {
          "line": 1899,
          "old_api": null,
          "new_api": "defining_instruction",
          "old_text": null,
          "new_text": "value->defining_instruction()->opcode()",
          "old_line_content": "  return false;",
          "new_line_content": "    if (value->defining_instruction()->opcode() == HloOpcode::kParameter &&",
          "content_same": false
        },
        {
          "line": 1900,
          "old_api": null,
          "new_api": "defining_instruction",
          "old_text": null,
          "new_text": "value->defining_instruction()->parent()",
          "old_line_content": "}",
          "new_line_content": "        value->defining_instruction()->parent() == entry_computation &&",
          "content_same": false
        },
        {
          "line": 1901,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "value->defining_position()",
          "old_line_content": "",
          "new_line_content": "        is_position_in_alternate_memory(value->defining_position())) {",
          "content_same": false
        },
        {
          "line": 1907,
          "old_api": null,
          "new_api": "is_position_in_alternate_memory",
          "old_text": null,
          "new_text": "is_position_in_alternate_memory(position)",
          "old_line_content": "}",
          "new_line_content": "          is_position_in_alternate_memory(position)) {",
          "content_same": false
        },
        {
          "line": 1926,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "allocation->ToString()",
          "old_line_content": "",
          "new_line_content": "    VLOG(3) << \"Moved \" << allocation->ToString() << \", size \"",
          "content_same": false
        },
        {
          "line": 1927,
          "old_api": null,
          "new_api": "chunk",
          "old_text": null,
          "new_text": "allocation->chunk()",
          "old_line_content": "void AlternateMemoryBestFitHeap::UncommitPendingChunks(",
          "new_line_content": "            << allocation->chunk().size << \", (\" << allocation_block.start_time",
          "content_same": false
        },
        {
          "line": 1931,
          "old_api": null,
          "new_api": "mutable_chunk",
          "old_text": null,
          "new_text": "allocation_block.allocation->mutable_chunk()",
          "old_line_content": "  for (AllocationValue& allocation_value : allocation_values) {",
          "new_line_content": "    allocation_block.allocation->mutable_chunk()->offset =",
          "content_same": false
        },
        {
          "line": 1933,
          "old_api": null,
          "new_api": "Add",
          "old_text": null,
          "new_text": "interval_tree_.Add(allocation_block.start_time, allocation_block.end_time,\n                       {allocation_block.offset, allocation_block.size})",
          "old_line_content": "  }",
          "new_line_content": "    interval_tree_.Add(allocation_block.start_time, allocation_block.end_time,",
          "content_same": false
        },
        {
          "line": 1950,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "  }",
          "new_line_content": "    VLOG(3) << \"Uncommitting: (\" << interval.start << \", \" << interval.end",
          "content_same": false
        },
        {
          "line": 1952,
          "old_api": null,
          "new_api": "Remove",
          "old_text": null,
          "new_text": "interval_tree_.Remove(interval.start, interval.end, chunk)",
          "old_line_content": "       pending_required_assignments_) {",
          "new_line_content": "    interval_tree_.Remove(interval.start, interval.end, chunk);",
          "content_same": false
        },
        {
          "line": 1956,
          "old_api": null,
          "new_api": "Remove",
          "old_text": null,
          "new_text": "prefetch_interval_tree_.Remove(interval.start_time, interval.end_time,\n                                     kDummyChunk)",
          "old_line_content": "        value_and_required_assignment.second;",
          "new_line_content": "      prefetch_interval_tree_.Remove(interval.start_time, interval.end_time,",
          "content_same": false
        },
        {
          "line": 1958,
          "old_api": null,
          "new_api": "RemoveCopy",
          "old_text": null,
          "new_text": "async_copy_ordering_.RemoveCopy(interval)",
          "old_line_content": "            << (required_assignment.memory_space == MemorySpace::kDefault",
          "new_line_content": "      async_copy_ordering_.RemoveCopy(interval);",
          "content_same": false
        },
        {
          "line": 1960,
          "old_api": null,
          "new_api": "Remove",
          "old_text": null,
          "new_text": "eviction_interval_tree_.Remove(interval.start_time, interval.end_time,\n                                     kDummyChunk)",
          "old_line_content": "                    : \"alt\")",
          "new_line_content": "      eviction_interval_tree_.Remove(interval.start_time, interval.end_time,",
          "content_same": false
        },
        {
          "line": 1970,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "    }",
          "new_line_content": "    VLOG(3) << \"Removing required assignment: \"",
          "content_same": false
        },
        {
          "line": 1977,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "required_assignment_vector.begin()",
          "old_line_content": "  absl::flat_hash_map<const AliasedOffset*,",
          "new_line_content": "    for (auto it = required_assignment_vector.begin();",
          "content_same": false
        },
        {
          "line": 1978,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "required_assignment_vector.end()",
          "old_line_content": "                      std::vector<MemorySpaceAssignment::Allocation*>>",
          "new_line_content": "         it != required_assignment_vector.end(); ++it) {",
          "content_same": false
        },
        {
          "line": 1980,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "required_assignment_vector.erase(it)",
          "old_line_content": "  for (AllocationValue& allocation_value : allocation_values) {",
          "new_line_content": "        required_assignment_vector.erase(it);",
          "content_same": false
        },
        {
          "line": 1985,
          "old_api": null,
          "new_api": "ClearPendingChunks",
          "old_text": null,
          "new_text": "ClearPendingChunks()",
          "old_line_content": "      MemorySpaceAssignment::Allocation* inserted_allocation =",
          "new_line_content": "  ClearPendingChunks();",
          "content_same": false
        },
        {
          "line": 1994,
          "old_api": null,
          "new_api": "allocation_sequence",
          "old_text": null,
          "new_text": "allocation_value.allocation_sequence()",
          "old_line_content": "  // Export these to repack_allocation_blocks_ so that we can repack them to",
          "new_line_content": "    for (auto& allocation : *allocation_value.allocation_sequence()) {",
          "content_same": false
        },
        {
          "line": 1995,
          "old_api": null,
          "new_api": "AppendAllocationInfoDebugString",
          "old_text": null,
          "new_text": "AppendAllocationInfoDebugString(allocation_value, *allocation,\n                                      allocation_info_str_)",
          "old_line_content": "  // reduce fragmentation.",
          "new_line_content": "      AppendAllocationInfoDebugString(allocation_value, *allocation,",
          "content_same": false
        },
        {
          "line": 1997,
          "old_api": null,
          "new_api": "std::move(allocation)",
          "old_text": null,
          "new_text": "std::move(allocation)",
          "old_line_content": "    std::vector<MemorySpaceAssignmentRepacker::AllocationBlock*> colocations;",
          "new_line_content": "      allocations_->push_back(std::move(allocation));",
          "content_same": false
        },
        {
          "line": 1999,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "allocations_->back().get()",
          "old_line_content": "         colocation.second) {",
          "new_line_content": "          allocations_->back().get();",
          "content_same": false
        },
        {
          "line": 2014,
          "old_api": null,
          "new_api": "end_time",
          "old_text": null,
          "new_text": "colocated_allocation->end_time()",
          "old_line_content": "}",
          "new_line_content": "          colocated_allocation->start_time(), colocated_allocation->end_time(),",
          "content_same": false
        },
        {
          "line": 2015,
          "old_api": null,
          "new_api": "chunk",
          "old_text": null,
          "new_text": "colocated_allocation->chunk()",
          "old_line_content": "",
          "new_line_content": "          colocated_allocation->chunk().size,",
          "content_same": false
        },
        {
          "line": 2016,
          "old_api": null,
          "new_api": "chunk",
          "old_text": null,
          "new_text": "colocated_allocation->chunk()",
          "old_line_content": "void AlternateMemoryBestFitHeap::ClearPendingChunks() {",
          "new_line_content": "          colocated_allocation->chunk().offset,",
          "content_same": false
        },
        {
          "line": 2026,
          "old_api": null,
          "new_api": "ClearPendingChunks",
          "old_text": null,
          "new_text": "ClearPendingChunks()",
          "old_line_content": "    const ChunkCandidate& chunk_candidate) {",
          "new_line_content": "  ClearPendingChunks();",
          "content_same": false
        },
        {
          "line": 2032,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "pending_required_assignments_.clear()",
          "old_line_content": "}",
          "new_line_content": "  pending_required_assignments_.clear();",
          "content_same": false
        },
        {
          "line": 2033,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "aliased_offset_map_.clear()",
          "old_line_content": "",
          "new_line_content": "  aliased_offset_map_.clear();",
          "content_same": false
        },
        {
          "line": 2034,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "aliased_offsets_.clear()",
          "old_line_content": "AlternateMemoryBestFitHeap::Result AlternateMemoryBestFitHeap::AllocateSegment(",
          "new_line_content": "  aliased_offsets_.clear();",
          "content_same": false
        },
        {
          "line": 2040,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "  if (request.start_time == request.end_time) {",
          "new_line_content": "  VLOG(3) << \"Committing chunk: \" << buffer_interval.start << \"-\"",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2050,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(2)",
          "new_text": null,
          "old_line_content": "  VLOG(2) << \"Finding allocation for \"",
          "new_line_content": "  // start_time == end_time is a special case where the value is consumed",
          "content_same": false
        },
        {
          "line": 2051,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "request.allocation_value->ToShortString()",
          "new_text": null,
          "old_line_content": "          << request.allocation_value->ToShortString() << \" (\"",
          "new_line_content": "  // multiple times by the same instruction. We can just find the previous",
          "content_same": false
        },
        {
          "line": 2054,
          "old_api": "back",
          "new_api": null,
          "old_text": "request.allocation_value->uses().back()",
          "new_text": null,
          "old_line_content": "          << \" last use = \" << request.allocation_value->uses().back().time",
          "new_line_content": "    MemorySpaceAssignment::Allocation* allocation =",
          "content_same": false
        },
        {
          "line": 2058,
          "old_api": "CHECK_LE",
          "new_api": null,
          "old_text": "CHECK_LE(request.start_time, request.end_time)",
          "new_text": null,
          "old_line_content": "  CHECK_LE(request.start_time, request.end_time);",
          "new_line_content": "    return Result::kSuccess;",
          "content_same": false
        },
        {
          "line": 2065,
          "old_api": "value",
          "new_api": null,
          "old_text": "RequiredMemoryAssignmentAt(\n      request.allocation_value->value(), request.start_time)",
          "new_text": null,
          "old_line_content": "  auto required_assignment_at_start = RequiredMemoryAssignmentAt(",
          "new_line_content": "          << request.start_time << \", \" << request.end_time",
          "content_same": false
        },
        {
          "line": 2066,
          "old_api": "value",
          "new_api": null,
          "old_text": "request.allocation_value->value()",
          "new_text": null,
          "old_line_content": "      request.allocation_value->value(), request.start_time);",
          "new_line_content": "          << \") latest prefetch = \" << request.latest_prefetch_time",
          "content_same": false
        },
        {
          "line": 2073,
          "old_api": "value",
          "new_api": null,
          "old_text": "RequiredMemoryAssignmentAt(\n      request.allocation_value->value(), request.end_time)",
          "new_text": null,
          "old_line_content": "  auto required_assignment_at_end = RequiredMemoryAssignmentAt(",
          "new_line_content": "  // There could be a requirement to pin this buffer to default memory either",
          "content_same": false
        },
        {
          "line": 2074,
          "old_api": "value",
          "new_api": null,
          "old_text": "request.allocation_value->value()",
          "new_text": null,
          "old_line_content": "      request.allocation_value->value(), request.end_time);",
          "new_line_content": "  // because it is a parameter or an output.  If the buffer is a parameter, then",
          "content_same": false
        },
        {
          "line": 2076,
          "old_api": "AliasedRequiredAssignmentForUse",
          "new_api": null,
          "old_text": "AliasedRequiredAssignmentForUse(*request.use)",
          "new_text": null,
          "old_line_content": "      AliasedRequiredAssignmentForUse(*request.use);",
          "new_line_content": "  // memory, we cannot prefetch it because if we did, it would be in alternate",
          "content_same": false
        },
        {
          "line": 2081,
          "old_api": "equals_ignoring_time",
          "new_api": null,
          "old_text": "CHECK(aliased_required_assignment_at_end == absl::nullopt ||\n            aliased_required_assignment_at_end->equals_ignoring_time(\n                *required_assignment_at_end))",
          "new_text": null,
          "old_line_content": "      CHECK(aliased_required_assignment_at_end == absl::nullopt ||",
          "new_line_content": "  if (required_assignment_at_start) {",
          "content_same": false
        },
        {
          "line": 2082,
          "old_api": "equals_ignoring_time",
          "new_api": null,
          "old_text": "aliased_required_assignment_at_end->equals_ignoring_time(\n                *required_assignment_at_end)",
          "new_text": null,
          "old_line_content": "            aliased_required_assignment_at_end->equals_ignoring_time(",
          "new_line_content": "    required_memory_space_at_start = required_assignment_at_start->memory_space;",
          "content_same": false
        },
        {
          "line": 2092,
          "old_api": "empty",
          "new_api": null,
          "old_text": "allocation_sequence->empty()",
          "new_text": null,
          "old_line_content": "    if (!allocation_sequence->empty()) {",
          "new_line_content": "      required_assignment_at_end = aliased_required_assignment_at_end;",
          "content_same": false
        },
        {
          "line": 2093,
          "old_api": "rbegin",
          "new_api": null,
          "old_text": "std::find_if(\n          allocation_sequence->rbegin(), allocation_sequence->rend(),\n          [&](const auto& allocation) {\n            return allocation->memory_space() ==\n                       required_memory_space_at_start &&\n                   allocation->defining_position() == defining_position;\n          })",
          "new_text": null,
          "old_line_content": "      auto prev_allocation_it = std::find_if(",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 2096,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "allocation->memory_space()",
          "new_text": null,
          "old_line_content": "            return allocation->memory_space() ==",
          "new_line_content": "                *required_assignment_at_end));",
          "content_same": false
        },
        {
          "line": 2098,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "allocation->defining_position()",
          "new_text": null,
          "old_line_content": "                   allocation->defining_position() == defining_position;",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2100,
          "old_api": "rend",
          "new_api": null,
          "old_text": "allocation_sequence->rend()",
          "new_text": null,
          "old_line_content": "      CHECK(prev_allocation_it != allocation_sequence->rend());",
          "new_line_content": "  if (required_assignment_at_end) {",
          "content_same": false
        },
        {
          "line": 2101,
          "old_api": "Extend",
          "new_api": null,
          "old_text": "*prev_allocation_it)->Extend(request.start_time)",
          "new_text": null,
          "old_line_content": "      (*prev_allocation_it)->Extend(request.start_time);",
          "new_line_content": "    required_memory_space_at_end = required_assignment_at_end->memory_space;",
          "content_same": false
        },
        {
          "line": 2110,
          "old_api": "absl::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, required_assignment_at_start->memory_space,\n              aliased_chunk, request.start_time, request.start_time,\n              /*is_scoped_allocation=*/false)",
          "new_api": null,
          "old_text": "absl::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, required_assignment_at_start->memory_space,\n              aliased_chunk, request.start_time, request.start_time,\n              /*is_scoped_allocation=*/false)",
          "new_text": null,
          "old_line_content": "          absl::make_unique<MemorySpaceAssignment::Allocation>(",
          "new_line_content": "                       required_memory_space_at_start &&",
          "content_same": false
        },
        {
          "line": 2116,
          "old_api": "back",
          "new_api": null,
          "old_text": "allocation_sequence->back()",
          "new_text": null,
          "old_line_content": "        CreateOrAddToAliasedOffset(*allocation_sequence->back(),",
          "new_line_content": "      absl::optional<Chunk> aliased_chunk = absl::nullopt;",
          "content_same": false
        },
        {
          "line": 2127,
          "old_api": "AllocateInAlternateMemoryNoCopy",
          "new_api": null,
          "old_text": "AllocateInAlternateMemoryNoCopy(request)",
          "new_text": null,
          "old_line_content": "    allocation_result = AllocateInAlternateMemoryNoCopy(request);",
          "new_line_content": "      if (required_assignment_at_start->memory_space ==",
          "content_same": false
        },
        {
          "line": 2133,
          "old_api": "rbegin",
          "new_api": null,
          "old_text": "allocation_sequence->rbegin()",
          "new_text": null,
          "old_line_content": "  auto prev_allocation_it = allocation_sequence->rbegin();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2136,
          "old_api": "rbegin",
          "new_api": null,
          "old_text": "std::find_if(\n      allocation_sequence->rbegin(), allocation_sequence->rend(),\n      [&](const auto& allocation) {\n        return allocation->memory_space() == MemorySpace::kDefault &&\n               allocation->defining_position() == defining_position;\n      })",
          "new_text": null,
          "old_line_content": "  auto prev_allocation_in_default_mem_it = std::find_if(",
          "new_line_content": "  // First try keeping the allocation entirely in the alternate memory.",
          "content_same": false
        },
        {
          "line": 2137,
          "old_api": "rend",
          "new_api": null,
          "old_text": "allocation_sequence->rend()",
          "new_text": null,
          "old_line_content": "      allocation_sequence->rbegin(), allocation_sequence->rend(),",
          "new_line_content": "  if (required_memory_space_at_start != MemorySpace::kDefault &&",
          "content_same": false
        },
        {
          "line": 2139,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "allocation->memory_space()",
          "new_text": null,
          "old_line_content": "        return allocation->memory_space() == MemorySpace::kDefault &&",
          "new_line_content": "      request.allow_no_copy_alternate_mem_allocation) {",
          "content_same": false
        },
        {
          "line": 2143,
          "old_api": "rend",
          "new_api": null,
          "old_text": "allocation_sequence->rend()",
          "new_text": null,
          "old_line_content": "  if (prev_allocation_in_default_mem_it == allocation_sequence->rend() &&",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2144,
          "old_api": "rend",
          "new_api": null,
          "old_text": "allocation_sequence->rend()",
          "new_text": null,
          "old_line_content": "      prev_allocation_it != allocation_sequence->rend() &&",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2145,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "*prev_allocation_it)->memory_space()",
          "new_text": null,
          "old_line_content": "      (*prev_allocation_it)->memory_space() == MemorySpace::kAlternate &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2147,
          "old_api": "requires_contiguous_allocation",
          "new_api": null,
          "old_text": "request.allocation_value->requires_contiguous_allocation()",
          "new_text": null,
          "old_line_content": "      !request.allocation_value->requires_contiguous_allocation()) {",
          "new_line_content": "  // Find a previous allocation that is in the default memory space (not",
          "content_same": false
        },
        {
          "line": 2155,
          "old_api": "rbegin",
          "new_api": null,
          "old_text": "allocation_sequence->rbegin()",
          "new_text": null,
          "old_line_content": "    prev_allocation_in_default_mem_it = allocation_sequence->rbegin();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2162,
          "old_api": "rbegin",
          "new_api": null,
          "old_text": "allocation_sequence->rbegin()",
          "new_text": null,
          "old_line_content": "    prev_allocation_in_default_mem_it = allocation_sequence->rbegin();",
          "new_line_content": "    // memory space, we also need to perform an eviction.",
          "content_same": false
        },
        {
          "line": 2165,
          "old_api": "rend",
          "new_api": null,
          "old_text": "allocation_sequence->rend()",
          "new_text": null,
          "old_line_content": "  CHECK(prev_allocation_in_default_mem_it != allocation_sequence->rend());",
          "new_line_content": "      // A non-success eviction requires us to uncommit previous allocations.",
          "content_same": false
        },
        {
          "line": 2173,
          "old_api": "Extend",
          "new_api": null,
          "old_text": "*prev_allocation_in_default_mem_it)->Extend(request.end_time)",
          "new_text": null,
          "old_line_content": "    (*prev_allocation_in_default_mem_it)->Extend(request.end_time);",
          "new_line_content": "            request.start_time, request.end_time,",
          "content_same": false
        },
        {
          "line": 125,
          "old_api": "end",
          "new_api": null,
          "old_text": "candidates.end()",
          "new_text": null,
          "old_line_content": "  if (best_candidate == candidates.end()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2174,
          "old_api": "AddUse",
          "new_api": null,
          "old_text": "*prev_allocation_in_default_mem_it)->AddUse(request.use->hlo_use)",
          "new_text": null,
          "old_line_content": "    (*prev_allocation_in_default_mem_it)->AddUse(request.use->hlo_use);",
          "new_line_content": "            /*is_scoped_allocation=*/false));",
          "content_same": false
        },
        {
          "line": 2181,
          "old_api": "Prefetch",
          "new_api": null,
          "old_text": "Prefetch(request, **prev_allocation_in_default_mem_it)",
          "new_text": null,
          "old_line_content": "        Prefetch(request, **prev_allocation_in_default_mem_it);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2185,
          "old_api": "result_mark",
          "new_api": null,
          "old_text": "result_mark(prefetch_result, allocation_result)",
          "new_text": null,
          "old_line_content": "    result_mark(prefetch_result, allocation_result);",
          "new_line_content": "        << \"Not trying to prefetch because use requires buffer in default mem.\";",
          "content_same": false
        },
        {
          "line": 142,
          "old_api": "CallGraph::Build(&module)",
          "new_api": null,
          "old_text": "CallGraph::Build(&module)",
          "new_text": null,
          "old_line_content": "  auto call_graph = CallGraph::Build(&module);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 143,
          "old_api": "absl::WrapUnique(new MemorySpaceAssignmentCostAnalysis(\n      cost_analysis, async_copy_bandwidth_bytes_per_second,\n      alternate_mem_bandwidth_bytes_per_second, std::move(alias_analysis),\n      std::move(hlo_live_range), std::move(call_graph)))",
          "new_api": null,
          "old_text": "absl::WrapUnique(new MemorySpaceAssignmentCostAnalysis(\n      cost_analysis, async_copy_bandwidth_bytes_per_second,\n      alternate_mem_bandwidth_bytes_per_second, std::move(alias_analysis),\n      std::move(hlo_live_range), std::move(call_graph)))",
          "new_text": null,
          "old_line_content": "  return absl::WrapUnique(new MemorySpaceAssignmentCostAnalysis(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2191,
          "old_api": "result_mark",
          "new_api": null,
          "old_text": "result_mark(Result::kFailRequiresUncommit, allocation_result)",
          "new_text": null,
          "old_line_content": "    return result_mark(Result::kFailRequiresUncommit, allocation_result);",
          "new_line_content": "  // Finally, try to prefetch the buffer into alternate memory.",
          "content_same": false
        },
        {
          "line": 145,
          "old_api": "std::move(alias_analysis)",
          "new_api": null,
          "old_text": "std::move(alias_analysis)",
          "new_text": null,
          "old_line_content": "      alternate_mem_bandwidth_bytes_per_second, std::move(alias_analysis),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 146,
          "old_api": "std::move(call_graph)",
          "new_api": null,
          "old_text": "std::move(call_graph)",
          "new_text": null,
          "old_line_content": "      std::move(hlo_live_range), std::move(call_graph)));",
          "new_line_content": "/*static*/ StatusOr<std::unique_ptr<MemorySpaceAssignmentCostAnalysis>>",
          "content_same": false
        },
        {
          "line": 2199,
          "old_api": "result_mark",
          "new_api": null,
          "old_text": "result_mark(Result::kFailRequiresUncommit, allocation_result)",
          "new_text": null,
          "old_line_content": "    return result_mark(Result::kFailRequiresUncommit, allocation_result);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 153,
          "old_api": "GetInstructionElapsedDueToCompute",
          "new_api": null,
          "old_text": "GetInstructionElapsedDueToCompute(instruction)",
          "new_text": null,
          "old_line_content": "      GetInstructionElapsedDueToCompute(instruction);",
          "new_line_content": "                      HloLiveRange::Run(module.schedule(), *alias_analysis,",
          "content_same": false
        },
        {
          "line": 2205,
          "old_api": "AddUse",
          "new_api": null,
          "old_text": "*prev_allocation_in_default_mem_it)->AddUse(request.use->hlo_use)",
          "new_text": null,
          "old_line_content": "  (*prev_allocation_in_default_mem_it)->AddUse(request.use->hlo_use);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 161,
          "old_api": "find",
          "new_api": null,
          "old_text": "cache->while_nest_multiplier.find(&instruction)",
          "new_text": null,
          "old_line_content": "      auto it = cache->while_nest_multiplier.find(&instruction);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 162,
          "old_api": "end",
          "new_api": null,
          "old_text": "cache->while_nest_multiplier.end()",
          "new_text": null,
          "old_line_content": "      if (it != cache->while_nest_multiplier.end()) {",
          "new_line_content": "float MemorySpaceAssignmentCostAnalysis::GetAlternateMemoryBenefit(",
          "content_same": false
        },
        {
          "line": 165,
          "old_api": "tensorflow::MathUtil::IPow<float>(\n            kWhileExecutionCount,\n            CalculateComputationNestLevel(&instruction,\n                                          /*while_only=*/true))",
          "new_api": null,
          "old_text": "tensorflow::MathUtil::IPow<float>(\n            kWhileExecutionCount,\n            CalculateComputationNestLevel(&instruction,\n                                          /*while_only=*/true))",
          "new_text": null,
          "old_line_content": "        while_nest_multiplier = tensorflow::MathUtil::IPow<float>(",
          "new_line_content": "  float elapsed_time_due_to_compute =",
          "content_same": false
        },
        {
          "line": 167,
          "old_api": "CalculateComputationNestLevel",
          "new_api": null,
          "old_text": "CalculateComputationNestLevel(&instruction,\n                                          /*while_only=*/true)",
          "new_text": null,
          "old_line_content": "            CalculateComputationNestLevel(&instruction,",
          "new_line_content": "  float elapsed_time_due_to_memory =",
          "content_same": false
        },
        {
          "line": 2215,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"Copy to \"",
          "new_line_content": "  // If a copy wasn't inserted, then add this use to the latest allocation in",
          "content_same": false
        },
        {
          "line": 172,
          "old_api": "tensorflow::MathUtil::IPow<float>(\n          kWhileExecutionCount,\n          CalculateComputationNestLevel(&instruction,\n                                        /*while_only=*/true))",
          "new_api": null,
          "old_text": "tensorflow::MathUtil::IPow<float>(\n          kWhileExecutionCount,\n          CalculateComputationNestLevel(&instruction,\n                                        /*while_only=*/true))",
          "new_text": null,
          "old_line_content": "      while_nest_multiplier = tensorflow::MathUtil::IPow<float>(",
          "new_line_content": "    if (cache) {",
          "content_same": false
        },
        {
          "line": 2221,
          "old_api": "CHECK_LT",
          "new_api": null,
          "old_text": "CHECK_LT(start_time, copy_done_schedule_before_time)",
          "new_text": null,
          "old_line_content": "  CHECK_LT(start_time, copy_done_schedule_before_time);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2223,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "allocations->push_back(\n      absl::make_unique<MemorySpaceAssignment::CopyAllocation>(\n          prev_allocation, memory_space, chunk, start_time, end_time,\n          copy_done_schedule_before_time, is_cross_program_prefetch))",
          "new_text": null,
          "old_line_content": "  allocations->push_back(",
          "new_line_content": "    const MemorySpaceAssignment::Allocation& prev_allocation,",
          "content_same": false
        },
        {
          "line": 2224,
          "old_api": "absl::make_unique<MemorySpaceAssignment::CopyAllocation>(\n          prev_allocation, memory_space, chunk, start_time, end_time,\n          copy_done_schedule_before_time, is_cross_program_prefetch)",
          "new_api": null,
          "old_text": "absl::make_unique<MemorySpaceAssignment::CopyAllocation>(\n          prev_allocation, memory_space, chunk, start_time, end_time,\n          copy_done_schedule_before_time, is_cross_program_prefetch)",
          "new_text": null,
          "old_line_content": "      absl::make_unique<MemorySpaceAssignment::CopyAllocation>(",
          "new_line_content": "    MemorySpace memory_space, absl::optional<Chunk> chunk, int64 start_time,",
          "content_same": false
        },
        {
          "line": 2230,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "pending_async_copies_.push_back(\n      {start_time, copy_done_schedule_before_time, memory_space})",
          "new_text": null,
          "old_line_content": "  pending_async_copies_.push_back(",
          "new_line_content": "                  ? \"default\"",
          "content_same": false
        },
        {
          "line": 2233,
          "old_api": "Add",
          "new_api": null,
          "old_text": "prefetch_interval_tree_.Add(start_time, copy_done_schedule_before_time,\n                                kDummyChunk)",
          "new_text": null,
          "old_line_content": "    prefetch_interval_tree_.Add(start_time, copy_done_schedule_before_time,",
          "new_line_content": "          << copy_done_schedule_before_time << \" keeping until \" << end_time;",
          "content_same": false
        },
        {
          "line": 2235,
          "old_api": "back",
          "new_api": null,
          "old_text": "pending_async_copies_.back()",
          "new_text": null,
          "old_line_content": "    async_copy_ordering_.AddCopy(pending_async_copies_.back());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 189,
          "old_api": "defining_instruction",
          "new_api": null,
          "old_text": "interval.buffer->defining_instruction()",
          "new_text": null,
          "old_line_content": "      *interval.buffer->defining_instruction();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 190,
          "old_api": "GetAlternateMemoryBenefit",
          "new_api": null,
          "old_text": "GetAlternateMemoryBenefit(\n      defining_instruction,\n      GetInstructionElapsedDueToMemory(defining_instruction,\n                                       /*operand_in_alternate_mem=*/{},\n                                       /*output_in_alternate_mem=*/true),\n      cache)",
          "new_text": null,
          "old_line_content": "  float alternate_mem_benefit = GetAlternateMemoryBenefit(",
          "new_line_content": "    return (elapsed_time_due_to_memory - elapsed_time_due_to_alternate_mem) *",
          "content_same": false
        },
        {
          "line": 2238,
          "old_api": "Add",
          "new_api": null,
          "old_text": "eviction_interval_tree_.Add(start_time, copy_done_schedule_before_time,\n                                kDummyChunk)",
          "new_text": null,
          "old_line_content": "    eviction_interval_tree_.Add(start_time, copy_done_schedule_before_time,",
          "new_line_content": "          prev_allocation, memory_space, chunk, start_time, end_time,",
          "content_same": false
        },
        {
          "line": 192,
          "old_api": "GetInstructionElapsedDueToMemory",
          "new_api": null,
          "old_text": "GetInstructionElapsedDueToMemory(defining_instruction,\n                                       /*operand_in_alternate_mem=*/{},\n                                       /*output_in_alternate_mem=*/true)",
          "new_text": null,
          "old_line_content": "      GetInstructionElapsedDueToMemory(defining_instruction,",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 196,
          "old_api": "ComputeBuffersAt",
          "new_api": null,
          "old_text": "alias_analysis_->ComputeBuffersAt(\n           interval.buffer->defining_position().instruction,\n           interval.buffer->defining_position().index)",
          "new_text": null,
          "old_line_content": "  for (const HloBuffer* buffer : alias_analysis_->ComputeBuffersAt(",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 197,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "interval.buffer->defining_position()",
          "new_text": null,
          "old_line_content": "           interval.buffer->defining_position().instruction,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 198,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "interval.buffer->defining_position()",
          "new_text": null,
          "old_line_content": "           interval.buffer->defining_position().index)) {",
          "new_line_content": "float MemorySpaceAssignmentCostAnalysis::GetMemoryBoundedness(",
          "content_same": false
        },
        {
          "line": 199,
          "old_api": "values",
          "new_api": null,
          "old_text": "buffer->values()",
          "new_text": null,
          "old_line_content": "    for (const HloValue* value : buffer->values()) {",
          "new_line_content": "    const GlobalDecreasingSizeBestFitHeap<HloValue>::BufferInterval& interval,",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": "uses",
          "new_api": null,
          "old_text": "value->uses()",
          "new_text": null,
          "old_line_content": "      for (const HloUse& use : value->uses()) {",
          "new_line_content": "    MemorySpaceAssignmentCostAnalysis::Cache* cache) const {",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "use.instruction->opcode()",
          "new_text": null,
          "old_line_content": "            use.instruction->opcode() == HloOpcode::kConditional) {",
          "new_line_content": "      defining_instruction,",
          "content_same": false
        },
        {
          "line": 208,
          "old_api": "GetAlternateMemoryBenefit",
          "new_api": null,
          "old_text": "GetAlternateMemoryBenefit(*use.instruction,\n                                      GetInstructionElapsedDueToMemory(\n                                          *use.instruction, use.operand_number),\n                                      cache)",
          "new_text": null,
          "old_line_content": "            GetAlternateMemoryBenefit(*use.instruction,",
          "new_line_content": "      cache);",
          "content_same": false
        },
        {
          "line": 2256,
          "old_api": "ChunksOverlappingInTime",
          "new_api": null,
          "old_text": "prefetch_interval_tree_.ChunksOverlappingInTime(start_time, end_time)\n            .size()",
          "new_text": null,
          "old_line_content": "        prefetch_interval_tree_.ChunksOverlappingInTime(start_time, end_time)",
          "new_line_content": "bool AlternateMemoryBestFitHeap::ViolatesMaximumOutstandingAsyncCopies(",
          "content_same": false
        },
        {
          "line": 2262,
          "old_api": "ChunksOverlappingInTime",
          "new_api": null,
          "old_text": "eviction_interval_tree_.ChunksOverlappingInTime(start_time, end_time)\n            .size()",
          "new_text": null,
          "old_line_content": "        eviction_interval_tree_.ChunksOverlappingInTime(start_time, end_time)",
          "new_line_content": "  if (options_.max_outstanding_evictions < 0 && !is_prefetch) {",
          "content_same": false
        },
        {
          "line": 219,
          "old_api": "std::max(alternate_mem_benefit, use_alternate_mem_benefit)",
          "new_api": null,
          "old_text": "std::max(alternate_mem_benefit, use_alternate_mem_benefit)",
          "new_text": null,
          "old_line_content": "              std::max(alternate_mem_benefit, use_alternate_mem_benefit);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2272,
          "old_api": "ViolatesOrdering",
          "new_api": null,
          "old_text": "async_copy_ordering_.ViolatesOrdering(start_time, end_time)",
          "new_text": null,
          "old_line_content": "  return async_copy_ordering_.ViolatesOrdering(start_time, end_time);",
          "new_line_content": "           options_.max_outstanding_prefetches + extra_async_copy_limit;",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": "std::sqrt(interval.size)",
          "new_api": null,
          "old_text": "std::sqrt(interval.size)",
          "new_text": null,
          "old_line_content": "  return alternate_mem_benefit / std::sqrt(interval.size);",
          "new_line_content": "        if (alternate_mem_benefit > 0 && use_alternate_mem_benefit > 0) {",
          "content_same": false
        },
        {
          "line": 2280,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "request.allocation_value->allocation_sequence()->empty()",
          "new_text": null,
          "old_line_content": "  if (request.allocation_value->allocation_sequence()->empty()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": "parent",
          "new_api": null,
          "old_text": "instruction->parent()",
          "new_text": null,
          "old_line_content": "  const HloComputation* computation = instruction->parent();",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 235,
          "old_api": "IsEntryComputation",
          "new_api": null,
          "old_text": "computation->IsEntryComputation()",
          "new_text": null,
          "old_line_content": "  while (!computation->IsEntryComputation()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": "GetNode",
          "new_api": null,
          "old_text": "call_graph_->GetNode(computation)",
          "new_text": null,
          "old_line_content": "    auto node = call_graph_->GetNode(computation);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": "caller_callsites",
          "new_api": null,
          "old_text": "node.caller_callsites()",
          "new_text": null,
          "old_line_content": "    auto callsites = node.caller_callsites();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 238,
          "old_api": "size",
          "new_api": null,
          "old_text": "callsites.size()",
          "new_text": null,
          "old_line_content": "    CHECK_EQ(callsites.size(), 1) << \"The module is not flattened!\";",
          "new_line_content": "  // Penalize larger buffers by dividing the benefit by the square root of the",
          "content_same": false
        },
        {
          "line": 2283,
          "old_api": "is_allowed_in_alternate_mem_fn",
          "new_api": null,
          "old_text": "options_.is_allowed_in_alternate_mem_fn(\n        *request.allocation_value->value())",
          "new_text": null,
          "old_line_content": "    can_eliminate_copy = options_.is_allowed_in_alternate_mem_fn(",
          "new_line_content": "AlternateMemoryBestFitHeap::ViolatesAsyncCopyOrdering(int64 start_time,",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": "instruction",
          "new_api": null,
          "old_text": "callsite.instruction()->opcode()",
          "new_text": null,
          "old_line_content": "    if (!while_only || callsite.instruction()->opcode() == HloOpcode::kWhile) {",
          "new_line_content": "  // to dividing by the size.",
          "content_same": false
        },
        {
          "line": 2284,
          "old_api": "value",
          "new_api": null,
          "old_text": "request.allocation_value->value()",
          "new_text": null,
          "old_line_content": "        *request.allocation_value->value());",
          "new_line_content": "                                                      int64 end_time) const {",
          "content_same": false
        },
        {
          "line": 2289,
          "old_api": "get",
          "new_api": null,
          "old_text": "request.allocation_value->allocation_sequence()->back().get()",
          "new_text": null,
          "old_line_content": "        request.allocation_value->allocation_sequence()->back().get();",
          "new_line_content": "AlternateMemoryBestFitHeap::AllocateInAlternateMemoryNoCopy(",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": "instruction",
          "new_api": null,
          "old_text": "callsite.instruction()->parent()",
          "new_text": null,
          "old_line_content": "    computation = callsite.instruction()->parent();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "prev_allocation->memory_space()",
          "new_text": null,
          "old_line_content": "        (prev_allocation->memory_space() == MemorySpace::kAlternate);",
          "new_line_content": "  MemorySpaceAssignment::Allocation* prev_allocation = nullptr;",
          "content_same": false
        },
        {
          "line": 2299,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "request.allocation_value->defining_position()",
          "new_text": null,
          "old_line_content": "      request.allocation_value->defining_position();",
          "new_line_content": "    // If there has been a previous allocation, we can eliminate the copy if the",
          "content_same": false
        },
        {
          "line": 252,
          "old_api": "per_second_rate",
          "new_api": null,
          "old_text": "cost_analysis_.per_second_rate(HloCostAnalysis::kFlopsKey)",
          "new_text": null,
          "old_line_content": "          cost_analysis_.per_second_rate(HloCostAnalysis::kFlopsKey),",
          "new_line_content": "    auto callsite = callsites[0];",
          "content_same": false
        },
        {
          "line": 2300,
          "old_api": "shape",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(\n          defining_position.shape(), request.start_time + 1,\n          request.end_time)",
          "new_text": null,
          "old_line_content": "  if (!options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(",
          "new_line_content": "    // previous allocation was also in the alternate memory.",
          "content_same": false
        },
        {
          "line": 254,
          "old_api": "per_second_rate",
          "new_api": null,
          "old_text": "cost_analysis_.per_second_rate(HloCostAnalysis::kTranscendentalsKey)",
          "new_text": null,
          "old_line_content": "          cost_analysis_.per_second_rate(HloCostAnalysis::kTranscendentalsKey));",
          "new_line_content": "      ++nest_level;",
          "content_same": false
        },
        {
          "line": 2301,
          "old_api": "shape",
          "new_api": null,
          "old_text": "defining_position.shape()",
          "new_text": null,
          "old_line_content": "          defining_position.shape(), request.start_time + 1,",
          "new_line_content": "    prev_allocation =",
          "content_same": false
        },
        {
          "line": 2307,
          "old_api": "value",
          "new_api": null,
          "old_text": "request.allocation_value->value()",
          "new_text": null,
          "old_line_content": "  alternate_mem_interval.buffer = request.allocation_value->value();",
          "new_line_content": "  if (!can_eliminate_copy) {",
          "content_same": false
        },
        {
          "line": 261,
          "old_api": "bytes_accessed",
          "new_api": null,
          "old_text": "cost_analysis_.bytes_accessed(instruction)",
          "new_text": null,
          "old_line_content": "  float bytes_accessed = cost_analysis_.bytes_accessed(instruction);",
          "new_line_content": "float MemorySpaceAssignmentCostAnalysis::GetInstructionElapsedDueToCompute(",
          "content_same": false
        },
        {
          "line": 2315,
          "old_api": "GetAliasedOffset",
          "new_api": null,
          "old_text": "GetAliasedOffset(*prev_allocation)",
          "new_text": null,
          "old_line_content": "    preferred_offset = GetAliasedOffset(*prev_allocation);",
          "new_line_content": "          request.end_time)) {",
          "content_same": false
        },
        {
          "line": 268,
          "old_api": "operand_bytes_accessed",
          "new_api": null,
          "old_text": "cost_analysis_.operand_bytes_accessed(\n        instruction, *operand_in_alternate_mem)",
          "new_text": null,
          "old_line_content": "    float operand_bytes_accessed = cost_analysis_.operand_bytes_accessed(",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2318,
          "old_api": "end_time",
          "new_api": null,
          "old_text": "prev_allocation->end_time()",
          "new_text": null,
          "old_line_content": "    alternate_mem_interval.start = prev_allocation->end_time() + 1;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": "per_second_rate",
          "new_api": null,
          "old_text": "cost_analysis_.per_second_rate(HloCostAnalysis::kBytesAccessedKey)",
          "new_text": null,
          "old_line_content": "            cost_analysis_.per_second_rate(HloCostAnalysis::kBytesAccessedKey);",
          "new_line_content": "      bytes_accessed /",
          "content_same": false
        },
        {
          "line": 2324,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(!preferred_offset || request.preferred_offset == preferred_offset)",
          "new_text": null,
          "old_line_content": "    CHECK(!preferred_offset || request.preferred_offset == preferred_offset)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": "output_bytes_accessed",
          "new_api": null,
          "old_text": "cost_analysis_.output_bytes_accessed(instruction)",
          "new_text": null,
          "old_line_content": "        cost_analysis_.output_bytes_accessed(instruction);",
          "new_line_content": "        instruction, *operand_in_alternate_mem);",
          "content_same": false
        },
        {
          "line": 2330,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"We can eliminate copy to alternate memory. Preferred offset = \"",
          "new_line_content": "    // of the previous allocation's end.",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": "GetInstructionElapsedDueToCompute",
          "new_api": null,
          "old_text": "GetInstructionElapsedDueToCompute(instruction)",
          "new_text": null,
          "old_line_content": "  return std::max(GetInstructionElapsedDueToCompute(instruction),",
          "new_line_content": "    float elapsed_due_to_output_bytes =",
          "content_same": false
        },
        {
          "line": 297,
          "old_api": "GetInstructionElapsedDueToMemory",
          "new_api": null,
          "old_text": "GetInstructionElapsedDueToMemory(instruction)",
          "new_text": null,
          "old_line_content": "                  GetInstructionElapsedDueToMemory(instruction));",
          "new_line_content": "        output_bytes_accessed / alternate_mem_bandwidth_bytes_per_second_;",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": "std::max(\n      GetInstructionElapsedDueToCompute(instruction),\n      GetInstructionElapsedDueToMemory(instruction, operand_in_alternate_mem,\n                                       output_in_alternate_mem))",
          "new_api": null,
          "old_text": "std::max(\n      GetInstructionElapsedDueToCompute(instruction),\n      GetInstructionElapsedDueToMemory(instruction, operand_in_alternate_mem,\n                                       output_in_alternate_mem))",
          "new_text": null,
          "old_line_content": "  return std::max(",
          "new_line_content": "  return elapsed_due_to_bytes;",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": "GetInstructionElapsedDueToCompute",
          "new_api": null,
          "old_text": "GetInstructionElapsedDueToCompute(instruction)",
          "new_text": null,
          "old_line_content": "      GetInstructionElapsedDueToCompute(instruction),",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": "GetInstructionElapsedDueToMemory",
          "new_api": null,
          "old_text": "GetInstructionElapsedDueToMemory(instruction, operand_in_alternate_mem,\n                                       output_in_alternate_mem)",
          "new_text": null,
          "old_line_content": "      GetInstructionElapsedDueToMemory(instruction, operand_in_alternate_mem,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2353,
          "old_api": "FindBestChunkCandidate",
          "new_api": null,
          "old_text": "FindBestChunkCandidate(\n      request, preferred_offset, &alternate_mem_interval)",
          "new_text": null,
          "old_line_content": "  absl::optional<ChunkCandidate> chunk_candidate = FindBestChunkCandidate(",
          "new_line_content": "  // New buffer:           |         |         |",
          "content_same": false
        },
        {
          "line": 2358,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \"Keep the buffer in alternate memory. Offset = \"",
          "new_line_content": "  //           --------------------------+-----------+------",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": "GetShapeSize",
          "new_api": null,
          "old_text": "cost_analysis_.GetShapeSize(shape)",
          "new_text": null,
          "old_line_content": "  int64 size_in_bytes = cost_analysis_.GetShapeSize(shape);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 313,
          "old_api": "static_cast<float>(size_in_bytes)",
          "new_api": null,
          "old_text": "static_cast<float>(size_in_bytes)",
          "new_text": null,
          "old_line_content": "  return static_cast<float>(size_in_bytes) /",
          "new_line_content": "float MemorySpaceAssignmentCostAnalysis::GetInstructionElapsedInAlternateMemory(",
          "content_same": false
        },
        {
          "line": 2363,
          "old_api": "shape",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->ToNoCopyDebugString(\n                   defining_position.shape(), request.start_time,\n                   request.end_time)",
          "new_text": null,
          "old_line_content": "            << options_.prefetch_interval_picker->ToNoCopyDebugString(",
          "new_line_content": "  // for the entire live range. This can result in unnecessary copies. By using",
          "content_same": false
        },
        {
          "line": 2364,
          "old_api": "shape",
          "new_api": null,
          "old_text": "defining_position.shape()",
          "new_text": null,
          "old_line_content": "                   defining_position.shape(), request.start_time,",
          "new_line_content": "  // the last use time, we try to find an allocation that is available for the",
          "content_same": false
        },
        {
          "line": 2372,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "prev_allocation->defining_position()",
          "new_text": null,
          "old_line_content": "         prev_allocation->defining_position() == defining_position)) {",
          "new_line_content": "            << chunk_candidate->chunk.offset",
          "content_same": false
        },
        {
          "line": 2373,
          "old_api": "Extend",
          "new_api": null,
          "old_text": "prev_allocation->Extend(request.end_time)",
          "new_text": null,
          "old_line_content": "      prev_allocation->Extend(request.end_time);",
          "new_line_content": "            << \", size = \" << chunk_candidate->chunk.size",
          "content_same": false
        },
        {
          "line": 2375,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "request.allocation_value->allocation_sequence()->push_back(\n          absl::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, MemorySpace::kAlternate,\n              chunk_candidate->chunk, request.start_time, request.end_time,\n              /*is_scoped_allocation=*/false))",
          "new_text": null,
          "old_line_content": "      request.allocation_value->allocation_sequence()->push_back(",
          "new_line_content": "            << \", prefetch picker = \"",
          "content_same": false
        },
        {
          "line": 328,
          "old_api": "std::min(start_time + min_overlap_count_, latest_end_time)",
          "new_api": null,
          "old_text": "std::min(start_time + min_overlap_count_, latest_end_time)",
          "new_text": null,
          "old_line_content": "  return std::min(start_time + min_overlap_count_, latest_end_time);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2380,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "CreateOrAddToAliasedOffset(\n          *request.allocation_value->allocation_sequence()->back(),\n          preferred_offset)",
          "new_text": null,
          "old_line_content": "      CreateOrAddToAliasedOffset(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2381,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "request.allocation_value->allocation_sequence()->back()",
          "new_text": null,
          "old_line_content": "          *request.allocation_value->allocation_sequence()->back(),",
          "new_line_content": "    // If there was a previous allocation, the buffer location is the",
          "content_same": false
        },
        {
          "line": 340,
          "old_api": "std::max(earliest_prefetch_start_time,\n                  prefetch_end_time - max_overlap_count_)",
          "new_api": null,
          "old_text": "std::max(earliest_prefetch_start_time,\n                  prefetch_end_time - max_overlap_count_)",
          "new_text": null,
          "old_line_content": "  return std::max(earliest_prefetch_start_time,",
          "new_line_content": "    const Shape& shape, int64 start_time, int64 latest_end_time) const {",
          "content_same": false
        },
        {
          "line": 2395,
          "old_api": "get",
          "new_api": null,
          "old_text": "request.allocation_value->allocation_sequence()->back().get()",
          "new_text": null,
          "old_line_content": "      request.allocation_value->allocation_sequence()->back().get();",
          "new_line_content": "          preferred_offset);",
          "content_same": false
        },
        {
          "line": 348,
          "old_api": "operand",
          "new_api": null,
          "old_text": "ShapeUtil::GetSubshape(\n      use.instruction->operand(use.operand_number)->shape(), use.operand_index)",
          "new_text": null,
          "old_line_content": "  const Shape& shape = ShapeUtil::GetSubshape(",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": "operand",
          "new_api": null,
          "old_text": "use.instruction->operand(use.operand_number)->shape()",
          "new_text": null,
          "old_line_content": "      use.instruction->operand(use.operand_number)->shape(), use.operand_index);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2396,
          "old_api": "start_time",
          "new_api": null,
          "old_text": "prev_allocation->start_time()",
          "new_text": null,
          "old_line_content": "  int64 eviction_start_time = prev_allocation->start_time();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": "PreferredPrefetchStartTime",
          "new_api": null,
          "old_text": "PreferredPrefetchStartTime(shape, start_time, end_time, end_time)",
          "new_text": null,
          "old_line_content": "      PreferredPrefetchStartTime(shape, start_time, end_time, end_time);",
          "new_line_content": "    const Shape& shape, int64 earliest_prefetch_start_time,",
          "content_same": false
        },
        {
          "line": 2398,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(eviction_start_time <= eviction_end_time)",
          "new_text": null,
          "old_line_content": "  CHECK(eviction_start_time <= eviction_end_time);",
          "new_line_content": "        request.use->hlo_use);",
          "content_same": false
        },
        {
          "line": 2401,
          "old_api": "shape",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->PreferredEvictionEndTime(\n                   request.allocation_value->defining_position().shape(),\n                   eviction_start_time, request.end_time)",
          "new_text": null,
          "old_line_content": "      std::max(options_.prefetch_interval_picker->PreferredEvictionEndTime(",
          "new_line_content": "  return Result::kFailOutOfMemory;",
          "content_same": false
        },
        {
          "line": 2402,
          "old_api": "shape",
          "new_api": null,
          "old_text": "request.allocation_value->defining_position().shape()",
          "new_text": null,
          "old_line_content": "                   request.allocation_value->defining_position().shape(),",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 355,
          "old_api": "Done",
          "new_api": null,
          "old_text": "Done()",
          "new_text": null,
          "old_line_content": "  CHECK(!Done()) << \"Prefetch interval picker's Next() is called even though \"",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2407,
          "old_api": "std::min(preferred_eviction_end_time, request.latest_prefetch_time)",
          "new_api": null,
          "old_text": "std::min(preferred_eviction_end_time, request.latest_prefetch_time)",
          "new_text": null,
          "old_line_content": "      std::min(preferred_eviction_end_time, request.latest_prefetch_time);",
          "new_line_content": "  MemorySpaceAssignment::Allocation* prev_allocation =",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": "absl::StrCat(\"Overlapped HLOs = \", end_time_ - current_prefetch_time_)",
          "new_api": null,
          "old_text": "absl::StrCat(\"Overlapped HLOs = \", end_time_ - current_prefetch_time_)",
          "new_text": null,
          "old_line_content": "  return absl::StrCat(\"Overlapped HLOs = \", end_time_ - current_prefetch_time_);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2416,
          "old_api": "chunk",
          "new_api": null,
          "old_text": "prev_allocation->chunk()",
          "new_text": null,
          "old_line_content": "  int64 preferred_offset = prev_allocation->chunk().offset;",
          "new_line_content": "                   eviction_start_time, request.end_time),",
          "content_same": false
        },
        {
          "line": 2417,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"Eviction (\" << eviction_start_time << \", \" << eviction_end_time",
          "new_line_content": "               eviction_end_time);",
          "content_same": false
        },
        {
          "line": 370,
          "old_api": "absl::StrCat(\"Overlapped HLOs = \", end_time - start_time)",
          "new_api": null,
          "old_text": "absl::StrCat(\"Overlapped HLOs = \", end_time - start_time)",
          "new_text": null,
          "old_line_content": "  return absl::StrCat(\"Overlapped HLOs = \", end_time - start_time);",
          "new_line_content": "  return current_prefetch_time_++;",
          "content_same": false
        },
        {
          "line": 2425,
          "old_api": "AddToPendingChunks",
          "new_api": null,
          "old_text": "AddToPendingChunks(eviction_mem_interval, chunk_candidate)",
          "new_text": null,
          "old_line_content": "      AddToPendingChunks(eviction_mem_interval, chunk_candidate);",
          "new_line_content": "  // Try to reserve a buffer from the end of the previous allocation to the",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": "hlo_live_range",
          "new_api": null,
          "old_text": "cost_analysis.hlo_live_range().instruction_schedule().size()",
          "new_text": null,
          "old_line_content": "          cost_analysis.hlo_live_range().instruction_schedule().size(), 0),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": "hlo_live_range",
          "new_api": null,
          "old_text": "cost_analysis.hlo_live_range().instruction_schedule().size()",
          "new_text": null,
          "old_line_content": "          cost_analysis.hlo_live_range().instruction_schedule().size(), 0),",
          "new_line_content": "    const Shape& shape, int64 start_time, int64 end_time) const {",
          "content_same": false
        },
        {
          "line": 2431,
          "old_api": "chunk",
          "new_api": null,
          "old_text": "prev_allocation->chunk()",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"Evicting buffer at \" << prev_allocation->chunk().offset << \" (\"",
          "new_line_content": "          << \") preferred end time = \" << eviction_mem_interval.end;",
          "content_same": false
        },
        {
          "line": 390,
          "old_api": "hlo_live_range",
          "new_api": null,
          "old_text": "cost_analysis_.hlo_live_range().instruction_schedule()",
          "new_text": null,
          "old_line_content": "      &cost_analysis_.hlo_live_range().instruction_schedule();",
          "new_line_content": "    float preferred_async_copy_to_overlap_ratio,",
          "content_same": false
        },
        {
          "line": 2442,
          "old_api": "Extend",
          "new_api": null,
          "old_text": "prev_allocation->Extend(eviction_end_time)",
          "new_text": null,
          "old_line_content": "    prev_allocation->Extend(eviction_end_time);",
          "new_line_content": "  eviction_end_time = eviction_mem_interval.end;",
          "content_same": false
        },
        {
          "line": 2443,
          "old_api": "end_time",
          "new_api": null,
          "old_text": "AddAsyncCopy(*prev_allocation, MemorySpace::kDefault,\n                 /*chunk=*/absl::nullopt, eviction_start_time,\n                 prev_allocation->end_time(), eviction_end_time,\n                 request.allocation_value->allocation_sequence(),\n                 /*aliased_offset=*/nullptr)",
          "new_text": null,
          "old_line_content": "    AddAsyncCopy(*prev_allocation, MemorySpace::kDefault,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 396,
          "old_api": "size",
          "new_api": null,
          "old_text": "instruction_schedule_->size()",
          "new_text": null,
          "old_line_content": "  std::vector<float> instructions_elapsed_time(instruction_schedule_->size(),",
          "new_line_content": "      cost_analysis_(cost_analysis),",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": "end_time",
          "new_api": null,
          "old_text": "prev_allocation->end_time()",
          "new_text": null,
          "old_line_content": "                 prev_allocation->end_time(), eviction_end_time,",
          "new_line_content": "          << eviction_start_time << \", \" << eviction_end_time << \")\";",
          "content_same": false
        },
        {
          "line": 2446,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "request.allocation_value->allocation_sequence()",
          "new_text": null,
          "old_line_content": "                 request.allocation_value->allocation_sequence(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2450,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \"This violates the maximum async copies.\";",
          "new_line_content": "                                            eviction_end_time,",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": "resize",
          "new_api": null,
          "old_text": "instructions_elapsed_time.resize(logical_time + 1, 0.0)",
          "new_text": null,
          "old_line_content": "      instructions_elapsed_time.resize(logical_time + 1, 0.0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": "resize",
          "new_api": null,
          "old_text": "while_nest_level_.resize(logical_time + 1, 0)",
          "new_text": null,
          "old_line_content": "      while_nest_level_.resize(logical_time + 1, 0);",
          "new_line_content": "  // Create a vector of elapsed times and while nesting levels of HLO",
          "content_same": false
        },
        {
          "line": 2452,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \"Eviction interval is too short (\" << eviction_start_time",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": "CalculateComputationNestLevel",
          "new_api": null,
          "old_text": "cost_analysis_.CalculateComputationNestLevel(\n        instruction_and_logical_time.first, /*while_only=*/true)",
          "new_text": null,
          "old_line_content": "    int while_nest_level = cost_analysis_.CalculateComputationNestLevel(",
          "new_line_content": "  // nest_level) to account for executing the HLOs multiple times in while",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": "CalculateComputationNestLevel",
          "new_api": null,
          "old_text": "cost_analysis_.CalculateComputationNestLevel(\n        instruction_and_logical_time.first, /*while_only=*/false)",
          "new_text": null,
          "old_line_content": "    int computation_nest_level = cost_analysis_.CalculateComputationNestLevel(",
          "new_line_content": "                                               0.0);",
          "content_same": false
        },
        {
          "line": 2460,
          "old_api": "ViolatesMaximumOutstandingAsyncCopies",
          "new_api": null,
          "old_text": "ViolatesMaximumOutstandingAsyncCopies(time, time + 1,\n                                                 /*is_prefetch=*/false)",
          "new_text": null,
          "old_line_content": "      if (!ViolatesMaximumOutstandingAsyncCopies(time, time + 1,",
          "new_line_content": "                 /*aliased_offset=*/nullptr);",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "instruction->opcode()",
          "new_text": null,
          "old_line_content": "    if (instruction->opcode() == HloOpcode::kWhile ||",
          "new_line_content": "    // conditional HLOs.",
          "content_same": false
        },
        {
          "line": 414,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "instruction->opcode()",
          "new_text": null,
          "old_line_content": "        instruction->opcode() == HloOpcode::kConditional) {",
          "new_line_content": "    const HloInstruction* instruction = instruction_and_logical_time.first;",
          "content_same": false
        },
        {
          "line": 2462,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "        VLOG(3) << \"Eviction successful.\";",
          "new_line_content": "    if (eviction_violates_outstanding_copies) {",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": "size",
          "new_api": null,
          "old_text": "instructions_elapsed_time.size()",
          "new_text": null,
          "old_line_content": "  elapsed_time_cumsum_.reserve(instructions_elapsed_time.size());",
          "new_line_content": "    computation_nest_level_[logical_time] = computation_nest_level;",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "elapsed_time_cumsum_.push_back(cumsum)",
          "new_text": null,
          "old_line_content": "    elapsed_time_cumsum_.push_back(cumsum);",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 2481,
          "old_api": "flattened_instruction_sequence",
          "new_api": null,
          "old_text": "hlo_live_range_.flattened_instruction_sequence()\n                     .instructions()",
          "new_text": null,
          "old_line_content": "              << hlo_live_range_.flattened_instruction_sequence()",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 435,
          "old_api": "size",
          "new_api": null,
          "old_text": "instructions_elapsed_time.size()",
          "new_text": null,
          "old_line_content": "  while_nest_level_change_.reserve(instructions_elapsed_time.size());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": "size",
          "new_api": null,
          "old_text": "while_nest_level_.size()",
          "new_text": null,
          "old_line_content": "  for (int i = 0; i < while_nest_level_.size(); ++i) {",
          "new_line_content": "  // As an optimization, create a cumulative sum vector of elapsed time.",
          "content_same": false
        },
        {
          "line": 442,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "while_nest_level_change_.push_back(change_idx)",
          "new_text": null,
          "old_line_content": "    while_nest_level_change_.push_back(change_idx);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2496,
          "old_api": "operand",
          "new_api": null,
          "old_text": "ShapeUtil::GetSubshape(\n      use.instruction->operand(use.operand_number)->shape(), use.operand_index)",
          "new_text": null,
          "old_line_content": "  const Shape& shape = ShapeUtil::GetSubshape(",
          "new_line_content": "      // return false;",
          "content_same": false
        },
        {
          "line": 2497,
          "old_api": "operand",
          "new_api": null,
          "old_text": "use.instruction->operand(use.operand_number)->shape()",
          "new_text": null,
          "old_line_content": "      use.instruction->operand(use.operand_number)->shape(), use.operand_index);",
          "new_line_content": "      return Result::kFailOutOfAsyncCopies;",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": "ShapeUtil::MakeShape(\n                      S32, {buffer_size_for_max_async_copy_ / 4})",
          "new_api": null,
          "old_text": "ShapeUtil::MakeShape(\n                      S32, {buffer_size_for_max_async_copy_ / 4})",
          "new_text": null,
          "old_line_content": "                  cost_analysis_.GetAsyncCopyElapsed(ShapeUtil::MakeShape(",
          "new_line_content": "    int nest_level = while_nest_level_[i];",
          "content_same": false
        },
        {
          "line": 2502,
          "old_api": "LatestPrefetchStartTime",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->LatestPrefetchStartTime(\n            shape, earliest_prefetch_time, prefetch_end_time, &use)",
          "new_text": null,
          "old_line_content": "        options_.prefetch_interval_picker->LatestPrefetchStartTime(",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2504,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(4)",
          "new_text": null,
          "old_line_content": "    VLOG(4) << \"Latest prefetch start time = \" << latest_prefetch_time",
          "new_line_content": "int64 AlternateMemoryBestFitHeap::FindPrefetchEndTime(",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": "GetAsyncCopyElapsed",
          "new_api": null,
          "old_text": "cost_analysis_.GetAsyncCopyElapsed(shape)",
          "new_text": null,
          "old_line_content": "  float async_copy_elapsed = cost_analysis_.GetAsyncCopyElapsed(shape);",
          "new_line_content": "float CostAnalysisPrefetchIntervalPicker::GetMaxElapsedInAlternateMemory(",
          "content_same": false
        },
        {
          "line": 461,
          "old_api": "GetLogicalIntervalElapsed",
          "new_api": null,
          "old_text": "GetLogicalIntervalElapsed(start_time, end_time)",
          "new_text": null,
          "old_line_content": "      GetLogicalIntervalElapsed(start_time, end_time);",
          "new_line_content": "  return max_async_copy_to_overlap_ratio_ *",
          "content_same": false
        },
        {
          "line": 468,
          "old_api": "GetAsyncCopyElapsed",
          "new_api": null,
          "old_text": "cost_analysis_.GetAsyncCopyElapsed(shape)",
          "new_text": null,
          "old_line_content": "  float async_copy_elapsed = cost_analysis_.GetAsyncCopyElapsed(shape);",
          "new_line_content": "    const Shape& shape, int64 start_time, int64 end_time) const {",
          "content_same": false
        },
        {
          "line": 2516,
          "old_api": "ViolatesAsyncCopyOrdering",
          "new_api": null,
          "old_text": "ViolatesAsyncCopyOrdering(latest_prefetch_time, prefetch_end_time)",
          "new_text": null,
          "old_line_content": "        ViolatesAsyncCopyOrdering(latest_prefetch_time, prefetch_end_time);",
          "new_line_content": "            shape, earliest_prefetch_time, prefetch_end_time, &use);",
          "content_same": false
        },
        {
          "line": 2521,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(4)",
          "new_text": null,
          "old_line_content": "    VLOG(4) << \"Violating async copy: (\" << violating_async_copy->start_time",
          "new_line_content": "    if (latest_prefetch_time < earliest_prefetch_time) {",
          "content_same": false
        },
        {
          "line": 2525,
          "old_api": "LatestPrefetchEndTime",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->LatestPrefetchEndTime(\n            prefetch_end_time, violating_async_copy->end_time)",
          "new_text": null,
          "old_line_content": "        options_.prefetch_interval_picker->LatestPrefetchEndTime(",
          "new_line_content": "    // Return either if there is no other violating asynchronous copy (since we",
          "content_same": false
        },
        {
          "line": 2528,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \"Update prefetch end time = \" << new_prefetch_end_time;",
          "new_line_content": "    auto violating_async_copy =",
          "content_same": false
        },
        {
          "line": 2531,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \"Can't update prefetch end time = \" << new_prefetch_end_time",
          "new_line_content": "        violating_async_copy->end_time >= prefetch_end_time) {",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": "GetInstructionElapsed",
          "new_api": null,
          "old_text": "cost_analysis_.GetInstructionElapsed(*use->instruction)",
          "new_text": null,
          "old_line_content": "        cost_analysis_.GetInstructionElapsed(*use->instruction);",
          "new_line_content": "  return end_time;",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": "GetInstructionElapsedInAlternateMemory",
          "new_api": null,
          "old_text": "cost_analysis_.GetInstructionElapsedInAlternateMemory(\n            *use->instruction, use->operand_number,\n            /*output_in_alternate_mem=*/false)",
          "new_text": null,
          "old_line_content": "        cost_analysis_.GetInstructionElapsedInAlternateMemory(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": "GetLogicalIntervalElapsed",
          "new_api": null,
          "old_text": "GetLogicalIntervalElapsed(latest_prefetch_time, end_time)",
          "new_text": null,
          "old_line_content": "            GetLogicalIntervalElapsed(latest_prefetch_time, end_time) +",
          "new_line_content": "            *use->instruction, use->operand_number,",
          "content_same": false
        },
        {
          "line": 2557,
          "old_api": "earliest_available_time",
          "new_api": null,
          "old_text": "prev_allocation_in_default_mem.earliest_available_time()",
          "new_text": null,
          "old_line_content": "      prev_allocation_in_default_mem.earliest_available_time();",
          "new_line_content": "  // Try partially placing the buffer in the alternate space. The time that is",
          "content_same": false
        },
        {
          "line": 2560,
          "old_api": "std::max(earliest_prefetch_time, *request.earliest_prefetch_time)",
          "new_api": null,
          "old_text": "std::max(earliest_prefetch_time, *request.earliest_prefetch_time)",
          "new_text": null,
          "old_line_content": "        std::max(earliest_prefetch_time, *request.earliest_prefetch_time);",
          "new_line_content": "  //",
          "content_same": false
        },
        {
          "line": 2563,
          "old_api": "FindPrefetchEndTime",
          "new_api": null,
          "old_text": "FindPrefetchEndTime(request, earliest_prefetch_time)",
          "new_text": null,
          "old_line_content": "      FindPrefetchEndTime(request, earliest_prefetch_time);",
          "new_line_content": "  //                      X---------------------X",
          "content_same": false
        },
        {
          "line": 2565,
          "old_api": "Begin",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->Begin(\n      request.use->hlo_use, earliest_prefetch_time, prefetch_end_time)",
          "new_text": null,
          "old_line_content": "  options_.prefetch_interval_picker->Begin(",
          "new_line_content": "  // Default:             +---------------------+",
          "content_same": false
        },
        {
          "line": 2567,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"Trying prefetch picker = \"",
          "new_line_content": "  //                                   Copy    Copy",
          "content_same": false
        },
        {
          "line": 2568,
          "old_api": "ToDebugString",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->ToDebugString()",
          "new_text": null,
          "old_line_content": "          << options_.prefetch_interval_picker->ToDebugString();",
          "new_line_content": "  //                                   Start   Done",
          "content_same": false
        },
        {
          "line": 524,
          "old_api": "GetLogicalIntervalElapsed",
          "new_api": null,
          "old_text": "GetLogicalIntervalElapsed(earliest_prefetch_start_time,\n                                                  prefetch_end_time)",
          "new_text": null,
          "old_line_content": "  float best_interval = GetLogicalIntervalElapsed(earliest_prefetch_start_time,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2577,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "request.use->hlo_use.instruction->opcode()",
          "new_text": null,
          "old_line_content": "      request.use->hlo_use.instruction->opcode() == HloOpcode::kWhile",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": "GetLogicalIntervalElapsed",
          "new_api": null,
          "old_text": "GetLogicalIntervalElapsed(prefetch_start_time, prefetch_end_time)",
          "new_text": null,
          "old_line_content": "        GetLogicalIntervalElapsed(prefetch_start_time, prefetch_end_time);",
          "new_line_content": "  // Between the earliest and latest prefetch interval, find the interval",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": "std::abs(preferred_interval - best_interval)",
          "new_api": null,
          "old_text": "std::abs(preferred_interval - best_interval)",
          "new_text": null,
          "old_line_content": "            std::abs(preferred_interval - best_interval)) {",
          "new_line_content": "  int64 preferred_prefetch_start_time = earliest_prefetch_start_time;",
          "content_same": false
        },
        {
          "line": 2582,
          "old_api": "Next",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->Next()",
          "new_text": null,
          "old_line_content": "    alternate_mem_interval.start = options_.prefetch_interval_picker->Next();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2583,
          "old_api": "CHECK_LT",
          "new_api": null,
          "old_text": "CHECK_LT(alternate_mem_interval.start, prefetch_end_time)",
          "new_text": null,
          "old_line_content": "    CHECK_LT(alternate_mem_interval.start, prefetch_end_time);",
          "new_line_content": "  // Create an alternate memory interval that starts at the earliest",
          "content_same": false
        },
        {
          "line": 2584,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(4)",
          "new_text": null,
          "old_line_content": "    VLOG(4) << \"Trying alternate memory allocation (\"",
          "new_line_content": "  // possible position, given by max_prefetch_interval.",
          "content_same": false
        },
        {
          "line": 2588,
          "old_api": "ViolatesAsyncCopyOrdering",
          "new_api": null,
          "old_text": "ViolatesAsyncCopyOrdering(alternate_mem_interval.start,\n                                  prefetch_end_time)",
          "new_text": null,
          "old_line_content": "    if (ViolatesAsyncCopyOrdering(alternate_mem_interval.start,",
          "new_line_content": "  // While uses might be allowed to have additional outstanding prefetches.",
          "content_same": false
        },
        {
          "line": 2591,
          "old_api": "result_mark",
          "new_api": null,
          "old_text": "result_mark(Result::kFailViolatesAsyncCopyOrdering, result)",
          "new_text": null,
          "old_line_content": "      result_mark(Result::kFailViolatesAsyncCopyOrdering, result);",
          "new_line_content": "          ? options_.while_use_extra_outstanding_prefetch_limit",
          "content_same": false
        },
        {
          "line": 2598,
          "old_api": "result_mark",
          "new_api": null,
          "old_text": "result_mark(Result::kFailOutOfAsyncCopies, result)",
          "new_text": null,
          "old_line_content": "      result_mark(Result::kFailOutOfAsyncCopies, result);",
          "new_line_content": "            << alternate_mem_interval.start << \", \" << request.end_time << \")\";",
          "content_same": false
        },
        {
          "line": 2602,
          "old_api": "FindBestChunkCandidate",
          "new_api": null,
          "old_text": "FindBestChunkCandidate(\n        request, request.preferred_offset, &alternate_mem_interval)",
          "new_text": null,
          "old_line_content": "    auto chunk_candidate = FindBestChunkCandidate(",
          "new_line_content": "                                  prefetch_end_time)) {",
          "content_same": false
        },
        {
          "line": 2606,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \"Move the buffer to alternate memory at \"",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 559,
          "old_api": "operand",
          "new_api": null,
          "old_text": "ShapeUtil::GetSubshape(\n      use.instruction->operand(use.operand_number)->shape(), use.operand_index)",
          "new_text": null,
          "old_line_content": "  const Shape& shape = ShapeUtil::GetSubshape(",
          "new_line_content": "  int64 original_nest_level =",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": "operand",
          "new_api": null,
          "old_text": "use.instruction->operand(use.operand_number)->shape()",
          "new_text": null,
          "old_line_content": "      use.instruction->operand(use.operand_number)->shape(), use.operand_index);",
          "new_line_content": "      computation_nest_level_[original_prefetch_end_time];",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": "GetAsyncCopyElapsed",
          "new_api": null,
          "old_text": "cost_analysis_.GetAsyncCopyElapsed(shape)",
          "new_text": null,
          "old_line_content": "  async_copy_elapsed_ = cost_analysis_.GetAsyncCopyElapsed(shape);",
          "new_line_content": "  for (new_prefetch_end_time = proposed_prefetch_end_time;",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": "GetInstructionElapsed",
          "new_api": null,
          "old_text": "cost_analysis_.GetInstructionElapsed(*use.instruction)",
          "new_text": null,
          "old_line_content": "  float elapsed_time = cost_analysis_.GetInstructionElapsed(*use.instruction);",
          "new_line_content": "       --new_prefetch_end_time) {",
          "content_same": false
        },
        {
          "line": 2612,
          "old_api": "ToDebugString",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->ToDebugString()",
          "new_text": null,
          "old_line_content": "              << options_.prefetch_interval_picker->ToDebugString();",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": "GetInstructionElapsedInAlternateMemory",
          "new_api": null,
          "old_text": "cost_analysis_.GetInstructionElapsedInAlternateMemory(\n          *use.instruction, use.operand_number,\n          /*output_in_alternate_mem=*/false)",
          "new_text": null,
          "old_line_content": "      cost_analysis_.GetInstructionElapsedInAlternateMemory(",
          "new_line_content": "  return new_prefetch_end_time;",
          "content_same": false
        },
        {
          "line": 2613,
          "old_api": "AddToPendingChunks",
          "new_api": null,
          "old_text": "AddToPendingChunks(alternate_mem_interval, *chunk_candidate)",
          "new_text": null,
          "old_line_content": "      AddToPendingChunks(alternate_mem_interval, *chunk_candidate);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2618,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "request.allocation_value->allocation_sequence()",
          "new_text": null,
          "old_line_content": "                   request.allocation_value->allocation_sequence(),",
          "new_line_content": "    if (chunk_candidate) {",
          "content_same": false
        },
        {
          "line": 2621,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "request.allocation_value->allocation_sequence()->back()->AddUse(\n          request.use->hlo_use)",
          "new_text": null,
          "old_line_content": "      request.allocation_value->allocation_sequence()->back()->AddUse(",
          "new_line_content": "              << \". Offset = \" << chunk_candidate->chunk.offset",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": "LatestPrefetchStartTime",
          "new_api": null,
          "old_text": "LatestPrefetchStartTime(shape, start_time, end_time, &use)",
          "new_text": null,
          "old_line_content": "      LatestPrefetchStartTime(shape, start_time, end_time, &use);",
          "new_line_content": "  // Estimate the time we would save by having this op in alternate memory.",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": "GetLogicalIntervalElapsed",
          "new_api": null,
          "old_text": "GetLogicalIntervalElapsed(earliest_prefetch_time_,\n                                                 end_logical_time_)",
          "new_text": null,
          "old_line_content": "        max_interval < GetLogicalIntervalElapsed(earliest_prefetch_time_,",
          "new_line_content": "  end_logical_time_ = end_time;",
          "content_same": false
        },
        {
          "line": 2644,
          "old_api": "begin",
          "new_api": null,
          "old_text": "use_times.begin()",
          "new_text": null,
          "old_line_content": "    auto use_time_it = use_times.begin();",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 2647,
          "old_api": "end",
          "new_api": null,
          "old_text": "use_times.end()",
          "new_text": null,
          "old_line_content": "    CHECK(use_time_it != use_times.end());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 600,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(4)",
          "new_text": null,
          "old_line_content": "  VLOG(4) << \"Interval min/max/preferred = \" << min_interval << \" \"",
          "new_line_content": "  if (earliest_prefetch_time_ > latest_prefetch_time_) {",
          "content_same": false
        },
        {
          "line": 2652,
          "old_api": "shape",
          "new_api": null,
          "old_text": "request.allocation_value->defining_position().shape()",
          "new_text": null,
          "old_line_content": "    const Shape& shape = request.allocation_value->defining_position().shape();",
          "new_line_content": "    BufferInterval* alternate_mem_interval) const {",
          "content_same": false
        },
        {
          "line": 2654,
          "old_api": "end",
          "new_api": null,
          "old_text": "use_times.end()",
          "new_text": null,
          "old_line_content": "         (use_time_it + 1) != use_times.end() &&",
          "new_line_content": "  if (!preferred_offset) {",
          "content_same": false
        },
        {
          "line": 2655,
          "old_api": "CanAllocateInAlternateMemoryNoCopy",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(\n             shape, *use_time_it, *(use_time_it + 1))",
          "new_text": null,
          "old_line_content": "         options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(",
          "new_line_content": "    // First find the earliest use that is the same or later than the end time.",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": "Next",
          "new_api": null,
          "old_text": "Next()",
          "new_text": null,
          "old_line_content": "  Next();",
          "new_line_content": "  float preferred_interval =",
          "content_same": false
        },
        {
          "line": 2659,
          "old_api": "end",
          "new_api": null,
          "old_text": "use_times.end()",
          "new_text": null,
          "old_line_content": "    CHECK(use_time_it != use_times.end());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 615,
          "old_api": "Done",
          "new_api": null,
          "old_text": "Done()",
          "new_text": null,
          "old_line_content": "  CHECK(!Done()) << \"Prefetch interval picker's Next() is called even though \"",
          "new_line_content": "          << \" prefetch time earliest/latest/starting = \"",
          "content_same": false
        },
        {
          "line": 2664,
          "old_api": "begin",
          "new_api": null,
          "old_text": "use_times.begin()",
          "new_text": null,
          "old_line_content": "    for (; use_time_it >= use_times.begin() && *use_time_it >= end_time;",
          "new_line_content": "    // copies.",
          "content_same": false
        },
        {
          "line": 2669,
          "old_api": "available_heap_size",
          "new_api": null,
          "old_text": "available_heap_size()",
          "new_text": null,
          "old_line_content": "      if (chunk_candidate.heap_size <= available_heap_size()) {",
          "new_line_content": "             shape, *use_time_it, *(use_time_it + 1));",
          "content_same": false
        },
        {
          "line": 2671,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "        VLOG(3) << \"FindBestChunkCandidate earliest use = \" << earliest_use",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2685,
          "old_api": "FindChunkCandidate",
          "new_api": null,
          "old_text": "FindChunkCandidate(*alternate_mem_interval, preferred_offset->offset)",
          "new_text": null,
          "old_line_content": "      FindChunkCandidate(*alternate_mem_interval, preferred_offset->offset);",
          "new_line_content": "                << \", latest contiguous use = \" << latest_contiguous_use_time",
          "content_same": false
        },
        {
          "line": 2701,
          "old_api": "TF_ASSIGN_OR_RETURN",
          "new_api": null,
          "old_text": "TF_ASSIGN_OR_RETURN(std::unique_ptr<HloDataflowAnalysis> dataflow_analysis,\n                      HloDataflowAnalysis::Run(*module_))",
          "new_text": null,
          "old_line_content": "  TF_ASSIGN_OR_RETURN(std::unique_ptr<HloDataflowAnalysis> dataflow_analysis,",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2702,
          "old_api": "HloDataflowAnalysis::Run(*module_)",
          "new_api": null,
          "old_text": "HloDataflowAnalysis::Run(*module_)",
          "new_text": null,
          "old_line_content": "                      HloDataflowAnalysis::Run(*module_));",
          "new_line_content": "  return absl::nullopt;",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": "std::min(while_nest_level_[start_time], while_nest_level_[end_time])",
          "new_api": null,
          "old_text": "std::min(while_nest_level_[start_time], while_nest_level_[end_time])",
          "new_text": null,
          "old_line_content": "      std::min(while_nest_level_[start_time], while_nest_level_[end_time]);",
          "new_line_content": "bool CostAnalysisPrefetchIntervalPicker::Done() const {",
          "content_same": false
        },
        {
          "line": 2704,
          "old_api": "MakeNonfusionComputations",
          "new_api": null,
          "old_text": "module_->MakeNonfusionComputations()",
          "new_text": null,
          "old_line_content": "       module_->MakeNonfusionComputations()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2705,
          "old_api": "instructions",
          "new_api": null,
          "old_text": "computation->instructions()",
          "new_text": null,
          "old_line_content": "    for (HloInstruction* instruction : computation->instructions()) {",
          "new_line_content": "StatusOr<MemorySpaceAssignment::AsyncCopyStats>",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": "std::min(min_nest_level, while_nest_level_[change_idx])",
          "new_api": null,
          "old_text": "std::min(min_nest_level, while_nest_level_[change_idx])",
          "new_text": null,
          "old_line_content": "    min_nest_level = std::min(min_nest_level, while_nest_level_[change_idx]);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2706,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "instruction->opcode()",
          "new_text": null,
          "old_line_content": "      if (instruction->opcode() == HloOpcode::kCopyStart) {",
          "new_line_content": "MemorySpaceAssignment::CalculateAsyncCopyStats() const {",
          "content_same": false
        },
        {
          "line": 2708,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "instruction->opcode()",
          "new_text": null,
          "old_line_content": "      } else if (instruction->opcode() == HloOpcode::kCopyDone) {",
          "new_line_content": "  stats.max_outstanding_async_copies = 0;",
          "content_same": false
        },
        {
          "line": 2711,
          "old_api": "GetUniqueValueAt",
          "new_api": null,
          "old_text": "dataflow_analysis->GetUniqueValueAt(instruction)",
          "new_text": null,
          "old_line_content": "            options_.size_fn(dataflow_analysis->GetUniqueValueAt(instruction));",
          "new_line_content": "  stats.num_evictions = 0;",
          "content_same": false
        },
        {
          "line": 2712,
          "old_api": "layout",
          "new_api": null,
          "old_text": "instruction->shape().layout().memory_space()",
          "new_text": null,
          "old_line_content": "        if (instruction->shape().layout().memory_space() ==",
          "new_line_content": "  stats.eviction_bytes = 0;",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": "CHECK_LE",
          "new_api": null,
          "old_text": "CHECK_LE(start_time, end_time)",
          "new_text": null,
          "old_line_content": "  CHECK_LE(start_time, end_time);",
          "new_line_content": "    int64 start_time, int64 end_time) const {",
          "content_same": false
        },
        {
          "line": 2722,
          "old_api": "std::max(stats.max_outstanding_async_copies, current_copies)",
          "new_api": null,
          "old_text": "std::max(stats.max_outstanding_async_copies, current_copies)",
          "new_text": null,
          "old_line_content": "          std::max(stats.max_outstanding_async_copies, current_copies);",
          "new_line_content": "        current_copies--;",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": "GetMinWhileNestLevel",
          "new_api": null,
          "old_text": "GetMinWhileNestLevel(start_time, end_time)",
          "new_text": null,
          "old_line_content": "  int interval_while_nest_level = GetMinWhileNestLevel(start_time, end_time);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2734,
          "old_api": "GetMemoryBoundedness",
          "new_api": null,
          "old_text": "cost_analysis.GetMemoryBoundedness(x, cache)",
          "new_text": null,
          "old_line_content": "    float x_memory_boundedness = cost_analysis.GetMemoryBoundedness(x, cache);",
          "new_line_content": "      stats.max_outstanding_async_copies =",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "GetLogicalIntervalElapsed",
          "new_api": null,
          "old_text": "GetLogicalIntervalElapsed(\n      current_logical_prefetch_time, end_logical_time_)",
          "new_text": null,
          "old_line_content": "  float logical_interval_elapsed = GetLogicalIntervalElapsed(",
          "new_line_content": "  // level, normalize the elapsed time by dividing with the nesting factor of",
          "content_same": false
        },
        {
          "line": 2740,
          "old_api": "GlobalDecreasingSizeBestFitHeap<\n        HloValue>::GetSpatialBufferIntervalCompare()(x, y)",
          "new_api": null,
          "old_text": "GlobalDecreasingSizeBestFitHeap<\n        HloValue>::GetSpatialBufferIntervalCompare()(x, y)",
          "new_text": null,
          "old_line_content": "    return GlobalDecreasingSizeBestFitHeap<",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 699,
          "old_api": "GetAsyncCopyElapsed",
          "new_api": null,
          "old_text": "cost_analysis_.GetAsyncCopyElapsed(shape)",
          "new_text": null,
          "old_line_content": "  float async_copy_elapsed = cost_analysis_.GetAsyncCopyElapsed(shape);",
          "new_line_content": "                                          : decreasing_prefetch_time_iterator_;",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": "GetLogicalIntervalElapsed",
          "new_api": null,
          "old_text": "GetLogicalIntervalElapsed(start_time, end_time)",
          "new_text": null,
          "old_line_content": "      GetLogicalIntervalElapsed(start_time, end_time);",
          "new_line_content": "      current_logical_prefetch_time, end_logical_time_);",
          "content_same": false
        },
        {
          "line": 2751,
          "old_api": "has_schedule",
          "new_api": null,
          "old_text": "module->has_schedule()",
          "new_text": null,
          "old_line_content": "  CHECK(module->has_schedule());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2752,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"Module before memory space assignment: \";",
          "new_line_content": "    // Tie-break if the memory boundedness is the same.",
          "content_same": false
        },
        {
          "line": 2754,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "module->schedule().ToString()",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"Schedule: \" << module->schedule().ToString();",
          "new_line_content": "        HloValue>::GetSpatialBufferIntervalCompare()(x, y);",
          "content_same": false
        },
        {
          "line": 2758,
          "old_api": "RunMemorySpaceAssignment",
          "new_api": null,
          "old_text": "memory_space_assignment.RunMemorySpaceAssignment(hlo_live_range,\n                                                          alias_analysis)",
          "new_text": null,
          "old_line_content": "  return memory_space_assignment.RunMemorySpaceAssignment(hlo_live_range,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": "GetMemoryBoundedness",
          "new_api": null,
          "old_text": "cost_analysis_.GetMemoryBoundedness(interval)",
          "new_text": null,
          "old_line_content": "  return cost_analysis_.GetMemoryBoundedness(interval);",
          "new_line_content": "    const Shape& shape, int64 start_time, int64 end_time) const {",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "other.defining_position()",
          "new_text": null,
          "old_line_content": "  return defining_position() == other.defining_position() &&",
          "new_line_content": "      \"Async copy elapsed (s) = \", async_copy_elapsed,",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "other.memory_space()",
          "new_text": null,
          "old_line_content": "         uses() == other.uses() && memory_space() == other.memory_space() &&",
          "new_line_content": "      \", logical interval elapsed (s) = \", logical_interval_elapsed);",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": "start_time",
          "new_api": null,
          "old_text": "other.start_time()",
          "new_text": null,
          "old_line_content": "         chunk() == other.chunk() && start_time() == other.start_time() &&",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": "end_time",
          "new_api": null,
          "old_text": "other.end_time()",
          "new_text": null,
          "old_line_content": "         end_time() == other.end_time() &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": "is_copy_allocation",
          "new_api": null,
          "old_text": "other.is_copy_allocation()",
          "new_text": null,
          "old_line_content": "         is_copy_allocation() == other.is_copy_allocation() &&",
          "new_line_content": "absl::optional<float>",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": "is_scoped_allocation",
          "new_api": null,
          "old_text": "other.is_scoped_allocation()",
          "new_text": null,
          "old_line_content": "         is_scoped_allocation() == other.is_scoped_allocation();",
          "new_line_content": "CostAnalysisPrefetchIntervalPicker::BufferIntervalAlternateMemoryBenefit(",
          "content_same": false
        },
        {
          "line": 2770,
          "old_api": "FixSchedule",
          "new_api": null,
          "old_text": "FixSchedule()",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(FixSchedule());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2768,
          "old_api": "ScheduleAsynchronousCopies",
          "new_api": null,
          "old_text": "ScheduleAsynchronousCopies()",
          "new_text": null,
          "old_line_content": "  ScheduleAsynchronousCopies();",
          "new_line_content": "  MemorySpaceAssignment memory_space_assignment(module, options,",
          "content_same": false
        },
        {
          "line": 2769,
          "old_api": "SimplifyGraph",
          "new_api": null,
          "old_text": "SimplifyGraph()",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(SimplifyGraph());",
          "new_line_content": "                                                hlo_live_range);",
          "content_same": false
        },
        {
          "line": 2773,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"Module after memory space assignment: \";",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": "static_cast<const Allocation&>(*this)",
          "new_api": null,
          "old_text": "static_cast<const Allocation&>(*this)",
          "new_text": null,
          "old_line_content": "  return static_cast<const Allocation&>(*this) ==",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 727,
          "old_api": "static_cast<const Allocation&>(other)",
          "new_api": null,
          "old_text": "static_cast<const Allocation&>(other)",
          "new_text": null,
          "old_line_content": "             static_cast<const Allocation&>(other) &&",
          "new_line_content": "bool MemorySpaceAssignment::Allocation::operator==(",
          "content_same": false
        },
        {
          "line": 728,
          "old_api": "copy_done_schedule_before",
          "new_api": null,
          "old_text": "other.copy_done_schedule_before()",
          "new_text": null,
          "old_line_content": "         copy_done_schedule_before() == other.copy_done_schedule_before() &&",
          "new_line_content": "    const MemorySpaceAssignment::Allocation& other) const {",
          "content_same": false
        },
        {
          "line": 2775,
          "old_api": "Verify",
          "new_api": null,
          "old_text": "module_->schedule().Verify()",
          "new_text": null,
          "old_line_content": "  TF_CHECK_OK(module_->schedule().Verify());",
          "new_line_content": "StatusOr<std::unique_ptr<PresetAssignments>>",
          "content_same": false
        },
        {
          "line": 2774,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "module_->ToString()",
          "new_text": null,
          "old_line_content": "  XLA_VLOG_LINES(3, module_->ToString());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2777,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(1)",
          "new_text": null,
          "old_line_content": "  VLOG(1) << \"Maximum number of outstanding async copies: \"",
          "new_line_content": "    const HloLiveRange& hlo_live_range,",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": "absl::StrAppend(&out,\n                  (requires_contiguous_allocation_ ? \" (cont alloc)\" : \"\"))",
          "new_api": null,
          "old_text": "absl::StrAppend(&out,\n                  (requires_contiguous_allocation_ ? \" (cont alloc)\" : \"\"))",
          "new_text": null,
          "old_line_content": "  absl::StrAppend(&out,",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": "absl::StrAppend(&out, \"\\n position:\\n\")",
          "new_api": null,
          "old_text": "absl::StrAppend(&out, \"\\n position:\\n\")",
          "new_text": null,
          "old_line_content": "  absl::StrAppend(&out, \"\\n position:\\n\");",
          "new_line_content": "bool MemorySpaceAssignment::CopyAllocation::operator==(",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "defining_position_.ToString()",
          "new_text": null,
          "old_line_content": "  absl::StrAppend(&out, \"  \", defining_position_.ToString(), \"\\n\");",
          "new_line_content": "    const MemorySpaceAssignment::CopyAllocation& other) const {",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "value_->ToShortString()",
          "new_text": null,
          "old_line_content": "                      \", value = \", value_->ToShortString(),",
          "new_line_content": "                  (requires_contiguous_allocation_ ? \" (cont alloc)\" : \"\"));",
          "content_same": false
        },
        {
          "line": 2798,
          "old_api": "schedule",
          "new_api": null,
          "old_text": "module_->schedule()",
          "new_text": null,
          "old_line_content": "                                        module_->schedule(), alias_analysis,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2802,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "Status MemorySpaceAssignment::FindAllocationSequence(",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "value->ToString()",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"Creating AllocationValues for: \" << value->ToString();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2807,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "use.instruction->mutable_operand(use.operand_number)",
          "new_text": null,
          "old_line_content": "      use.instruction->mutable_operand(use.operand_number);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2813,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "operand->mutable_operand(index)",
          "new_text": null,
          "old_line_content": "    operand = operand->mutable_operand(index);",
          "new_line_content": "                                        heap_simulator_options)",
          "content_same": false
        },
        {
          "line": 766,
          "old_api": "instruction_schedule",
          "new_api": null,
          "old_text": "hlo_live_range_.instruction_schedule()",
          "new_text": null,
          "old_line_content": "      instruction_schedule = hlo_live_range_.instruction_schedule();",
          "new_line_content": "void AlternateMemoryBestFitHeap::CreateAllocationValues(",
          "content_same": false
        },
        {
          "line": 768,
          "old_api": "positions",
          "new_api": null,
          "old_text": "value->positions()",
          "new_text": null,
          "old_line_content": "  for (const HloPosition& position : value->positions()) {",
          "new_line_content": "    std::vector<AllocationValue>& allocation_values) const {",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "instruction->opcode()",
          "new_text": null,
          "old_line_content": "        instruction->opcode() != HloOpcode::kTuple &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "instruction->opcode()",
          "new_text": null,
          "old_line_content": "        instruction->opcode() != HloOpcode::kBitcast) {",
          "new_line_content": "  // Find and sort all non-trivial (excluding GTE, Tuple, and bitcast)",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "positions.push_back(position)",
          "new_text": null,
          "old_line_content": "      positions.push_back(position);",
          "new_line_content": "  // positions. We create an AllocationValue object for each non-trivial",
          "content_same": false
        },
        {
          "line": 2819,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "instruction->opcode()",
          "new_text": null,
          "old_line_content": "    while (instruction->opcode() == HloOpcode::kGetTupleElement) {",
          "new_line_content": "  HloInstruction* operand =",
          "content_same": false
        },
        {
          "line": 2821,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "instruction->mutable_operand(0)",
          "new_text": null,
          "old_line_content": "          get_simplified_operand(instruction->mutable_operand(0));",
          "new_line_content": "  // If the use is a tuple, look inside the tuple to find the actual use.",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": "at",
          "new_api": null,
          "old_text": "absl::c_stable_sort(positions,\n                      [&](const HloPosition& pos1, const HloPosition& pos2) {\n                        return instruction_schedule.at(pos1.instruction) <\n                               instruction_schedule.at(pos2.instruction);\n                      })",
          "new_text": null,
          "old_line_content": "  absl::c_stable_sort(positions,",
          "new_line_content": "  // why we exclude the trivial positions from AllocationValue is because",
          "content_same": false
        },
        {
          "line": 2822,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "operand->opcode()",
          "new_text": null,
          "old_line_content": "      if (operand->opcode() == HloOpcode::kTuple) {",
          "new_line_content": "  for (int64 index : use.operand_index) {",
          "content_same": false
        },
        {
          "line": 778,
          "old_api": "at",
          "new_api": null,
          "old_text": "instruction_schedule.at(pos1.instruction)",
          "new_text": null,
          "old_line_content": "                        return instruction_schedule.at(pos1.instruction) <",
          "new_line_content": "  const absl::flat_hash_map<const HloInstruction*, int64>&",
          "content_same": false
        },
        {
          "line": 2830,
          "old_api": "get_simplified_operand",
          "new_api": null,
          "old_text": "get_simplified_operand(operand)",
          "new_text": null,
          "old_line_content": "  operand = get_simplified_operand(operand);",
          "new_line_content": "  std::function<HloInstruction*(HloInstruction*)> get_simplified_operand;",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "allocation_values.emplace_back(value, position, buffer_interval.size)",
          "new_text": null,
          "old_line_content": "    allocation_values.emplace_back(value, position, buffer_interval.size);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2837,
          "old_api": "is_scoped_allocation",
          "new_api": null,
          "old_text": "is_scoped_allocation()",
          "new_text": null,
          "old_line_content": "  if (is_scoped_allocation()) {",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "uses",
          "new_api": null,
          "old_text": "value->uses()",
          "new_text": null,
          "old_line_content": "  std::vector<HloUse> uses(value->uses());",
          "new_line_content": "                      [&](const HloPosition& pos1, const HloPosition& pos2) {",
          "content_same": false
        },
        {
          "line": 2839,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "    return Status::OK();",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": "at",
          "new_api": null,
          "old_text": "instruction_schedule.at(use2.instruction)",
          "new_text": null,
          "old_line_content": "           instruction_schedule.at(use2.instruction);",
          "new_line_content": "                      });",
          "content_same": false
        },
        {
          "line": 2841,
          "old_api": "AddGetTupleElements",
          "new_api": null,
          "old_text": "AddGetTupleElements()",
          "new_text": null,
          "old_line_content": "  HloInstruction* producing_instruction = AddGetTupleElements();",
          "new_line_content": "    return instruction;",
          "content_same": false
        },
        {
          "line": 2842,
          "old_api": "parent",
          "new_api": null,
          "old_text": "producing_instruction->parent()",
          "new_text": null,
          "old_line_content": "  HloComputation* computation = producing_instruction->parent();",
          "new_line_content": "  };",
          "content_same": false
        },
        {
          "line": 2844,
          "old_api": "operand",
          "new_api": null,
          "old_text": "use.instruction->operand(use.operand_number)->shape()",
          "new_text": null,
          "old_line_content": "    Shape operand_shape = use.instruction->operand(use.operand_number)->shape();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2846,
          "old_api": "IsTuple",
          "new_api": null,
          "old_text": "operand_shape.IsTuple()",
          "new_text": null,
          "old_line_content": "    if (operand_shape.IsTuple()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2847,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "TF_ASSIGN_OR_RETURN(\n          replacement_instruction,\n          ReplaceTupleWith(producing_instruction,\n                           use.instruction->mutable_operand(use.operand_number),\n                           use.operand_index))",
          "new_text": null,
          "old_line_content": "      TF_ASSIGN_OR_RETURN(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2849,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "ReplaceTupleWith(producing_instruction,\n                           use.instruction->mutable_operand(use.operand_number),\n                           use.operand_index)",
          "new_text": null,
          "old_line_content": "          ReplaceTupleWith(producing_instruction,",
          "new_line_content": "    MemorySpaceAssignment* memory_space_assignment) {",
          "content_same": false
        },
        {
          "line": 2853,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "operand_shape.ToString()",
          "new_text": null,
          "old_line_content": "      VLOG(4) << \"Old shape = \" << operand_shape.ToString()",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2856,
          "old_api": "AddInstruction",
          "new_api": null,
          "old_text": "computation->AddInstruction(\n          HloInstruction::CreateBitcast(operand_shape, producing_instruction))",
          "new_text": null,
          "old_line_content": "      replacement_instruction = computation->AddInstruction(",
          "new_line_content": "  for (const HloUse& use : uses_) {",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": "size",
          "new_api": null,
          "old_text": "allocation_values.size()",
          "new_text": null,
          "old_line_content": "    for (int i = beginning_idx; i < allocation_values.size(); ++i) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": "at",
          "new_api": null,
          "old_text": "allocation_values.at(i)",
          "new_text": null,
          "old_line_content": "      AllocationValue* allocation_value = &allocation_values.at(i);",
          "new_line_content": "  // Associate each use with an AllocationValue. Each AllocationValue contains a",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "HloDataflowAnalysis::IsAsynchronousOperationDone(\n              use.instruction->opcode())",
          "new_text": null,
          "old_line_content": "      if (HloDataflowAnalysis::IsAsynchronousOperationDone(",
          "new_line_content": "  // position and uses in the same computation. Furthermore, if the original",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "use.instruction->opcode()",
          "new_text": null,
          "old_line_content": "              use.instruction->opcode())) {",
          "new_line_content": "  // HloValue had multiple non-trivial positions in the same computation, those",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": "defining_instruction",
          "new_api": null,
          "old_text": "allocation_value->defining_instruction()",
          "new_text": null,
          "old_line_content": "        if (allocation_value->defining_instruction() ==",
          "new_line_content": "  // will get their own AllocationValue as well. We split these HloValues so",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": "operand",
          "new_api": null,
          "old_text": "use.instruction->operand(0)",
          "new_text": null,
          "old_line_content": "            use.instruction->operand(0)) {",
          "new_line_content": "  // that when we insert CopyStart/CopyDone in CopyAllocation::Process, they",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": "defining_instruction",
          "new_api": null,
          "old_text": "HloDataflowAnalysis::IsAsynchronousOperationStart(\n                     allocation_value->defining_instruction()->opcode())",
          "new_text": null,
          "old_line_content": "      } else if (!HloDataflowAnalysis::IsAsynchronousOperationStart(",
          "new_line_content": "  for (const HloUse& use : uses) {",
          "content_same": false
        },
        {
          "line": 819,
          "old_api": "at",
          "new_api": null,
          "old_text": "instruction_schedule.at(\n                     allocation_value->defining_position().instruction)",
          "new_text": null,
          "old_line_content": "                 instruction_schedule.at(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 820,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "allocation_value->defining_position()",
          "new_text": null,
          "old_line_content": "                     allocation_value->defining_position().instruction) <",
          "new_line_content": "    AllocationValue* last_allocation_value = nullptr;",
          "content_same": false
        },
        {
          "line": 2868,
          "old_api": "shape",
          "new_api": null,
          "old_text": "tuple->shape()",
          "new_text": null,
          "old_line_content": "  const Shape& tuple_shape = tuple->shape();",
          "new_line_content": "              << \"; inserting a bitcast.\";",
          "content_same": false
        },
        {
          "line": 2871,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "tuple->ToString()",
          "new_text": null,
          "old_line_content": "      << tuple->ToString()",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2873,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "shape_index.ToString()",
          "new_text": null,
          "old_line_content": "      << \", shape_index = \" << shape_index.ToString();",
          "new_line_content": "        use.operand_number, replacement_instruction));",
          "content_same": false
        },
        {
          "line": 2876,
          "old_api": "tuple_shapes_size",
          "new_api": null,
          "old_text": "tuple_shape.tuple_shapes_size()",
          "new_text": null,
          "old_line_content": "  std::vector<HloInstruction*> tuple_args(tuple_shape.tuple_shapes_size());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2877,
          "old_api": "tuple_shapes_size",
          "new_api": null,
          "old_text": "tuple_shape.tuple_shapes_size()",
          "new_text": null,
          "old_line_content": "  for (int64 i = 0; i < tuple_shape.tuple_shapes_size(); ++i) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2878,
          "old_api": "tuple_shapes",
          "new_api": null,
          "old_text": "tuple_shape.tuple_shapes(i)",
          "new_text": null,
          "old_line_content": "    const Shape& subshape = tuple_shape.tuple_shapes(i);",
          "new_line_content": "StatusOr<HloInstruction*> MemorySpaceAssignment::Allocation::ReplaceTupleWith(",
          "content_same": false
        },
        {
          "line": 834,
          "old_api": "uses",
          "new_api": null,
          "old_text": "HloDataflowAnalysis::IsAsynchronousOperationDone(\n          allocation_value.uses().at(0).hlo_use.instruction->opcode())",
          "new_text": null,
          "old_line_content": "      CHECK(HloDataflowAnalysis::IsAsynchronousOperationDone(",
          "new_line_content": "                     use_time) {",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": "uses",
          "new_api": null,
          "old_text": "allocation_value.uses().at(0).hlo_use.instruction->opcode()",
          "new_text": null,
          "old_line_content": "          allocation_value.uses().at(0).hlo_use.instruction->opcode()));",
          "new_line_content": "        last_allocation_value = allocation_value;",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "allocation_value.ToShortString()",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \"Mark \" << allocation_value.ToShortString()",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2883,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "tuple->opcode()",
          "new_text": null,
          "old_line_content": "      if (tuple->opcode() == HloOpcode::kTuple) {",
          "new_line_content": "      << \"ReplaceTupleWith was called for a non-tuple. Tuple = \"",
          "content_same": false
        },
        {
          "line": 2887,
          "old_api": "HloInstruction::CreateGetTupleElement(subshape, tuple, i)",
          "new_api": null,
          "old_text": "HloInstruction::CreateGetTupleElement(subshape, tuple, i)",
          "new_text": null,
          "old_line_content": "            HloInstruction::CreateGetTupleElement(subshape, tuple, i));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \"Created allocation value: \"",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 841,
          "old_api": "at",
          "new_api": null,
          "old_text": "allocation_values.at(i).ToString()",
          "new_text": null,
          "old_line_content": "            << allocation_values.at(i).ToString();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2893,
          "old_api": "IsTuple",
          "new_api": null,
          "old_text": "subshape.IsTuple()",
          "new_text": null,
          "old_line_content": "      if (subshape.IsTuple()) {",
          "new_line_content": "    // operand to construct the new tuple to improve compilation time",
          "content_same": false
        },
        {
          "line": 2894,
          "old_api": "begin",
          "new_api": null,
          "old_text": "TF_ASSIGN_OR_RETURN(tuple_args[i],\n                            ReplaceTupleWith(new_instruction, get_operand(),\n                                             ShapeIndex(shape_index.begin() + 1,\n                                                        shape_index.end())))",
          "new_text": null,
          "old_line_content": "        TF_ASSIGN_OR_RETURN(tuple_args[i],",
          "new_line_content": "    // performance.",
          "content_same": false
        },
        {
          "line": 2895,
          "old_api": "get_operand",
          "new_api": null,
          "old_text": "get_operand()",
          "new_text": null,
          "old_line_content": "                            ReplaceTupleWith(new_instruction, get_operand(),",
          "new_line_content": "    auto get_operand = [&]() {",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": "uses",
          "new_api": null,
          "old_text": "value.uses().empty()",
          "new_text": null,
          "old_line_content": "    if (value.uses().empty() && skip_values_with_no_uses) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2901,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "new_instruction->shape().ToString()",
          "new_text": null,
          "old_line_content": "                  << \", new shape = \" << new_instruction->shape().ToString()",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 855,
          "old_api": "defining_instruction",
          "new_api": null,
          "old_text": "value.defining_instruction()",
          "new_text": null,
          "old_line_content": "    CHECK_EQ(values_by_defining_inst.count(value.defining_instruction()), 0);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": "defining_instruction",
          "new_api": null,
          "old_text": "value.defining_instruction()",
          "new_text": null,
          "old_line_content": "    values_by_defining_inst[value.defining_instruction()] = &value;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2903,
          "old_api": "AddInstruction",
          "new_api": null,
          "old_text": "computation->AddInstruction(\n              HloInstruction::CreateBitcast(subshape, new_instruction))",
          "new_text": null,
          "old_line_content": "          new_instruction = computation->AddInstruction(",
          "new_line_content": "    if (i == shape_index[0]) {",
          "content_same": false
        },
        {
          "line": 2904,
          "old_api": "HloInstruction::CreateBitcast(subshape, new_instruction)",
          "new_api": null,
          "old_text": "HloInstruction::CreateBitcast(subshape, new_instruction)",
          "new_text": null,
          "old_line_content": "              HloInstruction::CreateBitcast(subshape, new_instruction));",
          "new_line_content": "      // If the subshape is still a tuple, recurse and pass a new shape index",
          "content_same": false
        },
        {
          "line": 2905,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "tuple->opcode()",
          "new_text": null,
          "old_line_content": "        } else if (tuple->opcode() == HloOpcode::kTuple &&",
          "new_line_content": "      // for the one level deeper.",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": "find",
          "new_api": null,
          "old_text": "values_by_defining_inst.find(instruction)",
          "new_text": null,
          "old_line_content": "    auto aliased_value_it = values_by_defining_inst.find(instruction);",
          "new_line_content": "    bool skip_values_with_no_uses) const {",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": "end",
          "new_api": null,
          "old_text": "values_by_defining_inst.end()",
          "new_text": null,
          "old_line_content": "    if (aliased_value_it != values_by_defining_inst.end()) {",
          "new_line_content": "  absl::flat_hash_map<const HloInstruction*, const AllocationValue*>",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "use->hlo_use.ToString()",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \"Adding aliasing for use \" << use->hlo_use.ToString() << \" to \"",
          "new_line_content": "      values_by_defining_inst;",
          "content_same": false
        },
        {
          "line": 863,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "aliased_value_it->second->ToShortString()",
          "new_text": null,
          "old_line_content": "              << aliased_value_it->second->ToShortString();",
          "new_line_content": "  for (AllocationValue& value : *allocation_values) {",
          "content_same": false
        },
        {
          "line": 864,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "aliased_value_it->second->defining_position()",
          "new_text": null,
          "old_line_content": "      use->aliases.push_back(aliased_value_it->second->defining_position());",
          "new_line_content": "    // Skip the value if it doesn't have any uses.",
          "content_same": false
        },
        {
          "line": 2911,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "new_instruction->ToShortString()",
          "new_text": null,
          "old_line_content": "                  << new_instruction->ToShortString()",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": "maybe_add_alias_with_instruction",
          "new_api": null,
          "old_text": "maybe_add_alias_with_instruction(use.hlo_use.instruction, &use)",
          "new_text": null,
          "old_line_content": "      maybe_add_alias_with_instruction(use.hlo_use.instruction, &use);",
          "new_line_content": "                                              AllocationValue::Use* use) {",
          "content_same": false
        },
        {
          "line": 2921,
          "old_api": "HloInstruction::CreateTuple(tuple_args)",
          "new_api": null,
          "old_text": "HloInstruction::CreateTuple(tuple_args)",
          "new_text": null,
          "old_line_content": "  return computation->AddInstruction(HloInstruction::CreateTuple(tuple_args));",
          "new_line_content": "          // actually don't have to create a new tuple, just return the original",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": "parameter_instructions",
          "new_api": null,
          "old_text": "called_computation->parameter_instructions()",
          "new_text": null,
          "old_line_content": "             called_computation->parameter_instructions()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": "maybe_add_alias_with_instruction",
          "new_api": null,
          "old_text": "maybe_add_alias_with_instruction(parameter_instruction, &use)",
          "new_text": null,
          "old_line_content": "          maybe_add_alias_with_instruction(parameter_instruction, &use);",
          "new_line_content": "  };",
          "content_same": false
        },
        {
          "line": 2926,
          "old_api": "CHECK_NE",
          "new_api": null,
          "old_text": "CHECK_NE(producing_instruction, nullptr)",
          "new_text": null,
          "old_line_content": "  CHECK_NE(producing_instruction, nullptr);",
          "new_line_content": "          return tuple;",
          "content_same": false
        },
        {
          "line": 2928,
          "old_api": "shape",
          "new_api": null,
          "old_text": "defining_position().shape()",
          "new_text": null,
          "old_line_content": "  Shape shape = defining_position().shape();",
          "new_line_content": "        tuple_args[i] = new_instruction;",
          "content_same": false
        },
        {
          "line": 2929,
          "old_api": "IsArray",
          "new_api": null,
          "old_text": "shape.IsArray()",
          "new_text": null,
          "old_line_content": "  CHECK(shape.IsArray()) << \"Allocation shape is not an array. Shape = \"",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2930,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "shape.ToString()",
          "new_text": null,
          "old_line_content": "                         << shape.ToString()",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 2932,
          "old_api": "parent",
          "new_api": null,
          "old_text": "producing_instruction->parent()",
          "new_text": null,
          "old_line_content": "  HloComputation* computation = producing_instruction->parent();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": "while_body",
          "new_api": null,
          "old_text": "use.hlo_use.instruction->while_body()->root_instruction()",
          "new_text": null,
          "old_line_content": "            use.hlo_use.instruction->while_body()->root_instruction(),",
          "new_line_content": "      // Find any aliases with the parameters of called computations.",
          "content_same": false
        },
        {
          "line": 2937,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "defining_position()",
          "new_text": null,
          "old_line_content": "  for (int64 index : defining_position().index) {",
          "new_line_content": "HloInstruction* MemorySpaceAssignment::Allocation::AddGetTupleElements() {",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "use.hlo_use.ToString()",
          "new_text": null,
          "old_line_content": "                << use.hlo_use.ToString() << \" to \" << root_alias;",
          "new_line_content": "        for (const HloInstruction* parameter_instruction :",
          "content_same": false
        },
        {
          "line": 2940,
          "old_api": "users",
          "new_api": null,
          "old_text": "absl::c_find_if(\n        producing_instruction->users(), [index](const HloInstruction* use) {\n          return use != use->parent()->root_instruction() &&\n                 use->opcode() == HloOpcode::kGetTupleElement &&\n                 use->tuple_index() == index;\n        })",
          "new_text": null,
          "old_line_content": "    auto gte_it = absl::c_find_if(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2946,
          "old_api": "end",
          "new_api": null,
          "old_text": "producing_instruction->users().end()",
          "new_text": null,
          "old_line_content": "    if (gte_it != producing_instruction->users().end()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2951,
          "old_api": "tuple_shapes",
          "new_api": null,
          "old_text": "producing_instruction->shape().tuple_shapes(index)",
          "new_text": null,
          "old_line_content": "              producing_instruction->shape().tuple_shapes(index),",
          "new_line_content": "    // We first search if there already is a get-tuple-element with the correct",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "colocated_intervals.push_back(item)",
          "new_text": null,
          "old_line_content": "    colocated_intervals.push_back(item);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": "at",
          "new_api": null,
          "old_text": "buffer_intervals_.at(buffer_colocated)",
          "new_text": null,
          "old_line_content": "      worklist.push_back(&buffer_intervals_.at(buffer_colocated));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": "absl::c_stable_sort(colocated_intervals, [&](const BufferInterval* x,\n                                               const BufferInterval* y) {\n    return std::make_pair(x->start, x->end) < std::make_pair(y->start, y->end);\n  })",
          "new_api": null,
          "old_text": "absl::c_stable_sort(colocated_intervals, [&](const BufferInterval* x,\n                                               const BufferInterval* y) {\n    return std::make_pair(x->start, x->end) < std::make_pair(y->start, y->end);\n  })",
          "new_text": null,
          "old_line_content": "  absl::c_stable_sort(colocated_intervals, [&](const BufferInterval* x,",
          "new_line_content": "AlternateMemoryBestFitHeap::GetSortedColocatedIntervals(",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": "std::make_pair(y->start, y->end)",
          "new_api": null,
          "old_text": "std::make_pair(y->start, y->end)",
          "new_text": null,
          "old_line_content": "    return std::make_pair(x->start, x->end) < std::make_pair(y->start, y->end);",
          "new_line_content": "  std::vector<const BufferInterval*> colocated_intervals;",
          "content_same": false
        },
        {
          "line": 2961,
          "old_api": "absl::StrCat(\"alt (off: \", chunk_->offset, \")\")",
          "new_api": null,
          "old_text": "absl::StrCat(\"alt (off: \", chunk_->offset, \")\")",
          "new_text": null,
          "old_line_content": "    memory_space_str = absl::StrCat(\"alt (off: \", chunk_->offset, \")\");",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 2965,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "defining_position_.ToString()",
          "new_text": null,
          "old_line_content": "                      defining_position_.ToString());",
          "new_line_content": "              producing_instruction, index));",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": "is_use_allowed_in_alternate_mem_fn",
          "new_api": null,
          "old_text": "options_.is_use_allowed_in_alternate_mem_fn(use)",
          "new_text": null,
          "old_line_content": "  if (!options_.is_use_allowed_in_alternate_mem_fn(use)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2971,
          "old_api": "absl::StrCat(\"alt (off: \", chunk_->offset, \")\")",
          "new_api": null,
          "old_text": "absl::StrCat(\"alt (off: \", chunk_->offset, \")\")",
          "new_text": null,
          "old_line_content": "    memory_space_str = absl::StrCat(\"alt (off: \", chunk_->offset, \")\");",
          "new_line_content": "std::string MemorySpaceAssignment::Allocation::ToString() const {",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": "while_body",
          "new_api": null,
          "old_text": "use.instruction->while_body()",
          "new_text": null,
          "old_line_content": "    HloComputation* while_body = use.instruction->while_body();",
          "new_line_content": "                                               const BufferInterval* y) {",
          "content_same": false
        },
        {
          "line": 2973,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "absl::StrCat(\"Copy Allocation in \", memory_space_str, \" from \",\n                      prev_allocation_.ToString())",
          "new_text": null,
          "old_line_content": "  return absl::StrCat(\"Copy Allocation in \", memory_space_str, \" from \",",
          "new_line_content": "  if (memory_space_ == MemorySpace::kAlternate) {",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": "dataflow_analysis",
          "new_api": null,
          "old_text": "alias_analysis_.dataflow_analysis().GetUniqueValueAt(\n            while_body->parameter_instruction(0), use.operand_index)",
          "new_text": null,
          "old_line_content": "        &alias_analysis_.dataflow_analysis().GetUniqueValueAt(",
          "new_line_content": "bool AlternateMemoryBestFitHeap::IsUseAllowedInAlternateMemory(",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": "parameter_instruction",
          "new_api": null,
          "old_text": "while_body->parameter_instruction(0)",
          "new_text": null,
          "old_line_content": "            while_body->parameter_instruction(0), use.operand_index);",
          "new_line_content": "    const AllocationValue& value, const HloUse& use) const {",
          "content_same": false
        },
        {
          "line": 2980,
          "old_api": "shape",
          "new_api": null,
          "old_text": "defining_position().shape()",
          "new_text": null,
          "old_line_content": "  Shape shape = defining_position().shape();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2981,
          "old_api": "AddGetTupleElements",
          "new_api": null,
          "old_text": "AddGetTupleElements()",
          "new_text": null,
          "old_line_content": "  HloInstruction* producing_instruction = AddGetTupleElements();",
          "new_line_content": "std::string MemorySpaceAssignment::CopyAllocation::ToString() const {",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "while_body->root_instruction()",
          "new_text": null,
          "old_line_content": "    int64 root_time = instruction_schedule.at(while_body->root_instruction());",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 2982,
          "old_api": "parent",
          "new_api": null,
          "old_text": "producing_instruction->parent()",
          "new_text": null,
          "old_line_content": "  HloComputation* computation = producing_instruction->parent();",
          "new_line_content": "  std::string memory_space_str = \"def\";",
          "content_same": false
        },
        {
          "line": 2983,
          "old_api": "HloInstruction::CreateCopyStart(\n      ShapeUtil::MakeTupleShape({shape, shape, ShapeUtil::MakeShape(U32, {})}),\n      producing_instruction, is_cross_program_prefetch_)",
          "new_api": null,
          "old_text": "HloInstruction::CreateCopyStart(\n      ShapeUtil::MakeTupleShape({shape, shape, ShapeUtil::MakeShape(U32, {})}),\n      producing_instruction, is_cross_program_prefetch_)",
          "new_text": null,
          "old_line_content": "  copy_start_ = computation->AddInstruction(HloInstruction::CreateCopyStart(",
          "new_line_content": "  if (memory_space_ == MemorySpace::kAlternate) {",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "parameter_use.instruction->opcode()",
          "new_text": null,
          "old_line_content": "      if (parameter_use.instruction->opcode() != HloOpcode::kGetTupleElement &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "parameter_use.instruction->opcode()",
          "new_text": null,
          "old_line_content": "          parameter_use.instruction->opcode() != HloOpcode::kTuple &&",
          "new_line_content": "    // We don't want to allocate this buffer in alternate memory if it will be",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "parameter_use.instruction->opcode()",
          "new_text": null,
          "old_line_content": "          parameter_use.instruction->opcode() != HloOpcode::kBitcast &&",
          "new_line_content": "    // evicted anyway. Find out if it has an early use or a late definition that",
          "content_same": false
        },
        {
          "line": 2988,
          "old_api": "name",
          "new_api": null,
          "old_text": "copy_start_->name()",
          "new_text": null,
          "old_line_content": "  VLOG(4) << \"Created \" << copy_start_->name()",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": "std::min(min_use_time, use_time)",
          "new_api": null,
          "old_text": "std::min(min_use_time, use_time)",
          "new_text": null,
          "old_line_content": "        min_use_time = std::min(min_use_time, use_time);",
          "new_line_content": "    HloValue* parameter_value =",
          "content_same": false
        },
        {
          "line": 2989,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "defining_position().ToString()",
          "new_text": null,
          "old_line_content": "          << \" for position: \" << defining_position().ToString();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(4)",
          "new_text": null,
          "old_line_content": "      VLOG(4) << \"While allocation not allowed in alternate memory. \"",
          "new_line_content": "    int64 min_use_time = root_time;",
          "content_same": false
        },
        {
          "line": 3003,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "ReplaceTupleWith(copy_done_,\n                           use.instruction->mutable_operand(use.operand_number),\n                           use.operand_index)",
          "new_text": null,
          "old_line_content": "          ReplaceTupleWith(copy_done_,",
          "new_line_content": "  // Update the allocation position with the copy done instruction so that if",
          "content_same": false
        },
        {
          "line": 3004,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "use.instruction->mutable_operand(use.operand_number)",
          "new_text": null,
          "old_line_content": "                           use.instruction->mutable_operand(use.operand_number),",
          "new_line_content": "  // there are further copies from it, it can find the correct position.",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(4)",
          "new_text": null,
          "old_line_content": "      VLOG(4) << \"While allocation not allowed in alternate memory. \"",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3006,
          "old_api": "shape",
          "new_api": null,
          "old_text": "copy_done_->shape()",
          "new_text": null,
          "old_line_content": "    } else if (operand_shape != copy_done_->shape()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3007,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "operand_shape.ToString()",
          "new_text": null,
          "old_line_content": "      VLOG(4) << \"Old shape = \" << operand_shape.ToString()",
          "new_line_content": "  // Replace all the uses with the new copy instruction.",
          "content_same": false
        },
        {
          "line": 3008,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "copy_done_->shape().ToString()",
          "new_text": null,
          "old_line_content": "              << \", new shape = \" << copy_done_->shape().ToString()",
          "new_line_content": "  for (HloUse use : uses_) {",
          "content_same": false
        },
        {
          "line": 3010,
          "old_api": "AddInstruction",
          "new_api": null,
          "old_text": "computation->AddInstruction(\n          HloInstruction::CreateBitcast(operand_shape, copy_done_))",
          "new_text": null,
          "old_line_content": "      replacement_instruction = computation->AddInstruction(",
          "new_line_content": "    // we want to replace.",
          "content_same": false
        },
        {
          "line": 3011,
          "old_api": "HloInstruction::CreateBitcast(operand_shape, copy_done_)",
          "new_api": null,
          "old_text": "HloInstruction::CreateBitcast(operand_shape, copy_done_)",
          "new_text": null,
          "old_line_content": "          HloInstruction::CreateBitcast(operand_shape, copy_done_));",
          "new_line_content": "    HloInstruction* replacement_instruction;",
          "content_same": false
        },
        {
          "line": 964,
          "old_api": "dataflow_analysis",
          "new_api": null,
          "old_text": "alias_analysis_.dataflow_analysis().GetUniqueValueAt(\n            use.instruction, use.operand_index)",
          "new_text": null,
          "old_line_content": "        &alias_analysis_.dataflow_analysis().GetUniqueValueAt(",
          "new_line_content": "      return false;",
          "content_same": false
        },
        {
          "line": 3015,
          "old_api": "ReplaceOperandWith",
          "new_api": null,
          "old_text": "use.instruction->ReplaceOperandWith(\n        use.operand_number, replacement_instruction)",
          "new_text": null,
          "old_line_content": "    TF_RETURN_IF_ERROR(use.instruction->ReplaceOperandWith(",
          "new_line_content": "          replacement_instruction,",
          "content_same": false
        },
        {
          "line": 968,
          "old_api": "RequiredMemoryAssignmentAt",
          "new_api": null,
          "old_text": "RequiredMemoryAssignmentAt(while_value, while_time)",
          "new_text": null,
          "old_line_content": "        RequiredMemoryAssignmentAt(while_value, while_time);",
          "new_line_content": "    // either at the beginning or end of the while loop body.",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "use.instruction->opcode()",
          "new_text": null,
          "old_line_content": "  } else if (use.instruction->opcode() == HloOpcode::kConditional) {",
          "new_line_content": "    // Check if there is a required assignment for the while loop output.",
          "content_same": false
        },
        {
          "line": 3026,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "allocation->ToString()",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \"Processing: \" << allocation->ToString();",
          "new_line_content": "      replacement_instruction = copy_done_;",
          "content_same": false
        },
        {
          "line": 3027,
          "old_api": "Process",
          "new_api": null,
          "old_text": "allocation->Process(this)",
          "new_text": null,
          "old_line_content": "    TF_RETURN_IF_ERROR(allocation->Process(this));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": "uses",
          "new_api": null,
          "old_text": "value.uses()",
          "new_text": null,
          "old_line_content": "    for (const AllocationValue::Use& other_use : value.uses()) {",
          "new_line_content": "    auto existing_required_assignment =",
          "content_same": false
        },
        {
          "line": 3030,
          "old_api": "is_scoped_allocation",
          "new_api": null,
          "old_text": "allocation->is_scoped_allocation()",
          "new_text": null,
          "old_line_content": "    if (allocation->is_scoped_allocation()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3031,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "allocation->memory_space()",
          "new_text": null,
          "old_line_content": "      CHECK(allocation->memory_space() == MemorySpace::kAlternate);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": "at",
          "new_api": null,
          "old_text": "use.instruction->called_computations().at(\n              other_use.hlo_use.operand_number - 1)",
          "new_text": null,
          "old_line_content": "          use.instruction->called_computations().at(",
          "new_line_content": "                 \"there is a required default memory assignment.\";",
          "content_same": false
        },
        {
          "line": 3033,
          "old_api": "chunk",
          "new_api": null,
          "old_text": "allocation->chunk()",
          "new_text": null,
          "old_line_content": "          allocation->defining_position().instruction, allocation->chunk());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3035,
          "old_api": "chunk_end",
          "new_api": null,
          "old_text": "allocation->chunk().chunk_end()",
          "new_text": null,
          "old_line_content": "          std::max(alternate_memory_size_, allocation->chunk().chunk_end());",
          "new_line_content": "Status MemorySpaceAssignment::Process() {",
          "content_same": false
        },
        {
          "line": 3037,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "alternate_memory_assignments_.emplace_back(\n          allocation->defining_position(), allocation->chunk())",
          "new_text": null,
          "old_line_content": "      alternate_memory_assignments_.emplace_back(",
          "new_line_content": "  // Insert CopyStart/CopyDone pairs.",
          "content_same": false
        },
        {
          "line": 990,
          "old_api": "dataflow_analysis",
          "new_api": null,
          "old_text": "alias_analysis_.dataflow_analysis().GetUniqueValueAt(\n              parameter_instruction, other_use.hlo_use.operand_index)",
          "new_text": null,
          "old_line_content": "          &alias_analysis_.dataflow_analysis().GetUniqueValueAt(",
          "new_line_content": "    // multiple called computations), determine if the parameter->first use",
          "content_same": false
        },
        {
          "line": 3038,
          "old_api": "chunk",
          "new_api": null,
          "old_text": "allocation->chunk()",
          "new_text": null,
          "old_line_content": "          allocation->defining_position(), allocation->chunk());",
          "new_line_content": "  for (auto& allocation : allocations_) {",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": "uses",
          "new_api": null,
          "old_text": "parameter_value->uses()",
          "new_text": null,
          "old_line_content": "      for (const HloUse& parameter_use : parameter_value->uses()) {",
          "new_line_content": "      if (other_use.hlo_use.instruction != use.instruction) {",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": "parent",
          "new_api": null,
          "old_text": "parameter_use.instruction->parent()",
          "new_text": null,
          "old_line_content": "        if (parameter_use.instruction->parent() == called_computation &&",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "parameter_use.instruction->opcode()",
          "new_text": null,
          "old_line_content": "            parameter_use.instruction->opcode() !=",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "parameter_use.instruction->opcode()",
          "new_text": null,
          "old_line_content": "            parameter_use.instruction->opcode() != HloOpcode::kBitcast) {",
          "new_line_content": "              other_use.hlo_use.operand_number - 1);",
          "content_same": false
        },
        {
          "line": 1000,
          "old_api": "at",
          "new_api": null,
          "old_text": "std::min(\n              min_use_time, instruction_schedule.at(parameter_use.instruction))",
          "new_text": null,
          "old_line_content": "          min_use_time = std::min(",
          "new_line_content": "      const HloInstruction* parameter_instruction =",
          "content_same": false
        },
        {
          "line": 3047,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(1)",
          "new_text": null,
          "old_line_content": "  VLOG(1) << \"Exporting buffers...\";",
          "new_line_content": "      alternate_memory_size_ =",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": "CanAllocateInAlternateMemoryNoCopy",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(\n              parameter_value->shape(), parameter_time, min_use_time)",
          "new_text": null,
          "old_line_content": "      if (options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(",
          "new_line_content": "              parameter_instruction, other_use.hlo_use.operand_index);",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(4)",
          "new_text": null,
          "old_line_content": "        VLOG(4) << \"Conditional allocation allowed in alternate memory for \"",
          "new_line_content": "      int64 min_use_time = conditional_time;",
          "content_same": false
        },
        {
          "line": 3054,
          "old_api": "GetUniqueBufferAt",
          "new_api": null,
          "old_text": "alias_analysis->GetUniqueBufferAt(\n        defining_position.instruction, defining_position.index)",
          "new_text": null,
          "old_line_content": "    const HloBuffer& buffer = alias_analysis->GetUniqueBufferAt(",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3057,
          "old_api": "end",
          "new_api": null,
          "old_text": "seen_buffer_offsets.end()",
          "new_text": null,
          "old_line_content": "    if (seen_buffer_offset_it != seen_buffer_offsets.end()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3058,
          "old_api": "CHECK_EQ",
          "new_api": null,
          "old_text": "CHECK_EQ(chunk.offset, seen_buffer_offset_it->second)",
          "new_text": null,
          "old_line_content": "      CHECK_EQ(chunk.offset, seen_buffer_offset_it->second)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3062,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \" [\" << chunk.offset << \", \" << chunk.size",
          "new_line_content": "  absl::flat_hash_map<int64, int64> seen_buffer_offsets;",
          "content_same": false
        },
        {
          "line": 1015,
          "old_api": "name",
          "new_api": null,
          "old_text": "called_computation->name()",
          "new_text": null,
          "old_line_content": "                << called_computation->name()",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3064,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "buffer.ToString()",
          "new_text": null,
          "old_line_content": "              << buffer.ToString() << \")\";",
          "new_line_content": "  for (const auto& position_and_chunk : alternate_memory_assignments_) {",
          "content_same": false
        },
        {
          "line": 3065,
          "old_api": "add_chunk",
          "new_api": null,
          "old_text": "preset_assignments_->add_chunk(defining_position, chunk)",
          "new_text": null,
          "old_line_content": "      preset_assignments_->add_chunk(defining_position, chunk);",
          "new_line_content": "    const HloPosition& defining_position = position_and_chunk.first;",
          "content_same": false
        },
        {
          "line": 3066,
          "old_api": "id",
          "new_api": null,
          "old_text": "buffer.id()",
          "new_text": null,
          "old_line_content": "      seen_buffer_offsets[buffer.id()] = chunk.offset;",
          "new_line_content": "    const Chunk& chunk = position_and_chunk.second;",
          "content_same": false
        },
        {
          "line": 3074,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \" [\" << chunk.offset << \", \" << chunk.size",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 3080,
          "old_api": "empty",
          "new_api": null,
          "old_text": "preset_assignments_->scoped_allocation_chunks().empty()",
          "new_text": null,
          "old_line_content": "      !preset_assignments_->scoped_allocation_chunks().empty()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3081,
          "old_api": "assignment_information_for_space",
          "new_api": null,
          "old_text": "preset_assignments_\n        ->assignment_information_for_space(options_.alternate_memory_space)",
          "new_text": null,
          "old_line_content": "    preset_assignments_",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3086,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"Exported alternate memory sizes:\";",
          "new_line_content": "    const Chunk& chunk = instruction_and_chunk.second;",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": "empty",
          "new_api": null,
          "old_text": "debug_str->empty()",
          "new_text": null,
          "old_line_content": "  if (debug_str->empty()) {",
          "new_line_content": "  // Columns in buffer information:",
          "content_same": false
        },
        {
          "line": 3091,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(1)",
          "new_text": null,
          "old_line_content": "  VLOG(1) << \"Coloring buffers...\";",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": "absl::StrAppend(debug_str,\n                    \"buffer_id,buffer_name,alt_mem_benefit,size,\"\n                    \"definition_time,use_times,use_names\\n\")",
          "new_api": null,
          "old_text": "absl::StrAppend(debug_str,\n                    \"buffer_id,buffer_name,alt_mem_benefit,size,\"\n                    \"definition_time,use_times,use_names\\n\")",
          "new_text": null,
          "old_line_content": "    absl::StrAppend(debug_str,",
          "new_line_content": "  // allocation information.",
          "content_same": false
        },
        {
          "line": 3096,
          "old_api": "ComputeBuffersAt",
          "new_api": null,
          "old_text": "alias_analysis->ComputeBuffersAt(\n             defining_position.instruction, defining_position.index)",
          "new_text": null,
          "old_line_content": "    for (auto& buffer : alias_analysis->ComputeBuffersAt(",
          "new_line_content": "        ->size = alternate_memory_size_;",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": "GetBufferContainingValue",
          "new_api": null,
          "old_text": "alias_analysis_.GetBufferContainingValue(*interval.buffer)",
          "new_text": null,
          "old_line_content": "      alias_analysis_.GetBufferContainingValue(*interval.buffer);",
          "new_line_content": "  // size: int. In bytes.",
          "content_same": false
        },
        {
          "line": 1050,
          "old_api": "instruction_schedule",
          "new_api": null,
          "old_text": "hlo_live_range_.instruction_schedule()",
          "new_text": null,
          "old_line_content": "  const auto& instruction_schedule = hlo_live_range_.instruction_schedule();",
          "new_line_content": "  // definition_time: int. Logical time this value was defined in the schedule.",
          "content_same": false
        },
        {
          "line": 3098,
          "old_api": "values",
          "new_api": null,
          "old_text": "buffer->values()",
          "new_text": null,
          "old_line_content": "      for (auto& value : buffer->values()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1052,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "interval.buffer->defining_position()",
          "new_text": null,
          "old_line_content": "      instruction_schedule.at(interval.buffer->defining_position().instruction);",
          "new_line_content": "  // the use times.",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": "values",
          "new_api": null,
          "old_text": "buffer.values()",
          "new_text": null,
          "old_line_content": "  for (const HloValue* value : buffer.values()) {",
          "new_line_content": "  // representation of uses.",
          "content_same": false
        },
        {
          "line": 3102,
          "old_api": "mutable_shape",
          "new_api": null,
          "old_text": "position.instruction->mutable_shape()",
          "new_text": null,
          "old_line_content": "              position.instruction->mutable_shape(), position.index);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1056,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "uses.push_back(\n          {instruction_schedule.at(use.instruction), use.ToString()})",
          "new_text": null,
          "old_line_content": "      uses.push_back(",
          "new_line_content": "    // Append the column names.",
          "content_same": false
        },
        {
          "line": 3103,
          "old_api": "IsArray",
          "new_api": null,
          "old_text": "shape->IsArray()",
          "new_text": null,
          "old_line_content": "          CHECK(shape->IsArray()) << \"Coloring a shape that is not an array: \"",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3105,
          "old_api": "mutable_layout",
          "new_api": null,
          "old_text": "shape->mutable_layout()->set_memory_space(\n              options_.alternate_memory_space)",
          "new_text": null,
          "old_line_content": "          shape->mutable_layout()->set_memory_space(",
          "new_line_content": "  // Color the pending positions and all of their aliased buffers.",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": "absl::c_sort(uses)",
          "new_api": null,
          "old_text": "absl::c_sort(uses)",
          "new_text": null,
          "old_line_content": "  absl::c_sort(uses);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1064,
          "old_api": "size",
          "new_api": null,
          "old_text": "uses.size()",
          "new_text": null,
          "old_line_content": "  use_names.reserve(uses.size());",
          "new_line_content": "  int64 definition_time =",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "use_times.push_back(use.first)",
          "new_text": null,
          "old_line_content": "    use_times.push_back(use.first);",
          "new_line_content": "  std::vector<std::pair<int64, std::string>> uses;",
          "content_same": false
        },
        {
          "line": 1071,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "interval.buffer->ToShortString()",
          "new_text": null,
          "old_line_content": "  absl::StrAppend(debug_str, \"\\\"\", interval.buffer->ToShortString(), \"\\\",\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3119,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \"Removing instruction from alternate memory assignments.\";",
          "new_line_content": "              options_.alternate_memory_space);",
          "content_same": false
        },
        {
          "line": 3121,
          "old_api": "back",
          "new_api": null,
          "old_text": "alternate_memory_assignments_.back()",
          "new_text": null,
          "old_line_content": "      position_and_chunk = alternate_memory_assignments_.back();",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3122,
          "old_api": "pop_back",
          "new_api": null,
          "old_text": "alternate_memory_assignments_.pop_back()",
          "new_text": null,
          "old_line_content": "      alternate_memory_assignments_.pop_back();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1075,
          "old_api": "absl::StrAppend(\n      debug_str, alternate_memory_benefit ? *alternate_memory_benefit : 0, \",\")",
          "new_api": null,
          "old_text": "absl::StrAppend(\n      debug_str, alternate_memory_benefit ? *alternate_memory_benefit : 0, \",\")",
          "new_text": null,
          "old_line_content": "  absl::StrAppend(",
          "new_line_content": "  std::vector<std::string> use_names;",
          "content_same": false
        },
        {
          "line": 1078,
          "old_api": "absl::StrAppend(debug_str, definition_time, \",\")",
          "new_api": null,
          "old_text": "absl::StrAppend(debug_str, definition_time, \",\")",
          "new_text": null,
          "old_line_content": "  absl::StrAppend(debug_str, definition_time, \",\");",
          "new_line_content": "  for (const auto& use : uses) {",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": "absl::StrAppend(debug_str, \"\\n\")",
          "new_api": null,
          "old_text": "absl::StrAppend(debug_str, \"\\n\")",
          "new_text": null,
          "old_line_content": "  absl::StrAppend(debug_str, \"\\n\");",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3129,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(1)",
          "new_text": null,
          "old_line_content": "  VLOG(1) << \"Simplifying graph...\";",
          "new_line_content": "  for (auto& position_and_chunk : alternate_memory_assignments_) {",
          "content_same": false
        },
        {
          "line": 3130,
          "old_api": "MakeNonfusionComputations",
          "new_api": null,
          "old_text": "module_->MakeNonfusionComputations()",
          "new_text": null,
          "old_line_content": "  for (HloComputation* computation : module_->MakeNonfusionComputations()) {",
          "new_line_content": "    const HloPosition& position = position_and_chunk.first;",
          "content_same": false
        },
        {
          "line": 3133,
          "old_api": "contains",
          "new_api": null,
          "old_text": "computations_in_schedule_.contains(computation)",
          "new_text": null,
          "old_line_content": "    if (!computations_in_schedule_.contains(computation)) {",
          "new_line_content": "      // Swap the removed position and chunk with the back and pop back.",
          "content_same": false
        },
        {
          "line": 1096,
          "old_api": "absl::StrAppend(&debug_str, \"buffer_id,size,offset,start_time,end_time\\n\")",
          "new_api": null,
          "old_text": "absl::StrAppend(&debug_str, \"buffer_id,size,offset,start_time,end_time\\n\")",
          "new_text": null,
          "old_line_content": "    absl::StrAppend(&debug_str, \"buffer_id,size,offset,start_time,end_time\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3144,
          "old_api": "MakeInstructionPostOrder",
          "new_api": null,
          "old_text": "computation->MakeInstructionPostOrder()",
          "new_text": null,
          "old_line_content": "         computation->MakeInstructionPostOrder()) {",
          "new_line_content": "    // Parallel computations aren't in the schedule and don't need to be",
          "content_same": false
        },
        {
          "line": 1098,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "allocation.memory_space()",
          "new_text": null,
          "old_line_content": "  if (allocation.memory_space() == MemorySpace::kAlternate) {",
          "new_line_content": "    const AllocationValue& value,",
          "content_same": false
        },
        {
          "line": 3145,
          "old_api": "DropAllControlDeps",
          "new_api": null,
          "old_text": "instruction->DropAllControlDeps()",
          "new_text": null,
          "old_line_content": "      TF_RETURN_IF_ERROR(instruction->DropAllControlDeps());",
          "new_line_content": "    // modified.",
          "content_same": false
        },
        {
          "line": 1100,
          "old_api": "value",
          "new_api": null,
          "old_text": "value.value()",
          "new_text": null,
          "old_line_content": "        alias_analysis_.GetBufferContainingValue(*value.value());",
          "new_line_content": "    std::string& debug_str) const {",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": "id",
          "new_api": null,
          "old_text": "buffer.id()",
          "new_text": null,
          "old_line_content": "    absl::StrAppend(&debug_str, buffer.id(), \",\");",
          "new_line_content": "  // Columns in allocation information:",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": "size",
          "new_api": null,
          "old_text": "value.size()",
          "new_text": null,
          "old_line_content": "    absl::StrAppend(&debug_str, value.size(), \",\");",
          "new_line_content": "  // buffer_id: int. This value can be used the match with buffer info.",
          "content_same": false
        },
        {
          "line": 1103,
          "old_api": "chunk",
          "new_api": null,
          "old_text": "allocation.chunk()",
          "new_text": null,
          "old_line_content": "    absl::StrAppend(&debug_str, allocation.chunk().offset, \",\");",
          "new_line_content": "  // size: int. In bytes.",
          "content_same": false
        },
        {
          "line": 1104,
          "old_api": "start_time",
          "new_api": null,
          "old_text": "allocation.start_time()",
          "new_text": null,
          "old_line_content": "    absl::StrAppend(&debug_str, allocation.start_time(), \",\");",
          "new_line_content": "  // offset: int. In bytes.",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": "end_time",
          "new_api": null,
          "old_text": "allocation.end_time()",
          "new_text": null,
          "old_line_content": "    absl::StrAppend(&debug_str, allocation.end_time(), \"\\n\");",
          "new_line_content": "  // start_time: int. Logical start time of the allocation.",
          "content_same": false
        },
        {
          "line": 3155,
          "old_api": "name",
          "new_api": null,
          "old_text": "computation->name()",
          "new_text": null,
          "old_line_content": "      VLOG(4) << \"Running simplify graph loop over \" << computation->name();",
          "new_line_content": "    // control dependencies).",
          "content_same": false
        },
        {
          "line": 3159,
          "old_api": "HasSideEffect",
          "new_api": null,
          "old_text": "instruction->HasSideEffect()",
          "new_text": null,
          "old_line_content": "            instruction->user_count() == 0 && !instruction->HasSideEffect() &&",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3160,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "computation->root_instruction()",
          "new_text": null,
          "old_line_content": "            instruction != computation->root_instruction() &&",
          "new_line_content": "    // We perform limited DCE and forward the tuple operand in patterns like",
          "content_same": false
        },
        {
          "line": 3161,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "instruction->opcode()",
          "new_text": null,
          "old_line_content": "            instruction->opcode() != HloOpcode::kCopyStart &&",
          "new_line_content": "    // GetTupleElement(Tuple(a, b), 0). This is mostly because memory space",
          "content_same": false
        },
        {
          "line": 3162,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "instruction->opcode()",
          "new_text": null,
          "old_line_content": "            instruction->opcode() != HloOpcode::kCopyDone) {",
          "new_line_content": "    // assignment is ran late in compilation (after DCE and arithmetic",
          "content_same": false
        },
        {
          "line": 3163,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "instruction->ToString()",
          "new_text": null,
          "old_line_content": "          VLOG(4) << \"Instruction removed: \" << instruction->ToString();",
          "new_line_content": "    // simplification passes) and we don't want to generate redundant code.  Run",
          "content_same": false
        },
        {
          "line": 3166,
          "old_api": "RemoveAssignmentForInstruction",
          "new_api": null,
          "old_text": "RemoveAssignmentForInstruction(instruction)",
          "new_text": null,
          "old_line_content": "          RemoveAssignmentForInstruction(instruction);",
          "new_line_content": "    while (computation_modified) {",
          "content_same": false
        },
        {
          "line": 1121,
          "old_api": "FindCrossProgramPrefetchCandidate",
          "new_api": null,
          "old_text": "FindCrossProgramPrefetchCandidate(\n            alias_analysis_, hlo_live_range_, options_)",
          "new_text": null,
          "old_line_content": "        prefetch_candidate = FindCrossProgramPrefetchCandidate(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1125,
          "old_api": "instruction",
          "new_api": null,
          "old_text": "prefetch_candidate->buffer->instruction()->GetModule()",
          "new_text": null,
          "old_line_content": "          prefetch_candidate->buffer->instruction()->GetModule();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3178,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "instruction->opcode()",
          "new_text": null,
          "old_line_content": "        } else if (instruction->opcode() == HloOpcode::kGetTupleElement) {",
          "new_line_content": "          // to the removed instruction.",
          "content_same": false
        },
        {
          "line": 3180,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "operand->opcode()",
          "new_text": null,
          "old_line_content": "          if (operand->opcode() == HloOpcode::kTuple) {",
          "new_line_content": "          // Instead of deleting the instruction from the schedule, replace it",
          "content_same": false
        },
        {
          "line": 1133,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(1)",
          "new_text": null,
          "old_line_content": "  VLOG(1) << \"Assigning buffers to alternate memory. Max heap size = \"",
          "new_line_content": "    absl::optional<AlternateMemoryBestFitHeap::BufferInterval>",
          "content_same": false
        },
        {
          "line": 3182,
          "old_api": "tuple_index",
          "new_api": null,
          "old_text": "instruction->tuple_index()",
          "new_text": null,
          "old_line_content": "                operand->mutable_operand(instruction->tuple_index());",
          "new_line_content": "          // logical time that is the index into flattened_instructions_ for",
          "content_same": false
        },
        {
          "line": 3183,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "instruction->ToString()",
          "new_text": null,
          "old_line_content": "            VLOG(4) << \"Replacing uses of \" << instruction->ToString()",
          "new_line_content": "          // scheduling asynchronous copies.",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": "AddInputAndOutputRequiredAssignments",
          "new_api": null,
          "old_text": "AddInputAndOutputRequiredAssignments()",
          "new_text": null,
          "old_line_content": "  AddInputAndOutputRequiredAssignments();",
          "new_line_content": "    if (prefetch_candidate) {",
          "content_same": false
        },
        {
          "line": 3184,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "forwarded_instruction->ToString()",
          "new_text": null,
          "old_line_content": "                    << \" with \" << forwarded_instruction->ToString();",
          "new_line_content": "          auto instruction_it =",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": "flattened_instruction_sequence",
          "new_api": null,
          "old_text": "hlo_live_range_.flattened_instruction_sequence().instructions()",
          "new_text": null,
          "old_line_content": "        hlo_live_range_.flattened_instruction_sequence().instructions();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1142,
          "old_api": "size",
          "new_api": null,
          "old_text": "instruction_sequence.size()",
          "new_text": null,
          "old_line_content": "    for (int i = 0; i < instruction_sequence.size(); ++i) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1143,
          "old_api": "parent",
          "new_api": null,
          "old_text": "instruction_sequence[i]->parent()->name()",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \" \" << i << \": \" << instruction_sequence[i]->parent()->name()",
          "new_line_content": "  std::vector<BufferInterval> sorted_buffer_intervals =",
          "content_same": false
        },
        {
          "line": 3194,
          "old_api": "operand",
          "new_api": null,
          "old_text": "instruction->operand(0)->opcode()",
          "new_text": null,
          "old_line_content": "              instruction->operand(0)->opcode() ==",
          "new_line_content": "            HloInstruction* forwarded_instruction =",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": "AreIntervalsReservedInAlternateMemory",
          "new_api": null,
          "old_text": "AreIntervalsReservedInAlternateMemory(colocated_intervals)",
          "new_text": null,
          "old_line_content": "    if (AreIntervalsReservedInAlternateMemory(colocated_intervals)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": "size_fn",
          "new_api": null,
          "old_text": "options_.size_fn(*interval.buffer)",
          "new_text": null,
          "old_line_content": "      reserved_in_bytes_ += options_.size_fn(*interval.buffer);",
          "new_line_content": "    const auto& instruction_sequence =",
          "content_same": false
        },
        {
          "line": 3201,
          "old_api": "operand_count",
          "new_api": null,
          "old_text": "instruction->operand_count()",
          "new_text": null,
          "old_line_content": "               operand_number < instruction->operand_count();",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 3204,
          "old_api": "operand",
          "new_api": null,
          "old_text": "instruction->operand(operand_number)",
          "new_text": null,
          "old_line_content": "                instruction->operand(operand_number);",
          "new_line_content": "          // with x.",
          "content_same": false
        },
        {
          "line": 3205,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "operand->opcode()",
          "new_text": null,
          "old_line_content": "            if (operand->opcode() != HloOpcode::kGetTupleElement ||",
          "new_line_content": "          bool can_replace =",
          "content_same": false
        },
        {
          "line": 3215,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "instruction->ToString()",
          "new_text": null,
          "old_line_content": "            VLOG(4) << \"Replacing uses of \" << instruction->ToString()",
          "new_line_content": "               ++operand_number) {",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": "instruction",
          "new_api": null,
          "old_text": "interval.buffer->instruction()",
          "new_text": null,
          "old_line_content": "    HloInstruction* inst = interval.buffer->instruction();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3216,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "forwarded_instruction->ToString()",
          "new_text": null,
          "old_line_content": "                    << \" with \" << forwarded_instruction->ToString();",
          "new_line_content": "            const HloInstruction* operand =",
          "content_same": false
        },
        {
          "line": 1172,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "inst->opcode()",
          "new_text": null,
          "old_line_content": "    if (inst->opcode() == HloOpcode::kParameter &&",
          "new_line_content": "    if (!interval.need_allocation) {",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": "CrossProgramPrefetches",
          "new_api": null,
          "old_text": "module->CrossProgramPrefetches()",
          "new_text": null,
          "old_line_content": "        absl::c_count(module->CrossProgramPrefetches(),",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": "parameter_number",
          "new_api": null,
          "old_text": "inst->parameter_number()",
          "new_text": null,
          "old_line_content": "                      std::make_pair(inst->parameter_number(),",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": "index",
          "new_api": null,
          "old_text": "interval.buffer->index()",
          "new_text": null,
          "old_line_content": "                                     interval.buffer->index())) > 0) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3226,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "            HloInstruction* forwarded_instruction =",
          "content_same": false
        },
        {
          "line": 3232,
          "old_api": "contains",
          "new_api": null,
          "old_text": "inserted_instructions->contains(new_instruction)",
          "new_text": null,
          "old_line_content": "  if (inserted_instructions->contains(new_instruction)) {",
          "new_line_content": "            computation_modified = true;",
          "content_same": false
        },
        {
          "line": 3235,
          "old_api": "operands",
          "new_api": null,
          "old_text": "new_instruction->operands()",
          "new_text": null,
          "old_line_content": "  for (HloInstruction* operand : new_instruction->operands()) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1190,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "interval.buffer->ToShortString()",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \"Interval \" << interval.buffer->ToShortString()",
          "new_line_content": "              << \" because it is cross-program prefetched.\";",
          "content_same": false
        },
        {
          "line": 3238,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "operand->opcode()",
          "new_text": null,
          "old_line_content": "    CHECK((operand->opcode() != HloOpcode::kCopyStart &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3240,
          "old_api": "contains",
          "new_api": null,
          "old_text": "inserted_instructions->contains(operand)",
          "new_text": null,
          "old_line_content": "          inserted_instructions->contains(operand))",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3241,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "new_instruction->ToString()",
          "new_text": null,
          "old_line_content": "        << \"Inserted instruction \" << new_instruction->ToString()",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3242,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "operand->ToString()",
          "new_text": null,
          "old_line_content": "        << \" has un-inserted dependency: \" << operand->ToString();",
          "new_line_content": "void MemorySpaceAssignment::EnsureInstructionAndOperandsInserted(",
          "content_same": false
        },
        {
          "line": 3243,
          "old_api": "EnsureInstructionAndOperandsInserted",
          "new_api": null,
          "old_text": "EnsureInstructionAndOperandsInserted(operand, new_sequence,\n                                         inserted_instructions)",
          "new_text": null,
          "old_line_content": "    EnsureInstructionAndOperandsInserted(operand, new_sequence,",
          "new_line_content": "    HloInstruction* new_instruction, HloInstructionSequence* new_sequence,",
          "content_same": false
        },
        {
          "line": 1197,
          "old_api": "positions",
          "new_api": null,
          "old_text": "value->positions()",
          "new_text": null,
          "old_line_content": "        for (auto& position : value->positions()) {",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "position.ToString()",
          "new_text": null,
          "old_line_content": "          VLOG(4) << \"Coloring \" << position.ToString();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1199,
          "old_api": "mutable_shape",
          "new_api": null,
          "old_text": "ShapeUtil::GetMutableSubshape(\n              position.instruction->mutable_shape(), position.index)",
          "new_text": null,
          "old_line_content": "          Shape* shape = ShapeUtil::GetMutableSubshape(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3246,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "new_instruction->ToShortString()",
          "new_text": null,
          "old_line_content": "  VLOG(4) << \"inserting: \" << new_instruction->ToShortString();",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": "IsArray",
          "new_api": null,
          "old_text": "shape->IsArray()",
          "new_text": null,
          "old_line_content": "          CHECK(shape->IsArray()) << \"Coloring a shape that is not an array: \"",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3247,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "new_sequence->push_back(new_instruction)",
          "new_text": null,
          "old_line_content": "  new_sequence->push_back(new_instruction);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3257,
          "old_api": "is_copy_allocation",
          "new_api": null,
          "old_text": "allocation->is_copy_allocation()",
          "new_text": null,
          "old_line_content": "      if (allocation->is_copy_allocation()) {",
          "new_line_content": "                                         inserted_instructions);",
          "content_same": false
        },
        {
          "line": 3258,
          "old_api": "get",
          "new_api": null,
          "old_text": "allocation.get()",
          "new_text": null,
          "old_line_content": "        auto copy_allocation = static_cast<CopyAllocation*>(allocation.get());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1218,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "ConsumeFuel(\"memory_space_assignment\", [&] {\n          return absl::StrCat(\"Ran out of fuel at buffer: \",\n                              colocated_intervals[0]->buffer->ToShortString());\n        })",
          "new_text": null,
          "old_line_content": "    if (!ConsumeFuel(\"memory_space_assignment\", [&] {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "absl::StrCat(\"Ran out of fuel at buffer: \",\n                              colocated_intervals[0]->buffer->ToShortString())",
          "new_text": null,
          "old_line_content": "          return absl::StrCat(\"Ran out of fuel at buffer: \",",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "colocated_intervals[0]->buffer->ToShortString()",
          "new_text": null,
          "old_line_content": "                              colocated_intervals[0]->buffer->ToShortString());",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 3267,
          "old_api": "copy_done_schedule_before",
          "new_api": null,
          "old_text": "first->copy_done_schedule_before()",
          "new_text": null,
          "old_line_content": "          return std::forward_as_tuple(first->copy_done_schedule_before(),",
          "new_line_content": "       {MemorySpace::kDefault, MemorySpace::kAlternate}) {",
          "content_same": false
        },
        {
          "line": 3268,
          "old_api": "copy_start_schedule_after",
          "new_api": null,
          "old_text": "first->copy_start_schedule_after()",
          "new_text": null,
          "old_line_content": "                                       first->copy_start_schedule_after()) <",
          "new_line_content": "    std::vector<CopyAllocation*> copy_allocations;",
          "content_same": false
        },
        {
          "line": 3269,
          "old_api": "copy_done_schedule_before",
          "new_api": null,
          "old_text": "second->copy_done_schedule_before()",
          "new_text": null,
          "old_line_content": "                 std::forward_as_tuple(second->copy_done_schedule_before(),",
          "new_line_content": "    for (auto& allocation : allocations_) {",
          "content_same": false
        },
        {
          "line": 1228,
          "old_api": "CreateAllocationValuesFromColocatedIntervals",
          "new_api": null,
          "old_text": "CreateAllocationValuesFromColocatedIntervals(colocated_intervals,\n                                                 allocation_values)",
          "new_text": null,
          "old_line_content": "    CreateAllocationValuesFromColocatedIntervals(colocated_intervals,",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 1235,
          "old_api": "AddRequiredAssignmentsForColocatedIntervals",
          "new_api": null,
          "old_text": "AddRequiredAssignmentsForColocatedIntervals(colocated_intervals)",
          "new_text": null,
          "old_line_content": "      AddRequiredAssignmentsForColocatedIntervals(colocated_intervals);",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 1237,
          "old_api": "SetRetryNumber",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->SetRetryNumber(retry_number)",
          "new_text": null,
          "old_line_content": "      options_.prefetch_interval_picker->SetRetryNumber(retry_number);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3285,
          "old_api": "copy_start",
          "new_api": null,
          "old_text": "copy_allocation->copy_start()->ToString()",
          "new_text": null,
          "old_line_content": "                << copy_allocation->copy_start()->ToString()",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": "absl::MakeSpan(allocation_values)",
          "new_api": null,
          "old_text": "absl::MakeSpan(allocation_values)",
          "new_text": null,
          "old_line_content": "          AllocateAllocationValues(absl::MakeSpan(allocation_values));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1240,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(2)",
          "new_text": null,
          "old_line_content": "      VLOG(2) << \"Allocation result = \"",
          "new_line_content": "    std::vector<AllocationValue> allocation_values;",
          "content_same": false
        },
        {
          "line": 3287,
          "old_api": "set_copy_start_schedule_after",
          "new_api": null,
          "old_text": "copy_allocation->set_copy_start_schedule_after(\n            ++copy_start_schedule_after)",
          "new_text": null,
          "old_line_content": "        copy_allocation->set_copy_start_schedule_after(",
          "new_line_content": "    for (CopyAllocation* copy_allocation : copy_allocations) {",
          "content_same": false
        },
        {
          "line": 1242,
          "old_api": "result_requires_uncommit",
          "new_api": null,
          "old_text": "result_requires_uncommit(result)",
          "new_text": null,
          "old_line_content": "      if (result_requires_uncommit(result) ||",
          "new_line_content": "                                                 allocation_values);",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": "result_failed_because_of_async_copy",
          "new_api": null,
          "old_text": "result_failed_because_of_async_copy(result)",
          "new_text": null,
          "old_line_content": "          (!final_retry && result_failed_because_of_async_copy(result))) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": "absl::MakeSpan(allocation_values)",
          "new_api": null,
          "old_text": "absl::MakeSpan(allocation_values)",
          "new_text": null,
          "old_line_content": "        UncommitPendingChunks(absl::MakeSpan(allocation_values));",
          "new_line_content": "    // Retry allocating this value with larger limits if allocation fails.",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(2)",
          "new_text": null,
          "old_line_content": "        VLOG(2) << \"Couldn't allocate. Retry number \" << retry_number;",
          "new_line_content": "    bool repacked = false;",
          "content_same": false
        },
        {
          "line": 1246,
          "old_api": "result_is",
          "new_api": null,
          "old_text": "result_is(result, Result::kFailOutOfMemory)",
          "new_text": null,
          "old_line_content": "      } else if ((result_is(result, Result::kFailOutOfMemory) ||",
          "new_line_content": "    for (int retry_number = 0; retry_number < options_.max_retries;",
          "content_same": false
        },
        {
          "line": 3292,
          "old_api": "copy_start",
          "new_api": null,
          "old_text": "copy_allocation->copy_start()",
          "new_text": null,
          "old_line_content": "          copy_allocation->copy_start());",
          "new_line_content": "      // Accessing flattened_instructions_ here without checking if it is",
          "content_same": false
        },
        {
          "line": 3293,
          "old_api": "copy_done_schedule_before",
          "new_api": null,
          "old_text": "copy_allocation->copy_done_schedule_before()",
          "new_text": null,
          "old_line_content": "      schedule_before_[copy_allocation->copy_done_schedule_before()].push_back(",
          "new_line_content": "      // nullptr is safe because this method is called before SimplifyGraph.",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": "absl::MakeSpan(allocation_values)",
          "new_api": null,
          "old_text": "absl::MakeSpan(allocation_values)",
          "new_text": null,
          "old_line_content": "        UncommitPendingChunks(absl::MakeSpan(allocation_values));",
          "new_line_content": "      bool final_retry = (retry_number == options_.max_retries - 1);",
          "content_same": false
        },
        {
          "line": 3301,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(1)",
          "new_text": null,
          "old_line_content": "  VLOG(1) << \"Fixing schedule...\";",
          "new_line_content": "            ++copy_start_schedule_after);",
          "content_same": false
        },
        {
          "line": 3302,
          "old_api": "has_schedule",
          "new_api": null,
          "old_text": "module_->has_schedule()",
          "new_text": null,
          "old_line_content": "  CHECK(module_->has_schedule());",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3303,
          "old_api": "schedule",
          "new_api": null,
          "old_text": "module_->schedule()",
          "new_text": null,
          "old_line_content": "  HloSchedule& schedule = module_->schedule();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(2)",
          "new_text": null,
          "old_line_content": "        VLOG(2) << \"Repack complete. Modified = \" << *repack_status;",
          "new_line_content": "                  options_.repack_after_every_allocation) &&",
          "content_same": false
        },
        {
          "line": 3308,
          "old_api": "contains",
          "new_api": null,
          "old_text": "computations_in_schedule_.contains(computation)",
          "new_text": null,
          "old_line_content": "    if (!computations_in_schedule_.contains(computation)) {",
          "new_line_content": "      prev_copy_allocation = copy_allocation;",
          "content_same": false
        },
        {
          "line": 3309,
          "old_api": "name",
          "new_api": null,
          "old_text": "computation->name()",
          "new_text": null,
          "old_line_content": "      VLOG(4) << \"Not scheduling \" << computation->name()",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3313,
          "old_api": "is_computation_scheduled",
          "new_api": null,
          "old_text": "schedule.is_computation_scheduled(computation)",
          "new_text": null,
          "old_line_content": "    CHECK(schedule.is_computation_scheduled(computation));",
          "new_line_content": "Status MemorySpaceAssignment::FixSchedule() {",
          "content_same": false
        },
        {
          "line": 1266,
          "old_api": "absl::MakeSpan(allocation_values)",
          "new_api": null,
          "old_text": "absl::MakeSpan(allocation_values)",
          "new_text": null,
          "old_line_content": "        FinalizeAllocations(absl::MakeSpan(allocation_values));",
          "new_line_content": "        std::vector<MemorySpaceAssignmentRepacker::AllocationBlock*>",
          "content_same": false
        },
        {
          "line": 1274,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"Debug allocation info: \";",
          "new_line_content": "        if (*repack_status) {",
          "content_same": false
        },
        {
          "line": 3323,
          "old_api": "find",
          "new_api": null,
          "old_text": "schedule_before_.find(instruction_index)",
          "new_text": null,
          "old_line_content": "      auto insts_before_iter = schedule_before_.find(instruction_index);",
          "new_line_content": "              << \" because it's not in the schedule.\";",
          "content_same": false
        },
        {
          "line": 1276,
          "old_api": "DumpDebugStringsIfEnabled",
          "new_api": null,
          "old_text": "DumpDebugStringsIfEnabled()",
          "new_text": null,
          "old_line_content": "  DumpDebugStringsIfEnabled();",
          "new_line_content": "          --retry_number;",
          "content_same": false
        },
        {
          "line": 3324,
          "old_api": "end",
          "new_api": null,
          "old_text": "schedule_before_.end()",
          "new_text": null,
          "old_line_content": "      if (insts_before_iter != schedule_before_.end()) {",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 3327,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(4)",
          "new_text": null,
          "old_line_content": "            VLOG(4) << \"before \" << instruction_index << \": \"",
          "new_line_content": "    HloInstructionSequence new_sequence;",
          "content_same": false
        },
        {
          "line": 1280,
          "old_api": "std::move(result_)",
          "new_api": null,
          "old_text": "std::move(result_)",
          "new_text": null,
          "old_line_content": "  result.heap_results.emplace_back(std::move(result_));",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 3328,
          "old_api": "name",
          "new_api": null,
          "old_text": "new_instruction->name()",
          "new_text": null,
          "old_line_content": "                    << new_instruction->name();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3329,
          "old_api": "EnsureInstructionAndOperandsInserted",
          "new_api": null,
          "old_text": "EnsureInstructionAndOperandsInserted(new_instruction, &new_sequence,\n                                                 &inserted_instructions)",
          "new_text": null,
          "old_line_content": "            EnsureInstructionAndOperandsInserted(new_instruction, &new_sequence,",
          "new_line_content": "    absl::flat_hash_set<HloInstruction*> inserted_instructions;",
          "content_same": false
        },
        {
          "line": 1291,
          "old_api": "positions",
          "new_api": null,
          "old_text": "value->positions()",
          "new_text": null,
          "old_line_content": "    for (const auto& position : value->positions()) {",
          "new_line_content": "  HeapSimulator::Result<HloValue> result;",
          "content_same": false
        },
        {
          "line": 1292,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "position.instruction->opcode()",
          "new_text": null,
          "old_line_content": "      if (position.instruction->opcode() == HloOpcode::kConditional) {",
          "new_line_content": "  result.heap_size = result_.heap_size;",
          "content_same": false
        },
        {
          "line": 1294,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "value->ToShortString()",
          "new_text": null,
          "old_line_content": "                << value->ToShortString();",
          "new_line_content": "  return result;",
          "content_same": false
        },
        {
          "line": 1295,
          "old_api": "AddRequiredAssignment",
          "new_api": null,
          "old_text": "AddRequiredAssignment(position.instruction, position.index,\n                              MemorySpace::kDefault)",
          "new_text": null,
          "old_line_content": "        AddRequiredAssignment(position.instruction, position.index,",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3343,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "instruction->opcode()",
          "new_text": null,
          "old_line_content": "          instruction->opcode() != HloOpcode::kTuple) {",
          "new_line_content": "                                                 &inserted_instructions);",
          "content_same": false
        },
        {
          "line": 3344,
          "old_api": "name",
          "new_api": null,
          "old_text": "instruction->name()",
          "new_text": null,
          "old_line_content": "        VLOG(4) << \"inst \" << instruction_index << \": \" << instruction->name();",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": "called_computations",
          "new_api": null,
          "old_text": "position.instruction->called_computations()",
          "new_text": null,
          "old_line_content": "             position.instruction->called_computations()) {",
          "new_line_content": "    absl::Span<const AlternateMemoryBestFitHeap::BufferInterval* const>",
          "content_same": false
        },
        {
          "line": 1299,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "called_computation->root_instruction()",
          "new_text": null,
          "old_line_content": "          AddRequiredAssignment(called_computation->root_instruction(),",
          "new_line_content": "        colocated_intervals) {",
          "content_same": false
        },
        {
          "line": 3345,
          "old_api": "EnsureInstructionAndOperandsInserted",
          "new_api": null,
          "old_text": "EnsureInstructionAndOperandsInserted(instruction, &new_sequence,\n                                             &inserted_instructions)",
          "new_text": null,
          "old_line_content": "        EnsureInstructionAndOperandsInserted(instruction, &new_sequence,",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3348,
          "old_api": "find",
          "new_api": null,
          "old_text": "schedule_after_.find(instruction_index)",
          "new_text": null,
          "old_line_content": "      auto insts_after_iter = schedule_after_.find(instruction_index);",
          "new_line_content": "      // Insert only if it is not deleted (SimplifyGraph sets it to nullptr if",
          "content_same": false
        },
        {
          "line": 3349,
          "old_api": "end",
          "new_api": null,
          "old_text": "schedule_after_.end()",
          "new_text": null,
          "old_line_content": "      if (insts_after_iter != schedule_after_.end()) {",
          "new_line_content": "      // it was deleted) and not previously inserted. Also bitcasts and tuples",
          "content_same": false
        },
        {
          "line": 3351,
          "old_api": "parent",
          "new_api": null,
          "old_text": "new_instruction->parent()",
          "new_text": null,
          "old_line_content": "          if (new_instruction->parent() == computation) {",
          "new_line_content": "      // dependencies.",
          "content_same": false
        },
        {
          "line": 3352,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(4)",
          "new_text": null,
          "old_line_content": "            VLOG(4) << \"after \" << instruction_index << \": \"",
          "new_line_content": "      if (instruction != nullptr &&",
          "content_same": false
        },
        {
          "line": 1313,
          "old_api": "CreateAllocationValues",
          "new_api": null,
          "old_text": "CreateAllocationValues(*colocated_interval, allocation_values)",
          "new_text": null,
          "old_line_content": "    CreateAllocationValues(*colocated_interval, allocation_values);",
          "new_line_content": "                                position.index, MemorySpace::kDefault);",
          "content_same": false
        },
        {
          "line": 1315,
          "old_api": "FindAliases",
          "new_api": null,
          "old_text": "FindAliases(&allocation_values, /*skip_values_with_no_uses=*/true)",
          "new_text": null,
          "old_line_content": "  FindAliases(&allocation_values, /*skip_values_with_no_uses=*/true);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3368,
          "old_api": "set_sequence",
          "new_api": null,
          "old_text": "schedule.set_sequence(computation, new_sequence)",
          "new_text": null,
          "old_line_content": "    schedule.set_sequence(computation, new_sequence);",
          "new_line_content": "                                                 &inserted_instructions);",
          "content_same": false
        },
        {
          "line": 1321,
          "old_api": "instruction_schedule",
          "new_api": null,
          "old_text": "hlo_live_range_.instruction_schedule()",
          "new_text": null,
          "old_line_content": "  const auto& instruction_schedule = hlo_live_range_.instruction_schedule();",
          "new_line_content": "    absl::Span<const AlternateMemoryBestFitHeap::BufferInterval* const>",
          "content_same": false
        },
        {
          "line": 3371,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3376,
          "old_api": "TF_ASSIGN_OR_RETURN",
          "new_api": null,
          "old_text": "TF_ASSIGN_OR_RETURN(std::unique_ptr<HloAliasAnalysis> alias_analysis,\n                      HloAliasAnalysis::Run(module_))",
          "new_text": null,
          "old_line_content": "  TF_ASSIGN_OR_RETURN(std::unique_ptr<HloAliasAnalysis> alias_analysis,",
          "new_line_content": "                                         &new_sequence, &inserted_instructions);",
          "content_same": false
        },
        {
          "line": 1329,
          "old_api": "std::back_inserter(all_use_times)",
          "new_api": null,
          "old_text": "std::back_inserter(all_use_times)",
          "new_text": null,
          "old_line_content": "                      std::back_inserter(all_use_times),",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1332,
          "old_api": "absl::c_sort(all_use_times)",
          "new_api": null,
          "old_text": "absl::c_sort(all_use_times)",
          "new_text": null,
          "old_line_content": "  absl::c_sort(all_use_times);",
          "new_line_content": "AlternateMemoryBestFitHeap::AllocateAllocationValues(",
          "content_same": false
        },
        {
          "line": 1343,
          "old_api": "defining_instruction",
          "new_api": null,
          "old_text": "allocation_value.defining_instruction()",
          "new_text": null,
          "old_line_content": "        instruction_schedule.at(allocation_value.defining_instruction());",
          "new_line_content": "                      [](const AllocationValue::Use& use) { return use.time; });",
          "content_same": false
        },
        {
          "line": 3394,
          "old_api": "id",
          "new_api": null,
          "old_text": "value->id()",
          "new_text": null,
          "old_line_content": "    events[std::make_tuple(start_time, /*is_free=*/false, value->id())] =",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1347,
          "old_api": "computation",
          "new_api": null,
          "old_text": "allocation_value.computation()",
          "new_text": null,
          "old_line_content": "        preferred_offset_for_computation.find(allocation_value.computation());",
          "new_line_content": "  // Data structure to contain the preferred offset for a given computation.",
          "content_same": false
        },
        {
          "line": 1348,
          "old_api": "end",
          "new_api": null,
          "old_text": "preferred_offset_for_computation.end()",
          "new_text": null,
          "old_line_content": "    if (preferred_offset_it != preferred_offset_for_computation.end()) {",
          "new_line_content": "  // We ensure that the same offset will be allocated outside the while loop",
          "content_same": false
        },
        {
          "line": 3395,
          "old_api": "std::make_tuple(value, chunk, HeapSimulatorTrace::Event::ALLOC)",
          "new_api": null,
          "old_text": "std::make_tuple(value, chunk, HeapSimulatorTrace::Event::ALLOC)",
          "new_text": null,
          "old_line_content": "        std::make_tuple(value, chunk, HeapSimulatorTrace::Event::ALLOC);",
          "new_line_content": "  BufferIntervalTree interval_tree;",
          "content_same": false
        },
        {
          "line": 3396,
          "old_api": "id",
          "new_api": null,
          "old_text": "value->id()",
          "new_text": null,
          "old_line_content": "    events[std::make_tuple(end_time, /*is_free=*/true, value->id())] =",
          "new_line_content": "  absl::flat_hash_set<int64> seen_buffers;",
          "content_same": false
        },
        {
          "line": 3397,
          "old_api": "std::make_tuple(value, chunk, HeapSimulatorTrace::Event::FREE)",
          "new_api": null,
          "old_text": "std::make_tuple(value, chunk, HeapSimulatorTrace::Event::FREE)",
          "new_text": null,
          "old_line_content": "        std::make_tuple(value, chunk, HeapSimulatorTrace::Event::FREE);",
          "new_line_content": "  // The key for events is: time, is_free, value_id. This is so that the events",
          "content_same": false
        },
        {
          "line": 1353,
          "old_api": "uses",
          "new_api": null,
          "old_text": "allocation_value.uses().size()",
          "new_text": null,
          "old_line_content": "    for (int use_idx = 0; use_idx < allocation_value.uses().size(); ++use_idx) {",
          "new_line_content": "  Result result = Result::kSuccess;",
          "content_same": false
        },
        {
          "line": 1354,
          "old_api": "uses",
          "new_api": null,
          "old_text": "allocation_value.uses().at(use_idx)",
          "new_text": null,
          "old_line_content": "      const AllocationValue::Use& use = allocation_value.uses().at(use_idx);",
          "new_line_content": "  for (AllocationValue& allocation_value : allocation_values) {",
          "content_same": false
        },
        {
          "line": 3406,
          "old_api": "ChunksOverlappingInTime",
          "new_api": null,
          "old_text": "interval_tree.ChunksOverlappingInTime(start_time, end_time - 1)",
          "new_text": null,
          "old_line_content": "         interval_tree.ChunksOverlappingInTime(start_time, end_time - 1)) {",
          "new_line_content": "                                       const HloValue* value) {",
          "content_same": false
        },
        {
          "line": 1363,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "hlo_use.instruction->opcode()",
          "new_text": null,
          "old_line_content": "          (GetInstructionCallContext(hlo_use.instruction->opcode()) ==",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3411,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "value->ToShortString()",
          "new_text": null,
          "old_line_content": "            value->ToShortString(), start_time, end_time, chunk.offset,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3415,
          "old_api": "Add",
          "new_api": null,
          "old_text": "interval_tree.Add(start_time, end_time - 1, chunk)",
          "new_text": null,
          "old_line_content": "    interval_tree.Add(start_time, end_time - 1, chunk);",
          "new_line_content": "    // really should check against end_time (inclusive) for cases where the",
          "content_same": false
        },
        {
          "line": 3416,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "    return Status::OK();",
          "new_line_content": "    // operand can't share buffer with user (see",
          "content_same": false
        },
        {
          "line": 1371,
          "old_api": "std::min(computation_span.start - 1, latest_prefetch_time)",
          "new_api": null,
          "old_text": "std::min(computation_span.start - 1, latest_prefetch_time)",
          "new_text": null,
          "old_line_content": "              std::min(computation_span.start - 1, latest_prefetch_time);",
          "new_line_content": "      bool allow_no_copy_alternate_mem_allocation = true;",
          "content_same": false
        },
        {
          "line": 1373,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "hlo_use.instruction->opcode()",
          "new_text": null,
          "old_line_content": "        if (hlo_use.instruction->opcode() == HloOpcode::kWhile) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3422,
          "old_api": "MakeNonfusionComputations",
          "new_api": null,
          "old_text": "module_->MakeNonfusionComputations()",
          "new_text": null,
          "old_line_content": "       module_->MakeNonfusionComputations()) {",
          "new_line_content": "            (\"Value %s (%d, %d) off: %d size: %d overlaps with another chunk\"",
          "content_same": false
        },
        {
          "line": 3423,
          "old_api": "instructions",
          "new_api": null,
          "old_text": "computation->instructions()",
          "new_text": null,
          "old_line_content": "    for (const HloInstruction* instruction : computation->instructions()) {",
          "new_line_content": "             \" off: %d size: %d\"),",
          "content_same": false
        },
        {
          "line": 3426,
          "old_api": "shape",
          "new_api": null,
          "old_text": "instruction->shape()",
          "new_text": null,
          "old_line_content": "            ShapeUtil::GetSubshape(instruction->shape(), {1})",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3430,
          "old_api": "shape",
          "new_api": null,
          "old_text": "instruction->shape()",
          "new_text": null,
          "old_line_content": "            ShapeUtil::GetSubshape(instruction->shape(), {0})",
          "new_line_content": "  };",
          "content_same": false
        },
        {
          "line": 3433,
          "old_api": "CHECK_NE",
          "new_api": null,
          "old_text": "CHECK_NE(from_memory_space, to_memory_space)",
          "new_text": null,
          "old_line_content": "        CHECK_NE(from_memory_space, to_memory_space)",
          "new_line_content": "  // instructions copy between alternate memory and default memory.",
          "content_same": false
        },
        {
          "line": 3440,
          "old_api": "chunks",
          "new_api": null,
          "old_text": "preset_assignments_->chunks()",
          "new_text": null,
          "old_line_content": "  for (const auto& position_and_chunk : preset_assignments_->chunks()) {",
          "new_line_content": "                .layout()",
          "content_same": false
        },
        {
          "line": 1394,
          "old_api": "while_body",
          "new_api": null,
          "old_text": "hlo_use.instruction->while_body()",
          "new_text": null,
          "old_line_content": "          HloComputation* while_body = hlo_use.instruction->while_body();",
          "new_line_content": "          // 3:   ...",
          "content_same": false
        },
        {
          "line": 1396,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "while_body->root_instruction()",
          "new_text": null,
          "old_line_content": "          CHECK_EQ(instruction_schedule.at(while_body->root_instruction()) + 1,",
          "new_line_content": "          //     body {",
          "content_same": false
        },
        {
          "line": 1397,
          "old_api": "at",
          "new_api": null,
          "old_text": "instruction_schedule.at(hlo_use.instruction)",
          "new_text": null,
          "old_line_content": "                   instruction_schedule.at(hlo_use.instruction))",
          "new_line_content": "          // 4:   p = param(0)",
          "content_same": false
        },
        {
          "line": 3444,
          "old_api": "GetUniqueBufferAt",
          "new_api": null,
          "old_text": "alias_analysis->GetUniqueBufferAt(position.instruction, position.index)",
          "new_text": null,
          "old_line_content": "        alias_analysis->GetUniqueBufferAt(position.instruction, position.index);",
          "new_line_content": "                .layout()",
          "content_same": false
        },
        {
          "line": 3445,
          "old_api": "id",
          "new_api": null,
          "old_text": "buffer.id()",
          "new_text": null,
          "old_line_content": "    CHECK(!seen_buffers.contains(buffer.id()))",
          "new_line_content": "                .memory_space();",
          "content_same": false
        },
        {
          "line": 3447,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "position.ToString()",
          "new_text": null,
          "old_line_content": "        << buffer.ToString() << \", pos: \" << position.ToString()",
          "new_line_content": "            << \"Asynchronous copy to the same memory space: \"",
          "content_same": false
        },
        {
          "line": 3449,
          "old_api": "id",
          "new_api": null,
          "old_text": "buffer.id()",
          "new_text": null,
          "old_line_content": "    seen_buffers.insert(buffer.id());",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3451,
          "old_api": "values",
          "new_api": null,
          "old_text": "buffer.values()",
          "new_text": null,
          "old_line_content": "    for (const HloValue* value : buffer.values()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1404,
          "old_api": "parameter_instruction",
          "new_api": null,
          "old_text": "while_body->parameter_instruction(0)",
          "new_text": null,
          "old_line_content": "              instruction_schedule.at(while_body->parameter_instruction(0));",
          "new_line_content": "          // the interval to time 0-4. This is so that the remaining interval",
          "content_same": false
        },
        {
          "line": 1405,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "hlo_use.instruction->opcode()",
          "new_text": null,
          "old_line_content": "        } else if (hlo_use.instruction->opcode() == HloOpcode::kConditional) {",
          "new_line_content": "          // (5-6) can be allocated separately and this buffer doesn't waste",
          "content_same": false
        },
        {
          "line": 3456,
          "old_api": "uses",
          "new_api": null,
          "old_text": "value->uses()",
          "new_text": null,
          "old_line_content": "      for (const HloUse& use : value->uses()) {",
          "new_line_content": "    const HloBuffer& buffer =",
          "content_same": false
        },
        {
          "line": 1411,
          "old_api": "at",
          "new_api": null,
          "old_text": "instruction_schedule.at(\n                              called_computation->parameter_instruction(0))",
          "new_text": null,
          "old_line_content": "                use_time, instruction_schedule.at(",
          "new_line_content": "              << \"While body ROOTs need to be the last in the schedule!  \"",
          "content_same": false
        },
        {
          "line": 1412,
          "old_api": "parameter_instruction",
          "new_api": null,
          "old_text": "called_computation->parameter_instruction(0)",
          "new_text": null,
          "old_line_content": "                              called_computation->parameter_instruction(0)));",
          "new_line_content": "                 \"Please run RootInstructionSinker.\";",
          "content_same": false
        },
        {
          "line": 1419,
          "old_api": "IsUseAllowedInAlternateMemory",
          "new_api": null,
          "old_text": "IsUseAllowedInAlternateMemory(allocation_value, hlo_use)",
          "new_text": null,
          "old_line_content": "      if (!IsUseAllowedInAlternateMemory(allocation_value, hlo_use)) {",
          "new_line_content": "          // Replace the use time with the earliest parameter of called",
          "content_same": false
        },
        {
          "line": 1420,
          "old_api": "value",
          "new_api": null,
          "old_text": "allocation_value.value()",
          "new_text": null,
          "old_line_content": "        AddRequiredAssignment(allocation_value.value(), hlo_use.instruction,",
          "new_line_content": "          // computations.",
          "content_same": false
        },
        {
          "line": 3474,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "        VLOG(3) << indent_string",
          "new_line_content": "          last_use_instruction = use.instruction;",
          "content_same": false
        },
        {
          "line": 3475,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "buffer.ToString()",
          "new_text": null,
          "old_line_content": "                << \"Splitting conditional buffer: \" << buffer.ToString()",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3476,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "value->ToShortString()",
          "new_text": null,
          "old_line_content": "                << \" value: \" << value->ToShortString() << \": (\" << start_time",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1430,
          "old_api": "uses",
          "new_api": null,
          "old_text": "allocation_value.uses().at(use_idx - 1)",
          "new_text": null,
          "old_line_content": "            allocation_value.uses().at(use_idx - 1);",
          "new_line_content": "      // Add a required assignment in default memory if the use not allowed in",
          "content_same": false
        },
        {
          "line": 1431,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "previous_use.hlo_use.instruction->opcode()",
          "new_text": null,
          "old_line_content": "        if (previous_use.hlo_use.instruction->opcode() ==",
          "new_line_content": "      // alternate memory.",
          "content_same": false
        },
        {
          "line": 3481,
          "old_api": "called_computations",
          "new_api": null,
          "old_text": "use_instruction->called_computations()",
          "new_text": null,
          "old_line_content": "             use_instruction->called_computations()) {",
          "new_line_content": "      split_conditional_buffer = [&](const HloInstruction* use_instruction,",
          "content_same": false
        },
        {
          "line": 3483,
          "old_api": "at",
          "new_api": null,
          "old_text": "std::min(earliest_computation_start_time,\n                       hlo_live_range->computation_span_times()\n                           .at(called_computation)\n                           .start)",
          "new_text": null,
          "old_line_content": "              std::min(earliest_computation_start_time,",
          "new_line_content": "                                     absl::string_view indent_string) {",
          "content_same": false
        },
        {
          "line": 1436,
          "old_api": "at",
          "new_api": null,
          "old_text": "instruction_schedule.at(previous_use.hlo_use.instruction)",
          "new_text": null,
          "old_line_content": "              instruction_schedule.at(previous_use.hlo_use.instruction);",
          "new_line_content": "        // We allow buffers in alternate memory that are passed into",
          "content_same": false
        },
        {
          "line": 1437,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "previous_use.hlo_use.ToString()",
          "new_text": null,
          "old_line_content": "          VLOG(3) << \"Previous use (\" << previous_use.hlo_use.ToString()",
          "new_line_content": "        // conditionals to give up their alternate memory allocation inside the",
          "content_same": false
        },
        {
          "line": 1438,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "hlo_use.ToString()",
          "new_text": null,
          "old_line_content": "                  << \") of use (\" << hlo_use.ToString()",
          "new_line_content": "        // called computation. This means that if a conditional operator has an",
          "content_same": false
        },
        {
          "line": 3484,
          "old_api": "at",
          "new_api": null,
          "old_text": "hlo_live_range->computation_span_times()\n                           .at(called_computation)",
          "new_text": null,
          "old_line_content": "                       hlo_live_range->computation_span_times()",
          "new_line_content": "        // Special case when verifying conditional: we internally split the use",
          "content_same": false
        },
        {
          "line": 3490,
          "old_api": "positions",
          "new_api": null,
          "old_text": "value->positions()",
          "new_text": null,
          "old_line_content": "          for (const HloPosition& position : value->positions()) {",
          "new_line_content": "                << \", \" << end_time << \") off: \" << chunk.offset",
          "content_same": false
        },
        {
          "line": 3491,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "position.instruction->opcode()",
          "new_text": null,
          "old_line_content": "            if (position.instruction->opcode() == HloOpcode::kParameter &&",
          "new_line_content": "                << \", size: \" << chunk.size;",
          "content_same": false
        },
        {
          "line": 3492,
          "old_api": "parent",
          "new_api": null,
          "old_text": "position.instruction->parent()",
          "new_text": null,
          "old_line_content": "                position.instruction->parent() == called_computation) {",
          "new_line_content": "        int64 earliest_computation_start_time = end_time;",
          "content_same": false
        },
        {
          "line": 3493,
          "old_api": "at",
          "new_api": null,
          "old_text": "hlo_live_range->instruction_schedule().at(\n                  position.instruction)",
          "new_text": null,
          "old_line_content": "              parameter_time = hlo_live_range->instruction_schedule().at(",
          "new_line_content": "        for (const HloComputation* called_computation :",
          "content_same": false
        },
        {
          "line": 1448,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "hlo_use.instruction->opcode()",
          "new_text": null,
          "old_line_content": "      if (hlo_use.instruction->opcode() != HloOpcode::kBitcast ||",
          "new_line_content": "          earliest_prefetch_time =",
          "content_same": false
        },
        {
          "line": 3498,
          "old_api": "uses",
          "new_api": null,
          "old_text": "value->uses()",
          "new_text": null,
          "old_line_content": "          for (const HloUse& use : value->uses()) {",
          "new_line_content": "                           .at(called_computation)",
          "content_same": false
        },
        {
          "line": 3500,
          "old_api": "at",
          "new_api": null,
          "old_text": "hlo_live_range->instruction_schedule().at(use.instruction)",
          "new_text": null,
          "old_line_content": "                hlo_live_range->instruction_schedule().at(use.instruction);",
          "new_line_content": "          int64 parameter_time = -1;",
          "content_same": false
        },
        {
          "line": 3501,
          "old_api": "parent",
          "new_api": null,
          "old_text": "use.instruction->parent()",
          "new_text": null,
          "old_line_content": "            if (use.instruction->parent() == called_computation &&",
          "new_line_content": "          int64 last_use_time = -1;",
          "content_same": false
        },
        {
          "line": 1455,
          "old_api": "std::min(definition_time, use_time)",
          "new_api": null,
          "old_text": "std::min(definition_time, use_time)",
          "new_text": null,
          "old_line_content": "        request.start_time = std::min(definition_time, use_time);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1458,
          "old_api": "size",
          "new_api": null,
          "old_text": "allocation_value.size()",
          "new_text": null,
          "old_line_content": "        request.size = allocation_value.size();",
          "new_line_content": "      // allocating buffers for bitcast uses (unless they are the root",
          "content_same": false
        },
        {
          "line": 3508,
          "old_api": "CHECK_NE",
          "new_api": null,
          "old_text": "CHECK_NE(parameter_time, -1)",
          "new_text": null,
          "old_line_content": "            CHECK_NE(parameter_time, -1);",
          "new_line_content": "              break;",
          "content_same": false
        },
        {
          "line": 3509,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "            VLOG(3) << indent_string",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3510,
          "old_api": "name",
          "new_api": null,
          "old_text": "called_computation->name()",
          "new_text": null,
          "old_line_content": "                    << \" computation: \" << called_computation->name() << \": (\"",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 3512,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(last_use_instruction)",
          "new_text": null,
          "old_line_content": "            CHECK(last_use_instruction);",
          "new_line_content": "            int64 use_time =",
          "content_same": false
        },
        {
          "line": 1466,
          "old_api": "AllocateSegment",
          "new_api": null,
          "old_text": "AllocateSegment(request)",
          "new_text": null,
          "old_line_content": "        result_mark(AllocateSegment(request), result);",
          "new_line_content": "        // same), definition time can be the time of the conditional and use",
          "content_same": false
        },
        {
          "line": 1467,
          "old_api": "result_requires_uncommit",
          "new_api": null,
          "old_text": "result_requires_uncommit(result)",
          "new_text": null,
          "old_line_content": "        if (result_requires_uncommit(result)) {",
          "new_line_content": "        // time is the parameter use, which is less.",
          "content_same": false
        },
        {
          "line": 3516,
          "old_api": "split_conditional_buffer",
          "new_api": null,
          "old_text": "split_conditional_buffer(\n                  last_use_instruction, parameter_time, last_use_time,\n                  absl::StrCat(indent_string, \"  \"))",
          "new_text": null,
          "old_line_content": "              TF_RETURN_IF_ERROR(split_conditional_buffer(",
          "new_line_content": "              last_use_time = use_time;",
          "content_same": false
        },
        {
          "line": 3518,
          "old_api": "absl::StrCat(indent_string, \"  \")",
          "new_api": null,
          "old_text": "absl::StrCat(indent_string, \"  \")",
          "new_text": null,
          "old_line_content": "                  absl::StrCat(indent_string, \"  \")));",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3520,
          "old_api": "std::min(last_use_time, end_time)",
          "new_api": null,
          "old_text": "std::min(last_use_time, end_time)",
          "new_text": null,
          "old_line_content": "              last_use_time = std::min(last_use_time, end_time);",
          "new_line_content": "          if (last_use_time != -1) {",
          "content_same": false
        },
        {
          "line": 1476,
          "old_api": "at",
          "new_api": null,
          "old_text": "instruction_schedule.at(hlo_use.instruction)",
          "new_text": null,
          "old_line_content": "        definition_time = instruction_schedule.at(hlo_use.instruction);",
          "new_line_content": "        request.use = &use;",
          "content_same": false
        },
        {
          "line": 1481,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "allocation_value.allocation_sequence()",
          "new_text": null,
          "old_line_content": "          GetLiveAllocationAt(*allocation_value.allocation_sequence(),",
          "new_line_content": "          // If the allocation finding failed (e.g., due to running out of",
          "content_same": false
        },
        {
          "line": 1484,
          "old_api": "AddAliasedRequiredAssignment",
          "new_api": null,
          "old_text": "AddAliasedRequiredAssignment(aliased_position.instruction,\n                                     aliased_position.index,\n                                     aliased_allocation)",
          "new_text": null,
          "old_line_content": "        AddAliasedRequiredAssignment(aliased_position.instruction,",
          "new_line_content": "          return result;",
          "content_same": false
        },
        {
          "line": 3535,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "last_use_instruction->opcode()",
          "new_text": null,
          "old_line_content": "          last_use_instruction->opcode() == HloOpcode::kConditional) {",
          "new_line_content": "                  parameter_time, last_use_time, chunk, value));",
          "content_same": false
        },
        {
          "line": 3536,
          "old_api": "split_conditional_buffer",
          "new_api": null,
          "old_text": "split_conditional_buffer(\n            last_use_instruction, time_bound.start, time_bound.end, \" \")",
          "new_text": null,
          "old_line_content": "        TF_RETURN_IF_ERROR(split_conditional_buffer(",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3538,
          "old_api": "empty",
          "new_api": null,
          "old_text": "value->uses().empty()",
          "new_text": null,
          "old_line_content": "      } else if (!value->uses().empty()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "hlo_use.instruction->opcode()",
          "new_text": null,
          "old_line_content": "      if (hlo_use.instruction->opcode() == HloOpcode::kWhile &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1492,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "aliased_allocation->memory_space()",
          "new_text": null,
          "old_line_content": "          aliased_allocation->memory_space() == MemorySpace::kAlternate) {",
          "new_line_content": "      // Propagate the allocation to any aliases this use might have had.",
          "content_same": false
        },
        {
          "line": 1493,
          "old_api": "while_body",
          "new_api": null,
          "old_text": "hlo_use.instruction->while_body()",
          "new_text": null,
          "old_line_content": "        preferred_offset_for_computation[hlo_use.instruction->while_body()] =",
          "new_line_content": "      MemorySpaceAssignment::Allocation* aliased_allocation =",
          "content_same": false
        },
        {
          "line": 3540,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "buffer.ToString()",
          "new_text": null,
          "old_line_content": "        VLOG(3) << \" buffer: \" << buffer.ToString()",
          "new_line_content": "                << start_time << \", \" << (earliest_computation_start_time - 1)",
          "content_same": false
        },
        {
          "line": 3541,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "value->ToShortString()",
          "new_text": null,
          "old_line_content": "                << \" value: \" << value->ToShortString() << \": (\"",
          "new_line_content": "                << \")\";",
          "content_same": false
        },
        {
          "line": 1508,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(it_and_inserted.second ||\n        it_and_inserted.first->start_time == copy.start_time)",
          "new_text": null,
          "old_line_content": "  CHECK(it_and_inserted.second ||",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3560,
          "old_api": "std::tie(time, is_free, buffer_id)",
          "new_api": null,
          "old_text": "std::tie(time, is_free, buffer_id)",
          "new_text": null,
          "old_line_content": "    std::tie(time, is_free, buffer_id) = event.first;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1513,
          "old_api": "find",
          "new_api": null,
          "old_text": "ranges_.find(copy)",
          "new_text": null,
          "old_line_content": "  auto copy_it = ranges_.find(copy);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1514,
          "old_api": "end",
          "new_api": null,
          "old_text": "ranges_.end()",
          "new_text": null,
          "old_line_content": "  CHECK(copy_it != ranges_.end());",
          "new_line_content": "bool operator<(const AsynchronousCopy& a, const AsynchronousCopy& b) {",
          "content_same": false
        },
        {
          "line": 1515,
          "old_api": "erase",
          "new_api": null,
          "old_text": "ranges_.erase(copy_it)",
          "new_text": null,
          "old_line_content": "  ranges_.erase(copy_it);",
          "new_line_content": "  return (a.start_time < b.start_time && a.end_time <= b.end_time) ||",
          "content_same": false
        },
        {
          "line": 3565,
          "old_api": "add_events",
          "new_api": null,
          "old_text": "heap_trace->add_events()",
          "new_text": null,
          "old_line_content": "    HeapSimulatorTrace::Event* heap_trace_event = heap_trace->add_events();",
          "new_line_content": "           ->assignment_information_for_space(options_.alternate_memory_space)",
          "content_same": false
        },
        {
          "line": 3566,
          "old_api": "set_kind",
          "new_api": null,
          "old_text": "heap_trace_event->set_kind(kind)",
          "new_text": null,
          "old_line_content": "    heap_trace_event->set_kind(kind);",
          "new_line_content": "           ->heap_simulator_trace;",
          "content_same": false
        },
        {
          "line": 3567,
          "old_api": "set_buffer_id",
          "new_api": null,
          "old_text": "heap_trace_event->set_buffer_id(buffer_id)",
          "new_text": null,
          "old_line_content": "    heap_trace_event->set_buffer_id(buffer_id);",
          "new_line_content": "  int64 memory_usage = 0;",
          "content_same": false
        },
        {
          "line": 3568,
          "old_api": "instruction",
          "new_api": null,
          "old_text": "value->instruction()->name()",
          "new_text": null,
          "old_line_content": "    heap_trace_event->set_instruction_name(value->instruction()->name());",
          "new_line_content": "  int64 max_memory_usage = 0;",
          "content_same": false
        },
        {
          "line": 3569,
          "old_api": "set_computation_name",
          "new_api": null,
          "old_text": "heap_trace_event->set_computation_name(\n        value->instruction()->parent()->name())",
          "new_text": null,
          "old_line_content": "    heap_trace_event->set_computation_name(",
          "new_line_content": "  for (const auto& event : events) {",
          "content_same": false
        },
        {
          "line": 3570,
          "old_api": "instruction",
          "new_api": null,
          "old_text": "value->instruction()->parent()->name()",
          "new_text": null,
          "old_line_content": "        value->instruction()->parent()->name());",
          "new_line_content": "    int64 time;",
          "content_same": false
        },
        {
          "line": 1524,
          "old_api": "find",
          "new_api": null,
          "old_text": "ranges_.find(\n      {start_time, end_time, MemorySpaceAssignment::MemorySpace::kAlternate})",
          "new_text": null,
          "old_line_content": "  auto copy_it = ranges_.find(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3575,
          "old_api": "CHECK_EQ",
          "new_api": null,
          "old_text": "CHECK_EQ(kind, HeapSimulatorTrace::Event::FREE)",
          "new_text": null,
          "old_line_content": "      CHECK_EQ(kind, HeapSimulatorTrace::Event::FREE);",
          "new_line_content": "    Chunk chunk;",
          "content_same": false
        },
        {
          "line": 1538,
          "old_api": "find",
          "new_api": null,
          "old_text": "aliased_offset_map_.find(&allocation)",
          "new_text": null,
          "old_line_content": "  auto aliased_offset_it = aliased_offset_map_.find(&allocation);",
          "new_line_content": "      {start_time, end_time, MemorySpaceAssignment::MemorySpace::kAlternate});",
          "content_same": false
        },
        {
          "line": 1546,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "allocation.memory_space()",
          "new_text": null,
          "old_line_content": "  CHECK(allocation.memory_space() == MemorySpace::kAlternate);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1547,
          "old_api": "contains",
          "new_api": null,
          "old_text": "aliased_offset_map_.contains(&allocation)",
          "new_text": null,
          "old_line_content": "  CHECK(!aliased_offset_map_.contains(&allocation));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1549,
          "old_api": "chunk",
          "new_api": null,
          "old_text": "allocation.chunk()",
          "new_text": null,
          "old_line_content": "    aliased_offsets_.push_back({allocation.chunk().offset});",
          "new_line_content": "AlternateMemoryBestFitHeap::GetAliasedOffset(",
          "content_same": false
        },
        {
          "line": 1550,
          "old_api": "back",
          "new_api": null,
          "old_text": "aliased_offsets_.back()",
          "new_text": null,
          "old_line_content": "    aliased_offset = &aliased_offsets_.back();",
          "new_line_content": "    const MemorySpaceAssignment::Allocation& allocation) {",
          "content_same": false
        },
        {
          "line": 1553,
          "old_api": "insert",
          "new_api": null,
          "old_text": "aliased_offset->allocations.insert(&allocation)",
          "new_text": null,
          "old_line_content": "  CHECK(aliased_offset->allocations.insert(&allocation).second);",
          "new_line_content": "  return aliased_offset_it->second;",
          "content_same": false
        },
        {
          "line": 1561,
          "old_api": "rend",
          "new_api": null,
          "old_text": "allocations.rend()",
          "new_text": null,
          "old_line_content": "       allocation_it != allocations.rend(); ++allocation_it) {",
          "new_line_content": "  if (!aliased_offset) {",
          "content_same": false
        },
        {
          "line": 1564,
          "old_api": "get",
          "new_api": null,
          "old_text": "allocation_it->get()",
          "new_text": null,
          "old_line_content": "      return allocation_it->get();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1578,
          "old_api": "available_heap_size",
          "new_api": null,
          "old_text": "available_heap_size()",
          "new_text": null,
          "old_line_content": "      chunk_candidate.heap_size > available_heap_size()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1579,
          "old_api": "LOG",
          "new_api": null,
          "old_text": "LOG(WARNING)",
          "new_text": null,
          "old_line_content": "    LOG(WARNING)",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1583,
          "old_api": "AddToPendingChunks",
          "new_api": null,
          "old_text": "AddToPendingChunks(*prefetch_candidate, chunk_candidate)",
          "new_text": null,
          "old_line_content": "  AddToPendingChunks(*prefetch_candidate, chunk_candidate);",
          "new_line_content": "void AlternateMemoryBestFitHeap::AllocateCrossProgramPrefetchBuffer(",
          "content_same": false
        },
        {
          "line": 1586,
          "old_api": "instruction",
          "new_api": null,
          "old_text": "buffer->instruction()->parameter_number()",
          "new_text": null,
          "old_line_content": "  int64 parameter = buffer->instruction()->parameter_number();",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 1587,
          "old_api": "index",
          "new_api": null,
          "old_text": "buffer->index()",
          "new_text": null,
          "old_line_content": "  module->AddCrossProgramPrefetch(parameter, buffer->index());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1590,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "absl::make_unique<MemorySpaceAssignment::Allocation>(\n      buffer->defining_position(), MemorySpace::kDefault, kDummyChunk,\n      prefetch_candidate->start, prefetch_candidate->end,\n      /*is_scoped_allocation=*/false)",
          "new_text": null,
          "old_line_content": "  allocations.push_back(absl::make_unique<MemorySpaceAssignment::Allocation>(",
          "new_line_content": "  if (chunk_candidate.chunk.offset != 0 ||",
          "content_same": false
        },
        {
          "line": 1597,
          "old_api": "uses",
          "new_api": null,
          "old_text": "buffer->uses()",
          "new_text": null,
          "old_line_content": "  auto uses = buffer->uses();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": "absl::c_min_element(uses, use_schedule_compare)",
          "new_api": null,
          "old_text": "absl::c_min_element(uses, use_schedule_compare)",
          "new_text": null,
          "old_line_content": "  auto first_use = absl::c_min_element(uses, use_schedule_compare);",
          "new_line_content": "  MemorySpaceAssignment::AllocationSequence allocations;",
          "content_same": false
        },
        {
          "line": 1606,
          "old_api": "at",
          "new_api": null,
          "old_text": "instruction_schedule.at(\n      absl::c_max_element(uses, use_schedule_compare)->instruction)",
          "new_text": null,
          "old_line_content": "  int64 last_use_time = instruction_schedule.at(",
          "new_line_content": "      /*is_scoped_allocation=*/false));",
          "content_same": false
        },
        {
          "line": 1607,
          "old_api": "absl::c_max_element(uses, use_schedule_compare)",
          "new_api": null,
          "old_text": "absl::c_max_element(uses, use_schedule_compare)",
          "new_text": null,
          "old_line_content": "      absl::c_max_element(uses, use_schedule_compare)->instruction);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1611,
          "old_api": "at",
          "new_api": null,
          "old_text": "instruction_schedule.at(\n            absl::c_max_element(colocation->uses(), use_schedule_compare)\n                ->instruction)",
          "new_text": null,
          "old_line_content": "        instruction_schedule.at(",
          "new_line_content": "  auto use_schedule_compare = [&](const HloUse& lhs, const HloUse& rhs) {",
          "content_same": false
        },
        {
          "line": 1618,
          "old_api": "shape",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->PreferredPrefetchStartTime(\n          buffer->defining_position().shape(), last_use_time,\n          end_of_program_prefetch_end_time, end_of_program_prefetch_end_time)",
          "new_text": null,
          "old_line_content": "      options_.prefetch_interval_picker->PreferredPrefetchStartTime(",
          "new_line_content": "  // Find the latest use time.",
          "content_same": false
        },
        {
          "line": 1621,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(2)",
          "new_text": null,
          "old_line_content": "  VLOG(2) << \"last use time = \" << last_use_time",
          "new_line_content": "  for (const HloValue* colocation : prefetch_candidate->colocations) {",
          "content_same": false
        },
        {
          "line": 1630,
          "old_api": "back",
          "new_api": null,
          "old_text": "allocations.back()",
          "new_text": null,
          "old_line_content": "  AddAsyncCopy(*allocations.back(), MemorySpace::kAlternate,",
          "new_line_content": "  int64 end_of_program_prefetch_start_time =",
          "content_same": false
        },
        {
          "line": 1635,
          "old_api": "back",
          "new_api": null,
          "old_text": "allocations.back()->AddUse(use)",
          "new_text": null,
          "old_line_content": "  absl::c_for_each(uses, [&](auto& use) { allocations.back()->AddUse(use); });",
          "new_line_content": "          << \", end-of-program prefetch start time = \"",
          "content_same": false
        },
        {
          "line": 1637,
          "old_api": "back",
          "new_api": null,
          "old_text": "allocations.back()",
          "new_text": null,
          "old_line_content": "      GetAliasedOffset(*allocations.back());",
          "new_line_content": "  bool free_buffer =",
          "content_same": false
        },
        {
          "line": 1640,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(2)",
          "new_text": null,
          "old_line_content": "    VLOG(2) << \"Adding an end-of-program prefetch for freed \"",
          "new_line_content": "  int64 cross_program_prefetch_end_time =",
          "content_same": false
        },
        {
          "line": 1642,
          "old_api": "front",
          "new_api": null,
          "old_text": "allocations.front()",
          "new_text": null,
          "old_line_content": "    AddAsyncCopy(*allocations.front(), MemorySpace::kAlternate,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1647,
          "old_api": "back",
          "new_api": null,
          "old_text": "CHECK_EQ(cross_program_prefetch_offset->offset,\n             allocations.back()->chunk().offset)",
          "new_text": null,
          "old_line_content": "    CHECK_EQ(cross_program_prefetch_offset->offset,",
          "new_line_content": "               /*is_cross_program_prefetch=*/true);",
          "content_same": false
        },
        {
          "line": 1651,
          "old_api": "size",
          "new_api": null,
          "old_text": "allocations_->size()",
          "new_text": null,
          "old_line_content": "  const int allocations_initial_size = allocations_->size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": "size",
          "new_api": null,
          "old_text": "allocations_->size()",
          "new_text": null,
          "old_line_content": "  for (int i = allocations_initial_size; i < allocations_->size(); ++i) {",
          "new_line_content": "                 end_of_program_prefetch_end_time, &allocations,",
          "content_same": false
        },
        {
          "line": 1659,
          "old_api": "at",
          "new_api": null,
          "old_text": "allocations_->at(i)",
          "new_text": null,
          "old_line_content": "    const auto& allocation = allocations_->at(i);",
          "new_line_content": "                 cross_program_prefetch_offset);",
          "content_same": false
        },
        {
          "line": 1662,
          "old_api": "end_time",
          "new_api": null,
          "old_text": "allocation->end_time()",
          "new_text": null,
          "old_line_content": "          allocation->start_time(), allocation->end_time(),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1663,
          "old_api": "chunk",
          "new_api": null,
          "old_text": "allocation->chunk()",
          "new_text": null,
          "old_line_content": "          allocation->chunk().size, allocation->chunk().offset,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1665,
          "old_api": "get",
          "new_api": null,
          "old_text": "allocation.get()",
          "new_text": null,
          "old_line_content": "          allocation.get()));",
          "new_line_content": "  for (auto& allocation : allocations) {",
          "content_same": false
        },
        {
          "line": 1668,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "colocation.colocations.push_back(inserted)",
          "new_text": null,
          "old_line_content": "        colocation.colocations.push_back(inserted);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1670,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "inserted->colocations.push_back(&colocation)",
          "new_text": null,
          "old_line_content": "          inserted->colocations.push_back(&colocation);",
          "new_line_content": "  // memory.",
          "content_same": false
        },
        {
          "line": 1685,
          "old_api": "reserved_scoped_memory_fn",
          "new_api": null,
          "old_text": "options_.reserved_scoped_memory_fn(instruction_sequence[i])",
          "new_text": null,
          "old_line_content": "        options_.reserved_scoped_memory_fn(instruction_sequence[i]);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1687,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(1)",
          "new_text": null,
          "old_line_content": "      VLOG(1) << \"Allocate reserved scoped memory at \" << i << \" (\"",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1688,
          "old_api": "name",
          "new_api": null,
          "old_text": "instruction_sequence[i]->name()",
          "new_text": null,
          "old_line_content": "              << instruction_sequence[i]->name()",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1699,
          "old_api": "CHECK_EQ",
          "new_api": null,
          "old_text": "CHECK_EQ(chunk_candidate.chunk.offset, 0)",
          "new_text": null,
          "old_line_content": "      CHECK_EQ(chunk_candidate.chunk.offset, 0);",
          "new_line_content": "    if (reserved_scoped_memory != 0) {",
          "content_same": false
        },
        {
          "line": 1702,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "allocations_->push_back(\n          absl::make_unique<MemorySpaceAssignment::Allocation>(\n              HloPosition{instruction_sequence[i], {}}, MemorySpace::kAlternate,\n              chunk_candidate.chunk, i, i, /*is_scoped_allocation=*/true))",
          "new_text": null,
          "old_line_content": "      allocations_->push_back(",
          "new_line_content": "              << \"): \" << reserved_scoped_memory;",
          "content_same": false
        },
        {
          "line": 1703,
          "old_api": "absl::make_unique<MemorySpaceAssignment::Allocation>(\n              HloPosition{instruction_sequence[i], {}}, MemorySpace::kAlternate,\n              chunk_candidate.chunk, i, i, /*is_scoped_allocation=*/true)",
          "new_api": null,
          "old_text": "absl::make_unique<MemorySpaceAssignment::Allocation>(\n              HloPosition{instruction_sequence[i], {}}, MemorySpace::kAlternate,\n              chunk_candidate.chunk, i, i, /*is_scoped_allocation=*/true)",
          "new_text": null,
          "old_line_content": "          absl::make_unique<MemorySpaceAssignment::Allocation>(",
          "new_line_content": "      MemorySpaceAssignment::BufferInterval interval;",
          "content_same": false
        },
        {
          "line": 1707,
          "old_api": "size",
          "new_api": null,
          "old_text": "MakeRepackAllocationBlock(\n          i, i, reserved_scoped_memory,\n          /*initial_offset=*/0,\n          static_cast<int64>(repack_allocation_blocks_.size()),\n          allocations_->back().get())",
          "new_text": null,
          "old_line_content": "      repack_allocation_blocks_.push_back(MakeRepackAllocationBlock(",
          "new_line_content": "      interval.end = i;",
          "content_same": false
        },
        {
          "line": 1710,
          "old_api": "size",
          "new_api": null,
          "old_text": "repack_allocation_blocks_.size()",
          "new_text": null,
          "old_line_content": "          static_cast<int64>(repack_allocation_blocks_.size()),",
          "new_line_content": "      ChunkCandidate chunk_candidate =",
          "content_same": false
        },
        {
          "line": 1731,
          "old_api": "find",
          "new_api": null,
          "old_text": "required_assignments_.find(buffer)",
          "new_text": null,
          "old_line_content": "  auto required_assignment_it = required_assignments_.find(buffer);",
          "new_line_content": "  // opportunity to deduplicate different ops.  However, this may hurt the",
          "content_same": false
        },
        {
          "line": 1733,
          "old_api": "end",
          "new_api": null,
          "old_text": "required_assignments_.end()",
          "new_text": null,
          "old_line_content": "  if (required_assignment_it != required_assignments_.end()) {",
          "new_line_content": "  if (options_.allocate_reserved_scoped_memory_at_same_offset) {",
          "content_same": false
        },
        {
          "line": 1738,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(!required_assignment_at_time)",
          "new_text": null,
          "old_line_content": "        CHECK(!required_assignment_at_time);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1752,
          "old_api": "dataflow_analysis",
          "new_api": null,
          "old_text": "alias_analysis_.dataflow_analysis().GetUniqueValueAt(\n            position.instruction, position.index)",
          "new_text": null,
          "old_line_content": "        &alias_analysis_.dataflow_analysis().GetUniqueValueAt(",
          "new_line_content": "        required_assignment_at_time = required_assignment;",
          "content_same": false
        },
        {
          "line": 1755,
          "old_api": "instruction_schedule",
          "new_api": null,
          "old_text": "hlo_live_range_.instruction_schedule().at(position.instruction)",
          "new_text": null,
          "old_line_content": "        hlo_live_range_.instruction_schedule().at(position.instruction);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1757,
          "old_api": "RequiredMemoryAssignmentAt",
          "new_api": null,
          "old_text": "RequiredMemoryAssignmentAt(value, time)",
          "new_text": null,
          "old_line_content": "        RequiredMemoryAssignmentAt(value, time);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1761,
          "old_api": "equals_ignoring_time",
          "new_api": null,
          "old_text": "CHECK(required_assignment_for_alias == absl::nullopt ||\n            required_assignment->equals_ignoring_time(\n                *required_assignment_for_alias))",
          "new_text": null,
          "old_line_content": "      CHECK(required_assignment_for_alias == absl::nullopt ||",
          "new_line_content": "    const AllocationValue::Use& use) const {",
          "content_same": false
        },
        {
          "line": 1762,
          "old_api": "equals_ignoring_time",
          "new_api": null,
          "old_text": "required_assignment->equals_ignoring_time(\n                *required_assignment_for_alias)",
          "new_text": null,
          "old_line_content": "            required_assignment->equals_ignoring_time(",
          "new_line_content": "  absl::optional<RequiredMemoryAssignment> required_assignment;",
          "content_same": false
        },
        {
          "line": 1773,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "aliased_allocation->memory_space()",
          "new_text": null,
          "old_line_content": "  if (aliased_allocation->memory_space() == MemorySpace::kAlternate) {",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1776,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "aliased_allocation->memory_space()",
          "new_text": null,
          "old_line_content": "  AddRequiredAssignment(instruction, index, aliased_allocation->memory_space(),",
          "new_line_content": "                *required_assignment_for_alias));",
          "content_same": false
        },
        {
          "line": 1788,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(memory_space == existing_required_assignment->memory_space)",
          "new_text": null,
          "old_line_content": "    CHECK(memory_space == existing_required_assignment->memory_space)",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1790,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK((!offset && !existing_required_assignment->offset) ||\n          offset == existing_required_assignment->offset)",
          "new_text": null,
          "old_line_content": "    CHECK((!offset && !existing_required_assignment->offset) ||",
          "new_line_content": "                        offset);",
          "content_same": false
        },
        {
          "line": 1792,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \"Not adding required assignment because there is one already: \"",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1793,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "value->ToShortString()",
          "new_text": null,
          "old_line_content": "            << value->ToShortString() << \" at \" << time << \" at \"",
          "new_line_content": "void AlternateMemoryBestFitHeap::AddRequiredAssignment(",
          "content_same": false
        },
        {
          "line": 1796,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "value->ToShortString()",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \"Adding required assignment: \" << value->ToShortString()",
          "new_line_content": "    AliasedOffset* offset) {",
          "content_same": false
        },
        {
          "line": 1800,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "required_assignments_[value].push_back(required_assignment)",
          "new_text": null,
          "old_line_content": "    required_assignments_[value].push_back(required_assignment);",
          "new_line_content": "  if (existing_required_assignment) {",
          "content_same": false
        },
        {
          "line": 1811,
          "old_api": "instruction_schedule",
          "new_api": null,
          "old_text": "hlo_live_range_.instruction_schedule().at(instruction)",
          "new_text": null,
          "old_line_content": "      hlo_live_range_.instruction_schedule().at(instruction);",
          "new_line_content": "            << (memory_space == MemorySpace::kDefault ? \"def\" : \"alt\");",
          "content_same": false
        },
        {
          "line": 1812,
          "old_api": "AddRequiredAssignment",
          "new_api": null,
          "old_text": "AddRequiredAssignment(value, instruction, memory_space, instruction_time,\n                        offset)",
          "new_text": null,
          "old_line_content": "  AddRequiredAssignment(value, instruction, memory_space, instruction_time,",
          "new_line_content": "    RequiredMemoryAssignment required_assignment{memory_space, time, offset};",
          "content_same": false
        },
        {
          "line": 1819,
          "old_api": "dataflow_analysis",
          "new_api": null,
          "old_text": "alias_analysis_.dataflow_analysis().module()",
          "new_text": null,
          "old_line_content": "  const HloModule& module = alias_analysis_.dataflow_analysis().module();",
          "new_line_content": "    const HloInstruction* instruction, ShapeIndex index,",
          "content_same": false
        },
        {
          "line": 1820,
          "old_api": "instruction_schedule",
          "new_api": null,
          "old_text": "hlo_live_range_.instruction_schedule()",
          "new_text": null,
          "old_line_content": "  const auto& instruction_schedule = hlo_live_range_.instruction_schedule();",
          "new_line_content": "    MemorySpace memory_space, AliasedOffset* offset) {",
          "content_same": false
        },
        {
          "line": 1821,
          "old_api": "entry_computation",
          "new_api": null,
          "old_text": "module.entry_computation()",
          "new_text": null,
          "old_line_content": "  HloComputation* entry_computation = module.entry_computation();",
          "new_line_content": "  const HloValue* value =",
          "content_same": false
        },
        {
          "line": 1823,
          "old_api": "parameter_instructions",
          "new_api": null,
          "old_text": "entry_computation->parameter_instructions()",
          "new_text": null,
          "old_line_content": "       entry_computation->parameter_instructions()) {",
          "new_line_content": "  int64 instruction_time =",
          "content_same": false
        },
        {
          "line": 1826,
          "old_api": "has_layout",
          "new_api": null,
          "old_text": "ShapeUtil::ForEachSubshape(\n        parameter_instruction->shape(),\n        [&](const Shape& subshape, const ShapeIndex& index) {\n          MemorySpace memory_space = MemorySpace::kDefault;\n          if (subshape.has_layout() && subshape.layout().memory_space() ==\n                                           options_.alternate_memory_space) {\n            memory_space = MemorySpace::kAlternate;\n          }\n          for (const HloBuffer* buffer :\n               alias_analysis_.ComputeBuffersAt(parameter_instruction, index)) {\n            for (const HloValue* value : buffer->values()) {\n              VLOG(3) << \"Adding required assignment for parameter value = \"\n                      << value->ToShortString()\n                      << \" time = \" << parameter_instruction_time << \" space = \"\n                      << (memory_space == MemorySpace::kDefault ? \"def\"\n                                                                : \"alt\");\n              required_assignments_[value].push_back(\n                  {memory_space, /*time=*/parameter_instruction_time});\n            }\n          }\n        })",
          "new_text": null,
          "old_line_content": "    ShapeUtil::ForEachSubshape(",
          "new_line_content": "                        offset);",
          "content_same": false
        },
        {
          "line": 1827,
          "old_api": "shape",
          "new_api": null,
          "old_text": "parameter_instruction->shape()",
          "new_text": null,
          "old_line_content": "        parameter_instruction->shape(),",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1830,
          "old_api": "layout",
          "new_api": null,
          "old_text": "subshape.layout().memory_space()",
          "new_text": null,
          "old_line_content": "          if (subshape.has_layout() && subshape.layout().memory_space() ==",
          "new_line_content": "  // Go through the parameters and outputs and pin them to the corresponding",
          "content_same": false
        },
        {
          "line": 1835,
          "old_api": "ComputeBuffersAt",
          "new_api": null,
          "old_text": "alias_analysis_.ComputeBuffersAt(parameter_instruction, index)",
          "new_text": null,
          "old_line_content": "               alias_analysis_.ComputeBuffersAt(parameter_instruction, index)) {",
          "new_line_content": "  for (HloInstruction* parameter_instruction :",
          "content_same": false
        },
        {
          "line": 1837,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "              VLOG(3) << \"Adding required assignment for parameter value = \"",
          "new_line_content": "    int64 parameter_instruction_time =",
          "content_same": false
        },
        {
          "line": 1842,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "required_assignments_[value].push_back(\n                  {memory_space, /*time=*/parameter_instruction_time})",
          "new_text": null,
          "old_line_content": "              required_assignments_[value].push_back(",
          "new_line_content": "          MemorySpace memory_space = MemorySpace::kDefault;",
          "content_same": false
        },
        {
          "line": 1854,
          "old_api": "layout",
          "new_api": null,
          "old_text": "subshape.layout().memory_space()",
          "new_text": null,
          "old_line_content": "        if (subshape.has_layout() && subshape.layout().memory_space() ==",
          "new_line_content": "                                                                : \"alt\");",
          "content_same": false
        },
        {
          "line": 1859,
          "old_api": "ComputeBuffersAt",
          "new_api": null,
          "old_text": "alias_analysis_.ComputeBuffersAt(root_instruction, index)",
          "new_text": null,
          "old_line_content": "             alias_analysis_.ComputeBuffersAt(root_instruction, index)) {",
          "new_line_content": "        });",
          "content_same": false
        },
        {
          "line": 1860,
          "old_api": "values",
          "new_api": null,
          "old_text": "buffer->values()",
          "new_text": null,
          "old_line_content": "          for (const HloValue* value : buffer->values()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1865,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "required_assignments_[value].push_back(\n                {memory_space, /*time=*/root_instruction_time})",
          "new_text": null,
          "old_line_content": "            required_assignments_[value].push_back(",
          "new_line_content": "      [&](const Shape& subshape, const ShapeIndex& index) {",
          "content_same": false
        },
        {
          "line": 1876,
          "old_api": "has_layout",
          "new_api": null,
          "old_text": "shape.has_layout()",
          "new_text": null,
          "old_line_content": "    return shape.has_layout() &&",
          "new_line_content": "                    << \" time = \" << root_instruction_time << \" space = \"",
          "content_same": false
        },
        {
          "line": 1877,
          "old_api": "layout",
          "new_api": null,
          "old_text": "shape.layout().memory_space()",
          "new_text": null,
          "old_line_content": "           shape.layout().memory_space() == options_.alternate_memory_space;",
          "new_line_content": "                    << (memory_space == MemorySpace::kDefault ? \"def\" : \"alt\");",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": "dataflow_analysis",
          "new_api": null,
          "old_text": "alias_analysis_.dataflow_analysis().module()",
          "new_text": null,
          "old_line_content": "  const HloModule& module = alias_analysis_.dataflow_analysis().module();",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 1881,
          "old_api": "entry_computation",
          "new_api": null,
          "old_text": "module.entry_computation()",
          "new_text": null,
          "old_line_content": "  const HloComputation* entry_computation = module.entry_computation();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1883,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "entry_computation->root_instruction()",
          "new_text": null,
          "old_line_content": "      entry_computation->root_instruction();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1886,
          "old_api": "defining_instruction",
          "new_api": null,
          "old_text": "value->defining_instruction()->opcode()",
          "new_text": null,
          "old_line_content": "    if (value->defining_instruction()->opcode() == HloOpcode::kParameter &&",
          "new_line_content": "    absl::Span<const BufferInterval* const> colocated_intervals) const {",
          "content_same": false
        },
        {
          "line": 1887,
          "old_api": "defining_instruction",
          "new_api": null,
          "old_text": "value->defining_instruction()->parent()",
          "new_text": null,
          "old_line_content": "        value->defining_instruction()->parent() == entry_computation &&",
          "new_line_content": "  auto is_position_in_alternate_memory = [&](const HloPosition& position) {",
          "content_same": false
        },
        {
          "line": 1892,
          "old_api": "positions",
          "new_api": null,
          "old_text": "value->positions()",
          "new_text": null,
          "old_line_content": "    for (const HloPosition& position : value->positions()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1913,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "allocation->ToString()",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \"Moved \" << allocation->ToString() << \", size \"",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1914,
          "old_api": "chunk",
          "new_api": null,
          "old_text": "allocation->chunk()",
          "new_text": null,
          "old_line_content": "            << allocation->chunk().size << \", (\" << allocation_block.start_time",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1920,
          "old_api": "Add",
          "new_api": null,
          "old_text": "interval_tree_.Add(allocation_block.start_time, allocation_block.end_time,\n                       {allocation_block.offset, allocation_block.size})",
          "new_text": null,
          "old_line_content": "    interval_tree_.Add(allocation_block.start_time, allocation_block.end_time,",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1932,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "allocation_value.allocation_sequence()->clear()",
          "new_text": null,
          "old_line_content": "    allocation_value.allocation_sequence()->clear();",
          "new_line_content": "        allocation_block.offset;",
          "content_same": false
        },
        {
          "line": 1937,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \"Uncommitting: (\" << interval.start << \", \" << interval.end",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1939,
          "old_api": "Remove",
          "new_api": null,
          "old_text": "interval_tree_.Remove(interval.start, interval.end, chunk)",
          "new_text": null,
          "old_line_content": "    interval_tree_.Remove(interval.start, interval.end, chunk);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1943,
          "old_api": "Remove",
          "new_api": null,
          "old_text": "prefetch_interval_tree_.Remove(interval.start_time, interval.end_time,\n                                     kDummyChunk)",
          "new_text": null,
          "old_line_content": "      prefetch_interval_tree_.Remove(interval.start_time, interval.end_time,",
          "new_line_content": "  // retry allocation after uncommitting.",
          "content_same": false
        },
        {
          "line": 1947,
          "old_api": "Remove",
          "new_api": null,
          "old_text": "eviction_interval_tree_.Remove(interval.start_time, interval.end_time,\n                                     kDummyChunk)",
          "new_text": null,
          "old_line_content": "      eviction_interval_tree_.Remove(interval.start_time, interval.end_time,",
          "new_line_content": "  for (const auto& interval_and_chunk : pending_chunks_) {",
          "content_same": false
        },
        {
          "line": 1957,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \"Removing required assignment: \"",
          "new_line_content": "                                     kDummyChunk);",
          "content_same": false
        },
        {
          "line": 1964,
          "old_api": "begin",
          "new_api": null,
          "old_text": "required_assignment_vector.begin()",
          "new_text": null,
          "old_line_content": "    for (auto it = required_assignment_vector.begin();",
          "new_line_content": "  for (const auto& value_and_required_assignment :",
          "content_same": false
        },
        {
          "line": 1965,
          "old_api": "end",
          "new_api": null,
          "old_text": "required_assignment_vector.end()",
          "new_text": null,
          "old_line_content": "         it != required_assignment_vector.end(); ++it) {",
          "new_line_content": "       pending_required_assignments_) {",
          "content_same": false
        },
        {
          "line": 1967,
          "old_api": "erase",
          "new_api": null,
          "old_text": "required_assignment_vector.erase(it)",
          "new_text": null,
          "old_line_content": "        required_assignment_vector.erase(it);",
          "new_line_content": "        required_assignments_[value_and_required_assignment.first];",
          "content_same": false
        },
        {
          "line": 1972,
          "old_api": "ClearPendingChunks",
          "new_api": null,
          "old_text": "ClearPendingChunks()",
          "new_text": null,
          "old_line_content": "  ClearPendingChunks();",
          "new_line_content": "                    ? \"def\"",
          "content_same": false
        },
        {
          "line": 1981,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "allocation_value.allocation_sequence()",
          "new_text": null,
          "old_line_content": "    for (auto& allocation : *allocation_value.allocation_sequence()) {",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 1982,
          "old_api": "AppendAllocationInfoDebugString",
          "new_api": null,
          "old_text": "AppendAllocationInfoDebugString(allocation_value, *allocation,\n                                      allocation_info_str_)",
          "new_text": null,
          "old_line_content": "      AppendAllocationInfoDebugString(allocation_value, *allocation,",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1984,
          "old_api": "std::move(allocation)",
          "new_api": null,
          "old_text": "std::move(allocation)",
          "new_text": null,
          "old_line_content": "      allocations_->push_back(std::move(allocation));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1986,
          "old_api": "get",
          "new_api": null,
          "old_text": "allocations_->back().get()",
          "new_text": null,
          "old_line_content": "          allocations_->back().get();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1987,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "inserted_allocation->memory_space()",
          "new_text": null,
          "old_line_content": "      if (inserted_allocation->memory_space() == MemorySpace::kAlternate) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1988,
          "old_api": "GetAliasedOffset",
          "new_api": null,
          "old_text": "GetAliasedOffset(*inserted_allocation)",
          "new_text": null,
          "old_line_content": "        colocation_map[GetAliasedOffset(*inserted_allocation)].push_back(",
          "new_line_content": "void AlternateMemoryBestFitHeap::FinalizeAllocations(",
          "content_same": false
        },
        {
          "line": 2002,
          "old_api": "chunk",
          "new_api": null,
          "old_text": "colocated_allocation->chunk()",
          "new_text": null,
          "old_line_content": "          colocated_allocation->chunk().size,",
          "new_line_content": "            inserted_allocation);",
          "content_same": false
        },
        {
          "line": 2003,
          "old_api": "chunk",
          "new_api": null,
          "old_text": "colocated_allocation->chunk()",
          "new_text": null,
          "old_line_content": "          colocated_allocation->chunk().offset,",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2004,
          "old_api": "size",
          "new_api": null,
          "old_text": "repack_allocation_blocks_.size()",
          "new_text": null,
          "old_line_content": "          static_cast<int64>(repack_allocation_blocks_.size()),",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2006,
          "old_api": "back",
          "new_api": null,
          "old_text": "repack_allocation_blocks_.back()",
          "new_text": null,
          "old_line_content": "      colocations.push_back(&repack_allocation_blocks_.back());",
          "new_line_content": "  // The allocations that have the same AliasedOffset need to be colocated.",
          "content_same": false
        },
        {
          "line": 2018,
          "old_api": "clear",
          "new_api": null,
          "old_text": "pending_async_copies_.clear()",
          "new_text": null,
          "old_line_content": "  pending_async_copies_.clear();",
          "new_line_content": "          colocated_allocation));",
          "content_same": false
        },
        {
          "line": 2020,
          "old_api": "clear",
          "new_api": null,
          "old_text": "aliased_offset_map_.clear()",
          "new_text": null,
          "old_line_content": "  aliased_offset_map_.clear();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2021,
          "old_api": "clear",
          "new_api": null,
          "old_text": "aliased_offsets_.clear()",
          "new_text": null,
          "old_line_content": "  aliased_offsets_.clear();",
          "new_line_content": "    for (MemorySpaceAssignmentRepacker::AllocationBlock* repack_block :",
          "content_same": false
        },
        {
          "line": 2027,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"Committing chunk: \" << buffer_interval.start << \"-\"",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2036,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "request.allocation_value->allocation_sequence()",
          "new_text": null,
          "old_line_content": "  auto allocation_sequence = request.allocation_value->allocation_sequence();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2042,
          "old_api": "GetLiveAllocationAt",
          "new_api": null,
          "old_text": "GetLiveAllocationAt(*allocation_sequence, request.end_time)",
          "new_text": null,
          "old_line_content": "        GetLiveAllocationAt(*allocation_sequence, request.end_time);",
          "new_line_content": "          << \", \" << chunk_candidate.chunk.size << \"]\";",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 349,
      "total_additions": 755,
      "total_deletions": 752,
      "total_api_changes": 1856
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 13,
        "api_related_lines": 1856,
        "non_api_lines": 9,
        "non_api_line_numbers": [
          129,
          117,
          118,
          119,
          120,
          121,
          122,
          126,
          127
        ]
      }
    },
    "api_calls_before": 1504,
    "api_calls_after": 1509,
    "diff_info": {
      "added_lines": 13,
      "removed_lines": 0,
      "total_diff_lines": 25
    }
  }
}