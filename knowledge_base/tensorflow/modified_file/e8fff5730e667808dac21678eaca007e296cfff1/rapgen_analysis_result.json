{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/e8fff5730e667808dac21678eaca007e296cfff1",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/e8fff5730e667808dac21678eaca007e296cfff1/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/e8fff5730e667808dac21678eaca007e296cfff1/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/e8fff5730e667808dac21678eaca007e296cfff1/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 290,
          "old_api": "registerLoopAnalyses",
          "new_api": "registerModuleAnalyses",
          "old_text": "pb.registerLoopAnalyses(lam)",
          "new_text": "pb.registerModuleAnalyses(mam)",
          "old_line_content": "    pb.registerLoopAnalyses(lam);",
          "new_line_content": "    pb.registerModuleAnalyses(mam);",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": "crossRegisterProxies",
          "new_api": "registerCGSCCAnalyses",
          "old_text": "pb.crossRegisterProxies(lam, fam, cgam, mam)",
          "new_text": "pb.registerCGSCCAnalyses(cgam)",
          "old_line_content": "    pb.crossRegisterProxies(lam, fam, cgam, mam);",
          "new_line_content": "    pb.registerCGSCCAnalyses(cgam);",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": "buildPerModuleDefaultPipeline",
          "new_api": "crossRegisterProxies",
          "old_text": "pb.buildPerModuleDefaultPipeline(llvm::OptimizationLevel::O2)",
          "new_text": "pb.crossRegisterProxies(lam, fam, cgam, mam)",
          "old_line_content": "    mpm.addPass(pb.buildPerModuleDefaultPipeline(llvm::OptimizationLevel::O2));",
          "new_line_content": "    pb.crossRegisterProxies(lam, fam, cgam, mam);",
          "content_same": false
        },
        {
          "line": 321,
          "old_api": "Convert",
          "new_api": "getName",
          "old_text": "opts.type_converter.Convert(\n        llvm::cast<mlir::FunctionType>(func.getFunctionType()))",
          "new_text": "func.getName()",
          "old_line_content": "    auto signature = opts.type_converter.Convert(",
          "new_line_content": "    std::string_view name = exported.emplace_back(func.getName());",
          "content_same": false
        },
        {
          "line": 326,
          "old_api": "calling_convention",
          "new_api": "status",
          "old_text": "opts.calling_convention(\n        llvm::cast<mlir::FunctionType>(func.getFunctionType()))",
          "new_text": "signature.status()",
          "old_line_content": "    auto runtime_type = opts.calling_convention(",
          "new_line_content": "    if (!signature.ok()) return signature.status();",
          "content_same": false
        },
        {
          "line": 329,
          "old_api": "StrFormat",
          "new_api": "calling_convention",
          "old_text": "StrFormat(\n          \"calling convention failed to convert function type for %s\", name)",
          "new_text": "opts.calling_convention(\n        llvm::cast<mlir::FunctionType>(func.getFunctionType()))",
          "old_line_content": "      return compiler->Error(StrFormat(",
          "new_line_content": "    auto runtime_type = opts.calling_convention(",
          "content_same": false
        },
        {
          "line": 347,
          "old_api": "getAttr",
          "new_api": "status",
          "old_text": "func->getAttr(\"xla.requires_blas\")",
          "new_text": "results_memory_layout.status()",
          "old_line_content": "    if (Attribute requires_blas_attr = func->getAttr(\"xla.requires_blas\")) {",
          "new_line_content": "    if (!results_memory_layout.ok()) return results_memory_layout.status();",
          "content_same": false
        },
        {
          "line": 356,
          "old_api": "std::move(*results_memory_layout)",
          "new_api": "Executable::Function(\n        name,\n        /*fptr=*/nullptr, std::move(*signature), std::move(*runtime_signature),\n        std::move(*arguments_memory_layout), std::move(*results_memory_layout),\n        requires_blas)",
          "old_text": "std::move(*results_memory_layout)",
          "new_text": "Executable::Function(\n        name,\n        /*fptr=*/nullptr, std::move(*signature), std::move(*runtime_signature),\n        std::move(*arguments_memory_layout), std::move(*results_memory_layout),\n        requires_blas)",
          "old_line_content": "        std::move(*arguments_memory_layout), std::move(*results_memory_layout),",
          "new_line_content": "    functions.push_back(Executable::Function(",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": "EnablePassTiming",
          "new_api": "module",
          "old_text": "EnablePassTiming()",
          "new_text": "compiler->module()",
          "old_line_content": "  if (EnablePassTiming()) llvm::TimePassesIsEnabled = true;",
          "new_line_content": "  if (failed(RunCompilationPipeline(compiler->module(), opts)))",
          "content_same": false
        },
        {
          "line": 367,
          "old_api": "llvm::orc::JITTargetMachineBuilder::detectHost()",
          "new_api": "EnablePassTiming",
          "old_text": "llvm::orc::JITTargetMachineBuilder::detectHost()",
          "new_text": "EnablePassTiming()",
          "old_line_content": "  auto builder = llvm::orc::JITTargetMachineBuilder::detectHost();",
          "new_line_content": "  if (EnablePassTiming()) llvm::TimePassesIsEnabled = true;",
          "content_same": false
        },
        {
          "line": 370,
          "old_api": "createTargetMachine",
          "new_api": "llvm::orc::JITTargetMachineBuilder::detectHost()",
          "old_text": "builder->createTargetMachine()",
          "new_text": "llvm::orc::JITTargetMachineBuilder::detectHost()",
          "old_line_content": "  auto target_machine = builder->createTargetMachine();",
          "new_line_content": "  auto builder = llvm::orc::JITTargetMachineBuilder::detectHost();",
          "content_same": false
        },
        {
          "line": 375,
          "old_api": "getSymName",
          "new_api": "takeError",
          "old_text": "compiler->module().getSymName().value_or(\"<unknown>\")",
          "new_text": "target_machine.takeError()",
          "old_line_content": "  auto module_name = compiler->module().getSymName().value_or(\"<unknown>\");",
          "new_line_content": "    return InternalError(toString(target_machine.takeError()));",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": "empty",
          "new_api": "getSymName",
          "old_text": "llvm::formatv(\n      \"/xla{0}{1}:@{2}::@{3}\", memory_region_name.empty() ? \"\" : \":\",\n      EscapeMemRegionName(memory_region_name), module_name,\n      specialization.has_value() ? \"specialized\" : \"default\")",
          "new_text": "compiler->module().getSymName().value_or(\"<unknown>\")",
          "old_line_content": "  std::string mapper_name = llvm::formatv(",
          "new_line_content": "  auto module_name = compiler->module().getSymName().value_or(\"<unknown>\");",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": "has_value",
          "new_api": "empty",
          "old_text": "specialization.has_value()",
          "new_text": "llvm::formatv(\n      \"/xla{0}{1}:@{2}::@{3}\", memory_region_name.empty() ? \"\" : \":\",\n      EscapeMemRegionName(memory_region_name), module_name,\n      specialization.has_value() ? \"specialized\" : \"default\")",
          "old_line_content": "      specialization.has_value() ? \"specialized\" : \"default\");",
          "new_line_content": "  std::string mapper_name = llvm::formatv(",
          "content_same": false
        },
        {
          "line": 396,
          "old_api": "get",
          "new_api": "options",
          "old_text": "memory_mapper.get()",
          "new_text": "compiler->options()",
          "old_line_content": "  engine_options.section_memory_mapper = memory_mapper.get();",
          "new_line_content": "  engine_options.opt_level = compiler->options().jit_code_opt_level;",
          "content_same": false
        },
        {
          "line": 397,
          "old_api": "std::move(symbols)",
          "new_api": "get",
          "old_text": "std::move(symbols)",
          "new_text": "target_machine->get()",
          "old_line_content": "  engine_options.symbols_binding = std::move(symbols);",
          "new_line_content": "  engine_options.target_machine = target_machine->get();",
          "content_same": false
        },
        {
          "line": 400,
          "old_api": "std::make_unique<llvm::LLVMContext>()",
          "new_api": "std::move(symbols)",
          "old_text": "std::make_unique<llvm::LLVMContext>()",
          "new_text": "std::move(symbols)",
          "old_line_content": "  auto llvm_ctx = std::make_unique<llvm::LLVMContext>();",
          "new_line_content": "  engine_options.symbols_binding = std::move(symbols);",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": "Error",
          "new_api": "std::make_unique<llvm::LLVMContext>()",
          "old_text": "compiler->Error(\"failed to translate module to LLVM IR\")",
          "new_text": "std::make_unique<llvm::LLVMContext>()",
          "old_line_content": "    return compiler->Error(\"failed to translate module to LLVM IR\");",
          "new_line_content": "  auto llvm_ctx = std::make_unique<llvm::LLVMContext>();",
          "content_same": false
        },
        {
          "line": 406,
          "old_api": "ExecutionEngine::CreateFromModule(\n      std::move(llvm_ctx), std::move(llvm_module), engine_options, exported)",
          "new_api": "Error",
          "old_text": "ExecutionEngine::CreateFromModule(\n      std::move(llvm_ctx), std::move(llvm_module), engine_options, exported)",
          "new_text": "compiler->Error(\"failed to translate module to LLVM IR\")",
          "old_line_content": "  auto engine = ExecutionEngine::CreateFromModule(",
          "new_line_content": "    return compiler->Error(\"failed to translate module to LLVM IR\");",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": "llvm::reportAndResetTimings()",
          "new_api": "std::chrono::duration_cast<std::chrono::milliseconds>(\n      std::chrono::steady_clock::now() - compilation_start)",
          "old_text": "llvm::reportAndResetTimings()",
          "new_text": "std::chrono::duration_cast<std::chrono::milliseconds>(\n      std::chrono::steady_clock::now() - compilation_start)",
          "old_line_content": "  if (EnablePassTiming()) llvm::reportAndResetTimings();",
          "new_line_content": "  auto time_to_compile = std::chrono::duration_cast<std::chrono::milliseconds>(",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": "size",
          "new_api": "llvm::reportAndResetTimings()",
          "old_text": "exported.size()",
          "new_text": "llvm::reportAndResetTimings()",
          "old_line_content": "  for (unsigned i = 0; i < exported.size(); ++i)",
          "new_line_content": "  if (EnablePassTiming()) llvm::reportAndResetTimings();",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": "std::move(memory_mapper)",
          "new_api": "size",
          "old_text": "std::move(memory_mapper)",
          "new_text": "exported.size()",
          "old_line_content": "  return Executable(compiler->name(), std::move(memory_mapper),",
          "new_line_content": "  for (unsigned i = 0; i < exported.size(); ++i)",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": "std::move(functions)",
          "new_api": "exported",
          "old_text": "std::move(functions)",
          "new_text": "*engine)->exported(i)",
          "old_line_content": "                    std::move(*engine), std::move(functions), specialization,",
          "new_line_content": "    functions[i].fptr = (*engine)->exported(i);",
          "content_same": false
        },
        {
          "line": 438,
          "old_api": "exported",
          "new_api": "assert",
          "old_text": "exported(ordinal)",
          "new_text": "assert(!specialized_ && \"can specialize executable only once\")",
          "old_line_content": "  auto func = exported(ordinal);",
          "new_line_content": "  assert(!specialized_ && \"can specialize executable only once\");",
          "content_same": false
        },
        {
          "line": 441,
          "old_api": "SpecializeFunction",
          "new_api": "exported",
          "old_text": "SpecializeFunction(func, arguments, symbolic_shapes,\n                                            constraints, listener)",
          "new_text": "exported(ordinal)",
          "old_line_content": "  if (auto specialized = SpecializeFunction(func, arguments, symbolic_shapes,",
          "new_line_content": "  auto func = exported(ordinal);",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": "message",
          "new_api": "ok",
          "old_text": "InternalError(\n        StrCat(\"failed to specialize: \", specialized.message()))",
          "new_text": "specialized.ok()",
          "old_line_content": "    return InternalError(",
          "new_line_content": "      !specialized.ok()) {",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": "absl::OkStatus()",
          "new_api": "RunSpecializationPipeline",
          "old_text": "absl::OkStatus()",
          "new_text": "RunSpecializationPipeline(*module_, opts_)",
          "old_line_content": "  return absl::OkStatus();",
          "new_line_content": "  if (failed(RunSpecializationPipeline(*module_, opts_)))",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 384,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "specialization.has_value()",
          "old_line_content": "  std::unique_ptr<XlaRuntimeMemoryMapper> memory_mapper =",
          "new_line_content": "      specialization.has_value() ? \"specialized\" : \"default\");",
          "content_same": false
        },
        {
          "line": 388,
          "old_api": null,
          "new_api": "std::move(mapper_name)",
          "old_text": null,
          "new_text": "std::move(mapper_name)",
          "old_line_content": "  ExecutionEngine::SymbolsBinding symbols =",
          "new_line_content": "      XlaRuntimeMemoryMapper::Create(std::move(mapper_name));",
          "content_same": false
        },
        {
          "line": 392,
          "old_api": null,
          "new_api": "options",
          "old_text": null,
          "new_text": "compiler->options()",
          "old_line_content": "  ExecutionEngine::JitOptions engine_options;",
          "new_line_content": "      RuntimeSymbolsBinding(compiler->options().symbols_binding);",
          "content_same": false
        },
        {
          "line": 399,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "memory_mapper.get()",
          "old_line_content": "  // Translate MLIR module to the LLVM module.",
          "new_line_content": "  engine_options.section_memory_mapper = memory_mapper.get();",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": null,
          "new_api": "module",
          "old_text": null,
          "new_text": "compiler->module()",
          "old_line_content": "",
          "new_line_content": "  auto llvm_module = translateModuleToLLVMIR(compiler->module(), *llvm_ctx);",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": null,
          "new_api": "ExecutionEngine::CreateFromModule(\n      std::move(llvm_ctx), std::move(llvm_module), engine_options, exported)",
          "old_text": null,
          "new_text": "ExecutionEngine::CreateFromModule(\n      std::move(llvm_ctx), std::move(llvm_module), engine_options, exported)",
          "old_line_content": "",
          "new_line_content": "  auto engine = ExecutionEngine::CreateFromModule(",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": null,
          "new_api": "std::move(llvm_module)",
          "old_text": null,
          "new_text": "std::move(llvm_module)",
          "old_line_content": "  // At this point compilation is completed, and all symbols in the LLVM module",
          "new_line_content": "      std::move(llvm_ctx), std::move(llvm_module), engine_options, exported);",
          "content_same": false
        },
        {
          "line": 411,
          "old_api": null,
          "new_api": "status",
          "old_text": null,
          "new_text": "engine.status()",
          "old_line_content": "  // materialized as addresses (all exported functions have a corresponding",
          "new_line_content": "  if (!engine.ok()) return engine.status();",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": null,
          "new_api": "std::chrono::steady_clock::now()",
          "old_text": null,
          "new_text": "std::chrono::steady_clock::now()",
          "old_line_content": "",
          "new_line_content": "      std::chrono::steady_clock::now() - compilation_start);",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": null,
          "new_api": "registerFunctionAnalyses",
          "old_text": null,
          "new_text": "pb.registerFunctionAnalyses(fam)",
          "old_line_content": "",
          "new_line_content": "    pb.registerFunctionAnalyses(fam);",
          "content_same": false
        },
        {
          "line": 293,
          "old_api": null,
          "new_api": "registerLoopAnalyses",
          "old_text": null,
          "new_text": "pb.registerLoopAnalyses(lam)",
          "old_line_content": "    llvm::ModulePassManager mpm;",
          "new_line_content": "    pb.registerLoopAnalyses(lam);",
          "content_same": false
        },
        {
          "line": 297,
          "old_api": null,
          "new_api": "buildPerModuleDefaultPipeline",
          "old_text": null,
          "new_text": "pb.buildPerModuleDefaultPipeline(llvm::OptimizationLevel::O2)",
          "old_line_content": "  };",
          "new_line_content": "    mpm.addPass(pb.buildPerModuleDefaultPipeline(llvm::OptimizationLevel::O2));",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": null,
          "new_api": "run",
          "old_text": null,
          "new_text": "mpm.run(*m, mam)",
          "old_line_content": "}",
          "new_line_content": "    mpm.run(*m, mam);",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": null,
          "new_api": "llvm::Error::success()",
          "old_text": null,
          "new_text": "llvm::Error::success()",
          "old_line_content": "",
          "new_line_content": "    return llvm::Error::success();",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": null,
          "new_api": "std::move(memory_mapper)",
          "old_text": null,
          "new_text": "std::move(memory_mapper)",
          "old_line_content": "}",
          "new_line_content": "  return Executable(compiler->name(), std::move(memory_mapper),",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": null,
          "new_api": "std::move(functions)",
          "old_text": null,
          "new_text": "std::move(functions)",
          "old_line_content": "",
          "new_line_content": "                    std::move(*engine), std::move(functions), specialization,",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": null,
          "new_api": "std::chrono::steady_clock::now()",
          "old_text": null,
          "new_text": "std::chrono::steady_clock::now()",
          "old_line_content": "",
          "new_line_content": "  auto compilation_start = std::chrono::steady_clock::now();",
          "content_same": false
        },
        {
          "line": 309,
          "old_api": null,
          "new_api": "options",
          "old_text": null,
          "new_text": "compiler->options()",
          "old_line_content": "  if (!opts.calling_convention)",
          "new_line_content": "  const JitCompiler::Options& opts = compiler->options();",
          "content_same": false
        },
        {
          "line": 313,
          "old_api": null,
          "new_api": "Error",
          "old_text": null,
          "new_text": "compiler->Error(\"calling convention is not defined\")",
          "old_line_content": "  std::vector<Executable::Function> functions;",
          "new_line_content": "    return compiler->Error(\"calling convention is not defined\");",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": null,
          "new_api": "SpecializeFunction",
          "old_text": null,
          "new_text": "SpecializeFunction(func, arguments, symbolic_shapes,\n                                            constraints, listener)",
          "old_line_content": "    // No need to call this->Error() because we don't have diagnostic to report",
          "new_line_content": "  if (auto specialized = SpecializeFunction(func, arguments, symbolic_shapes,",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": null,
          "new_api": "exported",
          "old_text": null,
          "new_text": "compiler->exported()",
          "old_line_content": "",
          "new_line_content": "  for (const auto& indexed : llvm::enumerate(compiler->exported())) {",
          "content_same": false
        },
        {
          "line": 320,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "indexed.value()",
          "old_line_content": "    // Get the signature of the exported function.",
          "new_line_content": "    auto func = indexed.value();",
          "content_same": false
        },
        {
          "line": 449,
          "old_api": null,
          "new_api": "message",
          "old_text": null,
          "new_text": "InternalError(\n        StrCat(\"failed to specialize: \", specialized.message()))",
          "old_line_content": "",
          "new_line_content": "    return InternalError(",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": null,
          "new_api": "message",
          "old_text": null,
          "new_text": "specialized.message()",
          "old_line_content": "  // Run the user-provided specialization pipeline to take advantage of the",
          "new_line_content": "        StrCat(\"failed to specialize: \", specialized.message()));",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": null,
          "new_api": "Convert",
          "old_text": null,
          "new_text": "opts.type_converter.Convert(\n        llvm::cast<mlir::FunctionType>(func.getFunctionType()))",
          "old_line_content": "",
          "new_line_content": "    auto signature = opts.type_converter.Convert(",
          "content_same": false
        },
        {
          "line": 325,
          "old_api": null,
          "new_api": "getFunctionType",
          "old_text": null,
          "new_text": "func.getFunctionType()",
          "old_line_content": "    // Calling convention conversion can fail if some types are not supported.",
          "new_line_content": "        llvm::cast<mlir::FunctionType>(func.getFunctionType()));",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": null,
          "new_api": "Error",
          "old_text": null,
          "new_text": "Error(\"failed to run specialization pipeline\")",
          "old_line_content": "}",
          "new_line_content": "    return Error(\"failed to run specialization pipeline\");",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": null,
          "new_api": "getFunctionType",
          "old_text": null,
          "new_text": "func.getFunctionType()",
          "old_line_content": "          \"calling convention failed to convert function type for %s\", name));",
          "new_line_content": "        llvm::cast<mlir::FunctionType>(func.getFunctionType()));",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": null,
          "new_api": "absl::OkStatus()",
          "old_text": null,
          "new_text": "absl::OkStatus()",
          "old_line_content": "}  // namespace runtime",
          "new_line_content": "  return absl::OkStatus();",
          "content_same": false
        },
        {
          "line": 332,
          "old_api": null,
          "new_api": "StrFormat",
          "old_text": null,
          "new_text": "StrFormat(\n          \"calling convention failed to convert function type for %s\", name)",
          "old_line_content": "    // Get the runtime signature of the exported function.",
          "new_line_content": "      return compiler->Error(StrFormat(",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": null,
          "new_api": "Convert",
          "old_text": null,
          "new_text": "opts.type_converter.Convert(runtime_type)",
          "old_line_content": "    // Get the memory layout for passing function arguments.",
          "new_line_content": "    auto runtime_signature = opts.type_converter.Convert(runtime_type);",
          "content_same": false
        },
        {
          "line": 337,
          "old_api": null,
          "new_api": "status",
          "old_text": null,
          "new_text": "runtime_signature.status()",
          "old_line_content": "    auto arguments_memory_layout =",
          "new_line_content": "    if (!runtime_signature.ok()) return runtime_signature.status();",
          "content_same": false
        },
        {
          "line": 341,
          "old_api": null,
          "new_api": "Executable::GetArgumentsMemoryLayout(*runtime_signature)",
          "old_text": null,
          "new_text": "Executable::GetArgumentsMemoryLayout(*runtime_signature)",
          "old_line_content": "    // Get the memory layout for returning function results.",
          "new_line_content": "        Executable::GetArgumentsMemoryLayout(*runtime_signature);",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": null,
          "new_api": "status",
          "old_text": null,
          "new_text": "arguments_memory_layout.status()",
          "old_line_content": "    auto results_memory_layout =",
          "new_line_content": "    if (!arguments_memory_layout.ok()) return arguments_memory_layout.status();",
          "content_same": false
        },
        {
          "line": 346,
          "old_api": null,
          "new_api": "Executable::GetResultsMemoryLayout(*runtime_signature)",
          "old_text": null,
          "new_text": "Executable::GetResultsMemoryLayout(*runtime_signature)",
          "old_line_content": "    bool requires_blas = false;",
          "new_line_content": "        Executable::GetResultsMemoryLayout(*runtime_signature);",
          "content_same": false
        },
        {
          "line": 350,
          "old_api": null,
          "new_api": "getAttr",
          "old_text": null,
          "new_text": "func->getAttr(\"xla.requires_blas\")",
          "old_line_content": "",
          "new_line_content": "    if (Attribute requires_blas_attr = func->getAttr(\"xla.requires_blas\")) {",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": null,
          "new_api": "getValue",
          "old_text": null,
          "new_text": "cast<BoolAttr>(requires_blas_attr).getValue()",
          "old_line_content": "    // Add function with an unresolved function pointer; it will be updated once",
          "new_line_content": "      requires_blas = cast<BoolAttr>(requires_blas_attr).getValue();",
          "content_same": false
        },
        {
          "line": 358,
          "old_api": null,
          "new_api": "std::move(*runtime_signature)",
          "old_text": null,
          "new_text": "std::move(*runtime_signature)",
          "old_line_content": "  }",
          "new_line_content": "        /*fptr=*/nullptr, std::move(*signature), std::move(*runtime_signature),",
          "content_same": false
        },
        {
          "line": 359,
          "old_api": null,
          "new_api": "std::move(*results_memory_layout)",
          "old_text": null,
          "new_text": "std::move(*results_memory_layout)",
          "old_line_content": "",
          "new_line_content": "        std::move(*arguments_memory_layout), std::move(*results_memory_layout),",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": null,
          "new_api": "Error",
          "old_text": null,
          "new_text": "compiler->Error(\"failed to run compilation pipeline\")",
          "old_line_content": "",
          "new_line_content": "    return compiler->Error(\"failed to run compilation pipeline\");",
          "content_same": false
        },
        {
          "line": 371,
          "old_api": null,
          "new_api": "takeError",
          "old_text": null,
          "new_text": "builder.takeError()",
          "old_line_content": "  if (!target_machine)",
          "new_line_content": "  if (!builder) return InternalError(toString(builder.takeError()));",
          "content_same": false
        },
        {
          "line": 373,
          "old_api": null,
          "new_api": "createTargetMachine",
          "old_text": null,
          "new_text": "builder->createTargetMachine()",
          "old_line_content": "",
          "new_line_content": "  auto target_machine = builder->createTargetMachine();",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "memory_region_name.empty()",
          "old_line_content": "",
          "new_line_content": "      \"/xla{0}{1}:@{2}::@{3}\", memory_region_name.empty() ? \"\" : \":\",",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": null,
          "new_api": "EscapeMemRegionName",
          "old_text": null,
          "new_text": "EscapeMemRegionName(memory_region_name)",
          "old_line_content": "  // Custom memory mapper to tag memory allocated for XLA executables.",
          "new_line_content": "      EscapeMemRegionName(memory_region_name), module_name,",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 385,
          "old_api": "std::move(mapper_name)",
          "new_api": null,
          "old_text": "std::move(mapper_name)",
          "new_text": null,
          "old_line_content": "      XlaRuntimeMemoryMapper::Create(std::move(mapper_name));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 389,
          "old_api": "options",
          "new_api": null,
          "old_text": "compiler->options()",
          "new_text": null,
          "old_line_content": "      RuntimeSymbolsBinding(compiler->options().symbols_binding);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": "options",
          "new_api": null,
          "old_text": "compiler->options()",
          "new_text": null,
          "old_line_content": "  engine_options.opt_level = compiler->options().jit_code_opt_level;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": "get",
          "new_api": null,
          "old_text": "target_machine->get()",
          "new_text": null,
          "old_line_content": "  engine_options.target_machine = target_machine->get();",
          "new_line_content": "  // Construct options for the XLA runtime execution engine.",
          "content_same": false
        },
        {
          "line": 401,
          "old_api": "module",
          "new_api": null,
          "old_text": "compiler->module()",
          "new_text": null,
          "old_line_content": "  auto llvm_module = translateModuleToLLVMIR(compiler->module(), *llvm_ctx);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": "std::move(llvm_module)",
          "new_api": null,
          "old_text": "std::move(llvm_module)",
          "new_text": null,
          "old_line_content": "      std::move(llvm_ctx), std::move(llvm_module), engine_options, exported);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": "status",
          "new_api": null,
          "old_text": "engine.status()",
          "new_text": null,
          "old_line_content": "  if (!engine.ok()) return engine.status();",
          "new_line_content": "  // Compile input module to the native function.",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": "std::chrono::duration_cast<std::chrono::milliseconds>(\n      std::chrono::steady_clock::now() - compilation_start)",
          "new_api": null,
          "old_text": "std::chrono::duration_cast<std::chrono::milliseconds>(\n      std::chrono::steady_clock::now() - compilation_start)",
          "new_text": null,
          "old_line_content": "  auto time_to_compile = std::chrono::duration_cast<std::chrono::milliseconds>(",
          "new_line_content": "  // At this point compilation is completed, and all symbols in the LLVM module",
          "content_same": false
        },
        {
          "line": 414,
          "old_api": "std::chrono::steady_clock::now()",
          "new_api": null,
          "old_text": "std::chrono::steady_clock::now()",
          "new_text": null,
          "old_line_content": "      std::chrono::steady_clock::now() - compilation_start);",
          "new_line_content": "  // materialized as addresses (all exported functions have a corresponding",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": "registerModuleAnalyses",
          "new_api": null,
          "old_text": "pb.registerModuleAnalyses(mam)",
          "new_text": null,
          "old_line_content": "    pb.registerModuleAnalyses(mam);",
          "new_line_content": "    tuningOptions.LoopVectorization = false;",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": "registerCGSCCAnalyses",
          "new_api": null,
          "old_text": "pb.registerCGSCCAnalyses(cgam)",
          "new_text": null,
          "old_line_content": "    pb.registerCGSCCAnalyses(cgam);",
          "new_line_content": "    llvm::PassBuilder pb(targetMachine, tuningOptions);",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": "registerFunctionAnalyses",
          "new_api": null,
          "old_text": "pb.registerFunctionAnalyses(fam)",
          "new_text": null,
          "old_line_content": "    pb.registerFunctionAnalyses(fam);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 420,
          "old_api": "exported",
          "new_api": null,
          "old_text": "*engine)->exported(i)",
          "new_text": null,
          "old_line_content": "    functions[i].fptr = (*engine)->exported(i);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": "run",
          "new_api": null,
          "old_text": "mpm.run(*m, mam)",
          "new_text": null,
          "old_line_content": "    mpm.run(*m, mam);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": "llvm::Error::success()",
          "new_api": null,
          "old_text": "llvm::Error::success()",
          "new_text": null,
          "old_line_content": "    return llvm::Error::success();",
          "new_line_content": "    llvm::ModulePassManager mpm;",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": "std::chrono::steady_clock::now()",
          "new_api": null,
          "old_text": "std::chrono::steady_clock::now()",
          "new_text": null,
          "old_line_content": "  auto compilation_start = std::chrono::steady_clock::now();",
          "new_line_content": "    std::unique_ptr<JitCompiler> compiler, std::string_view memory_region_name,",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": "options",
          "new_api": null,
          "old_text": "compiler->options()",
          "new_text": null,
          "old_line_content": "  const JitCompiler::Options& opts = compiler->options();",
          "new_line_content": "  // We track end-to-end time to compile the final executable.",
          "content_same": false
        },
        {
          "line": 435,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(!specialized_ && \"can specialize executable only once\")",
          "new_text": null,
          "old_line_content": "  assert(!specialized_ && \"can specialize executable only once\");",
          "new_line_content": "                                     ArrayRef<SymbolicShape> symbolic_shapes,",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": "Error",
          "new_api": null,
          "old_text": "compiler->Error(\"calling convention is not defined\")",
          "new_text": null,
          "old_line_content": "    return compiler->Error(\"calling convention is not defined\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": "ok",
          "new_api": null,
          "old_text": "specialized.ok()",
          "new_text": null,
          "old_line_content": "      !specialized.ok()) {",
          "new_line_content": "  // Update function signature and sink constant arguments into the body.",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": "exported",
          "new_api": null,
          "old_text": "compiler->exported()",
          "new_text": null,
          "old_line_content": "  for (const auto& indexed : llvm::enumerate(compiler->exported())) {",
          "new_line_content": "  std::vector<Executable::Function> functions;",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": "value",
          "new_api": null,
          "old_text": "indexed.value()",
          "new_text": null,
          "old_line_content": "    auto func = indexed.value();",
          "new_line_content": "  std::vector<std::string_view> exported;  // names of exported functions",
          "content_same": false
        },
        {
          "line": 318,
          "old_api": "getName",
          "new_api": null,
          "old_text": "func.getName()",
          "new_text": null,
          "old_line_content": "    std::string_view name = exported.emplace_back(func.getName());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 447,
          "old_api": "message",
          "new_api": null,
          "old_text": "specialized.message()",
          "new_text": null,
          "old_line_content": "        StrCat(\"failed to specialize: \", specialized.message()));",
          "new_line_content": "    // No need to call this->Error() because we don't have diagnostic to report",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": "getFunctionType",
          "new_api": null,
          "old_text": "func.getFunctionType()",
          "new_text": null,
          "old_line_content": "        llvm::cast<mlir::FunctionType>(func.getFunctionType()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 323,
          "old_api": "status",
          "new_api": null,
          "old_text": "signature.status()",
          "new_text": null,
          "old_line_content": "    if (!signature.ok()) return signature.status();",
          "new_line_content": "    // Get the signature of the exported function.",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": "RunSpecializationPipeline",
          "new_api": null,
          "old_text": "RunSpecializationPipeline(*module_, opts_)",
          "new_text": null,
          "old_line_content": "  if (failed(RunSpecializationPipeline(*module_, opts_)))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 453,
          "old_api": "Error",
          "new_api": null,
          "old_text": "Error(\"failed to run specialization pipeline\")",
          "new_text": null,
          "old_line_content": "    return Error(\"failed to run specialization pipeline\");",
          "new_line_content": "  // Run the user-provided specialization pipeline to take advantage of the",
          "content_same": false
        },
        {
          "line": 327,
          "old_api": "getFunctionType",
          "new_api": null,
          "old_text": "func.getFunctionType()",
          "new_text": null,
          "old_line_content": "        llvm::cast<mlir::FunctionType>(func.getFunctionType()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 333,
          "old_api": "Convert",
          "new_api": null,
          "old_text": "opts.type_converter.Convert(runtime_type)",
          "new_text": null,
          "old_line_content": "    auto runtime_signature = opts.type_converter.Convert(runtime_type);",
          "new_line_content": "          \"calling convention failed to convert function type for %s\", name));",
          "content_same": false
        },
        {
          "line": 334,
          "old_api": "status",
          "new_api": null,
          "old_text": "runtime_signature.status()",
          "new_text": null,
          "old_line_content": "    if (!runtime_signature.ok()) return runtime_signature.status();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": "Executable::GetArgumentsMemoryLayout(*runtime_signature)",
          "new_api": null,
          "old_text": "Executable::GetArgumentsMemoryLayout(*runtime_signature)",
          "new_text": null,
          "old_line_content": "        Executable::GetArgumentsMemoryLayout(*runtime_signature);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 339,
          "old_api": "status",
          "new_api": null,
          "old_text": "arguments_memory_layout.status()",
          "new_text": null,
          "old_line_content": "    if (!arguments_memory_layout.ok()) return arguments_memory_layout.status();",
          "new_line_content": "    // Get the memory layout for passing function arguments.",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": "Executable::GetResultsMemoryLayout(*runtime_signature)",
          "new_api": null,
          "old_text": "Executable::GetResultsMemoryLayout(*runtime_signature)",
          "new_text": null,
          "old_line_content": "        Executable::GetResultsMemoryLayout(*runtime_signature);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 344,
          "old_api": "status",
          "new_api": null,
          "old_text": "results_memory_layout.status()",
          "new_text": null,
          "old_line_content": "    if (!results_memory_layout.ok()) return results_memory_layout.status();",
          "new_line_content": "    // Get the memory layout for returning function results.",
          "content_same": false
        },
        {
          "line": 348,
          "old_api": "getValue",
          "new_api": null,
          "old_text": "cast<BoolAttr>(requires_blas_attr).getValue()",
          "new_text": null,
          "old_line_content": "      requires_blas = cast<BoolAttr>(requires_blas_attr).getValue();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 353,
          "old_api": "Executable::Function(\n        name,\n        /*fptr=*/nullptr, std::move(*signature), std::move(*runtime_signature),\n        std::move(*arguments_memory_layout), std::move(*results_memory_layout),\n        requires_blas)",
          "new_api": null,
          "old_text": "Executable::Function(\n        name,\n        /*fptr=*/nullptr, std::move(*signature), std::move(*runtime_signature),\n        std::move(*arguments_memory_layout), std::move(*results_memory_layout),\n        requires_blas)",
          "new_text": null,
          "old_line_content": "    functions.push_back(Executable::Function(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 355,
          "old_api": "std::move(*runtime_signature)",
          "new_api": null,
          "old_text": "std::move(*runtime_signature)",
          "new_text": null,
          "old_line_content": "        /*fptr=*/nullptr, std::move(*signature), std::move(*runtime_signature),",
          "new_line_content": "    // we compile the input module to the native executable.",
          "content_same": false
        },
        {
          "line": 361,
          "old_api": "module",
          "new_api": null,
          "old_text": "compiler->module()",
          "new_text": null,
          "old_line_content": "  if (failed(RunCompilationPipeline(compiler->module(), opts)))",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 362,
          "old_api": "Error",
          "new_api": null,
          "old_text": "compiler->Error(\"failed to run compilation pipeline\")",
          "new_text": null,
          "old_line_content": "    return compiler->Error(\"failed to run compilation pipeline\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 368,
          "old_api": "takeError",
          "new_api": null,
          "old_text": "builder.takeError()",
          "new_text": null,
          "old_line_content": "  if (!builder) return InternalError(toString(builder.takeError()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": "takeError",
          "new_api": null,
          "old_text": "target_machine.takeError()",
          "new_text": null,
          "old_line_content": "    return InternalError(toString(target_machine.takeError()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": "empty",
          "new_api": null,
          "old_text": "memory_region_name.empty()",
          "new_text": null,
          "old_line_content": "      \"/xla{0}{1}:@{2}::@{3}\", memory_region_name.empty() ? \"\" : \":\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": "EscapeMemRegionName",
          "new_api": null,
          "old_text": "EscapeMemRegionName(memory_region_name)",
          "new_text": null,
          "old_line_content": "      EscapeMemRegionName(memory_region_name), module_name,",
          "new_line_content": "  // Memory region name to mmap executable code.",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 27,
      "total_additions": 44,
      "total_deletions": 44,
      "total_api_changes": 115
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 3,
        "api_related_lines": 115,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          283,
          284,
          285
        ]
      }
    },
    "api_calls_before": 189,
    "api_calls_after": 189,
    "diff_info": {
      "added_lines": 3,
      "removed_lines": 0,
      "total_diff_lines": 15
    }
  }
}