{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/f7bae45c694afe597c1e2aa259862c705ebd77e7",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/f7bae45c694afe597c1e2aa259862c705ebd77e7/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/f7bae45c694afe597c1e2aa259862c705ebd77e7/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/f7bae45c694afe597c1e2aa259862c705ebd77e7/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 172,
          "old_api": "size",
          "new_api": "name",
          "old_text": "props_->output_types.size()",
          "new_text": "props_->node_def.name()",
          "old_line_content": "int32 Node::num_outputs() const { return props_->output_types.size(); }",
          "new_line_content": "const string& Node::name() const { return props_->node_def.name(); }",
          "content_same": false
        },
        {
          "line": 181,
          "old_api": "input",
          "new_api": "size",
          "old_text": "def().input()",
          "new_text": "props_->output_types.size()",
          "old_line_content": "  return def().input();",
          "new_line_content": "int32 Node::num_outputs() const { return props_->output_types.size(); }",
          "content_same": false
        },
        {
          "line": 187,
          "old_api": "begin",
          "new_api": "def",
          "old_text": "out_edges_.begin()",
          "new_text": "def()",
          "old_line_content": "  return gtl::make_range(NeighborIter(out_edges_.begin(), false),",
          "new_line_content": "AttrSlice Node::attrs() const { return AttrSlice(def()); }",
          "content_same": false
        },
        {
          "line": 193,
          "old_api": "end",
          "new_api": "device",
          "old_text": "in_edges_.end()",
          "new_text": "def().device()",
          "old_line_content": "                         NeighborIter(in_edges_.end(), true));",
          "new_line_content": "const string& Node::requested_device() const { return def().device(); }",
          "content_same": false
        },
        {
          "line": 214,
          "old_api": "MaybeCopyOnWrite",
          "new_api": "mutable_attr",
          "old_text": "MaybeCopyOnWrite()",
          "new_text": "props_->node_def.mutable_attr()",
          "old_line_content": "  MaybeCopyOnWrite();",
          "new_line_content": "  return &((*props_->node_def.mutable_attr())[name]);",
          "content_same": false
        },
        {
          "line": 219,
          "old_api": "MaybeCopyOnWrite",
          "new_api": "mutable_attr",
          "old_text": "MaybeCopyOnWrite()",
          "new_text": "props_->node_def.mutable_attr()",
          "old_line_content": "  MaybeCopyOnWrite();",
          "new_line_content": "  (*props_->node_def.mutable_attr()).erase(name);",
          "content_same": false
        },
        {
          "line": 224,
          "old_api": "MaybeCopyOnWrite",
          "new_api": "std::move(name)",
          "old_text": "MaybeCopyOnWrite()",
          "new_text": "std::move(name)",
          "old_line_content": "  MaybeCopyOnWrite();",
          "new_line_content": "  props_->node_def.set_name(std::move(name));",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": "mutable_experimental_debug_info",
          "new_api": "MaybeCopyOnWrite",
          "old_text": "props_->node_def.mutable_experimental_debug_info()\n         ->mutable_original_node_names()",
          "new_text": "MaybeCopyOnWrite()",
          "old_line_content": "    *props_->node_def.mutable_experimental_debug_info()",
          "new_line_content": "  MaybeCopyOnWrite();",
          "content_same": false
        },
        {
          "line": 229,
          "old_api": "end",
          "new_api": "set_device",
          "old_text": "names.end()",
          "new_text": "props_->node_def.set_device(device)",
          "old_line_content": "         ->mutable_original_node_names() = {names.begin(), names.end()};",
          "new_line_content": "  props_->node_def.set_device(device);",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": "num_inputs",
          "new_api": "mutable_experimental_debug_info",
          "old_text": "num_inputs()",
          "new_text": "props_->node_def.mutable_experimental_debug_info()\n      ->clear_original_node_names()",
          "old_line_content": "  if (idx < 0 || idx >= num_inputs()) {",
          "new_line_content": "  props_->node_def.mutable_experimental_debug_info()",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": "num_inputs",
          "new_api": "empty",
          "old_text": "num_inputs()",
          "new_text": "names.empty()",
          "old_line_content": "                                   name(), \" only has \", num_inputs(),",
          "new_line_content": "  if (!names.empty()) {",
          "content_same": false
        },
        {
          "line": 261,
          "old_api": "clear",
          "new_api": "Status::OK()",
          "old_text": "input_edges->clear()",
          "new_text": "Status::OK()",
          "old_line_content": "  input_edges->clear();",
          "new_line_content": "      return Status::OK();",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": "IsControlEdge",
          "new_api": "name",
          "old_text": "edge->IsControlEdge()",
          "new_text": "name()",
          "old_line_content": "    if (edge->IsControlEdge()) continue;",
          "new_line_content": "  return errors::NotFound(\"Could not find input edge \", idx, \" for \", name());",
          "content_same": false
        },
        {
          "line": 270,
          "old_api": "dst_input",
          "new_api": "clear",
          "old_text": "errors::Internal(\"Duplicate edge input number: \",\n                              edge->dst_input())",
          "new_text": "input_edges->clear()",
          "old_line_content": "      return errors::Internal(\"Duplicate edge input number: \",",
          "new_line_content": "  input_edges->clear();",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": "dst_input",
          "new_api": "num_inputs",
          "old_text": "edge->dst_input()",
          "new_text": "num_inputs()",
          "old_line_content": "                              edge->dst_input());",
          "new_line_content": "  input_edges->resize(num_inputs(), nullptr);",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": "dst_input",
          "new_api": "in_edges",
          "old_text": "edge->dst_input()",
          "new_text": "in_edges()",
          "old_line_content": "    (*input_edges)[edge->dst_input()] = edge;",
          "new_line_content": "  for (const Edge* edge : in_edges()) {",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": "num_inputs",
          "new_api": "dst_input",
          "old_text": "num_inputs()",
          "new_text": "edge->dst_input()",
          "old_line_content": "  for (int i = 0; i < num_inputs(); ++i) {",
          "new_line_content": "      return errors::Internal(\"Invalid edge input number \", edge->dst_input());",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": "errors::InvalidArgument(\"Missing edge input number: \", i)",
          "new_api": "dst_input",
          "old_text": "errors::InvalidArgument(\"Missing edge input number: \", i)",
          "new_text": "edge->dst_input()",
          "old_line_content": "      return errors::InvalidArgument(\"Missing edge input number: \", i);",
          "new_line_content": "    if ((*input_edges)[edge->dst_input()] != nullptr) {",
          "content_same": false
        },
        {
          "line": 290,
          "old_api": "src",
          "new_api": "Status::OK()",
          "old_text": "e->src()",
          "new_text": "Status::OK()",
          "old_line_content": "    *n = e->src();",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": "Status::OK()",
          "new_api": "src",
          "old_text": "Status::OK()",
          "new_text": "e->src()",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "    *n = e->src();",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": "src_output",
          "new_api": "input_node",
          "old_text": "e->src_output()",
          "new_text": "input_node(idx, &n)",
          "old_line_content": "  *t = OutputTensor(e->src(), e->src_output());",
          "new_line_content": "  TF_RETURN_IF_ERROR(input_node(idx, &n));",
          "content_same": false
        },
        {
          "line": 314,
          "old_api": "has_experimental_debug_info",
          "new_api": "DCHECK",
          "old_text": "ndef.has_experimental_debug_info()",
          "new_text": "DCHECK(e != nullptr)",
          "old_line_content": "    : NodeDebugInfo(ndef.name(), ndef.has_experimental_debug_info(),",
          "new_line_content": "  DCHECK(e != nullptr);",
          "content_same": false
        },
        {
          "line": 315,
          "old_api": "experimental_debug_info",
          "new_api": "src_output",
          "old_text": "ndef.experimental_debug_info()",
          "new_text": "e->src_output()",
          "old_line_content": "                    ndef.experimental_debug_info()) {}",
          "new_line_content": "  *t = OutputTensor(e->src(), e->src_output());",
          "content_same": false
        },
        {
          "line": 321,
          "old_api": "original_node_names",
          "new_api": "def",
          "old_text": "experimental_debug_info.original_node_names()",
          "new_text": "n.def()",
          "old_line_content": "    const auto& names = experimental_debug_info.original_node_names();",
          "new_line_content": "NodeDebugInfo::NodeDebugInfo(const Node& n) : NodeDebugInfo(n.def()) {}",
          "content_same": false
        },
        {
          "line": 354,
          "old_api": "set_producer",
          "new_api": "std::hash<int>()(s.index)",
          "old_text": "versions_->set_producer(TF_GRAPH_DEF_VERSION)",
          "new_text": "std::hash<int>()(s.index)",
          "old_line_content": "  versions_->set_producer(TF_GRAPH_DEF_VERSION);",
          "new_line_content": "                       std::hash<int>()(s.index));",
          "content_same": false
        },
        {
          "line": 363,
          "old_api": "set_name",
          "new_api": "set_producer",
          "old_text": "def.set_name(\"_SOURCE\")",
          "new_text": "versions_->set_producer(TF_GRAPH_DEF_VERSION)",
          "old_line_content": "  def.set_name(\"_SOURCE\");",
          "new_line_content": "  versions_->set_producer(TF_GRAPH_DEF_VERSION);",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": "set_op",
          "new_api": "set_min_consumer",
          "old_text": "def.set_op(\"NoOp\")",
          "new_text": "versions_->set_min_consumer(TF_GRAPH_DEF_VERSION_MIN_CONSUMER)",
          "old_line_content": "  def.set_op(\"NoOp\");",
          "new_line_content": "  versions_->set_min_consumer(TF_GRAPH_DEF_VERSION_MIN_CONSUMER);",
          "content_same": false
        },
        {
          "line": 367,
          "old_api": "TF_CHECK_OK",
          "new_api": "push_back",
          "old_text": "TF_CHECK_OK(status)",
          "new_text": "device_names_.push_back(\"\")",
          "old_line_content": "  TF_CHECK_OK(status);",
          "new_line_content": "  device_names_.push_back(\"\");",
          "content_same": false
        },
        {
          "line": 368,
          "old_api": "id",
          "new_api": "InternDeviceName",
          "old_text": "source->id()",
          "new_text": "InternDeviceName(\"\")",
          "old_line_content": "  CHECK_EQ(source->id(), kSourceId);",
          "new_line_content": "  DCHECK_EQ(0, InternDeviceName(\"\"));",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": "TF_CHECK_OK",
          "new_api": "set_name",
          "old_text": "TF_CHECK_OK(status)",
          "new_text": "def.set_name(\"_SOURCE\")",
          "old_line_content": "  TF_CHECK_OK(status);",
          "new_line_content": "  def.set_name(\"_SOURCE\");",
          "content_same": false
        },
        {
          "line": 373,
          "old_api": "id",
          "new_api": "set_op",
          "old_text": "sink->id()",
          "new_text": "def.set_op(\"NoOp\")",
          "old_line_content": "  CHECK_EQ(sink->id(), kSinkId);",
          "new_line_content": "  def.set_op(\"NoOp\");",
          "content_same": false
        },
        {
          "line": 375,
          "old_api": "AddControlEdge",
          "new_api": "AddNode",
          "old_text": "AddControlEdge(source, sink)",
          "new_text": "AddNode(def, &status)",
          "old_line_content": "  AddControlEdge(source, sink);",
          "new_line_content": "  Node* source = AddNode(def, &status);",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": "default_registry",
          "new_api": "set_name",
          "old_text": "flib_def.default_registry()",
          "new_text": "def.set_name(\"_SINK\")",
          "old_line_content": "    : Graph(flib_def.default_registry()) {",
          "new_line_content": "  def.set_name(\"_SINK\");",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": "min_consumer",
          "new_api": "TF_CHECK_OK",
          "old_text": "versions_->min_consumer()",
          "new_text": "TF_CHECK_OK(status)",
          "old_line_content": "  if (flib_def.num_functions() > 0 && versions_->min_consumer() < 12) {",
          "new_line_content": "  TF_CHECK_OK(status);",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": "set_min_consumer",
          "new_api": "id",
          "old_text": "versions_->set_min_consumer(12)",
          "new_text": "sink->id()",
          "old_line_content": "    versions_->set_min_consumer(12);",
          "new_line_content": "  CHECK_EQ(sink->id(), kSinkId);",
          "content_same": false
        },
        {
          "line": 384,
          "old_api": "AddLibrary",
          "new_api": "AddControlEdge",
          "old_text": "ops_.AddLibrary(flib_def)",
          "new_text": "AddControlEdge(source, sink)",
          "old_line_content": "  Status s = ops_.AddLibrary(flib_def);",
          "new_line_content": "  AddControlEdge(source, sink);",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": "node->~Node()",
          "new_api": "AddLibrary",
          "old_text": "node->~Node()",
          "new_text": "ops_.AddLibrary(flib_def)",
          "old_line_content": "      node->~Node();",
          "new_line_content": "  Status s = ops_.AddLibrary(flib_def);",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": "op",
          "new_api": "Update",
          "old_text": "node_def.op()",
          "new_text": "status->Update(\n      InOutTypesForNode(node_def, op_reg_data->op_def, &inputs, &outputs))",
          "old_line_content": "                                   : Node::GetNodeClassForOp(node_def.op());",
          "new_line_content": "  status->Update(",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": "AllocateNode",
          "new_api": "ok",
          "old_text": "AllocateNode(\n      std::make_shared<NodeProperties>(&op_reg_data->op_def,\n                                       std::move(node_def), inputs, outputs),\n      nullptr, node_class)",
          "new_text": "status->ok()",
          "old_line_content": "  Node* node = AllocateNode(",
          "new_line_content": "  if (!status->ok()) {",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": "std::make_shared<NodeProperties>(&op_reg_data->op_def,\n                                       std::move(node_def), inputs, outputs)",
          "new_api": "AttachDef",
          "old_text": "std::make_shared<NodeProperties>(&op_reg_data->op_def,\n                                       std::move(node_def), inputs, outputs)",
          "new_text": "AttachDef(*status, node_def)",
          "old_line_content": "      std::make_shared<NodeProperties>(&op_reg_data->op_def,",
          "new_line_content": "    *status = AttachDef(*status, node_def);",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": "IsSink",
          "new_api": "AllocateNode",
          "old_text": "node->IsSink()",
          "new_text": "AllocateNode(\n      std::make_shared<NodeProperties>(&op_reg_data->op_def,\n                                       std::move(node_def), inputs, outputs),\n      nullptr, node_class)",
          "old_line_content": "  DCHECK(!node->IsSink());",
          "new_line_content": "  Node* node = AllocateNode(",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": "AllocateNode",
          "new_api": "std::make_shared<NodeProperties>(&op_reg_data->op_def,\n                                       std::move(node_def), inputs, outputs)",
          "old_text": "AllocateNode(node->props_, node, node->class_)",
          "new_text": "std::make_shared<NodeProperties>(&op_reg_data->op_def,\n                                       std::move(node_def), inputs, outputs)",
          "old_line_content": "  Node* copy = AllocateNode(node->props_, node, node->class_);",
          "new_line_content": "      std::make_shared<NodeProperties>(&op_reg_data->op_def,",
          "content_same": false
        },
        {
          "line": 435,
          "old_api": "assigned_device_name",
          "new_api": "std::move(node_def)",
          "old_text": "node->assigned_device_name()",
          "new_text": "std::move(node_def)",
          "old_line_content": "  copy->set_assigned_device_name(node->assigned_device_name());",
          "new_line_content": "                                       std::move(node_def), inputs, outputs),",
          "content_same": false
        },
        {
          "line": 441,
          "old_api": "type_string",
          "new_api": "IsSource",
          "old_text": "node->type_string()",
          "new_text": "node->IsSource()",
          "old_line_content": "  TF_CHECK_OK(ops_.LookUpOpDef(node->type_string(), &op_def));",
          "new_line_content": "  DCHECK(!node->IsSource());",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": "MaybeCopyOnWrite",
          "new_api": "AllocateNode",
          "old_text": "copy->MaybeCopyOnWrite()",
          "new_text": "AllocateNode(node->props_, node, node->class_)",
          "old_line_content": "    copy->MaybeCopyOnWrite();",
          "new_line_content": "  Node* copy = AllocateNode(node->props_, node, node->class_);",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": "IsSource",
          "new_api": "MaybeCopyOnWrite",
          "old_text": "node->IsSource()",
          "new_text": "copy->MaybeCopyOnWrite()",
          "old_line_content": "  DCHECK(!node->IsSource());",
          "new_line_content": "    copy->MaybeCopyOnWrite();",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": "clear",
          "new_api": "IsSink",
          "old_text": "node->in_edges_.clear()",
          "new_text": "node->IsSink()",
          "old_line_content": "  node->in_edges_.clear();",
          "new_line_content": "  DCHECK(!node->IsSink());",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": "RecycleEdge",
          "new_api": "erase",
          "old_text": "RecycleEdge(e)",
          "new_text": "e->src_->out_edges_.erase(e)",
          "old_line_content": "    RecycleEdge(e);",
          "new_line_content": "    CHECK_EQ(e->src_->out_edges_.erase(e), size_t{1});",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": "DebugString",
          "new_api": "RecycleEdge",
          "old_text": "dest->DebugString()",
          "new_text": "RecycleEdge(e)",
          "old_line_content": "  TF_DCHECK_OK(IsValidNode(dest)) << dest->DebugString();",
          "new_line_content": "    RecycleEdge(e);",
          "content_same": false
        },
        {
          "line": 479,
          "old_api": "sink_node",
          "new_api": "ReleaseNode",
          "old_text": "sink_node()",
          "new_text": "ReleaseNode(node)",
          "old_line_content": "  if (source == source_node() || dest == sink_node() || x == kControlSlot ||",
          "new_line_content": "  ReleaseNode(node);",
          "content_same": false
        },
        {
          "line": 490,
          "old_api": "pop_back",
          "new_api": "DebugString",
          "old_text": "free_edges_.pop_back()",
          "new_text": "source->DebugString()",
          "old_line_content": "    free_edges_.pop_back();",
          "new_line_content": "    DCHECK_EQ(x, kControlSlot) << source->DebugString();",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": "insert",
          "new_api": "back",
          "old_text": "dest->in_edges_.insert(e)",
          "new_text": "free_edges_.back()",
          "old_line_content": "  CHECK(dest->in_edges_.insert(e).second);",
          "new_line_content": "    e = free_edges_.back();",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": "push_back",
          "new_api": "pop_back",
          "old_text": "edges_.push_back(e)",
          "new_text": "free_edges_.pop_back()",
          "old_line_content": "  edges_.push_back(e);",
          "new_line_content": "    free_edges_.pop_back();",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": "DebugString",
          "new_api": "insert",
          "old_text": "e->dst_->DebugString()",
          "new_text": "source->out_edges_.insert(e)",
          "old_line_content": "  TF_DCHECK_OK(IsValidNode(e->dst_)) << e->dst_->DebugString();",
          "new_line_content": "  CHECK(source->out_edges_.insert(e).second);",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": "erase",
          "new_api": "insert",
          "old_text": "e->src_->out_edges_.erase(e)",
          "new_text": "dest->in_edges_.insert(e)",
          "old_line_content": "  CHECK_EQ(e->src_->out_edges_.erase(e), size_t{1});",
          "new_line_content": "  CHECK(dest->in_edges_.insert(e).second);",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": "erase",
          "new_api": "push_back",
          "old_text": "e->dst_->in_edges_.erase(e)",
          "new_text": "edges_.push_back(e)",
          "old_line_content": "  CHECK_EQ(e->dst_->in_edges_.erase(e), size_t{1});",
          "new_line_content": "  edges_.push_back(e);",
          "content_same": false
        },
        {
          "line": 518,
          "old_api": "const_cast<Edge*>(e)",
          "new_api": "CHECK_EQ",
          "old_text": "const_cast<Edge*>(e)",
          "new_text": "CHECK_EQ(e, edges_[e->id_])",
          "old_line_content": "  free_edges_.push_back(const_cast<Edge*>(e));",
          "new_line_content": "  CHECK_EQ(e, edges_[e->id_]);",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": "name",
          "new_api": "src",
          "old_text": "source->name()",
          "new_text": "edge->src()",
          "old_line_content": "    const string new_input = strings::StrCat(\"^\", source->name());",
          "new_line_content": "      if (edge->IsControlEdge() && edge->src() == source) {",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": "MaybeCopyOnWrite",
          "new_api": "name",
          "old_text": "dest->MaybeCopyOnWrite()",
          "new_text": "source->name()",
          "old_line_content": "      dest->MaybeCopyOnWrite();",
          "new_line_content": "    const string new_input = strings::StrCat(\"^\", source->name());",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": "name",
          "new_api": "add_input",
          "old_text": "e->src_->name()",
          "new_text": "dest->props_->node_def.add_input(new_input)",
          "old_line_content": "    string e_src_name = strings::StrCat(\"^\", e->src_->name());",
          "new_line_content": "      dest->props_->node_def.add_input(new_input);",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": "RemoveEdge",
          "new_api": "name",
          "old_text": "RemoveEdge(e)",
          "new_text": "e->src_->name()",
          "old_line_content": "  RemoveEdge(e);",
          "new_line_content": "    string e_src_name = strings::StrCat(\"^\", e->src_->name());",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": "IsValidOutputTensor",
          "new_api": "in_edges",
          "old_text": "IsValidOutputTensor(new_src, new_src_index)",
          "new_text": "dst->in_edges()",
          "old_line_content": "  TF_RETURN_IF_ERROR(IsValidOutputTensor(new_src, new_src_index));",
          "new_line_content": "  for (const Edge* e : dst->in_edges()) {",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": "IsValidInputTensor",
          "new_api": "dst_input",
          "old_text": "IsValidInputTensor(dst, dst_index)",
          "new_text": "e->dst_input()",
          "old_line_content": "  TF_RETURN_IF_ERROR(IsValidInputTensor(dst, dst_index));",
          "new_line_content": "    if (e->dst_input() == index) return e;",
          "content_same": false
        },
        {
          "line": 585,
          "old_api": "MaybeCopyOnWrite",
          "new_api": "IsValidOutputTensor",
          "old_text": "dst->MaybeCopyOnWrite()",
          "new_text": "IsValidOutputTensor(new_src, new_src_index)",
          "old_line_content": "  dst->MaybeCopyOnWrite();",
          "new_line_content": "  TF_RETURN_IF_ERROR(IsValidOutputTensor(new_src, new_src_index));",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": "mutable_input",
          "new_api": "IsValidInputTensor",
          "old_text": "dst->props_->node_def.mutable_input()",
          "new_text": "IsValidInputTensor(dst, dst_index)",
          "old_line_content": "  (*dst->props_->node_def.mutable_input())[dst_index] =",
          "new_line_content": "  TF_RETURN_IF_ERROR(IsValidInputTensor(dst, dst_index));",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": "name",
          "new_api": "FindEdge",
          "old_text": "new_src->name()",
          "new_text": "FindEdge(dst, dst_index)",
          "old_line_content": "      strings::StrCat(new_src->name(), \":\", new_src_index);",
          "new_line_content": "  const Edge* e = FindEdge(dst, dst_index);",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": "IsWhileNode",
          "new_api": "RemoveEdge",
          "old_text": "dst->IsWhileNode()",
          "new_text": "RemoveEdge(e)",
          "old_line_content": "  if (!dst->IsWhileNode()) {",
          "new_line_content": "  RemoveEdge(e);",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": "DebugString",
          "new_api": "AddEdge",
          "old_text": "errors::Internal(\n        \"dst argument to AddWhileEdgeHack should be a While op, got: \",\n        dst->DebugString())",
          "new_text": "AddEdge(new_src, new_src_index, dst, dst_index)",
          "old_line_content": "    return errors::Internal(",
          "new_line_content": "  AddEdge(new_src, new_src_index, dst, dst_index);",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "DebugString",
          "new_api": "mutable_input",
          "old_text": "dst->DebugString()",
          "new_text": "dst->props_->node_def.mutable_input()",
          "old_line_content": "        dst->DebugString());",
          "new_line_content": "  (*dst->props_->node_def.mutable_input())[dst_index] =",
          "content_same": false
        },
        {
          "line": 597,
          "old_api": "IsValidOutputTensor",
          "new_api": "Status::OK()",
          "old_text": "IsValidOutputTensor(new_src, new_src_index)",
          "new_text": "Status::OK()",
          "old_line_content": "  TF_RETURN_IF_ERROR(IsValidOutputTensor(new_src, new_src_index));",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": "in_edges",
          "new_api": "IsWhileNode",
          "old_text": "dst->in_edges()",
          "new_text": "dst->IsWhileNode()",
          "old_line_content": "  for (const Edge* edge : dst->in_edges()) {",
          "new_line_content": "  if (!dst->IsWhileNode()) {",
          "content_same": false
        },
        {
          "line": 602,
          "old_api": "IsControlEdge",
          "new_api": "DebugString",
          "old_text": "edge->IsControlEdge()",
          "new_text": "errors::Internal(\n        \"dst argument to AddWhileEdgeHack should be a While op, got: \",\n        dst->DebugString())",
          "old_line_content": "    if (edge->IsControlEdge()) continue;",
          "new_line_content": "    return errors::Internal(",
          "content_same": false
        },
        {
          "line": 606,
          "old_api": "AddEdge",
          "new_api": "IsValidOutputTensor",
          "old_text": "AddEdge(new_src, new_src_index, dst, dst_index)",
          "new_text": "IsValidOutputTensor(new_src, new_src_index)",
          "old_line_content": "  AddEdge(new_src, new_src_index, dst, dst_index);",
          "new_line_content": "  TF_RETURN_IF_ERROR(IsValidOutputTensor(new_src, new_src_index));",
          "content_same": false
        },
        {
          "line": 610,
          "old_api": "Status::OK()",
          "new_api": "in_edges",
          "old_text": "Status::OK()",
          "new_text": "dst->in_edges()",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  for (const Edge* edge : dst->in_edges()) {",
          "content_same": false
        },
        {
          "line": 615,
          "old_api": "min_consumer",
          "new_api": "AddEdge",
          "old_text": "versions_->min_consumer()",
          "new_text": "AddEdge(new_src, new_src_index, dst, dst_index)",
          "old_line_content": "  if (fdef_lib.function_size() > 0 && versions_->min_consumer() < 12) {",
          "new_line_content": "  AddEdge(new_src, new_src_index, dst, dst_index);",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": "set_min_consumer",
          "new_api": "MaybeCopyOnWrite",
          "old_text": "versions_->set_min_consumer(12)",
          "new_text": "dst->MaybeCopyOnWrite()",
          "old_line_content": "    versions_->set_min_consumer(12);",
          "new_line_content": "  dst->MaybeCopyOnWrite();",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": "AddLibrary",
          "new_api": "name",
          "old_text": "ops_.AddLibrary(fdef_lib)",
          "new_text": "new_src->name()",
          "old_line_content": "  return ops_.AddLibrary(fdef_lib);",
          "new_line_content": "      strings::StrCat(new_src->name(), \":\", new_src_index));",
          "content_same": false
        },
        {
          "line": 625,
          "old_api": "strings::StrCat(\"^\", src_name)",
          "new_api": "set_min_consumer",
          "old_text": "strings::StrCat(\"^\", src_name)",
          "new_text": "versions_->set_min_consumer(12)",
          "old_line_content": "    dst->add_input(strings::StrCat(\"^\", src_name));",
          "new_line_content": "    versions_->set_min_consumer(12);",
          "content_same": false
        },
        {
          "line": 627,
          "old_api": "size",
          "new_api": "AddLibrary",
          "old_text": "src_name.size()",
          "new_text": "ops_.AddLibrary(fdef_lib)",
          "old_line_content": "    dst->add_input(src_name.data(), src_name.size());",
          "new_line_content": "  return ops_.AddLibrary(fdef_lib);",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": "ToGraphDefSubRange",
          "new_api": "size",
          "old_text": "ToGraphDefSubRange(graph_def, 0)",
          "new_text": "src_name.size()",
          "old_line_content": "  ToGraphDefSubRange(graph_def, 0);",
          "new_line_content": "    dst->add_input(src_name.data(), src_name.size());",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": "num_nodes",
          "new_api": "ToGraphDef",
          "old_text": "num_nodes()",
          "new_text": "ToGraphDef(&ret)",
          "old_line_content": "  graph_def->mutable_node()->Reserve(std::max(1, num_nodes() - from_node_id));",
          "new_line_content": "  ToGraphDef(&ret);",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": "FindNodeId",
          "new_api": "Clear",
          "old_text": "FindNodeId(id)",
          "new_text": "graph_def->Clear()",
          "old_line_content": "    const Node* node = FindNodeId(id);",
          "new_line_content": "  graph_def->Clear();",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": "IsOp",
          "new_api": "versions",
          "old_text": "node->IsOp()",
          "new_text": "versions()",
          "old_line_content": "    if (node == nullptr || !node->IsOp()) continue;",
          "new_line_content": "  *graph_def->mutable_versions() = versions();",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": "add_node",
          "new_api": "ToProto",
          "old_text": "graph_def->add_node()",
          "new_text": "ops_.ToProto()",
          "old_line_content": "    NodeDef* node_def = graph_def->add_node();",
          "new_line_content": "  *graph_def->mutable_library() = ops_.ToProto();",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": "assigned_device_name",
          "new_api": "num_node_ids",
          "old_text": "node->assigned_device_name()",
          "new_text": "num_node_ids()",
          "old_line_content": "      node_def->set_device(node->assigned_device_name());",
          "new_line_content": "  for (auto id = from_node_id; id < num_node_ids(); ++id) {",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": "IsControlEdge",
          "new_api": "empty",
          "old_text": "edge->IsControlEdge()",
          "new_text": "node->assigned_device_name().empty()",
          "old_line_content": "      if (edge->IsControlEdge()) {",
          "new_line_content": "    if (!node->assigned_device_name().empty()) {",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": "push_back",
          "new_api": "assigned_device_name",
          "old_text": "inputs.push_back(edge)",
          "new_text": "node->assigned_device_name()",
          "old_line_content": "        inputs.push_back(edge);",
          "new_line_content": "      node_def->set_device(node->assigned_device_name());",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": "DebugString",
          "new_api": "clear",
          "old_text": "node->DebugString()",
          "new_text": "inputs.clear()",
          "old_line_content": "            << node->num_inputs() << \") for node \" << node->DebugString();",
          "new_line_content": "    inputs.clear();",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": "dst_input",
          "new_api": "num_inputs",
          "old_text": "edge->dst_input()",
          "new_text": "node->num_inputs()",
          "old_line_content": "        CHECK(inputs[edge->dst_input()] == nullptr)",
          "new_line_content": "    inputs.resize(node->num_inputs(), nullptr);",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": "dst",
          "new_api": "in_edges",
          "old_text": "edge->dst()->name()",
          "new_text": "node->in_edges()",
          "old_line_content": "            << \"Edge \" << edge->src()->name() << \"->\" << edge->dst()->name()",
          "new_line_content": "    for (const Edge* edge : node->in_edges()) {",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": "dst_input",
          "new_api": "push_back",
          "old_text": "edge->dst_input()",
          "new_text": "inputs.push_back(edge)",
          "old_line_content": "            << inputs[edge->dst_input()]->src()->name() << \"->\"",
          "new_line_content": "        inputs.push_back(edge);",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": "dst_input",
          "new_api": "DebugString",
          "old_text": "edge->dst_input()",
          "new_text": "edge->DebugString()",
          "old_line_content": "        inputs[edge->dst_input()] = edge;",
          "new_line_content": "            << \"Edge \" << edge->DebugString()",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": "end",
          "new_api": "dst",
          "old_text": "inputs.end()",
          "new_text": "edge->dst()->name()",
          "old_line_content": "    std::sort(inputs.begin() + node->num_inputs(), inputs.end(),",
          "new_line_content": "            << \"Edge \" << edge->src()->name() << \"->\" << edge->dst()->name()",
          "content_same": false
        },
        {
          "line": 690,
          "old_api": "src",
          "new_api": "dst_input",
          "old_text": "b->src()->name()",
          "new_text": "edge->dst_input()",
          "old_line_content": "                return a->src()->name() < b->src()->name();",
          "new_line_content": "            << inputs[edge->dst_input()]->src()->name() << \"->\"",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": "size",
          "new_api": "dst_input",
          "old_text": "inputs.size()",
          "new_text": "edge->dst_input()",
          "old_line_content": "    node_def->mutable_input()->Reserve(inputs.size());",
          "new_line_content": "        inputs[edge->dst_input()] = edge;",
          "content_same": false
        },
        {
          "line": 699,
          "old_api": "requested_inputs",
          "new_api": "src",
          "old_text": "node->requested_inputs()",
          "new_text": "b->src()->name()",
          "old_line_content": "          node_def->add_input(node->requested_inputs()[i]);",
          "new_line_content": "                return a->src()->name() < b->src()->name();",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": "add_input",
          "new_api": "clear_input",
          "old_text": "node_def->add_input(\"\")",
          "new_text": "node_def->clear_input()",
          "old_line_content": "          node_def->add_input(\"\");",
          "new_line_content": "    node_def->clear_input();",
          "content_same": false
        },
        {
          "line": 704,
          "old_api": "src",
          "new_api": "size",
          "old_text": "edge->src()",
          "new_text": "inputs.size()",
          "old_line_content": "        const Node* src = edge->src();",
          "new_line_content": "    for (size_t i = 0; i < inputs.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": "strings::StrCat(prefix, \"/_\", name_counter_++)",
          "new_api": "src",
          "old_text": "strings::StrCat(prefix, \"/_\", name_counter_++)",
          "new_text": "edge->src()",
          "old_line_content": "  return strings::StrCat(prefix, \"/_\", name_counter_++);",
          "new_line_content": "        const Node* src = edge->src();",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": "errors::InvalidArgument(\"node id \", id, \" is less than zero\")",
          "new_api": "strings::StrCat(prefix, \"/_\", name_counter_++)",
          "old_text": "errors::InvalidArgument(\"node id \", id, \" is less than zero\")",
          "new_text": "strings::StrCat(prefix, \"/_\", name_counter_++)",
          "old_line_content": "    return errors::InvalidArgument(\"node id \", id, \" is less than zero\");",
          "new_line_content": "  return strings::StrCat(prefix, \"/_\", name_counter_++);",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": "errors::InvalidArgument(\"Node with id \", id,\n                                   \" is different from the passed in node. \"\n                                   \"Does it belong to a different graph?\")",
          "new_api": "id",
          "old_text": "errors::InvalidArgument(\"Node with id \", id,\n                                   \" is different from the passed in node. \"\n                                   \"Does it belong to a different graph?\")",
          "new_text": "node->id()",
          "old_line_content": "    return errors::InvalidArgument(\"Node with id \", id,",
          "new_line_content": "  const int id = node->id();",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": "Status::OK()",
          "new_api": "size",
          "old_text": "Status::OK()",
          "new_text": "nodes_.size()",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  if (static_cast<size_t>(id) >= nodes_.size()) {",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": "num_outputs",
          "new_api": "errors::InvalidArgument(\"Node with id \", id,\n                                   \" is different from the passed in node. \"\n                                   \"Does it belong to a different graph?\")",
          "old_text": "node->num_outputs()",
          "new_text": "errors::InvalidArgument(\"Node with id \", id,\n                                   \" is different from the passed in node. \"\n                                   \"Does it belong to a different graph?\")",
          "old_line_content": "  if (idx >= node->num_outputs() || idx < 0) {",
          "new_line_content": "    return errors::InvalidArgument(\"Node with id \", id,",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": "IsValidNode",
          "new_api": "name",
          "old_text": "IsValidNode(node)",
          "new_text": "node->name()",
          "old_line_content": "  TF_RETURN_IF_ERROR(IsValidNode(node));",
          "new_line_content": "    return errors::OutOfRange(\"Node '\", node->name(), \"' (type: '\",",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": "num_inputs",
          "new_api": "name",
          "old_text": "node->num_inputs()",
          "new_text": "node->op_def().name()",
          "old_line_content": "  if (idx >= node->num_inputs() || idx < 0) {",
          "new_line_content": "                              node->op_def().name(),",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": "name",
          "new_api": "num_outputs",
          "old_text": "node->name()",
          "new_text": "node->num_outputs()",
          "old_line_content": "    return errors::OutOfRange(\"Node '\", node->name(), \"' (type: '\",",
          "new_line_content": "                              \"', num of outputs: \", node->num_outputs(),",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": "empty",
          "new_api": "num_inputs",
          "old_text": "free_nodes_.empty()",
          "new_text": "node->num_inputs()",
          "old_line_content": "  if (free_nodes_.empty()) {",
          "new_line_content": "                              \"', num of inputs: \", node->num_inputs(),",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": "back",
          "new_api": "Status::OK()",
          "old_text": "free_nodes_.back()",
          "new_text": "Status::OK()",
          "old_line_content": "    node = free_nodes_.back();",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": "std::move(props)",
          "new_api": "empty",
          "old_text": "std::move(props)",
          "new_text": "free_nodes_.empty()",
          "old_line_content": "  node->Initialize(id, cost_id, std::move(props), node_class);",
          "new_line_content": "  if (free_nodes_.empty()) {",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": "push_back",
          "new_api": "Alloc",
          "old_text": "nodes_.push_back(node)",
          "new_text": "arena_.Alloc(sizeof(Node))",
          "old_line_content": "  nodes_.push_back(node);",
          "new_line_content": "    node = new (arena_.Alloc(sizeof(Node))) Node;  // placement new",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": "DebugString",
          "new_api": "size",
          "old_text": "node->DebugString()",
          "new_text": "nodes_.size()",
          "old_line_content": "  TF_DCHECK_OK(IsValidNode(node)) << node->DebugString();",
          "new_line_content": "  const int id = nodes_.size();",
          "content_same": false
        },
        {
          "line": 778,
          "old_api": "id",
          "new_api": "cost_id",
          "old_text": "node->id()",
          "new_text": "cost_node->cost_id()",
          "old_line_content": "  nodes_[node->id()] = nullptr;",
          "new_line_content": "  int cost_id = cost_node ? cost_node->cost_id() : id;",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": "push_back",
          "new_api": "std::move(props)",
          "old_text": "free_nodes_.push_back(node)",
          "new_text": "std::move(props)",
          "old_line_content": "  free_nodes_.push_back(node);",
          "new_line_content": "  node->Initialize(id, cost_id, std::move(props), node_class);",
          "content_same": false
        },
        {
          "line": 800,
          "old_api": "size",
          "new_api": "empty",
          "old_text": "device_names_map_.size()",
          "new_text": "device_name.empty()",
          "old_line_content": "  const int index = device_names_map_.size();",
          "new_line_content": "  if (device_name.empty()) {",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": "Status::OK()",
          "new_api": "std::move(exit_nodes)",
          "old_text": "Status::OK()",
          "new_text": "std::move(exit_nodes)",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "      WhileContext(frame_name, std::move(enter_nodes), std::move(exit_nodes),",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "nodes",
          "new_api": "errors::InvalidArgument(\"WhileContext with frame name '\", frame_name,\n                                   \"' already exists\")",
          "old_text": "nodes()",
          "new_text": "errors::InvalidArgument(\"WhileContext with frame name '\", frame_name,\n                                   \"' already exists\")",
          "old_line_content": "  for (Node* n : nodes()) {",
          "new_line_content": "    return errors::InvalidArgument(\"WhileContext with frame name '\", frame_name,",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 514,
          "old_api": null,
          "new_api": "DebugString",
          "old_text": null,
          "new_text": "e->src_->DebugString()",
          "old_line_content": "  --num_edges_;",
          "new_line_content": "  TF_DCHECK_OK(IsValidNode(e->src_)) << e->src_->DebugString();",
          "content_same": false
        },
        {
          "line": 515,
          "old_api": null,
          "new_api": "DebugString",
          "old_text": null,
          "new_text": "e->dst_->DebugString()",
          "old_line_content": "}",
          "new_line_content": "  TF_DCHECK_OK(IsValidNode(e->dst_)) << e->dst_->DebugString();",
          "content_same": false
        },
        {
          "line": 516,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "e->src_->out_edges_.erase(e)",
          "old_line_content": "",
          "new_line_content": "  CHECK_EQ(e->src_->out_edges_.erase(e), size_t{1});",
          "content_same": false
        },
        {
          "line": 517,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "e->dst_->in_edges_.erase(e)",
          "old_line_content": "void Graph::RecycleEdge(const Edge* e) {",
          "new_line_content": "  CHECK_EQ(e->dst_->in_edges_.erase(e), size_t{1});",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": null,
          "new_api": "CHECK_GT",
          "old_text": null,
          "new_text": "CHECK_GT(num_edges_, 0)",
          "old_line_content": "}",
          "new_line_content": "  CHECK_GT(num_edges_, 0);",
          "content_same": false
        },
        {
          "line": 522,
          "old_api": null,
          "new_api": "RecycleEdge",
          "old_text": null,
          "new_text": "RecycleEdge(e)",
          "old_line_content": "                                  bool allow_duplicates) {",
          "new_line_content": "  RecycleEdge(e);",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": null,
          "new_api": "const_cast<Edge*>(e)",
          "old_text": null,
          "new_text": "const_cast<Edge*>(e)",
          "old_line_content": "        return nullptr;",
          "new_line_content": "  free_edges_.push_back(const_cast<Edge*>(e));",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": null,
          "new_api": "in_edges",
          "old_text": null,
          "new_text": "dest->in_edges()",
          "old_line_content": "    // Check if this input is already in dest's NodeDef.",
          "new_line_content": "    for (const Edge* edge : dest->in_edges()) {",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": null,
          "new_api": "IsSink",
          "old_text": null,
          "new_text": "dest->IsSink()",
          "old_line_content": "    }",
          "new_line_content": "  if (!source->IsSource() && !dest->IsSink() && !allow_duplicates) {",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": null,
          "new_api": "input",
          "old_text": null,
          "new_text": "dest->props_->node_def.input()",
          "old_line_content": "    }",
          "new_line_content": "    for (const string& input : dest->props_->node_def.input()) {",
          "content_same": false
        },
        {
          "line": 556,
          "old_api": null,
          "new_api": "AddEdge",
          "old_text": null,
          "new_text": "AddEdge(source, kControlSlot, dest, kControlSlot)",
          "old_line_content": "      if (*it == e_src_name) {",
          "new_line_content": "  return AddEdge(source, kControlSlot, dest, kControlSlot);",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": null,
          "new_api": "IsSink",
          "old_text": null,
          "new_text": "e->dst_->IsSink()",
          "old_line_content": "    }",
          "new_line_content": "  if (!e->src_->IsSource() && !e->dst_->IsSink()) {",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": null,
          "new_api": "MaybeCopyOnWrite",
          "old_text": null,
          "new_text": "e->dst_->MaybeCopyOnWrite()",
          "old_line_content": "  }",
          "new_line_content": "    e->dst_->MaybeCopyOnWrite();",
          "content_same": false
        },
        {
          "line": 563,
          "old_api": null,
          "new_api": "mutable_input",
          "old_text": null,
          "new_text": "e->dst_->props_->node_def.mutable_input()",
          "old_line_content": "}",
          "new_line_content": "    auto* inputs = e->dst_->props_->node_def.mutable_input();",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "inputs->end()",
          "old_line_content": "",
          "new_line_content": "    for (auto it = inputs->begin(); it != inputs->end(); ++it) {",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "inputs->erase(it)",
          "old_line_content": "const Edge* FindEdge(const Node* dst, int index) {",
          "new_line_content": "        inputs->erase(it);",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": null,
          "new_api": "RemoveEdge",
          "old_text": null,
          "new_text": "RemoveEdge(e)",
          "old_line_content": "}",
          "new_line_content": "  RemoveEdge(e);",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": null,
          "new_api": "errors::InvalidArgument(\"Couldn't find edge to \",\n                                   FormatNodeForError(*dst))",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\"Couldn't find edge to \",\n                                   FormatNodeForError(*dst))",
          "old_line_content": "}",
          "new_line_content": "    return errors::InvalidArgument(\"Couldn't find edge to \",",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": null,
          "new_api": "FormatNodeForError",
          "old_text": null,
          "new_text": "FormatNodeForError(*dst)",
          "old_line_content": "",
          "new_line_content": "                                   FormatNodeForError(*dst));",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": null,
          "new_api": "MaybeCopyOnWrite",
          "old_text": null,
          "new_text": "dst->MaybeCopyOnWrite()",
          "old_line_content": "        \"dst argument to AddWhileEdgeHack should be a While op, got: \",",
          "new_line_content": "  dst->MaybeCopyOnWrite();",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "new_src->name()",
          "old_line_content": "  }",
          "new_line_content": "      strings::StrCat(new_src->name(), \":\", new_src_index);",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": null,
          "new_api": "DebugString",
          "old_text": null,
          "new_text": "dst->DebugString()",
          "old_line_content": "  }",
          "new_line_content": "        dst->DebugString());",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": null,
          "new_api": "IsControlEdge",
          "old_text": null,
          "new_text": "edge->IsControlEdge()",
          "old_line_content": "}",
          "new_line_content": "    if (edge->IsControlEdge()) continue;",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": null,
          "new_api": "IsValidInputTensor",
          "old_text": null,
          "new_text": "IsValidInputTensor(dst, dst_index)",
          "old_line_content": "  // Need a new-enough consumer to support the functions we add to the graph.",
          "new_line_content": "  TF_RETURN_IF_ERROR(IsValidInputTensor(dst, dst_index));",
          "content_same": false
        },
        {
          "line": 617,
          "old_api": null,
          "new_api": "add_input",
          "old_text": null,
          "new_text": "dst->props_->node_def.add_input(\n      strings::StrCat(new_src->name(), \":\", new_src_index))",
          "old_line_content": "  }",
          "new_line_content": "  dst->props_->node_def.add_input(",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "}",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": null,
          "new_api": "min_consumer",
          "old_text": null,
          "new_text": "versions_->min_consumer()",
          "old_line_content": "  if (src_slot == Graph::kControlSlot) {",
          "new_line_content": "  if (fdef_lib.function_size() > 0 && versions_->min_consumer() < 12) {",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": null,
          "new_api": "strings::StrCat(\"^\", src_name)",
          "old_text": null,
          "new_text": "strings::StrCat(\"^\", src_name)",
          "old_line_content": "",
          "new_line_content": "    dst->add_input(strings::StrCat(\"^\", src_name));",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": null,
          "new_api": "strings::StrCat(src_name, \":\", src_slot)",
          "old_text": null,
          "new_text": "strings::StrCat(src_name, \":\", src_slot)",
          "old_line_content": "",
          "new_line_content": "    dst->add_input(strings::StrCat(src_name, \":\", src_slot));",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": null,
          "new_api": "ToGraphDefSubRange",
          "old_text": null,
          "new_text": "ToGraphDefSubRange(graph_def, 0)",
          "old_line_content": "void Graph::ToGraphDefSubRange(GraphDef* graph_def, int from_node_id) const {",
          "new_line_content": "  ToGraphDefSubRange(graph_def, 0);",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": null,
          "new_api": "num_nodes",
          "old_text": null,
          "new_text": "num_nodes()",
          "old_line_content": "",
          "new_line_content": "  graph_def->mutable_node()->Reserve(std::max(1, num_nodes() - from_node_id));",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "FindNodeId",
          "old_text": null,
          "new_text": "FindNodeId(id)",
          "old_line_content": "    }",
          "new_line_content": "    const Node* node = FindNodeId(id);",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": null,
          "new_api": "IsOp",
          "old_text": null,
          "new_text": "node->IsOp()",
          "old_line_content": "",
          "new_line_content": "    if (node == nullptr || !node->IsOp()) continue;",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": null,
          "new_api": "add_node",
          "old_text": null,
          "new_text": "graph_def->add_node()",
          "old_line_content": "    // Get the inputs for this Node.  We make sure control inputs are",
          "new_line_content": "    NodeDef* node_def = graph_def->add_node();",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": null,
          "new_api": "def",
          "old_text": null,
          "new_text": "node->def()",
          "old_line_content": "    // after data inputs, as required by GraphDef.",
          "new_line_content": "    *node_def = node->def();",
          "content_same": false
        },
        {
          "line": 160,
          "old_api": null,
          "new_api": "use_count",
          "old_text": null,
          "new_text": "props_.use_count()",
          "old_line_content": "                                            inputs, outputs);",
          "new_line_content": "    if (TF_PREDICT_TRUE(props_.use_count() == 1)) {",
          "content_same": false
        },
        {
          "line": 166,
          "old_api": null,
          "new_api": "std::make_shared<NodeProperties>(\n          props_->op_def, std::move(props_->node_def), inputs, outputs)",
          "old_text": null,
          "new_text": "std::make_shared<NodeProperties>(\n          props_->op_def, std::move(props_->node_def), inputs, outputs)",
          "old_line_content": "const OpDef& Node::op_def() const { return *props_->op_def; }",
          "new_line_content": "      props_ = std::make_shared<NodeProperties>(",
          "content_same": false
        },
        {
          "line": 167,
          "old_api": null,
          "new_api": "std::move(props_->node_def)",
          "old_text": null,
          "new_text": "std::move(props_->node_def)",
          "old_line_content": "",
          "new_line_content": "          props_->op_def, std::move(props_->node_def), inputs, outputs);",
          "content_same": false
        },
        {
          "line": 680,
          "old_api": null,
          "new_api": "IsControlEdge",
          "old_text": null,
          "new_text": "edge->IsControlEdge()",
          "old_line_content": "            << \" conflicts with pre-existing input edge \"",
          "new_line_content": "      if (edge->IsControlEdge()) {",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "inputs.size()",
          "old_line_content": "",
          "new_line_content": "        DCHECK(edge->dst_input() < inputs.size())",
          "content_same": false
        },
        {
          "line": 173,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "props_->node_def.op()",
          "old_line_content": "DataType Node::output_type(int32 o) const { return props_->output_types[o]; }",
          "new_line_content": "const string& Node::type_string() const { return props_->node_def.op(); }",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": null,
          "new_api": "DebugString",
          "old_text": null,
          "new_text": "node->DebugString()",
          "old_line_content": "    }",
          "new_line_content": "            << node->num_inputs() << \") for node \" << node->DebugString();",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": null,
          "new_api": "dst_input",
          "old_text": null,
          "new_text": "edge->dst_input()",
          "old_line_content": "    // Sort the control inputs for more predictable serialization.",
          "new_line_content": "        CHECK(inputs[edge->dst_input()] == nullptr)",
          "content_same": false
        },
        {
          "line": 177,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "props_->input_types.size()",
          "old_line_content": "",
          "new_line_content": "int32 Node::num_inputs() const { return props_->input_types.size(); }",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": null,
          "new_api": "dst_input",
          "old_text": null,
          "new_text": "edge->dst_input()",
          "old_line_content": "              });",
          "new_line_content": "            << inputs[edge->dst_input()]->dst()->name();",
          "content_same": false
        },
        {
          "line": 697,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "inputs.end()",
          "old_line_content": "      if (edge == nullptr) {",
          "new_line_content": "    std::sort(inputs.begin() + node->num_inputs(), inputs.end(),",
          "content_same": false
        },
        {
          "line": 190,
          "old_api": null,
          "new_api": "input",
          "old_text": null,
          "new_text": "def().input()",
          "old_line_content": "",
          "new_line_content": "  return def().input();",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "inputs.size()",
          "old_line_content": "        }",
          "new_line_content": "    node_def->mutable_input()->Reserve(inputs.size());",
          "content_same": false
        },
        {
          "line": 707,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "node->requested_inputs().size()",
          "old_line_content": "      }",
          "new_line_content": "        if (i < node->requested_inputs().size()) {",
          "content_same": false
        },
        {
          "line": 196,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "out_edges_.begin()",
          "old_line_content": "void Node::MaybeCopyOnWrite() {",
          "new_line_content": "  return gtl::make_range(NeighborIter(out_edges_.begin(), false),",
          "content_same": false
        },
        {
          "line": 197,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "out_edges_.end()",
          "old_line_content": "  // NodeProperties may be shared between Nodes. Make a copy if so.",
          "new_line_content": "                         NeighborIter(out_edges_.end(), false));",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": null,
          "new_api": "requested_inputs",
          "old_text": null,
          "new_text": "node->requested_inputs()",
          "old_line_content": "    }",
          "new_line_content": "          node_def->add_input(node->requested_inputs()[i]);",
          "content_same": false
        },
        {
          "line": 710,
          "old_api": null,
          "new_api": "add_input",
          "old_text": null,
          "new_text": "node_def->add_input(\"\")",
          "old_line_content": "}",
          "new_line_content": "          node_def->add_input(\"\");",
          "content_same": false
        },
        {
          "line": 201,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "in_edges_.begin()",
          "old_line_content": "}",
          "new_line_content": "  return gtl::make_range(NeighborIter(in_edges_.begin(), true),",
          "content_same": false
        },
        {
          "line": 202,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "in_edges_.end()",
          "old_line_content": "",
          "new_line_content": "                         NeighborIter(in_edges_.end(), true));",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": null,
          "new_api": "IsOp",
          "old_text": null,
          "new_text": "src->IsOp()",
          "old_line_content": "}",
          "new_line_content": "        if (!src->IsOp()) continue;",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": null,
          "new_api": "src_output",
          "old_text": null,
          "new_text": "edge->src_output()",
          "old_line_content": "",
          "new_line_content": "        AddInput(node_def, src->name(), edge->src_output());",
          "content_same": false
        },
        {
          "line": 207,
          "old_api": null,
          "new_api": "unique",
          "old_text": null,
          "new_text": "props_.unique()",
          "old_line_content": "",
          "new_line_content": "  if (!props_.unique()) {",
          "content_same": false
        },
        {
          "line": 208,
          "old_api": null,
          "new_api": "std::make_shared<NodeProperties>(*props_)",
          "old_text": null,
          "new_text": "std::make_shared<NodeProperties>(*props_)",
          "old_line_content": "void Node::ClearAttr(const string& name) {",
          "new_line_content": "    props_ = std::make_shared<NodeProperties>(*props_);",
          "content_same": false
        },
        {
          "line": 213,
          "old_api": null,
          "new_api": "MaybeCopyOnWrite",
          "old_text": null,
          "new_text": "MaybeCopyOnWrite()",
          "old_line_content": "void Node::set_name(string name) {",
          "new_line_content": "  MaybeCopyOnWrite();",
          "content_same": false
        },
        {
          "line": 727,
          "old_api": null,
          "new_api": "errors::InvalidArgument(\"Node is null\")",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\"Node is null\")",
          "old_line_content": "  }",
          "new_line_content": "    return errors::InvalidArgument(\"Node is null\");",
          "content_same": false
        },
        {
          "line": 218,
          "old_api": null,
          "new_api": "MaybeCopyOnWrite",
          "old_text": null,
          "new_text": "MaybeCopyOnWrite()",
          "old_line_content": "void Node::set_requested_device(const string& device) {",
          "new_line_content": "  MaybeCopyOnWrite();",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": null,
          "new_api": "errors::InvalidArgument(\"node id \", id, \" is less than zero\")",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\"node id \", id, \" is less than zero\")",
          "old_line_content": "                                   \"Does it belong to a different graph?\");",
          "new_line_content": "    return errors::InvalidArgument(\"node id \", id, \" is less than zero\");",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\n        \"node id \", id, \" is >= than number of nodes in graph \", nodes_.size())",
          "old_line_content": "}",
          "new_line_content": "    return errors::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": null,
          "new_api": "MaybeCopyOnWrite",
          "old_text": null,
          "new_text": "MaybeCopyOnWrite()",
          "old_line_content": "void Node::set_original_node_names(const std::vector<string>& names) {",
          "new_line_content": "  MaybeCopyOnWrite();",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "nodes_.size()",
          "old_line_content": "",
          "new_line_content": "        \"node id \", id, \" is >= than number of nodes in graph \", nodes_.size());",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "                              \") does not have \", \"output \", idx);",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 233,
          "old_api": null,
          "new_api": "MaybeCopyOnWrite",
          "old_text": null,
          "new_text": "MaybeCopyOnWrite()",
          "old_line_content": "Status Node::input_edge(int idx, const Edge** e) const {",
          "new_line_content": "  MaybeCopyOnWrite();",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": null,
          "new_api": "IsValidNode",
          "old_text": null,
          "new_text": "IsValidNode(node)",
          "old_line_content": "",
          "new_line_content": "  TF_RETURN_IF_ERROR(IsValidNode(node));",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": null,
          "new_api": "num_outputs",
          "old_text": null,
          "new_text": "node->num_outputs()",
          "old_line_content": "Status Graph::IsValidInputTensor(const Node* node, int idx) const {",
          "new_line_content": "  if (idx >= node->num_outputs() || idx < 0) {",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": null,
          "new_api": "mutable_experimental_debug_info",
          "old_text": null,
          "new_text": "props_->node_def.mutable_experimental_debug_info()\n         ->mutable_original_node_names()",
          "old_line_content": "                                   \" inputs.\");",
          "new_line_content": "    *props_->node_def.mutable_experimental_debug_info()",
          "content_same": false
        },
        {
          "line": 238,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "names.end()",
          "old_line_content": "  }",
          "new_line_content": "         ->mutable_original_node_names() = {names.begin(), names.end()};",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "                              \") does not have \", \"input \", idx);",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": null,
          "new_api": "num_inputs",
          "old_text": null,
          "new_text": "num_inputs()",
          "old_line_content": "  // optimization where, if the number of edges is small, we use",
          "new_line_content": "  if (idx < 0 || idx >= num_inputs()) {",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": null,
          "new_api": "errors::InvalidArgument(\"Invalid input_edge index: \", idx, \", Node \",\n                                   name(), \" only has \", num_inputs(),\n                                   \" inputs.\")",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\"Invalid input_edge index: \", idx, \", Node \",\n                                   name(), \" only has \", num_inputs(),\n                                   \" inputs.\")",
          "old_line_content": "  // linear iteration, and if the number of edges is large, we perform",
          "new_line_content": "    return errors::InvalidArgument(\"Invalid input_edge index: \", idx, \", Node \",",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": null,
          "new_api": "num_inputs",
          "old_text": null,
          "new_text": "num_inputs()",
          "old_line_content": "  // an indexing step during construction that keeps an array of Edges",
          "new_line_content": "                                   name(), \" only has \", num_inputs(),",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": null,
          "new_api": "IsValidNode",
          "old_text": null,
          "new_text": "IsValidNode(node)",
          "old_line_content": "",
          "new_line_content": "  TF_RETURN_IF_ERROR(IsValidNode(node));",
          "content_same": false
        },
        {
          "line": 758,
          "old_api": null,
          "new_api": "num_inputs",
          "old_text": null,
          "new_text": "node->num_inputs()",
          "old_line_content": "Node* Graph::AllocateNode(std::shared_ptr<NodeProperties> props,",
          "new_line_content": "  if (idx >= node->num_inputs() || idx < 0) {",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "node->name()",
          "old_line_content": "                          const Node* cost_node, Node::NodeClass node_class) {",
          "new_line_content": "    return errors::OutOfRange(\"Node '\", node->name(), \"' (type: '\",",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "node->op_def().name()",
          "old_line_content": "  Node* node = nullptr;",
          "new_line_content": "                              node->op_def().name(),",
          "content_same": false
        },
        {
          "line": 258,
          "old_api": null,
          "new_api": "in_edges",
          "old_text": null,
          "new_text": "in_edges()",
          "old_line_content": "",
          "new_line_content": "  for (const Edge* edge : in_edges()) {",
          "content_same": false
        },
        {
          "line": 259,
          "old_api": null,
          "new_api": "dst_input",
          "old_text": null,
          "new_text": "edge->dst_input()",
          "old_line_content": "// Returns a vector of the non-control input edges to a node, indexed by ID.",
          "new_line_content": "    if (edge->dst_input() == idx) {",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "free_nodes_.back()",
          "old_line_content": "  return node;",
          "new_line_content": "    node = free_nodes_.back();",
          "content_same": false
        },
        {
          "line": 774,
          "old_api": null,
          "new_api": "pop_back",
          "old_text": null,
          "new_text": "free_nodes_.pop_back()",
          "old_line_content": "}",
          "new_line_content": "    free_nodes_.pop_back();",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "nodes_.push_back(node)",
          "old_line_content": "  --num_nodes_;",
          "new_line_content": "  nodes_.push_back(node);",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": null,
          "new_api": "IsControlEdge",
          "old_text": null,
          "new_text": "edge->IsControlEdge()",
          "old_line_content": "  }",
          "new_line_content": "    if (edge->IsControlEdge()) continue;",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": null,
          "new_api": "num_inputs",
          "old_text": null,
          "new_text": "num_inputs()",
          "old_line_content": "",
          "new_line_content": "    if (edge->dst_input() < 0 || edge->dst_input() >= num_inputs()) {",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": null,
          "new_api": "DebugString",
          "old_text": null,
          "new_text": "node->DebugString()",
          "old_line_content": "// calls to Node::set_assigned_device_name_index().",
          "new_line_content": "  TF_DCHECK_OK(IsValidNode(node)) << node->DebugString();",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": null,
          "new_api": "id",
          "old_text": null,
          "new_text": "node->id()",
          "old_line_content": "int Graph::InternDeviceName(const string& device_name) {",
          "new_line_content": "  nodes_[node->id()] = nullptr;",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "free_nodes_.push_back(node)",
          "old_line_content": "  // Special case, very common.  Also, this allows us to use a single map",
          "new_line_content": "  free_nodes_.push_back(node);",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": null,
          "new_api": "dst_input",
          "old_text": null,
          "new_text": "errors::Internal(\"Duplicate edge input number: \",\n                              edge->dst_input())",
          "old_line_content": "    }",
          "new_line_content": "      return errors::Internal(\"Duplicate edge input number: \",",
          "content_same": false
        },
        {
          "line": 280,
          "old_api": null,
          "new_api": "dst_input",
          "old_text": null,
          "new_text": "edge->dst_input()",
          "old_line_content": "  }",
          "new_line_content": "                              edge->dst_input());",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": null,
          "new_api": "Clear",
          "old_text": null,
          "new_text": "node->Clear()",
          "old_line_content": "  // relies on this check.",
          "new_line_content": "  node->Clear();",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": null,
          "new_api": "dst_input",
          "old_text": null,
          "new_text": "edge->dst_input()",
          "old_line_content": "}",
          "new_line_content": "    (*input_edges)[edge->dst_input()] = edge;",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": null,
          "new_api": "num_inputs",
          "old_text": null,
          "new_text": "num_inputs()",
          "old_line_content": "  const Edge* e;",
          "new_line_content": "  for (int i = 0; i < num_inputs(); ++i) {",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": null,
          "new_api": "errors::InvalidArgument(\"Missing edge input number: \", i)",
          "old_text": null,
          "new_text": "errors::InvalidArgument(\"Missing edge input number: \", i)",
          "old_line_content": "  if (e == nullptr) {",
          "new_line_content": "      return errors::InvalidArgument(\"Missing edge input number: \", i);",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": null,
          "new_api": "input_edge",
          "old_text": null,
          "new_text": "input_edge(idx, &e)",
          "old_line_content": "Status Node::input_node(int idx, const Node** const_n) const {",
          "new_line_content": "  TF_RETURN_IF_ERROR(input_edge(idx, &e));",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "device_names_map_.size()",
          "old_line_content": "                              OutputTensor cond_output,",
          "new_line_content": "  const int index = device_names_map_.size();",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "device_names_.push_back(device_name)",
          "old_line_content": "                              std::vector<OutputTensor> body_outputs,",
          "new_line_content": "  device_names_.push_back(device_name);",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 308,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "}",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": null,
          "new_api": "std::pair<string, WhileContext>(\n      string(frame_name),\n      WhileContext(frame_name, std::move(enter_nodes), std::move(exit_nodes),\n                   cond_output, std::move(body_inputs),\n                   std::move(body_outputs)))",
          "old_text": null,
          "new_text": "std::pair<string, WhileContext>(\n      string(frame_name),\n      WhileContext(frame_name, std::move(enter_nodes), std::move(exit_nodes),\n                   cond_output, std::move(body_inputs),\n                   std::move(body_outputs)))",
          "old_line_content": "  }",
          "new_line_content": "  auto pair = while_ctxs_.insert(std::pair<string, WhileContext>(",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": null,
          "new_api": "string",
          "old_text": null,
          "new_text": "string(frame_name)",
          "old_line_content": "  *result = &pair.first->second;",
          "new_line_content": "      string(frame_name),",
          "content_same": false
        },
        {
          "line": 313,
          "old_api": null,
          "new_api": "input_edge",
          "old_text": null,
          "new_text": "input_edge(idx, &e)",
          "old_line_content": "NodeDebugInfo::NodeDebugInfo(const NodeDef& ndef)",
          "new_line_content": "  TF_RETURN_IF_ERROR(input_edge(idx, &e));",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": null,
          "new_api": "std::move(body_inputs)",
          "old_text": null,
          "new_text": "std::move(body_inputs)",
          "old_line_content": "}",
          "new_line_content": "                   cond_output, std::move(body_inputs),",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": null,
          "new_api": "std::move(body_outputs)",
          "old_text": null,
          "new_text": "std::move(body_outputs)",
          "old_line_content": "",
          "new_line_content": "                   std::move(body_outputs))));",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "NodeDebugInfo::NodeDebugInfo(",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "}",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 323,
          "old_api": null,
          "new_api": "has_experimental_debug_info",
          "old_text": null,
          "new_text": "ndef.has_experimental_debug_info()",
          "old_line_content": "  }",
          "new_line_content": "    : NodeDebugInfo(ndef.name(), ndef.has_experimental_debug_info(),",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": null,
          "new_api": "experimental_debug_info",
          "old_text": null,
          "new_text": "ndef.experimental_debug_info()",
          "old_line_content": "}",
          "new_line_content": "                    ndef.experimental_debug_info()) {}",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": null,
          "new_api": "nodes",
          "old_text": null,
          "new_text": "nodes()",
          "old_line_content": "}",
          "new_line_content": "  for (Node* n : nodes()) {",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "n->name()",
          "old_line_content": "",
          "new_line_content": "    result[n->name()] = n;",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": null,
          "new_api": "original_node_names",
          "old_text": null,
          "new_text": "experimental_debug_info.original_node_names()",
          "old_line_content": "}",
          "new_line_content": "    const auto& names = experimental_debug_info.original_node_names();",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "names.end()",
          "old_line_content": "",
          "new_line_content": "    original_node_names.assign(names.begin(), names.end());",
          "content_same": false
        },
        {
          "line": 845,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "src_->name().c_str()",
          "old_line_content": "",
          "new_line_content": "  return strings::Printf(\"[id=%d %s:%d -> %s:%d]\", id_, src_->name().c_str(),",
          "content_same": false
        },
        {
          "line": 846,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "dst_->name().c_str()",
          "old_line_content": "",
          "new_line_content": "                         src_output_, dst_->name().c_str(), dst_input_);",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": null,
          "new_api": "std::hash<const Node*>()(s.node)",
          "old_text": null,
          "new_text": "std::hash<const Node*>()(s.node)",
          "old_line_content": "",
          "new_line_content": "  return Hash64Combine(std::hash<const Node*>()(s.node),",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": null,
          "new_api": "std::hash<int>()(s.index)",
          "old_text": null,
          "new_text": "std::hash<int>()(s.index)",
          "old_line_content": "uint64 OutputTensor::Hash::operator()(OutputTensor const& s) const {",
          "new_line_content": "                       std::hash<int>()(s.index));",
          "content_same": false
        },
        {
          "line": 353,
          "old_api": null,
          "new_api": "std::hash<const Node*>()(s.node)",
          "old_text": null,
          "new_text": "std::hash<const Node*>()(s.node)",
          "old_line_content": "      arena_(8 << 10 /* 8kB */) {",
          "new_line_content": "  return Hash64Combine(std::hash<const Node*>()(s.node),",
          "content_same": false
        },
        {
          "line": 360,
          "old_api": null,
          "new_api": "FunctionDefLibrary",
          "old_text": null,
          "new_text": "FunctionDefLibrary()",
          "old_line_content": "",
          "new_line_content": "    : ops_(ops, FunctionDefLibrary()),",
          "content_same": false
        },
        {
          "line": 376,
          "old_api": null,
          "new_api": "TF_CHECK_OK",
          "old_text": null,
          "new_text": "TF_CHECK_OK(status)",
          "old_line_content": "}",
          "new_line_content": "  TF_CHECK_OK(status);",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": null,
          "new_api": "id",
          "old_text": null,
          "new_text": "source->id()",
          "old_line_content": "",
          "new_line_content": "  CHECK_EQ(source->id(), kSourceId);",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": null,
          "new_api": "AddNode",
          "old_text": null,
          "new_text": "AddNode(def, &status)",
          "old_line_content": "  // Need a new-enough consumer to support the functions we add to the graph.",
          "new_line_content": "  Node* sink = AddNode(def, &status);",
          "content_same": false
        },
        {
          "line": 388,
          "old_api": null,
          "new_api": "default_registry",
          "old_text": null,
          "new_text": "flib_def.default_registry()",
          "old_line_content": "Graph::~Graph() {",
          "new_line_content": "    : Graph(flib_def.default_registry()) {",
          "content_same": false
        },
        {
          "line": 390,
          "old_api": null,
          "new_api": "min_consumer",
          "old_text": null,
          "new_text": "versions_->min_consumer()",
          "old_line_content": "  // placement new.",
          "new_line_content": "  if (flib_def.num_functions() > 0 && versions_->min_consumer() < 12) {",
          "content_same": false
        },
        {
          "line": 391,
          "old_api": null,
          "new_api": "set_min_consumer",
          "old_text": null,
          "new_text": "versions_->set_min_consumer(12)",
          "old_line_content": "  for (Node* node : nodes_) {",
          "new_line_content": "    versions_->set_min_consumer(12);",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": null,
          "new_api": "error_message",
          "old_text": null,
          "new_text": "s.error_message()",
          "old_line_content": "    }",
          "new_line_content": "  CHECK(s.ok()) << s.error_message();",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": null,
          "new_api": "node->~Node()",
          "old_text": null,
          "new_text": "node->~Node()",
          "old_line_content": "",
          "new_line_content": "      node->~Node();",
          "content_same": false
        },
        {
          "line": 406,
          "old_api": null,
          "new_api": "node->~Node()",
          "old_text": null,
          "new_text": "node->~Node()",
          "old_line_content": "Node* Graph::AddNode(NodeDef node_def, Status* status) {",
          "new_line_content": "    node->~Node();",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "node_def.op()",
          "old_line_content": "    return nullptr;",
          "new_line_content": "  status->Update(ops_.LookUp(node_def.op(), &op_reg_data));",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": null,
          "new_api": "ok",
          "old_text": null,
          "new_text": "status->ok()",
          "old_line_content": "  }",
          "new_line_content": "  if (!status->ok()) return nullptr;",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": null,
          "new_api": "InOutTypesForNode",
          "old_text": null,
          "new_text": "InOutTypesForNode(node_def, op_reg_data->op_def, &inputs, &outputs)",
          "old_line_content": "",
          "new_line_content": "      InOutTypesForNode(node_def, op_reg_data->op_def, &inputs, &outputs));",
          "content_same": false
        },
        {
          "line": 431,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "node_def.op()",
          "old_line_content": "Node* Graph::CopyNode(const Node* node) {",
          "new_line_content": "                                   : Node::GetNodeClassForOp(node_def.op());",
          "content_same": false
        },
        {
          "line": 442,
          "old_api": null,
          "new_api": "IsSink",
          "old_text": null,
          "new_text": "node->IsSink()",
          "old_line_content": "  if (op_def != node->props_->op_def) {",
          "new_line_content": "  DCHECK(!node->IsSink());",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": null,
          "new_api": "assigned_device_name",
          "old_text": null,
          "new_text": "node->assigned_device_name()",
          "old_line_content": "    copy->props_->op_def = op_def;",
          "new_line_content": "  copy->set_assigned_device_name(node->assigned_device_name());",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": null,
          "new_api": "type_string",
          "old_text": null,
          "new_text": "node->type_string()",
          "old_line_content": "void Graph::RemoveNode(Node* node) {",
          "new_line_content": "  TF_CHECK_OK(ops_.LookUpOpDef(node->type_string(), &op_def));",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": null,
          "new_api": "DebugString",
          "old_text": null,
          "new_text": "node->DebugString()",
          "old_line_content": "    --num_edges_;",
          "new_line_content": "  TF_DCHECK_OK(IsValidNode(node)) << node->DebugString();",
          "content_same": false
        },
        {
          "line": 461,
          "old_api": null,
          "new_api": "IsSource",
          "old_text": null,
          "new_text": "node->IsSource()",
          "old_line_content": "  }",
          "new_line_content": "  DCHECK(!node->IsSource());",
          "content_same": false
        },
        {
          "line": 468,
          "old_api": null,
          "new_api": "RecycleEdge",
          "old_text": null,
          "new_text": "RecycleEdge(e)",
          "old_line_content": "  }",
          "new_line_content": "    RecycleEdge(e);",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "node->in_edges_.clear()",
          "old_line_content": "}",
          "new_line_content": "  node->in_edges_.clear();",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "e->dst_->in_edges_.erase(e)",
          "old_line_content": "const Edge* Graph::AddEdge(Node* source, int x, Node* dest, int y) {",
          "new_line_content": "    CHECK_EQ(e->dst_->in_edges_.erase(e), size_t{1});",
          "content_same": false
        },
        {
          "line": 478,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "node->out_edges_.clear()",
          "old_line_content": "  // control slots must only be linked to control slots.",
          "new_line_content": "  node->out_edges_.clear();",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": null,
          "new_api": "DebugString",
          "old_text": null,
          "new_text": "source->DebugString()",
          "old_line_content": "  }",
          "new_line_content": "  TF_DCHECK_OK(IsValidNode(source)) << source->DebugString();",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": null,
          "new_api": "DebugString",
          "old_text": null,
          "new_text": "dest->DebugString()",
          "old_line_content": "",
          "new_line_content": "  TF_DCHECK_OK(IsValidNode(dest)) << dest->DebugString();",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": null,
          "new_api": "sink_node",
          "old_text": null,
          "new_text": "sink_node()",
          "old_line_content": "  } else {",
          "new_line_content": "  if (source == source_node() || dest == sink_node() || x == kControlSlot ||",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": null,
          "new_api": "DebugString",
          "old_text": null,
          "new_text": "dest->DebugString()",
          "old_line_content": "  }",
          "new_line_content": "    DCHECK_EQ(y, kControlSlot) << dest->DebugString();",
          "content_same": false
        },
        {
          "line": 495,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "free_edges_.empty()",
          "old_line_content": "  e->src_output_ = x;",
          "new_line_content": "  if (free_edges_.empty()) {",
          "content_same": false
        },
        {
          "line": 496,
          "old_api": null,
          "new_api": "Alloc",
          "old_text": null,
          "new_text": "arena_.Alloc(sizeof(Edge))",
          "old_line_content": "  e->dst_input_ = y;",
          "new_line_content": "    e = new (arena_.Alloc(sizeof(Edge))) Edge;  // placement new",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "edges_.size()",
          "old_line_content": "  return e;",
          "new_line_content": "  e->id_ = edges_.size();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 513,
          "old_api": "RecycleEdge",
          "new_api": null,
          "old_text": "RecycleEdge(e)",
          "new_text": null,
          "old_line_content": "  RecycleEdge(e);",
          "new_line_content": "void Graph::RemoveEdge(const Edge* e) {",
          "content_same": false
        },
        {
          "line": 524,
          "old_api": "in_edges",
          "new_api": null,
          "old_text": "dest->in_edges()",
          "new_text": null,
          "old_line_content": "    for (const Edge* edge : dest->in_edges()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 525,
          "old_api": "src",
          "new_api": null,
          "old_text": "edge->src()",
          "new_text": null,
          "old_line_content": "      if (edge->IsControlEdge() && edge->src() == source) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": "IsSink",
          "new_api": null,
          "old_text": "dest->IsSink()",
          "new_text": null,
          "old_line_content": "  if (!source->IsSource() && !dest->IsSink() && !allow_duplicates) {",
          "new_line_content": "  if (!allow_duplicates) {",
          "content_same": false
        },
        {
          "line": 536,
          "old_api": "input",
          "new_api": null,
          "old_text": "dest->props_->node_def.input()",
          "new_text": null,
          "old_line_content": "    for (const string& input : dest->props_->node_def.input()) {",
          "new_line_content": "        return nullptr;",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": "add_input",
          "new_api": null,
          "old_text": "dest->props_->node_def.add_input(new_input)",
          "new_text": null,
          "old_line_content": "      dest->props_->node_def.add_input(new_input);",
          "new_line_content": "    bool input_exists = false;",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": "AddEdge",
          "new_api": null,
          "old_text": "AddEdge(source, kControlSlot, dest, kControlSlot)",
          "new_text": null,
          "old_line_content": "  return AddEdge(source, kControlSlot, dest, kControlSlot);",
          "new_line_content": "        input_exists = true;",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": "IsSink",
          "new_api": null,
          "old_text": "e->dst_->IsSink()",
          "new_text": null,
          "old_line_content": "  if (!e->src_->IsSource() && !e->dst_->IsSink()) {",
          "new_line_content": "    if (!input_exists) {",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": "mutable_input",
          "new_api": null,
          "old_text": "e->dst_->props_->node_def.mutable_input()",
          "new_text": null,
          "old_line_content": "    auto* inputs = e->dst_->props_->node_def.mutable_input();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 555,
          "old_api": "end",
          "new_api": null,
          "old_text": "inputs->end()",
          "new_text": null,
          "old_line_content": "    for (auto it = inputs->begin(); it != inputs->end(); ++it) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": "erase",
          "new_api": null,
          "old_text": "inputs->erase(it)",
          "new_text": null,
          "old_line_content": "        inputs->erase(it);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": "in_edges",
          "new_api": null,
          "old_text": "dst->in_edges()",
          "new_text": null,
          "old_line_content": "  for (const Edge* e : dst->in_edges()) {",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": "dst_input",
          "new_api": null,
          "old_text": "e->dst_input()",
          "new_text": null,
          "old_line_content": "    if (e->dst_input() == index) return e;",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": "FindEdge",
          "new_api": null,
          "old_text": "FindEdge(dst, dst_index)",
          "new_text": null,
          "old_line_content": "  const Edge* e = FindEdge(dst, dst_index);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": "errors::InvalidArgument(\"Couldn't find edge to \",\n                                   FormatNodeForError(*dst))",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\"Couldn't find edge to \",\n                                   FormatNodeForError(*dst))",
          "new_text": null,
          "old_line_content": "    return errors::InvalidArgument(\"Couldn't find edge to \",",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": "FormatNodeForError",
          "new_api": null,
          "old_text": "FormatNodeForError(*dst)",
          "new_text": null,
          "old_line_content": "                                   FormatNodeForError(*dst));",
          "new_line_content": "}  // namespace",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": "RemoveEdge",
          "new_api": null,
          "old_text": "RemoveEdge(e)",
          "new_text": null,
          "old_line_content": "  RemoveEdge(e);",
          "new_line_content": "Status Graph::UpdateEdge(Node* new_src, int new_src_index, Node* dst,",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": "AddEdge",
          "new_api": null,
          "old_text": "AddEdge(new_src, new_src_index, dst, dst_index)",
          "new_text": null,
          "old_line_content": "  AddEdge(new_src, new_src_index, dst, dst_index);",
          "new_line_content": "                         int dst_index) {",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  if (e == nullptr) {",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": "IsValidInputTensor",
          "new_api": null,
          "old_text": "IsValidInputTensor(dst, dst_index)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(IsValidInputTensor(dst, dst_index));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 607,
          "old_api": "MaybeCopyOnWrite",
          "new_api": null,
          "old_text": "dst->MaybeCopyOnWrite()",
          "new_text": null,
          "old_line_content": "  dst->MaybeCopyOnWrite();",
          "new_line_content": "  // Find the current number of data inputs. We'll add the new edge to the next",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": "add_input",
          "new_api": null,
          "old_text": "dst->props_->node_def.add_input(\n      strings::StrCat(new_src->name(), \":\", new_src_index))",
          "new_text": null,
          "old_line_content": "  dst->props_->node_def.add_input(",
          "new_line_content": "  // missing data input.",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": "name",
          "new_api": null,
          "old_text": "new_src->name()",
          "new_text": null,
          "old_line_content": "      strings::StrCat(new_src->name(), \":\", new_src_index));",
          "new_line_content": "  int dst_index = 0;",
          "content_same": false
        },
        {
          "line": 629,
          "old_api": "strings::StrCat(src_name, \":\", src_slot)",
          "new_api": null,
          "old_text": "strings::StrCat(src_name, \":\", src_slot)",
          "new_text": null,
          "old_line_content": "    dst->add_input(strings::StrCat(src_name, \":\", src_slot));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": "ToGraphDef",
          "new_api": null,
          "old_text": "ToGraphDef(&ret)",
          "new_text": null,
          "old_line_content": "  ToGraphDef(&ret);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": "Clear",
          "new_api": null,
          "old_text": "graph_def->Clear()",
          "new_text": null,
          "old_line_content": "  graph_def->Clear();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": "versions",
          "new_api": null,
          "old_text": "versions()",
          "new_text": null,
          "old_line_content": "  *graph_def->mutable_versions() = versions();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": "ToProto",
          "new_api": null,
          "old_text": "ops_.ToProto()",
          "new_text": null,
          "old_line_content": "  *graph_def->mutable_library() = ops_.ToProto();",
          "new_line_content": "GraphDef Graph::ToGraphDefDebug() const {",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": "num_node_ids",
          "new_api": null,
          "old_text": "num_node_ids()",
          "new_text": null,
          "old_line_content": "  for (auto id = from_node_id; id < num_node_ids(); ++id) {",
          "new_line_content": "void Graph::ToGraphDefSubRange(GraphDef* graph_def, int from_node_id) const {",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": "def",
          "new_api": null,
          "old_text": "node->def()",
          "new_text": null,
          "old_line_content": "    *node_def = node->def();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": "empty",
          "new_api": null,
          "old_text": "node->assigned_device_name().empty()",
          "new_text": null,
          "old_line_content": "    if (!node->assigned_device_name().empty()) {",
          "new_line_content": "      inputs;  // Construct this outside the loop for speed.",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": "clear",
          "new_api": null,
          "old_text": "inputs.clear()",
          "new_text": null,
          "old_line_content": "    inputs.clear();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": "num_inputs",
          "new_api": null,
          "old_text": "node->num_inputs()",
          "new_text": null,
          "old_line_content": "    inputs.resize(node->num_inputs(), nullptr);",
          "new_line_content": "    // Use the node's assigned device, if any, instead of the device requested",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": "in_edges",
          "new_api": null,
          "old_text": "node->in_edges()",
          "new_text": null,
          "old_line_content": "    for (const Edge* edge : node->in_edges()) {",
          "new_line_content": "    // in the NodeDef.",
          "content_same": false
        },
        {
          "line": 159,
          "old_api": "std::make_shared<NodeProperties>(props_->op_def, props_->node_def,\n                                            inputs, outputs)",
          "new_api": null,
          "old_text": "std::make_shared<NodeProperties>(props_->op_def, props_->node_def,\n                                            inputs, outputs)",
          "new_text": null,
          "old_line_content": "  props_ = std::make_shared<NodeProperties>(props_->op_def, props_->node_def,",
          "new_line_content": "  if (props_->input_types != inputs || props_->output_types != outputs) {",
          "content_same": false
        },
        {
          "line": 674,
          "old_api": "size",
          "new_api": null,
          "old_text": "inputs.size()",
          "new_text": null,
          "old_line_content": "        DCHECK(edge->dst_input() < inputs.size())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 163,
          "old_api": "name",
          "new_api": null,
          "old_text": "props_->node_def.name()",
          "new_text": null,
          "old_line_content": "const string& Node::name() const { return props_->node_def.name(); }",
          "new_line_content": "      props_->output_types = outputs;",
          "content_same": false
        },
        {
          "line": 164,
          "old_api": "op",
          "new_api": null,
          "old_text": "props_->node_def.op()",
          "new_text": null,
          "old_line_content": "const string& Node::type_string() const { return props_->node_def.op(); }",
          "new_line_content": "      props_->output_types_slice = props_->output_types;",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": "DebugString",
          "new_api": null,
          "old_text": "edge->DebugString()",
          "new_text": null,
          "old_line_content": "            << \"Edge \" << edge->DebugString()",
          "new_line_content": "    // Get the inputs for this Node.  We make sure control inputs are",
          "content_same": false
        },
        {
          "line": 168,
          "old_api": "size",
          "new_api": null,
          "old_text": "props_->input_types.size()",
          "new_text": null,
          "old_line_content": "int32 Node::num_inputs() const { return props_->input_types.size(); }",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": "dst_input",
          "new_api": null,
          "old_text": "edge->dst_input()",
          "new_text": null,
          "old_line_content": "            << inputs[edge->dst_input()]->dst()->name();",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 178,
          "old_api": "def",
          "new_api": null,
          "old_text": "def()",
          "new_text": null,
          "old_line_content": "AttrSlice Node::attrs() const { return AttrSlice(def()); }",
          "new_line_content": "DataType Node::input_type(int32 i) const { return props_->input_types[i]; }",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": "clear_input",
          "new_api": null,
          "old_text": "node_def->clear_input()",
          "new_text": null,
          "old_line_content": "    node_def->clear_input();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 695,
          "old_api": "size",
          "new_api": null,
          "old_text": "inputs.size()",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i < inputs.size(); ++i) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 184,
          "old_api": "device",
          "new_api": null,
          "old_text": "def().device()",
          "new_text": null,
          "old_line_content": "const string& Node::requested_device() const { return def().device(); }",
          "new_line_content": "  return props_->output_types;",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": "size",
          "new_api": null,
          "old_text": "node->requested_inputs().size()",
          "new_text": null,
          "old_line_content": "        if (i < node->requested_inputs().size()) {",
          "new_line_content": "              [](const Edge* a, const Edge* b) -> bool {",
          "content_same": false
        },
        {
          "line": 188,
          "old_api": "end",
          "new_api": null,
          "old_text": "out_edges_.end()",
          "new_text": null,
          "old_line_content": "                         NeighborIter(out_edges_.end(), false));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 192,
          "old_api": "begin",
          "new_api": null,
          "old_text": "in_edges_.begin()",
          "new_text": null,
          "old_line_content": "  return gtl::make_range(NeighborIter(in_edges_.begin(), true),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": "IsOp",
          "new_api": null,
          "old_text": "src->IsOp()",
          "new_text": null,
          "old_line_content": "        if (!src->IsOp()) continue;",
          "new_line_content": "      const Edge* edge = inputs[i];",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": "src_output",
          "new_api": null,
          "old_text": "edge->src_output()",
          "new_text": null,
          "old_line_content": "        AddInput(node_def, src->name(), edge->src_output());",
          "new_line_content": "      if (edge == nullptr) {",
          "content_same": false
        },
        {
          "line": 198,
          "old_api": "unique",
          "new_api": null,
          "old_text": "props_.unique()",
          "new_text": null,
          "old_line_content": "  if (!props_.unique()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 199,
          "old_api": "std::make_shared<NodeProperties>(*props_)",
          "new_api": null,
          "old_text": "std::make_shared<NodeProperties>(*props_)",
          "new_text": null,
          "old_line_content": "    props_ = std::make_shared<NodeProperties>(*props_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": "MaybeCopyOnWrite",
          "new_api": null,
          "old_text": "MaybeCopyOnWrite()",
          "new_text": null,
          "old_line_content": "  MaybeCopyOnWrite();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 205,
          "old_api": "mutable_attr",
          "new_api": null,
          "old_text": "props_->node_def.mutable_attr()",
          "new_text": null,
          "old_line_content": "  return &((*props_->node_def.mutable_attr())[name]);",
          "new_line_content": "void Node::MaybeCopyOnWrite() {",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": "errors::InvalidArgument(\"Node is null\")",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\"Node is null\")",
          "new_text": null,
          "old_line_content": "    return errors::InvalidArgument(\"Node is null\");",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": "id",
          "new_api": null,
          "old_text": "node->id()",
          "new_text": null,
          "old_line_content": "  const int id = node->id();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 209,
          "old_api": "MaybeCopyOnWrite",
          "new_api": null,
          "old_text": "MaybeCopyOnWrite()",
          "new_text": null,
          "old_line_content": "  MaybeCopyOnWrite();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 210,
          "old_api": "mutable_attr",
          "new_api": null,
          "old_text": "props_->node_def.mutable_attr()",
          "new_text": null,
          "old_line_content": "  (*props_->node_def.mutable_attr()).erase(name);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "size",
          "new_api": null,
          "old_text": "nodes_.size()",
          "new_text": null,
          "old_line_content": "  if (static_cast<size_t>(id) >= nodes_.size()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": "size",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\n        \"node id \", id, \" is >= than number of nodes in graph \", nodes_.size())",
          "new_text": null,
          "old_line_content": "    return errors::InvalidArgument(",
          "new_line_content": "Status Graph::IsValidNode(const Node* node) const {",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": "size",
          "new_api": null,
          "old_text": "nodes_.size()",
          "new_text": null,
          "old_line_content": "        \"node id \", id, \" is >= than number of nodes in graph \", nodes_.size());",
          "new_line_content": "  if (node == nullptr) {",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": "std::move(name)",
          "new_api": null,
          "old_text": "std::move(name)",
          "new_text": null,
          "old_line_content": "  props_->node_def.set_name(std::move(name));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 220,
          "old_api": "set_device",
          "new_api": null,
          "old_text": "props_->node_def.set_device(device)",
          "new_text": null,
          "old_line_content": "  props_->node_def.set_device(device);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 225,
          "old_api": "mutable_experimental_debug_info",
          "new_api": null,
          "old_text": "props_->node_def.mutable_experimental_debug_info()\n      ->clear_original_node_names()",
          "new_text": null,
          "old_line_content": "  props_->node_def.mutable_experimental_debug_info()",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": "IsValidNode",
          "new_api": null,
          "old_text": "IsValidNode(node)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(IsValidNode(node));",
          "new_line_content": "  if (nodes_[id] != node) {",
          "content_same": false
        },
        {
          "line": 227,
          "old_api": "empty",
          "new_api": null,
          "old_text": "names.empty()",
          "new_text": null,
          "old_line_content": "  if (!names.empty()) {",
          "new_line_content": "void Node::set_requested_device(const string& device) {",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": "name",
          "new_api": null,
          "old_text": "node->name()",
          "new_text": null,
          "old_line_content": "    return errors::OutOfRange(\"Node '\", node->name(), \"' (type: '\",",
          "new_line_content": "                                   \" is different from the passed in node. \"",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": "name",
          "new_api": null,
          "old_text": "node->op_def().name()",
          "new_text": null,
          "old_line_content": "                              node->op_def().name(),",
          "new_line_content": "                                   \"Does it belong to a different graph?\");",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": "num_outputs",
          "new_api": null,
          "old_text": "node->num_outputs()",
          "new_text": null,
          "old_line_content": "                              \"', num of outputs: \", node->num_outputs(),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 235,
          "old_api": "errors::InvalidArgument(\"Invalid input_edge index: \", idx, \", Node \",\n                                   name(), \" only has \", num_inputs(),\n                                   \" inputs.\")",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\"Invalid input_edge index: \", idx, \", Node \",\n                                   name(), \" only has \", num_inputs(),\n                                   \" inputs.\")",
          "new_text": null,
          "old_line_content": "    return errors::InvalidArgument(\"Invalid input_edge index: \", idx, \", Node \",",
          "new_line_content": "      ->clear_original_node_names();",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": "name",
          "new_api": null,
          "old_text": "node->op_def().name()",
          "new_text": null,
          "old_line_content": "                              node->op_def().name(),",
          "new_line_content": "                              \") does not have \", \"output \", idx);",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": "num_inputs",
          "new_api": null,
          "old_text": "node->num_inputs()",
          "new_text": null,
          "old_line_content": "                              \"', num of inputs: \", node->num_inputs(),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": "in_edges",
          "new_api": null,
          "old_text": "in_edges()",
          "new_text": null,
          "old_line_content": "  for (const Edge* edge : in_edges()) {",
          "new_line_content": "  // This does a linear search over the edges.  In the common case,",
          "content_same": false
        },
        {
          "line": 250,
          "old_api": "dst_input",
          "new_api": null,
          "old_text": "edge->dst_input()",
          "new_text": null,
          "old_line_content": "    if (edge->dst_input() == idx) {",
          "new_line_content": "  // the number of elements is small enough that this search isn't",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": "Alloc",
          "new_api": null,
          "old_text": "arena_.Alloc(sizeof(Node))",
          "new_text": null,
          "old_line_content": "    node = new (arena_.Alloc(sizeof(Node))) Node;  // placement new",
          "new_line_content": "                              \") does not have \", \"input \", idx);",
          "content_same": false
        },
        {
          "line": 252,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "      return Status::OK();",
          "new_line_content": "  // optimization where, if the number of edges is small, we use",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": "pop_back",
          "new_api": null,
          "old_text": "free_nodes_.pop_back()",
          "new_text": null,
          "old_line_content": "    free_nodes_.pop_back();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 256,
          "old_api": "name",
          "new_api": null,
          "old_text": "name()",
          "new_text": null,
          "old_line_content": "  return errors::NotFound(\"Could not find input edge \", idx, \" for \", name());",
          "new_line_content": "  // in the common case but make this function faster when the number",
          "content_same": false
        },
        {
          "line": 768,
          "old_api": "size",
          "new_api": null,
          "old_text": "nodes_.size()",
          "new_text": null,
          "old_line_content": "  const int id = nodes_.size();",
          "new_line_content": "                          const Node* cost_node, Node::NodeClass node_class) {",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": "cost_id",
          "new_api": null,
          "old_text": "cost_node->cost_id()",
          "new_text": null,
          "old_line_content": "  int cost_id = cost_node ? cost_node->cost_id() : id;",
          "new_line_content": "  Node* node = nullptr;",
          "content_same": false
        },
        {
          "line": 262,
          "old_api": "num_inputs",
          "new_api": null,
          "old_text": "num_inputs()",
          "new_text": null,
          "old_line_content": "  input_edges->resize(num_inputs(), nullptr);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": "in_edges",
          "new_api": null,
          "old_text": "in_edges()",
          "new_text": null,
          "old_line_content": "  for (const Edge* edge : in_edges()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 266,
          "old_api": "num_inputs",
          "new_api": null,
          "old_text": "num_inputs()",
          "new_text": null,
          "old_line_content": "    if (edge->dst_input() < 0 || edge->dst_input() >= num_inputs()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": "dst_input",
          "new_api": null,
          "old_text": "edge->dst_input()",
          "new_text": null,
          "old_line_content": "      return errors::Internal(\"Invalid edge input number \", edge->dst_input());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": "dst_input",
          "new_api": null,
          "old_text": "edge->dst_input()",
          "new_text": null,
          "old_line_content": "    if ((*input_edges)[edge->dst_input()] != nullptr) {",
          "new_line_content": "Status Node::input_edges(std::vector<const Edge*>* input_edges) const {",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": "Clear",
          "new_api": null,
          "old_text": "node->Clear()",
          "new_text": null,
          "old_line_content": "  node->Clear();",
          "new_line_content": "  ++num_nodes_;",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": "empty",
          "new_api": null,
          "old_text": "device_name.empty()",
          "new_text": null,
          "old_line_content": "  if (device_name.empty()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": "input_edge",
          "new_api": null,
          "old_text": "input_edge(idx, &e)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(input_edge(idx, &e));",
          "new_line_content": "    if ((*input_edges)[i] == nullptr) {",
          "content_same": false
        },
        {
          "line": 802,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "device_names_.push_back(device_name)",
          "new_text": null,
          "old_line_content": "  device_names_.push_back(device_name);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 297,
          "old_api": "input_node",
          "new_api": null,
          "old_text": "input_node(idx, &n)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(input_node(idx, &n));",
          "new_line_content": "    *n = nullptr;",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": "std::pair<string, WhileContext>(\n      string(frame_name),\n      WhileContext(frame_name, std::move(enter_nodes), std::move(exit_nodes),\n                   cond_output, std::move(body_inputs),\n                   std::move(body_outputs)))",
          "new_api": null,
          "old_text": "std::pair<string, WhileContext>(\n      string(frame_name),\n      WhileContext(frame_name, std::move(enter_nodes), std::move(exit_nodes),\n                   cond_output, std::move(body_inputs),\n                   std::move(body_outputs)))",
          "new_text": null,
          "old_line_content": "  auto pair = while_ctxs_.insert(std::pair<string, WhileContext>(",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": "string",
          "new_api": null,
          "old_text": "string(frame_name)",
          "new_text": null,
          "old_line_content": "      string(frame_name),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": "std::move(exit_nodes)",
          "new_api": null,
          "old_text": "std::move(exit_nodes)",
          "new_text": null,
          "old_line_content": "      WhileContext(frame_name, std::move(enter_nodes), std::move(exit_nodes),",
          "new_line_content": "Status Graph::AddWhileContext(StringPiece frame_name,",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": "input_edge",
          "new_api": null,
          "old_text": "input_edge(idx, &e)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(input_edge(idx, &e));",
          "new_line_content": "Status Node::input_node(int idx, const Node** const_n) const {",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(e != nullptr)",
          "new_text": null,
          "old_line_content": "  DCHECK(e != nullptr);",
          "new_line_content": "  Node* n;",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": "std::move(body_inputs)",
          "new_api": null,
          "old_text": "std::move(body_inputs)",
          "new_text": null,
          "old_line_content": "                   cond_output, std::move(body_inputs),",
          "new_line_content": "                              std::vector<Node*> enter_nodes,",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  *const_n = n;",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": "std::move(body_outputs)",
          "new_api": null,
          "old_text": "std::move(body_outputs)",
          "new_text": null,
          "old_line_content": "                   std::move(body_outputs))));",
          "new_line_content": "                              std::vector<Node*> exit_nodes,",
          "content_same": false
        },
        {
          "line": 820,
          "old_api": "errors::InvalidArgument(\"WhileContext with frame name '\", frame_name,\n                                   \"' already exists\")",
          "new_api": null,
          "old_text": "errors::InvalidArgument(\"WhileContext with frame name '\", frame_name,\n                                   \"' already exists\")",
          "new_text": null,
          "old_line_content": "    return errors::InvalidArgument(\"WhileContext with frame name '\", frame_name,",
          "new_line_content": "                              std::vector<OutputTensor> body_outputs,",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": "def",
          "new_api": null,
          "old_text": "n.def()",
          "new_text": null,
          "old_line_content": "NodeDebugInfo::NodeDebugInfo(const Node& n) : NodeDebugInfo(n.def()) {}",
          "new_line_content": "  const Edge* e;",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": "name",
          "new_api": null,
          "old_text": "n->name()",
          "new_text": null,
          "old_line_content": "    result[n->name()] = n;",
          "new_line_content": "                                   \"' already exists\");",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": "end",
          "new_api": null,
          "old_text": "names.end()",
          "new_text": null,
          "old_line_content": "    original_node_names.assign(names.begin(), names.end());",
          "new_line_content": "NodeDebugInfo::NodeDebugInfo(const NodeDef& ndef)",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "src_->name().c_str()",
          "new_text": null,
          "old_line_content": "  return strings::Printf(\"[id=%d %s:%d -> %s:%d]\", id_, src_->name().c_str(),",
          "new_line_content": "std::unordered_map<string, Node*> Graph::BuildNodeNameIndex() const {",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "dst_->name().c_str()",
          "new_text": null,
          "old_line_content": "                         src_output_, dst_->name().c_str(), dst_input_);",
          "new_line_content": "  std::unordered_map<string, Node*> result;",
          "content_same": false
        },
        {
          "line": 333,
          "old_api": "std::hash<const Node*>()(s.node)",
          "new_api": null,
          "old_text": "std::hash<const Node*>()(s.node)",
          "new_text": null,
          "old_line_content": "  return Hash64Combine(std::hash<const Node*>()(s.node),",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 334,
          "old_api": "std::hash<int>()(s.index)",
          "new_api": null,
          "old_text": "std::hash<int>()(s.index)",
          "new_text": null,
          "old_line_content": "                       std::hash<int>()(s.index));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 344,
          "old_api": "std::hash<const Node*>()(s.node)",
          "new_api": null,
          "old_text": "std::hash<const Node*>()(s.node)",
          "new_text": null,
          "old_line_content": "  return Hash64Combine(std::hash<const Node*>()(s.node),",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 345,
          "old_api": "std::hash<int>()(s.index)",
          "new_api": null,
          "old_text": "std::hash<int>()(s.index)",
          "new_text": null,
          "old_line_content": "                       std::hash<int>()(s.index));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": "FunctionDefLibrary",
          "new_api": null,
          "old_text": "FunctionDefLibrary()",
          "new_text": null,
          "old_line_content": "    : ops_(ops, FunctionDefLibrary()),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 355,
          "old_api": "set_min_consumer",
          "new_api": null,
          "old_text": "versions_->set_min_consumer(TF_GRAPH_DEF_VERSION_MIN_CONSUMER)",
          "new_text": null,
          "old_line_content": "  versions_->set_min_consumer(TF_GRAPH_DEF_VERSION_MIN_CONSUMER);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 358,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "device_names_.push_back(\"\")",
          "new_text": null,
          "old_line_content": "  device_names_.push_back(\"\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 359,
          "old_api": "InternDeviceName",
          "new_api": null,
          "old_text": "InternDeviceName(\"\")",
          "new_text": null,
          "old_line_content": "  DCHECK_EQ(0, InternDeviceName(\"\"));",
          "new_line_content": "Graph::Graph(const OpRegistryInterface* ops)",
          "content_same": false
        },
        {
          "line": 366,
          "old_api": "AddNode",
          "new_api": null,
          "old_text": "AddNode(def, &status)",
          "new_text": null,
          "old_line_content": "  Node* source = AddNode(def, &status);",
          "new_line_content": "  // Initialize the name interning table for assigned_device_name.",
          "content_same": false
        },
        {
          "line": 370,
          "old_api": "set_name",
          "new_api": null,
          "old_text": "def.set_name(\"_SINK\")",
          "new_text": null,
          "old_line_content": "  def.set_name(\"_SINK\");",
          "new_line_content": "  // Source and sink have no endpoints, just control edges.",
          "content_same": false
        },
        {
          "line": 371,
          "old_api": "AddNode",
          "new_api": null,
          "old_text": "AddNode(def, &status)",
          "new_text": null,
          "old_line_content": "  Node* sink = AddNode(def, &status);",
          "new_line_content": "  NodeDef def;",
          "content_same": false
        },
        {
          "line": 385,
          "old_api": "error_message",
          "new_api": null,
          "old_text": "s.error_message()",
          "new_text": null,
          "old_line_content": "  CHECK(s.ok()) << s.error_message();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 397,
          "old_api": "node->~Node()",
          "new_api": null,
          "old_text": "node->~Node()",
          "new_text": null,
          "old_line_content": "    node->~Node();",
          "new_line_content": "Graph::~Graph() {",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": "op",
          "new_api": null,
          "old_text": "node_def.op()",
          "new_text": null,
          "old_line_content": "  status->Update(ops_.LookUp(node_def.op(), &op_reg_data));",
          "new_line_content": "  // Edges have no destructor, and we arena-allocated them, so no need to",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": "ok",
          "new_api": null,
          "old_text": "status->ok()",
          "new_text": null,
          "old_line_content": "  if (!status->ok()) return nullptr;",
          "new_line_content": "  // destroy them.",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": "Update",
          "new_api": null,
          "old_text": "status->Update(\n      InOutTypesForNode(node_def, op_reg_data->op_def, &inputs, &outputs))",
          "new_text": null,
          "old_line_content": "  status->Update(",
          "new_line_content": "void Graph::set_versions(const VersionDef& versions) { *versions_ = versions; }",
          "content_same": false
        },
        {
          "line": 414,
          "old_api": "InOutTypesForNode",
          "new_api": null,
          "old_text": "InOutTypesForNode(node_def, op_reg_data->op_def, &inputs, &outputs)",
          "new_text": null,
          "old_line_content": "      InOutTypesForNode(node_def, op_reg_data->op_def, &inputs, &outputs));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 415,
          "old_api": "ok",
          "new_api": null,
          "old_text": "status->ok()",
          "new_text": null,
          "old_line_content": "  if (!status->ok()) {",
          "new_line_content": "Node* Graph::AddNode(NodeDef node_def, Status* status) {",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": "AttachDef",
          "new_api": null,
          "old_text": "AttachDef(*status, node_def)",
          "new_text": null,
          "old_line_content": "    *status = AttachDef(*status, node_def);",
          "new_line_content": "  const OpRegistrationData* op_reg_data;",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": "std::move(node_def)",
          "new_api": null,
          "old_text": "std::move(node_def)",
          "new_text": null,
          "old_line_content": "                                       std::move(node_def), inputs, outputs),",
          "new_line_content": "    return nullptr;",
          "content_same": false
        },
        {
          "line": 432,
          "old_api": "IsSource",
          "new_api": null,
          "old_text": "node->IsSource()",
          "new_text": null,
          "old_line_content": "  DCHECK(!node->IsSource());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": "DebugString",
          "new_api": null,
          "old_text": "node->DebugString()",
          "new_text": null,
          "old_line_content": "  TF_DCHECK_OK(IsValidNode(node)) << node->DebugString();",
          "new_line_content": "  if (op_def != node->props_->op_def) {",
          "content_same": false
        },
        {
          "line": 453,
          "old_api": "IsSink",
          "new_api": null,
          "old_text": "node->IsSink()",
          "new_text": null,
          "old_line_content": "  DCHECK(!node->IsSink());",
          "new_line_content": "    copy->props_->op_def = op_def;",
          "content_same": false
        },
        {
          "line": 457,
          "old_api": "erase",
          "new_api": null,
          "old_text": "e->src_->out_edges_.erase(e)",
          "new_text": null,
          "old_line_content": "    CHECK_EQ(e->src_->out_edges_.erase(e), size_t{1});",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": "RecycleEdge",
          "new_api": null,
          "old_text": "RecycleEdge(e)",
          "new_text": null,
          "old_line_content": "    RecycleEdge(e);",
          "new_line_content": "void Graph::RemoveNode(Node* node) {",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": "erase",
          "new_api": null,
          "old_text": "e->dst_->in_edges_.erase(e)",
          "new_text": null,
          "old_line_content": "    CHECK_EQ(e->dst_->in_edges_.erase(e), size_t{1});",
          "new_line_content": "  // Remove any edges involving this node.",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": "clear",
          "new_api": null,
          "old_text": "node->out_edges_.clear()",
          "new_text": null,
          "old_line_content": "  node->out_edges_.clear();",
          "new_line_content": "    --num_edges_;",
          "content_same": false
        },
        {
          "line": 470,
          "old_api": "ReleaseNode",
          "new_api": null,
          "old_text": "ReleaseNode(node)",
          "new_text": null,
          "old_line_content": "  ReleaseNode(node);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": "DebugString",
          "new_api": null,
          "old_text": "source->DebugString()",
          "new_text": null,
          "old_line_content": "  TF_DCHECK_OK(IsValidNode(source)) << source->DebugString();",
          "new_line_content": "    edges_[e->id_] = nullptr;",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": "DebugString",
          "new_api": null,
          "old_text": "source->DebugString()",
          "new_text": null,
          "old_line_content": "    DCHECK_EQ(x, kControlSlot) << source->DebugString();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": "DebugString",
          "new_api": null,
          "old_text": "dest->DebugString()",
          "new_text": null,
          "old_line_content": "    DCHECK_EQ(y, kControlSlot) << dest->DebugString();",
          "new_line_content": "const Edge* Graph::AddEdge(Node* source, int x, Node* dest, int y) {",
          "content_same": false
        },
        {
          "line": 486,
          "old_api": "empty",
          "new_api": null,
          "old_text": "free_edges_.empty()",
          "new_text": null,
          "old_line_content": "  if (free_edges_.empty()) {",
          "new_line_content": "  // source/sink must only be linked via control slots, and",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": "Alloc",
          "new_api": null,
          "old_text": "arena_.Alloc(sizeof(Edge))",
          "new_text": null,
          "old_line_content": "    e = new (arena_.Alloc(sizeof(Edge))) Edge;  // placement new",
          "new_line_content": "  // control slots must only be linked to control slots.",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": "back",
          "new_api": null,
          "old_text": "free_edges_.back()",
          "new_text": null,
          "old_line_content": "    e = free_edges_.back();",
          "new_line_content": "      y == kControlSlot) {",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": "size",
          "new_api": null,
          "old_text": "edges_.size()",
          "new_text": null,
          "old_line_content": "  e->id_ = edges_.size();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": "insert",
          "new_api": null,
          "old_text": "source->out_edges_.insert(e)",
          "new_text": null,
          "old_line_content": "  CHECK(source->out_edges_.insert(e).second);",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": "DebugString",
          "new_api": null,
          "old_text": "e->src_->DebugString()",
          "new_text": null,
          "old_line_content": "  TF_DCHECK_OK(IsValidNode(e->src_)) << e->src_->DebugString();",
          "new_line_content": "  e->dst_input_ = y;",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": "CHECK_EQ",
          "new_api": null,
          "old_text": "CHECK_EQ(e, edges_[e->id_])",
          "new_text": null,
          "old_line_content": "  CHECK_EQ(e, edges_[e->id_]);",
          "new_line_content": "  ++num_edges_;",
          "content_same": false
        },
        {
          "line": 510,
          "old_api": "CHECK_GT",
          "new_api": null,
          "old_text": "CHECK_GT(num_edges_, 0)",
          "new_text": null,
          "old_line_content": "  CHECK_GT(num_edges_, 0);",
          "new_line_content": "  return e;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 116,
      "total_additions": 149,
      "total_deletions": 147,
      "total_api_changes": 412
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 11,
        "api_related_lines": 412,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          161,
          162,
          169,
          165
        ]
      }
    },
    "api_calls_before": 430,
    "api_calls_after": 433,
    "diff_info": {
      "added_lines": 11,
      "removed_lines": 2,
      "total_diff_lines": 25
    }
  }
}