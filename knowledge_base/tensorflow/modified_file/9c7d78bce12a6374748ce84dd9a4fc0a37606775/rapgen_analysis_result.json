{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/9c7d78bce12a6374748ce84dd9a4fc0a37606775",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/9c7d78bce12a6374748ce84dd9a4fc0a37606775/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/9c7d78bce12a6374748ce84dd9a4fc0a37606775/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/9c7d78bce12a6374748ce84dd9a4fc0a37606775/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 283,
          "old_api": "EmitTargetAddressForOp",
          "new_api": "layout",
          "old_text": "EmitTargetAddressForOp(copy)",
          "new_text": "copy->operand(0)->shape().layout()",
          "old_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(copy));",
          "new_line_content": "       LayoutUtil::Equal(copy->operand(0)->shape().layout(),",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": "operand",
          "new_api": "layout",
          "old_text": "copy->operand(0)",
          "new_text": "copy->shape().layout()",
          "old_line_content": "    return EmitMemcpy(*(copy->operand(0)), *copy);",
          "new_line_content": "                         copy->shape().layout()))) {",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": "DefaultAction",
          "new_api": "EmitTargetAddressForOp",
          "old_text": "DefaultAction(copy)",
          "new_text": "EmitTargetAddressForOp(copy)",
          "old_line_content": "    return DefaultAction(copy);",
          "new_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(copy));",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": "element_type",
          "new_api": "IsArray",
          "old_text": "Unimplemented(\"unsupported operand type %s for copy instruction\",\n                       PrimitiveType_Name(copy->shape().element_type()))",
          "new_text": "copy->shape().IsArray()",
          "old_line_content": "  return Unimplemented(\"unsupported operand type %s for copy instruction\",",
          "new_line_content": "  } else if (copy->shape().IsArray()) {",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": "DCHECK_LE",
          "new_api": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "old_text": "DCHECK_LE(byte_size, 16)",
          "new_text": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "old_line_content": "  DCHECK_LE(byte_size, 16);",
          "new_line_content": "  int64 byte_size = ShapeUtil::ByteSizeOfPrimitiveType(primitive_type);",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": "getDataLayout",
          "new_api": "std::min(int64{8}, byte_size)",
          "old_text": "module_->getDataLayout()",
          "new_text": "std::min(int64{8}, byte_size)",
          "old_line_content": "  return llvm_ir::ByteSizeOf(shape, module_->getDataLayout());",
          "new_line_content": "  return std::min(int64{8}, byte_size);",
          "content_same": false
        },
        {
          "line": 315,
          "old_api": "ByteSizeOf",
          "new_api": "ShapeUtil::IsScalar(shape)",
          "old_text": "ByteSizeOf(shape)",
          "new_text": "ShapeUtil::IsScalar(shape)",
          "old_line_content": "  int64 buffer_size = ByteSizeOf(shape);",
          "new_line_content": "  if (ShapeUtil::IsScalar(shape)) {",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": "DCHECK_GE",
          "new_api": "element_type",
          "old_text": "DCHECK_GE(buffer_size, 0)",
          "new_text": "shape.element_type()",
          "old_line_content": "  DCHECK_GE(buffer_size, 0);",
          "new_line_content": "    return MinimumAlignmentForPrimitiveType(shape.element_type());",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": "minimum_alignment_for_allocation",
          "new_api": "ByteSizeOf",
          "old_text": "target_machine_features_.minimum_alignment_for_allocation(buffer_size)",
          "new_text": "ByteSizeOf(shape)",
          "old_line_content": "  return target_machine_features_.minimum_alignment_for_allocation(buffer_size);",
          "new_line_content": "  int64 buffer_size = ByteSizeOf(shape);",
          "content_same": false
        },
        {
          "line": 360,
          "old_api": "GetEmittedValueFor",
          "new_api": "operand",
          "old_text": "GetEmittedValueFor(operand)",
          "new_text": "get_tuple_element->operand(0)",
          "old_line_content": "      GetEmittedValueFor(operand), &b_);",
          "new_line_content": "  auto operand = get_tuple_element->operand(0);",
          "content_same": false
        },
        {
          "line": 361,
          "old_api": "Status::OK()",
          "new_api": "shape",
          "old_text": "Status::OK()",
          "new_text": "get_tuple_element->shape()",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  const Shape& shape = get_tuple_element->shape();",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": "operand",
          "new_api": "Status::OK()",
          "old_text": "select->operand(0)",
          "new_text": "Status::OK()",
          "old_line_content": "  auto pred = select->operand(0);",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 371,
          "old_api": "operand",
          "new_api": "DefaultAction",
          "old_text": "tuple_select->operand(0)",
          "new_text": "DefaultAction(select)",
          "old_line_content": "  auto pred = tuple_select->operand(0);",
          "new_line_content": "  return DefaultAction(select);",
          "content_same": false
        },
        {
          "line": 375,
          "old_api": "shape",
          "new_api": "operand",
          "old_text": "pred->shape()",
          "new_text": "tuple_select->operand(0)",
          "old_line_content": "  TF_RET_CHECK(ShapeUtil::IsScalar(pred->shape()));",
          "new_line_content": "  auto pred = tuple_select->operand(0);",
          "content_same": false
        },
        {
          "line": 376,
          "old_api": "IsTuple",
          "new_api": "operand",
          "old_text": "tuple_select->shape().IsTuple()",
          "new_text": "tuple_select->operand(1)",
          "old_line_content": "  TF_RET_CHECK(tuple_select->shape().IsTuple());",
          "new_line_content": "  auto on_true = tuple_select->operand(1);",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": "EmitTargetAddressForOp",
          "new_api": "operand",
          "old_text": "EmitTargetAddressForOp(tuple_select)",
          "new_text": "tuple_select->operand(2)",
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(tuple_select));",
          "new_line_content": "  auto on_false = tuple_select->operand(2);",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": "GetIrArrayFor",
          "new_api": "element_type",
          "old_text": "GetIrArrayFor(pred)",
          "new_text": "pred->shape().element_type()",
          "old_line_content": "  llvm_ir::EmitTupleSelect(GetIrArrayFor(tuple_select), GetIrArrayFor(pred),",
          "new_line_content": "  TF_RET_CHECK(pred->shape().element_type() == PRED);",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": "GetEmittedValueFor",
          "new_api": "shape",
          "old_text": "GetEmittedValueFor(on_true)",
          "new_text": "pred->shape()",
          "old_line_content": "                           GetEmittedValueFor(on_true),",
          "new_line_content": "  TF_RET_CHECK(ShapeUtil::IsScalar(pred->shape()));",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": "GetEmittedValueFor",
          "new_api": "IsTuple",
          "old_text": "GetEmittedValueFor(on_false)",
          "new_text": "tuple_select->shape().IsTuple()",
          "old_line_content": "                           GetEmittedValueFor(on_false), &b_);",
          "new_line_content": "  TF_RET_CHECK(tuple_select->shape().IsTuple());",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": "Status::OK()",
          "new_api": "EmitTargetAddressForOp",
          "old_text": "Status::OK()",
          "new_text": "EmitTargetAddressForOp(tuple_select)",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(tuple_select));",
          "content_same": false
        },
        {
          "line": 385,
          "old_api": "Cast<HloInfeedInstruction>(instruction)",
          "new_api": "Status::OK()",
          "old_text": "Cast<HloInfeedInstruction>(instruction)",
          "new_text": "Status::OK()",
          "old_line_content": "  HloInfeedInstruction* infeed = Cast<HloInfeedInstruction>(instruction);",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 390,
          "old_api": "infeed_shape",
          "new_api": "ToString",
          "old_text": "infeed->infeed_shape()",
          "new_text": "infeed->ToString()",
          "old_line_content": "  const Shape& data_shape = infeed->infeed_shape();",
          "new_line_content": "  VLOG(2) << \"HandleInfeed: \" << infeed->ToString();",
          "content_same": false
        },
        {
          "line": 437,
          "old_api": "EmitXfeedTransfer",
          "new_api": "llvm_ir::IrArray(data_address, data_shape)",
          "old_text": "EmitXfeedTransfer(XfeedKind::kInfeed, data_shape, data_address)",
          "new_text": "llvm_ir::IrArray(data_address, data_shape)",
          "old_line_content": "        EmitXfeedTransfer(XfeedKind::kInfeed, data_shape, data_address));",
          "new_line_content": "    llvm_ir::EmitTuple(llvm_ir::IrArray(data_address, data_shape),",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": "Status::OK()",
          "new_api": "TF_RETURN_IF_ERROR",
          "old_text": "Status::OK()",
          "new_text": "TF_RETURN_IF_ERROR(\n        EmitXfeedTransfer(XfeedKind::kInfeed, data_shape, data_address))",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "    TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": "getInt32Ty",
          "new_api": "TF_ASSIGN_OR_RETURN",
          "old_text": "b_.getInt32Ty()",
          "new_text": "TF_ASSIGN_OR_RETURN(\n      llvm::Value * shape_ptr,\n      llvm_ir::EncodeSelfDescribingShapeConstant(shape, &shape_length, &b_))",
          "old_line_content": "  llvm::Type* int32_type = b_.getInt32Ty();",
          "new_line_content": "  TF_ASSIGN_OR_RETURN(",
          "content_same": false
        },
        {
          "line": 461,
          "old_api": "llvm::FunctionType::get(\n      i8_ptr_type,\n      {/*run_options*/ i8_ptr_type, /*buffer_length*/ int32_type,\n       /*shape_ptr*/ i8_ptr_type, /*shape_length*/ int32_type},\n      /*isVarArg=*/false)",
          "new_api": "llvm_ir::EncodeSelfDescribingShapeConstant(shape, &shape_length, &b_)",
          "old_text": "llvm::FunctionType::get(\n      i8_ptr_type,\n      {/*run_options*/ i8_ptr_type, /*buffer_length*/ int32_type,\n       /*shape_ptr*/ i8_ptr_type, /*shape_length*/ int32_type},\n      /*isVarArg=*/false)",
          "new_text": "llvm_ir::EncodeSelfDescribingShapeConstant(shape, &shape_length, &b_)",
          "old_line_content": "  llvm::FunctionType* acquire_type = llvm::FunctionType::get(",
          "new_line_content": "      llvm_ir::EncodeSelfDescribingShapeConstant(shape, &shape_length, &b_));",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": "MemCpy",
          "new_api": "getInt32",
          "old_text": "MemCpy(program_buffer_address, /*DstAlign=*/1, acquired_pointer,\n           /*SrcAlign=*/1, length_32)",
          "new_text": "b_.getInt32(shape_length)",
          "old_line_content": "    MemCpy(program_buffer_address, /*DstAlign=*/1, acquired_pointer,",
          "new_line_content": "                     shape_ptr, b_.getInt32(shape_length)});",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": "getInt32",
          "new_api": "MemCpy",
          "old_text": "b_.getInt32(length_32)",
          "new_text": "MemCpy(acquired_pointer, /*DstAlign=*/1, program_buffer_address,\n           /*SrcAlign=*/1, length_32)",
          "old_line_content": "  Call(release_func, {GetExecutableRunOptionsArgument(), b_.getInt32(length_32),",
          "new_line_content": "    MemCpy(acquired_pointer, /*DstAlign=*/1, program_buffer_address,",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": "IsTuple",
          "new_api": "operands",
          "old_text": "operand_shape.IsTuple()",
          "new_text": "outfeed->operands()",
          "old_line_content": "  if (!operand_shape.IsTuple()) {",
          "new_line_content": "  HloInstruction* operand = outfeed->operands()[0];",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": "EmitXfeedTransfer",
          "new_api": "shape",
          "old_text": "EmitXfeedTransfer(XfeedKind::kOutfeed, operand_shape, value)",
          "new_text": "operand->shape()",
          "old_line_content": "    return EmitXfeedTransfer(XfeedKind::kOutfeed, operand_shape, value);",
          "new_line_content": "  const Shape& operand_shape = operand->shape();",
          "content_same": false
        },
        {
          "line": 548,
          "old_api": "ShapeUtil::IsNestedTuple(operand_shape)",
          "new_api": "IsTuple",
          "old_text": "ShapeUtil::IsNestedTuple(operand_shape)",
          "new_text": "operand_shape.IsTuple()",
          "old_line_content": "  TF_RET_CHECK(!ShapeUtil::IsNestedTuple(operand_shape));",
          "new_line_content": "  if (!operand_shape.IsTuple()) {",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": "ShapeUtil::GetTupleElementShape(operand_shape, i)",
          "new_api": "ShapeUtil::IsNestedTuple(operand_shape)",
          "old_text": "ShapeUtil::GetTupleElementShape(operand_shape, i)",
          "new_text": "ShapeUtil::IsNestedTuple(operand_shape)",
          "old_line_content": "        ShapeUtil::GetTupleElementShape(operand_shape, i);",
          "new_line_content": "  TF_RET_CHECK(!ShapeUtil::IsNestedTuple(operand_shape));",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": "MinimumAlignmentForShape",
          "new_api": "tuple_shapes_size",
          "old_text": "MinimumAlignmentForShape(tuple_element_shape)",
          "new_text": "operand_shape.tuple_shapes_size()",
          "old_line_content": "        tuple_element_shape, i, MinimumAlignmentForShape(tuple_element_shape),",
          "new_line_content": "  for (int64 i = 0; i < operand_shape.tuple_shapes_size(); ++i) {",
          "content_same": false
        },
        {
          "line": 556,
          "old_api": "EmitXfeedTransfer",
          "new_api": "ShapeUtil::GetTupleElementShape(operand_shape, i)",
          "old_text": "EmitXfeedTransfer(XfeedKind::kOutfeed,\n                                         tuple_element_shape, tuple_element)",
          "new_text": "ShapeUtil::GetTupleElementShape(operand_shape, i)",
          "old_line_content": "    TF_RETURN_IF_ERROR(EmitXfeedTransfer(XfeedKind::kOutfeed,",
          "new_line_content": "        ShapeUtil::GetTupleElementShape(operand_shape, i);",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": "Status::OK()",
          "new_api": "EmitXfeedTransfer",
          "old_text": "Status::OK()",
          "new_text": "EmitXfeedTransfer(XfeedKind::kOutfeed,\n                                         tuple_element_shape, tuple_element)",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "    TF_RETURN_IF_ERROR(EmitXfeedTransfer(XfeedKind::kOutfeed,",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": "Cast<HloSortInstruction>(hlo)",
          "new_api": "Status::OK()",
          "old_text": "Cast<HloSortInstruction>(hlo)",
          "new_text": "Status::OK()",
          "old_line_content": "  const HloSortInstruction* sort = Cast<HloSortInstruction>(hlo);",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": "operand_count",
          "new_api": "Unimplemented",
          "old_text": "sort->operand_count()",
          "new_text": "Unimplemented(\n          \"Element type %s not supported in the Sort op on CPU.\",\n          PrimitiveType_Name(keys_type))",
          "old_line_content": "  std::vector<llvm::Value*> destination_addresses(sort->operand_count());",
          "new_line_content": "      return Unimplemented(",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": "operand",
          "new_api": "operand_count",
          "old_text": "sort->operand(i)",
          "new_text": "sort->operand_count()",
          "old_line_content": "    const HloInstruction* operand = sort->operand(i);",
          "new_line_content": "  std::vector<llvm::Value*> destination_addresses(sort->operand_count());",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "shape",
          "new_api": "ShapeIndex",
          "old_text": "TF_RET_CHECK(\n        LayoutUtil::LayoutsInShapesEqual(keys_shape, operand->shape()))",
          "new_text": "ShapeIndex({})",
          "old_line_content": "    TF_RET_CHECK(",
          "new_line_content": "        sort->values_count() > 0 ? ShapeIndex({i}) : ShapeIndex({});",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": "shape",
          "new_api": "operand",
          "old_text": "operand->shape()",
          "new_text": "sort->operand(i)",
          "old_line_content": "        LayoutUtil::LayoutsInShapesEqual(keys_shape, operand->shape()));",
          "new_line_content": "    const HloInstruction* operand = sort->operand(i);",
          "content_same": false
        },
        {
          "line": 602,
          "old_api": "GetAllocationSlice",
          "new_api": "shape",
          "old_text": "GetAllocationSlice(*sort, shape_index)",
          "new_text": "sort->shape()",
          "old_line_content": "    auto destination_buffer = GetAllocationSlice(*sort, shape_index);",
          "new_line_content": "        keys_shape, ShapeUtil::GetSubshape(sort->shape(), shape_index)));",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": "element_type",
          "new_api": "shape",
          "old_text": "operand->shape().element_type()",
          "new_text": "operand->shape()",
          "old_line_content": "          ShapeUtil::ByteSizeOfPrimitiveType(operand->shape().element_type());",
          "new_line_content": "        EmitBufferPointer(destination_buffer, operand->shape());",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": "GetEmittedValueFor",
          "new_api": "GetAllocationSlice",
          "old_text": "GetEmittedValueFor(operand)",
          "new_text": "GetAllocationSlice(*operand)",
          "old_line_content": "      auto source_buffer = GetEmittedValueFor(operand);",
          "new_line_content": "    auto source_address = GetAllocationSlice(*operand);",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": "dimensions",
          "new_api": "layout",
          "old_text": "normalized_keys_shape.dimensions(physical_dimension_to_sort)",
          "new_text": "LayoutUtil::MakeLogicalToPhysical(\n      keys_shape.layout())",
          "old_line_content": "      normalized_keys_shape.dimensions(physical_dimension_to_sort);",
          "new_line_content": "  int64 physical_dimension_to_sort = LayoutUtil::MakeLogicalToPhysical(",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": "to_apply",
          "new_api": "dimensions",
          "old_text": "sort->to_apply()",
          "new_text": "normalized_keys_shape.dimensions(i)",
          "old_line_content": "  CHECK(absl::c_binary_search(thread_local_computations_, sort->to_apply()));",
          "new_line_content": "    lower_dimensions *= normalized_keys_shape.dimensions(i);",
          "content_same": false
        },
        {
          "line": 639,
          "old_api": "getInt64Ty",
          "new_api": "to_apply",
          "old_text": "b_.getInt64Ty()",
          "new_text": "sort->to_apply()",
          "old_line_content": "      {b_.getInt64Ty(), b_.getInt64Ty(), b_.getInt64Ty(),",
          "new_line_content": "  auto less_than_function = FindOrDie(emitted_functions_, sort->to_apply());",
          "content_same": false
        },
        {
          "line": 640,
          "old_api": "getInt32Ty",
          "new_api": "to_apply",
          "old_text": "b_.getInt32Ty()",
          "new_text": "sort->to_apply()",
          "old_line_content": "       b_.getInt8PtrTy()->getPointerTo(), b_.getInt32Ty(),",
          "new_line_content": "  CHECK(absl::c_binary_search(thread_local_computations_, sort->to_apply()));",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": "getInt8PtrTy",
          "new_api": "getVoidTy",
          "old_text": "b_.getInt8PtrTy()",
          "new_text": "llvm::FunctionType::get(\n      b_.getVoidTy(),\n      {b_.getInt64Ty(), b_.getInt64Ty(), b_.getInt64Ty(),\n       b_.getInt8PtrTy()->getPointerTo(), b_.getInt32Ty(),\n       b_.getInt32Ty()->getPointerTo(), b_.getInt1Ty(), b_.getInt8PtrTy(),\n       b_.getInt64Ty()->getPointerTo(), less_than_function->getType()},\n      /*isVarArg=*/false)",
          "old_line_content": "       b_.getInt32Ty()->getPointerTo(), b_.getInt1Ty(), b_.getInt8PtrTy(),",
          "new_line_content": "  llvm::FunctionType* key_value_sort_type = llvm::FunctionType::get(",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": "getType",
          "new_api": "getVoidTy",
          "old_text": "less_than_function->getType()",
          "new_text": "b_.getVoidTy()",
          "old_line_content": "       b_.getInt64Ty()->getPointerTo(), less_than_function->getType()},",
          "new_line_content": "      b_.getVoidTy(),",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": "getCallee",
          "new_api": "getInt32Ty",
          "old_text": "llvm::dyn_cast<llvm::Function>(\n      module_\n          ->getOrInsertFunction(runtime::kKeyValueSortSymbolName,\n                                key_value_sort_type)\n          .getCallee())",
          "new_text": "b_.getInt32Ty()",
          "old_line_content": "  auto* key_value_sort_func = llvm::dyn_cast<llvm::Function>(",
          "new_line_content": "       b_.getInt8PtrTy()->getPointerTo(), b_.getInt32Ty(),",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": "getCallee",
          "new_api": "getInt8PtrTy",
          "old_text": "module_\n          ->getOrInsertFunction(runtime::kKeyValueSortSymbolName,\n                                key_value_sort_type)\n          .getCallee()",
          "new_text": "b_.getInt8PtrTy()",
          "old_line_content": "      module_",
          "new_line_content": "       b_.getInt32Ty()->getPointerTo(), b_.getInt1Ty(), b_.getInt8PtrTy(),",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": "setCallingConv",
          "new_api": "getCallee",
          "old_text": "key_value_sort_func->setCallingConv(llvm::CallingConv::C)",
          "new_text": "module_\n          ->getOrInsertFunction(runtime::kKeyValueSortSymbolName,\n                                key_value_sort_type)\n          .getCallee()",
          "old_line_content": "  key_value_sort_func->setCallingConv(llvm::CallingConv::C);",
          "new_line_content": "      module_",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": "getInt32Ty",
          "new_api": "setDoesNotThrow",
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntryWithCount(\n      b_.getInt32Ty(), b_.getInt32(sort->operand_count()), \"cc_sizes_alloca\",\n      &b_)",
          "new_text": "key_value_sort_func->setDoesNotThrow()",
          "old_line_content": "  llvm::Value* sizes = llvm_ir::EmitAllocaAtFunctionEntryWithCount(",
          "new_line_content": "  key_value_sort_func->setDoesNotThrow();",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": "operand_count",
          "new_api": "getInt8PtrTy",
          "old_text": "sort->operand_count()",
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntryWithCount(\n      b_.getInt8PtrTy(), b_.getInt32(sort->operand_count()), \"cc_values_alloca\",\n      &b_)",
          "old_line_content": "      b_.getInt32Ty(), b_.getInt32(sort->operand_count()), \"cc_sizes_alloca\",",
          "new_line_content": "  llvm::Value* values = llvm_ir::EmitAllocaAtFunctionEntryWithCount(",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": "getInt8PtrTy",
          "new_api": "operand_count",
          "old_text": "b_.getInt8PtrTy()",
          "new_text": "sort->operand_count()",
          "old_line_content": "        PointerCast(destination_addresses[i], b_.getInt8PtrTy());",
          "new_line_content": "      b_.getInt32Ty(), b_.getInt32(sort->operand_count()), \"cc_sizes_alloca\",",
          "content_same": false
        },
        {
          "line": 661,
          "old_api": "getInt8PtrTy",
          "new_api": "operand_count",
          "old_text": "b_.getInt8PtrTy()",
          "new_text": "sort->operand_count()",
          "old_line_content": "        ConstInBoundsGEP1_32(b_.getInt8PtrTy(), values, i);",
          "new_line_content": "  for (int64 i = 0; i < sort->operand_count(); ++i) {",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": "element_type",
          "new_api": "getInt8PtrTy",
          "old_text": "ShapeUtil::ByteSizeOfPrimitiveType(\n        sort->operand(i)->shape().element_type())",
          "new_text": "b_.getInt8PtrTy()",
          "old_line_content": "    llvm::Value* size = b_.getInt32(ShapeUtil::ByteSizeOfPrimitiveType(",
          "new_line_content": "        ConstInBoundsGEP1_32(b_.getInt8PtrTy(), values, i);",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": "element_type",
          "new_api": "Store",
          "old_text": "sort->operand(i)->shape().element_type()",
          "new_text": "Store(value_as_i8ptr, slot_in_values_alloca)",
          "old_line_content": "        sort->operand(i)->shape().element_type()));",
          "new_line_content": "    Store(value_as_i8ptr, slot_in_values_alloca);",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": "getInt64",
          "new_api": "element_type",
          "old_text": "Call(key_value_sort_func,\n       {b_.getInt64(higher_dimensions), b_.getInt64(sort_dimension_elements),\n        b_.getInt64(lower_dimensions), values,\n        b_.getInt32(sort->operand_count()), sizes,\n        b_.getInt1(sort->is_stable()), GetExecutableRunOptionsArgument(),\n        GetProfileCountersArgument(), less_than_function})",
          "new_text": "sort->operand(i)->shape().element_type()",
          "old_line_content": "  Call(key_value_sort_func,",
          "new_line_content": "        sort->operand(i)->shape().element_type()));",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": "getInt64",
          "new_api": "Store",
          "old_text": "b_.getInt64(sort_dimension_elements)",
          "new_text": "Store(size, slot_in_sizes_alloca)",
          "old_line_content": "       {b_.getInt64(higher_dimensions), b_.getInt64(sort_dimension_elements),",
          "new_line_content": "    Store(size, slot_in_sizes_alloca);",
          "content_same": false
        },
        {
          "line": 674,
          "old_api": "GetExecutableRunOptionsArgument",
          "new_api": "getInt64",
          "old_text": "GetExecutableRunOptionsArgument()",
          "new_text": "Call(key_value_sort_func,\n       {b_.getInt64(higher_dimensions), b_.getInt64(sort_dimension_elements),\n        b_.getInt64(lower_dimensions), values,\n        b_.getInt32(sort->operand_count()), sizes,\n        b_.getInt1(sort->is_stable()), GetExecutableRunOptionsArgument(),\n        GetProfileCountersArgument(), less_than_function})",
          "old_line_content": "        b_.getInt1(sort->is_stable()), GetExecutableRunOptionsArgument(),",
          "new_line_content": "  Call(key_value_sort_func,",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": "GetProfileCountersArgument",
          "new_api": "getInt64",
          "old_text": "GetProfileCountersArgument()",
          "new_text": "b_.getInt64(sort_dimension_elements)",
          "old_line_content": "        GetProfileCountersArgument(), less_than_function});",
          "new_line_content": "       {b_.getInt64(higher_dimensions), b_.getInt64(sort_dimension_elements),",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": "values_count",
          "new_api": "operand_count",
          "old_text": "sort->values_count()",
          "new_text": "sort->operand_count()",
          "old_line_content": "  if (sort->values_count() > 0) {",
          "new_line_content": "        b_.getInt32(sort->operand_count()), sizes,",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": "GetIrArrayFor",
          "new_api": "GetExecutableRunOptionsArgument",
          "old_text": "GetIrArrayFor(sort)",
          "new_text": "GetExecutableRunOptionsArgument()",
          "old_line_content": "    llvm_ir::EmitTuple(GetIrArrayFor(sort), destination_addresses, &b_);",
          "new_line_content": "        b_.getInt1(sort->is_stable()), GetExecutableRunOptionsArgument(),",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": "EmitTargetAddressForOp",
          "new_api": "Status::OK()",
          "old_text": "EmitTargetAddressForOp(tuple)",
          "new_text": "Status::OK()",
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(tuple));",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 690,
          "old_api": "Status::OK()",
          "new_api": "operands",
          "old_text": "Status::OK()",
          "new_text": "tuple->operands()",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  for (auto operand : tuple->operands()) {",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": "element_type",
          "new_api": "window",
          "old_text": "operand->shape().element_type()",
          "new_text": "reduce_window->window()",
          "old_line_content": "  PrimitiveType operand_element_type = operand->shape().element_type();",
          "new_line_content": "  const Window& window = reduce_window->window();",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": "MinimumAlignmentForPrimitiveType",
          "new_api": "element_type",
          "old_text": "MinimumAlignmentForPrimitiveType(operand_element_type)",
          "new_text": "operand->shape().element_type()",
          "old_line_content": "      MinimumAlignmentForPrimitiveType(operand_element_type));",
          "new_line_content": "  PrimitiveType operand_element_type = operand->shape().element_type();",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": "operand",
          "new_api": "llvm_ir::EmitAllocaAtFunctionEntry(\n      llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_),\n      \"reduce_window_accumulator_address\", &b_,\n      MinimumAlignmentForPrimitiveType(operand_element_type))",
          "old_text": "reduce_window->operand(1)",
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n      llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_),\n      \"reduce_window_accumulator_address\", &b_,\n      MinimumAlignmentForPrimitiveType(operand_element_type))",
          "old_line_content": "  Store(Load(GetEmittedValueFor(reduce_window->operand(1))),",
          "new_line_content": "  llvm::Value* accumulator_address = llvm_ir::EmitAllocaAtFunctionEntry(",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": "IrName",
          "new_api": "MinimumAlignmentForPrimitiveType",
          "old_text": "IrName(reduce_window, \"inner\")",
          "new_text": "MinimumAlignmentForPrimitiveType(operand_element_type)",
          "old_line_content": "  llvm_ir::ForLoopNest loops(IrName(reduce_window, \"inner\"), &b_);",
          "new_line_content": "      MinimumAlignmentForPrimitiveType(operand_element_type));",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": "ShapeUtil::MakeShape(operand_element_type, window_size)",
          "new_api": "dimensions",
          "old_text": "ShapeUtil::MakeShape(operand_element_type, window_size)",
          "new_text": "window.dimensions()",
          "old_line_content": "      ShapeUtil::MakeShape(operand_element_type, window_size), \"window\");",
          "new_line_content": "  for (const auto& dim : window.dimensions()) {",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": "GetInnerLoopBodyBasicBlock",
          "new_api": "AddLoopsForShape",
          "old_text": "loops.GetInnerLoopBodyBasicBlock()",
          "new_text": "loops.AddLoopsForShape(\n      ShapeUtil::MakeShape(operand_element_type, window_size), \"window\")",
          "old_line_content": "  SetToFirstInsertPoint(loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "new_line_content": "  const llvm_ir::IrArray::Index window_index = loops.AddLoopsForShape(",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": "size",
          "new_api": "GetInnerLoopBodyBasicBlock",
          "old_text": "index.size()",
          "new_text": "loops.GetInnerLoopBodyBasicBlock()",
          "old_line_content": "  for (size_t i = 0; i < index.size(); ++i) {",
          "new_line_content": "  SetToFirstInsertPoint(loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 732,
          "old_api": "dimensions",
          "new_api": "size",
          "old_text": "window.dimensions(i).stride()",
          "new_text": "index.size()",
          "old_line_content": "        NSWMul(index[i], b_.getInt64(window.dimensions(i).stride()));",
          "new_line_content": "  std::vector<llvm::Value*> input_multi_index(index.size());",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": "getInt64",
          "new_api": "size",
          "old_text": "NSWAdd(strided_index,\n               NSWMul(window_index[i],\n                      b_.getInt64(window.dimensions(i).window_dilation())))",
          "new_text": "index.size()",
          "old_line_content": "        NSWAdd(strided_index,",
          "new_line_content": "  for (size_t i = 0; i < index.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": "dimensions",
          "new_api": "getInt64",
          "old_text": "window.dimensions(i).padding_low()",
          "new_text": "NSWSub(\n        NSWAdd(strided_index,\n               NSWMul(window_index[i],\n                      b_.getInt64(window.dimensions(i).window_dilation()))),\n        b_.getInt64(window.dimensions(i).padding_low()))",
          "old_line_content": "        b_.getInt64(window.dimensions(i).padding_low()));",
          "new_line_content": "    input_multi_index[i] = NSWSub(",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": "getInt64",
          "new_api": "dimensions",
          "old_text": "SRem(input_multi_index[i],\n                    b_.getInt64(window.dimensions(i).base_dilation()))",
          "new_text": "window.dimensions(i).padding_low()",
          "old_line_content": "        ICmpEQ(SRem(input_multi_index[i],",
          "new_line_content": "        b_.getInt64(window.dimensions(i).padding_low()));",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": "And",
          "new_api": "getInt64",
          "old_text": "And(in_bounds_condition, dilation_condition)",
          "new_text": "b_.getInt64(0)",
          "old_line_content": "      in_bounds_condition = And(in_bounds_condition, dilation_condition);",
          "new_line_content": "               b_.getInt64(0));",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": "And",
          "new_api": "shape",
          "old_text": "And(in_bounds_condition, index_condition)",
          "new_text": "operand->shape()",
          "old_line_content": "      in_bounds_condition = And(in_bounds_condition, index_condition);",
          "new_line_content": "                b_.getInt64(ShapeUtil::GetDimension(operand->shape(), i)));",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": "SetToFirstInsertPoint",
          "new_api": "CHECK",
          "old_text": "SetToFirstInsertPoint(if_data.true_block, &b_)",
          "new_text": "CHECK(in_bounds_condition != nullptr)",
          "old_line_content": "  SetToFirstInsertPoint(if_data.true_block, &b_);",
          "new_line_content": "  CHECK(in_bounds_condition != nullptr);",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": "shape",
          "new_api": "llvm_ir::EmitIfThenElse(in_bounds_condition, \"in-bounds\", &b_)",
          "old_text": "operand->shape()",
          "new_text": "llvm_ir::EmitIfThenElse(in_bounds_condition, \"in-bounds\", &b_)",
          "old_line_content": "  llvm_ir::IrArray::Index input_index(input_multi_index, operand->shape(),",
          "new_line_content": "      llvm_ir::EmitIfThenElse(in_bounds_condition, \"in-bounds\", &b_);",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": "getInt64Ty",
          "new_api": "SetToFirstInsertPoint",
          "old_text": "b_.getInt64Ty()",
          "new_text": "SetToFirstInsertPoint(if_data.true_block, &b_)",
          "old_line_content": "                                      b_.getInt64Ty());",
          "new_line_content": "  SetToFirstInsertPoint(if_data.true_block, &b_);",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": "to_apply",
          "new_api": "shape",
          "old_text": "EmitScalarReturningThreadLocalCall(\n      *reduce_window->to_apply(), {Load(accumulator_address), input_value},\n      \"reducer_function\")",
          "new_text": "operand->shape()",
          "old_line_content": "  llvm::Value* result = EmitScalarReturningThreadLocalCall(",
          "new_line_content": "  llvm_ir::IrArray::Index input_index(input_multi_index, operand->shape(),",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": "Load",
          "new_api": "getInt64Ty",
          "old_text": "Load(accumulator_address)",
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "      *reduce_window->to_apply(), {Load(accumulator_address), input_value},",
          "new_line_content": "                                      b_.getInt64Ty());",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": "GetOuterLoopExitBasicBlock",
          "new_api": "Load",
          "old_text": "loops.GetOuterLoopExitBasicBlock()",
          "new_text": "Load(accumulator_address)",
          "old_line_content": "  SetToFirstInsertPoint(loops.GetOuterLoopExitBasicBlock(), &b_);",
          "new_line_content": "      *reduce_window->to_apply(), {Load(accumulator_address), input_value},",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": "operand_count",
          "new_api": "DefaultAction",
          "old_text": "select_and_scatter->operand_count()",
          "new_text": "DefaultAction(reduce_window)",
          "old_line_content": "  CHECK_EQ(select_and_scatter->operand_count(), 3);",
          "new_line_content": "  return DefaultAction(reduce_window);",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": "window",
          "new_api": "operand_count",
          "old_text": "select_and_scatter->window()",
          "new_text": "select_and_scatter->operand_count()",
          "old_line_content": "  const Window& window = select_and_scatter->window();",
          "new_line_content": "  CHECK_EQ(select_and_scatter->operand_count(), 3);",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": "element_type",
          "new_api": "operand",
          "old_text": "operand->shape().element_type()",
          "new_text": "select_and_scatter->operand(0)",
          "old_line_content": "  PrimitiveType operand_element_type = operand->shape().element_type();",
          "new_line_content": "  const auto operand = select_and_scatter->operand(0);",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": "rank",
          "new_api": "operand",
          "old_text": "operand->shape().rank()",
          "new_text": "select_and_scatter->operand(1)",
          "old_line_content": "  const int64 rank = operand->shape().rank();",
          "new_line_content": "  const auto source = select_and_scatter->operand(1);",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": "rank",
          "new_api": "operand",
          "old_text": "source->shape().rank()",
          "new_text": "select_and_scatter->operand(2)",
          "old_line_content": "  CHECK_EQ(rank, source->shape().rank());",
          "new_line_content": "  const auto init_value = select_and_scatter->operand(2);",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": "dimensions_size",
          "new_api": "window",
          "old_text": "window.dimensions_size()",
          "new_text": "select_and_scatter->window()",
          "old_line_content": "  CHECK_EQ(rank, window.dimensions_size());",
          "new_line_content": "  const Window& window = select_and_scatter->window();",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": "window_util::HasDilation(window)",
          "new_api": "rank",
          "old_text": "window_util::HasDilation(window)",
          "new_text": "source->shape().rank()",
          "old_line_content": "  if (window_util::HasDilation(window)) {",
          "new_line_content": "  CHECK_EQ(rank, source->shape().rank());",
          "content_same": false
        },
        {
          "line": 818,
          "old_api": "Unimplemented",
          "new_api": "dimensions_size",
          "old_text": "Unimplemented(\n        \"Dilation for SelectAndScatter is not implemented on CPU. \")",
          "new_text": "window.dimensions_size()",
          "old_line_content": "    return Unimplemented(",
          "new_line_content": "  CHECK_EQ(rank, window.dimensions_size());",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": "Load",
          "new_api": "EmitTargetElementLoop",
          "old_text": "Load(init_value_addr)",
          "new_text": "EmitTargetElementLoop(\n      select_and_scatter, /*desc=*/IrName(select_and_scatter, \"init\"),\n      [this, init_value](const llvm_ir::IrArray::Index& target_index) {\n        llvm::Value* init_value_addr = GetEmittedValueFor(init_value);\n        return Load(init_value_addr);\n      })",
          "old_line_content": "        return Load(init_value_addr);",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetElementLoop(",
          "content_same": false
        },
        {
          "line": 851,
          "old_api": "IrName",
          "new_api": "Load",
          "old_text": "IrName(select_and_scatter)",
          "new_text": "Load(init_value_addr)",
          "old_line_content": "  llvm_ir::ForLoopNest source_loops(IrName(select_and_scatter), &b_);",
          "new_line_content": "        return Load(init_value_addr);",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": "llvm_ir::EmitAllocaAtFunctionEntry(\n      llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_),\n      \"selected_value_address\", &b_,\n      MinimumAlignmentForPrimitiveType(operand_element_type))",
          "new_api": "GetInnerLoopBodyBasicBlock",
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n      llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_),\n      \"selected_value_address\", &b_,\n      MinimumAlignmentForPrimitiveType(operand_element_type))",
          "new_text": "source_loops.GetInnerLoopBodyBasicBlock()",
          "old_line_content": "  llvm::Value* selected_value_address = llvm_ir::EmitAllocaAtFunctionEntry(",
          "new_line_content": "  SetToFirstInsertPoint(source_loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 863,
          "old_api": "getInt64Ty",
          "new_api": "llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_)",
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntryWithCount(\n          b_.getInt64Ty(), b_.getInt32(rank), \"selected_index_address\", &b_)",
          "new_text": "llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_)",
          "old_line_content": "      llvm_ir::EmitAllocaAtFunctionEntryWithCount(",
          "new_line_content": "      llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_),",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": "getInt1Ty",
          "new_api": "MinimumAlignmentForPrimitiveType",
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n      b_.getInt1Ty(), \"initialized_flag_address\", &b_)",
          "new_text": "MinimumAlignmentForPrimitiveType(operand_element_type)",
          "old_line_content": "  llvm::Value* initialized_flag_address = llvm_ir::EmitAllocaAtFunctionEntry(",
          "new_line_content": "      MinimumAlignmentForPrimitiveType(operand_element_type));",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": "getInt1",
          "new_api": "getInt64Ty",
          "old_text": "b_.getInt1(false)",
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntryWithCount(\n          b_.getInt64Ty(), b_.getInt32(rank), \"selected_index_address\", &b_)",
          "old_line_content": "  Store(b_.getInt1(false), initialized_flag_address);",
          "new_line_content": "      llvm_ir::EmitAllocaAtFunctionEntryWithCount(",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": "IrName",
          "new_api": "getInt1Ty",
          "old_text": "IrName(select_and_scatter, \"window\")",
          "new_text": "b_.getInt1Ty()",
          "old_line_content": "  llvm_ir::ForLoopNest window_loops(IrName(select_and_scatter, \"window\"), &b_);",
          "new_line_content": "      b_.getInt1Ty(), \"initialized_flag_address\", &b_);",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": "ShapeUtil::MakeShape(operand_element_type, window_size)",
          "new_api": "dimensions",
          "old_text": "ShapeUtil::MakeShape(operand_element_type, window_size)",
          "new_text": "window.dimensions()",
          "old_line_content": "      ShapeUtil::MakeShape(operand_element_type, window_size), \"window\");",
          "new_line_content": "  for (const auto& dim : window.dimensions()) {",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": "GetInnerLoopBodyBasicBlock",
          "new_api": "size",
          "old_text": "window_loops.GetInnerLoopBodyBasicBlock()",
          "new_text": "dim.size()",
          "old_line_content": "  SetToFirstInsertPoint(window_loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "new_line_content": "    window_size.push_back(dim.size());",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": "dimensions",
          "new_api": "size",
          "old_text": "window.dimensions(i).stride()",
          "new_text": "source_index.size()",
          "old_line_content": "        NSWMul(source_index[i], b_.getInt64(window.dimensions(i).stride()));",
          "new_line_content": "  std::vector<llvm::Value*> operand_multi_index(source_index.size());",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": "shape",
          "new_api": "NSWAdd",
          "old_text": "operand->shape()",
          "new_text": "NSWAdd(strided_index, window_index[i])",
          "old_line_content": "                b_.getInt64(ShapeUtil::GetDimension(operand->shape(), i)));",
          "new_line_content": "        NSWSub(NSWAdd(strided_index, window_index[i]),",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": "And",
          "new_api": "dimensions",
          "old_text": "And(in_bounds_condition, index_condition)",
          "new_text": "window.dimensions(i).padding_low()",
          "old_line_content": "    in_bounds_condition = And(in_bounds_condition, index_condition);",
          "new_line_content": "               b_.getInt64(window.dimensions(i).padding_low()));",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": "CHECK",
          "new_api": "getInt64",
          "old_text": "CHECK(in_bounds_condition != nullptr)",
          "new_text": "ICmpULT(operand_multi_index[i],\n                b_.getInt64(ShapeUtil::GetDimension(operand->shape(), i)))",
          "old_line_content": "  CHECK(in_bounds_condition != nullptr);",
          "new_line_content": "        ICmpULT(operand_multi_index[i],",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": "SetToFirstInsertPoint",
          "new_api": "Load",
          "old_text": "SetToFirstInsertPoint(if_initialized.false_block, &b_)",
          "new_text": "Load(initialized_flag_address)",
          "old_line_content": "  SetToFirstInsertPoint(if_initialized.false_block, &b_);",
          "new_line_content": "      Load(initialized_flag_address), \"initialized\", &b_);",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": "save_operand_index",
          "new_api": "getInt64Ty",
          "old_text": "save_operand_index(operand_index)",
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "  save_operand_index(operand_index);",
          "new_line_content": "      operand_multi_index, operand_array.GetShape(), b_.getInt64Ty());",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": "SetToFirstInsertPoint",
          "new_api": "getInt1",
          "old_text": "SetToFirstInsertPoint(if_initialized.true_block, &b_)",
          "new_text": "b_.getInt1(true)",
          "old_line_content": "  SetToFirstInsertPoint(if_initialized.true_block, &b_);",
          "new_line_content": "  Store(b_.getInt1(true), initialized_flag_address);",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": "select",
          "new_api": "SetToFirstInsertPoint",
          "old_text": "EmitScalarReturningThreadLocalCall(\n      *select_and_scatter->select(),\n      {Load(selected_value_address), operand_element}, \"select_function\")",
          "new_text": "SetToFirstInsertPoint(if_initialized.true_block, &b_)",
          "old_line_content": "  llvm::Value* result = EmitScalarReturningThreadLocalCall(",
          "new_line_content": "  SetToFirstInsertPoint(if_initialized.true_block, &b_);",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": "Load",
          "new_api": "EmitArrayElementAddress",
          "old_text": "Load(selected_value_address)",
          "new_text": "operand_array.EmitArrayElementAddress(operand_index, &b_)",
          "old_line_content": "      {Load(selected_value_address), operand_element}, \"select_function\");",
          "new_line_content": "      operand_array.EmitArrayElementAddress(operand_index, &b_);",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": "ICmpNE",
          "new_api": "Load",
          "old_text": "ICmpNE(\n      result,\n      llvm::ConstantInt::get(llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0),\n      \"boolean_predicate\")",
          "new_text": "Load(selected_value_address)",
          "old_line_content": "  llvm::Value* cond = ICmpNE(",
          "new_line_content": "      {Load(selected_value_address), operand_element}, \"select_function\");",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": "SetToFirstInsertPoint",
          "new_api": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "old_text": "SetToFirstInsertPoint(if_select_lhs.false_block, &b_)",
          "new_text": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "old_line_content": "  SetToFirstInsertPoint(if_select_lhs.false_block, &b_);",
          "new_line_content": "      llvm::ConstantInt::get(llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0),",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": "getInt32",
          "new_api": "GetOuterLoopExitBasicBlock",
          "old_text": "b_.getInt32(i)",
          "new_text": "window_loops.GetOuterLoopExitBasicBlock()",
          "old_line_content": "        InBoundsGEP(selected_index_address, {b_.getInt32(i)});",
          "new_line_content": "  SetToFirstInsertPoint(window_loops.GetOuterLoopExitBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": "EmitReadArrayElement",
          "new_api": "Load",
          "old_text": "source_array.EmitReadArrayElement(source_index, &b_)",
          "new_text": "Load(selected_index_address_slot)",
          "old_line_content": "      source_array.EmitReadArrayElement(source_index, &b_);",
          "new_line_content": "    selected_multi_index.push_back(Load(selected_index_address_slot));",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": "scatter",
          "new_api": "GetType",
          "old_text": "select_and_scatter->scatter()",
          "new_text": "source_index.GetType()",
          "old_line_content": "      *select_and_scatter->scatter(), {output_value, source_value},",
          "new_line_content": "      selected_multi_index, output_array.GetShape(), source_index.GetType());",
          "content_same": false
        },
        {
          "line": 969,
          "old_api": "EmitWriteArrayElement",
          "new_api": "EmitReadArrayElement",
          "old_text": "output_array.EmitWriteArrayElement(selected_index, scatter_value, &b_)",
          "new_text": "output_array.EmitReadArrayElement(selected_index, &b_)",
          "old_line_content": "  output_array.EmitWriteArrayElement(selected_index, scatter_value, &b_);",
          "new_line_content": "      output_array.EmitReadArrayElement(selected_index, &b_);",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": "GetOuterLoopExitBasicBlock",
          "new_api": "scatter",
          "old_text": "source_loops.GetOuterLoopExitBasicBlock()",
          "new_text": "select_and_scatter->scatter()",
          "old_line_content": "  SetToFirstInsertPoint(source_loops.GetOuterLoopExitBasicBlock(), &b_);",
          "new_line_content": "      *select_and_scatter->scatter(), {output_value, source_value},",
          "content_same": false
        },
        {
          "line": 976,
          "old_api": "operand",
          "new_api": "Status::OK()",
          "old_text": "dot->operand(0)",
          "new_text": "Status::OK()",
          "old_line_content": "  auto lhs = dot->operand(0);",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": "dot_dimension_numbers",
          "new_api": "operand",
          "old_text": "dot->dot_dimension_numbers()",
          "new_text": "dot->operand(1)",
          "old_line_content": "  const DotDimensionNumbers& dnums = dot->dot_dimension_numbers();",
          "new_line_content": "  auto rhs = dot->operand(1);",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": "Unimplemented",
          "new_api": "dot_dimension_numbers",
          "old_text": "Unimplemented(\n        \"Dot with multiple contracting dimensions not implemented.\")",
          "new_text": "dot->dot_dimension_numbers()",
          "old_line_content": "    return Unimplemented(",
          "new_line_content": "  const DotDimensionNumbers& dnums = dot->dot_dimension_numbers();",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": "VLOG",
          "new_api": "EmitTargetAddressForOp",
          "old_text": "VLOG(2)",
          "new_text": "EmitTargetAddressForOp(dot)",
          "old_line_content": "  VLOG(2) << \"  lhs operand: \"",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(dot));",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": "GetBasePointer",
          "new_api": "GetIrArrayFor",
          "old_text": "lhs_array.GetBasePointer()",
          "new_text": "GetIrArrayFor(dot)",
          "old_line_content": "          << llvm_ir::DumpToString(*lhs_array.GetBasePointer());",
          "new_line_content": "  llvm_ir::IrArray target_array = GetIrArrayFor(dot);",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "GetBasePointer",
          "new_api": "VLOG",
          "old_text": "rhs_array.GetBasePointer()",
          "new_text": "VLOG(2)",
          "old_line_content": "          << llvm_ir::DumpToString(*rhs_array.GetBasePointer());",
          "new_line_content": "  VLOG(2) << \"HandleDot: \";",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": "EmitDotOperation",
          "new_api": "VLOG",
          "old_text": "EmitDotOperation(*dot, target_array, lhs_array, rhs_array,\n                          /*addend_array=*/nullptr,\n                          GetExecutableRunOptionsArgument(), &b_,\n                          hlo_module_config_, target_machine_features_)",
          "new_text": "VLOG(2)",
          "old_line_content": "  return EmitDotOperation(*dot, target_array, lhs_array, rhs_array,",
          "new_line_content": "  VLOG(2) << \"  target: \"",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": "convolution_dimension_numbers",
          "new_api": "operand",
          "old_text": "convolution->convolution_dimension_numbers()",
          "new_text": "convolution->operand(1)",
          "old_line_content": "      convolution->convolution_dimension_numbers();",
          "new_line_content": "  const HloInstruction* rhs = convolution->operand(1);",
          "content_same": false
        },
        {
          "line": 1021,
          "old_api": "output_spatial_dimensions_size",
          "new_api": "window",
          "old_text": "dnums.output_spatial_dimensions_size()",
          "new_text": "convolution->window()",
          "old_line_content": "  int num_spatial_dims = dnums.output_spatial_dimensions_size();",
          "new_line_content": "  const Window& window = convolution->window();",
          "content_same": false
        },
        {
          "line": 1024,
          "old_api": "output_spatial_dimensions",
          "new_api": "convolution_dimension_numbers",
          "old_text": "dnums.output_spatial_dimensions(i)",
          "new_text": "convolution->convolution_dimension_numbers()",
          "old_line_content": "    output_spatial[i] = index[dnums.output_spatial_dimensions(i)];",
          "new_line_content": "      convolution->convolution_dimension_numbers();",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": "element_type",
          "new_api": "output_batch_dimension",
          "old_text": "lhs->shape().element_type()",
          "new_text": "dnums.output_batch_dimension()",
          "old_line_content": "  PrimitiveType lhs_element_type = lhs->shape().element_type();",
          "new_line_content": "  llvm::Value* batch = index[dnums.output_batch_dimension()];",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": "llvm_ir::EmitAllocaAtFunctionEntry(\n      accumulator_type, \"convolution_sum_address\", &b_,\n      MinimumAlignmentForPrimitiveType(lhs_element_type))",
          "new_api": "llvm_ir::PrimitiveTypeToIrType(lhs_element_type, module_)",
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n      accumulator_type, \"convolution_sum_address\", &b_,\n      MinimumAlignmentForPrimitiveType(lhs_element_type))",
          "new_text": "llvm_ir::PrimitiveTypeToIrType(lhs_element_type, module_)",
          "old_line_content": "  llvm::Value* sum_address = llvm_ir::EmitAllocaAtFunctionEntry(",
          "new_line_content": "      llvm_ir::PrimitiveTypeToIrType(lhs_element_type, module_);",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": "llvm::Constant::getNullValue(accumulator_type)",
          "new_api": "getFloatTy",
          "old_text": "llvm::Constant::getNullValue(accumulator_type)",
          "new_text": "b_.getFloatTy()",
          "old_line_content": "  llvm::Value* constant_zero = llvm::Constant::getNullValue(accumulator_type);",
          "new_line_content": "      lhs_element_type == F16 ? b_.getFloatTy() : lhs_llvm_type;",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": "Store",
          "new_api": "llvm_ir::EmitAllocaAtFunctionEntry(\n      accumulator_type, \"convolution_sum_address\", &b_,\n      MinimumAlignmentForPrimitiveType(lhs_element_type))",
          "old_text": "Store(constant_zero, sum_address)",
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n      accumulator_type, \"convolution_sum_address\", &b_,\n      MinimumAlignmentForPrimitiveType(lhs_element_type))",
          "old_line_content": "  Store(constant_zero, sum_address);",
          "new_line_content": "  llvm::Value* sum_address = llvm_ir::EmitAllocaAtFunctionEntry(",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": "IrName",
          "new_api": "MinimumAlignmentForPrimitiveType",
          "old_text": "IrName(convolution, \"inner\")",
          "new_text": "MinimumAlignmentForPrimitiveType(lhs_element_type)",
          "old_line_content": "  llvm_ir::ForLoopNest loops(IrName(convolution, \"inner\"), &b_);",
          "new_line_content": "      MinimumAlignmentForPrimitiveType(lhs_element_type));",
          "content_same": false
        },
        {
          "line": 1047,
          "old_api": "AddLoop",
          "new_api": "IrName",
          "old_text": "loops\n            .AddLoop(\n                0, rhs->shape().dimensions(dnums.kernel_spatial_dimensions(i)),\n                absl::StrCat(\"k\", i))\n            ->GetIndVarValue()",
          "new_text": "IrName(convolution, \"inner\")",
          "old_line_content": "        loops",
          "new_line_content": "  llvm_ir::ForLoopNest loops(IrName(convolution, \"inner\"), &b_);",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": "AddLoop",
          "new_api": "absl::StrCat(\"k\", i)",
          "old_text": "loops\n          .AddLoop(0, lhs->shape().dimensions(dnums.input_feature_dimension()),\n                   \"iz\")\n          ->GetIndVarValue()",
          "new_text": "absl::StrCat(\"k\", i)",
          "old_line_content": "      loops",
          "new_line_content": "                absl::StrCat(\"k\", i))",
          "content_same": false
        },
        {
          "line": 1059,
          "old_api": "GetInnerLoopBodyBasicBlock",
          "new_api": "input_feature_dimension",
          "old_text": "loops.GetInnerLoopBodyBasicBlock()",
          "new_text": "dnums.input_feature_dimension()",
          "old_line_content": "  SetToFirstInsertPoint(loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "new_line_content": "          .AddLoop(0, lhs->shape().dimensions(dnums.input_feature_dimension()),",
          "content_same": false
        },
        {
          "line": 1072,
          "old_api": "padding_low",
          "new_api": "stride",
          "old_text": "window_dim.padding_low()",
          "new_text": "window_dim.stride()",
          "old_line_content": "                  b_.getInt64(window_dim.padding_low()));",
          "new_line_content": "        NSWMul(output_index, b_.getInt64(window_dim.stride()));",
          "content_same": false
        },
        {
          "line": 1076,
          "old_api": "dimensions",
          "new_api": "padding_low",
          "old_text": "calculate_input_index(\n        output_spatial[i], kernel_spatial[i], window.dimensions(i))",
          "new_text": "window_dim.padding_low()",
          "old_line_content": "    input_spatial[i] = calculate_input_index(",
          "new_line_content": "                  b_.getInt64(window_dim.padding_low()));",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": "getInt1",
          "new_api": "getInt64",
          "old_text": "b_.getInt1(true)",
          "new_text": "b_.getInt64(base_dilation)",
          "old_line_content": "  llvm::Value* in_bounds_condition = b_.getInt1(true);",
          "new_line_content": "    llvm::Value* remainder = SRem(input_index, b_.getInt64(base_dilation));",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": "dimensions",
          "new_api": "getInt1",
          "old_text": "window.dimensions(i).base_dilation()",
          "new_text": "b_.getInt1(true)",
          "old_line_content": "        window.dimensions(i).base_dilation()));",
          "new_line_content": "  llvm::Value* in_bounds_condition = b_.getInt1(true);",
          "content_same": false
        },
        {
          "line": 1100,
          "old_api": "dimensions",
          "new_api": "input_spatial_dimensions",
          "old_text": "window.dimensions(i).base_dilation()",
          "new_text": "dnums.input_spatial_dimensions(i)",
          "old_line_content": "        not_in_hole(input_spatial[i], window.dimensions(i).base_dilation());",
          "new_line_content": "        lhs->shape().dimensions(dnums.input_spatial_dimensions(i)),",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": "And",
          "new_api": "dimensions",
          "old_text": "And(dim_in_bound, dim_not_in_hole)",
          "new_text": "window.dimensions(i).base_dilation()",
          "old_line_content": "    llvm::Value* dim_ok = And(dim_in_bound, dim_not_in_hole);",
          "new_line_content": "        window.dimensions(i).base_dilation()));",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": "And",
          "new_api": "ICmpULT",
          "old_text": "And(in_bounds_condition, dim_ok)",
          "new_text": "ICmpULT(input_spatial[i], input_bound)",
          "old_line_content": "    in_bounds_condition = And(in_bounds_condition, dim_ok);",
          "new_line_content": "    llvm::Value* dim_in_bound = ICmpULT(input_spatial[i], input_bound);",
          "content_same": false
        },
        {
          "line": 1112,
          "old_api": "dimensions",
          "new_api": "getInt64",
          "old_text": "window.dimensions(i).base_dilation()",
          "new_text": "b_.getInt64(base_dilation)",
          "old_line_content": "        undilate(input_spatial[i], window.dimensions(i).base_dilation());",
          "new_line_content": "    return SDiv(input_index, b_.getInt64(base_dilation));",
          "content_same": false
        },
        {
          "line": 1116,
          "old_api": "llvm_ir::EmitIfThenElse(in_bounds_condition, \"in-bounds\", &b_)",
          "new_api": "dimensions",
          "old_text": "llvm_ir::EmitIfThenElse(in_bounds_condition, \"in-bounds\", &b_)",
          "new_text": "window.dimensions(i).base_dilation()",
          "old_line_content": "      llvm_ir::EmitIfThenElse(in_bounds_condition, \"in-bounds\", &b_);",
          "new_line_content": "        undilate(input_spatial[i], window.dimensions(i).base_dilation());",
          "content_same": false
        },
        {
          "line": 1130,
          "old_api": "kernel_spatial_dimensions",
          "new_api": "input_batch_dimension",
          "old_text": "dnums.kernel_spatial_dimensions(i)",
          "new_text": "dnums.input_batch_dimension()",
          "old_line_content": "    kernel_multi_index[dnums.kernel_spatial_dimensions(i)] =",
          "new_line_content": "  input_multi_index[dnums.input_batch_dimension()] = batch;",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": "getInt64Ty",
          "new_api": "kernel_input_feature_dimension",
          "old_text": "b_.getInt64Ty()",
          "new_text": "dnums.kernel_input_feature_dimension()",
          "old_line_content": "                                      b_.getInt64Ty());",
          "new_line_content": "  kernel_multi_index[dnums.kernel_input_feature_dimension()] = input_feature;",
          "content_same": false
        },
        {
          "line": 1148,
          "old_api": "FMul",
          "new_api": "shape",
          "old_text": "FMul(input_value, kernel_value)",
          "new_text": "rhs->shape()",
          "old_line_content": "  llvm::Value* product = FMul(input_value, kernel_value);",
          "new_line_content": "  llvm_ir::IrArray::Index kernel_index(kernel_multi_index, rhs->shape(),",
          "content_same": false
        },
        {
          "line": 1149,
          "old_api": "FPCast",
          "new_api": "getInt64Ty",
          "old_text": "FPCast(product, accumulator_type)",
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "  llvm::Value* sum = FAdd(Load(sum_address), FPCast(product, accumulator_type));",
          "new_line_content": "                                       b_.getInt64Ty());",
          "content_same": false
        },
        {
          "line": 1152,
          "old_api": "GetOuterLoopExitBasicBlock",
          "new_api": "FMul",
          "old_text": "loops.GetOuterLoopExitBasicBlock()",
          "new_text": "FMul(input_value, kernel_value)",
          "old_line_content": "  SetToFirstInsertPoint(loops.GetOuterLoopExitBasicBlock(), &b_);",
          "new_line_content": "  llvm::Value* product = FMul(input_value, kernel_value);",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": "Load",
          "new_api": "FPCast",
          "old_text": "Load(sum_address)",
          "new_text": "FPCast(product, accumulator_type)",
          "old_line_content": "  return FPCast(Load(sum_address), lhs_llvm_type);",
          "new_line_content": "  llvm::Value* sum = FAdd(Load(sum_address), FPCast(product, accumulator_type));",
          "content_same": false
        },
        {
          "line": 1157,
          "old_api": "operand",
          "new_api": "Load",
          "old_text": "convolution->operand(0)",
          "new_text": "Load(sum_address)",
          "old_line_content": "  auto lhs = convolution->operand(0);",
          "new_line_content": "  return FPCast(Load(sum_address), lhs_llvm_type);",
          "content_same": false
        },
        {
          "line": 1169,
          "old_api": "shape",
          "new_api": "PotentiallyImplementedAsEigenConvolution",
          "old_text": "convolution->shape()",
          "new_text": "PotentiallyImplementedAsEigenConvolution(*convolution,\n                                               target_machine_features_)",
          "old_line_content": "    const Shape& convolution_shape = convolution->shape();",
          "new_line_content": "  if (PotentiallyImplementedAsEigenConvolution(*convolution,",
          "content_same": false
        },
        {
          "line": 1171,
          "old_api": "layout",
          "new_api": "shape",
          "old_text": "lhs_shape.layout()",
          "new_text": "lhs->shape()",
          "old_line_content": "    if (LayoutUtil::IsMonotonicWithDim0Major(lhs_shape.layout()) &&",
          "new_line_content": "    const Shape& lhs_shape = lhs->shape();",
          "content_same": false
        },
        {
          "line": 1172,
          "old_api": "layout",
          "new_api": "shape",
          "old_text": "rhs_shape.layout()",
          "new_text": "rhs->shape()",
          "old_line_content": "        LayoutUtil::IsMonotonicWithDim0Major(rhs_shape.layout()) &&",
          "new_line_content": "    const Shape& rhs_shape = rhs->shape();",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": "layout",
          "new_api": "shape",
          "old_text": "convolution_shape.layout()",
          "new_text": "convolution->shape()",
          "old_line_content": "        LayoutUtil::IsMonotonicWithDim0Major(convolution_shape.layout())) {",
          "new_line_content": "    const Shape& convolution_shape = convolution->shape();",
          "content_same": false
        },
        {
          "line": 1184,
          "old_api": "convolution_dimension_numbers",
          "new_api": "GetEmittedValueFor",
          "old_text": "convolution->convolution_dimension_numbers()",
          "new_text": "GetEmittedValueFor(rhs)",
          "old_line_content": "          convolution->convolution_dimension_numbers();",
          "new_line_content": "      llvm::Value* rhs_address = GetEmittedValueFor(rhs);",
          "content_same": false
        },
        {
          "line": 1188,
          "old_api": "input_batch_dimension",
          "new_api": "convolution_dimension_numbers",
          "old_text": "dnums.input_batch_dimension()",
          "new_text": "convolution->convolution_dimension_numbers()",
          "old_line_content": "      int64 input_batch = input_shape.dimensions(dnums.input_batch_dimension());",
          "new_line_content": "          convolution->convolution_dimension_numbers();",
          "content_same": false
        },
        {
          "line": 1209,
          "old_api": "kernel_output_feature_dimension",
          "new_api": "kernel_spatial_dimensions",
          "old_text": "dnums.kernel_output_feature_dimension()",
          "new_text": "dnums.kernel_spatial_dimensions(1)",
          "old_line_content": "          kernel_shape.dimensions(dnums.kernel_output_feature_dimension());",
          "new_line_content": "              : kernel_shape.dimensions(dnums.kernel_spatial_dimensions(1));",
          "content_same": false
        },
        {
          "line": 1221,
          "old_api": "window",
          "new_api": "dimensions",
          "old_text": "convolution->window()",
          "new_text": "convolution_shape.dimensions(\n                                    dnums.output_spatial_dimensions(1))",
          "old_line_content": "      const Window& window = convolution->window();",
          "new_line_content": "                              : convolution_shape.dimensions(",
          "content_same": false
        },
        {
          "line": 1222,
          "old_api": "dimensions",
          "new_api": "output_spatial_dimensions",
          "old_text": "window.dimensions(0).stride()",
          "new_text": "dnums.output_spatial_dimensions(1)",
          "old_line_content": "      int64 row_stride = window.dimensions(0).stride();",
          "new_line_content": "                                    dnums.output_spatial_dimensions(1));",
          "content_same": false
        },
        {
          "line": 1240,
          "old_api": "element_type",
          "new_api": "dimensions",
          "old_text": "lhs->shape().element_type()",
          "new_text": "window.dimensions(0).window_dilation()",
          "old_line_content": "      PrimitiveType primitive_type = lhs->shape().element_type();",
          "new_line_content": "      int64 rhs_row_dilation = window.dimensions(0).window_dilation();",
          "content_same": false
        },
        {
          "line": 1242,
          "old_api": "getHalfTy",
          "new_api": "dimensions",
          "old_text": "b_.getHalfTy()->getPointerTo()",
          "new_text": "window.dimensions(1).window_dilation()",
          "old_line_content": "                                    ? b_.getHalfTy()->getPointerTo()",
          "new_line_content": "          one_dim_convolution ? 1 : window.dimensions(1).window_dilation();",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": "getInt64Ty",
          "new_api": "element_type",
          "old_text": "b_.getInt64Ty()",
          "new_text": "lhs->shape().element_type()",
          "old_line_content": "      llvm::Type* int64_type = b_.getInt64Ty();",
          "new_line_content": "      PrimitiveType primitive_type = lhs->shape().element_type();",
          "content_same": false
        },
        {
          "line": 1246,
          "old_api": "getVoidTy",
          "new_api": "getHalfTy",
          "old_text": "llvm::FunctionType::get(\n          b_.getVoidTy(),\n          {int8_ptr_type, ir_ptr_type, ir_ptr_type, ir_ptr_type, int64_type,\n           int64_type,    int64_type,  int64_type,  int64_type,  int64_type,\n           int64_type,    int64_type,  int64_type,  int64_type,  int64_type,\n           int64_type,    int64_type,  int64_type,  int64_type,  int64_type,\n           int64_type,    int64_type,  int64_type,  int64_type},\n          /*isVarArg=*/false)",
          "new_text": "b_.getHalfTy()->getPointerTo()",
          "old_line_content": "      llvm::FunctionType* conv_type = llvm::FunctionType::get(",
          "new_line_content": "                                    ? b_.getHalfTy()->getPointerTo()",
          "content_same": false
        },
        {
          "line": 1247,
          "old_api": "getVoidTy",
          "new_api": "getFloatTy",
          "old_text": "b_.getVoidTy()",
          "new_text": "b_.getFloatTy()->getPointerTo()",
          "old_line_content": "          b_.getVoidTy(),",
          "new_line_content": "                                    : b_.getFloatTy()->getPointerTo();",
          "content_same": false
        },
        {
          "line": 1275,
          "old_api": "getCallee",
          "new_api": "LOG",
          "old_text": "module_->getOrInsertFunction(fn_name, conv_type).getCallee()",
          "new_text": "LOG(WARNING)",
          "old_line_content": "          module_->getOrInsertFunction(fn_name, conv_type).getCallee());",
          "new_line_content": "        LOG(WARNING) << \"Using Eigen instead of MKL-DNN for single-threaded \"",
          "content_same": false
        },
        {
          "line": 1278,
          "old_api": "setOnlyAccessesArgMemory",
          "new_api": "getCallee",
          "old_text": "conv_func->setOnlyAccessesArgMemory()",
          "new_text": "llvm::dyn_cast<llvm::Function>(\n          module_->getOrInsertFunction(fn_name, conv_type).getCallee())",
          "old_line_content": "      conv_func->setOnlyAccessesArgMemory();",
          "new_line_content": "      llvm::Function* conv_func = llvm::dyn_cast<llvm::Function>(",
          "content_same": false
        },
        {
          "line": 1279,
          "old_api": "getInt64",
          "new_api": "getCallee",
          "old_text": "Call(conv_func, {\n                          GetExecutableRunOptionsArgument(),\n                          BitCast(GetEmittedValueFor(convolution), ir_ptr_type),\n                          BitCast(lhs_address, ir_ptr_type),\n                          BitCast(rhs_address, ir_ptr_type),\n                          b_.getInt64(input_batch),\n                          b_.getInt64(input_rows),\n                          b_.getInt64(input_cols),\n                          b_.getInt64(input_channels),\n                          b_.getInt64(kernel_rows),\n                          b_.getInt64(kernel_cols),\n                          b_.getInt64(kernel_channels),\n                          b_.getInt64(kernel_filters),\n                          b_.getInt64(output_rows),\n                          b_.getInt64(output_cols),\n                          b_.getInt64(row_stride),\n                          b_.getInt64(col_stride),\n                          b_.getInt64(padding_top),\n                          b_.getInt64(padding_bottom),\n                          b_.getInt64(padding_left),\n                          b_.getInt64(padding_right),\n                          b_.getInt64(lhs_row_dilation),\n                          b_.getInt64(lhs_col_dilation),\n                          b_.getInt64(rhs_row_dilation),\n                          b_.getInt64(rhs_col_dilation),\n                      })",
          "new_text": "module_->getOrInsertFunction(fn_name, conv_type).getCallee()",
          "old_line_content": "      Call(conv_func, {",
          "new_line_content": "          module_->getOrInsertFunction(fn_name, conv_type).getCallee());",
          "content_same": false
        },
        {
          "line": 1280,
          "old_api": "GetExecutableRunOptionsArgument",
          "new_api": "setCallingConv",
          "old_text": "GetExecutableRunOptionsArgument()",
          "new_text": "conv_func->setCallingConv(llvm::CallingConv::C)",
          "old_line_content": "                          GetExecutableRunOptionsArgument(),",
          "new_line_content": "      conv_func->setCallingConv(llvm::CallingConv::C);",
          "content_same": false
        },
        {
          "line": 1281,
          "old_api": "GetEmittedValueFor",
          "new_api": "setDoesNotThrow",
          "old_text": "GetEmittedValueFor(convolution)",
          "new_text": "conv_func->setDoesNotThrow()",
          "old_line_content": "                          BitCast(GetEmittedValueFor(convolution), ir_ptr_type),",
          "new_line_content": "      conv_func->setDoesNotThrow();",
          "content_same": false
        },
        {
          "line": 1282,
          "old_api": "BitCast",
          "new_api": "setOnlyAccessesArgMemory",
          "old_text": "BitCast(lhs_address, ir_ptr_type)",
          "new_text": "conv_func->setOnlyAccessesArgMemory()",
          "old_line_content": "                          BitCast(lhs_address, ir_ptr_type),",
          "new_line_content": "      conv_func->setOnlyAccessesArgMemory();",
          "content_same": false
        },
        {
          "line": 1283,
          "old_api": "BitCast",
          "new_api": "getInt64",
          "old_text": "BitCast(rhs_address, ir_ptr_type)",
          "new_text": "Call(conv_func, {\n                          GetExecutableRunOptionsArgument(),\n                          BitCast(GetEmittedValueFor(convolution), ir_ptr_type),\n                          BitCast(lhs_address, ir_ptr_type),\n                          BitCast(rhs_address, ir_ptr_type),\n                          b_.getInt64(input_batch),\n                          b_.getInt64(input_rows),\n                          b_.getInt64(input_cols),\n                          b_.getInt64(input_channels),\n                          b_.getInt64(kernel_rows),\n                          b_.getInt64(kernel_cols),\n                          b_.getInt64(kernel_channels),\n                          b_.getInt64(kernel_filters),\n                          b_.getInt64(output_rows),\n                          b_.getInt64(output_cols),\n                          b_.getInt64(row_stride),\n                          b_.getInt64(col_stride),\n                          b_.getInt64(padding_top),\n                          b_.getInt64(padding_bottom),\n                          b_.getInt64(padding_left),\n                          b_.getInt64(padding_right),\n                          b_.getInt64(lhs_row_dilation),\n                          b_.getInt64(lhs_col_dilation),\n                          b_.getInt64(rhs_row_dilation),\n                          b_.getInt64(rhs_col_dilation),\n                      })",
          "old_line_content": "                          BitCast(rhs_address, ir_ptr_type),",
          "new_line_content": "      Call(conv_func, {",
          "content_same": false
        },
        {
          "line": 1284,
          "old_api": "getInt64",
          "new_api": "GetExecutableRunOptionsArgument",
          "old_text": "b_.getInt64(input_batch)",
          "new_text": "GetExecutableRunOptionsArgument()",
          "old_line_content": "                          b_.getInt64(input_batch),",
          "new_line_content": "                          GetExecutableRunOptionsArgument(),",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": "getInt64",
          "new_api": "GetEmittedValueFor",
          "old_text": "b_.getInt64(input_rows)",
          "new_text": "GetEmittedValueFor(convolution)",
          "old_line_content": "                          b_.getInt64(input_rows),",
          "new_line_content": "                          BitCast(GetEmittedValueFor(convolution), ir_ptr_type),",
          "content_same": false
        },
        {
          "line": 1286,
          "old_api": "getInt64",
          "new_api": "BitCast",
          "old_text": "b_.getInt64(input_cols)",
          "new_text": "BitCast(lhs_address, ir_ptr_type)",
          "old_line_content": "                          b_.getInt64(input_cols),",
          "new_line_content": "                          BitCast(lhs_address, ir_ptr_type),",
          "content_same": false
        },
        {
          "line": 1287,
          "old_api": "getInt64",
          "new_api": "BitCast",
          "old_text": "b_.getInt64(input_channels)",
          "new_text": "BitCast(rhs_address, ir_ptr_type)",
          "old_line_content": "                          b_.getInt64(input_channels),",
          "new_line_content": "                          BitCast(rhs_address, ir_ptr_type),",
          "content_same": false
        },
        {
          "line": 1306,
          "old_api": "Status::OK()",
          "new_api": "getInt64",
          "old_text": "Status::OK()",
          "new_text": "b_.getInt64(rhs_row_dilation)",
          "old_line_content": "      return Status::OK();",
          "new_line_content": "                          b_.getInt64(rhs_row_dilation),",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": "operand",
          "new_api": "DefaultAction",
          "old_text": "fft->operand(0)",
          "new_text": "DefaultAction(convolution)",
          "old_line_content": "  auto operand = fft->operand(0);",
          "new_line_content": "  return DefaultAction(convolution);",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": "layout",
          "new_api": "operand",
          "old_text": "operand->shape().layout()",
          "new_text": "fft->operand(0)",
          "old_line_content": "  TF_RET_CHECK(LayoutUtil::IsMonotonicWithDim0Major(operand->shape().layout()));",
          "new_line_content": "  auto operand = fft->operand(0);",
          "content_same": false
        },
        {
          "line": 1325,
          "old_api": "layout",
          "new_api": "ElementTypesSameAndSupported",
          "old_text": "fft->shape().layout()",
          "new_text": "ElementTypesSameAndSupported(\n      /*instruction=*/*fft, /*operands=*/{operand},\n      /*supported_types=*/{F32, C64})",
          "old_line_content": "  TF_RET_CHECK(LayoutUtil::IsMonotonicWithDim0Major(fft->shape().layout()));",
          "new_line_content": "  TF_RETURN_IF_ERROR(ElementTypesSameAndSupported(",
          "content_same": false
        },
        {
          "line": 1329,
          "old_api": "GetEmittedValueFor",
          "new_api": "layout",
          "old_text": "GetEmittedValueFor(operand)",
          "new_text": "fft->shape().layout()",
          "old_line_content": "  llvm::Value* operand_address = GetEmittedValueFor(operand);",
          "new_line_content": "  TF_RET_CHECK(LayoutUtil::IsMonotonicWithDim0Major(fft->shape().layout()));",
          "content_same": false
        },
        {
          "line": 1330,
          "old_api": "EmitTargetAddressForOp",
          "new_api": "shape",
          "old_text": "EmitTargetAddressForOp(fft)",
          "new_text": "operand->shape()",
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(fft));",
          "new_line_content": "  VLOG(3) << \"operand=\" << ShapeUtil::HumanStringWithLayout(operand->shape());",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": "size",
          "new_api": "EmitTargetAddressForOp",
          "old_text": "fft_length.size()",
          "new_text": "EmitTargetAddressForOp(fft)",
          "old_line_content": "  for (int i = 0; i < fft->shape().dimensions_size() - fft_length.size(); i++) {",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(fft));",
          "content_same": false
        },
        {
          "line": 1339,
          "old_api": "getInt8Ty",
          "new_api": "dimensions",
          "old_text": "b_.getInt8Ty()->getPointerTo()",
          "new_text": "fft->shape().dimensions(i)",
          "old_line_content": "  llvm::Type* int8_ptr_type = b_.getInt8Ty()->getPointerTo();",
          "new_line_content": "    input_batch *= fft->shape().dimensions(i);",
          "content_same": false
        },
        {
          "line": 1343,
          "old_api": "getVoidTy",
          "new_api": "getInt8Ty",
          "old_text": "b_.getVoidTy()",
          "new_text": "b_.getInt8Ty()->getPointerTo()",
          "old_line_content": "      b_.getVoidTy(),",
          "new_line_content": "  llvm::Type* int8_ptr_type = b_.getInt8Ty()->getPointerTo();",
          "content_same": false
        },
        {
          "line": 1358,
          "old_api": "setOnlyAccessesInaccessibleMemOrArgMem",
          "new_api": "getCallee",
          "old_text": "fft_func->setOnlyAccessesInaccessibleMemOrArgMem()",
          "new_text": "llvm::dyn_cast<llvm::Function>(\n      module_->getOrInsertFunction(fn_name, fft_type).getCallee())",
          "old_line_content": "  fft_func->setOnlyAccessesInaccessibleMemOrArgMem();",
          "new_line_content": "  llvm::Function* fft_func = llvm::dyn_cast<llvm::Function>(",
          "content_same": false
        },
        {
          "line": 1359,
          "old_api": "size",
          "new_api": "getCallee",
          "old_text": "fft_length.size()",
          "new_text": "module_->getOrInsertFunction(fn_name, fft_type).getCallee()",
          "old_line_content": "  const int fft_rank = fft_length.size();",
          "new_line_content": "      module_->getOrInsertFunction(fn_name, fft_type).getCallee());",
          "content_same": false
        },
        {
          "line": 1360,
          "old_api": "getInt32",
          "new_api": "setCallingConv",
          "old_text": "Call(fft_func,\n       {GetExecutableRunOptionsArgument(),\n        BitCast(GetEmittedValueFor(fft), int8_ptr_type),\n        BitCast(operand_address, int8_ptr_type), b_.getInt32(fft->fft_type()),\n        b_.getInt32(fft_rank), b_.getInt64(input_batch),\n        b_.getInt64(fft_rank > 0 ? fft_length[0] : 0),\n        b_.getInt64(fft_rank > 1 ? fft_length[1] : 0),\n        b_.getInt64(fft_rank > 2 ? fft_length[2] : 0)})",
          "new_text": "fft_func->setCallingConv(llvm::CallingConv::C)",
          "old_line_content": "  Call(fft_func,",
          "new_line_content": "  fft_func->setCallingConv(llvm::CallingConv::C);",
          "content_same": false
        },
        {
          "line": 1361,
          "old_api": "GetExecutableRunOptionsArgument",
          "new_api": "setDoesNotThrow",
          "old_text": "GetExecutableRunOptionsArgument()",
          "new_text": "fft_func->setDoesNotThrow()",
          "old_line_content": "       {GetExecutableRunOptionsArgument(),",
          "new_line_content": "  fft_func->setDoesNotThrow();",
          "content_same": false
        },
        {
          "line": 1362,
          "old_api": "GetEmittedValueFor",
          "new_api": "setOnlyAccessesInaccessibleMemOrArgMem",
          "old_text": "GetEmittedValueFor(fft)",
          "new_text": "fft_func->setOnlyAccessesInaccessibleMemOrArgMem()",
          "old_line_content": "        BitCast(GetEmittedValueFor(fft), int8_ptr_type),",
          "new_line_content": "  fft_func->setOnlyAccessesInaccessibleMemOrArgMem();",
          "content_same": false
        },
        {
          "line": 1363,
          "old_api": "fft_type",
          "new_api": "size",
          "old_text": "fft->fft_type()",
          "new_text": "fft_length.size()",
          "old_line_content": "        BitCast(operand_address, int8_ptr_type), b_.getInt32(fft->fft_type()),",
          "new_line_content": "  const int fft_rank = fft_length.size();",
          "content_same": false
        },
        {
          "line": 1364,
          "old_api": "getInt64",
          "new_api": "getInt32",
          "old_text": "b_.getInt64(input_batch)",
          "new_text": "Call(fft_func,\n       {GetExecutableRunOptionsArgument(),\n        BitCast(GetEmittedValueFor(fft), int8_ptr_type),\n        BitCast(operand_address, int8_ptr_type), b_.getInt32(fft->fft_type()),\n        b_.getInt32(fft_rank), b_.getInt64(input_batch),\n        b_.getInt64(fft_rank > 0 ? fft_length[0] : 0),\n        b_.getInt64(fft_rank > 1 ? fft_length[1] : 0),\n        b_.getInt64(fft_rank > 2 ? fft_length[2] : 0)})",
          "old_line_content": "        b_.getInt32(fft_rank), b_.getInt64(input_batch),",
          "new_line_content": "  Call(fft_func,",
          "content_same": false
        },
        {
          "line": 1365,
          "old_api": "getInt64",
          "new_api": "GetExecutableRunOptionsArgument",
          "old_text": "b_.getInt64(fft_rank > 0 ? fft_length[0] : 0)",
          "new_text": "GetExecutableRunOptionsArgument()",
          "old_line_content": "        b_.getInt64(fft_rank > 0 ? fft_length[0] : 0),",
          "new_line_content": "       {GetExecutableRunOptionsArgument(),",
          "content_same": false
        },
        {
          "line": 1366,
          "old_api": "getInt64",
          "new_api": "GetEmittedValueFor",
          "old_text": "b_.getInt64(fft_rank > 1 ? fft_length[1] : 0)",
          "new_text": "GetEmittedValueFor(fft)",
          "old_line_content": "        b_.getInt64(fft_rank > 1 ? fft_length[1] : 0),",
          "new_line_content": "        BitCast(GetEmittedValueFor(fft), int8_ptr_type),",
          "content_same": false
        },
        {
          "line": 1367,
          "old_api": "getInt64",
          "new_api": "fft_type",
          "old_text": "b_.getInt64(fft_rank > 2 ? fft_length[2] : 0)",
          "new_text": "fft->fft_type()",
          "old_line_content": "        b_.getInt64(fft_rank > 2 ? fft_length[2] : 0)});",
          "new_line_content": "        BitCast(operand_address, int8_ptr_type), b_.getInt32(fft->fft_type()),",
          "content_same": false
        },
        {
          "line": 1369,
          "old_api": "Status::OK()",
          "new_api": "getInt64",
          "old_text": "Status::OK()",
          "new_text": "b_.getInt64(fft_rank > 0 ? fft_length[0] : 0)",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "        b_.getInt64(fft_rank > 0 ? fft_length[0] : 0),",
          "content_same": false
        },
        {
          "line": 1384,
          "old_api": "operand",
          "new_api": "EmitTargetAddressForOp",
          "old_text": "crs->operand(0)",
          "new_text": "EmitTargetAddressForOp(crs)",
          "old_line_content": "    return EmitMemcpy(*crs->operand(0), *crs);",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(crs));",
          "content_same": false
        },
        {
          "line": 1400,
          "old_api": "back",
          "new_api": "ToString",
          "old_text": "operand_ptrs.back()",
          "new_text": "crs->ToString()",
          "old_line_content": "    MemCpy(operand_ptrs.back(), /*DstAlign=*/1, in_ptr,",
          "new_line_content": "        << \"Operands to all-reduce must be arrays: \" << crs->ToString();",
          "content_same": false
        },
        {
          "line": 1401,
          "old_api": "ShapeUtil::ByteSizeOf(operand_shape)",
          "new_api": "EmitBufferPointer",
          "old_text": "ShapeUtil::ByteSizeOf(operand_shape)",
          "new_text": "EmitBufferPointer(out_slice, operand_shape)",
          "old_line_content": "           /*SrcAlign=*/1, ShapeUtil::ByteSizeOf(operand_shape));",
          "new_line_content": "    operand_ptrs.push_back(EmitBufferPointer(out_slice, operand_shape));",
          "content_same": false
        },
        {
          "line": 1404,
          "old_api": "Status::OK()",
          "new_api": "back",
          "old_text": "Status::OK()",
          "new_text": "operand_ptrs.back()",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "    MemCpy(operand_ptrs.back(), /*DstAlign=*/1, in_ptr,",
          "content_same": false
        },
        {
          "line": 1408,
          "old_api": "operand_count",
          "new_api": "Status::OK()",
          "old_text": "crs->operand_count()",
          "new_text": "Status::OK()",
          "old_line_content": "  CHECK_GE(crs->operand_count(), 1);",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 1412,
          "old_api": "[&] {\n    // TODO(cheshire): Fix duplication wrt. cpu_runtime\n    switch (datatype) {\n      case S8:\n      case U8:\n      case S32:\n      case U32:\n      case S64:\n      case U64:\n      case F16:\n      case F32:\n      case F64:\n        return true;\n      default:\n        return false;\n    }\n  }()",
          "new_api": "operand_count",
          "old_text": "[&] {\n    // TODO(cheshire): Fix duplication wrt. cpu_runtime\n    switch (datatype) {\n      case S8:\n      case U8:\n      case S32:\n      case U32:\n      case S64:\n      case U64:\n      case F16:\n      case F32:\n      case F64:\n        return true;\n      default:\n        return false;\n    }\n  }()",
          "new_text": "crs->operand_count()",
          "old_line_content": "  bool is_datatype_supported = [&] {",
          "new_line_content": "  CHECK_GE(crs->operand_count(), 1);",
          "content_same": false
        },
        {
          "line": 1435,
          "old_api": "to_apply",
          "new_api": "Unimplemented",
          "old_text": "crs->to_apply()",
          "new_text": "Unimplemented(\"AllReduce for datatype '%s' is not supported\",\n                         primitive_util::LowercasePrimitiveTypeName(datatype))",
          "old_line_content": "  if (!MatchReductionComputation(crs->to_apply()).has_value()) {",
          "new_line_content": "    return Unimplemented(\"AllReduce for datatype '%s' is not supported\",",
          "content_same": false
        },
        {
          "line": 1436,
          "old_api": "to_apply",
          "new_api": "primitive_util::LowercasePrimitiveTypeName(datatype)",
          "old_text": "Unimplemented(\"AllReduce for computation '%s' is not supported\",\n                         crs->to_apply()->ToString())",
          "new_text": "primitive_util::LowercasePrimitiveTypeName(datatype)",
          "old_line_content": "    return Unimplemented(\"AllReduce for computation '%s' is not supported\",",
          "new_line_content": "                         primitive_util::LowercasePrimitiveTypeName(datatype));",
          "content_same": false
        },
        {
          "line": 1440,
          "old_api": "getContext",
          "new_api": "to_apply",
          "old_text": "module_->getContext()",
          "new_text": "Unimplemented(\"AllReduce for computation '%s' is not supported\",\n                         crs->to_apply()->ToString())",
          "old_line_content": "  llvm::Type* i8_ptr_type = llvm::Type::getInt8PtrTy(module_->getContext());",
          "new_line_content": "    return Unimplemented(\"AllReduce for computation '%s' is not supported\",",
          "content_same": false
        },
        {
          "line": 1441,
          "old_api": "getInt32Ty",
          "new_api": "to_apply",
          "old_text": "b_.getInt32Ty()",
          "new_text": "crs->to_apply()->ToString()",
          "old_line_content": "  llvm::Type* int32_type = b_.getInt32Ty();",
          "new_line_content": "                         crs->to_apply()->ToString());",
          "content_same": false
        },
        {
          "line": 1444,
          "old_api": "getVoidTy",
          "new_api": "getContext",
          "old_text": "b_.getVoidTy()",
          "new_text": "module_->getContext()",
          "old_line_content": "      llvm::FunctionType::get(b_.getVoidTy(),",
          "new_line_content": "  llvm::Type* i8_ptr_type = llvm::Type::getInt8PtrTy(module_->getContext());",
          "content_same": false
        },
        {
          "line": 1462,
          "old_api": "setCallingConv",
          "new_api": "getCallee",
          "old_text": "all_reduce_func->setCallingConv(llvm::CallingConv::C)",
          "new_text": "module_\n          ->getOrInsertFunction(runtime::kAllReduceSymbolName,\n                                all_reduce_func_ty)\n          .getCallee()",
          "old_line_content": "  all_reduce_func->setCallingConv(llvm::CallingConv::C);",
          "new_line_content": "      module_",
          "content_same": false
        },
        {
          "line": 1466,
          "old_api": "CreateGlobalStringPtr",
          "new_api": "setCallingConv",
          "old_text": "b_.CreateGlobalStringPtr(replica_groups)",
          "new_text": "all_reduce_func->setCallingConv(llvm::CallingConv::C)",
          "old_line_content": "  llvm::Value* replica_groups_v = b_.CreateGlobalStringPtr(replica_groups);",
          "new_line_content": "  all_reduce_func->setCallingConv(llvm::CallingConv::C);",
          "content_same": false
        },
        {
          "line": 1468,
          "old_api": "operand",
          "new_api": "replica_groups",
          "old_text": "crs->operand(0)->shape()",
          "new_text": "crs->replica_groups()",
          "old_line_content": "  Shape shape = crs->operand(0)->shape();",
          "new_line_content": "  std::string replica_groups = ReplicaGroupsToString(crs->replica_groups());",
          "content_same": false
        },
        {
          "line": 1470,
          "old_api": "TF_ASSIGN_OR_RETURN",
          "new_api": "CreateGlobalStringPtr",
          "old_text": "TF_ASSIGN_OR_RETURN(\n      llvm::Value * shape_ptr,\n      llvm_ir::EncodeSelfDescribingShapeConstant(shape, &shape_length, &b_))",
          "new_text": "b_.CreateGlobalStringPtr(replica_groups)",
          "old_line_content": "  TF_ASSIGN_OR_RETURN(",
          "new_line_content": "  llvm::Value* replica_groups_v = b_.CreateGlobalStringPtr(replica_groups);",
          "content_same": false
        },
        {
          "line": 1472,
          "old_api": "llvm_ir::EncodeSelfDescribingShapeConstant(shape, &shape_length, &b_)",
          "new_api": "operand",
          "old_text": "llvm_ir::EncodeSelfDescribingShapeConstant(shape, &shape_length, &b_)",
          "new_text": "crs->operand(0)->shape()",
          "old_line_content": "      llvm_ir::EncodeSelfDescribingShapeConstant(shape, &shape_length, &b_));",
          "new_line_content": "  Shape shape = crs->operand(0)->shape();",
          "content_same": false
        },
        {
          "line": 1476,
          "old_api": "EmitBufferPointer",
          "new_api": "llvm_ir::EncodeSelfDescribingShapeConstant(shape, &shape_length, &b_)",
          "old_text": "EmitBufferPointer(input_slice, shape)",
          "new_text": "llvm_ir::EncodeSelfDescribingShapeConstant(shape, &shape_length, &b_)",
          "old_line_content": "  llvm::Value* input_buffer = EmitBufferPointer(input_slice, shape);",
          "new_line_content": "      llvm_ir::EncodeSelfDescribingShapeConstant(shape, &shape_length, &b_));",
          "content_same": false
        },
        {
          "line": 1492,
          "old_api": "GetModule",
          "new_api": "has_value",
          "old_text": "crs->GetModule()->unique_id()",
          "new_text": "crs->channel_id().has_value()",
          "old_line_content": "                        : crs->GetModule()->unique_id()),",
          "new_line_content": "        b_.getInt32(static_cast<int32>(crs->channel_id().has_value())),",
          "content_same": false
        },
        {
          "line": 1495,
          "old_api": "getInt32",
          "new_api": "channel_id",
          "old_text": "b_.getInt32(\n            static_cast<int32>(*MatchReductionComputation(crs->to_apply())))",
          "new_text": "crs->channel_id()",
          "old_line_content": "        b_.getInt32(",
          "new_line_content": "                        ? *crs->channel_id()",
          "content_same": false
        },
        {
          "line": 1496,
          "old_api": "to_apply",
          "new_api": "GetModule",
          "old_text": "crs->to_apply()",
          "new_text": "crs->GetModule()->unique_id()",
          "old_line_content": "            static_cast<int32>(*MatchReductionComputation(crs->to_apply()))),",
          "new_line_content": "                        : crs->GetModule()->unique_id()),",
          "content_same": false
        },
        {
          "line": 1508,
          "old_api": "replica_count",
          "new_api": "Status::OK()",
          "old_text": "hlo_module_config_.replica_count()",
          "new_text": "Status::OK()",
          "old_line_content": "  if (hlo_module_config_.replica_count() == 1) {",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 1515,
          "old_api": "EmitTargetAddressForOp",
          "new_api": "HandleAllReduceMultipleReplica",
          "old_text": "EmitTargetAddressForOp(hlo)",
          "new_text": "HandleAllReduceMultipleReplica(crs)",
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(hlo));",
          "new_line_content": "  return HandleAllReduceMultipleReplica(crs);",
          "content_same": false
        },
        {
          "line": 1522,
          "old_api": "getCallee",
          "new_api": "getVoidTy",
          "old_text": "llvm::dyn_cast<llvm::Function>(\n      module_\n          ->getOrInsertFunction(runtime::kReplicaIdSymbolName,\n                                replica_id_function_ty)\n          .getCallee())",
          "new_text": "b_.getVoidTy()",
          "old_line_content": "  auto* replica_id_func = llvm::dyn_cast<llvm::Function>(",
          "new_line_content": "      llvm::FunctionType::get(b_.getVoidTy(),",
          "content_same": false
        },
        {
          "line": 1527,
          "old_api": "setCallingConv",
          "new_api": "getCallee",
          "old_text": "replica_id_func->setCallingConv(llvm::CallingConv::C)",
          "new_text": "module_\n          ->getOrInsertFunction(runtime::kReplicaIdSymbolName,\n                                replica_id_function_ty)\n          .getCallee()",
          "old_line_content": "  replica_id_func->setCallingConv(llvm::CallingConv::C);",
          "new_line_content": "      module_",
          "content_same": false
        },
        {
          "line": 1531,
          "old_api": "CreateBitCast",
          "new_api": "setCallingConv",
          "old_text": "Call(replica_id_func,\n       {/*run_options=*/GetExecutableRunOptionsArgument(),\n        /*output_buffer=*/b_.CreateBitCast(output_buffer, i8_ptr_type)})",
          "new_text": "replica_id_func->setCallingConv(llvm::CallingConv::C)",
          "old_line_content": "  Call(replica_id_func,",
          "new_line_content": "  replica_id_func->setCallingConv(llvm::CallingConv::C);",
          "content_same": false
        },
        {
          "line": 1535,
          "old_api": "Status::OK()",
          "new_api": "CreateBitCast",
          "old_text": "Status::OK()",
          "new_text": "Call(replica_id_func,\n       {/*run_options=*/GetExecutableRunOptionsArgument(),\n        /*output_buffer=*/b_.CreateBitCast(output_buffer, i8_ptr_type)})",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  Call(replica_id_func,",
          "content_same": false
        },
        {
          "line": 1539,
          "old_api": "ToString",
          "new_api": "Status::OK()",
          "old_text": "parameter->ToString()",
          "new_text": "Status::OK()",
          "old_line_content": "  VLOG(2) << \"HandleParameter: \" << parameter->ToString();",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 1559,
          "old_api": "shape",
          "new_api": "dimensions",
          "old_text": "reduce.shape()",
          "new_text": "reduce.dimensions().begin()",
          "old_line_content": "  const Shape& result_shape = reduce.shape();",
          "new_line_content": "  absl::flat_hash_set<int64> reduced_dims(reduce.dimensions().begin(),",
          "content_same": false
        },
        {
          "line": 1562,
          "old_api": "dimensions_size",
          "new_api": "operand",
          "old_text": "operand_shape.dimensions_size()",
          "new_text": "reduce.operand(0)->shape()",
          "old_line_content": "  for (int64 i = 0; i < operand_shape.dimensions_size(); i++) {",
          "new_line_content": "  const Shape& operand_shape = reduce.operand(0)->shape();",
          "content_same": false
        },
        {
          "line": 1563,
          "old_api": "contains",
          "new_api": "shape",
          "old_text": "reduced_dims.contains(i)",
          "new_text": "reduce.shape()",
          "old_line_content": "    if (reduced_dims.contains(i)) {",
          "new_line_content": "  const Shape& result_shape = reduce.shape();",
          "content_same": false
        },
        {
          "line": 1566,
          "old_api": "InsertOrDie",
          "new_api": "dimensions_size",
          "old_text": "InsertOrDie(&unreduced_dim_map, i, i - delta)",
          "new_text": "operand_shape.dimensions_size()",
          "old_line_content": "      InsertOrDie(&unreduced_dim_map, i, i - delta);",
          "new_line_content": "  for (int64 i = 0; i < operand_shape.dimensions_size(); i++) {",
          "content_same": false
        },
        {
          "line": 1578,
          "old_api": "layout",
          "new_api": "dimensions_size",
          "old_text": "result_shape.layout().minor_to_major(result_dim_idx++)",
          "new_text": "operand_shape.dimensions_size()",
          "old_line_content": "          result_shape.layout().minor_to_major(result_dim_idx++)) {",
          "new_line_content": "       operand_dim_idx < operand_shape.dimensions_size(); operand_dim_idx++) {",
          "content_same": false
        },
        {
          "line": 1614,
          "old_api": "operand",
          "new_api": "ShapeUtil::ElementIsFloating(root_shape)",
          "old_text": "root_instruction->operand(0)",
          "new_text": "ShapeUtil::ElementIsFloating(root_shape)",
          "old_line_content": "  auto lhs = root_instruction->operand(0);",
          "new_line_content": "  bool root_is_floating_point = ShapeUtil::ElementIsFloating(root_shape);",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": "operand",
          "new_api": "ShapeUtil::ElementIsIntegral(root_shape)",
          "old_text": "root_instruction->operand(1)",
          "new_text": "ShapeUtil::ElementIsIntegral(root_shape)",
          "old_line_content": "  auto rhs = root_instruction->operand(1);",
          "new_line_content": "  bool root_is_integral = ShapeUtil::ElementIsIntegral(root_shape);",
          "content_same": false
        },
        {
          "line": 1618,
          "old_api": "parameter_instruction",
          "new_api": "operand",
          "old_text": "function->parameter_instruction(1)",
          "new_text": "root_instruction->operand(0)",
          "old_line_content": "  auto param_1 = function->parameter_instruction(1);",
          "new_line_content": "  auto lhs = root_instruction->operand(0);",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": "CreateSelect",
          "new_api": "getType",
          "old_text": "b->CreateSelect(\n            b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SGE\n                                         : llvm::ICmpInst::ICMP_UGE,\n                          lhs, rhs),\n            lhs, rhs)",
          "new_text": "llvm_ir::EmitCallToIntrinsic(llvm::Intrinsic::maxnum,\n                                              {lhs, rhs}, {lhs->getType()}, b)",
          "old_line_content": "        return b->CreateSelect(",
          "new_line_content": "          return llvm_ir::EmitCallToIntrinsic(llvm::Intrinsic::maxnum,",
          "content_same": false
        },
        {
          "line": 1676,
          "old_api": "CreateICmp",
          "new_api": "getType",
          "old_text": "b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SGE\n                                         : llvm::ICmpInst::ICMP_UGE,\n                          lhs, rhs)",
          "new_text": "lhs->getType()",
          "old_line_content": "            b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SGE",
          "new_line_content": "                                              {lhs, rhs}, {lhs->getType()}, b);",
          "content_same": false
        },
        {
          "line": 1691,
          "old_api": "CreateSelect",
          "new_api": "getType",
          "old_text": "b->CreateSelect(\n            b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SLE\n                                         : llvm::ICmpInst::ICMP_ULE,\n                          lhs, rhs),\n            lhs, rhs)",
          "new_text": "llvm_ir::EmitCallToIntrinsic(llvm::Intrinsic::minnum,\n                                              {lhs, rhs}, {lhs->getType()}, b)",
          "old_line_content": "        return b->CreateSelect(",
          "new_line_content": "          return llvm_ir::EmitCallToIntrinsic(llvm::Intrinsic::minnum,",
          "content_same": false
        },
        {
          "line": 1692,
          "old_api": "CreateICmp",
          "new_api": "getType",
          "old_text": "b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SLE\n                                         : llvm::ICmpInst::ICMP_ULE,\n                          lhs, rhs)",
          "new_text": "lhs->getType()",
          "old_line_content": "            b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SLE",
          "new_line_content": "                                              {lhs, rhs}, {lhs->getType()}, b);",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": "llvm_ir::PrimitiveTypeToIrType(element_type, module_)",
          "new_api": "ShapeUtil::ByteSizeOfPrimitiveType(element_type)",
          "old_text": "llvm_ir::PrimitiveTypeToIrType(element_type, module_)",
          "new_text": "ShapeUtil::ByteSizeOfPrimitiveType(element_type)",
          "old_line_content": "      llvm_ir::PrimitiveTypeToIrType(element_type, module_);",
          "new_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(element_type);",
          "content_same": false
        },
        {
          "line": 1766,
          "old_api": "GetEmittedValueFor",
          "new_api": "llvm_ir::EmitAllocaAtFunctionEntry(\n        accumulator_shard_type, \"accumulator\", &b_, 0)",
          "old_text": "GetEmittedValueFor(init_value)",
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n        accumulator_shard_type, \"accumulator\", &b_, 0)",
          "old_line_content": "  llvm::Value* init_value_ssa = Load(GetEmittedValueFor(init_value));",
          "new_line_content": "    accumulator.push_back(llvm_ir::EmitAllocaAtFunctionEntry(",
          "content_same": false
        },
        {
          "line": 1770,
          "old_api": "getType",
          "new_api": "GetEmittedValueFor",
          "old_text": "accumulator_shard->getType()->getPointerElementType()",
          "new_text": "GetEmittedValueFor(init_value)",
          "old_line_content": "    auto shard_type = accumulator_shard->getType()->getPointerElementType();",
          "new_line_content": "  llvm::Value* init_value_ssa = Load(GetEmittedValueFor(init_value));",
          "content_same": false
        },
        {
          "line": 1801,
          "old_api": "EmitArrayElementAddress",
          "new_api": "end",
          "old_text": "BitCast(\n      arg_array.EmitArrayElementAddress(input_index, &b_), b_.getInt8PtrTy())",
          "new_text": "output_index.end()",
          "old_line_content": "  llvm::Value* input_address = BitCast(",
          "new_line_content": "  CHECK(output_index.end() == it);",
          "content_same": false
        },
        {
          "line": 1802,
          "old_api": "getInt8PtrTy",
          "new_api": "shape",
          "old_text": "b_.getInt8PtrTy()",
          "new_text": "arg->shape()",
          "old_line_content": "      arg_array.EmitArrayElementAddress(input_index, &b_), b_.getInt8PtrTy());",
          "new_line_content": "  llvm_ir::IrArray::Index input_index(input_multi_index, arg->shape(),",
          "content_same": false
        },
        {
          "line": 1806,
          "old_api": "getType",
          "new_api": "getInt8PtrTy",
          "old_text": "accumulator[i]->getType()",
          "new_text": "b_.getInt8PtrTy()",
          "old_line_content": "        BitCast(input_address, accumulator[i]->getType());",
          "new_line_content": "      arg_array.EmitArrayElementAddress(input_index, &b_), b_.getInt8PtrTy());",
          "content_same": false
        },
        {
          "line": 1808,
          "old_api": "AlignedLoad",
          "new_api": "size",
          "old_text": "AlignedLoad(accumulator[i], element_alignment)",
          "new_text": "accumulator.size()",
          "old_line_content": "        AlignedLoad(accumulator[i], element_alignment);",
          "new_line_content": "  for (int i = 0; i < accumulator.size(); i++) {",
          "content_same": false
        },
        {
          "line": 1810,
          "old_api": "AnnotateLoadStoreInstructionWithMetadata",
          "new_api": "getType",
          "old_text": "arg_array.AnnotateLoadStoreInstructionWithMetadata(addend)",
          "new_text": "accumulator[i]->getType()",
          "old_line_content": "    arg_array.AnnotateLoadStoreInstructionWithMetadata(addend);",
          "new_line_content": "        BitCast(input_address, accumulator[i]->getType());",
          "content_same": false
        },
        {
          "line": 1813,
          "old_api": "reduction_generator",
          "new_api": "AlignedLoad",
          "old_text": "reduction_generator(&b_, current_accumulator_value, addend)",
          "new_text": "AlignedLoad(input_address_typed, element_alignment)",
          "old_line_content": "        reduction_generator(&b_, current_accumulator_value, addend);",
          "new_line_content": "    auto addend = AlignedLoad(input_address_typed, element_alignment);",
          "content_same": false
        },
        {
          "line": 1814,
          "old_api": "AlignedStore",
          "new_api": "AnnotateLoadStoreInstructionWithMetadata",
          "old_text": "AlignedStore(reduced_result, accumulator[i], element_alignment)",
          "new_text": "arg_array.AnnotateLoadStoreInstructionWithMetadata(addend)",
          "old_line_content": "    AlignedStore(reduced_result, accumulator[i], element_alignment);",
          "new_line_content": "    arg_array.AnnotateLoadStoreInstructionWithMetadata(addend);",
          "content_same": false
        },
        {
          "line": 1817,
          "old_api": "getType",
          "new_api": "reduction_generator",
          "old_text": "reduced_result->getType()",
          "new_text": "reduction_generator(&b_, current_accumulator_value, addend)",
          "old_line_content": "      input_address = ConstInBoundsGEP1_32(reduced_result->getType(),",
          "new_line_content": "        reduction_generator(&b_, current_accumulator_value, addend);",
          "content_same": false
        },
        {
          "line": 1841,
          "old_api": "AlignedStore",
          "new_api": "getType",
          "old_text": "AlignedStore(value_to_store[i], store_address_typed, alignment)",
          "new_text": "BitCast(store_address,\n                llvm::PointerType::getUnqual(value_to_store[i]->getType()))",
          "old_line_content": "        AlignedStore(value_to_store[i], store_address_typed, alignment);",
          "new_line_content": "        BitCast(store_address,",
          "content_same": false
        },
        {
          "line": 1842,
          "old_api": "AnnotateLoadStoreInstructionWithMetadata",
          "new_api": "getType",
          "old_text": "containing_array.AnnotateLoadStoreInstructionWithMetadata(\n        store_instruction)",
          "new_text": "value_to_store[i]->getType()",
          "old_line_content": "    containing_array.AnnotateLoadStoreInstructionWithMetadata(",
          "new_line_content": "                llvm::PointerType::getUnqual(value_to_store[i]->getType()));",
          "content_same": false
        },
        {
          "line": 1845,
          "old_api": "size",
          "new_api": "AlignedStore",
          "old_text": "value_to_store.size()",
          "new_text": "AlignedStore(value_to_store[i], store_address_typed, alignment)",
          "old_line_content": "    if (i != (value_to_store.size() - 1)) {",
          "new_line_content": "        AlignedStore(value_to_store[i], store_address_typed, alignment);",
          "content_same": false
        },
        {
          "line": 1846,
          "old_api": "getType",
          "new_api": "AnnotateLoadStoreInstructionWithMetadata",
          "old_text": "value_to_store[i]->getType()",
          "new_text": "containing_array.AnnotateLoadStoreInstructionWithMetadata(\n        store_instruction)",
          "old_line_content": "      store_address = ConstInBoundsGEP1_32(value_to_store[i]->getType(),",
          "new_line_content": "    containing_array.AnnotateLoadStoreInstructionWithMetadata(",
          "content_same": false
        },
        {
          "line": 1893,
          "old_api": "element_type",
          "new_api": "layout",
          "old_text": "reduce->shape().element_type()",
          "new_text": "absl::c_linear_search(\n      dimensions, LayoutUtil::Minor(arg->shape().layout(), 0))",
          "old_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(reduce->shape().element_type()),",
          "new_line_content": "  bool is_reduction_over_minor_dimension = absl::c_linear_search(",
          "content_same": false
        },
        {
          "line": 1894,
          "old_api": "element_type",
          "new_api": "layout",
          "old_text": "reduce->shape().element_type()",
          "new_text": "arg->shape().layout()",
          "old_line_content": "      MinimumAlignmentForPrimitiveType(reduce->shape().element_type()));",
          "new_line_content": "      dimensions, LayoutUtil::Minor(arg->shape().layout(), 0));",
          "content_same": false
        },
        {
          "line": 1932,
          "old_api": "dimensions",
          "new_api": "shape",
          "old_text": "reduce->shape().dimensions(dimension)",
          "new_text": "reduce->shape()",
          "old_line_content": "    int64 end_index = reduce->shape().dimensions(dimension);",
          "new_line_content": "  for (int i = LayoutUtil::MinorToMajor(reduce->shape()).size() - 1; i > 0;",
          "content_same": false
        },
        {
          "line": 1934,
          "old_api": "absl::StrFormat(\"dim.%d\", dimension)",
          "new_api": "layout",
          "old_text": "absl::StrFormat(\"dim.%d\", dimension)",
          "new_text": "reduce->shape().layout()",
          "old_line_content": "        start_index, end_index, absl::StrFormat(\"dim.%d\", dimension));",
          "new_line_content": "    int64 dimension = LayoutUtil::Minor(reduce->shape().layout(), i);",
          "content_same": false
        },
        {
          "line": 1938,
          "old_api": "layout",
          "new_api": "absl::StrFormat(\"dim.%d\", dimension)",
          "old_text": "reduce->shape().layout()",
          "new_text": "absl::StrFormat(\"dim.%d\", dimension)",
          "old_line_content": "  int64 innermost_dimension = LayoutUtil::Minor(reduce->shape().layout(), 0);",
          "new_line_content": "        start_index, end_index, absl::StrFormat(\"dim.%d\", dimension));",
          "content_same": false
        },
        {
          "line": 1944,
          "old_api": "SetToFirstInsertPoint",
          "new_api": "dimensions",
          "old_text": "SetToFirstInsertPoint(innermost_body_bb, &b_)",
          "new_text": "reduce->shape().dimensions(innermost_dimension)",
          "old_line_content": "    SetToFirstInsertPoint(innermost_body_bb, &b_);",
          "new_line_content": "      reduce->shape().dimensions(innermost_dimension);",
          "content_same": false
        },
        {
          "line": 1947,
          "old_api": "GetOuterLoopExitBasicBlock",
          "new_api": "GetInnerLoopBodyBasicBlock",
          "old_text": "loop_nest.GetOuterLoopExitBasicBlock()",
          "new_text": "loop_nest.GetInnerLoopBodyBasicBlock()",
          "old_line_content": "  auto outermost_loop_exit_block = loop_nest.GetOuterLoopExitBasicBlock();",
          "new_line_content": "          loop_nest.GetInnerLoopBodyBasicBlock()) {",
          "content_same": false
        },
        {
          "line": 1958,
          "old_api": "GetBodyBasicBlock",
          "new_api": "AddLoop",
          "old_text": "loop->GetBodyBasicBlock()",
          "new_text": "loop_nest.AddLoop(start_index, end_index, vectorization_factor,\n                          absl::StrFormat(\"dim.%d\", innermost_dimension))",
          "old_line_content": "    SetToFirstInsertPoint(loop->GetBodyBasicBlock(), &b_);",
          "new_line_content": "        loop_nest.AddLoop(start_index, end_index, vectorization_factor,",
          "content_same": false
        },
        {
          "line": 1960,
          "old_api": "element_type",
          "new_api": "GetIndVarValue",
          "old_text": "CreateShardedVectorType(\n        reduce->shape().element_type(), vectorization_factor)",
          "new_text": "loop->GetIndVarValue()",
          "old_line_content": "    ShardedVectorType vector_type = CreateShardedVectorType(",
          "new_line_content": "    array_multi_index[innermost_dimension] = loop->GetIndVarValue();",
          "content_same": false
        },
        {
          "line": 1962,
          "old_api": "shape",
          "new_api": "GetBodyBasicBlock",
          "old_text": "reduce->shape()",
          "new_text": "loop->GetBodyBasicBlock()",
          "old_line_content": "    llvm_ir::IrArray::Index array_index(array_multi_index, reduce->shape(),",
          "new_line_content": "    SetToFirstInsertPoint(loop->GetBodyBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 1975,
          "old_api": "GetExitBasicBlock",
          "new_api": "EmitArrayElementAddress",
          "old_text": "loop->GetExitBasicBlock()->getTerminator()",
          "new_text": "target_array.EmitArrayElementAddress(array_index, &b_)",
          "old_line_content": "    if (auto exit_terminator = loop->GetExitBasicBlock()->getTerminator()) {",
          "new_line_content": "        target_array.EmitArrayElementAddress(array_index, &b_);",
          "content_same": false
        },
        {
          "line": 1976,
          "old_api": "shape",
          "new_api": "EmitShardedVectorStore",
          "old_text": "reduce->shape()",
          "new_text": "EmitShardedVectorStore(output_address, accumulator, element_alignment,\n                           target_array)",
          "old_line_content": "      CHECK_GT(LayoutUtil::MinorToMajor(reduce->shape()).size(), 1);",
          "new_line_content": "    EmitShardedVectorStore(output_address, accumulator, element_alignment,",
          "content_same": false
        },
        {
          "line": 1979,
          "old_api": "shape",
          "new_api": "GetExitBasicBlock",
          "old_text": "reduce->shape()",
          "new_text": "loop->GetExitBasicBlock()->getTerminator()",
          "old_line_content": "      CHECK_EQ(LayoutUtil::MinorToMajor(reduce->shape()).size(), 1);",
          "new_line_content": "    if (auto exit_terminator = loop->GetExitBasicBlock()->getTerminator()) {",
          "content_same": false
        },
        {
          "line": 1980,
          "old_api": "GetExitBasicBlock",
          "new_api": "shape",
          "old_text": "loop->GetExitBasicBlock()",
          "new_text": "reduce->shape()",
          "old_line_content": "      b_.SetInsertPoint(loop->GetExitBasicBlock());",
          "new_line_content": "      CHECK_GT(LayoutUtil::MinorToMajor(reduce->shape()).size(), 1);",
          "content_same": false
        },
        {
          "line": 1994,
          "old_api": "element_type",
          "new_api": "getInt64",
          "old_text": "reduce->shape().element_type()",
          "new_text": "b_.getInt64(innermost_dimension_size -\n                    (innermost_dimension_size % vectorization_factor))",
          "old_line_content": "        reduce->shape().element_type(),",
          "new_line_content": "        b_.getInt64(innermost_dimension_size -",
          "content_same": false
        },
        {
          "line": 1997,
          "old_api": "getInt64Ty",
          "new_api": "element_type",
          "old_text": "b_.getInt64Ty()",
          "new_text": "CreateShardedVectorType(\n        reduce->shape().element_type(),\n        innermost_dimension_size % vectorization_factor)",
          "old_line_content": "                                        b_.getInt64Ty());",
          "new_line_content": "    ShardedVectorType vector_type = CreateShardedVectorType(",
          "content_same": false
        },
        {
          "line": 2026,
          "old_api": "IsTuple",
          "new_api": "shape",
          "old_text": "out_shape.IsTuple()",
          "new_text": "reduce->shape()",
          "old_line_content": "    CHECK(out_shape.IsTuple());",
          "new_line_content": "  const Shape& out_shape = reduce->shape();",
          "content_same": false
        },
        {
          "line": 2027,
          "old_api": "tuple_shapes_size",
          "new_api": "IsArray",
          "old_text": "out_shape.tuple_shapes_size()",
          "new_text": "out_shape.IsArray()",
          "old_line_content": "    accumulators_count = out_shape.tuple_shapes_size();",
          "new_line_content": "  bool is_variadic = !out_shape.IsArray();",
          "content_same": false
        },
        {
          "line": 2030,
          "old_api": "dimensions",
          "new_api": "IsTuple",
          "old_text": "reduce->dimensions()",
          "new_text": "out_shape.IsTuple()",
          "old_line_content": "  absl::Span<const int64> reduced_dimensions(reduce->dimensions());",
          "new_line_content": "    CHECK(out_shape.IsTuple());",
          "content_same": false
        },
        {
          "line": 2040,
          "old_api": "push_back",
          "new_api": "tuple_shapes",
          "old_text": "accumulator_types.push_back(accumulator_llvm_type)",
          "new_text": "out_shape.tuple_shapes(i)",
          "old_line_content": "    accumulator_types.push_back(accumulator_llvm_type);",
          "new_line_content": "        is_variadic ? out_shape.tuple_shapes(i) : out_shape;",
          "content_same": false
        },
        {
          "line": 2043,
          "old_api": "llvm_ir::EmitAllocaAtFunctionEntry(\n        accumulator_llvm_type, \"accumulator_\" + std::to_string(i), &b_,\n        MinimumAlignmentForPrimitiveType(accumulator_type))",
          "new_api": "llvm_ir::PrimitiveTypeToIrType(accumulator_type, module_)",
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n        accumulator_llvm_type, \"accumulator_\" + std::to_string(i), &b_,\n        MinimumAlignmentForPrimitiveType(accumulator_type))",
          "new_text": "llvm_ir::PrimitiveTypeToIrType(accumulator_type, module_)",
          "old_line_content": "    llvm::AllocaInst* accumulator_addr = llvm_ir::EmitAllocaAtFunctionEntry(",
          "new_line_content": "        llvm_ir::PrimitiveTypeToIrType(accumulator_type, module_);",
          "content_same": false
        },
        {
          "line": 2044,
          "old_api": "std::to_string(i)",
          "new_api": "push_back",
          "old_text": "std::to_string(i)",
          "new_text": "accumulator_types.push_back(accumulator_llvm_type)",
          "old_line_content": "        accumulator_llvm_type, \"accumulator_\" + std::to_string(i), &b_,",
          "new_line_content": "    accumulator_types.push_back(accumulator_llvm_type);",
          "content_same": false
        },
        {
          "line": 2049,
          "old_api": "Store",
          "new_api": "MinimumAlignmentForPrimitiveType",
          "old_text": "Store(init_value, accumulator_addr)",
          "new_text": "MinimumAlignmentForPrimitiveType(accumulator_type)",
          "old_line_content": "    Store(init_value, accumulator_addr);",
          "new_line_content": "        MinimumAlignmentForPrimitiveType(accumulator_type));",
          "content_same": false
        },
        {
          "line": 2084,
          "old_api": "Load",
          "new_api": "getInt64Ty",
          "old_text": "Load(accum)",
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "    llvm::Value* accum_value = Load(accum);",
          "new_line_content": "                                      b_.getInt64Ty());",
          "content_same": false
        },
        {
          "line": 2095,
          "old_api": "to_apply",
          "new_api": "push_back",
          "old_text": "reduce->to_apply()",
          "new_text": "reduction_operands.push_back(input_element)",
          "old_line_content": "      *reduce->to_apply(), reduction_operands, \"reduce_function\");",
          "new_line_content": "    reduction_operands.push_back(input_element);",
          "content_same": false
        },
        {
          "line": 2099,
          "old_api": "Store",
          "new_api": "to_apply",
          "old_text": "Store(results[i], accumulator_addrs[i])",
          "new_text": "reduce->to_apply()",
          "old_line_content": "    Store(results[i], accumulator_addrs[i]);",
          "new_line_content": "      *reduce->to_apply(), reduction_operands, \"reduce_function\");",
          "content_same": false
        },
        {
          "line": 2101,
          "old_api": "GetOuterLoopExitBasicBlock",
          "new_api": "size",
          "old_text": "loops.GetOuterLoopExitBasicBlock()",
          "new_text": "results.size()",
          "old_line_content": "  SetToFirstInsertPoint(loops.GetOuterLoopExitBasicBlock(), &b_);",
          "new_line_content": "  CHECK(results.size() == accumulators_count);",
          "content_same": false
        },
        {
          "line": 2105,
          "old_api": "getContext",
          "new_api": "GetOuterLoopExitBasicBlock",
          "old_text": "llvm::UndefValue::get(\n        llvm::StructType::get(b_.getContext(), accumulator_types))",
          "new_text": "loops.GetOuterLoopExitBasicBlock()",
          "old_line_content": "    llvm::Value* returned_structure = llvm::UndefValue::get(",
          "new_line_content": "  SetToFirstInsertPoint(loops.GetOuterLoopExitBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 2110,
          "old_api": "CreateInsertValue",
          "new_api": "getContext",
          "old_text": "b_.CreateInsertValue(returned_structure, accumulator_value, i)",
          "new_text": "b_.getContext()",
          "old_line_content": "          b_.CreateInsertValue(returned_structure, accumulator_value, i);",
          "new_line_content": "        llvm::StructType::get(b_.getContext(), accumulator_types));",
          "content_same": false
        },
        {
          "line": 2114,
          "old_api": "size",
          "new_api": "CreateInsertValue",
          "old_text": "accumulator_addrs.size()",
          "new_text": "b_.CreateInsertValue(returned_structure, accumulator_value, i)",
          "old_line_content": "    CHECK_EQ(accumulator_addrs.size(), 1);",
          "new_line_content": "          b_.CreateInsertValue(returned_structure, accumulator_value, i);",
          "content_same": false
        },
        {
          "line": 2124,
          "old_api": "options::VectorizedReduceDisabled(hlo_module_config_)",
          "new_api": "mutable_operand",
          "old_text": "options::VectorizedReduceDisabled(hlo_module_config_)",
          "new_text": "reduce->mutable_operand(0)",
          "old_line_content": "  if (!options::VectorizedReduceDisabled(hlo_module_config_)) {",
          "new_line_content": "  auto arg = reduce->mutable_operand(0);",
          "content_same": false
        },
        {
          "line": 2144,
          "old_api": "Unimplemented",
          "new_api": "DefaultAction",
          "old_text": "Unimplemented(\"AllToAll is not implemented on CPU.\")",
          "new_text": "DefaultAction(reduce)",
          "old_line_content": "  return Unimplemented(\"AllToAll is not implemented on CPU.\");",
          "new_line_content": "  return DefaultAction(reduce);",
          "content_same": false
        },
        {
          "line": 2162,
          "old_api": "ToString",
          "new_api": "Unimplemented",
          "old_text": "slice->ToString()",
          "new_text": "Unimplemented(\"Scatter is not implemented on CPUs.\")",
          "old_line_content": "  VLOG(2) << \"HandleSlice: \" << slice->ToString();",
          "new_line_content": "  return Unimplemented(\"Scatter is not implemented on CPUs.\");",
          "content_same": false
        },
        {
          "line": 2166,
          "old_api": "ShouldEmitParallelLoopFor",
          "new_api": "ToString",
          "old_text": "ShouldEmitParallelLoopFor(*slice)",
          "new_text": "slice->ToString()",
          "old_line_content": "  if (ShouldEmitParallelLoopFor(*slice)) {",
          "new_line_content": "  VLOG(2) << \"HandleSlice: \" << slice->ToString();",
          "content_same": false
        },
        {
          "line": 2167,
          "old_api": "DefaultAction",
          "new_api": "operand",
          "old_text": "DefaultAction(slice)",
          "new_text": "slice->operand(0)",
          "old_line_content": "    return DefaultAction(slice);",
          "new_line_content": "  auto operand = slice->operand(0);",
          "content_same": false
        },
        {
          "line": 2171,
          "old_api": "layout",
          "new_api": "DefaultAction",
          "old_text": "slice->shape().layout()",
          "new_text": "DefaultAction(slice)",
          "old_line_content": "  if (!LayoutUtil::Equal(operand->shape().layout(), slice->shape().layout())) {",
          "new_line_content": "    return DefaultAction(slice);",
          "content_same": false
        },
        {
          "line": 2175,
          "old_api": "EmitTargetAddressForOp",
          "new_api": "layout",
          "old_text": "EmitTargetAddressForOp(slice)",
          "new_text": "slice->shape().layout()",
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(slice));",
          "new_line_content": "  if (!LayoutUtil::Equal(operand->shape().layout(), slice->shape().layout())) {",
          "content_same": false
        },
        {
          "line": 2181,
          "old_api": "layout",
          "new_api": "shape",
          "old_text": "operand->shape().layout()",
          "new_text": "slice->shape()",
          "old_line_content": "  const Layout& layout = operand->shape().layout();",
          "new_line_content": "  if (ShapeUtil::IsZeroElementArray(slice->shape())) {",
          "content_same": false
        },
        {
          "line": 2182,
          "old_api": "dimensions_size",
          "new_api": "Status::OK()",
          "old_text": "operand->shape().dimensions_size()",
          "new_text": "Status::OK()",
          "old_line_content": "  const int64 num_dims = operand->shape().dimensions_size();",
          "new_line_content": "    return Status::OK();",
          "content_same": false
        },
        {
          "line": 2201,
          "old_api": "insert",
          "new_api": "LayoutUtil::MinorToMajor(layout)",
          "old_text": "inner_dims.insert(dim)",
          "new_text": "LayoutUtil::MinorToMajor(layout)",
          "old_line_content": "    inner_dims.insert(dim);",
          "new_line_content": "  for (int64 dim : LayoutUtil::MinorToMajor(layout)) {",
          "content_same": false
        },
        {
          "line": 2220,
          "old_api": "ShapeUtil::ElementsIn(logical_element_shape)",
          "new_api": "contains",
          "old_text": "ShapeUtil::ElementsIn(logical_element_shape)",
          "new_text": "inner_dims.contains(dim)",
          "old_line_content": "      ShapeUtil::ElementsIn(logical_element_shape);",
          "new_line_content": "      [&inner_dims](int64 dim) { return inner_dims.contains(dim); },",
          "content_same": false
        },
        {
          "line": 2224,
          "old_api": "size",
          "new_api": "ShapeUtil::ElementsIn(logical_element_shape)",
          "old_text": "inner_dims.size()",
          "new_text": "ShapeUtil::ElementsIn(logical_element_shape)",
          "old_line_content": "  const int64 memcpy_dim = LayoutUtil::Minor(layout, inner_dims.size());",
          "new_line_content": "      ShapeUtil::ElementsIn(logical_element_shape);",
          "content_same": false
        },
        {
          "line": 2261,
          "old_api": "getInt64Ty",
          "new_api": "end",
          "old_text": "b_.getInt64Ty()",
          "new_text": "target_multi_index.end()",
          "old_line_content": "                                       b_.getInt64Ty());",
          "new_line_content": "  std::replace(target_multi_index.begin(), target_multi_index.end(),",
          "content_same": false
        },
        {
          "line": 2264,
          "old_api": "GetInnerLoopBodyBasicBlock",
          "new_api": "shape",
          "old_text": "loops.GetInnerLoopBodyBasicBlock()",
          "new_text": "slice->shape()",
          "old_line_content": "    SetToFirstInsertPoint(loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "new_line_content": "  llvm_ir::IrArray::Index target_index(target_multi_index, slice->shape(),",
          "content_same": false
        },
        {
          "line": 2268,
          "old_api": "SourceIndexOfSlice",
          "new_api": "GetInnerLoopBodyBasicBlock",
          "old_text": "target_index.SourceIndexOfSlice(\n      /*operand_shape=*/operand->shape(), /*starts=*/slice->slice_starts(),\n      /*strides=*/slice->slice_strides(), /*builder=*/&b_)",
          "new_text": "loops.GetInnerLoopBodyBasicBlock()",
          "old_line_content": "  const llvm_ir::IrArray::Index source_index = target_index.SourceIndexOfSlice(",
          "new_line_content": "    SetToFirstInsertPoint(loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 2273,
          "old_api": "EmitArrayElementAddress",
          "new_api": "slice_starts",
          "old_text": "target_array.EmitArrayElementAddress(target_index, &b_, \"slice.dest\")",
          "new_text": "slice->slice_starts()",
          "old_line_content": "      target_array.EmitArrayElementAddress(target_index, &b_, \"slice.dest\");",
          "new_line_content": "      /*operand_shape=*/operand->shape(), /*starts=*/slice->slice_starts(),",
          "content_same": false
        },
        {
          "line": 2284,
          "old_api": "VLOG_IS_ON",
          "new_api": "element_type",
          "old_text": "VLOG_IS_ON(2)",
          "new_text": "EmitTransferElements(memcpy_dest, memcpy_source, memcpy_elements,\n                       slice->shape().element_type(), target_array,\n                       source_array)",
          "old_line_content": "  if (VLOG_IS_ON(2)) {",
          "new_line_content": "  EmitTransferElements(memcpy_dest, memcpy_source, memcpy_elements,",
          "content_same": false
        },
        {
          "line": 2299,
          "old_api": "shape",
          "new_api": "Status::OK()",
          "old_text": "dynamic_slice->shape()",
          "new_text": "Status::OK()",
          "old_line_content": "  if (ShapeUtil::IsScalar(dynamic_slice->shape())) {",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2303,
          "old_api": "DefaultAction",
          "new_api": "shape",
          "old_text": "DefaultAction(dynamic_slice)",
          "new_text": "dynamic_slice->shape()",
          "old_line_content": "  return DefaultAction(dynamic_slice);",
          "new_line_content": "  if (ShapeUtil::IsScalar(dynamic_slice->shape())) {",
          "content_same": false
        },
        {
          "line": 2312,
          "old_api": "llvm_ir::CanUpdateDynamicSliceInPlace(dynamic_update_slice,\n                                                   assignment_)",
          "new_api": "operand",
          "old_text": "llvm_ir::CanUpdateDynamicSliceInPlace(dynamic_update_slice,\n                                                   assignment_)",
          "new_text": "dynamic_update_slice->operand(1)",
          "old_line_content": "  } else if (llvm_ir::CanUpdateDynamicSliceInPlace(dynamic_update_slice,",
          "new_line_content": "  auto update = dynamic_update_slice->operand(1);",
          "content_same": false
        },
        {
          "line": 2315,
          "old_api": "GetIrArraysForOperandsOf",
          "new_api": "EmitMemcpy",
          "old_text": "GetIrArraysForOperandsOf(dynamic_update_slice)",
          "new_text": "EmitMemcpy(*update, *dynamic_update_slice)",
          "old_line_content": "    auto operands = GetIrArraysForOperandsOf(dynamic_update_slice);",
          "new_line_content": "    return EmitMemcpy(*update, *dynamic_update_slice);",
          "content_same": false
        },
        {
          "line": 2316,
          "old_api": "llvm_ir::EmitDynamicUpdateSliceInPlace(\n        operands, GetIrArrayFor(dynamic_update_slice),\n        IrName(dynamic_update_slice, \"in_place\"), &b_)",
          "new_api": "llvm_ir::CanUpdateDynamicSliceInPlace(dynamic_update_slice,\n                                                   assignment_)",
          "old_text": "llvm_ir::EmitDynamicUpdateSliceInPlace(\n        operands, GetIrArrayFor(dynamic_update_slice),\n        IrName(dynamic_update_slice, \"in_place\"), &b_)",
          "new_text": "llvm_ir::CanUpdateDynamicSliceInPlace(dynamic_update_slice,\n                                                   assignment_)",
          "old_line_content": "    return llvm_ir::EmitDynamicUpdateSliceInPlace(",
          "new_line_content": "  } else if (llvm_ir::CanUpdateDynamicSliceInPlace(dynamic_update_slice,",
          "content_same": false
        },
        {
          "line": 2318,
          "old_api": "IrName",
          "new_api": "EmitTargetAddressForOp",
          "old_text": "IrName(dynamic_update_slice, \"in_place\")",
          "new_text": "EmitTargetAddressForOp(dynamic_update_slice)",
          "old_line_content": "        IrName(dynamic_update_slice, \"in_place\"), &b_);",
          "new_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(dynamic_update_slice));",
          "content_same": false
        },
        {
          "line": 2320,
          "old_api": "DefaultAction",
          "new_api": "llvm_ir::EmitDynamicUpdateSliceInPlace(\n        operands, GetIrArrayFor(dynamic_update_slice),\n        IrName(dynamic_update_slice, \"in_place\"), &b_)",
          "old_text": "DefaultAction(dynamic_update_slice)",
          "new_text": "llvm_ir::EmitDynamicUpdateSliceInPlace(\n        operands, GetIrArrayFor(dynamic_update_slice),\n        IrName(dynamic_update_slice, \"in_place\"), &b_)",
          "old_line_content": "  return DefaultAction(dynamic_update_slice);",
          "new_line_content": "    return llvm_ir::EmitDynamicUpdateSliceInPlace(",
          "content_same": false
        },
        {
          "line": 2342,
          "old_api": "ToString",
          "new_api": "edge_padding_high",
          "old_text": "pad->ToString()",
          "new_text": "padding_dimension.edge_padding_high()",
          "old_line_content": "          pad->ToString());",
          "new_line_content": "        padding_dimension.edge_padding_high() < 0) {",
          "content_same": false
        },
        {
          "line": 2351,
          "old_api": "GetEmittedValueFor",
          "new_api": "operand",
          "old_text": "GetEmittedValueFor(padding_value)",
          "new_text": "EmitTargetElementLoop(\n      pad, \"initialize\",\n      [this, pad](const llvm_ir::IrArray::Index& target_index) {\n        const HloInstruction* padding_value = pad->operand(1);\n        llvm::Value* padding_value_addr = GetEmittedValueFor(padding_value);\n        return Load(padding_value_addr);\n      })",
          "old_line_content": "        llvm::Value* padding_value_addr = GetEmittedValueFor(padding_value);",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetElementLoop(",
          "content_same": false
        },
        {
          "line": 2362,
          "old_api": "GetInnerLoopBodyBasicBlock",
          "new_api": "operand",
          "old_text": "loops.GetInnerLoopBodyBasicBlock()",
          "new_text": "pad->operand(0)",
          "old_line_content": "  SetToFirstInsertPoint(loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "new_line_content": "  const HloInstruction* operand = pad->operand(0);",
          "content_same": false
        },
        {
          "line": 2371,
          "old_api": "padding_config",
          "new_api": "EmitReadArrayElement",
          "old_text": "pad->padding_config()",
          "new_text": "operand_array.EmitReadArrayElement(operand_index, &b_)",
          "old_line_content": "  const PaddingConfig& padding_config = pad->padding_config();",
          "new_line_content": "      operand_array.EmitReadArrayElement(operand_index, &b_);",
          "content_same": false
        },
        {
          "line": 2375,
          "old_api": "getInt64",
          "new_api": "padding_config",
          "old_text": "Mul(operand_index[i],\n            b_.getInt64(padding_config.dimensions(i).interior_padding() + 1))",
          "new_text": "pad->padding_config()",
          "old_line_content": "        Mul(operand_index[i],",
          "new_line_content": "  const PaddingConfig& padding_config = pad->padding_config();",
          "content_same": false
        },
        {
          "line": 2377,
          "old_api": "getInt64",
          "new_api": "size",
          "old_text": "Add(\n        offset, b_.getInt64(padding_config.dimensions(i).edge_padding_low()))",
          "new_text": "operand_index.size()",
          "old_line_content": "    llvm::Value* index = Add(",
          "new_line_content": "  for (size_t i = 0; i < operand_index.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2379,
          "old_api": "push_back",
          "new_api": "getInt64",
          "old_text": "output_multi_index.push_back(index)",
          "new_text": "Mul(operand_index[i],\n            b_.getInt64(padding_config.dimensions(i).interior_padding() + 1))",
          "old_line_content": "    output_multi_index.push_back(index);",
          "new_line_content": "        Mul(operand_index[i],",
          "content_same": false
        },
        {
          "line": 2389,
          "old_api": "Status::OK()",
          "new_api": "GetType",
          "old_text": "Status::OK()",
          "new_text": "operand_index.GetType()",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "      output_multi_index, output_array.GetShape(), operand_index.GetType());",
          "content_same": false
        },
        {
          "line": 2393,
          "old_api": "fused_expression_root",
          "new_api": "Status::OK()",
          "old_text": "fusion->fused_expression_root()",
          "new_text": "Status::OK()",
          "old_line_content": "  auto* root = fusion->fused_expression_root();",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2397,
          "old_api": "EmitTargetAddressForOp",
          "new_api": "fused_expression_root",
          "old_text": "EmitTargetAddressForOp(fusion)",
          "new_text": "fusion->fused_expression_root()",
          "old_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(fusion));",
          "new_line_content": "  auto* root = fusion->fused_expression_root();",
          "content_same": false
        },
        {
          "line": 2399,
          "old_api": "llvm_ir::EmitFusedDynamicUpdateSliceInPlace(\n        fusion, GetGeneratorForOperandIrArrays(fusion), GetIrArrayFor(fusion),\n        &elemental_emitter, &b_)",
          "new_api": "VLOG",
          "old_text": "llvm_ir::EmitFusedDynamicUpdateSliceInPlace(\n        fusion, GetGeneratorForOperandIrArrays(fusion), GetIrArrayFor(fusion),\n        &elemental_emitter, &b_)",
          "new_text": "VLOG(3)",
          "old_line_content": "    return llvm_ir::EmitFusedDynamicUpdateSliceInPlace(",
          "new_line_content": "    VLOG(3) << \"HandleFusion FusedDynamicUpdateSliceInPlace\";",
          "content_same": false
        },
        {
          "line": 2403,
          "old_api": "VLOG",
          "new_api": "llvm_ir::EmitFusedDynamicUpdateSliceInPlace(\n        fusion, GetGeneratorForOperandIrArrays(fusion), GetIrArrayFor(fusion),\n        &elemental_emitter, &b_)",
          "old_text": "VLOG(3)",
          "new_text": "llvm_ir::EmitFusedDynamicUpdateSliceInPlace(\n        fusion, GetGeneratorForOperandIrArrays(fusion), GetIrArrayFor(fusion),\n        &elemental_emitter, &b_)",
          "old_line_content": "    VLOG(3) << \"HandleFusion kLoop\";",
          "new_line_content": "    return llvm_ir::EmitFusedDynamicUpdateSliceInPlace(",
          "content_same": false
        },
        {
          "line": 2406,
          "old_api": "GetGeneratorForOperandIrArrays",
          "new_api": "IsLoopFusion",
          "old_text": "GetGeneratorForOperandIrArrays(fusion)",
          "new_text": "fusion->IsLoopFusion()",
          "old_line_content": "    FusedIrEmitter fused_emitter(GetGeneratorForOperandIrArrays(fusion),",
          "new_line_content": "  } else if (fusion->IsLoopFusion()) {",
          "content_same": false
        },
        {
          "line": 2410,
          "old_api": "GetRootGenerator",
          "new_api": "GetGeneratorForOperandIrArrays",
          "old_text": "fused_emitter.GetRootGenerator()",
          "new_text": "GetGeneratorForOperandIrArrays(fusion)",
          "old_line_content": "    return EmitTargetElementLoop(fusion, fused_emitter.GetRootGenerator());",
          "new_line_content": "    FusedIrEmitter fused_emitter(GetGeneratorForOperandIrArrays(fusion),",
          "content_same": false
        },
        {
          "line": 2412,
          "old_api": "VLOG",
          "new_api": "fused_expression_root",
          "old_text": "VLOG(3)",
          "new_text": "fusion->fused_expression_root()->Accept(&fused_emitter)",
          "old_line_content": "    VLOG(3) << \"HandleFusion kOutput\";",
          "new_line_content": "    TF_RETURN_IF_ERROR(fusion->fused_expression_root()->Accept(&fused_emitter));",
          "content_same": false
        },
        {
          "line": 2414,
          "old_api": "operand",
          "new_api": "GetRootGenerator",
          "old_text": "root->operand(dot_op_index)",
          "new_text": "fused_emitter.GetRootGenerator()",
          "old_line_content": "    const HloInstruction* dot = root->operand(dot_op_index);",
          "new_line_content": "    return EmitTargetElementLoop(fusion, fused_emitter.GetRootGenerator());",
          "content_same": false
        },
        {
          "line": 2415,
          "old_api": "opcode",
          "new_api": "IsOutputFusion",
          "old_text": "dot->opcode()",
          "new_text": "fusion->IsOutputFusion()",
          "old_line_content": "    CHECK_EQ(dot->opcode(), HloOpcode::kDot)",
          "new_line_content": "  } else if (fusion->IsOutputFusion()) {",
          "content_same": false
        },
        {
          "line": 2416,
          "old_api": "ToString",
          "new_api": "VLOG",
          "old_text": "dot->ToString()",
          "new_text": "VLOG(3)",
          "old_line_content": "        << dot->ToString() << \"  \"",
          "new_line_content": "    VLOG(3) << \"HandleFusion kOutput\";",
          "content_same": false
        },
        {
          "line": 2417,
          "old_api": "fused_instructions_computation",
          "new_api": "operand",
          "old_text": "fusion->fused_instructions_computation()->ToString()",
          "new_text": "root->operand(0)->opcode()",
          "old_line_content": "        << fusion->fused_instructions_computation()->ToString();",
          "new_line_content": "    int64 dot_op_index = root->operand(0)->opcode() == HloOpcode::kDot ? 0 : 1;",
          "content_same": false
        },
        {
          "line": 2419,
          "old_api": "operand",
          "new_api": "opcode",
          "old_text": "dot->operand(0)->parameter_number()",
          "new_text": "dot->opcode()",
          "old_line_content": "    int64 dot_lhs_param_number = dot->operand(0)->parameter_number();",
          "new_line_content": "    CHECK_EQ(dot->opcode(), HloOpcode::kDot)",
          "content_same": false
        },
        {
          "line": 2420,
          "old_api": "operand",
          "new_api": "ToString",
          "old_text": "dot->operand(1)->parameter_number()",
          "new_text": "dot->ToString()",
          "old_line_content": "    int64 dot_rhs_param_number = dot->operand(1)->parameter_number();",
          "new_line_content": "        << dot->ToString() << \"  \"",
          "content_same": false
        },
        {
          "line": 2424,
          "old_api": "shape",
          "new_api": "operand",
          "old_text": "fusion->shape()",
          "new_text": "dot->operand(1)->parameter_number()",
          "old_line_content": "    Shape target_shape = fusion->shape();",
          "new_line_content": "    int64 dot_rhs_param_number = dot->operand(1)->parameter_number();",
          "content_same": false
        },
        {
          "line": 2426,
          "old_api": "GetIrArrayFor",
          "new_api": "operand",
          "old_text": "GetIrArrayFor(fusion)",
          "new_text": "root->operand(1 - dot_op_index)->parameter_number()",
          "old_line_content": "    llvm_ir::IrArray target_array = GetIrArrayFor(fusion);",
          "new_line_content": "        root->operand(1 - dot_op_index)->parameter_number();",
          "content_same": false
        },
        {
          "line": 2429,
          "old_api": "operand",
          "new_api": "EmitTargetAddressForOp",
          "old_text": "fusion->operand(dot_lhs_param_number)",
          "new_text": "EmitTargetAddressForOp(fusion)",
          "old_line_content": "        GetIrArrayFor(fusion->operand(dot_lhs_param_number)));",
          "new_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(fusion));",
          "content_same": false
        },
        {
          "line": 2435,
          "old_api": "TF_RETURN_IF_ERROR",
          "new_api": "operand",
          "old_text": "TF_RETURN_IF_ERROR(\n        EmitDotOperation(*dot, target_array, lhs_array, rhs_array,\n                         &addend_array, GetExecutableRunOptionsArgument(), &b_,\n                         hlo_module_config_, target_machine_features_))",
          "new_text": "fusion->operand(dot_rhs_param_number)",
          "old_line_content": "    TF_RETURN_IF_ERROR(",
          "new_line_content": "        GetIrArrayFor(fusion->operand(dot_rhs_param_number)));",
          "content_same": false
        },
        {
          "line": 2437,
          "old_api": "GetExecutableRunOptionsArgument",
          "new_api": "operand",
          "old_text": "GetExecutableRunOptionsArgument()",
          "new_text": "fusion->operand(addend_param_number)",
          "old_line_content": "                         &addend_array, GetExecutableRunOptionsArgument(), &b_,",
          "new_line_content": "        GetIrArrayFor(fusion->operand(addend_param_number)));",
          "content_same": false
        },
        {
          "line": 2439,
          "old_api": "Status::OK()",
          "new_api": "TF_RETURN_IF_ERROR",
          "old_text": "Status::OK()",
          "new_text": "TF_RETURN_IF_ERROR(\n        EmitDotOperation(*dot, target_array, lhs_array, rhs_array,\n                         &addend_array, GetExecutableRunOptionsArgument(), &b_,\n                         hlo_module_config_, target_machine_features_))",
          "old_line_content": "    return Status::OK();",
          "new_line_content": "    TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 2441,
          "old_api": "Unimplemented",
          "new_api": "GetExecutableRunOptionsArgument",
          "old_text": "Unimplemented(\"Fusion kind not implemented on CPU\")",
          "new_text": "GetExecutableRunOptionsArgument()",
          "old_line_content": "    return Unimplemented(\"Fusion kind not implemented on CPU\");",
          "new_line_content": "                         &addend_array, GetExecutableRunOptionsArgument(), &b_,",
          "content_same": false
        },
        {
          "line": 2451,
          "old_api": "empty",
          "new_api": "FindOrDie",
          "old_text": "computation->root_instruction()->outer_dimension_partitions().empty()",
          "new_text": "FindOrDie(emitted_functions_, computation)",
          "old_line_content": "  if (!computation->root_instruction()->outer_dimension_partitions().empty()) {",
          "new_line_content": "  llvm::Function* call_ir_function = FindOrDie(emitted_functions_, computation);",
          "content_same": false
        },
        {
          "line": 2455,
          "old_api": "name",
          "new_api": "empty",
          "old_text": "computation->name()",
          "new_text": "computation->root_instruction()->outer_dimension_partitions().empty()",
          "old_line_content": "        {}, &b_, computation->name(),",
          "new_line_content": "  if (!computation->root_instruction()->outer_dimension_partitions().empty()) {",
          "content_same": false
        },
        {
          "line": 2458,
          "old_api": "GetBufferTableArgument",
          "new_api": "name",
          "old_text": "GetBufferTableArgument()",
          "new_text": "GetArrayFunctionCallArguments(\n        {}, &b_, computation->name(),\n        /*return_value_buffer=*/emitted_value_[call],\n        /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),\n        /*buffer_table_arg=*/GetBufferTableArgument(),\n        /*profile_counters_arg=*/GetProfileCountersArgument())",
          "old_line_content": "        /*buffer_table_arg=*/GetBufferTableArgument(),",
          "new_line_content": "    std::vector<llvm::Value*> call_args = GetArrayFunctionCallArguments(",
          "content_same": false
        },
        {
          "line": 2459,
          "old_api": "GetProfileCountersArgument",
          "new_api": "name",
          "old_text": "GetProfileCountersArgument()",
          "new_text": "computation->name()",
          "old_line_content": "        /*profile_counters_arg=*/GetProfileCountersArgument());",
          "new_line_content": "        {}, &b_, computation->name(),",
          "content_same": false
        },
        {
          "line": 2461,
          "old_api": "root_instruction",
          "new_api": "GetExecutableRunOptionsArgument",
          "old_text": "computation->root_instruction()",
          "new_text": "GetExecutableRunOptionsArgument()",
          "old_line_content": "    HloInstruction* root = computation->root_instruction();",
          "new_line_content": "        /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),",
          "content_same": false
        },
        {
          "line": 2462,
          "old_api": "shape",
          "new_api": "GetBufferTableArgument",
          "old_text": "EmitCallToParallelForkJoin(\n        call_args, root->shape(), root->outer_dimension_partitions(), &b_,\n        call_ir_function, computation->name())",
          "new_text": "GetBufferTableArgument()",
          "old_line_content": "    TF_RETURN_IF_ERROR(EmitCallToParallelForkJoin(",
          "new_line_content": "        /*buffer_table_arg=*/GetBufferTableArgument(),",
          "content_same": false
        },
        {
          "line": 2463,
          "old_api": "outer_dimension_partitions",
          "new_api": "GetProfileCountersArgument",
          "old_text": "root->outer_dimension_partitions()",
          "new_text": "GetProfileCountersArgument()",
          "old_line_content": "        call_args, root->shape(), root->outer_dimension_partitions(), &b_,",
          "new_line_content": "        /*profile_counters_arg=*/GetProfileCountersArgument());",
          "content_same": false
        },
        {
          "line": 2466,
          "old_api": "name",
          "new_api": "shape",
          "old_text": "computation->name()",
          "new_text": "EmitCallToParallelForkJoin(\n        call_args, root->shape(), root->outer_dimension_partitions(), &b_,\n        call_ir_function, computation->name())",
          "old_line_content": "    EmitGlobalCall(*computation, computation->name());",
          "new_line_content": "    TF_RETURN_IF_ERROR(EmitCallToParallelForkJoin(",
          "content_same": false
        },
        {
          "line": 2473,
          "old_api": "operands",
          "new_api": "Status::OK()",
          "old_text": "custom_call->operands()",
          "new_text": "Status::OK()",
          "old_line_content": "  absl::Span<HloInstruction* const> operands(custom_call->operands());",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2477,
          "old_api": "size",
          "new_api": "operands",
          "old_text": "operands.size()",
          "new_text": "custom_call->operands()",
          "old_line_content": "          i8_ptr_type, b_.getInt32(operands.size()), \"cc_operands_alloca\", &b_);",
          "new_line_content": "  absl::Span<HloInstruction* const> operands(custom_call->operands());",
          "content_same": false
        },
        {
          "line": 2478,
          "old_api": "size",
          "new_api": "getInt8PtrTy",
          "old_text": "operands.size()",
          "new_text": "b_.getInt8PtrTy()",
          "old_line_content": "  for (size_t i = 0; i < operands.size(); ++i) {",
          "new_line_content": "  llvm::Type* i8_ptr_type = b_.getInt8PtrTy();",
          "content_same": false
        },
        {
          "line": 2481,
          "old_api": "GetEmittedValueFor",
          "new_api": "size",
          "old_text": "GetEmittedValueFor(operand)",
          "new_text": "operands.size()",
          "old_line_content": "        PointerCast(GetEmittedValueFor(operand), i8_ptr_type);",
          "new_line_content": "          i8_ptr_type, b_.getInt32(operands.size()), \"cc_operands_alloca\", &b_);",
          "content_same": false
        },
        {
          "line": 2500,
          "old_api": "getAllocationSizeInBits",
          "new_api": "getVoidTy",
          "old_text": "Call(msan_unpoison_ir_function,\n         {PointerCast(operands_alloca, i8_ptr_type),\n          llvm::ConstantInt::get(\n              intptr_type, *operands_alloca->getAllocationSizeInBits(dl) / 8)})",
          "new_text": "llvm::FunctionType::get(\n                    /*Result=*/b_.getVoidTy(),\n                    /*Params=*/{i8_ptr_type, intptr_type}, /*isVarArg=*/false)",
          "old_line_content": "    Call(msan_unpoison_ir_function,",
          "new_line_content": "                llvm::FunctionType::get(",
          "content_same": false
        },
        {
          "line": 2501,
          "old_api": "PointerCast",
          "new_api": "getVoidTy",
          "old_text": "PointerCast(operands_alloca, i8_ptr_type)",
          "new_text": "b_.getVoidTy()",
          "old_line_content": "         {PointerCast(operands_alloca, i8_ptr_type),",
          "new_line_content": "                    /*Result=*/b_.getVoidTy(),",
          "content_same": false
        },
        {
          "line": 2505,
          "old_api": "getVoidTy",
          "new_api": "PointerCast",
          "old_text": "llvm::dyn_cast<llvm::Function>(\n      module_\n          ->getOrInsertFunction(\n              custom_call->custom_call_target(),\n              llvm::FunctionType::get(\n                  /*Result=*/b_.getVoidTy(),\n                  /*Params=*/{i8_ptr_type, operands_alloca->getType()},\n                  /*isVarArg=*/false))\n          .getCallee())",
          "new_text": "PointerCast(operands_alloca, i8_ptr_type)",
          "old_line_content": "  auto* custom_call_ir_function = llvm::dyn_cast<llvm::Function>(",
          "new_line_content": "         {PointerCast(operands_alloca, i8_ptr_type),",
          "content_same": false
        },
        {
          "line": 2506,
          "old_api": "getVoidTy",
          "new_api": "getAllocationSizeInBits",
          "old_text": "module_\n          ->getOrInsertFunction(\n              custom_call->custom_call_target(),\n              llvm::FunctionType::get(\n                  /*Result=*/b_.getVoidTy(),\n                  /*Params=*/{i8_ptr_type, operands_alloca->getType()},\n                  /*isVarArg=*/false))\n          .getCallee()",
          "new_text": "llvm::ConstantInt::get(\n              intptr_type, *operands_alloca->getAllocationSizeInBits(dl) / 8)",
          "old_line_content": "      module_",
          "new_line_content": "          llvm::ConstantInt::get(",
          "content_same": false
        },
        {
          "line": 2515,
          "old_api": "EmitTargetAddressForOp",
          "new_api": "getType",
          "old_text": "EmitTargetAddressForOp(custom_call)",
          "new_text": "operands_alloca->getType()",
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(custom_call));",
          "new_line_content": "                  /*Params=*/{i8_ptr_type, operands_alloca->getType()},",
          "content_same": false
        },
        {
          "line": 2519,
          "old_api": "shape",
          "new_api": "EmitTargetAddressForOp",
          "old_text": "custom_call->shape()",
          "new_text": "EmitTargetAddressForOp(custom_call)",
          "old_line_content": "    for (int i = 0; i < ShapeUtil::TupleElementCount(custom_call->shape());",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(custom_call));",
          "content_same": false
        },
        {
          "line": 2523,
          "old_api": "IsTuple",
          "new_api": "shape",
          "old_text": "elem_shape.IsTuple()",
          "new_text": "custom_call->shape()",
          "old_line_content": "      TF_RET_CHECK(!elem_shape.IsTuple()) << \"Nested tuples not implemented\";",
          "new_line_content": "    for (int i = 0; i < ShapeUtil::TupleElementCount(custom_call->shape());",
          "content_same": false
        },
        {
          "line": 2526,
          "old_api": "EmitBufferPointer",
          "new_api": "shape",
          "old_text": "EmitBufferPointer(slice, elem_shape)",
          "new_text": "custom_call->shape()",
          "old_line_content": "      llvm::Value* addr = EmitBufferPointer(slice, elem_shape);",
          "new_line_content": "          ShapeUtil::GetTupleElementShape(custom_call->shape(), i);",
          "content_same": false
        },
        {
          "line": 2527,
          "old_api": "push_back",
          "new_api": "IsTuple",
          "old_text": "base_ptrs.push_back(addr)",
          "new_text": "elem_shape.IsTuple()",
          "old_line_content": "      base_ptrs.push_back(addr);",
          "new_line_content": "      TF_RET_CHECK(!elem_shape.IsTuple()) << \"Nested tuples not implemented\";",
          "content_same": false
        },
        {
          "line": 2536,
          "old_api": "Status::OK()",
          "new_api": "GetEmittedValueFor",
          "old_text": "Status::OK()",
          "new_text": "GetEmittedValueFor(custom_call)",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "      PointerCast(GetEmittedValueFor(custom_call), i8_ptr_type);",
          "content_same": false
        },
        {
          "line": 2545,
          "old_api": "root_instruction",
          "new_api": "while_condition",
          "old_text": "condition->root_instruction()->shape()",
          "new_text": "xla_while->while_condition()",
          "old_line_content": "      << ShapeUtil::HumanString(condition->root_instruction()->shape());",
          "new_line_content": "  HloComputation* condition = xla_while->while_condition();",
          "content_same": false
        },
        {
          "line": 2547,
          "old_api": "GetUniqueSlice",
          "new_api": "element_type",
          "old_text": "ShapeUtil::ForEachSubshapeWithStatus(\n      xla_while->shape(),\n      [this, &xla_while](const Shape& /*subshape*/,\n                         const ShapeIndex& index) -> Status {\n        auto check = [this](const HloInstruction* a, const HloInstruction* b,\n                            const ShapeIndex& index) {\n          const BufferAllocation::Slice slice_a =\n              assignment_.GetUniqueSlice(a, index).ConsumeValueOrDie();\n          const BufferAllocation::Slice slice_b =\n              assignment_.GetUniqueSlice(b, index).ConsumeValueOrDie();\n          if (slice_a != slice_b) {\n            return InternalError(\n                \"instruction %s %s does not share slice with \"\n                \"instruction %s %s\",\n                a->ToString(), slice_a.ToString(), b->ToString(),\n                slice_b.ToString());\n          }\n          return Status::OK();\n        };\n        TF_RETURN_IF_ERROR(check(xla_while, xla_while->operand(0), index));\n        TF_RETURN_IF_ERROR(check(\n            xla_while, xla_while->while_condition()->parameter_instruction(0),\n            index));\n        TF_RETURN_IF_ERROR(\n            check(xla_while, xla_while->while_body()->parameter_instruction(0),\n                  index));\n        TF_RETURN_IF_ERROR(check(\n            xla_while, xla_while->while_body()->root_instruction(), index));\n        return Status::OK();\n      })",
          "new_text": "condition->root_instruction()->shape().element_type()",
          "old_line_content": "  TF_RETURN_IF_ERROR(ShapeUtil::ForEachSubshapeWithStatus(",
          "new_line_content": "               condition->root_instruction()->shape().element_type() == PRED)",
          "content_same": false
        },
        {
          "line": 2558,
          "old_api": "ToString",
          "new_api": "GetUniqueSlice",
          "old_text": "InternalError(\n                \"instruction %s %s does not share slice with \"\n                \"instruction %s %s\",\n                a->ToString(), slice_a.ToString(), b->ToString(),\n                slice_b.ToString())",
          "new_text": "assignment_.GetUniqueSlice(a, index).ConsumeValueOrDie()",
          "old_line_content": "            return InternalError(",
          "new_line_content": "              assignment_.GetUniqueSlice(a, index).ConsumeValueOrDie();",
          "content_same": false
        },
        {
          "line": 2566,
          "old_api": "operand",
          "new_api": "ToString",
          "old_text": "xla_while->operand(0)",
          "new_text": "slice_b.ToString()",
          "old_line_content": "        TF_RETURN_IF_ERROR(check(xla_while, xla_while->operand(0), index));",
          "new_line_content": "                slice_b.ToString());",
          "content_same": false
        },
        {
          "line": 2568,
          "old_api": "while_condition",
          "new_api": "Status::OK()",
          "old_text": "xla_while->while_condition()->parameter_instruction(0)",
          "new_text": "Status::OK()",
          "old_line_content": "            xla_while, xla_while->while_condition()->parameter_instruction(0),",
          "new_line_content": "          return Status::OK();",
          "content_same": false
        },
        {
          "line": 2570,
          "old_api": "while_body",
          "new_api": "operand",
          "old_text": "TF_RETURN_IF_ERROR(\n            check(xla_while, xla_while->while_body()->parameter_instruction(0),\n                  index))",
          "new_text": "xla_while->operand(0)",
          "old_line_content": "        TF_RETURN_IF_ERROR(",
          "new_line_content": "        TF_RETURN_IF_ERROR(check(xla_while, xla_while->operand(0), index));",
          "content_same": false
        },
        {
          "line": 2571,
          "old_api": "while_body",
          "new_api": "while_condition",
          "old_text": "xla_while->while_body()->parameter_instruction(0)",
          "new_text": "check(\n            xla_while, xla_while->while_condition()->parameter_instruction(0),\n            index)",
          "old_line_content": "            check(xla_while, xla_while->while_body()->parameter_instruction(0),",
          "new_line_content": "        TF_RETURN_IF_ERROR(check(",
          "content_same": false
        },
        {
          "line": 2575,
          "old_api": "Status::OK()",
          "new_api": "while_body",
          "old_text": "Status::OK()",
          "new_text": "xla_while->while_body()->parameter_instruction(0)",
          "old_line_content": "        return Status::OK();",
          "new_line_content": "            check(xla_while, xla_while->while_body()->parameter_instruction(0),",
          "content_same": false
        },
        {
          "line": 2579,
          "old_api": "operand",
          "new_api": "Status::OK()",
          "old_text": "xla_while->operand(0)",
          "new_text": "Status::OK()",
          "old_line_content": "  const HloInstruction* init = xla_while->operand(0);",
          "new_line_content": "        return Status::OK();",
          "content_same": false
        },
        {
          "line": 2594,
          "old_api": "SetInsertPoint",
          "new_api": "getContext",
          "old_text": "b_.SetInsertPoint(header_bb)",
          "new_text": "llvm::BasicBlock::Create(\n      module_->getContext(), IrName(xla_while, \"header\"),\n      compute_function_->function())",
          "old_line_content": "  b_.SetInsertPoint(header_bb);",
          "new_line_content": "  llvm::BasicBlock* header_bb = llvm::BasicBlock::Create(",
          "content_same": false
        },
        {
          "line": 2598,
          "old_api": "IrName",
          "new_api": "SetInsertPoint",
          "old_text": "IrName(xla_while, \"cond\")",
          "new_text": "b_.SetInsertPoint(header_bb)",
          "old_line_content": "  EmitGlobalCall(*xla_while->while_condition(), IrName(xla_while, \"cond\"));",
          "new_line_content": "  b_.SetInsertPoint(header_bb);",
          "content_same": false
        },
        {
          "line": 2605,
          "old_api": "IrName",
          "new_api": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "old_text": "IrName(xla_while, \"body\")",
          "new_text": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "old_line_content": "      llvm::BasicBlock::Create(module_->getContext(), IrName(xla_while, \"body\"),",
          "new_line_content": "      llvm::ConstantInt::get(llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0));",
          "content_same": false
        },
        {
          "line": 2609,
          "old_api": "CondBr",
          "new_api": "IrName",
          "old_text": "CondBr(while_predicate, body_bb, exit_bb)",
          "new_text": "IrName(xla_while, \"body\")",
          "old_line_content": "  CondBr(while_predicate, body_bb, exit_bb);",
          "new_line_content": "      llvm::BasicBlock::Create(module_->getContext(), IrName(xla_while, \"body\"),",
          "content_same": false
        },
        {
          "line": 2612,
          "old_api": "SetInsertPoint",
          "new_api": "IrName",
          "old_text": "b_.SetInsertPoint(body_bb)",
          "new_text": "IrName(xla_while, \"exit\")",
          "old_line_content": "  b_.SetInsertPoint(body_bb);",
          "new_line_content": "      module_->getContext(), IrName(xla_while, \"exit\"));",
          "content_same": false
        },
        {
          "line": 2622,
          "old_api": "SetInsertPoint",
          "new_api": "Br",
          "old_text": "b_.SetInsertPoint(exit_bb)",
          "new_text": "Br(header_bb)",
          "old_line_content": "  b_.SetInsertPoint(exit_bb);",
          "new_line_content": "  Br(header_bb);",
          "content_same": false
        },
        {
          "line": 2653,
          "old_api": "begin",
          "new_api": "layout",
          "old_text": "output_min2maj.begin()",
          "new_text": "output_shape.layout()",
          "old_line_content": "  std::vector<int64> inner_dims(output_min2maj.begin(), concat_dim_layout_itr);",
          "new_line_content": "  const Layout& output_layout = output_shape.layout();",
          "content_same": false
        },
        {
          "line": 2654,
          "old_api": "std::next(concat_dim_layout_itr)",
          "new_api": "LayoutUtil::MinorToMajor(output_layout)",
          "old_text": "std::next(concat_dim_layout_itr)",
          "new_text": "LayoutUtil::MinorToMajor(output_layout)",
          "old_line_content": "  std::vector<int64> outer_dims(std::next(concat_dim_layout_itr),",
          "new_line_content": "  auto output_min2maj = LayoutUtil::MinorToMajor(output_layout);",
          "content_same": false
        },
        {
          "line": 2655,
          "old_api": "end",
          "new_api": "absl::c_find(output_min2maj, concat_dim)",
          "old_text": "output_min2maj.end()",
          "new_text": "absl::c_find(output_min2maj, concat_dim)",
          "old_line_content": "                                output_min2maj.end());",
          "new_line_content": "  auto concat_dim_layout_itr = absl::c_find(output_min2maj, concat_dim);",
          "content_same": false
        },
        {
          "line": 2657,
          "old_api": "getInt8PtrTy",
          "new_api": "begin",
          "old_text": "b_.getInt8PtrTy()",
          "new_text": "output_min2maj.begin()",
          "old_line_content": "  llvm::Type* i8_ptr_type = b_.getInt8PtrTy();",
          "new_line_content": "  std::vector<int64> inner_dims(output_min2maj.begin(), concat_dim_layout_itr);",
          "content_same": false
        },
        {
          "line": 2659,
          "old_api": "EmitTargetAddressForOp",
          "new_api": "end",
          "old_text": "EmitTargetAddressForOp(concatenate)",
          "new_text": "output_min2maj.end()",
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(concatenate));",
          "new_line_content": "                                output_min2maj.end());",
          "content_same": false
        },
        {
          "line": 2664,
          "old_api": "AddLoopsForShapeOnDimensions",
          "new_api": "GetIrArrayFor",
          "old_text": "loops.AddLoopsForShapeOnDimensions(output_shape, outer_dims, \"concat\")",
          "new_text": "GetIrArrayFor(concatenate)",
          "old_line_content": "      loops.AddLoopsForShapeOnDimensions(output_shape, outer_dims, \"concat\");",
          "new_line_content": "  llvm_ir::IrArray target_array = GetIrArrayFor(concatenate);",
          "content_same": false
        },
        {
          "line": 2666,
          "old_api": "static_cast<llvm::Value*>(nullptr)",
          "new_api": "IrName",
          "old_text": "static_cast<llvm::Value*>(nullptr)",
          "new_text": "IrName(concatenate)",
          "old_line_content": "               static_cast<llvm::Value*>(nullptr),",
          "new_line_content": "  llvm_ir::ForLoopNest loops(IrName(concatenate), &b_);",
          "content_same": false
        },
        {
          "line": 2669,
          "old_api": "getInt64Ty",
          "new_api": "end",
          "old_text": "b_.getInt64Ty()",
          "new_text": "target_multi_index.end()",
          "old_line_content": "                                       b_.getInt64Ty());",
          "new_line_content": "  std::replace(target_multi_index.begin(), target_multi_index.end(),",
          "content_same": false
        },
        {
          "line": 2671,
          "old_api": "empty",
          "new_api": "getInt64",
          "old_text": "outer_dims.empty()",
          "new_text": "b_.getInt64(0)",
          "old_line_content": "  if (!outer_dims.empty()) {",
          "new_line_content": "               static_cast<llvm::Value*>(b_.getInt64(0)));",
          "content_same": false
        },
        {
          "line": 2675,
          "old_api": "element_type",
          "new_api": "empty",
          "old_text": "output_shape.element_type()",
          "new_text": "outer_dims.empty()",
          "old_line_content": "  PrimitiveType primitive_type = output_shape.element_type();",
          "new_line_content": "  if (!outer_dims.empty()) {",
          "content_same": false
        },
        {
          "line": 2681,
          "old_api": "EmitArrayElementAddress",
          "new_api": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "old_text": "BitCast(\n      target_array.EmitArrayElementAddress(target_index, &b_, \"target_region\"),\n      i8_ptr_type)",
          "new_text": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "old_line_content": "  llvm::Value* target_region_begin = BitCast(",
          "new_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(primitive_type);",
          "content_same": false
        },
        {
          "line": 2699,
          "old_api": "EmitArrayElementAddress",
          "new_api": "shape",
          "old_text": "BitCast(\n        source_array.EmitArrayElementAddress(source_index, &b_, \"src_addr\"),\n        i8_ptr_type)",
          "new_text": "operand->shape()",
          "old_line_content": "    llvm::Value* copy_source_address = BitCast(",
          "new_line_content": "    const Shape& input_shape = operand->shape();",
          "content_same": false
        },
        {
          "line": 2700,
          "old_api": "EmitArrayElementAddress",
          "new_api": "GetIrArrayFor",
          "old_text": "source_array.EmitArrayElementAddress(source_index, &b_, \"src_addr\")",
          "new_text": "GetIrArrayFor(operand)",
          "old_line_content": "        source_array.EmitArrayElementAddress(source_index, &b_, \"src_addr\"),",
          "new_line_content": "    llvm_ir::IrArray source_array = GetIrArrayFor(operand);",
          "content_same": false
        },
        {
          "line": 2704,
          "old_api": "getInt64",
          "new_api": "EmitArrayElementAddress",
          "old_text": "b_.getInt64(byte_offset_into_target_region)",
          "new_text": "source_array.EmitArrayElementAddress(source_index, &b_, \"src_addr\")",
          "old_line_content": "        GEP(target_region_begin, b_.getInt64(byte_offset_into_target_region));",
          "new_line_content": "        source_array.EmitArrayElementAddress(source_index, &b_, \"src_addr\"),",
          "content_same": false
        },
        {
          "line": 2708,
          "old_api": "dimensions",
          "new_api": "getInt64",
          "old_text": "input_shape.dimensions(concat_dim)",
          "new_text": "b_.getInt64(byte_offset_into_target_region)",
          "old_line_content": "        inner_dims_product * input_shape.dimensions(concat_dim), primitive_type,",
          "new_line_content": "        GEP(target_region_begin, b_.getInt64(byte_offset_into_target_region));",
          "content_same": false
        },
        {
          "line": 2716,
          "old_api": "empty",
          "new_api": "dimensions",
          "old_text": "outer_dims.empty()",
          "new_text": "input_shape.dimensions(concat_dim)",
          "old_line_content": "  if (!outer_dims.empty()) {",
          "new_line_content": "                                      input_shape.dimensions(concat_dim) *",
          "content_same": false
        },
        {
          "line": 2733,
          "old_api": "llvm_ir::PrimitiveTypeToIrType(primitive_type, module_)",
          "new_api": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "old_text": "llvm_ir::PrimitiveTypeToIrType(primitive_type, module_)",
          "new_text": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "old_line_content": "      llvm_ir::PrimitiveTypeToIrType(primitive_type, module_));",
          "new_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(primitive_type);",
          "content_same": false
        },
        {
          "line": 2737,
          "old_api": "BitCast",
          "new_api": "llvm_ir::PrimitiveTypeToIrType(primitive_type, module_)",
          "old_text": "BitCast(source, primitive_ptr_type)",
          "new_text": "llvm_ir::PrimitiveTypeToIrType(primitive_type, module_)",
          "old_line_content": "        AlignedLoad(BitCast(source, primitive_ptr_type), element_alignment);",
          "new_line_content": "      llvm_ir::PrimitiveTypeToIrType(primitive_type, module_));",
          "content_same": false
        },
        {
          "line": 2744,
          "old_api": "MemCpy",
          "new_api": "BitCast",
          "old_text": "MemCpy(\n        target, /*DstAlign=*/element_alignment, source,\n        /*SrcAlign=*/element_alignment, element_count * primitive_type_size)",
          "new_text": "BitCast(target, primitive_ptr_type)",
          "old_line_content": "    auto* memcpy_instruction = MemCpy(",
          "new_line_content": "        AlignedStore(load_instruction, BitCast(target, primitive_ptr_type),",
          "content_same": false
        },
        {
          "line": 2777,
          "old_api": "operand",
          "new_api": "DefaultAction",
          "old_text": "conditional->operand(0)",
          "new_text": "DefaultAction(concatenate)",
          "old_line_content": "  auto branch_index = conditional->operand(0);",
          "new_line_content": "  return DefaultAction(concatenate);",
          "content_same": false
        },
        {
          "line": 2781,
          "old_api": "element_type",
          "new_api": "operand",
          "old_text": "branch_index->shape().element_type()",
          "new_text": "conditional->operand(0)",
          "old_line_content": "                branch_index->shape().element_type() == S32))",
          "new_line_content": "  auto branch_index = conditional->operand(0);",
          "content_same": false
        },
        {
          "line": 2795,
          "old_api": "EmitTargetAddressForOp",
          "new_api": "shape",
          "old_text": "EmitTargetAddressForOp(conditional)",
          "new_text": "conditional->shape()",
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(conditional));",
          "new_line_content": "        << ShapeUtil::HumanString(conditional->shape()) << \" and \"",
          "content_same": false
        },
        {
          "line": 2807,
          "old_api": "llvm::ConstantInt::get(\n                   llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0)",
          "new_api": "GetBasePointer",
          "old_text": "llvm::ConstantInt::get(\n                   llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0)",
          "new_text": "Load(\n        GetIrArrayFor(branch_index).GetBasePointer(), \"load_predicate_value\")",
          "old_line_content": "               llvm::ConstantInt::get(",
          "new_line_content": "    llvm::LoadInst* pred_value = Load(",
          "content_same": false
        },
        {
          "line": 2808,
          "old_api": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "new_api": "GetBasePointer",
          "old_text": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "new_text": "GetIrArrayFor(branch_index).GetBasePointer()",
          "old_line_content": "                   llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0),",
          "new_line_content": "        GetIrArrayFor(branch_index).GetBasePointer(), \"load_predicate_value\");",
          "content_same": false
        },
        {
          "line": 2811,
          "old_api": "llvm_ir::EmitIfThenElse(pred_cond, \"conditional\", &b_)",
          "new_api": "llvm::ConstantInt::get(\n                   llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0)",
          "old_text": "llvm_ir::EmitIfThenElse(pred_cond, \"conditional\", &b_)",
          "new_text": "llvm::ConstantInt::get(\n                   llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0)",
          "old_line_content": "        llvm_ir::EmitIfThenElse(pred_cond, \"conditional\", &b_);",
          "new_line_content": "               llvm::ConstantInt::get(",
          "content_same": false
        },
        {
          "line": 2815,
          "old_api": "IrName",
          "new_api": "llvm_ir::EmitIfThenElse(pred_cond, \"conditional\", &b_)",
          "old_text": "IrName(conditional, \"_true\")",
          "new_text": "llvm_ir::EmitIfThenElse(pred_cond, \"conditional\", &b_)",
          "old_line_content": "                   IrName(conditional, \"_true\"));",
          "new_line_content": "        llvm_ir::EmitIfThenElse(pred_cond, \"conditional\", &b_);",
          "content_same": false
        },
        {
          "line": 2822,
          "old_api": "Status::OK()",
          "new_api": "branch_computation",
          "old_text": "Status::OK()",
          "new_text": "conditional->branch_computation(1)",
          "old_line_content": "    return Status::OK();",
          "new_line_content": "    EmitGlobalCall(*conditional->branch_computation(1),",
          "content_same": false
        },
        {
          "line": 2845,
          "old_api": "llvm_ir::CreateBasicBlock(nullptr, \"case-after\", &b_)",
          "new_api": "GetInsertBlock",
          "old_text": "llvm_ir::CreateBasicBlock(nullptr, \"case-after\", &b_)",
          "new_text": "b_.GetInsertBlock()",
          "old_line_content": "    after_block = llvm_ir::CreateBasicBlock(nullptr, \"case-after\", &b_);",
          "new_line_content": "  auto case_block = b_.GetInsertBlock();",
          "content_same": false
        },
        {
          "line": 2850,
          "old_api": "GetInsertPoint",
          "new_api": "SetInsertPoint",
          "old_text": "b_.GetInsertPoint()",
          "new_text": "b_.SetInsertPoint(case_block)",
          "old_line_content": "        case_block->splitBasicBlock(b_.GetInsertPoint(), \"case-after\");",
          "new_line_content": "    b_.SetInsertPoint(case_block);",
          "content_same": false
        },
        {
          "line": 2854,
          "old_api": "getTerminator",
          "new_api": "GetInsertPoint",
          "old_text": "case_block->getTerminator()->eraseFromParent()",
          "new_text": "b_.GetInsertPoint()",
          "old_line_content": "  case_block->getTerminator()->eraseFromParent();",
          "new_line_content": "        case_block->splitBasicBlock(b_.GetInsertPoint(), \"case-after\");",
          "content_same": false
        },
        {
          "line": 2858,
          "old_api": "SetInsertPoint",
          "new_api": "getTerminator",
          "old_text": "b_.SetInsertPoint(default_block)",
          "new_text": "case_block->getTerminator()->eraseFromParent()",
          "old_line_content": "  b_.SetInsertPoint(default_block);",
          "new_line_content": "  case_block->getTerminator()->eraseFromParent();",
          "content_same": false
        },
        {
          "line": 2861,
          "old_api": "CreateBr",
          "new_api": "llvm_ir::CreateBasicBlock(nullptr, \"case-default\", &b_)",
          "old_text": "b_.CreateBr(after_block)",
          "new_text": "llvm_ir::CreateBasicBlock(nullptr, \"case-default\", &b_)",
          "old_line_content": "  b_.CreateBr(after_block);",
          "new_line_content": "  auto default_block = llvm_ir::CreateBasicBlock(nullptr, \"case-default\", &b_);",
          "content_same": false
        },
        {
          "line": 2864,
          "old_api": "SetInsertPoint",
          "new_api": "IrName",
          "old_text": "b_.SetInsertPoint(case_block)",
          "new_text": "IrName(conditional, \"_default\")",
          "old_line_content": "  b_.SetInsertPoint(case_block);",
          "new_line_content": "                 IrName(conditional, \"_default\"));",
          "content_same": false
        },
        {
          "line": 2875,
          "old_api": "CreateBr",
          "new_api": "absl::StrCat(\"case-branch\", b)",
          "old_text": "b_.CreateBr(after_block)",
          "new_text": "absl::StrCat(\"case-branch\", b)",
          "old_line_content": "    b_.CreateBr(after_block);",
          "new_line_content": "        llvm_ir::CreateBasicBlock(nullptr, absl::StrCat(\"case-branch\", b), &b_);",
          "content_same": false
        },
        {
          "line": 2876,
          "old_api": "getInt32",
          "new_api": "SetInsertPoint",
          "old_text": "b_.getInt32(b)",
          "new_text": "b_.SetInsertPoint(branch_block)",
          "old_line_content": "    case_inst->addCase(b_.getInt32(b), branch_block);",
          "new_line_content": "    b_.SetInsertPoint(branch_block);",
          "content_same": false
        },
        {
          "line": 2879,
          "old_api": "SetToFirstInsertPoint",
          "new_api": "CreateBr",
          "old_text": "SetToFirstInsertPoint(after_block, &b_)",
          "new_text": "b_.CreateBr(after_block)",
          "old_line_content": "  SetToFirstInsertPoint(after_block, &b_);",
          "new_line_content": "    b_.CreateBr(after_block);",
          "content_same": false
        },
        {
          "line": 2880,
          "old_api": "Status::OK()",
          "new_api": "getInt32",
          "old_text": "Status::OK()",
          "new_text": "b_.getInt32(b)",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "    case_inst->addCase(b_.getInt32(b), branch_block);",
          "content_same": false
        },
        {
          "line": 2884,
          "old_api": "shape",
          "new_api": "Status::OK()",
          "old_text": "after_all->shape()",
          "new_text": "Status::OK()",
          "old_line_content": "  TF_RET_CHECK(ByteSizeOf(after_all->shape()) == 0);",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2898,
          "old_api": "Unimplemented",
          "new_api": "Status::OK()",
          "old_text": "Unimplemented(\"Rng should be expanded for CPU.\")",
          "new_text": "Status::OK()",
          "old_line_content": "  return Unimplemented(\"Rng should be expanded for CPU.\");",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2902,
          "old_api": "ToString",
          "new_api": "Unimplemented",
          "old_text": "rng_state->ToString()",
          "new_text": "Unimplemented(\"Rng should be expanded for CPU.\")",
          "old_line_content": "  VLOG(2) << \"RngGetAndUpdateState: \" << rng_state->ToString();",
          "new_line_content": "  return Unimplemented(\"Rng should be expanded for CPU.\");",
          "content_same": false
        },
        {
          "line": 2907,
          "old_api": "EmitTargetAddressForOp",
          "new_api": "delta",
          "old_text": "EmitTargetAddressForOp(rng_state)",
          "new_text": "llvm_ir::RngGetAndUpdateState(\n      Cast<HloRngGetAndUpdateStateInstruction>(rng_state)->delta(), module_,\n      &b_)",
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(rng_state));",
          "new_line_content": "  llvm::Value* old_state = llvm_ir::RngGetAndUpdateState(",
          "content_same": false
        },
        {
          "line": 2908,
          "old_api": "GetEmittedValueFor",
          "new_api": "delta",
          "old_text": "GetEmittedValueFor(rng_state)",
          "new_text": "Cast<HloRngGetAndUpdateStateInstruction>(rng_state)->delta()",
          "old_line_content": "  llvm::Value* address = GetEmittedValueFor(rng_state);",
          "new_line_content": "      Cast<HloRngGetAndUpdateStateInstruction>(rng_state)->delta(), module_,",
          "content_same": false
        },
        {
          "line": 2912,
          "old_api": "getType",
          "new_api": "GetEmittedValueFor",
          "old_text": "llvm::PointerType::get(\n                                 old_state->getType()->getScalarType(),\n                                 address->getType()->getPointerAddressSpace())",
          "new_text": "GetEmittedValueFor(rng_state)",
          "old_line_content": "  address = BitCast(address, llvm::PointerType::get(",
          "new_line_content": "  llvm::Value* address = GetEmittedValueFor(rng_state);",
          "content_same": false
        },
        {
          "line": 2916,
          "old_api": "element_type",
          "new_api": "getType",
          "old_text": "store->setAlignment(\n      llvm::MaybeAlign(IrEmitter::MinimumAlignmentForPrimitiveType(\n          rng_state->shape().element_type())))",
          "new_text": "llvm::PointerType::get(\n                                 old_state->getType()->getScalarType(),\n                                 address->getType()->getPointerAddressSpace())",
          "old_line_content": "  store->setAlignment(",
          "new_line_content": "  address = BitCast(address, llvm::PointerType::get(",
          "content_same": false
        },
        {
          "line": 2917,
          "old_api": "element_type",
          "new_api": "getType",
          "old_text": "IrEmitter::MinimumAlignmentForPrimitiveType(\n          rng_state->shape().element_type())",
          "new_text": "old_state->getType()->getScalarType()",
          "old_line_content": "      llvm::MaybeAlign(IrEmitter::MinimumAlignmentForPrimitiveType(",
          "new_line_content": "                                 old_state->getType()->getScalarType(),",
          "content_same": false
        },
        {
          "line": 2918,
          "old_api": "element_type",
          "new_api": "getType",
          "old_text": "rng_state->shape().element_type()",
          "new_text": "address->getType()->getPointerAddressSpace()",
          "old_line_content": "          rng_state->shape().element_type())));",
          "new_line_content": "                                 address->getType()->getPointerAddressSpace()));",
          "content_same": false
        },
        {
          "line": 2920,
          "old_api": "Status::OK()",
          "new_api": "element_type",
          "old_text": "Status::OK()",
          "new_text": "store->setAlignment(\n      llvm::MaybeAlign(IrEmitter::MinimumAlignmentForPrimitiveType(\n          rng_state->shape().element_type())))",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  store->setAlignment(",
          "content_same": false
        },
        {
          "line": 2935,
          "old_api": "GetEmittedValueFor",
          "new_api": "opcode",
          "old_text": "GetEmittedValueFor(root)",
          "new_text": "root->opcode()",
          "old_line_content": "    VLOG(2) << \"  value: \" << llvm_ir::DumpToString(*GetEmittedValueFor(root));",
          "new_line_content": "  if (root->opcode() == HloOpcode::kOutfeed) {",
          "content_same": false
        },
        {
          "line": 2986,
          "old_api": "CreateAdd",
          "new_api": "CreateSub",
          "old_text": "b->CreateAdd(cycle_diff, old_cycle_count, \"new_cycle_count\")",
          "new_text": "b->CreateSub(cycle_end, cycle_start)",
          "old_line_content": "      b->CreateAdd(cycle_diff, old_cycle_count, \"new_cycle_count\");",
          "new_line_content": "  auto* cycle_diff = b->CreateSub(cycle_end, cycle_start);",
          "content_same": false
        },
        {
          "line": 2991,
          "old_api": "GetInsertBlock",
          "new_api": "CreateStore",
          "old_text": "b->GetInsertBlock()->getModule()",
          "new_text": "b->CreateStore(new_cycle_count, prof_counter)",
          "old_line_content": "  llvm::Module* module = b->GetInsertBlock()->getModule();",
          "new_line_content": "  b->CreateStore(new_cycle_count, prof_counter);",
          "content_same": false
        },
        {
          "line": 3046,
          "old_api": "getParent",
          "new_api": "getInt64Ty",
          "old_text": "function->getParent()",
          "new_text": "b->getInt64Ty()",
          "old_line_content": "  llvm::Module* module = function->getParent();",
          "new_line_content": "      llvm::FunctionType::get(b->getInt64Ty(), {void_ptr_type, int8_ptr_type},",
          "content_same": false
        },
        {
          "line": 3049,
          "old_api": "getOrInsertFunction",
          "new_api": "GetInsertBlock",
          "old_text": "module->getOrInsertFunction(fn_name, fn_type)",
          "new_text": "b->GetInsertBlock()->getParent()",
          "old_line_content": "      module->getOrInsertFunction(fn_name, fn_type);",
          "new_line_content": "  llvm::Function* function = b->GetInsertBlock()->getParent();",
          "content_same": false
        },
        {
          "line": 3050,
          "old_api": "getCallee",
          "new_api": "getParent",
          "old_text": "trace_func.getCallee()",
          "new_text": "function->getParent()",
          "old_line_content": "  if (auto* fn = llvm::dyn_cast<llvm::Function>(trace_func.getCallee())) {",
          "new_line_content": "  llvm::Module* module = function->getParent();",
          "content_same": false
        },
        {
          "line": 3053,
          "old_api": "setOnlyAccessesArgMemory",
          "new_api": "getOrInsertFunction",
          "old_text": "fn->setOnlyAccessesArgMemory()",
          "new_text": "module->getOrInsertFunction(fn_name, fn_type)",
          "old_line_content": "    fn->setOnlyAccessesArgMemory();",
          "new_line_content": "      module->getOrInsertFunction(fn_name, fn_type);",
          "content_same": false
        },
        {
          "line": 3055,
          "old_api": "name",
          "new_api": "setCallingConv",
          "old_text": "hlo->name()",
          "new_text": "fn->setCallingConv(llvm::CallingConv::C)",
          "old_line_content": "  auto* hlo_name = b->CreateGlobalStringPtr(hlo->name());",
          "new_line_content": "    fn->setCallingConv(llvm::CallingConv::C);",
          "content_same": false
        },
        {
          "line": 3057,
          "old_api": "CreateBitCast",
          "new_api": "setOnlyAccessesArgMemory",
          "old_text": "b->CreateBitCast(run_options, void_ptr_type)",
          "new_text": "fn->setOnlyAccessesArgMemory()",
          "old_line_content": "      b->CreateCall(trace_func, {b->CreateBitCast(run_options, void_ptr_type),",
          "new_line_content": "    fn->setOnlyAccessesArgMemory();",
          "content_same": false
        },
        {
          "line": 3059,
          "old_api": "IrName",
          "new_api": "name",
          "old_text": "IrName(hlo, \"activity_id\")",
          "new_text": "hlo->name()",
          "old_line_content": "  activity_id->setName(IrName(hlo, \"activity_id\"));",
          "new_line_content": "  auto* hlo_name = b->CreateGlobalStringPtr(hlo->name());",
          "content_same": false
        },
        {
          "line": 3076,
          "old_api": "getParent",
          "new_api": "getInt64Ty",
          "old_text": "function->getParent()",
          "new_text": "b->getInt64Ty()",
          "old_line_content": "  llvm::Module* module = function->getParent();",
          "new_line_content": "      llvm::FunctionType::get(b->getVoidTy(), {void_ptr_type, b->getInt64Ty()},",
          "content_same": false
        },
        {
          "line": 3079,
          "old_api": "getOrInsertFunction",
          "new_api": "GetInsertBlock",
          "old_text": "module->getOrInsertFunction(fn_name, fn_type)",
          "new_text": "b->GetInsertBlock()->getParent()",
          "old_line_content": "      module->getOrInsertFunction(fn_name, fn_type);",
          "new_line_content": "  llvm::Function* function = b->GetInsertBlock()->getParent();",
          "content_same": false
        },
        {
          "line": 3080,
          "old_api": "getCallee",
          "new_api": "getParent",
          "old_text": "trace_func.getCallee()",
          "new_text": "function->getParent()",
          "old_line_content": "  if (auto* fn = llvm::dyn_cast<llvm::Function>(trace_func.getCallee())) {",
          "new_line_content": "  llvm::Module* module = function->getParent();",
          "content_same": false
        },
        {
          "line": 3083,
          "old_api": "setOnlyAccessesArgMemory",
          "new_api": "getOrInsertFunction",
          "old_text": "fn->setOnlyAccessesArgMemory()",
          "new_text": "module->getOrInsertFunction(fn_name, fn_type)",
          "old_line_content": "    fn->setOnlyAccessesArgMemory();",
          "new_line_content": "      module->getOrInsertFunction(fn_name, fn_type);",
          "content_same": false
        },
        {
          "line": 3085,
          "old_api": "at",
          "new_api": "setCallingConv",
          "old_text": "activity_ids_.at(hlo)",
          "new_text": "fn->setCallingConv(llvm::CallingConv::C)",
          "old_line_content": "  auto* activity_id = activity_ids_.at(hlo);",
          "new_line_content": "    fn->setCallingConv(llvm::CallingConv::C);",
          "content_same": false
        },
        {
          "line": 3086,
          "old_api": "CreateCall",
          "new_api": "setDoesNotThrow",
          "old_text": "b->CreateCall(trace_func,\n                {b->CreateBitCast(run_options, void_ptr_type), activity_id})",
          "new_text": "fn->setDoesNotThrow()",
          "old_line_content": "  b->CreateCall(trace_func,",
          "new_line_content": "    fn->setDoesNotThrow();",
          "content_same": false
        },
        {
          "line": 3087,
          "old_api": "CreateBitCast",
          "new_api": "setOnlyAccessesArgMemory",
          "old_text": "b->CreateBitCast(run_options, void_ptr_type)",
          "new_text": "fn->setOnlyAccessesArgMemory()",
          "old_line_content": "                {b->CreateBitCast(run_options, void_ptr_type), activity_id});",
          "new_line_content": "    fn->setOnlyAccessesArgMemory();",
          "content_same": false
        },
        {
          "line": 3091,
          "old_api": "ToString",
          "new_api": "CreateBitCast",
          "old_text": "hlo->ToString()",
          "new_text": "b->CreateBitCast(run_options, void_ptr_type)",
          "old_line_content": "  VLOG(3) << \"Visiting: \" << hlo->ToString();",
          "new_line_content": "                {b->CreateBitCast(run_options, void_ptr_type), activity_id});",
          "content_same": false
        },
        {
          "line": 3095,
          "old_api": "GetExecutableRunOptionsArgument",
          "new_api": "ToString",
          "old_text": "GetExecutableRunOptionsArgument()",
          "new_text": "hlo->ToString()",
          "old_line_content": "                                    GetExecutableRunOptionsArgument());",
          "new_line_content": "  VLOG(3) << \"Visiting: \" << hlo->ToString();",
          "content_same": false
        },
        {
          "line": 3096,
          "old_api": "RecordCycleStart",
          "new_api": "count",
          "old_text": "profiling_state_.RecordCycleStart(&b_, hlo)",
          "new_text": "instruction_to_profile_idx_.count(hlo)",
          "old_line_content": "    profiling_state_.RecordCycleStart(&b_, hlo);",
          "new_line_content": "  if (instruction_to_profile_idx_.count(hlo)) {",
          "content_same": false
        },
        {
          "line": 3098,
          "old_api": "Status::OK()",
          "new_api": "EmitTracingStart",
          "old_text": "Status::OK()",
          "new_text": "tracing_state_.EmitTracingStart(&b_, hlo,\n                                    GetExecutableRunOptionsArgument())",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "    tracing_state_.EmitTracingStart(&b_, hlo,",
          "content_same": false
        },
        {
          "line": 3102,
          "old_api": "GetProfileCounterFor",
          "new_api": "Status::OK()",
          "old_text": "GetProfileCounterFor(*hlo)",
          "new_text": "Status::OK()",
          "old_line_content": "  if (auto* prof_counter = GetProfileCounterFor(*hlo)) {",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3106,
          "old_api": "count",
          "new_api": "GetProfileCounterFor",
          "old_text": "instruction_to_profile_idx_.count(hlo)",
          "new_text": "GetProfileCounterFor(*hlo)",
          "old_line_content": "  if (instruction_to_profile_idx_.count(hlo)) {",
          "new_line_content": "  if (auto* prof_counter = GetProfileCounterFor(*hlo)) {",
          "content_same": false
        },
        {
          "line": 3107,
          "old_api": "GetExecutableRunOptionsArgument",
          "new_api": "RecordCycleDelta",
          "old_text": "GetExecutableRunOptionsArgument()",
          "new_text": "profiling_state_.RecordCycleDelta(&b_, hlo, prof_counter)",
          "old_line_content": "    tracing_state_.EmitTracingEnd(&b_, hlo, GetExecutableRunOptionsArgument());",
          "new_line_content": "    profiling_state_.RecordCycleDelta(&b_, hlo, prof_counter);",
          "content_same": false
        },
        {
          "line": 3113,
          "old_api": "GetEmittedValueFor",
          "new_api": "Status::OK()",
          "old_text": "GetEmittedValueFor(hlo)",
          "new_text": "Status::OK()",
          "old_line_content": "  llvm::Value* value_for_op = GetEmittedValueFor(hlo);",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3143,
          "old_api": "profile_counters_arg",
          "new_api": "llvm_ir::ShapeToIrType(shape, module_)",
          "old_text": "compute_function_->profile_counters_arg()",
          "new_text": "llvm_ir::ShapeToIrType(shape, module_)",
          "old_line_content": "  return compute_function_->profile_counters_arg();",
          "new_line_content": "  return llvm_ir::ShapeToIrType(shape, module_);",
          "content_same": false
        },
        {
          "line": 3147,
          "old_api": "buffer_table_arg",
          "new_api": "profile_counters_arg",
          "old_text": "compute_function_->buffer_table_arg()",
          "new_text": "compute_function_->profile_counters_arg()",
          "old_line_content": "  return compute_function_->buffer_table_arg();",
          "new_line_content": "  return compute_function_->profile_counters_arg();",
          "content_same": false
        },
        {
          "line": 3151,
          "old_api": "exec_run_options_arg",
          "new_api": "buffer_table_arg",
          "old_text": "compute_function_->exec_run_options_arg()",
          "new_text": "compute_function_->buffer_table_arg()",
          "old_line_content": "  return compute_function_->exec_run_options_arg();",
          "new_line_content": "  return compute_function_->buffer_table_arg();",
          "content_same": false
        },
        {
          "line": 3160,
          "old_api": "end",
          "new_api": "allocation",
          "old_text": "computation_parameter_allocations_.end()",
          "new_text": "slice.allocation()",
          "old_line_content": "    if (param_it != computation_parameter_allocations_.end()) {",
          "new_line_content": "  const BufferAllocation& allocation = *slice.allocation();",
          "content_same": false
        },
        {
          "line": 3176,
          "old_api": "AttachAlignmentMetadataForLoad",
          "new_api": "llvm_ir::EmitBufferIndexingGEP(params, param_number, &b_)",
          "old_text": "AttachAlignmentMetadataForLoad(param_address_untyped, target_shape)",
          "new_text": "llvm_ir::EmitBufferIndexingGEP(params, param_number, &b_)",
          "old_line_content": "        AttachAlignmentMetadataForLoad(param_address_untyped, target_shape);",
          "new_line_content": "          llvm_ir::EmitBufferIndexingGEP(params, param_number, &b_);",
          "content_same": false
        },
        {
          "line": 3177,
          "old_api": "AttachDereferenceableMetadataForLoad",
          "new_api": "Load",
          "old_text": "AttachDereferenceableMetadataForLoad(param_address_untyped,\n                                             target_shape)",
          "new_text": "Load(param_address_offset)",
          "old_line_content": "        AttachDereferenceableMetadataForLoad(param_address_untyped,",
          "new_line_content": "      llvm::LoadInst* param_address_untyped = Load(param_address_offset);",
          "content_same": false
        },
        {
          "line": 3189,
          "old_api": "function",
          "new_api": "size",
          "old_text": "compute_function_->function()",
          "new_text": "assigned_buffers.size()",
          "old_line_content": "        compute_function_->function(), slice};",
          "new_line_content": "    CHECK_EQ(1, assigned_buffers.size());",
          "content_same": false
        },
        {
          "line": 3190,
          "old_api": "find",
          "new_api": "begin",
          "old_text": "thread_local_buffers_.find(key)",
          "new_text": "assigned_buffers.begin()->first->shape()",
          "old_line_content": "    auto buf_it = thread_local_buffers_.find(key);",
          "new_line_content": "    const Shape& shape = assigned_buffers.begin()->first->shape();",
          "content_same": false
        },
        {
          "line": 3193,
          "old_api": "ToString",
          "new_api": "function",
          "old_text": "slice.ToString()",
          "new_text": "compute_function_->function()",
          "old_line_content": "          IrShapeType(shape), absl::StrCat(\"thread_local\", slice.ToString()),",
          "new_line_content": "        compute_function_->function(), slice};",
          "content_same": false
        },
        {
          "line": 3194,
          "old_api": "MinimumAlignmentForShape",
          "new_api": "find",
          "old_text": "MinimumAlignmentForShape(target_shape)",
          "new_text": "thread_local_buffers_.find(key)",
          "old_line_content": "          &b_, MinimumAlignmentForShape(target_shape));",
          "new_line_content": "    auto buf_it = thread_local_buffers_.find(key);",
          "content_same": false
        },
        {
          "line": 3195,
          "old_api": "insert",
          "new_api": "end",
          "old_text": "thread_local_buffers_.insert({key, buffer})",
          "new_text": "thread_local_buffers_.end()",
          "old_line_content": "      auto it_inserted_pair = thread_local_buffers_.insert({key, buffer});",
          "new_line_content": "    if (buf_it == thread_local_buffers_.end()) {",
          "content_same": false
        },
        {
          "line": 3196,
          "old_api": "CHECK",
          "new_api": "ToString",
          "old_text": "CHECK(it_inserted_pair.second)",
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n          IrShapeType(shape), absl::StrCat(\"thread_local\", slice.ToString()),\n          &b_, MinimumAlignmentForShape(target_shape))",
          "old_line_content": "      CHECK(it_inserted_pair.second);",
          "new_line_content": "      llvm::Value* buffer = llvm_ir::EmitAllocaAtFunctionEntry(",
          "content_same": false
        },
        {
          "line": 3210,
          "old_api": "debug_options",
          "new_api": "allocation",
          "old_text": "hlo_module_config_.debug_options()\n          .xla_llvm_enable_invariant_load_metadata()",
          "new_text": "slice.allocation()",
          "old_line_content": "  if (hlo_module_config_.debug_options()",
          "new_line_content": "  const BufferAllocation& allocation = *slice.allocation();",
          "content_same": false
        },
        {
          "line": 3212,
          "old_api": "setMetadata",
          "new_api": "index",
          "old_text": "tempbuf_address_base->setMetadata(\n        llvm::LLVMContext::MD_invariant_load,\n        llvm::MDNode::get(tempbuf_address_base->getContext(), /*MDs=*/{}))",
          "new_text": "slice.index()",
          "old_line_content": "    tempbuf_address_base->setMetadata(",
          "new_line_content": "      GetBufferTableArgument(), slice.index(), &b_);",
          "content_same": false
        },
        {
          "line": 3214,
          "old_api": "getContext",
          "new_api": "debug_options",
          "old_text": "tempbuf_address_base->getContext()",
          "new_text": "hlo_module_config_.debug_options()\n          .xla_llvm_enable_invariant_load_metadata()",
          "old_line_content": "        llvm::MDNode::get(tempbuf_address_base->getContext(), /*MDs=*/{}));",
          "new_line_content": "  if (hlo_module_config_.debug_options()",
          "content_same": false
        },
        {
          "line": 3216,
          "old_api": "size",
          "new_api": "setMetadata",
          "old_text": "allocation.size()",
          "new_text": "tempbuf_address_base->setMetadata(\n        llvm::LLVMContext::MD_invariant_load,\n        llvm::MDNode::get(tempbuf_address_base->getContext(), /*MDs=*/{}))",
          "old_line_content": "  AttachAlignmentMetadataForLoad(tempbuf_address_base, allocation.size());",
          "new_line_content": "    tempbuf_address_base->setMetadata(",
          "content_same": false
        },
        {
          "line": 3220,
          "old_api": "offset",
          "new_api": "size",
          "old_text": "slice.offset()",
          "new_text": "allocation.size()",
          "old_line_content": "  if (slice.offset() > 0) {",
          "new_line_content": "  AttachAlignmentMetadataForLoad(tempbuf_address_base, allocation.size());",
          "content_same": false
        },
        {
          "line": 3236,
          "old_api": "getPointerTo",
          "new_api": "EmitThreadLocalBufferPointer",
          "old_text": "IrShapeType(target_shape)->getPointerTo()",
          "new_text": "EmitThreadLocalBufferPointer(slice, target_shape)",
          "old_line_content": "        IrShapeType(target_shape)->getPointerTo());",
          "new_line_content": "    return EmitThreadLocalBufferPointer(slice, target_shape);",
          "content_same": false
        },
        {
          "line": 3238,
          "old_api": "EmitGlobalBufferPointer",
          "new_api": "allocation",
          "old_text": "EmitGlobalBufferPointer(slice, target_shape)",
          "new_text": "BitCast(\n        FindOrDie(constant_buffer_to_global_, slice.allocation()->index()),\n        IrShapeType(target_shape)->getPointerTo())",
          "old_line_content": "    return EmitGlobalBufferPointer(slice, target_shape);",
          "new_line_content": "    return BitCast(",
          "content_same": false
        },
        {
          "line": 3247,
          "old_api": "IrName",
          "new_api": "shape",
          "old_text": "IrName(op)",
          "new_text": "op->shape()",
          "old_line_content": "  addr->setName(IrName(op));",
          "new_line_content": "  const Shape& target_shape = op->shape();",
          "content_same": false
        },
        {
          "line": 3265,
          "old_api": "GetIrArrayFor",
          "new_api": "ToString",
          "old_text": "GetIrArrayFor(target_op)",
          "new_text": "target_op->ToString()",
          "old_line_content": "  llvm_ir::IrArray target_array = GetIrArrayFor(target_op);",
          "new_line_content": "  VLOG(2) << \"EmitTargetElementLoop: \" << target_op->ToString();",
          "content_same": false
        },
        {
          "line": 3267,
          "old_api": "opcode",
          "new_api": "shape",
          "old_text": "target_op->opcode()",
          "new_text": "target_op->shape()",
          "old_line_content": "  if (target_shape.IsTuple() && (target_op->opcode() == HloOpcode::kFusion ||",
          "new_line_content": "  const Shape& target_shape = target_op->shape();",
          "content_same": false
        },
        {
          "line": 3268,
          "old_api": "opcode",
          "new_api": "EmitTargetAddressForOp",
          "old_text": "target_op->opcode()",
          "new_text": "EmitTargetAddressForOp(target_op)",
          "old_line_content": "                                 target_op->opcode() == HloOpcode::kReduce)) {",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(target_op));",
          "content_same": false
        },
        {
          "line": 3272,
          "old_api": "ShapeUtil::TupleElementCount(target_shape)",
          "new_api": "opcode",
          "old_text": "ShapeUtil::TupleElementCount(target_shape)",
          "new_text": "target_op->opcode()",
          "old_line_content": "    for (int64 i = 0; i < ShapeUtil::TupleElementCount(target_shape); ++i) {",
          "new_line_content": "                                 target_op->opcode() == HloOpcode::kReduce)) {",
          "content_same": false
        },
        {
          "line": 3276,
          "old_api": "EmitBufferPointer",
          "new_api": "ShapeUtil::TupleElementCount(target_shape)",
          "old_text": "EmitBufferPointer(slice, element_shape)",
          "new_text": "ShapeUtil::TupleElementCount(target_shape)",
          "old_line_content": "      llvm::Value* op_target_address = EmitBufferPointer(slice, element_shape);",
          "new_line_content": "    for (int64 i = 0; i < ShapeUtil::TupleElementCount(target_shape); ++i) {",
          "content_same": false
        },
        {
          "line": 3280,
          "old_api": "EmitLoop",
          "new_api": "EmitBufferPointer",
          "old_text": "TF_RETURN_IF_ERROR(\n        llvm_ir::LoopEmitter(element_generator, output_arrays, &b_)\n            .EmitLoop(IrName(target_op)))",
          "new_text": "EmitBufferPointer(slice, element_shape)",
          "old_line_content": "    TF_RETURN_IF_ERROR(",
          "new_line_content": "      llvm::Value* op_target_address = EmitBufferPointer(slice, element_shape);",
          "content_same": false
        },
        {
          "line": 3281,
          "old_api": "EmitLoop",
          "new_api": "push_back",
          "old_text": "llvm_ir::LoopEmitter(element_generator, output_arrays, &b_)\n            .EmitLoop(IrName(target_op))",
          "new_text": "output_arrays.push_back(\n          llvm_ir::IrArray(op_target_address, element_shape))",
          "old_line_content": "        llvm_ir::LoopEmitter(element_generator, output_arrays, &b_)",
          "new_line_content": "      output_arrays.push_back(",
          "content_same": false
        },
        {
          "line": 3282,
          "old_api": "IrName",
          "new_api": "llvm_ir::IrArray(op_target_address, element_shape)",
          "old_text": "IrName(target_op)",
          "new_text": "llvm_ir::IrArray(op_target_address, element_shape)",
          "old_line_content": "            .EmitLoop(IrName(target_op)));",
          "new_line_content": "          llvm_ir::IrArray(op_target_address, element_shape));",
          "content_same": false
        },
        {
          "line": 3285,
          "old_api": "size",
          "new_api": "EmitLoop",
          "old_text": "output_arrays.size()",
          "new_text": "llvm_ir::LoopEmitter(element_generator, output_arrays, &b_)\n            .EmitLoop(IrName(target_op))",
          "old_line_content": "    for (int64 i = 0; i < output_arrays.size(); ++i) {",
          "new_line_content": "        llvm_ir::LoopEmitter(element_generator, output_arrays, &b_)",
          "content_same": false
        },
        {
          "line": 3286,
          "old_api": "GetBasePointer",
          "new_api": "IrName",
          "old_text": "output_arrays[i].GetBasePointer()",
          "new_text": "IrName(target_op)",
          "old_line_content": "      tuple_operand_ptrs.push_back(output_arrays[i].GetBasePointer());",
          "new_line_content": "            .EmitLoop(IrName(target_op)));",
          "content_same": false
        },
        {
          "line": 3298,
          "old_api": "IrName",
          "new_api": "GetDynamicLoopBounds",
          "old_text": "IrName(target_op)",
          "new_text": "compute_function_->GetDynamicLoopBounds()",
          "old_line_content": "                             .EmitLoop(IrName(target_op)));",
          "new_line_content": "          compute_function_->GetDynamicLoopBounds();",
          "content_same": false
        },
        {
          "line": 3305,
          "old_api": "Status::OK()",
          "new_api": "EmitLoop",
          "old_text": "Status::OK()",
          "new_text": "llvm_ir::LoopEmitter(element_generator, target_array, &b_)\n              .EmitLoop(IrName(target_op))",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "          llvm_ir::LoopEmitter(element_generator, target_array, &b_)",
          "content_same": false
        },
        {
          "line": 3314,
          "old_api": "MemCpy",
          "new_api": "GetEmittedValueFor",
          "old_text": "MemCpy(destination_value, /*DstAlign=*/1, source_value,\n         /*SrcAlign=*/1, source_size)",
          "new_text": "GetEmittedValueFor(&source)",
          "old_line_content": "  MemCpy(destination_value, /*DstAlign=*/1, source_value,",
          "new_line_content": "  llvm::Value* source_value = GetEmittedValueFor(&source);",
          "content_same": false
        },
        {
          "line": 3316,
          "old_api": "Status::OK()",
          "new_api": "shape",
          "old_text": "Status::OK()",
          "new_text": "source.shape()",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  int64 source_size = ByteSizeOf(source.shape());",
          "content_same": false
        },
        {
          "line": 3328,
          "old_api": "empty",
          "new_api": "shape",
          "old_text": "operands.empty()",
          "new_text": "TF_RET_CHECK(\n        ShapeUtil::SameElementType(operands[0]->shape(), operand->shape()))",
          "old_line_content": "  TF_RET_CHECK(!operands.empty());",
          "new_line_content": "    TF_RET_CHECK(",
          "content_same": false
        },
        {
          "line": 3329,
          "old_api": "element_type",
          "new_api": "shape",
          "old_text": "operands[0]->shape().element_type()",
          "new_text": "operand->shape()",
          "old_line_content": "  PrimitiveType primitive_type = operands[0]->shape().element_type();",
          "new_line_content": "        ShapeUtil::SameElementType(operands[0]->shape(), operand->shape()));",
          "content_same": false
        },
        {
          "line": 3332,
          "old_api": "PrimitiveType_Name",
          "new_api": "empty",
          "old_text": "PrimitiveType_Name(primitive_type)",
          "new_text": "operands.empty()",
          "old_line_content": "                         PrimitiveType_Name(primitive_type),",
          "new_line_content": "  TF_RET_CHECK(!operands.empty());",
          "content_same": false
        },
        {
          "line": 3333,
          "old_api": "opcode",
          "new_api": "element_type",
          "old_text": "instruction.opcode()",
          "new_text": "operands[0]->shape().element_type()",
          "old_line_content": "                         HloOpcodeString(instruction.opcode()));",
          "new_line_content": "  PrimitiveType primitive_type = operands[0]->shape().element_type();",
          "content_same": false
        },
        {
          "line": 3335,
          "old_api": "Status::OK()",
          "new_api": "opcode",
          "old_text": "Status::OK()",
          "new_text": "Unimplemented(\"unsupported operand type %s in op %s\",\n                         PrimitiveType_Name(primitive_type),\n                         HloOpcodeString(instruction.opcode()))",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "    return Unimplemented(\"unsupported operand type %s in op %s\",",
          "content_same": false
        },
        {
          "line": 3346,
          "old_api": "MakeElementGenerator",
          "new_api": "EmitReadArrayElement",
          "old_text": "EmitTargetElementLoop(\n      hlo, elemental_emitter.MakeElementGenerator(hlo, operand_to_generator))",
          "new_text": "GetIrArrayFor(operand).EmitReadArrayElement(index, &b_)",
          "old_line_content": "  return EmitTargetElementLoop(",
          "new_line_content": "      return GetIrArrayFor(operand).EmitReadArrayElement(index, &b_);",
          "content_same": false
        },
        {
          "line": 3366,
          "old_api": "IsTuple",
          "new_api": "absl::c_binary_search(thread_local_computations_, &callee)",
          "old_text": "return_shape.IsTuple()",
          "new_text": "absl::c_binary_search(thread_local_computations_, &callee)",
          "old_line_content": "      return_shape.IsTuple() &&",
          "new_line_content": "  CHECK(absl::c_binary_search(thread_local_computations_, &callee));",
          "content_same": false
        },
        {
          "line": 3367,
          "old_api": "tuple_shapes",
          "new_api": "root_instruction",
          "old_text": "return_shape.tuple_shapes()",
          "new_text": "callee.root_instruction()->shape()",
          "old_line_content": "      absl::c_all_of(return_shape.tuple_shapes(), [&](const Shape& shape) {",
          "new_line_content": "  const Shape& return_shape = callee.root_instruction()->shape();",
          "content_same": false
        },
        {
          "line": 3368,
          "old_api": "ShapeUtil::IsScalar(shape)",
          "new_api": "ShapeUtil::IsScalar(return_shape)",
          "old_text": "ShapeUtil::IsScalar(shape)",
          "new_text": "ShapeUtil::IsScalar(return_shape)",
          "old_line_content": "        return ShapeUtil::IsScalar(shape);",
          "new_line_content": "  bool is_scalar_return = ShapeUtil::IsScalar(return_shape);",
          "content_same": false
        },
        {
          "line": 3370,
          "old_api": "CHECK",
          "new_api": "IsTuple",
          "old_text": "CHECK(is_scalar_return || is_tuple_of_scalars_return)",
          "new_text": "return_shape.IsTuple()",
          "old_line_content": "  CHECK(is_scalar_return || is_tuple_of_scalars_return);",
          "new_line_content": "      return_shape.IsTuple() &&",
          "content_same": false
        },
        {
          "line": 3374,
          "old_api": "getType",
          "new_api": "CHECK",
          "old_text": "parameter->getType()->isPointerTy()",
          "new_text": "CHECK(is_scalar_return || is_tuple_of_scalars_return)",
          "old_line_content": "    CHECK(!parameter->getType()->isPointerTy());",
          "new_line_content": "  CHECK(is_scalar_return || is_tuple_of_scalars_return);",
          "content_same": false
        },
        {
          "line": 3378,
          "old_api": "push_back",
          "new_api": "getType",
          "old_text": "parameter_addrs.push_back(parameter_addr)",
          "new_text": "parameter->getType()->isPointerTy()",
          "old_line_content": "    parameter_addrs.push_back(parameter_addr);",
          "new_line_content": "    CHECK(!parameter->getType()->isPointerTy());",
          "content_same": false
        },
        {
          "line": 3382,
          "old_api": "llvm_ir::ShapeToIrType(return_shape, module_)",
          "new_api": "push_back",
          "old_text": "llvm_ir::ShapeToIrType(return_shape, module_)",
          "new_text": "parameter_addrs.push_back(parameter_addr)",
          "old_line_content": "      llvm_ir::ShapeToIrType(return_shape, module_);",
          "new_line_content": "    parameter_addrs.push_back(parameter_addr);",
          "content_same": false
        },
        {
          "line": 3386,
          "old_api": "element_type",
          "new_api": "llvm_ir::ShapeToIrType(return_shape, module_)",
          "old_text": "return_shape.element_type()",
          "new_text": "llvm_ir::ShapeToIrType(return_shape, module_)",
          "old_line_content": "          ? MinimumAlignmentForPrimitiveType(return_shape.element_type())",
          "new_line_content": "      llvm_ir::ShapeToIrType(return_shape, module_);",
          "content_same": false
        },
        {
          "line": 3400,
          "old_api": "llvm_ir::EmitTupleAllocasAtFunctionEntry(return_shape, &b_)",
          "new_api": "tuple_shapes_size",
          "old_text": "llvm_ir::EmitTupleAllocasAtFunctionEntry(return_shape, &b_)",
          "new_text": "return_shape.tuple_shapes_size()",
          "old_line_content": "        llvm_ir::EmitTupleAllocasAtFunctionEntry(return_shape, &b_);",
          "new_line_content": "    CHECK_LT(return_shape.tuple_shapes_size(), max_tuple_size)",
          "content_same": false
        },
        {
          "line": 3407,
          "old_api": "getInt8PtrTy",
          "new_api": "EmitTuple",
          "old_text": "GetArrayFunctionCallArguments(\n           parameter_addrs, &b_, name,\n           /*return_value_buffer=*/return_value_buffer,\n           /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),\n           /*buffer_table_arg=*/\n           llvm::Constant::getNullValue(b_.getInt8PtrTy()->getPointerTo()),\n           /*profile_counters_arg=*/GetProfileCountersArgument())",
          "new_text": "EmitTuple(tuple_array, allocas_for_returned_scalars, &b_)",
          "old_line_content": "       GetArrayFunctionCallArguments(",
          "new_line_content": "    EmitTuple(tuple_array, allocas_for_returned_scalars, &b_);",
          "content_same": false
        },
        {
          "line": 3410,
          "old_api": "GetExecutableRunOptionsArgument",
          "new_api": "FindOrDie",
          "old_text": "GetExecutableRunOptionsArgument()",
          "new_text": "FindOrDie(emitted_functions_, &callee)",
          "old_line_content": "           /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),",
          "new_line_content": "  Call(FindOrDie(emitted_functions_, &callee),",
          "content_same": false
        },
        {
          "line": 3416,
          "old_api": "size",
          "new_api": "getInt8PtrTy",
          "old_text": "allocas_for_returned_scalars.size()",
          "new_text": "b_.getInt8PtrTy()->getPointerTo()",
          "old_line_content": "  returned_scalars.reserve(allocas_for_returned_scalars.size());",
          "new_line_content": "           llvm::Constant::getNullValue(b_.getInt8PtrTy()->getPointerTo()),",
          "content_same": false
        },
        {
          "line": 3431,
          "old_api": "getInt8PtrTy",
          "new_api": "FindOrDie",
          "old_text": "b_.getInt8PtrTy()",
          "new_text": "FindOrDie(emitted_functions_, &callee)",
          "old_line_content": "           llvm::Constant::getNullValue(b_.getInt8PtrTy()),",
          "new_line_content": "  Call(FindOrDie(emitted_functions_, &callee),",
          "content_same": false
        },
        {
          "line": 3432,
          "old_api": "GetExecutableRunOptionsArgument",
          "new_api": "getInt8PtrTy",
          "old_text": "GetExecutableRunOptionsArgument()",
          "new_text": "GetArrayFunctionCallArguments(\n           /*parameter_addresses=*/{}, &b_, name,\n           /*return_value_buffer=*/\n           llvm::Constant::getNullValue(b_.getInt8PtrTy()),\n           /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),\n           /*buffer_table_arg=*/GetBufferTableArgument(),\n           /*profile_counters_arg=*/GetProfileCountersArgument())",
          "old_line_content": "           /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),",
          "new_line_content": "       GetArrayFunctionCallArguments(",
          "content_same": false
        },
        {
          "line": 3445,
          "old_api": "GetUniqueTopLevelSlice",
          "new_api": "getInt8PtrTy",
          "old_text": "assignment_.GetUniqueTopLevelSlice(root_inst).ValueOrDie()",
          "new_text": "b_.getInt8PtrTy()",
          "old_line_content": "      assignment_.GetUniqueTopLevelSlice(root_inst).ValueOrDie();",
          "new_line_content": "    return llvm::Constant::getNullValue(b_.getInt8PtrTy());",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2048,
          "old_api": null,
          "new_api": "std::to_string(i)",
          "old_text": null,
          "new_text": "std::to_string(i)",
          "old_line_content": "        initial_value_generators[i](llvm_ir::IrArray::Index(index.GetType())));",
          "new_line_content": "        accumulator_llvm_type, \"accumulator_\" + std::to_string(i), &b_,",
          "content_same": false
        },
        {
          "line": 2053,
          "old_api": null,
          "new_api": "Store",
          "old_text": null,
          "new_text": "Store(init_value, accumulator_addr)",
          "old_line_content": "  // The enclosing loops go over all the target elements. Now we have to compute",
          "new_line_content": "    Store(init_value, accumulator_addr);",
          "content_same": false
        },
        {
          "line": 2054,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "accumulator_addrs.push_back(accumulator_addr)",
          "old_line_content": "  // the actual target element. For this, we build a new loop nest to iterate",
          "new_line_content": "    accumulator_addrs.push_back(accumulator_addr);",
          "content_same": false
        },
        {
          "line": 2062,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(reduce, \"inner\")",
          "old_line_content": "                                         \"reduction_dim\");",
          "new_line_content": "  llvm_ir::ForLoopNest loops(IrName(reduce, \"inner\"), &b_);",
          "content_same": false
        },
        {
          "line": 2063,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "reduce->operand(0)",
          "old_line_content": "",
          "new_line_content": "  const HloInstruction* arg = reduce->operand(0);",
          "content_same": false
        },
        {
          "line": 2065,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "arg->shape()",
          "old_line_content": "",
          "new_line_content": "      loops.AddLoopsForShapeOnDimensions(arg->shape(), reduced_dimensions,",
          "content_same": false
        },
        {
          "line": 2068,
          "old_api": null,
          "new_api": "GetInnerLoopBodyBasicBlock",
          "old_text": null,
          "new_text": "loops.GetInnerLoopBodyBasicBlock()",
          "old_line_content": "  // fill in the rest of the dimensions with induction Value*s taken from",
          "new_line_content": "  SetToFirstInsertPoint(loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 2075,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "index.begin()",
          "old_line_content": "      i = *it++;",
          "new_line_content": "  llvm_ir::IrArray::Index::const_iterator it = index.begin();",
          "content_same": false
        },
        {
          "line": 2082,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "index.end()",
          "old_line_content": "  std::vector<llvm::Value*> reduction_operands;",
          "new_line_content": "  CHECK(index.end() == it);",
          "content_same": false
        },
        {
          "line": 2083,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "arg->shape()",
          "old_line_content": "  for (llvm::Value* accum : accumulator_addrs) {",
          "new_line_content": "  llvm_ir::IrArray::Index input_index(input_multi_index, arg->shape(),",
          "content_same": false
        },
        {
          "line": 2088,
          "old_api": null,
          "new_api": "Load",
          "old_text": null,
          "new_text": "Load(accum)",
          "old_line_content": "  for (int i = 0; i < accumulators_count; i++) {",
          "new_line_content": "    llvm::Value* accum_value = Load(accum);",
          "content_same": false
        },
        {
          "line": 2089,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "reduction_operands.push_back(accum_value)",
          "old_line_content": "    TF_ASSIGN_OR_RETURN(llvm::Value* const input_element,",
          "new_line_content": "    reduction_operands.push_back(accum_value);",
          "content_same": false
        },
        {
          "line": 2098,
          "old_api": null,
          "new_api": "to_apply",
          "old_text": null,
          "new_text": "EmitThreadLocalCall(\n      *reduce->to_apply(), reduction_operands, \"reduce_function\")",
          "old_line_content": "  for (int i = 0; i < accumulators_count; i++) {",
          "new_line_content": "  std::vector<llvm::Value*> results = EmitThreadLocalCall(",
          "content_same": false
        },
        {
          "line": 2103,
          "old_api": null,
          "new_api": "Store",
          "old_text": null,
          "new_text": "Store(results[i], accumulator_addrs[i])",
          "old_line_content": "  if (is_variadic) {",
          "new_line_content": "    Store(results[i], accumulator_addrs[i]);",
          "content_same": false
        },
        {
          "line": 2109,
          "old_api": null,
          "new_api": "getContext",
          "old_text": null,
          "new_text": "llvm::UndefValue::get(\n        llvm::StructType::get(b_.getContext(), accumulator_types))",
          "old_line_content": "      returned_structure =",
          "new_line_content": "    llvm::Value* returned_structure = llvm::UndefValue::get(",
          "content_same": false
        },
        {
          "line": 2112,
          "old_api": null,
          "new_api": "Load",
          "old_text": null,
          "new_text": "Load(accumulator_addrs[i])",
          "old_line_content": "    return returned_structure;",
          "new_line_content": "      llvm::Value* accumulator_value = Load(accumulator_addrs[i]);",
          "content_same": false
        },
        {
          "line": 2118,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "accumulator_addrs.size()",
          "old_line_content": "",
          "new_line_content": "    CHECK_EQ(accumulator_addrs.size(), 1);",
          "content_same": false
        },
        {
          "line": 2119,
          "old_api": null,
          "new_api": "Load",
          "old_text": null,
          "new_text": "Load(accumulator_addrs[0])",
          "old_line_content": "Status IrEmitter::HandleReduce(HloInstruction* reduce) {",
          "new_line_content": "    return Load(accumulator_addrs[0]);",
          "content_same": false
        },
        {
          "line": 2125,
          "old_api": null,
          "new_api": "mutable_operand",
          "old_text": null,
          "new_text": "reduce->mutable_operand(1)",
          "old_line_content": "    string vectorization_failure_reason;",
          "new_line_content": "  auto init_value = reduce->mutable_operand(1);",
          "content_same": false
        },
        {
          "line": 2126,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "reduce->dimensions()",
          "old_line_content": "    TF_ASSIGN_OR_RETURN(",
          "new_line_content": "  absl::Span<const int64> dimensions(reduce->dimensions());",
          "content_same": false
        },
        {
          "line": 2127,
          "old_api": null,
          "new_api": "to_apply",
          "old_text": null,
          "new_text": "reduce->to_apply()",
          "old_line_content": "        bool vectorization_successful,",
          "new_line_content": "  HloComputation* function = reduce->to_apply();",
          "content_same": false
        },
        {
          "line": 2128,
          "old_api": null,
          "new_api": "options::VectorizedReduceDisabled(hlo_module_config_)",
          "old_text": null,
          "new_text": "options::VectorizedReduceDisabled(hlo_module_config_)",
          "old_line_content": "        EmitVectorizedReduce(reduce, arg, init_value, dimensions, function,",
          "new_line_content": "  if (!options::VectorizedReduceDisabled(hlo_module_config_)) {",
          "content_same": false
        },
        {
          "line": 2137,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "    }",
          "new_line_content": "      return Status::OK();",
          "content_same": false
        },
        {
          "line": 2139,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "reduce->ToString()",
          "old_line_content": "",
          "new_line_content": "      VLOG(1) << \"Could not vectorize reduction \" << reduce->ToString() << \": \"",
          "content_same": false
        },
        {
          "line": 2148,
          "old_api": null,
          "new_api": "Unimplemented",
          "old_text": null,
          "new_text": "Unimplemented(\"AllToAll is not implemented on CPU.\")",
          "old_line_content": "  // TODO(b/33942983): Support Send/Recv on CPU.",
          "new_line_content": "  return Unimplemented(\"AllToAll is not implemented on CPU.\");",
          "content_same": false
        },
        {
          "line": 2153,
          "old_api": null,
          "new_api": "Unimplemented",
          "old_text": null,
          "new_text": "Unimplemented(\"Send is not implemented on CPU.\")",
          "old_line_content": "  // TODO(b/33942983): Support Send/Recv on CPU.",
          "new_line_content": "  return Unimplemented(\"Send is not implemented on CPU.\");",
          "content_same": false
        },
        {
          "line": 2170,
          "old_api": null,
          "new_api": "ShouldEmitParallelLoopFor",
          "old_text": null,
          "new_text": "ShouldEmitParallelLoopFor(*slice)",
          "old_line_content": "  // The code below assumes the layouts are equal.",
          "new_line_content": "  if (ShouldEmitParallelLoopFor(*slice)) {",
          "content_same": false
        },
        {
          "line": 2176,
          "old_api": null,
          "new_api": "DefaultAction",
          "old_text": null,
          "new_text": "DefaultAction(slice)",
          "old_line_content": "",
          "new_line_content": "    return DefaultAction(slice);",
          "content_same": false
        },
        {
          "line": 2179,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(slice)",
          "old_line_content": "  }",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(slice));",
          "content_same": false
        },
        {
          "line": 2185,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "operand->shape().layout()",
          "old_line_content": "  // copied from the source to the target. This is done by looking at the",
          "new_line_content": "  const Layout& layout = operand->shape().layout();",
          "content_same": false
        },
        {
          "line": 2186,
          "old_api": null,
          "new_api": "dimensions_size",
          "old_text": null,
          "new_text": "operand->shape().dimensions_size()",
          "old_line_content": "  // source/target layout in minor to major order and do the following:",
          "new_line_content": "  const int64 num_dims = operand->shape().dimensions_size();",
          "content_same": false
        },
        {
          "line": 2202,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "slice->shape().dimensions(dim)",
          "old_line_content": "  }",
          "new_line_content": "    if (operand->shape().dimensions(dim) != slice->shape().dimensions(dim)) {",
          "content_same": false
        },
        {
          "line": 2205,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "inner_dims.insert(dim)",
          "old_line_content": "  if (is_trivial_copy) {",
          "new_line_content": "    inner_dims.insert(dim);",
          "content_same": false
        },
        {
          "line": 2208,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "inner_dims.size()",
          "old_line_content": "    } else {",
          "new_line_content": "  const bool is_trivial_copy = (inner_dims.size() == num_dims);",
          "content_same": false
        },
        {
          "line": 2210,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "slice->shape()",
          "old_line_content": "    }",
          "new_line_content": "    if (ShapeUtil::IsEffectiveScalar(slice->shape())) {",
          "content_same": false
        },
        {
          "line": 2211,
          "old_api": null,
          "new_api": "DefaultAction",
          "old_text": null,
          "new_text": "DefaultAction(slice)",
          "old_line_content": "  }",
          "new_line_content": "      return DefaultAction(slice);",
          "content_same": false
        },
        {
          "line": 2213,
          "old_api": null,
          "new_api": "EmitMemcpy",
          "old_text": null,
          "new_text": "EmitMemcpy(*slice, *operand)",
          "old_line_content": "  // The memcpy will copy elements that are logically this shape (allowed to be",
          "new_line_content": "      return EmitMemcpy(*slice, *operand);",
          "content_same": false
        },
        {
          "line": 2219,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "ShapeUtil::FilterDimensions(\n      [&inner_dims](int64 dim) { return inner_dims.contains(dim); },\n      operand->shape())",
          "old_line_content": "  const int64 primitive_elements_per_logical_element =",
          "new_line_content": "  const Shape logical_element_shape = ShapeUtil::FilterDimensions(",
          "content_same": false
        },
        {
          "line": 2221,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "operand->shape()",
          "old_line_content": "",
          "new_line_content": "      operand->shape());",
          "content_same": false
        },
        {
          "line": 2228,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "inner_dims.size()",
          "old_line_content": "  // to memcpy. We can only copy 1 element at a time if there is a non-trivial",
          "new_line_content": "  const int64 memcpy_dim = LayoutUtil::Minor(layout, inner_dims.size());",
          "content_same": false
        },
        {
          "line": 2230,
          "old_api": null,
          "new_api": "slice_strides",
          "old_text": null,
          "new_text": "slice->slice_strides(memcpy_dim)",
          "old_line_content": "  const int64 memcpy_logical_elements =",
          "new_line_content": "  const bool memcpy_is_contiguous = slice->slice_strides(memcpy_dim) == 1;",
          "content_same": false
        },
        {
          "line": 2236,
          "old_api": null,
          "new_api": "slice_starts",
          "old_text": null,
          "new_text": "slice->slice_starts(memcpy_dim)",
          "old_line_content": "  std::vector<int64> outer_dims;",
          "new_line_content": "          ? slice->slice_limits(memcpy_dim) - slice->slice_starts(memcpy_dim)",
          "content_same": false
        },
        {
          "line": 2241,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "inner_dims.size()",
          "old_line_content": "  // Is the slice along the memcpy dimension contiguous? If not, then memcpy_dim",
          "new_line_content": "  for (int64 i = 0; i < num_dims - inner_dims.size() - 1; ++i) {",
          "content_same": false
        },
        {
          "line": 2242,
          "old_api": null,
          "new_api": "LayoutUtil::Major(layout, i)",
          "old_text": null,
          "new_text": "LayoutUtil::Major(layout, i)",
          "old_line_content": "  // needs to be wrapped around a loop as well.",
          "new_line_content": "    outer_dims.push_back(LayoutUtil::Major(layout, i));",
          "content_same": false
        },
        {
          "line": 2248,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "outer_dims.push_back(memcpy_dim)",
          "old_line_content": "",
          "new_line_content": "    outer_dims.push_back(memcpy_dim);",
          "content_same": false
        },
        {
          "line": 2251,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(slice)",
          "old_line_content": "  std::vector<llvm::Value*> target_multi_index =",
          "new_line_content": "  llvm_ir::IrArray target_array = GetIrArrayFor(slice);",
          "content_same": false
        },
        {
          "line": 2253,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "outer_dims.size()",
          "old_line_content": "",
          "new_line_content": "  const int64 num_outer_loops = outer_dims.size();",
          "content_same": false
        },
        {
          "line": 2254,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(slice)",
          "old_line_content": "  // Only the indices for the outer dimensions have been initialized in",
          "new_line_content": "  llvm_ir::ForLoopNest loops(IrName(slice), &b_);",
          "content_same": false
        },
        {
          "line": 2256,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "slice->shape()",
          "old_line_content": "  // for the rest of the dimensions the copy writes to the full dimension.",
          "new_line_content": "      loops.AddLoopsForShapeOnDimensions(slice->shape(), outer_dims, \"slice\");",
          "content_same": false
        },
        {
          "line": 2262,
          "old_api": null,
          "new_api": "static_cast<llvm::Value*>(nullptr)",
          "old_text": null,
          "new_text": "static_cast<llvm::Value*>(nullptr)",
          "old_line_content": "",
          "new_line_content": "               static_cast<llvm::Value*>(nullptr),",
          "content_same": false
        },
        {
          "line": 2263,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "b_.getInt64(0)",
          "old_line_content": "  if (num_outer_loops > 0) {",
          "new_line_content": "               static_cast<llvm::Value*>(b_.getInt64(0)));",
          "content_same": false
        },
        {
          "line": 2265,
          "old_api": null,
          "new_api": "getInt64Ty",
          "old_text": null,
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "  }",
          "new_line_content": "                                       b_.getInt64Ty());",
          "content_same": false
        },
        {
          "line": 2271,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(operand)",
          "old_line_content": "",
          "new_line_content": "  llvm_ir::IrArray source_array = GetIrArrayFor(operand);",
          "content_same": false
        },
        {
          "line": 2272,
          "old_api": null,
          "new_api": "SourceIndexOfSlice",
          "old_text": null,
          "new_text": "target_index.SourceIndexOfSlice(\n      /*operand_shape=*/operand->shape(), /*starts=*/slice->slice_starts(),\n      /*strides=*/slice->slice_strides(), /*builder=*/&b_)",
          "old_line_content": "  llvm::Value* memcpy_dest =",
          "new_line_content": "  const llvm_ir::IrArray::Index source_index = target_index.SourceIndexOfSlice(",
          "content_same": false
        },
        {
          "line": 2274,
          "old_api": null,
          "new_api": "slice_strides",
          "old_text": null,
          "new_text": "slice->slice_strides()",
          "old_line_content": "  llvm::Value* memcpy_source =",
          "new_line_content": "      /*strides=*/slice->slice_strides(), /*builder=*/&b_);",
          "content_same": false
        },
        {
          "line": 2277,
          "old_api": null,
          "new_api": "EmitArrayElementAddress",
          "old_text": null,
          "new_text": "target_array.EmitArrayElementAddress(target_index, &b_, \"slice.dest\")",
          "old_line_content": "  const int64 memcpy_elements =",
          "new_line_content": "      target_array.EmitArrayElementAddress(target_index, &b_, \"slice.dest\");",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": null,
          "new_api": "EmitArrayElementAddress",
          "old_text": null,
          "new_text": "source_array.EmitArrayElementAddress(source_index, &b_, \"slice.source\")",
          "old_line_content": "",
          "new_line_content": "      source_array.EmitArrayElementAddress(source_index, &b_, \"slice.source\");",
          "content_same": false
        },
        {
          "line": 2285,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "slice->shape().element_type()",
          "old_line_content": "    const int64 memcpy_bytes =",
          "new_line_content": "                       slice->shape().element_type(), target_array,",
          "content_same": false
        },
        {
          "line": 2288,
          "old_api": null,
          "new_api": "VLOG_IS_ON",
          "old_text": null,
          "new_text": "VLOG_IS_ON(2)",
          "old_line_content": "            << num_outer_loops << \" loops\";",
          "new_line_content": "  if (VLOG_IS_ON(2)) {",
          "content_same": false
        },
        {
          "line": 2290,
          "old_api": null,
          "new_api": "ShapeUtil::ByteSizeOf(logical_element_shape)",
          "old_text": null,
          "new_text": "ShapeUtil::ByteSizeOf(logical_element_shape)",
          "old_line_content": "",
          "new_line_content": "        ShapeUtil::ByteSizeOf(logical_element_shape) * memcpy_elements;",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(2)",
          "old_line_content": "  if (num_outer_loops > 0) {",
          "new_line_content": "    VLOG(2) << \"  emitted copy of \" << memcpy_bytes << \" bytes inside \"",
          "content_same": false
        },
        {
          "line": 2296,
          "old_api": null,
          "new_api": "GetOuterLoopExitBasicBlock",
          "old_text": null,
          "new_text": "loops.GetOuterLoopExitBasicBlock()",
          "old_line_content": "}",
          "new_line_content": "    SetToFirstInsertPoint(loops.GetOuterLoopExitBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 2304,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(dynamic_slice)",
          "old_line_content": "}",
          "new_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(dynamic_slice));",
          "content_same": false
        },
        {
          "line": 2305,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "dynamic_slice->operand(0)",
          "old_line_content": "",
          "new_line_content": "    return EmitMemcpy(*dynamic_slice->operand(0), *dynamic_slice);",
          "content_same": false
        },
        {
          "line": 2307,
          "old_api": null,
          "new_api": "DefaultAction",
          "old_text": null,
          "new_text": "DefaultAction(dynamic_slice)",
          "old_line_content": "    HloInstruction* dynamic_update_slice) {",
          "new_line_content": "  return DefaultAction(dynamic_slice);",
          "content_same": false
        },
        {
          "line": 2313,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "dynamic_update_slice->shape()",
          "old_line_content": "                                                   assignment_)) {",
          "new_line_content": "  if (ShapeUtil::IsScalar(dynamic_update_slice->shape())) {",
          "content_same": false
        },
        {
          "line": 2319,
          "old_api": null,
          "new_api": "GetIrArraysForOperandsOf",
          "old_text": null,
          "new_text": "GetIrArraysForOperandsOf(dynamic_update_slice)",
          "old_line_content": "  }",
          "new_line_content": "    auto operands = GetIrArraysForOperandsOf(dynamic_update_slice);",
          "content_same": false
        },
        {
          "line": 2321,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(dynamic_update_slice)",
          "old_line_content": "}",
          "new_line_content": "        operands, GetIrArrayFor(dynamic_update_slice),",
          "content_same": false
        },
        {
          "line": 2322,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(dynamic_update_slice, \"in_place\")",
          "old_line_content": "",
          "new_line_content": "        IrName(dynamic_update_slice, \"in_place\"), &b_);",
          "content_same": false
        },
        {
          "line": 2324,
          "old_api": null,
          "new_api": "DefaultAction",
          "old_text": null,
          "new_text": "DefaultAction(dynamic_update_slice)",
          "old_line_content": "  // TODO(b/33942983): Support Send/Recv on CPU.",
          "new_line_content": "  return DefaultAction(dynamic_update_slice);",
          "content_same": false
        },
        {
          "line": 2329,
          "old_api": null,
          "new_api": "Unimplemented",
          "old_text": null,
          "new_text": "Unimplemented(\"Recv is not implemented on CPU.\")",
          "old_line_content": "  // TODO(b/33942983): Support Send/Recv on CPU.",
          "new_line_content": "  return Unimplemented(\"Recv is not implemented on CPU.\");",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": null,
          "new_api": "IsArray",
          "old_text": null,
          "new_text": "copy->shape().IsArray()",
          "old_line_content": "    // kCopy shallow copies a tuple so just memcpy the top-level buffer.",
          "new_line_content": "      (copy->shape().IsArray() &&",
          "content_same": false
        },
        {
          "line": 2334,
          "old_api": null,
          "new_api": "Unimplemented",
          "old_text": null,
          "new_text": "Unimplemented(\"Recv-done is not implemented on CPU.\")",
          "old_line_content": "  // CPU backend does not properly handle negative padding but this is ok",
          "new_line_content": "  return Unimplemented(\"Recv-done is not implemented on CPU.\");",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "copy->operand(0)",
          "old_line_content": "  }",
          "new_line_content": "    return EmitMemcpy(*(copy->operand(0)), *copy);",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": null,
          "new_api": "DefaultAction",
          "old_text": null,
          "new_text": "DefaultAction(copy)",
          "old_line_content": "}",
          "new_line_content": "    return DefaultAction(copy);",
          "content_same": false
        },
        {
          "line": 2340,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "pad->padding_config().dimensions()",
          "old_line_content": "          \"Encountered negative padding in IrEmitter on CPU. \"",
          "new_line_content": "  for (auto& padding_dimension : pad->padding_config().dimensions()) {",
          "content_same": false
        },
        {
          "line": 293,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "Unimplemented(\"unsupported operand type %s for copy instruction\",\n                       PrimitiveType_Name(copy->shape().element_type()))",
          "old_line_content": "// Calculate the alignment of a buffer allocated for a given primitive type.",
          "new_line_content": "  return Unimplemented(\"unsupported operand type %s for copy instruction\",",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "copy->shape().element_type()",
          "old_line_content": "int IrEmitter::MinimumAlignmentForPrimitiveType(PrimitiveType primitive_type) {",
          "new_line_content": "                       PrimitiveType_Name(copy->shape().element_type()));",
          "content_same": false
        },
        {
          "line": 2341,
          "old_api": null,
          "new_api": "edge_padding_low",
          "old_text": null,
          "new_text": "padding_dimension.edge_padding_low()",
          "old_line_content": "          \"This should have been eliminated at the HLO level. \",",
          "new_line_content": "    if (padding_dimension.edge_padding_low() < 0 ||",
          "content_same": false
        },
        {
          "line": 2343,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "InternalErrorStrCat(\n          \"Encountered negative padding in IrEmitter on CPU. \"\n          \"This should have been eliminated at the HLO level. \",\n          pad->ToString())",
          "old_line_content": "    }",
          "new_line_content": "      return InternalErrorStrCat(",
          "content_same": false
        },
        {
          "line": 2346,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pad->ToString()",
          "old_line_content": "  // First, fill in the padding value to all output elements.",
          "new_line_content": "          pad->ToString());",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": null,
          "new_api": "DCHECK_GE",
          "old_text": null,
          "new_text": "DCHECK_GE(byte_size, 0)",
          "old_line_content": "",
          "new_line_content": "  DCHECK_GE(byte_size, 0);",
          "content_same": false
        },
        {
          "line": 303,
          "old_api": null,
          "new_api": "DCHECK_LE",
          "old_text": null,
          "new_text": "DCHECK_LE(byte_size, 16)",
          "old_line_content": "}",
          "new_line_content": "  DCHECK_LE(byte_size, 16);",
          "content_same": false
        },
        {
          "line": 2354,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "pad->operand(1)",
          "old_line_content": "",
          "new_line_content": "        const HloInstruction* padding_value = pad->operand(1);",
          "content_same": false
        },
        {
          "line": 2355,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(padding_value)",
          "old_line_content": "  // Create a loop to iterate over the operand elements and update the output",
          "new_line_content": "        llvm::Value* padding_value_addr = GetEmittedValueFor(padding_value);",
          "content_same": false
        },
        {
          "line": 2356,
          "old_api": null,
          "new_api": "Load",
          "old_text": null,
          "new_text": "Load(padding_value_addr)",
          "old_line_content": "  // locations where the operand elements should be stored.",
          "new_line_content": "        return Load(padding_value_addr);",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": null,
          "new_api": "getDataLayout",
          "old_text": null,
          "new_text": "module_->getDataLayout()",
          "old_line_content": "int IrEmitter::MinimumAlignmentForShape(const Shape& shape) {",
          "new_line_content": "  return llvm_ir::ByteSizeOf(shape, module_->getDataLayout());",
          "content_same": false
        },
        {
          "line": 2361,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(pad, \"assign\")",
          "old_line_content": "",
          "new_line_content": "  llvm_ir::ForLoopNest loops(IrName(pad, \"assign\"), &b_);",
          "content_same": false
        },
        {
          "line": 2364,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "operand->shape()",
          "old_line_content": "  // Load an element from the operand.",
          "new_line_content": "      loops.AddLoopsForShape(operand->shape(), \"operand\");",
          "content_same": false
        },
        {
          "line": 2366,
          "old_api": null,
          "new_api": "GetInnerLoopBodyBasicBlock",
          "old_text": null,
          "new_text": "loops.GetInnerLoopBodyBasicBlock()",
          "old_line_content": "  llvm::Value* operand_data =",
          "new_line_content": "  SetToFirstInsertPoint(loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 320,
          "old_api": null,
          "new_api": "DCHECK_GE",
          "old_text": null,
          "new_text": "DCHECK_GE(buffer_size, 0)",
          "old_line_content": "}",
          "new_line_content": "  DCHECK_GE(buffer_size, 0);",
          "content_same": false
        },
        {
          "line": 321,
          "old_api": null,
          "new_api": "DCHECK_LE",
          "old_text": null,
          "new_text": "DCHECK_LE(buffer_size, SIZE_MAX)",
          "old_line_content": "",
          "new_line_content": "  DCHECK_LE(buffer_size, SIZE_MAX);",
          "content_same": false
        },
        {
          "line": 323,
          "old_api": null,
          "new_api": "minimum_alignment_for_allocation",
          "old_text": null,
          "new_text": "target_machine_features_.minimum_alignment_for_allocation(buffer_size)",
          "old_line_content": "                                               const Shape& shape) {",
          "new_line_content": "  return target_machine_features_.minimum_alignment_for_allocation(buffer_size);",
          "content_same": false
        },
        {
          "line": 328,
          "old_api": null,
          "new_api": "MinimumAlignmentForShape",
          "old_text": null,
          "new_text": "MinimumAlignmentForShape(shape)",
          "old_line_content": "}",
          "new_line_content": "  int alignment = MinimumAlignmentForShape(shape);",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": null,
          "new_api": "llvm_ir::SetAlignmentMetadataForLoad(load, alignment)",
          "old_text": null,
          "new_text": "llvm_ir::SetAlignmentMetadataForLoad(load, alignment)",
          "old_line_content": "void IrEmitter::AttachAlignmentMetadataForLoad(llvm::LoadInst* load,",
          "new_line_content": "    llvm_ir::SetAlignmentMetadataForLoad(load, alignment);",
          "content_same": false
        },
        {
          "line": 2380,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "padding_config.dimensions(i).interior_padding()",
          "old_line_content": "  }",
          "new_line_content": "            b_.getInt64(padding_config.dimensions(i).interior_padding() + 1));",
          "content_same": false
        },
        {
          "line": 2381,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "Add(\n        offset, b_.getInt64(padding_config.dimensions(i).edge_padding_low()))",
          "old_line_content": "",
          "new_line_content": "    llvm::Value* index = Add(",
          "content_same": false
        },
        {
          "line": 2382,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "padding_config.dimensions(i).edge_padding_low()",
          "old_line_content": "  // Store the operand element to the computed output location.",
          "new_line_content": "        offset, b_.getInt64(padding_config.dimensions(i).edge_padding_low()));",
          "content_same": false
        },
        {
          "line": 2383,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "output_multi_index.push_back(index)",
          "old_line_content": "  llvm_ir::IrArray output_array(GetIrArrayFor(pad));",
          "new_line_content": "    output_multi_index.push_back(index);",
          "content_same": false
        },
        {
          "line": 337,
          "old_api": null,
          "new_api": "minimum_alignment_for_allocation",
          "old_text": null,
          "new_text": "target_machine_features_.minimum_alignment_for_allocation(buffer_size)",
          "old_line_content": "}",
          "new_line_content": "      target_machine_features_.minimum_alignment_for_allocation(buffer_size);",
          "content_same": false
        },
        {
          "line": 339,
          "old_api": null,
          "new_api": "llvm_ir::SetAlignmentMetadataForLoad(load, alignment)",
          "old_text": null,
          "new_text": "llvm_ir::SetAlignmentMetadataForLoad(load, alignment)",
          "old_line_content": "void IrEmitter::AttachDereferenceableMetadataForLoad(llvm::LoadInst* load,",
          "new_line_content": "    llvm_ir::SetAlignmentMetadataForLoad(load, alignment);",
          "content_same": false
        },
        {
          "line": 2390,
          "old_api": null,
          "new_api": "EmitWriteArrayElement",
          "old_text": null,
          "new_text": "output_array.EmitWriteArrayElement(output_index, operand_data, &b_)",
          "old_line_content": "}",
          "new_line_content": "  output_array.EmitWriteArrayElement(output_index, operand_data, &b_);",
          "content_same": false
        },
        {
          "line": 2392,
          "old_api": null,
          "new_api": "GetOuterLoopExitBasicBlock",
          "old_text": null,
          "new_text": "loops.GetOuterLoopExitBasicBlock()",
          "old_line_content": "Status IrEmitter::HandleFusion(HloInstruction* fusion) {",
          "new_line_content": "  SetToFirstInsertPoint(loops.GetOuterLoopExitBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 345,
          "old_api": null,
          "new_api": "ByteSizeOf",
          "old_text": null,
          "new_text": "ByteSizeOf(shape)",
          "old_line_content": "                                                     int64 buffer_size) {",
          "new_line_content": "  AttachDereferenceableMetadataForLoad(load, ByteSizeOf(shape));",
          "content_same": false
        },
        {
          "line": 2398,
          "old_api": null,
          "new_api": "llvm_ir::CanEmitFusedDynamicUpdateSliceInPlace(fusion, assignment_)",
          "old_text": null,
          "new_text": "llvm_ir::CanEmitFusedDynamicUpdateSliceInPlace(fusion, assignment_)",
          "old_line_content": "    // Delegate to common implementation of fused in-place dynamic-update-slice.",
          "new_line_content": "  if (llvm_ir::CanEmitFusedDynamicUpdateSliceInPlace(fusion, assignment_)) {",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": null,
          "new_api": "llvm_ir::SetDereferenceableMetadataForLoad(load, buffer_size)",
          "old_text": null,
          "new_text": "llvm_ir::SetDereferenceableMetadataForLoad(load, buffer_size)",
          "old_line_content": "Status IrEmitter::HandleGetTupleElement(HloInstruction* get_tuple_element) {",
          "new_line_content": "    llvm_ir::SetDereferenceableMetadataForLoad(load, buffer_size);",
          "content_same": false
        },
        {
          "line": 2401,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(fusion)",
          "old_line_content": "        &elemental_emitter, &b_);",
          "new_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(fusion));",
          "content_same": false
        },
        {
          "line": 2404,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(fusion)",
          "old_line_content": "    CpuElementalIrEmitter elemental_emitter(hlo_module_config_, this, module_);",
          "new_line_content": "        fusion, GetGeneratorForOperandIrArrays(fusion), GetIrArrayFor(fusion),",
          "content_same": false
        },
        {
          "line": 2407,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "                                 &elemental_emitter);",
          "new_line_content": "    VLOG(3) << \"HandleFusion kLoop\";",
          "content_same": false
        },
        {
          "line": 2409,
          "old_api": null,
          "new_api": "GetIrArraysForOperandsOf",
          "old_text": null,
          "new_text": "GetIrArraysForOperandsOf(fusion)",
          "old_line_content": "",
          "new_line_content": "    auto operands = GetIrArraysForOperandsOf(fusion);",
          "content_same": false
        },
        {
          "line": 362,
          "old_api": null,
          "new_api": "tuple_index",
          "old_text": null,
          "new_text": "llvm_ir::EmitGetTupleElement(\n      shape, get_tuple_element->tuple_index(), MinimumAlignmentForShape(shape),\n      GetEmittedValueFor(operand), &b_)",
          "old_line_content": "}",
          "new_line_content": "  emitted_value_[get_tuple_element] = llvm_ir::EmitGetTupleElement(",
          "content_same": false
        },
        {
          "line": 363,
          "old_api": null,
          "new_api": "MinimumAlignmentForShape",
          "old_text": null,
          "new_text": "MinimumAlignmentForShape(shape)",
          "old_line_content": "",
          "new_line_content": "      shape, get_tuple_element->tuple_index(), MinimumAlignmentForShape(shape),",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(operand)",
          "old_line_content": "Status IrEmitter::HandleSelect(HloInstruction* select) {",
          "new_line_content": "      GetEmittedValueFor(operand), &b_);",
          "content_same": false
        },
        {
          "line": 369,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "select->operand(0)",
          "old_line_content": "",
          "new_line_content": "  auto pred = select->operand(0);",
          "content_same": false
        },
        {
          "line": 370,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "pred->shape().element_type()",
          "old_line_content": "Status IrEmitter::HandleTupleSelect(HloInstruction* tuple_select) {",
          "new_line_content": "  TF_RET_CHECK(pred->shape().element_type() == PRED);",
          "content_same": false
        },
        {
          "line": 2418,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "root->operand(dot_op_index)",
          "old_line_content": "",
          "new_line_content": "    const HloInstruction* dot = root->operand(dot_op_index);",
          "content_same": false
        },
        {
          "line": 2421,
          "old_api": null,
          "new_api": "fused_instructions_computation",
          "old_text": null,
          "new_text": "fusion->fused_instructions_computation()->ToString()",
          "old_line_content": "    int64 addend_param_number =",
          "new_line_content": "        << fusion->fused_instructions_computation()->ToString();",
          "content_same": false
        },
        {
          "line": 2423,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "dot->operand(0)->parameter_number()",
          "old_line_content": "",
          "new_line_content": "    int64 dot_lhs_param_number = dot->operand(0)->parameter_number();",
          "content_same": false
        },
        {
          "line": 2428,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "fusion->shape()",
          "old_line_content": "    llvm_ir::IrArray lhs_array(",
          "new_line_content": "    Shape target_shape = fusion->shape();",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(pred)",
          "old_line_content": "}",
          "new_line_content": "  llvm_ir::EmitTupleSelect(GetIrArrayFor(tuple_select), GetIrArrayFor(pred),",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(on_true)",
          "old_line_content": "",
          "new_line_content": "                           GetEmittedValueFor(on_true),",
          "content_same": false
        },
        {
          "line": 384,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(on_false)",
          "old_line_content": "Status IrEmitter::HandleInfeed(HloInstruction* instruction) {",
          "new_line_content": "                           GetEmittedValueFor(on_false), &b_);",
          "content_same": false
        },
        {
          "line": 2430,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(fusion)",
          "old_line_content": "    llvm_ir::IrArray rhs_array(",
          "new_line_content": "    llvm_ir::IrArray target_array = GetIrArrayFor(fusion);",
          "content_same": false
        },
        {
          "line": 389,
          "old_api": null,
          "new_api": "Cast<HloInfeedInstruction>(instruction)",
          "old_text": null,
          "new_text": "Cast<HloInfeedInstruction>(instruction)",
          "old_line_content": "  // token value. HloInfeedInstruction::infeed_shape gives us the data shape.",
          "new_line_content": "  HloInfeedInstruction* infeed = Cast<HloInfeedInstruction>(instruction);",
          "content_same": false
        },
        {
          "line": 2440,
          "old_api": null,
          "new_api": "EmitDotOperation",
          "old_text": null,
          "new_text": "EmitDotOperation(*dot, target_array, lhs_array, rhs_array,\n                         &addend_array, GetExecutableRunOptionsArgument(), &b_,\n                         hlo_module_config_, target_machine_features_)",
          "old_line_content": "  } else {",
          "new_line_content": "        EmitDotOperation(*dot, target_array, lhs_array, rhs_array,",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": null,
          "new_api": "infeed_shape",
          "old_text": null,
          "new_text": "infeed->infeed_shape()",
          "old_line_content": "",
          "new_line_content": "  const Shape& data_shape = infeed->infeed_shape();",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "ShapeUtil::Equal(data_shape,\n                          ShapeUtil::GetTupleElementShape(infeed->shape(), 0))",
          "old_line_content": "  // Write the tuple index table.",
          "new_line_content": "  DCHECK(ShapeUtil::Equal(data_shape,",
          "content_same": false
        },
        {
          "line": 396,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "infeed->shape()",
          "old_line_content": "  TF_ASSIGN_OR_RETURN(BufferAllocation::Slice data_slice,",
          "new_line_content": "                          ShapeUtil::GetTupleElementShape(infeed->shape(), 0)));",
          "content_same": false
        },
        {
          "line": 397,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(infeed)",
          "old_line_content": "                      assignment_.GetUniqueSlice(infeed, {0}));",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(infeed));",
          "content_same": false
        },
        {
          "line": 2443,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "}",
          "new_line_content": "    return Status::OK();",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": null,
          "new_api": "Unimplemented",
          "old_text": null,
          "new_text": "Unimplemented(\"Fusion kind not implemented on CPU\")",
          "old_line_content": "Status IrEmitter::HandleCall(HloInstruction* call) {",
          "new_line_content": "    return Unimplemented(\"Fusion kind not implemented on CPU\");",
          "content_same": false
        },
        {
          "line": 2450,
          "old_api": null,
          "new_api": "to_apply",
          "old_text": null,
          "new_text": "call->to_apply()",
          "old_line_content": "",
          "new_line_content": "  HloComputation* computation = call->to_apply();",
          "content_same": false
        },
        {
          "line": 2453,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(call)",
          "old_line_content": "    // ParallelForkJoin.",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(call));",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": null,
          "new_api": "tuple_shapes_size",
          "old_text": null,
          "new_text": "data_shape.tuple_shapes_size()",
          "old_line_content": "      const Shape& tuple_element_shape =",
          "new_line_content": "    for (int64 i = 0; i < data_shape.tuple_shapes_size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2465,
          "old_api": null,
          "new_api": "root_instruction",
          "old_text": null,
          "new_text": "computation->root_instruction()",
          "old_line_content": "  } else {",
          "new_line_content": "    HloInstruction* root = computation->root_instruction();",
          "content_same": false
        },
        {
          "line": 2467,
          "old_api": null,
          "new_api": "outer_dimension_partitions",
          "old_text": null,
          "new_text": "root->outer_dimension_partitions()",
          "old_line_content": "  }",
          "new_line_content": "        call_args, root->shape(), root->outer_dimension_partitions(), &b_,",
          "content_same": false
        },
        {
          "line": 2468,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "computation->name()",
          "old_line_content": "",
          "new_line_content": "        call_ir_function, computation->name()));",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": null,
          "new_api": "ShapeUtil::GetTupleElementShape(data_shape, i)",
          "old_text": null,
          "new_text": "ShapeUtil::GetTupleElementShape(data_shape, i)",
          "old_line_content": "      // instruction. Target addresses for internal elements can be obtained",
          "new_line_content": "          ShapeUtil::GetTupleElementShape(data_shape, i);",
          "content_same": false
        },
        {
          "line": 2470,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "computation->name()",
          "old_line_content": "}",
          "new_line_content": "    EmitGlobalCall(*computation, computation->name());",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": null,
          "new_api": "EmitBufferPointer",
          "old_text": null,
          "new_text": "EmitBufferPointer(buffer, tuple_element_shape)",
          "old_line_content": "",
          "new_line_content": "          EmitBufferPointer(buffer, tuple_element_shape);",
          "content_same": false
        },
        {
          "line": 431,
          "old_api": null,
          "new_api": "EmitXfeedTransfer",
          "old_text": null,
          "new_text": "EmitXfeedTransfer(\n          XfeedKind::kInfeed, tuple_element_shape, tuple_element_address)",
          "old_line_content": "    }",
          "new_line_content": "      TF_RETURN_IF_ERROR(EmitXfeedTransfer(",
          "content_same": false
        },
        {
          "line": 2480,
          "old_api": null,
          "new_api": "getInt32",
          "old_text": null,
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntryWithCount(\n          i8_ptr_type, b_.getInt32(operands.size()), \"cc_operands_alloca\", &b_)",
          "old_line_content": "    llvm::Value* operand_as_i8ptr =",
          "new_line_content": "      llvm_ir::EmitAllocaAtFunctionEntryWithCount(",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "tuple_element_addresses.push_back(tuple_element_address)",
          "old_line_content": "                       tuple_element_addresses, &b_);",
          "new_line_content": "      tuple_element_addresses.push_back(tuple_element_address);",
          "content_same": false
        },
        {
          "line": 2482,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "operands.size()",
          "old_line_content": "    llvm::Value* slot_in_operands_alloca =",
          "new_line_content": "  for (size_t i = 0; i < operands.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2485,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(operand)",
          "old_line_content": "  }",
          "new_line_content": "        PointerCast(GetEmittedValueFor(operand), i8_ptr_type);",
          "content_same": false
        },
        {
          "line": 2487,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "b_.getInt64(i)",
          "old_line_content": "    // Mark the alloca as initialized for msan. The buffer gets read by the",
          "new_line_content": "        InBoundsGEP(operands_alloca, {b_.getInt64(i)});",
          "content_same": false
        },
        {
          "line": 2488,
          "old_api": null,
          "new_api": "Store",
          "old_text": null,
          "new_text": "Store(operand_as_i8ptr, slot_in_operands_alloca)",
          "old_line_content": "    // custom callee, which might be msan-instrumented.",
          "new_line_content": "    Store(operand_as_i8ptr, slot_in_operands_alloca);",
          "content_same": false
        },
        {
          "line": 441,
          "old_api": null,
          "new_api": "EmitXfeedTransfer",
          "old_text": null,
          "new_text": "EmitXfeedTransfer(XfeedKind::kInfeed, data_shape, data_address)",
          "old_line_content": "}",
          "new_line_content": "        EmitXfeedTransfer(XfeedKind::kInfeed, data_shape, data_address));",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "                                    llvm::Value* program_buffer_address) {",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2494,
          "old_api": null,
          "new_api": "getDataLayout",
          "old_text": null,
          "new_text": "module_->getDataLayout()",
          "old_line_content": "            ->getOrInsertFunction(",
          "new_line_content": "    const llvm::DataLayout& dl = module_->getDataLayout();",
          "content_same": false
        },
        {
          "line": 2495,
          "old_api": null,
          "new_api": "getIntPtrTy",
          "old_text": null,
          "new_text": "b_.getIntPtrTy(dl)",
          "old_line_content": "                \"__msan_unpoison\",",
          "new_line_content": "    llvm::Type* intptr_type = b_.getIntPtrTy(dl);",
          "content_same": false
        },
        {
          "line": 449,
          "old_api": null,
          "new_api": "ByteSizeOf",
          "old_text": null,
          "new_text": "ByteSizeOf(shape)",
          "old_line_content": "        \"size range\",",
          "new_line_content": "  int64 length = ByteSizeOf(shape);",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": null,
          "new_api": "std::numeric_limits<int32>::max()",
          "old_text": null,
          "new_text": "std::numeric_limits<int32>::max()",
          "old_line_content": "        length);",
          "new_line_content": "  if (length <= 0 || length > std::numeric_limits<int32>::max()) {",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": null,
          "new_api": "InvalidArgument",
          "old_text": null,
          "new_text": "InvalidArgument(\n        \"xfeed (infeed or outfeed) buffer length %d is outside the valid \"\n        \"size range\",\n        length)",
          "old_line_content": "  }",
          "new_line_content": "    return InvalidArgument(",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": null,
          "new_api": "static_cast<int32>(length)",
          "old_text": null,
          "new_text": "static_cast<int32>(length)",
          "old_line_content": "      llvm::Value * shape_ptr,",
          "new_line_content": "  int32 length_32 = static_cast<int32>(length);",
          "content_same": false
        },
        {
          "line": 2504,
          "old_api": null,
          "new_api": "getAllocationSizeInBits",
          "old_text": null,
          "new_text": "Call(msan_unpoison_ir_function,\n         {PointerCast(operands_alloca, i8_ptr_type),\n          llvm::ConstantInt::get(\n              intptr_type, *operands_alloca->getAllocationSizeInBits(dl) / 8)})",
          "old_line_content": "  }",
          "new_line_content": "    Call(msan_unpoison_ir_function,",
          "content_same": false
        },
        {
          "line": 2507,
          "old_api": null,
          "new_api": "getAllocationSizeInBits",
          "old_text": null,
          "new_text": "operands_alloca->getAllocationSizeInBits(dl)",
          "old_line_content": "          ->getOrInsertFunction(",
          "new_line_content": "              intptr_type, *operands_alloca->getAllocationSizeInBits(dl) / 8)});",
          "content_same": false
        },
        {
          "line": 463,
          "old_api": null,
          "new_api": "getInt32Ty",
          "old_text": null,
          "new_text": "b_.getInt32Ty()",
          "old_line_content": "      {/*run_options*/ i8_ptr_type, /*buffer_length*/ int32_type,",
          "new_line_content": "  llvm::Type* int32_type = b_.getInt32Ty();",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": null,
          "new_api": "getContext",
          "old_text": null,
          "new_text": "module_->getContext()",
          "old_line_content": "       /*shape_ptr*/ i8_ptr_type, /*shape_length*/ int32_type},",
          "new_line_content": "  llvm::Type* i8_ptr_type = llvm::Type::getInt8PtrTy(module_->getContext());",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": null,
          "new_api": "llvm::FunctionType::get(\n      i8_ptr_type,\n      {/*run_options*/ i8_ptr_type, /*buffer_length*/ int32_type,\n       /*shape_ptr*/ i8_ptr_type, /*shape_length*/ int32_type},\n      /*isVarArg=*/false)",
          "old_text": null,
          "new_text": "llvm::FunctionType::get(\n      i8_ptr_type,\n      {/*run_options*/ i8_ptr_type, /*buffer_length*/ int32_type,\n       /*shape_ptr*/ i8_ptr_type, /*shape_length*/ int32_type},\n      /*isVarArg=*/false)",
          "old_line_content": "      /*isVarArg=*/false);",
          "new_line_content": "  llvm::FunctionType* acquire_type = llvm::FunctionType::get(",
          "content_same": false
        },
        {
          "line": 2512,
          "old_api": null,
          "new_api": "custom_call_target",
          "old_text": null,
          "new_text": "custom_call->custom_call_target()",
          "old_line_content": "                  /*isVarArg=*/false))",
          "new_line_content": "              custom_call->custom_call_target(),",
          "content_same": false
        },
        {
          "line": 2513,
          "old_api": null,
          "new_api": "getVoidTy",
          "old_text": null,
          "new_text": "llvm::FunctionType::get(\n                  /*Result=*/b_.getVoidTy(),\n                  /*Params=*/{i8_ptr_type, operands_alloca->getType()},\n                  /*isVarArg=*/false)",
          "old_line_content": "          .getCallee());",
          "new_line_content": "              llvm::FunctionType::get(",
          "content_same": false
        },
        {
          "line": 2514,
          "old_api": null,
          "new_api": "getVoidTy",
          "old_text": null,
          "new_text": "b_.getVoidTy()",
          "old_line_content": "",
          "new_line_content": "                  /*Result=*/b_.getVoidTy(),",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": null,
          "new_api": "getCallee",
          "old_text": null,
          "new_text": "llvm::dyn_cast<llvm::Function>(\n        module_\n            ->getOrInsertFunction(\n                runtime::kAcquireInfeedBufferForDequeueSymbolName, acquire_type)\n            .getCallee())",
          "old_line_content": "            .getCallee());",
          "new_line_content": "    acquire_func = llvm::dyn_cast<llvm::Function>(",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": null,
          "new_api": "getCallee",
          "old_text": null,
          "new_text": "module_\n            ->getOrInsertFunction(\n                runtime::kAcquireInfeedBufferForDequeueSymbolName, acquire_type)\n            .getCallee()",
          "old_line_content": "  } else {",
          "new_line_content": "        module_",
          "content_same": false
        },
        {
          "line": 2521,
          "old_api": null,
          "new_api": "IsTuple",
          "old_text": null,
          "new_text": "custom_call->shape().IsTuple()",
          "old_line_content": "      const Shape& elem_shape =",
          "new_line_content": "  if (custom_call->shape().IsTuple()) {",
          "content_same": false
        },
        {
          "line": 479,
          "old_api": null,
          "new_api": "getCallee",
          "old_text": null,
          "new_text": "llvm::dyn_cast<llvm::Function>(\n        module_\n            ->getOrInsertFunction(\n                runtime::kAcquireOutfeedBufferForPopulationSymbolName,\n                acquire_type)\n            .getCallee())",
          "old_line_content": "                acquire_type)",
          "new_line_content": "    acquire_func = llvm::dyn_cast<llvm::Function>(",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": null,
          "new_api": "getCallee",
          "old_text": null,
          "new_text": "module_\n            ->getOrInsertFunction(\n                runtime::kAcquireOutfeedBufferForPopulationSymbolName,\n                acquire_type)\n            .getCallee()",
          "old_line_content": "            .getCallee());",
          "new_line_content": "        module_",
          "content_same": false
        },
        {
          "line": 2530,
          "old_api": null,
          "new_api": "EmitBufferPointer",
          "old_text": null,
          "new_text": "EmitBufferPointer(slice, elem_shape)",
          "old_line_content": "  }",
          "new_line_content": "      llvm::Value* addr = EmitBufferPointer(slice, elem_shape);",
          "content_same": false
        },
        {
          "line": 2531,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "base_ptrs.push_back(addr)",
          "old_line_content": "  auto* output_address_arg =",
          "new_line_content": "      base_ptrs.push_back(addr);",
          "content_same": false
        },
        {
          "line": 2533,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(custom_call)",
          "old_line_content": "",
          "new_line_content": "    llvm_ir::EmitTuple(GetIrArrayFor(custom_call), base_ptrs, &b_);",
          "content_same": false
        },
        {
          "line": 486,
          "old_api": null,
          "new_api": "setCallingConv",
          "old_text": null,
          "new_text": "acquire_func->setCallingConv(llvm::CallingConv::C)",
          "old_line_content": "      {/*run_options*/ i8_ptr_type, /*buffer_length*/ int32_type,",
          "new_line_content": "  acquire_func->setCallingConv(llvm::CallingConv::C);",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": null,
          "new_api": "getVoidTy",
          "old_text": null,
          "new_text": "llvm::FunctionType::get(\n      b_.getVoidTy(),\n      {/*run_options*/ i8_ptr_type, /*buffer_length*/ int32_type,\n       /*buffer_ptr*/ i8_ptr_type, /*shape_ptr*/ i8_ptr_type,\n       /*shape_length*/ int32_type},\n      /*isVarArg=*/false)",
          "old_line_content": "       /*shape_length*/ int32_type},",
          "new_line_content": "  llvm::FunctionType* release_type = llvm::FunctionType::get(",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": null,
          "new_api": "getVoidTy",
          "old_text": null,
          "new_text": "b_.getVoidTy()",
          "old_line_content": "      /*isVarArg=*/false);",
          "new_line_content": "      b_.getVoidTy(),",
          "content_same": false
        },
        {
          "line": 2538,
          "old_api": null,
          "new_api": "Call",
          "old_text": null,
          "new_text": "Call(custom_call_ir_function, {output_address_arg, operands_alloca})",
          "old_line_content": "",
          "new_line_content": "  Call(custom_call_ir_function, {output_address_arg, operands_alloca});",
          "content_same": false
        },
        {
          "line": 2540,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "  // Precondition: Condition computation must return a scalar bool.",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": null,
          "new_api": "getCallee",
          "old_text": null,
          "new_text": "llvm::dyn_cast<llvm::Function>(\n        module_\n            ->getOrInsertFunction(\n                runtime::kReleaseInfeedBufferAfterDequeueSymbolName,\n                release_type)\n            .getCallee())",
          "old_line_content": "                release_type)",
          "new_line_content": "    release_func = llvm::dyn_cast<llvm::Function>(",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": null,
          "new_api": "getCallee",
          "old_text": null,
          "new_text": "module_\n            ->getOrInsertFunction(\n                runtime::kReleaseInfeedBufferAfterDequeueSymbolName,\n                release_type)\n            .getCallee()",
          "old_line_content": "            .getCallee());",
          "new_line_content": "        module_",
          "content_same": false
        },
        {
          "line": 2546,
          "old_api": null,
          "new_api": "root_instruction",
          "old_text": null,
          "new_text": "condition->root_instruction()->shape()",
          "old_line_content": "  // Check that all while-related buffers share an allocation slice.",
          "new_line_content": "  TF_RET_CHECK(ShapeUtil::IsScalar(condition->root_instruction()->shape()) &&",
          "content_same": false
        },
        {
          "line": 2549,
          "old_api": null,
          "new_api": "root_instruction",
          "old_text": null,
          "new_text": "condition->root_instruction()->shape()",
          "old_line_content": "      [this, &xla_while](const Shape& /*subshape*/,",
          "new_line_content": "      << ShapeUtil::HumanString(condition->root_instruction()->shape());",
          "content_same": false
        },
        {
          "line": 2551,
          "old_api": null,
          "new_api": "GetUniqueSlice",
          "old_text": null,
          "new_text": "ShapeUtil::ForEachSubshapeWithStatus(\n      xla_while->shape(),\n      [this, &xla_while](const Shape& /*subshape*/,\n                         const ShapeIndex& index) -> Status {\n        auto check = [this](const HloInstruction* a, const HloInstruction* b,\n                            const ShapeIndex& index) {\n          const BufferAllocation::Slice slice_a =\n              assignment_.GetUniqueSlice(a, index).ConsumeValueOrDie();\n          const BufferAllocation::Slice slice_b =\n              assignment_.GetUniqueSlice(b, index).ConsumeValueOrDie();\n          if (slice_a != slice_b) {\n            return InternalError(\n                \"instruction %s %s does not share slice with \"\n                \"instruction %s %s\",\n                a->ToString(), slice_a.ToString(), b->ToString(),\n                slice_b.ToString());\n          }\n          return Status::OK();\n        };\n        TF_RETURN_IF_ERROR(check(xla_while, xla_while->operand(0), index));\n        TF_RETURN_IF_ERROR(check(\n            xla_while, xla_while->while_condition()->parameter_instruction(0),\n            index));\n        TF_RETURN_IF_ERROR(\n            check(xla_while, xla_while->while_body()->parameter_instruction(0),\n                  index));\n        TF_RETURN_IF_ERROR(check(\n            xla_while, xla_while->while_body()->root_instruction(), index));\n        return Status::OK();\n      })",
          "old_line_content": "        auto check = [this](const HloInstruction* a, const HloInstruction* b,",
          "new_line_content": "  TF_RETURN_IF_ERROR(ShapeUtil::ForEachSubshapeWithStatus(",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": null,
          "new_api": "getCallee",
          "old_text": null,
          "new_text": "llvm::dyn_cast<llvm::Function>(\n        module_\n            ->getOrInsertFunction(\n                runtime::kReleaseOutfeedBufferAfterPopulationSymbolName,\n                release_type)\n            .getCallee())",
          "old_line_content": "                release_type)",
          "new_line_content": "    release_func = llvm::dyn_cast<llvm::Function>(",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": null,
          "new_api": "getCallee",
          "old_text": null,
          "new_text": "module_\n            ->getOrInsertFunction(\n                runtime::kReleaseOutfeedBufferAfterPopulationSymbolName,\n                release_type)\n            .getCallee()",
          "old_line_content": "            .getCallee());",
          "new_line_content": "        module_",
          "content_same": false
        },
        {
          "line": 2552,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "xla_while->shape()",
          "old_line_content": "                            const ShapeIndex& index) {",
          "new_line_content": "      xla_while->shape(),",
          "content_same": false
        },
        {
          "line": 511,
          "old_api": null,
          "new_api": "setCallingConv",
          "old_text": null,
          "new_text": "release_func->setCallingConv(llvm::CallingConv::C)",
          "old_line_content": "  // check-failing the process if there is a mismatch, versus passing us back a",
          "new_line_content": "  release_func->setCallingConv(llvm::CallingConv::C);",
          "content_same": false
        },
        {
          "line": 2560,
          "old_api": null,
          "new_api": "GetUniqueSlice",
          "old_text": null,
          "new_text": "assignment_.GetUniqueSlice(b, index).ConsumeValueOrDie()",
          "old_line_content": "                \"instruction %s %s\",",
          "new_line_content": "              assignment_.GetUniqueSlice(b, index).ConsumeValueOrDie();",
          "content_same": false
        },
        {
          "line": 517,
          "old_api": null,
          "new_api": "getInt32",
          "old_text": null,
          "new_text": "Call(\n      acquire_func, {GetExecutableRunOptionsArgument(), b_.getInt32(length_32),\n                     shape_ptr, b_.getInt32(shape_length)})",
          "old_line_content": "  if (kind == XfeedKind::kInfeed) {",
          "new_line_content": "  llvm::Value* acquired_pointer = Call(",
          "content_same": false
        },
        {
          "line": 518,
          "old_api": null,
          "new_api": "getInt32",
          "old_text": null,
          "new_text": "b_.getInt32(length_32)",
          "old_line_content": "    // Copy to the program buffer address from the acquired buffer.",
          "new_line_content": "      acquire_func, {GetExecutableRunOptionsArgument(), b_.getInt32(length_32),",
          "content_same": false
        },
        {
          "line": 2565,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "b->ToString()",
          "old_line_content": "        };",
          "new_line_content": "                a->ToString(), slice_a.ToString(), b->ToString(),",
          "content_same": false
        },
        {
          "line": 2572,
          "old_api": null,
          "new_api": "while_condition",
          "old_text": null,
          "new_text": "xla_while->while_condition()->parameter_instruction(0)",
          "old_line_content": "                  index));",
          "new_line_content": "            xla_while, xla_while->while_condition()->parameter_instruction(0),",
          "content_same": false
        },
        {
          "line": 2577,
          "old_api": null,
          "new_api": "while_body",
          "old_text": null,
          "new_text": "check(\n            xla_while, xla_while->while_body()->root_instruction(), index)",
          "old_line_content": "",
          "new_line_content": "        TF_RETURN_IF_ERROR(check(",
          "content_same": false
        },
        {
          "line": 2578,
          "old_api": null,
          "new_api": "while_body",
          "old_text": null,
          "new_text": "xla_while->while_body()->root_instruction()",
          "old_line_content": "  // Set emitted value to that of 'init' with which it shares an allocation.",
          "new_line_content": "            xla_while, xla_while->while_body()->root_instruction(), index));",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": null,
          "new_api": "getInt32",
          "old_text": null,
          "new_text": "b_.getInt32(length_32)",
          "old_line_content": "}",
          "new_line_content": "  Call(release_func, {GetExecutableRunOptionsArgument(), b_.getInt32(length_32),",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": null,
          "new_api": "getInt32",
          "old_text": null,
          "new_text": "b_.getInt32(shape_length)",
          "old_line_content": "",
          "new_line_content": "                      acquired_pointer, shape_ptr, b_.getInt32(shape_length)});",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "  // Outfeed produces no useful result, but it does return a token[] that can be",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2583,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "xla_while->operand(0)",
          "old_line_content": "  //   while (Condition(while_result)) {",
          "new_line_content": "  const HloInstruction* init = xla_while->operand(0);",
          "content_same": false
        },
        {
          "line": 2584,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(init)",
          "old_line_content": "  //     // CopyInsertion pass inserts copies which enable 'while_result' to",
          "new_line_content": "  emitted_value_[xla_while] = GetEmittedValueFor(init);",
          "content_same": false
        },
        {
          "line": 542,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(outfeed)",
          "old_line_content": "",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(outfeed));",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(operand)",
          "old_line_content": "",
          "new_line_content": "  llvm::Value* value = GetEmittedValueFor(operand);",
          "content_same": false
        },
        {
          "line": 2595,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(xla_while, \"header\")",
          "old_line_content": "",
          "new_line_content": "      module_->getContext(), IrName(xla_while, \"header\"),",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": null,
          "new_api": "EmitXfeedTransfer",
          "old_text": null,
          "new_text": "EmitXfeedTransfer(XfeedKind::kOutfeed, operand_shape, value)",
          "old_line_content": "",
          "new_line_content": "    return EmitXfeedTransfer(XfeedKind::kOutfeed, operand_shape, value);",
          "content_same": false
        },
        {
          "line": 2596,
          "old_api": null,
          "new_api": "function",
          "old_text": null,
          "new_text": "compute_function_->function()",
          "old_line_content": "  // Calls the condition function to determine whether to proceed with the",
          "new_line_content": "      compute_function_->function());",
          "content_same": false
        },
        {
          "line": 2597,
          "old_api": null,
          "new_api": "Br",
          "old_text": null,
          "new_text": "Br(header_bb)",
          "old_line_content": "  // body.  It must return a bool, so use the scalar call form.",
          "new_line_content": "  Br(header_bb);",
          "content_same": false
        },
        {
          "line": 2602,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(xla_while, \"cond\")",
          "old_line_content": "",
          "new_line_content": "  EmitGlobalCall(*xla_while->while_condition(), IrName(xla_while, \"cond\"));",
          "content_same": false
        },
        {
          "line": 2603,
          "old_api": null,
          "new_api": "while_condition",
          "old_text": null,
          "new_text": "ICmpNE(\n      Load(GetBufferForGlobalCallReturnValue(*xla_while->while_condition())),\n      llvm::ConstantInt::get(llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0))",
          "old_line_content": "  // Branches to the body or to the while exit depending on the condition.",
          "new_line_content": "  llvm::Value* while_predicate = ICmpNE(",
          "content_same": false
        },
        {
          "line": 2604,
          "old_api": null,
          "new_api": "while_condition",
          "old_text": null,
          "new_text": "xla_while->while_condition()",
          "old_line_content": "  llvm::BasicBlock* body_bb =",
          "new_line_content": "      Load(GetBufferForGlobalCallReturnValue(*xla_while->while_condition())),",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": null,
          "new_api": "llvm_ir::EmitGetTupleElement(\n        tuple_element_shape, i, MinimumAlignmentForShape(tuple_element_shape),\n        value, &b_)",
          "old_text": null,
          "new_text": "llvm_ir::EmitGetTupleElement(\n        tuple_element_shape, i, MinimumAlignmentForShape(tuple_element_shape),\n        value, &b_)",
          "old_line_content": "                                         tuple_element_shape, tuple_element));",
          "new_line_content": "    llvm::Value* tuple_element = llvm_ir::EmitGetTupleElement(",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": null,
          "new_api": "MinimumAlignmentForShape",
          "old_text": null,
          "new_text": "MinimumAlignmentForShape(tuple_element_shape)",
          "old_line_content": "  }",
          "new_line_content": "        tuple_element_shape, i, MinimumAlignmentForShape(tuple_element_shape),",
          "content_same": false
        },
        {
          "line": 2610,
          "old_api": null,
          "new_api": "function",
          "old_text": null,
          "new_text": "compute_function_->function()",
          "old_line_content": "",
          "new_line_content": "                               compute_function_->function());",
          "content_same": false
        },
        {
          "line": 2611,
          "old_api": null,
          "new_api": "getContext",
          "old_text": null,
          "new_text": "llvm::BasicBlock::Create(\n      module_->getContext(), IrName(xla_while, \"exit\"))",
          "old_line_content": "  // Calls the body function from the body block.",
          "new_line_content": "  llvm::BasicBlock* exit_bb = llvm::BasicBlock::Create(",
          "content_same": false
        },
        {
          "line": 2613,
          "old_api": null,
          "new_api": "CondBr",
          "old_text": null,
          "new_text": "CondBr(while_predicate, body_bb, exit_bb)",
          "old_line_content": "",
          "new_line_content": "  CondBr(while_predicate, body_bb, exit_bb);",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": null,
          "new_api": "Cast<HloSortInstruction>(hlo)",
          "old_text": null,
          "new_text": "Cast<HloSortInstruction>(hlo)",
          "old_line_content": "  switch (keys_type) {",
          "new_line_content": "  const HloSortInstruction* sort = Cast<HloSortInstruction>(hlo);",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(sort)",
          "old_line_content": "    case PRED:",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(sort));",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": null,
          "new_api": "keys",
          "old_text": null,
          "new_text": "sort->keys()->shape()",
          "old_line_content": "    case S8:",
          "new_line_content": "  Shape keys_shape = sort->keys()->shape();",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "keys_shape.element_type()",
          "old_line_content": "    case U8:",
          "new_line_content": "  PrimitiveType keys_type = keys_shape.element_type();",
          "content_same": false
        },
        {
          "line": 2616,
          "old_api": null,
          "new_api": "SetInsertPoint",
          "old_text": null,
          "new_text": "b_.SetInsertPoint(body_bb)",
          "old_line_content": "",
          "new_line_content": "  b_.SetInsertPoint(body_bb);",
          "content_same": false
        },
        {
          "line": 2619,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(xla_while, \"body\")",
          "old_line_content": "",
          "new_line_content": "  EmitGlobalCall(*xla_while->while_body(), IrName(xla_while, \"body\"));",
          "content_same": false
        },
        {
          "line": 2625,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "compute_function_->function()->getBasicBlockList().push_back(exit_bb)",
          "old_line_content": "}",
          "new_line_content": "  compute_function_->function()->getBasicBlockList().push_back(exit_bb);",
          "content_same": false
        },
        {
          "line": 2626,
          "old_api": null,
          "new_api": "SetInsertPoint",
          "old_text": null,
          "new_text": "b_.SetInsertPoint(exit_bb)",
          "old_line_content": "",
          "new_line_content": "  b_.SetInsertPoint(exit_bb);",
          "content_same": false
        },
        {
          "line": 2628,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "    HloInstruction* concatenate, absl::Span<HloInstruction* const> operands,",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2634,
          "old_api": null,
          "new_api": "ShouldEmitParallelLoopFor",
          "old_text": null,
          "new_text": "ShouldEmitParallelLoopFor(*concatenate)",
          "old_line_content": "  }",
          "new_line_content": "  if (ShouldEmitParallelLoopFor(*concatenate)) {",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": null,
          "new_api": "PrimitiveType_Name",
          "old_text": null,
          "new_text": "PrimitiveType_Name(keys_type)",
          "old_line_content": "    ShapeIndex shape_index =",
          "new_line_content": "          PrimitiveType_Name(keys_type));",
          "content_same": false
        },
        {
          "line": 2640,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "concatenate->shape()",
          "old_line_content": "      return false;",
          "new_line_content": "  const Shape& output_shape = concatenate->shape();",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": null,
          "new_api": "operand_count",
          "old_text": null,
          "new_text": "sort->operand_count()",
          "old_line_content": "    // We assume that the layout of all involved operands and outputs is the",
          "new_line_content": "  for (int64 i = 0; i < sort->operand_count(); ++i) {",
          "content_same": false
        },
        {
          "line": 2642,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "output_shape.layout()",
          "old_line_content": "  }",
          "new_line_content": "    if (!LayoutUtil::Equal(op->shape().layout(), output_shape.layout())) {",
          "content_same": false
        },
        {
          "line": 599,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "TF_RET_CHECK(\n        LayoutUtil::LayoutsInShapesEqual(keys_shape, operand->shape()))",
          "old_line_content": "",
          "new_line_content": "    TF_RET_CHECK(",
          "content_same": false
        },
        {
          "line": 600,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "operand->shape()",
          "old_line_content": "    // The sort is implemented in-place, therefore we first copy the operand",
          "new_line_content": "        LayoutUtil::LayoutsInShapesEqual(keys_shape, operand->shape()));",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "LayoutUtil::LayoutsInShapesEqual(\n        keys_shape, ShapeUtil::GetSubshape(sort->shape(), shape_index))",
          "old_line_content": "    // buffer to the output buffer if they are not the same.",
          "new_line_content": "    TF_RET_CHECK(LayoutUtil::LayoutsInShapesEqual(",
          "content_same": false
        },
        {
          "line": 2652,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "concatenate->dimensions(0)",
          "old_line_content": "",
          "new_line_content": "  int64 concat_dim = concatenate->dimensions(0);",
          "content_same": false
        },
        {
          "line": 606,
          "old_api": null,
          "new_api": "GetAllocationSlice",
          "old_text": null,
          "new_text": "GetAllocationSlice(*sort, shape_index)",
          "old_line_content": "    if (destination_buffer != source_address) {",
          "new_line_content": "    auto destination_buffer = GetAllocationSlice(*sort, shape_index);",
          "content_same": false
        },
        {
          "line": 2658,
          "old_api": null,
          "new_api": "std::next(concat_dim_layout_itr)",
          "old_text": null,
          "new_text": "std::next(concat_dim_layout_itr)",
          "old_line_content": "",
          "new_line_content": "  std::vector<int64> outer_dims(std::next(concat_dim_layout_itr),",
          "content_same": false
        },
        {
          "line": 612,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "operand->shape().element_type()",
          "old_line_content": "             source_buffer,",
          "new_line_content": "          ShapeUtil::ByteSizeOfPrimitiveType(operand->shape().element_type());",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(operand)",
          "old_line_content": "             /*SrcAlign=*/primitive_type_size, size);",
          "new_line_content": "      auto source_buffer = GetEmittedValueFor(operand);",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "operand->shape()",
          "old_line_content": "    }",
          "new_line_content": "      int64 size = ByteSizeOf(operand->shape());",
          "content_same": false
        },
        {
          "line": 615,
          "old_api": null,
          "new_api": "MemCpy",
          "old_text": null,
          "new_text": "MemCpy(destination_addresses[i], /*DstAlign=*/primitive_type_size,\n             source_buffer,\n             /*SrcAlign=*/primitive_type_size, size)",
          "old_line_content": "  }",
          "new_line_content": "      MemCpy(destination_addresses[i], /*DstAlign=*/primitive_type_size,",
          "content_same": false
        },
        {
          "line": 2661,
          "old_api": null,
          "new_api": "getInt8PtrTy",
          "old_text": null,
          "new_text": "b_.getInt8PtrTy()",
          "old_line_content": "",
          "new_line_content": "  llvm::Type* i8_ptr_type = b_.getInt8PtrTy();",
          "content_same": false
        },
        {
          "line": 2663,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(concatenate)",
          "old_line_content": "  std::vector<llvm::Value*> target_multi_index =",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(concatenate));",
          "content_same": false
        },
        {
          "line": 2668,
          "old_api": null,
          "new_api": "AddLoopsForShapeOnDimensions",
          "old_text": null,
          "new_text": "loops.AddLoopsForShapeOnDimensions(output_shape, outer_dims, \"concat\")",
          "old_line_content": "  llvm_ir::IrArray::Index target_index(target_multi_index, output_shape,",
          "new_line_content": "      loops.AddLoopsForShapeOnDimensions(output_shape, outer_dims, \"concat\");",
          "content_same": false
        },
        {
          "line": 2670,
          "old_api": null,
          "new_api": "static_cast<llvm::Value*>(nullptr)",
          "old_text": null,
          "new_text": "static_cast<llvm::Value*>(nullptr)",
          "old_line_content": "",
          "new_line_content": "               static_cast<llvm::Value*>(nullptr),",
          "content_same": false
        },
        {
          "line": 623,
          "old_api": null,
          "new_api": "ShapeUtil::MakeShapeWithDescendingLayoutAndSamePhysicalLayout(keys_shape)",
          "old_text": null,
          "new_text": "ShapeUtil::MakeShapeWithDescendingLayoutAndSamePhysicalLayout(keys_shape)",
          "old_line_content": "  int64 sort_dimension_elements =",
          "new_line_content": "      ShapeUtil::MakeShapeWithDescendingLayoutAndSamePhysicalLayout(keys_shape);",
          "content_same": false
        },
        {
          "line": 625,
          "old_api": null,
          "new_api": "sort_dimension",
          "old_text": null,
          "new_text": "sort->sort_dimension()",
          "old_line_content": "  int64 higher_dimensions = 1;",
          "new_line_content": "      keys_shape.layout())[sort->sort_dimension()];",
          "content_same": false
        },
        {
          "line": 2673,
          "old_api": null,
          "new_api": "getInt64Ty",
          "old_text": null,
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "  }",
          "new_line_content": "                                       b_.getInt64Ty());",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "normalized_keys_shape.dimensions(physical_dimension_to_sort)",
          "old_line_content": "  }",
          "new_line_content": "      normalized_keys_shape.dimensions(physical_dimension_to_sort);",
          "content_same": false
        },
        {
          "line": 2676,
          "old_api": null,
          "new_api": "GetInnerLoopBodyBasicBlock",
          "old_text": null,
          "new_text": "loops.GetInnerLoopBodyBasicBlock()",
          "old_line_content": "  unsigned primitive_type_size =",
          "new_line_content": "    SetToFirstInsertPoint(loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "normalized_keys_shape.dimensions(i)",
          "old_line_content": "       i > physical_dimension_to_sort; --i) {",
          "new_line_content": "    higher_dimensions *= normalized_keys_shape.dimensions(i);",
          "content_same": false
        },
        {
          "line": 2679,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "output_shape.element_type()",
          "old_line_content": "  // Contiguous subregions from each operand to the concatenate contribute to a",
          "new_line_content": "  PrimitiveType primitive_type = output_shape.element_type();",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": null,
          "new_api": "rank",
          "old_text": null,
          "new_text": "normalized_keys_shape.rank()",
          "old_line_content": "",
          "new_line_content": "  for (int64 i = normalized_keys_shape.rank() - 1;",
          "content_same": false
        },
        {
          "line": 2685,
          "old_api": null,
          "new_api": "EmitArrayElementAddress",
          "old_text": null,
          "new_text": "BitCast(\n      target_array.EmitArrayElementAddress(target_index, &b_, \"target_region\"),\n      i8_ptr_type)",
          "old_line_content": "",
          "new_line_content": "  llvm::Value* target_region_begin = BitCast(",
          "content_same": false
        },
        {
          "line": 2686,
          "old_api": null,
          "new_api": "EmitArrayElementAddress",
          "old_text": null,
          "new_text": "target_array.EmitArrayElementAddress(target_index, &b_, \"target_region\")",
          "old_line_content": "  int64 inner_dims_product =",
          "new_line_content": "      target_array.EmitArrayElementAddress(target_index, &b_, \"target_region\"),",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": null,
          "new_api": "getInt64Ty",
          "old_text": null,
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "      /*isVarArg=*/false);",
          "new_line_content": "      {b_.getInt64Ty(), b_.getInt64Ty(), b_.getInt64Ty(),",
          "content_same": false
        },
        {
          "line": 2691,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "inner_dims.end()",
          "old_line_content": "",
          "new_line_content": "      std::accumulate(inner_dims.begin(), inner_dims.end(), 1l,",
          "content_same": false
        },
        {
          "line": 2693,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "output_shape.dimensions(inner_dim)",
          "old_line_content": "  // equal to the product of inner dimensions.",
          "new_line_content": "                        return product * output_shape.dimensions(inner_dim);",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": null,
          "new_api": "getType",
          "old_text": null,
          "new_text": "less_than_function->getType()",
          "old_line_content": "          ->getOrInsertFunction(runtime::kKeyValueSortSymbolName,",
          "new_line_content": "       b_.getInt64Ty()->getPointerTo(), less_than_function->getType()},",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": null,
          "new_api": "getCallee",
          "old_text": null,
          "new_text": "llvm::dyn_cast<llvm::Function>(\n      module_\n          ->getOrInsertFunction(runtime::kKeyValueSortSymbolName,\n                                key_value_sort_type)\n          .getCallee())",
          "old_line_content": "          .getCallee());",
          "new_line_content": "  auto* key_value_sort_func = llvm::dyn_cast<llvm::Function>(",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": null,
          "new_api": "setCallingConv",
          "old_text": null,
          "new_text": "key_value_sort_func->setCallingConv(llvm::CallingConv::C)",
          "old_line_content": "      &b_);",
          "new_line_content": "  key_value_sort_func->setCallingConv(llvm::CallingConv::C);",
          "content_same": false
        },
        {
          "line": 2701,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "operand->shape()",
          "old_line_content": "        i8_ptr_type);",
          "new_line_content": "    llvm_ir::IrArray::Index source_index(target_multi_index, operand->shape(),",
          "content_same": false
        },
        {
          "line": 2702,
          "old_api": null,
          "new_api": "getInt64Ty",
          "old_text": null,
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "",
          "new_line_content": "                                         b_.getInt64Ty());",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": null,
          "new_api": "operand_count",
          "old_text": null,
          "new_text": "sort->operand_count()",
          "old_line_content": "      &b_);",
          "new_line_content": "      b_.getInt8PtrTy(), b_.getInt32(sort->operand_count()), \"cc_values_alloca\",",
          "content_same": false
        },
        {
          "line": 2703,
          "old_api": null,
          "new_api": "EmitArrayElementAddress",
          "old_text": null,
          "new_text": "BitCast(\n        source_array.EmitArrayElementAddress(source_index, &b_, \"src_addr\"),\n        i8_ptr_type)",
          "old_line_content": "    llvm::Value* copy_target_address =",
          "new_line_content": "    llvm::Value* copy_source_address = BitCast(",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": null,
          "new_api": "getInt32Ty",
          "old_text": null,
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntryWithCount(\n      b_.getInt32Ty(), b_.getInt32(sort->operand_count()), \"cc_sizes_alloca\",\n      &b_)",
          "old_line_content": "    llvm::Value* value_as_i8ptr =",
          "new_line_content": "  llvm::Value* sizes = llvm_ir::EmitAllocaAtFunctionEntryWithCount(",
          "content_same": false
        },
        {
          "line": 2710,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "EmitTransferElements(\n        copy_target_address, copy_source_address,\n        inner_dims_product * input_shape.dimensions(concat_dim), primitive_type,\n        target_array, source_array)",
          "old_line_content": "",
          "new_line_content": "    EmitTransferElements(",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": null,
          "new_api": "getInt8PtrTy",
          "old_text": null,
          "new_text": "b_.getInt8PtrTy()",
          "old_line_content": "    llvm::Value* slot_in_sizes_alloca =",
          "new_line_content": "        PointerCast(destination_addresses[i], b_.getInt8PtrTy());",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": null,
          "new_api": "getInt32Ty",
          "old_text": null,
          "new_text": "b_.getInt32Ty()",
          "old_line_content": "  }",
          "new_line_content": "        ConstInBoundsGEP1_32(b_.getInt32Ty(), sizes, i);",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "ShapeUtil::ByteSizeOfPrimitiveType(\n        sort->operand(i)->shape().element_type())",
          "old_line_content": "",
          "new_line_content": "    llvm::Value* size = b_.getInt32(ShapeUtil::ByteSizeOfPrimitiveType(",
          "content_same": false
        },
        {
          "line": 2720,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "outer_dims.empty()",
          "old_line_content": "  return true;",
          "new_line_content": "  if (!outer_dims.empty()) {",
          "content_same": false
        },
        {
          "line": 2721,
          "old_api": null,
          "new_api": "GetOuterLoopExitBasicBlock",
          "old_text": null,
          "new_text": "loops.GetOuterLoopExitBasicBlock()",
          "old_line_content": "}",
          "new_line_content": "    SetToFirstInsertPoint(loops.GetOuterLoopExitBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "b_.getInt64(lower_dimensions)",
          "old_line_content": "",
          "new_line_content": "        b_.getInt64(lower_dimensions), values,",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": null,
          "new_api": "GetProfileCountersArgument",
          "old_text": null,
          "new_text": "GetProfileCountersArgument()",
          "old_line_content": "  }",
          "new_line_content": "        GetProfileCountersArgument(), less_than_function});",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": null,
          "new_api": "values_count",
          "old_text": null,
          "new_text": "sort->values_count()",
          "old_line_content": "}",
          "new_line_content": "  if (sort->values_count() > 0) {",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(sort)",
          "old_line_content": "",
          "new_line_content": "    llvm_ir::EmitTuple(GetIrArrayFor(sort), destination_addresses, &b_);",
          "content_same": false
        },
        {
          "line": 2734,
          "old_api": null,
          "new_api": "tensorflow::MathUtil::GCD<unsigned>(\n      primitive_type_size, MinimumAlignmentForPrimitiveType(primitive_type))",
          "old_text": null,
          "new_text": "tensorflow::MathUtil::GCD<unsigned>(\n      primitive_type_size, MinimumAlignmentForPrimitiveType(primitive_type))",
          "old_line_content": "",
          "new_line_content": "  unsigned element_alignment = tensorflow::MathUtil::GCD<unsigned>(",
          "content_same": false
        },
        {
          "line": 2735,
          "old_api": null,
          "new_api": "MinimumAlignmentForPrimitiveType",
          "old_text": null,
          "new_text": "MinimumAlignmentForPrimitiveType(primitive_type)",
          "old_line_content": "  if (element_count == 1) {",
          "new_line_content": "      primitive_type_size, MinimumAlignmentForPrimitiveType(primitive_type));",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(tuple)",
          "old_line_content": "  }",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(tuple));",
          "content_same": false
        },
        {
          "line": 2736,
          "old_api": null,
          "new_api": "llvm::PointerType::getUnqual(\n      llvm_ir::PrimitiveTypeToIrType(primitive_type, module_))",
          "old_text": null,
          "new_text": "llvm::PointerType::getUnqual(\n      llvm_ir::PrimitiveTypeToIrType(primitive_type, module_))",
          "old_line_content": "    auto* load_instruction =",
          "new_line_content": "  llvm::Type* primitive_ptr_type = llvm::PointerType::getUnqual(",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(operand)",
          "old_line_content": "}",
          "new_line_content": "    base_ptrs.push_back(GetEmittedValueFor(operand));",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(tuple)",
          "old_line_content": "llvm::Value* IrEmitter::EmitElementalMap(",
          "new_line_content": "  llvm_ir::EmitTuple(GetIrArrayFor(tuple), base_ptrs, &b_);",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "    const HloMapInstruction& map_instr,",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 2741,
          "old_api": null,
          "new_api": "BitCast",
          "old_text": null,
          "new_text": "BitCast(source, primitive_ptr_type)",
          "old_line_content": "                     element_alignment);",
          "new_line_content": "        AlignedLoad(BitCast(source, primitive_ptr_type), element_alignment);",
          "content_same": false
        },
        {
          "line": 2746,
          "old_api": null,
          "new_api": "AnnotateLoadStoreInstructionWithMetadata",
          "old_text": null,
          "new_text": "target_array.AnnotateLoadStoreInstructionWithMetadata(store_instruction)",
          "old_line_content": "        /*SrcAlign=*/element_alignment, element_count * primitive_type_size);",
          "new_line_content": "    target_array.AnnotateLoadStoreInstructionWithMetadata(store_instruction);",
          "content_same": false
        },
        {
          "line": 700,
          "old_api": null,
          "new_api": "to_apply",
          "old_text": null,
          "new_text": "map_instr.to_apply()",
          "old_line_content": "StatusOr<llvm::Value*> IrEmitter::EmitElementalReduceWindow(",
          "new_line_content": "  return EmitScalarReturningThreadLocalCall(*map_instr.to_apply(),",
          "content_same": false
        },
        {
          "line": 2748,
          "old_api": null,
          "new_api": "MemCpy",
          "old_text": null,
          "new_text": "MemCpy(\n        target, /*DstAlign=*/element_alignment, source,\n        /*SrcAlign=*/element_alignment, element_count * primitive_type_size)",
          "old_line_content": "    // The memcpy does the load and the store internally.  The aliasing related",
          "new_line_content": "    auto* memcpy_instruction = MemCpy(",
          "content_same": false
        },
        {
          "line": 2755,
          "old_api": null,
          "new_api": "metadata",
          "old_text": null,
          "new_text": "source_array.metadata()",
          "old_line_content": "    }",
          "new_line_content": "        llvm_ir::MergeMetadata(&module_->getContext(), source_array.metadata(),",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "reduce_window->operand(0)",
          "old_line_content": "  // the initial value on the reduce_window.",
          "new_line_content": "  const HloInstruction* operand = reduce_window->operand(0);",
          "content_same": false
        },
        {
          "line": 2756,
          "old_api": null,
          "new_api": "metadata",
          "old_text": null,
          "new_text": "target_array.metadata()",
          "old_line_content": "  }",
          "new_line_content": "                               target_array.metadata());",
          "content_same": false
        },
        {
          "line": 2758,
          "old_api": null,
          "new_api": "setMetadata",
          "old_text": null,
          "new_text": "memcpy_instruction->setMetadata(kind_md_pair.first, kind_md_pair.second)",
          "old_line_content": "",
          "new_line_content": "      memcpy_instruction->setMetadata(kind_md_pair.first, kind_md_pair.second);",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": null,
          "new_api": "llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_)",
          "old_text": null,
          "new_text": "llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_)",
          "old_line_content": "        accumulator_address);",
          "new_line_content": "      llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_),",
          "content_same": false
        },
        {
          "line": 2764,
          "old_api": null,
          "new_api": "operands",
          "old_text": null,
          "new_text": "concatenate->operands()",
          "old_line_content": "      EmitFastConcatenate(concatenate, operands, &failure_reason));",
          "new_line_content": "  absl::Span<HloInstruction* const> operands(concatenate->operands());",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "reduce_window->operand(1)",
          "old_line_content": "  std::vector<int64> window_size;",
          "new_line_content": "  Store(Load(GetEmittedValueFor(reduce_window->operand(1))),",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(reduce_window, \"inner\")",
          "old_line_content": "  }",
          "new_line_content": "  llvm_ir::ForLoopNest loops(IrName(reduce_window, \"inner\"), &b_);",
          "content_same": false
        },
        {
          "line": 2771,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "          << \": \" << failure_reason;",
          "new_line_content": "    return Status::OK();",
          "content_same": false
        },
        {
          "line": 2774,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "concatenate->ToString()",
          "old_line_content": "}",
          "new_line_content": "  VLOG(1) << \"Could not emit fast concatenate for \" << concatenate->ToString()",
          "content_same": false
        },
        {
          "line": 727,
          "old_api": null,
          "new_api": "ShapeUtil::MakeShape(operand_element_type, window_size)",
          "old_text": null,
          "new_text": "ShapeUtil::MakeShape(operand_element_type, window_size)",
          "old_line_content": "",
          "new_line_content": "      ShapeUtil::MakeShape(operand_element_type, window_size), \"window\");",
          "content_same": false
        },
        {
          "line": 2782,
          "old_api": null,
          "new_api": "branch_count",
          "old_text": null,
          "new_text": "conditional->branch_count()",
          "old_line_content": "      << \"Branch index on a conditional must be scalar bool or int32; got: \"",
          "new_line_content": "  int num_branches = conditional->branch_count();",
          "content_same": false
        },
        {
          "line": 2784,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "branch_index->shape().element_type()",
          "old_line_content": "",
          "new_line_content": "               (branch_index->shape().element_type() == PRED ||",
          "content_same": false
        },
        {
          "line": 2785,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "branch_index->shape().element_type()",
          "old_line_content": "  for (int b = 0; b < num_branches; ++b) {",
          "new_line_content": "                branch_index->shape().element_type() == S32))",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "NSWAdd(strided_index,\n               NSWMul(window_index[i],\n                      b_.getInt64(window.dimensions(i).window_dilation())))",
          "old_line_content": "",
          "new_line_content": "        NSWAdd(strided_index,",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "NSWMul(window_index[i],\n                      b_.getInt64(window.dimensions(i).window_dilation()))",
          "old_line_content": "    // We need to verify that we are not in the dilated base area.",
          "new_line_content": "               NSWMul(window_index[i],",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "window.dimensions(i).window_dilation()",
          "old_line_content": "    llvm::Value* dilation_condition =",
          "new_line_content": "                      b_.getInt64(window.dimensions(i).window_dilation()))),",
          "content_same": false
        },
        {
          "line": 2790,
          "old_api": null,
          "new_api": "branch_computation",
          "old_text": null,
          "new_text": "conditional->branch_computation(b)",
          "old_line_content": "        << \"th branch computation; got: \"",
          "new_line_content": "    HloComputation* br_computation = conditional->branch_computation(b);",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "SRem(input_multi_index[i],\n                    b_.getInt64(window.dimensions(i).base_dilation()))",
          "old_line_content": "      in_bounds_condition = dilation_condition;",
          "new_line_content": "        ICmpEQ(SRem(input_multi_index[i],",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "window.dimensions(i).base_dilation()",
          "old_line_content": "    } else {",
          "new_line_content": "                    b_.getInt64(window.dimensions(i).base_dilation())),",
          "content_same": false
        },
        {
          "line": 2796,
          "old_api": null,
          "new_api": "root_instruction",
          "old_text": null,
          "new_text": "br_computation->root_instruction()->shape()",
          "old_line_content": "",
          "new_line_content": "        << ShapeUtil::HumanString(br_computation->root_instruction()->shape());",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": null,
          "new_api": "And",
          "old_text": null,
          "new_text": "And(in_bounds_condition, dilation_condition)",
          "old_line_content": "    input_multi_index[i] =",
          "new_line_content": "      in_bounds_condition = And(in_bounds_condition, dilation_condition);",
          "content_same": false
        },
        {
          "line": 2799,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(conditional)",
          "old_line_content": "    //   if (pred)",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(conditional));",
          "content_same": false
        },
        {
          "line": 2801,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "branch_index->shape().element_type()",
          "old_line_content": "    //   else",
          "new_line_content": "  if (branch_index->shape().element_type() == PRED) {",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "SDiv(input_multi_index[i],\n             b_.getInt64(window.dimensions(i).base_dilation()))",
          "old_line_content": "    // are in the padding so that we can skip the computation. That is",
          "new_line_content": "        SDiv(input_multi_index[i],",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "window.dimensions(i).base_dilation()",
          "old_line_content": "    // equivalent to input_multi_index[i] < bound as an *unsigned* comparison,",
          "new_line_content": "             b_.getInt64(window.dimensions(i).base_dilation()));",
          "content_same": false
        },
        {
          "line": 2810,
          "old_api": null,
          "new_api": "ICmpNE",
          "old_text": null,
          "new_text": "ICmpNE(pred_value,\n               llvm::ConstantInt::get(\n                   llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0),\n               \"boolean_predicate\")",
          "old_line_content": "    llvm_ir::LlvmIfData if_data =",
          "new_line_content": "        ICmpNE(pred_value,",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "ICmpULT(input_multi_index[i],\n                b_.getInt64(ShapeUtil::GetDimension(operand->shape(), i)))",
          "old_line_content": "    } else {",
          "new_line_content": "        ICmpULT(input_multi_index[i],",
          "content_same": false
        },
        {
          "line": 2812,
          "old_api": null,
          "new_api": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "old_text": null,
          "new_text": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "old_line_content": "",
          "new_line_content": "                   llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0),",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": null,
          "new_api": "And",
          "old_text": null,
          "new_text": "And(in_bounds_condition, index_condition)",
          "old_line_content": "",
          "new_line_content": "      in_bounds_condition = And(in_bounds_condition, index_condition);",
          "content_same": false
        },
        {
          "line": 2823,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(conditional, \"_false\")",
          "old_line_content": "  }",
          "new_line_content": "                   IrName(conditional, \"_false\"));",
          "content_same": false
        },
        {
          "line": 2825,
          "old_api": null,
          "new_api": "SetToFirstInsertPoint",
          "old_text": null,
          "new_text": "SetToFirstInsertPoint(if_data.after_block, &b_)",
          "old_line_content": "  // switch (branch_index) {",
          "new_line_content": "    SetToFirstInsertPoint(if_data.after_block, &b_);",
          "content_same": false
        },
        {
          "line": 2826,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "  //   default:",
          "new_line_content": "    return Status::OK();",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": null,
          "new_api": "to_apply",
          "old_text": null,
          "new_text": "EmitScalarReturningThreadLocalCall(\n      *reduce_window->to_apply(), {Load(accumulator_address), input_value},\n      \"reducer_function\")",
          "old_line_content": "",
          "new_line_content": "  llvm::Value* result = EmitScalarReturningThreadLocalCall(",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": null,
          "new_api": "Store",
          "old_text": null,
          "new_text": "Store(result, accumulator_address)",
          "old_line_content": "}",
          "new_line_content": "  Store(result, accumulator_address);",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": null,
          "new_api": "GetOuterLoopExitBasicBlock",
          "old_text": null,
          "new_text": "loops.GetOuterLoopExitBasicBlock()",
          "old_line_content": "Status IrEmitter::HandleReduceWindow(HloInstruction* reduce_window) {",
          "new_line_content": "  SetToFirstInsertPoint(loops.GetOuterLoopExitBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": null,
          "new_api": "Load",
          "old_text": null,
          "new_text": "Load(accumulator_address)",
          "old_line_content": "  // Pseudo code for reduce window:",
          "new_line_content": "  return Load(accumulator_address);",
          "content_same": false
        },
        {
          "line": 2842,
          "old_api": null,
          "new_api": "GetBasePointer",
          "old_text": null,
          "new_text": "Load(\n      GetIrArrayFor(branch_index).GetBasePointer(), \"load_branch_index_value\")",
          "old_line_content": "  llvm::BasicBlock* after_block;",
          "new_line_content": "  llvm::LoadInst* branch_index_value = Load(",
          "content_same": false
        },
        {
          "line": 2843,
          "old_api": null,
          "new_api": "GetBasePointer",
          "old_text": null,
          "new_text": "GetIrArrayFor(branch_index).GetBasePointer()",
          "old_line_content": "  // Add a terminator to the case block, if necessary.",
          "new_line_content": "      GetIrArrayFor(branch_index).GetBasePointer(), \"load_branch_index_value\");",
          "content_same": false
        },
        {
          "line": 2848,
          "old_api": null,
          "new_api": "getTerminator",
          "old_text": null,
          "new_text": "case_block->getTerminator()",
          "old_line_content": "  } else {",
          "new_line_content": "  if (case_block->getTerminator() == nullptr) {",
          "content_same": false
        },
        {
          "line": 2849,
          "old_api": null,
          "new_api": "llvm_ir::CreateBasicBlock(nullptr, \"case-after\", &b_)",
          "old_text": null,
          "new_text": "llvm_ir::CreateBasicBlock(nullptr, \"case-after\", &b_)",
          "old_line_content": "    after_block =",
          "new_line_content": "    after_block = llvm_ir::CreateBasicBlock(nullptr, \"case-after\", &b_);",
          "content_same": false
        },
        {
          "line": 2851,
          "old_api": null,
          "new_api": "CreateBr",
          "old_text": null,
          "new_text": "b_.CreateBr(after_block)",
          "old_line_content": "  }",
          "new_line_content": "    b_.CreateBr(after_block);",
          "content_same": false
        },
        {
          "line": 2862,
          "old_api": null,
          "new_api": "SetInsertPoint",
          "old_text": null,
          "new_text": "b_.SetInsertPoint(default_block)",
          "old_line_content": "",
          "new_line_content": "  b_.SetInsertPoint(default_block);",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "operand->shape().element_type()",
          "old_line_content": "",
          "new_line_content": "  PrimitiveType operand_element_type = operand->shape().element_type();",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": null,
          "new_api": "rank",
          "old_text": null,
          "new_text": "operand->shape().rank()",
          "old_line_content": "  // TODO(b/31410564): Implement dilation for select-and-scatter.",
          "new_line_content": "  const int64 rank = operand->shape().rank();",
          "content_same": false
        },
        {
          "line": 2863,
          "old_api": null,
          "new_api": "branch_computation",
          "old_text": null,
          "new_text": "conditional->branch_computation(num_branches - 1)",
          "old_line_content": "  // Prepare the switch (branch_index) { ... } instruction.",
          "new_line_content": "  EmitGlobalCall(*conditional->branch_computation(num_branches - 1),",
          "content_same": false
        },
        {
          "line": 2865,
          "old_api": null,
          "new_api": "CreateBr",
          "old_text": null,
          "new_text": "b_.CreateBr(after_block)",
          "old_line_content": "  llvm::SwitchInst* case_inst =",
          "new_line_content": "  b_.CreateBr(after_block);",
          "content_same": false
        },
        {
          "line": 2868,
          "old_api": null,
          "new_api": "SetInsertPoint",
          "old_text": null,
          "new_text": "b_.SetInsertPoint(case_block)",
          "old_line_content": "  for (int b = 0; b < num_branches - 1; ++b) {  // last branch is default",
          "new_line_content": "  b_.SetInsertPoint(case_block);",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": null,
          "new_api": "window_util::HasDilation(window)",
          "old_text": null,
          "new_text": "window_util::HasDilation(window)",
          "old_line_content": "",
          "new_line_content": "  if (window_util::HasDilation(window)) {",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": null,
          "new_api": "Unimplemented",
          "old_text": null,
          "new_text": "Unimplemented(\n        \"Dilation for SelectAndScatter is not implemented on CPU. \")",
          "old_line_content": "  // Pseudo code for select-and-scatter:",
          "new_line_content": "    return Unimplemented(",
          "content_same": false
        },
        {
          "line": 2870,
          "old_api": null,
          "new_api": "CreateSwitch",
          "old_text": null,
          "new_text": "b_.CreateSwitch(branch_index_value, default_block, num_branches - 1)",
          "old_line_content": "    auto branch_block =",
          "new_line_content": "      b_.CreateSwitch(branch_index_value, default_block, num_branches - 1);",
          "content_same": false
        },
        {
          "line": 2877,
          "old_api": null,
          "new_api": "branch_computation",
          "old_text": null,
          "new_text": "conditional->branch_computation(b)",
          "old_line_content": "  }",
          "new_line_content": "    EmitGlobalCall(*conditional->branch_computation(b),",
          "content_same": false
        },
        {
          "line": 2878,
          "old_api": null,
          "new_api": "absl::StrCat(\"_branch\", b)",
          "old_text": null,
          "new_text": "absl::StrCat(\"_branch\", b)",
          "old_line_content": "",
          "new_line_content": "                   IrName(conditional, absl::StrCat(\"_branch\", b)));",
          "content_same": false
        },
        {
          "line": 2883,
          "old_api": null,
          "new_api": "SetToFirstInsertPoint",
          "old_text": null,
          "new_text": "SetToFirstInsertPoint(after_block, &b_)",
          "old_line_content": "Status IrEmitter::HandleAfterAll(HloInstruction* after_all) {",
          "new_line_content": "  SetToFirstInsertPoint(after_block, &b_);",
          "content_same": false
        },
        {
          "line": 2888,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "after_all->shape()",
          "old_line_content": "}",
          "new_line_content": "  TF_RET_CHECK(ByteSizeOf(after_all->shape()) == 0);",
          "content_same": false
        },
        {
          "line": 2890,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(after_all)",
          "old_line_content": "Status IrEmitter::HandleAddDependency(HloInstruction* add_dependency) {",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(after_all));",
          "content_same": false
        },
        {
          "line": 2891,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "  // AddDedendency just forwards its zero-th operand.",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(select_and_scatter, \"init\")",
          "old_line_content": "      }));",
          "new_line_content": "      select_and_scatter, /*desc=*/IrName(select_and_scatter, \"init\"),",
          "content_same": false
        },
        {
          "line": 2897,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "add_dependency->operand(0)",
          "old_line_content": "Status IrEmitter::HandleRng(HloInstruction* rng) {",
          "new_line_content": "      GetEmittedValueFor(add_dependency->operand(0));",
          "content_same": false
        },
        {
          "line": 850,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(init_value)",
          "old_line_content": "  // Create a loop to iterate over the source array to scatter to the output.",
          "new_line_content": "        llvm::Value* init_value_addr = GetEmittedValueFor(init_value);",
          "content_same": false
        },
        {
          "line": 855,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(select_and_scatter)",
          "old_line_content": "",
          "new_line_content": "  llvm_ir::ForLoopNest source_loops(IrName(select_and_scatter), &b_);",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "source->shape()",
          "old_line_content": "  // the boolean initialized_flag, which is initially set to false.",
          "new_line_content": "      source_loops.AddLoopsForShape(source->shape(), \"source\");",
          "content_same": false
        },
        {
          "line": 2906,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "rng_state->ToString()",
          "old_line_content": "",
          "new_line_content": "  VLOG(2) << \"RngGetAndUpdateState: \" << rng_state->ToString();",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": null,
          "new_api": "llvm_ir::EmitAllocaAtFunctionEntry(\n      llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_),\n      \"selected_value_address\", &b_,\n      MinimumAlignmentForPrimitiveType(operand_element_type))",
          "old_text": null,
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n      llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_),\n      \"selected_value_address\", &b_,\n      MinimumAlignmentForPrimitiveType(operand_element_type))",
          "old_line_content": "  llvm::Value* selected_index_address =",
          "new_line_content": "  llvm::Value* selected_value_address = llvm_ir::EmitAllocaAtFunctionEntry(",
          "content_same": false
        },
        {
          "line": 2911,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(rng_state)",
          "old_line_content": "  // buffer to i128 type to store the value.",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(rng_state));",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": null,
          "new_api": "getInt32",
          "old_text": null,
          "new_text": "b_.getInt32(rank)",
          "old_line_content": "",
          "new_line_content": "          b_.getInt64Ty(), b_.getInt32(rank), \"selected_index_address\", &b_);",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": null,
          "new_api": "getInt1Ty",
          "old_text": null,
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n      b_.getInt1Ty(), \"initialized_flag_address\", &b_)",
          "old_line_content": "  // Create the inner loop to iterate over the window.",
          "new_line_content": "  llvm::Value* initialized_flag_address = llvm_ir::EmitAllocaAtFunctionEntry(",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": null,
          "new_api": "getInt1",
          "old_text": null,
          "new_text": "b_.getInt1(false)",
          "old_line_content": "  std::vector<int64> window_size;",
          "new_line_content": "  Store(b_.getInt1(false), initialized_flag_address);",
          "content_same": false
        },
        {
          "line": 2919,
          "old_api": null,
          "new_api": "Store",
          "old_text": null,
          "new_text": "Store(old_state, address)",
          "old_line_content": "",
          "new_line_content": "  llvm::StoreInst* store = Store(old_state, address);",
          "content_same": false
        },
        {
          "line": 2921,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "IrEmitter::MinimumAlignmentForPrimitiveType(\n          rng_state->shape().element_type())",
          "old_line_content": "}",
          "new_line_content": "      llvm::MaybeAlign(IrEmitter::MinimumAlignmentForPrimitiveType(",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(select_and_scatter, \"window\")",
          "old_line_content": "  }",
          "new_line_content": "  llvm_ir::ForLoopNest window_loops(IrName(select_and_scatter, \"window\"), &b_);",
          "content_same": false
        },
        {
          "line": 2922,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "rng_state->shape().element_type()",
          "old_line_content": "",
          "new_line_content": "          rng_state->shape().element_type())));",
          "content_same": false
        },
        {
          "line": 2924,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "  // When this method is called, we should have already emitted an IR value for",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": null,
          "new_api": "AddLoopsForShape",
          "old_text": null,
          "new_text": "window_loops.AddLoopsForShape(\n      ShapeUtil::MakeShape(operand_element_type, window_size), \"window\")",
          "old_line_content": "  // Compute the operand index to visit and evaluate the condition whether the",
          "new_line_content": "  const llvm_ir::IrArray::Index window_index = window_loops.AddLoopsForShape(",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": null,
          "new_api": "ShapeUtil::MakeShape(operand_element_type, window_size)",
          "old_text": null,
          "new_text": "ShapeUtil::MakeShape(operand_element_type, window_size)",
          "old_line_content": "  // operand index is within the bounds. The unsigned comparison includes",
          "new_line_content": "      ShapeUtil::MakeShape(operand_element_type, window_size), \"window\");",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": null,
          "new_api": "GetInnerLoopBodyBasicBlock",
          "old_text": null,
          "new_text": "window_loops.GetInnerLoopBodyBasicBlock()",
          "old_line_content": "  // checking whether the operand index >= 0.",
          "new_line_content": "  SetToFirstInsertPoint(window_loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 2934,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "root->ToString()",
          "old_line_content": "  } else {",
          "new_line_content": "  VLOG(2) << \"FinishVisit root: \" << root->ToString();",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": null,
          "new_api": "getTrue",
          "old_text": null,
          "new_text": "b_.getTrue()",
          "old_line_content": "    operand_multi_index[i] =",
          "new_line_content": "  llvm::Value* in_bounds_condition = b_.getTrue();",
          "content_same": false
        },
        {
          "line": 2936,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(2)",
          "old_line_content": "  }",
          "new_line_content": "    VLOG(2) << \"  outfeed with value: \"",
          "content_same": false
        },
        {
          "line": 2937,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "root->operand(0)",
          "old_line_content": "",
          "new_line_content": "            << llvm_ir::DumpToString(*GetEmittedValueFor(root->operand(0)));",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "window.dimensions(i).stride()",
          "old_line_content": "    llvm::Value* index_condition =",
          "new_line_content": "        NSWMul(source_index[i], b_.getInt64(window.dimensions(i).stride()));",
          "content_same": false
        },
        {
          "line": 2939,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(root)",
          "old_line_content": "    if (prof_counter) {",
          "new_line_content": "    VLOG(2) << \"  value: \" << llvm_ir::DumpToString(*GetEmittedValueFor(root));",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "operand->shape()",
          "old_line_content": "",
          "new_line_content": "                b_.getInt64(ShapeUtil::GetDimension(operand->shape(), i)));",
          "content_same": false
        },
        {
          "line": 897,
          "old_api": null,
          "new_api": "And",
          "old_text": null,
          "new_text": "And(in_bounds_condition, index_condition)",
          "old_line_content": "  // Only need to do something if the operand index is within the bounds. First",
          "new_line_content": "    in_bounds_condition = And(in_bounds_condition, index_condition);",
          "content_same": false
        },
        {
          "line": 2944,
          "old_api": null,
          "new_api": "RecordCompleteComputation",
          "old_text": null,
          "new_text": "profiling_state_.RecordCompleteComputation(&b_, prof_counter)",
          "old_line_content": "  // For the entry computation this increment is cumulative of embedded",
          "new_line_content": "      profiling_state_.RecordCompleteComputation(&b_, prof_counter);",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(in_bounds_condition != nullptr)",
          "old_line_content": "  llvm_ir::LlvmIfData if_in_bounds =",
          "new_line_content": "  CHECK(in_bounds_condition != nullptr);",
          "content_same": false
        },
        {
          "line": 2951,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "root->parent()",
          "old_line_content": "template <typename T>",
          "new_line_content": "  record_complete_computation(GetProfileCounterFor(*root->parent()));",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": null,
          "new_api": "llvm_ir::EmitIfThenElse(in_bounds_condition, \"in-bounds\", &b_)",
          "old_text": null,
          "new_text": "llvm_ir::EmitIfThenElse(in_bounds_condition, \"in-bounds\", &b_)",
          "old_line_content": "",
          "new_line_content": "      llvm_ir::EmitIfThenElse(in_bounds_condition, \"in-bounds\", &b_);",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": null,
          "new_api": "SetToFirstInsertPoint",
          "old_text": null,
          "new_text": "SetToFirstInsertPoint(if_in_bounds.true_block, &b_)",
          "old_line_content": "  // If the initialized_flag is false, initialize the selected value and index",
          "new_line_content": "  SetToFirstInsertPoint(if_in_bounds.true_block, &b_);",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": null,
          "new_api": "llvm_ir::EmitIfThenElse(\n      Load(initialized_flag_address), \"initialized\", &b_)",
          "old_text": null,
          "new_text": "llvm_ir::EmitIfThenElse(\n      Load(initialized_flag_address), \"initialized\", &b_)",
          "old_line_content": "  // with the currently visiting operand.",
          "new_line_content": "  llvm_ir::LlvmIfData if_initialized = llvm_ir::EmitIfThenElse(",
          "content_same": false
        },
        {
          "line": 2952,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "llvm::Value* IrEmitter::GetProfileCounterCommon(",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": null,
          "new_api": "SetToFirstInsertPoint",
          "old_text": null,
          "new_text": "SetToFirstInsertPoint(if_initialized.false_block, &b_)",
          "old_line_content": "          llvm::Value* selected_index_address_slot =",
          "new_line_content": "  SetToFirstInsertPoint(if_initialized.false_block, &b_);",
          "content_same": false
        },
        {
          "line": 2959,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "profile_index_map.find(&hlo)",
          "old_line_content": "",
          "new_line_content": "  auto it = profile_index_map.find(&hlo);",
          "content_same": false
        },
        {
          "line": 2960,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "profile_index_map.end()",
          "old_line_content": "  int64 prof_counter_idx = it->second;",
          "new_line_content": "  if (it == profile_index_map.end()) {",
          "content_same": false
        },
        {
          "line": 916,
          "old_api": null,
          "new_api": "getInt32",
          "old_text": null,
          "new_text": "b_.getInt32(i)",
          "old_line_content": "  llvm_ir::IrArray operand_array(GetIrArrayFor(operand));",
          "new_line_content": "              InBoundsGEP(selected_index_address, {b_.getInt32(i)});",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": null,
          "new_api": "Store",
          "old_text": null,
          "new_text": "Store(operand_index[i], selected_index_address_slot)",
          "old_line_content": "  llvm_ir::IrArray::Index operand_index(",
          "new_line_content": "          Store(operand_index[i], selected_index_address_slot);",
          "content_same": false
        },
        {
          "line": 2965,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "hlo.name()",
          "old_line_content": "",
          "new_line_content": "  string counter_name = IrName(\"prof_counter\", hlo.name());",
          "content_same": false
        },
        {
          "line": 2966,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "b_.getInt64(prof_counter_idx)",
          "old_line_content": "llvm::Value* IrEmitter::GetProfileCounterFor(",
          "new_line_content": "  return GEP(GetProfileCountersArgument(), b_.getInt64(prof_counter_idx),",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": null,
          "new_api": "EmitReadArrayElement",
          "old_text": null,
          "new_text": "operand_array.EmitReadArrayElement(operand_index, &b_)",
          "old_line_content": "",
          "new_line_content": "      operand_array.EmitReadArrayElement(operand_index, &b_);",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": null,
          "new_api": "Store",
          "old_text": null,
          "new_text": "Store(operand_data, selected_value_address)",
          "old_line_content": "  // If the initialized_flag is true, call the `select` function to potentially",
          "new_line_content": "  Store(operand_data, selected_value_address);",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": null,
          "new_api": "save_operand_index",
          "old_text": null,
          "new_text": "save_operand_index(operand_index)",
          "old_line_content": "  // update the selected value and index with the currently visiting operand.",
          "new_line_content": "  save_operand_index(operand_index);",
          "content_same": false
        },
        {
          "line": 2972,
          "old_api": null,
          "new_api": "GetProfileCounterCommon<HloInstruction>(instruction,\n                                                 instruction_to_profile_idx_)",
          "old_text": null,
          "new_text": "GetProfileCounterCommon<HloInstruction>(instruction,\n                                                 instruction_to_profile_idx_)",
          "old_line_content": "llvm::Value* IrEmitter::GetProfileCounterFor(",
          "new_line_content": "  return GetProfileCounterCommon<HloInstruction>(instruction,",
          "content_same": false
        },
        {
          "line": 2978,
          "old_api": null,
          "new_api": "GetProfileCounterCommon<HloComputation>(computation,\n                                                 computation_to_profile_idx_)",
          "old_text": null,
          "new_text": "GetProfileCounterCommon<HloComputation>(computation,\n                                                 computation_to_profile_idx_)",
          "old_line_content": "void IrEmitter::ProfilingState::UpdateProfileCounter(llvm::IRBuilder<>* b,",
          "new_line_content": "  return GetProfileCounterCommon<HloComputation>(computation,",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": null,
          "new_api": "Load",
          "old_text": null,
          "new_text": "Load(operand_address)",
          "old_line_content": "",
          "new_line_content": "  llvm::Value* operand_element = Load(operand_address);",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": null,
          "new_api": "select",
          "old_text": null,
          "new_text": "EmitScalarReturningThreadLocalCall(\n      *select_and_scatter->select(),\n      {Load(selected_value_address), operand_element}, \"select_function\")",
          "old_line_content": "  // If the 'select' function returns false, update the selected value and the",
          "new_line_content": "  llvm::Value* result = EmitScalarReturningThreadLocalCall(",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": null,
          "new_api": "select",
          "old_text": null,
          "new_text": "select_and_scatter->select()",
          "old_line_content": "  // index to the currently visiting operand.",
          "new_line_content": "      *select_and_scatter->select(),",
          "content_same": false
        },
        {
          "line": 2988,
          "old_api": null,
          "new_api": "CreateLoad",
          "old_text": null,
          "new_text": "b->CreateLoad(prof_counter, \"old_cycle_count\")",
          "old_line_content": "}",
          "new_line_content": "      b->CreateLoad(prof_counter, \"old_cycle_count\");",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": null,
          "new_api": "ICmpNE",
          "old_text": null,
          "new_text": "ICmpNE(\n      result,\n      llvm::ConstantInt::get(llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0),\n      \"boolean_predicate\")",
          "old_line_content": "  llvm_ir::LlvmIfData if_select_lhs =",
          "new_line_content": "  llvm::Value* cond = ICmpNE(",
          "content_same": false
        },
        {
          "line": 2990,
          "old_api": null,
          "new_api": "CreateAdd",
          "old_text": null,
          "new_text": "b->CreateAdd(cycle_diff, old_cycle_count, \"new_cycle_count\")",
          "old_line_content": "llvm::Value* IrEmitter::ProfilingState::ReadCycleCounter(llvm::IRBuilder<>* b) {",
          "new_line_content": "      b->CreateAdd(cycle_diff, old_cycle_count, \"new_cycle_count\");",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": null,
          "new_api": "llvm_ir::EmitIfThenElse(cond, \"if-select-lhs\", &b_)",
          "old_text": null,
          "new_text": "llvm_ir::EmitIfThenElse(cond, \"if-select-lhs\", &b_)",
          "old_line_content": "",
          "new_line_content": "      llvm_ir::EmitIfThenElse(cond, \"if-select-lhs\", &b_);",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": null,
          "new_api": "SetToFirstInsertPoint",
          "old_text": null,
          "new_text": "SetToFirstInsertPoint(if_select_lhs.false_block, &b_)",
          "old_line_content": "  // After iterating over the window elements, scatter the source element to",
          "new_line_content": "  SetToFirstInsertPoint(if_select_lhs.false_block, &b_);",
          "content_same": false
        },
        {
          "line": 948,
          "old_api": null,
          "new_api": "Load",
          "old_text": null,
          "new_text": "Load(operand_address)",
          "old_line_content": "  // the selected index of the output. The value we store at the output",
          "new_line_content": "  Store(Load(operand_address), selected_value_address);",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": null,
          "new_api": "save_operand_index",
          "old_text": null,
          "new_text": "save_operand_index(operand_index)",
          "old_line_content": "  // location is computed by calling the `scatter` function with the source",
          "new_line_content": "  save_operand_index(operand_index);",
          "content_same": false
        },
        {
          "line": 2995,
          "old_api": null,
          "new_api": "GetInsertBlock",
          "old_text": null,
          "new_text": "b->GetInsertBlock()->getModule()",
          "old_line_content": "                                        llvm::Intrinsic::readcyclecounter);",
          "new_line_content": "  llvm::Module* module = b->GetInsertBlock()->getModule();",
          "content_same": false
        },
        {
          "line": 2998,
          "old_api": null,
          "new_api": "llvm::Intrinsic::getDeclaration(module,\n                                        llvm::Intrinsic::readcyclecounter)",
          "old_text": null,
          "new_text": "llvm::Intrinsic::getDeclaration(module,\n                                        llvm::Intrinsic::readcyclecounter)",
          "old_line_content": "  llvm::Function* func_llvm_x86_rdtscp =",
          "new_line_content": "        llvm::Intrinsic::getDeclaration(module,",
          "content_same": false
        },
        {
          "line": 3003,
          "old_api": null,
          "new_api": "llvm::Intrinsic::getDeclaration(module, llvm::Intrinsic::x86_rdtscp)",
          "old_text": null,
          "new_text": "llvm::Intrinsic::getDeclaration(module, llvm::Intrinsic::x86_rdtscp)",
          "old_line_content": "",
          "new_line_content": "      llvm::Intrinsic::getDeclaration(module, llvm::Intrinsic::x86_rdtscp);",
          "content_same": false
        },
        {
          "line": 3004,
          "old_api": null,
          "new_api": "CreateCall",
          "old_text": null,
          "new_text": "b->CreateCall(func_llvm_x86_rdtscp)",
          "old_line_content": "void IrEmitter::ProfilingState::RecordCycleStart(llvm::IRBuilder<>* b,",
          "new_line_content": "  llvm::Value* rdtscp_call = b->CreateCall(func_llvm_x86_rdtscp);",
          "content_same": false
        },
        {
          "line": 3005,
          "old_api": null,
          "new_api": "CreateExtractValue",
          "old_text": null,
          "new_text": "b->CreateExtractValue(rdtscp_call, {0})",
          "old_line_content": "                                                 HloInstruction* hlo) {",
          "new_line_content": "  return b->CreateExtractValue(rdtscp_call, {0});",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": null,
          "new_api": "getInt32",
          "old_text": null,
          "new_text": "b_.getInt32(i)",
          "old_line_content": "  llvm::Value* source_value =",
          "new_line_content": "        InBoundsGEP(selected_index_address, {b_.getInt32(i)});",
          "content_same": false
        },
        {
          "line": 3010,
          "old_api": null,
          "new_api": "ReadCycleCounter",
          "old_text": null,
          "new_text": "ReadCycleCounter(b)",
          "old_line_content": "    first_read_cycle_start_ = cycle_start;",
          "new_line_content": "  auto* cycle_start = ReadCycleCounter(b);",
          "content_same": false
        },
        {
          "line": 3011,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(hlo, \"cycle_start\")",
          "old_line_content": "  }",
          "new_line_content": "  cycle_start->setName(IrName(hlo, \"cycle_start\"));",
          "content_same": false
        },
        {
          "line": 964,
          "old_api": null,
          "new_api": "EmitReadArrayElement",
          "old_text": null,
          "new_text": "source_array.EmitReadArrayElement(source_index, &b_)",
          "old_line_content": "  llvm::Value* output_value =",
          "new_line_content": "      source_array.EmitReadArrayElement(source_index, &b_);",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": null,
          "new_api": "scatter",
          "old_text": null,
          "new_text": "EmitScalarReturningThreadLocalCall(\n      *select_and_scatter->scatter(), {output_value, source_value},\n      \"scatter_function\")",
          "old_line_content": "",
          "new_line_content": "  llvm::Value* scatter_value = EmitScalarReturningThreadLocalCall(",
          "content_same": false
        },
        {
          "line": 973,
          "old_api": null,
          "new_api": "EmitWriteArrayElement",
          "old_text": null,
          "new_text": "output_array.EmitWriteArrayElement(selected_index, scatter_value, &b_)",
          "old_line_content": "}",
          "new_line_content": "  output_array.EmitWriteArrayElement(selected_index, scatter_value, &b_);",
          "content_same": false
        },
        {
          "line": 3021,
          "old_api": null,
          "new_api": "ReadCycleCounter",
          "old_text": null,
          "new_text": "ReadCycleCounter(b)",
          "old_line_content": "  last_read_cycle_end_ = cycle_end;",
          "new_line_content": "  auto* cycle_end = ReadCycleCounter(b);",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": null,
          "new_api": "GetOuterLoopExitBasicBlock",
          "old_text": null,
          "new_text": "source_loops.GetOuterLoopExitBasicBlock()",
          "old_line_content": "Status IrEmitter::HandleDot(HloInstruction* dot) {",
          "new_line_content": "  SetToFirstInsertPoint(source_loops.GetOuterLoopExitBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 3022,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(hlo, \"cycle_end\")",
          "old_line_content": "}",
          "new_line_content": "  cycle_end->setName(IrName(hlo, \"cycle_end\"));",
          "content_same": false
        },
        {
          "line": 3024,
          "old_api": null,
          "new_api": "UpdateProfileCounter",
          "old_text": null,
          "new_text": "UpdateProfileCounter(b, prof_counter, cycle_end, cycle_start)",
          "old_line_content": "void IrEmitter::ProfilingState::RecordCompleteComputation(",
          "new_line_content": "  UpdateProfileCounter(b, prof_counter, cycle_end, cycle_start);",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "dot->operand(0)",
          "old_line_content": "      /*supported_types=*/{S32, F16, F32, F64, C64, C128}));",
          "new_line_content": "  auto lhs = dot->operand(0);",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": null,
          "new_api": "ElementTypesSameAndSupported",
          "old_text": null,
          "new_text": "ElementTypesSameAndSupported(\n      /*instruction=*/*dot, /*operands=*/{lhs, rhs},\n      /*supported_types=*/{S32, F16, F32, F64, C64, C128})",
          "old_line_content": "",
          "new_line_content": "  TF_RETURN_IF_ERROR(ElementTypesSameAndSupported(",
          "content_same": false
        },
        {
          "line": 3031,
          "old_api": null,
          "new_api": "UpdateProfileCounter",
          "old_text": null,
          "new_text": "UpdateProfileCounter(b, prof_counter, last_read_cycle_end_,\n                         first_read_cycle_start_)",
          "old_line_content": "",
          "new_line_content": "    UpdateProfileCounter(b, prof_counter, last_read_cycle_end_,",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": null,
          "new_api": "lhs_contracting_dimensions_size",
          "old_text": null,
          "new_text": "dnums.lhs_contracting_dimensions_size()",
          "old_line_content": "  }",
          "new_line_content": "  if (dnums.lhs_contracting_dimensions_size() != 1) {",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": null,
          "new_api": "Unimplemented",
          "old_text": null,
          "new_text": "Unimplemented(\n        \"Dot with multiple contracting dimensions not implemented.\")",
          "old_line_content": "  llvm_ir::IrArray lhs_array(GetIrArrayFor(lhs));",
          "new_line_content": "    return Unimplemented(",
          "content_same": false
        },
        {
          "line": 3043,
          "old_api": null,
          "new_api": "getInt8Ty",
          "old_text": null,
          "new_text": "b->getInt8Ty()->getPointerTo()",
          "old_line_content": "                              /*isVarArg=*/false);",
          "new_line_content": "  llvm::Type* int8_ptr_type = b->getInt8Ty()->getPointerTo();",
          "content_same": false
        },
        {
          "line": 3044,
          "old_api": null,
          "new_api": "getVoidTy",
          "old_text": null,
          "new_text": "b->getVoidTy()->getPointerTo()",
          "old_line_content": "",
          "new_line_content": "  llvm::Type* void_ptr_type = b->getVoidTy()->getPointerTo();",
          "content_same": false
        },
        {
          "line": 1002,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(2)",
          "old_line_content": "",
          "new_line_content": "  VLOG(2) << \"  rhs operand: \"",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": null,
          "new_api": "GetBasePointer",
          "old_text": null,
          "new_text": "rhs_array.GetBasePointer()",
          "old_line_content": "  // Dot operation is complicated so we delegate to a helper class.",
          "new_line_content": "          << llvm_ir::DumpToString(*rhs_array.GetBasePointer());",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": null,
          "new_api": "GetBasePointer",
          "old_text": null,
          "new_text": "target_array.GetBasePointer()",
          "old_line_content": "                          /*addend_array=*/nullptr,",
          "new_line_content": "          << llvm_ir::DumpToString(*target_array.GetBasePointer());",
          "content_same": false
        },
        {
          "line": 3054,
          "old_api": null,
          "new_api": "getCallee",
          "old_text": null,
          "new_text": "trace_func.getCallee()",
          "old_line_content": "  }",
          "new_line_content": "  if (auto* fn = llvm::dyn_cast<llvm::Function>(trace_func.getCallee())) {",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": null,
          "new_api": "EmitDotOperation",
          "old_text": null,
          "new_text": "EmitDotOperation(*dot, target_array, lhs_array, rhs_array,\n                          /*addend_array=*/nullptr,\n                          GetExecutableRunOptionsArgument(), &b_,\n                          hlo_module_config_, target_machine_features_)",
          "old_line_content": "}",
          "new_line_content": "  return EmitDotOperation(*dot, target_array, lhs_array, rhs_array,",
          "content_same": false
        },
        {
          "line": 3056,
          "old_api": null,
          "new_api": "setDoesNotThrow",
          "old_text": null,
          "new_text": "fn->setDoesNotThrow()",
          "old_line_content": "  auto* activity_id =",
          "new_line_content": "    fn->setDoesNotThrow();",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": null,
          "new_api": "GetExecutableRunOptionsArgument",
          "old_text": null,
          "new_text": "GetExecutableRunOptionsArgument()",
          "old_line_content": "StatusOr<llvm::Value*> IrEmitter::EmitElementalConvolution(",
          "new_line_content": "                          GetExecutableRunOptionsArgument(), &b_,",
          "content_same": false
        },
        {
          "line": 3061,
          "old_api": null,
          "new_api": "CreateBitCast",
          "old_text": null,
          "new_text": "b->CreateBitCast(run_options, void_ptr_type)",
          "old_line_content": "}",
          "new_line_content": "      b->CreateCall(trace_func, {b->CreateBitCast(run_options, void_ptr_type),",
          "content_same": false
        },
        {
          "line": 3062,
          "old_api": null,
          "new_api": "CreateBitCast",
          "old_text": null,
          "new_text": "b->CreateBitCast(hlo_name, int8_ptr_type)",
          "old_line_content": "",
          "new_line_content": "                                 b->CreateBitCast(hlo_name, int8_ptr_type)});",
          "content_same": false
        },
        {
          "line": 3063,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(hlo, \"activity_id\")",
          "old_line_content": "void IrEmitter::TracingState::EmitTracingEnd(llvm::IRBuilder<>* b,",
          "new_line_content": "  activity_id->setName(IrName(hlo, \"activity_id\"));",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "convolution->operand(0)",
          "old_line_content": "  const ConvolutionDimensionNumbers& dnums =",
          "new_line_content": "  const HloInstruction* lhs = convolution->operand(0);",
          "content_same": false
        },
        {
          "line": 1025,
          "old_api": null,
          "new_api": "output_spatial_dimensions_size",
          "old_text": null,
          "new_text": "dnums.output_spatial_dimensions_size()",
          "old_line_content": "  }",
          "new_line_content": "  int num_spatial_dims = dnums.output_spatial_dimensions_size();",
          "content_same": false
        },
        {
          "line": 3074,
          "old_api": null,
          "new_api": "getVoidTy",
          "old_text": null,
          "new_text": "b->getVoidTy()->getPointerTo()",
          "old_line_content": "",
          "new_line_content": "  llvm::Type* void_ptr_type = b->getVoidTy()->getPointerTo();",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": null,
          "new_api": "output_spatial_dimensions",
          "old_text": null,
          "new_text": "dnums.output_spatial_dimensions(i)",
          "old_line_content": "",
          "new_line_content": "    output_spatial[i] = index[dnums.output_spatial_dimensions(i)];",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": null,
          "new_api": "output_feature_dimension",
          "old_text": null,
          "new_text": "dnums.output_feature_dimension()",
          "old_line_content": "  // at the given index.",
          "new_line_content": "  llvm::Value* output_feature = index[dnums.output_feature_dimension()];",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "lhs->shape().element_type()",
          "old_line_content": "  llvm::Type* accumulator_type =",
          "new_line_content": "  PrimitiveType lhs_element_type = lhs->shape().element_type();",
          "content_same": false
        },
        {
          "line": 3084,
          "old_api": null,
          "new_api": "getCallee",
          "old_text": null,
          "new_text": "trace_func.getCallee()",
          "old_line_content": "  }",
          "new_line_content": "  if (auto* fn = llvm::dyn_cast<llvm::Function>(trace_func.getCallee())) {",
          "content_same": false
        },
        {
          "line": 3089,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "activity_ids_.at(hlo)",
          "old_line_content": "",
          "new_line_content": "  auto* activity_id = activity_ids_.at(hlo);",
          "content_same": false
        },
        {
          "line": 3090,
          "old_api": null,
          "new_api": "CreateCall",
          "old_text": null,
          "new_text": "b->CreateCall(trace_func,\n                {b->CreateBitCast(run_options, void_ptr_type), activity_id})",
          "old_line_content": "Status IrEmitter::Preprocess(HloInstruction* hlo) {",
          "new_line_content": "  b->CreateCall(trace_func,",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": null,
          "new_api": "llvm::Constant::getNullValue(accumulator_type)",
          "old_text": null,
          "new_text": "llvm::Constant::getNullValue(accumulator_type)",
          "old_line_content": "  std::vector<llvm::Value*> kernel_spatial(num_spatial_dims);",
          "new_line_content": "  llvm::Value* constant_zero = llvm::Constant::getNullValue(accumulator_type);",
          "content_same": false
        },
        {
          "line": 1045,
          "old_api": null,
          "new_api": "Store",
          "old_text": null,
          "new_text": "Store(constant_zero, sum_address)",
          "old_line_content": "  for (int i = 0; i < num_spatial_dims; ++i) {",
          "new_line_content": "  Store(constant_zero, sum_address);",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": null,
          "new_api": "AddLoop",
          "old_text": null,
          "new_text": "loops\n            .AddLoop(\n                0, rhs->shape().dimensions(dnums.kernel_spatial_dimensions(i)),\n                absl::StrCat(\"k\", i))\n            ->GetIndVarValue()",
          "old_line_content": "            ->GetIndVarValue();",
          "new_line_content": "        loops",
          "content_same": false
        },
        {
          "line": 3099,
          "old_api": null,
          "new_api": "GetExecutableRunOptionsArgument",
          "old_text": null,
          "new_text": "GetExecutableRunOptionsArgument()",
          "old_line_content": "}",
          "new_line_content": "                                    GetExecutableRunOptionsArgument());",
          "content_same": false
        },
        {
          "line": 1053,
          "old_api": null,
          "new_api": "kernel_spatial_dimensions",
          "old_text": null,
          "new_text": "dnums.kernel_spatial_dimensions(i)",
          "old_line_content": "  llvm::Value* input_feature =",
          "new_line_content": "                0, rhs->shape().dimensions(dnums.kernel_spatial_dimensions(i)),",
          "content_same": false
        },
        {
          "line": 3100,
          "old_api": null,
          "new_api": "RecordCycleStart",
          "old_text": null,
          "new_text": "profiling_state_.RecordCycleStart(&b_, hlo)",
          "old_line_content": "",
          "new_line_content": "    profiling_state_.RecordCycleStart(&b_, hlo);",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": null,
          "new_api": "AddLoop",
          "old_text": null,
          "new_text": "loops\n          .AddLoop(0, lhs->shape().dimensions(dnums.input_feature_dimension()),\n                   \"iz\")\n          ->GetIndVarValue()",
          "old_line_content": "",
          "new_line_content": "      loops",
          "content_same": false
        },
        {
          "line": 3110,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "instruction_to_profile_idx_.count(hlo)",
          "old_line_content": "}",
          "new_line_content": "  if (instruction_to_profile_idx_.count(hlo)) {",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": null,
          "new_api": "GetInnerLoopBodyBasicBlock",
          "old_text": null,
          "new_text": "loops.GetInnerLoopBodyBasicBlock()",
          "old_line_content": "  // of the array.",
          "new_line_content": "  SetToFirstInsertPoint(loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 3111,
          "old_api": null,
          "new_api": "GetExecutableRunOptionsArgument",
          "old_text": null,
          "new_text": "GetExecutableRunOptionsArgument()",
          "old_line_content": "",
          "new_line_content": "    tracing_state_.EmitTracingEnd(&b_, hlo, GetExecutableRunOptionsArgument());",
          "content_same": false
        },
        {
          "line": 3117,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(hlo)",
          "old_line_content": "  return array;",
          "new_line_content": "  llvm::Value* value_for_op = GetEmittedValueFor(hlo);",
          "content_same": false
        },
        {
          "line": 3119,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "hlo->shape()",
          "old_line_content": "",
          "new_line_content": "  llvm_ir::IrArray array(value_for_op, hlo->shape());",
          "content_same": false
        },
        {
          "line": 3120,
          "old_api": null,
          "new_api": "AddAliasingInformationToIrArray",
          "old_text": null,
          "new_text": "AddAliasingInformationToIrArray(*hlo, &array)",
          "old_line_content": "std::vector<llvm_ir::IrArray> IrEmitter::GetIrArraysForOperandsOf(",
          "new_line_content": "  AddAliasingInformationToIrArray(*hlo, &array);",
          "content_same": false
        },
        {
          "line": 1074,
          "old_api": null,
          "new_api": "window_dilation",
          "old_text": null,
          "new_text": "window_dim.window_dilation()",
          "old_line_content": "  std::vector<llvm::Value*> input_spatial(num_spatial_dims);",
          "new_line_content": "        NSWMul(kernel_index, b_.getInt64(window_dim.window_dilation()));",
          "content_same": false
        },
        {
          "line": 1075,
          "old_api": null,
          "new_api": "NSWAdd",
          "old_text": null,
          "new_text": "NSWAdd(strided_index, dilated_kernel_index)",
          "old_line_content": "  for (int i = 0; i < num_spatial_dims; ++i) {",
          "new_line_content": "    return NSWSub(NSWAdd(strided_index, dilated_kernel_index),",
          "content_same": false
        },
        {
          "line": 3127,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "std::transform(\n      hlo->operands().begin(), hlo->operands().end(),\n      std::back_inserter(arrays),\n      [&](const HloInstruction* operand) { return GetIrArrayFor(operand); })",
          "old_line_content": "  return arrays;",
          "new_line_content": "  std::transform(",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "calculate_input_index(\n        output_spatial[i], kernel_spatial[i], window.dimensions(i))",
          "old_line_content": "  // We need to check if 0 <= input dim < bound, as otherwise we are in the",
          "new_line_content": "    input_spatial[i] = calculate_input_index(",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "window.dimensions(i)",
          "old_line_content": "  // padding so that we can skip the computation. That is equivalent to input",
          "new_line_content": "        output_spatial[i], kernel_spatial[i], window.dimensions(i));",
          "content_same": false
        },
        {
          "line": 3128,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "hlo->operands().end()",
          "old_line_content": "}",
          "new_line_content": "      hlo->operands().begin(), hlo->operands().end(),",
          "content_same": false
        },
        {
          "line": 3129,
          "old_api": null,
          "new_api": "std::back_inserter(arrays)",
          "old_text": null,
          "new_text": "std::back_inserter(arrays)",
          "old_line_content": "",
          "new_line_content": "      std::back_inserter(arrays),",
          "content_same": false
        },
        {
          "line": 3130,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(operand)",
          "old_line_content": "llvm::Value* IrEmitter::GetEmittedValueFor(const HloInstruction* hlo) {",
          "new_line_content": "      [&](const HloInstruction* operand) { return GetIrArrayFor(operand); });",
          "content_same": false
        },
        {
          "line": 3135,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "emitted_value_.find(hlo)",
          "old_line_content": "  return it->second;",
          "new_line_content": "  auto it = emitted_value_.find(hlo);",
          "content_same": false
        },
        {
          "line": 3136,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "emitted_value_.end()",
          "old_line_content": "}",
          "new_line_content": "  if (it == emitted_value_.end()) {",
          "content_same": false
        },
        {
          "line": 3137,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "hlo->ToString()",
          "old_line_content": "",
          "new_line_content": "    LOG(FATAL) << \"could not find emitted value for: \" << hlo->ToString();",
          "content_same": false
        },
        {
          "line": 1094,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "b_.getInt64(0)",
          "old_line_content": "  for (int i = 0; i < num_spatial_dims; ++i) {",
          "new_line_content": "    return ICmpEQ(remainder, b_.getInt64(0));",
          "content_same": false
        },
        {
          "line": 1099,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "window_util::DilatedBound(\n        lhs->shape().dimensions(dnums.input_spatial_dimensions(i)),\n        window.dimensions(i).base_dilation())",
          "old_line_content": "    llvm::Value* dim_not_in_hole =",
          "new_line_content": "    llvm::ConstantInt* input_bound = b_.getInt64(window_util::DilatedBound(",
          "content_same": false
        },
        {
          "line": 1104,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "window.dimensions(i).base_dilation()",
          "old_line_content": "",
          "new_line_content": "        not_in_hole(input_spatial[i], window.dimensions(i).base_dilation());",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": null,
          "new_api": "And",
          "old_text": null,
          "new_text": "And(dim_in_bound, dim_not_in_hole)",
          "old_line_content": "  // Now we need to map the dilated base coordinates back to the actual",
          "new_line_content": "    llvm::Value* dim_ok = And(dim_in_bound, dim_not_in_hole);",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": null,
          "new_api": "And",
          "old_text": null,
          "new_text": "And(in_bounds_condition, dim_ok)",
          "old_line_content": "  // data indices on the lhs.",
          "new_line_content": "    in_bounds_condition = And(in_bounds_condition, dim_ok);",
          "content_same": false
        },
        {
          "line": 3155,
          "old_api": null,
          "new_api": "exec_run_options_arg",
          "old_text": null,
          "new_text": "compute_function_->exec_run_options_arg()",
          "old_line_content": "    const BufferAllocation::Slice& slice, const Shape& target_shape) {",
          "new_line_content": "  return compute_function_->exec_run_options_arg();",
          "content_same": false
        },
        {
          "line": 3161,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "() -> llvm::Value* {\n    auto param_it =\n        computation_parameter_allocations_.find(slice.allocation()->index());\n    if (param_it != computation_parameter_allocations_.end()) {\n      int64 param_number = param_it->second;\n      // We have to access the parameter at offset param_number in the params\n      // array. The code generated here is equivalent to this C code:\n      //\n      //   i8* param_address_untyped = params[param_number];\n      //   Param* param_address_typed = (Param*)param_address_untyped;\n      //\n      // Where Param is the actual element type of the underlying buffer (for\n      // example, float for an XLA F32 element type).\n      llvm::Value* params = compute_function_->parameters_arg();\n      llvm::Value* param_address_offset =\n          llvm_ir::EmitBufferIndexingGEP(params, param_number, &b_);\n      llvm::LoadInst* param_address_untyped = Load(param_address_offset);\n\n      if (!target_shape.IsOpaque()) {\n        AttachAlignmentMetadataForLoad(param_address_untyped, target_shape);\n        AttachDereferenceableMetadataForLoad(param_address_untyped,\n                                             target_shape);\n      }\n      return param_address_untyped;\n    }\n\n    // Thread-local allocations should only be assigned a single buffer.\n    const auto& assigned_buffers = allocation.assigned_buffers();\n    CHECK_EQ(1, assigned_buffers.size());\n    const Shape& shape = assigned_buffers.begin()->first->shape();\n\n    std::pair<llvm::Function*, BufferAllocation::Slice> key = {\n        compute_function_->function(), slice};\n    auto buf_it = thread_local_buffers_.find(key);\n    if (buf_it == thread_local_buffers_.end()) {\n      llvm::Value* buffer = llvm_ir::EmitAllocaAtFunctionEntry(\n          IrShapeType(shape), absl::StrCat(\"thread_local\", slice.ToString()),\n          &b_, MinimumAlignmentForShape(target_shape));\n      auto it_inserted_pair = thread_local_buffers_.insert({key, buffer});\n      CHECK(it_inserted_pair.second);\n      buf_it = it_inserted_pair.first;\n    }\n    return buf_it->second;\n  }()",
          "old_line_content": "      int64 param_number = param_it->second;",
          "new_line_content": "  llvm::Value* tempbuf_address = [&]() -> llvm::Value* {",
          "content_same": false
        },
        {
          "line": 3163,
          "old_api": null,
          "new_api": "allocation",
          "old_text": null,
          "new_text": "slice.allocation()->index()",
          "old_line_content": "      // array. The code generated here is equivalent to this C code:",
          "new_line_content": "        computation_parameter_allocations_.find(slice.allocation()->index());",
          "content_same": false
        },
        {
          "line": 3164,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "computation_parameter_allocations_.end()",
          "old_line_content": "      //",
          "new_line_content": "    if (param_it != computation_parameter_allocations_.end()) {",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": null,
          "new_api": "llvm_ir::EmitIfThenElse(in_bounds_condition, \"in-bounds\", &b_)",
          "old_text": null,
          "new_text": "llvm_ir::EmitIfThenElse(in_bounds_condition, \"in-bounds\", &b_)",
          "old_line_content": "  int num_dims = num_spatial_dims + 2;",
          "new_line_content": "      llvm_ir::EmitIfThenElse(in_bounds_condition, \"in-bounds\", &b_);",
          "content_same": false
        },
        {
          "line": 1121,
          "old_api": null,
          "new_api": "SetToFirstInsertPoint",
          "old_text": null,
          "new_text": "SetToFirstInsertPoint(if_data.true_block, &b_)",
          "old_line_content": "  std::vector<llvm::Value*> input_multi_index(num_dims);",
          "new_line_content": "  SetToFirstInsertPoint(if_data.true_block, &b_);",
          "content_same": false
        },
        {
          "line": 3174,
          "old_api": null,
          "new_api": "parameters_arg",
          "old_text": null,
          "new_text": "compute_function_->parameters_arg()",
          "old_line_content": "",
          "new_line_content": "      llvm::Value* params = compute_function_->parameters_arg();",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": null,
          "new_api": "input_spatial_dimensions",
          "old_text": null,
          "new_text": "dnums.input_spatial_dimensions(i)",
          "old_line_content": "",
          "new_line_content": "    input_multi_index[dnums.input_spatial_dimensions(i)] = input_spatial[i];",
          "content_same": false
        },
        {
          "line": 1129,
          "old_api": null,
          "new_api": "input_feature_dimension",
          "old_text": null,
          "new_text": "dnums.input_feature_dimension()",
          "old_line_content": "  for (int i = 0; i < num_spatial_dims; ++i) {",
          "new_line_content": "  input_multi_index[dnums.input_feature_dimension()] = input_feature;",
          "content_same": false
        },
        {
          "line": 3179,
          "old_api": null,
          "new_api": "IsOpaque",
          "old_text": null,
          "new_text": "target_shape.IsOpaque()",
          "old_line_content": "      }",
          "new_line_content": "      if (!target_shape.IsOpaque()) {",
          "content_same": false
        },
        {
          "line": 3180,
          "old_api": null,
          "new_api": "AttachAlignmentMetadataForLoad",
          "old_text": null,
          "new_text": "AttachAlignmentMetadataForLoad(param_address_untyped, target_shape)",
          "old_line_content": "      return param_address_untyped;",
          "new_line_content": "        AttachAlignmentMetadataForLoad(param_address_untyped, target_shape);",
          "content_same": false
        },
        {
          "line": 3181,
          "old_api": null,
          "new_api": "AttachDereferenceableMetadataForLoad",
          "old_text": null,
          "new_text": "AttachDereferenceableMetadataForLoad(param_address_untyped,\n                                             target_shape)",
          "old_line_content": "    }",
          "new_line_content": "        AttachDereferenceableMetadataForLoad(param_address_untyped,",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": null,
          "new_api": "kernel_spatial_dimensions",
          "old_text": null,
          "new_text": "dnums.kernel_spatial_dimensions(i)",
          "old_line_content": "            : kernel_spatial[i];",
          "new_line_content": "    kernel_multi_index[dnums.kernel_spatial_dimensions(i)] =",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "window.dimensions(i).window_reversal()",
          "old_line_content": "  }",
          "new_line_content": "        window.dimensions(i).window_reversal()",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "window.dimensions(i).size()",
          "old_line_content": "",
          "new_line_content": "            ? NSWSub(b_.getInt64(window.dimensions(i).size() - 1),",
          "content_same": false
        },
        {
          "line": 3188,
          "old_api": null,
          "new_api": "assigned_buffers",
          "old_text": null,
          "new_text": "allocation.assigned_buffers()",
          "old_line_content": "    std::pair<llvm::Function*, BufferAllocation::Slice> key = {",
          "new_line_content": "    const auto& assigned_buffers = allocation.assigned_buffers();",
          "content_same": false
        },
        {
          "line": 1142,
          "old_api": null,
          "new_api": "kernel_output_feature_dimension",
          "old_text": null,
          "new_text": "dnums.kernel_output_feature_dimension()",
          "old_line_content": "  TF_ASSIGN_OR_RETURN(llvm::Value* const input_value,",
          "new_line_content": "  kernel_multi_index[dnums.kernel_output_feature_dimension()] = output_feature;",
          "content_same": false
        },
        {
          "line": 3197,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "slice.ToString()",
          "old_line_content": "      buf_it = it_inserted_pair.first;",
          "new_line_content": "          IrShapeType(shape), absl::StrCat(\"thread_local\", slice.ToString()),",
          "content_same": false
        },
        {
          "line": 3198,
          "old_api": null,
          "new_api": "MinimumAlignmentForShape",
          "old_text": null,
          "new_text": "MinimumAlignmentForShape(target_shape)",
          "old_line_content": "    }",
          "new_line_content": "          &b_, MinimumAlignmentForShape(target_shape));",
          "content_same": false
        },
        {
          "line": 3199,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "thread_local_buffers_.insert({key, buffer})",
          "old_line_content": "    return buf_it->second;",
          "new_line_content": "      auto it_inserted_pair = thread_local_buffers_.insert({key, buffer});",
          "content_same": false
        },
        {
          "line": 3200,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(it_inserted_pair.second)",
          "old_line_content": "  }();",
          "new_line_content": "      CHECK(it_inserted_pair.second);",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": null,
          "new_api": "Store",
          "old_text": null,
          "new_text": "Store(sum, sum_address)",
          "old_line_content": "}",
          "new_line_content": "  Store(sum, sum_address);",
          "content_same": false
        },
        {
          "line": 1156,
          "old_api": null,
          "new_api": "GetOuterLoopExitBasicBlock",
          "old_text": null,
          "new_text": "loops.GetOuterLoopExitBasicBlock()",
          "old_line_content": "Status IrEmitter::HandleConvolution(HloInstruction* convolution) {",
          "new_line_content": "  SetToFirstInsertPoint(loops.GetOuterLoopExitBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 3205,
          "old_api": null,
          "new_api": "getPointerTo",
          "old_text": null,
          "new_text": "IrShapeType(target_shape)->getPointerTo()",
          "old_line_content": "    const BufferAllocation::Slice& slice, const Shape& target_shape) {",
          "new_line_content": "  return BitCast(tempbuf_address, IrShapeType(target_shape)->getPointerTo());",
          "content_same": false
        },
        {
          "line": 1161,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "convolution->operand(0)",
          "old_line_content": "      /*supported_types=*/{F16, F32, F64, C64, C128}));",
          "new_line_content": "  auto lhs = convolution->operand(0);",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "convolution->operand(1)",
          "old_line_content": "",
          "new_line_content": "  auto rhs = convolution->operand(1);",
          "content_same": false
        },
        {
          "line": 1163,
          "old_api": null,
          "new_api": "ElementTypesSameAndSupported",
          "old_text": null,
          "new_text": "ElementTypesSameAndSupported(\n      /*instruction=*/*convolution, /*operands=*/{lhs, rhs},\n      /*supported_types=*/{F16, F32, F64, C64, C128})",
          "old_line_content": "  // TODO(tonywy): Add PotentiallyImplementedAsMKLConvolution to support",
          "new_line_content": "  TF_RETURN_IF_ERROR(ElementTypesSameAndSupported(",
          "content_same": false
        },
        {
          "line": 3211,
          "old_api": null,
          "new_api": "index",
          "old_text": null,
          "new_text": "llvm_ir::EmitBufferIndexingGEP(\n      GetBufferTableArgument(), slice.index(), &b_)",
          "old_line_content": "          .xla_llvm_enable_invariant_load_metadata()) {",
          "new_line_content": "  llvm::Value* tempbuf_address_ptr = llvm_ir::EmitBufferIndexingGEP(",
          "content_same": false
        },
        {
          "line": 3213,
          "old_api": null,
          "new_api": "Load",
          "old_text": null,
          "new_text": "Load(tempbuf_address_ptr)",
          "old_line_content": "        llvm::LLVMContext::MD_invariant_load,",
          "new_line_content": "  llvm::LoadInst* tempbuf_address_base = Load(tempbuf_address_ptr);",
          "content_same": false
        },
        {
          "line": 3218,
          "old_api": null,
          "new_api": "getContext",
          "old_text": null,
          "new_text": "tempbuf_address_base->getContext()",
          "old_line_content": "",
          "new_line_content": "        llvm::MDNode::get(tempbuf_address_base->getContext(), /*MDs=*/{}));",
          "content_same": false
        },
        {
          "line": 3221,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "allocation.size()",
          "old_line_content": "    // Adjust the address to account for the slice offset.",
          "new_line_content": "  AttachDereferenceableMetadataForLoad(tempbuf_address_base, allocation.size());",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "lhs_shape.layout()",
          "old_line_content": "      // convolutions, except that we pretend that the 1D convolution is really",
          "new_line_content": "    if (LayoutUtil::IsMonotonicWithDim0Major(lhs_shape.layout()) &&",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "rhs_shape.layout()",
          "old_line_content": "      // a 2D convolution with the missing dimension set to 1.  We also adjust",
          "new_line_content": "        LayoutUtil::IsMonotonicWithDim0Major(rhs_shape.layout()) &&",
          "content_same": false
        },
        {
          "line": 1177,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "convolution_shape.layout()",
          "old_line_content": "      // the padding, dilation parameters as needed.",
          "new_line_content": "        LayoutUtil::IsMonotonicWithDim0Major(convolution_shape.layout())) {",
          "content_same": false
        },
        {
          "line": 3224,
          "old_api": null,
          "new_api": "offset",
          "old_text": null,
          "new_text": "slice.offset()",
          "old_line_content": "  }",
          "new_line_content": "  if (slice.offset() > 0) {",
          "content_same": false
        },
        {
          "line": 3227,
          "old_api": null,
          "new_api": "offset",
          "old_text": null,
          "new_text": "slice.offset()",
          "old_line_content": "}",
          "new_line_content": "        InBoundsGEP(tempbuf_address_base, b_.getInt64(slice.offset()));",
          "content_same": false
        },
        {
          "line": 3229,
          "old_api": null,
          "new_api": "getPointerTo",
          "old_text": null,
          "new_text": "BitCast(tempbuf_address_untyped,\n                 IrShapeType(target_shape)->getPointerTo())",
          "old_line_content": "llvm::Value* IrEmitter::EmitBufferPointer(const BufferAllocation::Slice& slice,",
          "new_line_content": "  return BitCast(tempbuf_address_untyped,",
          "content_same": false
        },
        {
          "line": 1182,
          "old_api": null,
          "new_api": "dimensions_size",
          "old_text": null,
          "new_text": "lhs_shape.dimensions_size()",
          "old_line_content": "",
          "new_line_content": "      bool one_dim_convolution = lhs_shape.dimensions_size() == 3;",
          "content_same": false
        },
        {
          "line": 1183,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(lhs)",
          "old_line_content": "      const ConvolutionDimensionNumbers& dnums =",
          "new_line_content": "      llvm::Value* lhs_address = GetEmittedValueFor(lhs);",
          "content_same": false
        },
        {
          "line": 3230,
          "old_api": null,
          "new_api": "getPointerTo",
          "old_text": null,
          "new_text": "IrShapeType(target_shape)->getPointerTo()",
          "old_line_content": "                                          const Shape& target_shape) {",
          "new_line_content": "                 IrShapeType(target_shape)->getPointerTo());",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(convolution)",
          "old_line_content": "",
          "new_line_content": "      TF_RETURN_IF_ERROR(EmitTargetAddressForOp(convolution));",
          "content_same": false
        },
        {
          "line": 3237,
          "old_api": null,
          "new_api": "allocation",
          "old_text": null,
          "new_text": "slice.allocation()->is_constant()",
          "old_line_content": "  } else {",
          "new_line_content": "  } else if (slice.allocation()->is_constant()) {",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "convolution->operand(0)->shape()",
          "old_line_content": "      int64 input_cols =",
          "new_line_content": "      const Shape& input_shape = convolution->operand(0)->shape();",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": null,
          "new_api": "input_batch_dimension",
          "old_text": null,
          "new_text": "dnums.input_batch_dimension()",
          "old_line_content": "          one_dim_convolution",
          "new_line_content": "      int64 input_batch = input_shape.dimensions(dnums.input_batch_dimension());",
          "content_same": false
        },
        {
          "line": 3239,
          "old_api": null,
          "new_api": "allocation",
          "old_text": null,
          "new_text": "slice.allocation()->index()",
          "old_line_content": "  }",
          "new_line_content": "        FindOrDie(constant_buffer_to_global_, slice.allocation()->index()),",
          "content_same": false
        },
        {
          "line": 3240,
          "old_api": null,
          "new_api": "getPointerTo",
          "old_text": null,
          "new_text": "IrShapeType(target_shape)->getPointerTo()",
          "old_line_content": "}",
          "new_line_content": "        IrShapeType(target_shape)->getPointerTo());",
          "content_same": false
        },
        {
          "line": 3242,
          "old_api": null,
          "new_api": "EmitGlobalBufferPointer",
          "old_text": null,
          "new_text": "EmitGlobalBufferPointer(slice, target_shape)",
          "old_line_content": "Status IrEmitter::EmitTargetAddressForOp(const HloInstruction* op) {",
          "new_line_content": "    return EmitGlobalBufferPointer(slice, target_shape);",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": null,
          "new_api": "input_spatial_dimensions",
          "old_text": null,
          "new_text": "dnums.input_spatial_dimensions(1)",
          "old_line_content": "      // Kernel tensor.",
          "new_line_content": "              : input_shape.dimensions(dnums.input_spatial_dimensions(1));",
          "content_same": false
        },
        {
          "line": 1200,
          "old_api": null,
          "new_api": "input_feature_dimension",
          "old_text": null,
          "new_text": "dnums.input_feature_dimension()",
          "old_line_content": "      int64 kernel_rows =",
          "new_line_content": "          input_shape.dimensions(dnums.input_feature_dimension());",
          "content_same": false
        },
        {
          "line": 3250,
          "old_api": null,
          "new_api": "EmitBufferPointer",
          "old_text": null,
          "new_text": "EmitBufferPointer(slice, target_shape)",
          "old_line_content": "}",
          "new_line_content": "  llvm::Value* addr = EmitBufferPointer(slice, target_shape);",
          "content_same": false
        },
        {
          "line": 1203,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "convolution->operand(1)->shape()",
          "old_line_content": "          one_dim_convolution",
          "new_line_content": "      const Shape& kernel_shape = convolution->operand(1)->shape();",
          "content_same": false
        },
        {
          "line": 3251,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(op)",
          "old_line_content": "",
          "new_line_content": "  addr->setName(IrName(op));",
          "content_same": false
        },
        {
          "line": 3253,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "    HloInstruction* target_op,",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": null,
          "new_api": "kernel_input_feature_dimension",
          "old_text": null,
          "new_text": "dnums.kernel_input_feature_dimension()",
          "old_line_content": "      // Output tensor.",
          "new_line_content": "          kernel_shape.dimensions(dnums.kernel_input_feature_dimension());",
          "content_same": false
        },
        {
          "line": 3259,
          "old_api": null,
          "new_api": "EmitTargetElementLoop",
          "old_text": null,
          "new_text": "EmitTargetElementLoop(target_op, /*desc=*/\"\", element_generator)",
          "old_line_content": "    HloInstruction* target_op, absl::string_view desc,",
          "new_line_content": "  return EmitTargetElementLoop(target_op, /*desc=*/\"\", element_generator);",
          "content_same": false
        },
        {
          "line": 1213,
          "old_api": null,
          "new_api": "kernel_output_feature_dimension",
          "old_text": null,
          "new_text": "dnums.kernel_output_feature_dimension()",
          "old_line_content": "      int64 output_rows =",
          "new_line_content": "          kernel_shape.dimensions(dnums.kernel_output_feature_dimension());",
          "content_same": false
        },
        {
          "line": 1216,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "convolution->shape()",
          "old_line_content": "                              ? 1",
          "new_line_content": "      const Shape& convolution_shape = convolution->shape();",
          "content_same": false
        },
        {
          "line": 3269,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(target_op)",
          "old_line_content": "    // For multiple outputs fusion, we need to emit each operand and the root.",
          "new_line_content": "  llvm_ir::IrArray target_array = GetIrArrayFor(target_op);",
          "content_same": false
        },
        {
          "line": 3271,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "target_op->opcode()",
          "old_line_content": "    std::vector<llvm_ir::IrArray> output_arrays;",
          "new_line_content": "  if (target_shape.IsTuple() && (target_op->opcode() == HloOpcode::kFusion ||",
          "content_same": false
        },
        {
          "line": 1225,
          "old_api": null,
          "new_api": "window",
          "old_text": null,
          "new_text": "convolution->window()",
          "old_line_content": "",
          "new_line_content": "      const Window& window = convolution->window();",
          "content_same": false
        },
        {
          "line": 3274,
          "old_api": null,
          "new_api": "TF_RET_CHECK",
          "old_text": null,
          "new_text": "TF_RET_CHECK(num_dynamic_loop_bounds_ == 0)",
          "old_line_content": "                          assignment_.GetUniqueSlice(target_op, {i}));",
          "new_line_content": "    TF_RET_CHECK(num_dynamic_loop_bounds_ == 0);",
          "content_same": false
        },
        {
          "line": 1228,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "window.dimensions(1).stride()",
          "old_line_content": "      int64 padding_left =",
          "new_line_content": "          one_dim_convolution ? 1 : window.dimensions(1).stride();",
          "content_same": false
        },
        {
          "line": 1230,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "window.dimensions(0).padding_low()",
          "old_line_content": "      int64 padding_right =",
          "new_line_content": "      int64 padding_top = window.dimensions(0).padding_low();",
          "content_same": false
        },
        {
          "line": 3279,
          "old_api": null,
          "new_api": "ShapeUtil::GetSubshape(target_shape, {i})",
          "old_text": null,
          "new_text": "ShapeUtil::GetSubshape(target_shape, {i})",
          "old_line_content": "    }",
          "new_line_content": "      const Shape& element_shape = ShapeUtil::GetSubshape(target_shape, {i});",
          "content_same": false
        },
        {
          "line": 3284,
          "old_api": null,
          "new_api": "EmitLoop",
          "old_text": null,
          "new_text": "TF_RETURN_IF_ERROR(\n        llvm_ir::LoopEmitter(element_generator, output_arrays, &b_)\n            .EmitLoop(IrName(target_op)))",
          "old_line_content": "    std::vector<llvm::Value*> tuple_operand_ptrs;",
          "new_line_content": "    TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 1237,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "window.dimensions(0).base_dilation()",
          "old_line_content": "      int64 rhs_col_dilation =",
          "new_line_content": "      int64 lhs_row_dilation = window.dimensions(0).base_dilation();",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "window.dimensions(1).base_dilation()",
          "old_line_content": "",
          "new_line_content": "          one_dim_convolution ? 1 : window.dimensions(1).base_dilation();",
          "content_same": false
        },
        {
          "line": 3289,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "output_arrays.size()",
          "old_line_content": "",
          "new_line_content": "    for (int64 i = 0; i < output_arrays.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 3290,
          "old_api": null,
          "new_api": "GetBasePointer",
          "old_text": null,
          "new_text": "output_arrays[i].GetBasePointer()",
          "old_line_content": "  } else {",
          "new_line_content": "      tuple_operand_ptrs.push_back(output_arrays[i].GetBasePointer());",
          "content_same": false
        },
        {
          "line": 3292,
          "old_api": null,
          "new_api": "llvm_ir::EmitTuple(target_array, tuple_operand_ptrs, &b_)",
          "old_text": null,
          "new_text": "llvm_ir::EmitTuple(target_array, tuple_operand_ptrs, &b_)",
          "old_line_content": "      // Emit code to read dynamic loop bounds from compute function argument.",
          "new_line_content": "    llvm_ir::EmitTuple(target_array, tuple_operand_ptrs, &b_);",
          "content_same": false
        },
        {
          "line": 3295,
          "old_api": null,
          "new_api": "ShouldEmitParallelLoopFor",
          "old_text": null,
          "new_text": "ShouldEmitParallelLoopFor(*target_op)",
          "old_line_content": "      // Emit parallel loop with dynamic loop bounds for most-major dimensions.",
          "new_line_content": "    if (ShouldEmitParallelLoopFor(*target_op)) {",
          "content_same": false
        },
        {
          "line": 1248,
          "old_api": null,
          "new_api": "getInt64Ty",
          "old_text": null,
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "          {int8_ptr_type, ir_ptr_type, ir_ptr_type, ir_ptr_type, int64_type,",
          "new_line_content": "      llvm::Type* int64_type = b_.getInt64Ty();",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": null,
          "new_api": "getInt8Ty",
          "old_text": null,
          "new_text": "b_.getInt8Ty()->getPointerTo()",
          "old_line_content": "           int64_type,    int64_type,  int64_type,  int64_type,  int64_type,",
          "new_line_content": "      llvm::Type* int8_ptr_type = b_.getInt8Ty()->getPointerTo();",
          "content_same": false
        },
        {
          "line": 1250,
          "old_api": null,
          "new_api": "getVoidTy",
          "old_text": null,
          "new_text": "llvm::FunctionType::get(\n          b_.getVoidTy(),\n          {int8_ptr_type, ir_ptr_type, ir_ptr_type, ir_ptr_type, int64_type,\n           int64_type,    int64_type,  int64_type,  int64_type,  int64_type,\n           int64_type,    int64_type,  int64_type,  int64_type,  int64_type,\n           int64_type,    int64_type,  int64_type,  int64_type,  int64_type,\n           int64_type,    int64_type,  int64_type,  int64_type},\n          /*isVarArg=*/false)",
          "old_line_content": "           int64_type,    int64_type,  int64_type,  int64_type,  int64_type,",
          "new_line_content": "      llvm::FunctionType* conv_type = llvm::FunctionType::get(",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": null,
          "new_api": "getVoidTy",
          "old_text": null,
          "new_text": "b_.getVoidTy()",
          "old_line_content": "           int64_type,    int64_type,  int64_type,  int64_type,  int64_type,",
          "new_line_content": "          b_.getVoidTy(),",
          "content_same": false
        },
        {
          "line": 3304,
          "old_api": null,
          "new_api": "EmitLoop",
          "old_text": null,
          "new_text": "TF_RETURN_IF_ERROR(\n          llvm_ir::LoopEmitter(element_generator, target_array, &b_)\n              .EmitLoop(IrName(target_op)))",
          "old_line_content": "  }",
          "new_line_content": "      TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 3306,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(target_op)",
          "old_line_content": "}",
          "new_line_content": "              .EmitLoop(IrName(target_op)));",
          "content_same": false
        },
        {
          "line": 1259,
          "old_api": null,
          "new_api": "debug_options",
          "old_text": null,
          "new_text": "hlo_module_config_.debug_options().xla_cpu_multi_thread_eigen()",
          "old_line_content": "      // TODO(b/78639006) Singlethread MKL conv2d is not implemented due to the",
          "new_line_content": "          hlo_module_config_.debug_options().xla_cpu_multi_thread_eigen();",
          "content_same": false
        },
        {
          "line": 1261,
          "old_api": null,
          "new_api": "debug_options",
          "old_text": null,
          "new_text": "hlo_module_config_.debug_options().xla_cpu_use_mkl_dnn()",
          "old_line_content": "      const char* fn_name =",
          "new_line_content": "          hlo_module_config_.debug_options().xla_cpu_use_mkl_dnn();",
          "content_same": false
        },
        {
          "line": 3309,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "                             const HloInstruction& destination) {",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3315,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(&destination)",
          "old_line_content": "         /*SrcAlign=*/1, source_size);",
          "new_line_content": "  llvm::Value* destination_value = GetEmittedValueFor(&destination);",
          "content_same": false
        },
        {
          "line": 3318,
          "old_api": null,
          "new_api": "MemCpy",
          "old_text": null,
          "new_text": "MemCpy(destination_value, /*DstAlign=*/1, source_value,\n         /*SrcAlign=*/1, source_size)",
          "old_line_content": "",
          "new_line_content": "  MemCpy(destination_value, /*DstAlign=*/1, source_value,",
          "content_same": false
        },
        {
          "line": 3320,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "    const HloInstruction& instruction,",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3334,
          "old_api": null,
          "new_api": "absl::c_linear_search(supported_types, primitive_type)",
          "old_text": null,
          "new_text": "absl::c_linear_search(supported_types, primitive_type)",
          "old_line_content": "  }",
          "new_line_content": "  if (!absl::c_linear_search(supported_types, primitive_type)) {",
          "content_same": false
        },
        {
          "line": 3336,
          "old_api": null,
          "new_api": "PrimitiveType_Name",
          "old_text": null,
          "new_text": "PrimitiveType_Name(primitive_type)",
          "old_line_content": "}",
          "new_line_content": "                         PrimitiveType_Name(primitive_type),",
          "content_same": false
        },
        {
          "line": 3337,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction.opcode()",
          "old_line_content": "",
          "new_line_content": "                         HloOpcodeString(instruction.opcode()));",
          "content_same": false
        },
        {
          "line": 3339,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "  ElementalIrEmitter::HloToElementGeneratorMap operand_to_generator;",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3344,
          "old_api": null,
          "new_api": "operands",
          "old_text": null,
          "new_text": "hlo->operands()",
          "old_line_content": "  }",
          "new_line_content": "  for (const HloInstruction* operand : hlo->operands()) {",
          "content_same": false
        },
        {
          "line": 3350,
          "old_api": null,
          "new_api": "MakeElementGenerator",
          "old_text": null,
          "new_text": "EmitTargetElementLoop(\n      hlo, elemental_emitter.MakeElementGenerator(hlo, operand_to_generator))",
          "old_line_content": "llvm::Value* IrEmitter::EmitScalarReturningThreadLocalCall(",
          "new_line_content": "  return EmitTargetElementLoop(",
          "content_same": false
        },
        {
          "line": 3351,
          "old_api": null,
          "new_api": "MakeElementGenerator",
          "old_text": null,
          "new_text": "elemental_emitter.MakeElementGenerator(hlo, operand_to_generator)",
          "old_line_content": "    const HloComputation& callee, absl::Span<llvm::Value* const> parameters,",
          "new_line_content": "      hlo, elemental_emitter.MakeElementGenerator(hlo, operand_to_generator));",
          "content_same": false
        },
        {
          "line": 1304,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "b_.getInt64(lhs_row_dilation)",
          "old_line_content": "                      });",
          "new_line_content": "                          b_.getInt64(lhs_row_dilation),",
          "content_same": false
        },
        {
          "line": 1305,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "b_.getInt64(lhs_col_dilation)",
          "old_line_content": "",
          "new_line_content": "                          b_.getInt64(lhs_col_dilation),",
          "content_same": false
        },
        {
          "line": 1307,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "b_.getInt64(rhs_col_dilation)",
          "old_line_content": "    }",
          "new_line_content": "                          b_.getInt64(rhs_col_dilation),",
          "content_same": false
        },
        {
          "line": 1310,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "  // This is a completely un-optimized version of convolution just to",
          "new_line_content": "      return Status::OK();",
          "content_same": false
        },
        {
          "line": 3358,
          "old_api": null,
          "new_api": "EmitThreadLocalCall",
          "old_text": null,
          "new_text": "EmitThreadLocalCall(callee, parameters, name)",
          "old_line_content": "",
          "new_line_content": "      EmitThreadLocalCall(callee, parameters, name);",
          "content_same": false
        },
        {
          "line": 3359,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "return_value.size()",
          "old_line_content": "std::vector<llvm::Value*> IrEmitter::EmitThreadLocalCall(",
          "new_line_content": "  CHECK_EQ(return_value.size(), 1);",
          "content_same": false
        },
        {
          "line": 3371,
          "old_api": null,
          "new_api": "tuple_shapes",
          "old_text": null,
          "new_text": "return_shape.tuple_shapes()",
          "old_line_content": "",
          "new_line_content": "      absl::c_all_of(return_shape.tuple_shapes(), [&](const Shape& shape) {",
          "content_same": false
        },
        {
          "line": 3372,
          "old_api": null,
          "new_api": "ShapeUtil::IsScalar(shape)",
          "old_text": null,
          "new_text": "ShapeUtil::IsScalar(shape)",
          "old_line_content": "  std::vector<llvm::Value*> parameter_addrs;",
          "new_line_content": "        return ShapeUtil::IsScalar(shape);",
          "content_same": false
        },
        {
          "line": 1328,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "operand->shape().layout()",
          "old_line_content": "",
          "new_line_content": "  TF_RET_CHECK(LayoutUtil::IsMonotonicWithDim0Major(operand->shape().layout()));",
          "content_same": false
        },
        {
          "line": 1331,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "fft->shape()",
          "old_line_content": "",
          "new_line_content": "  VLOG(3) << \"fft=\" << ShapeUtil::HumanStringWithLayout(fft->shape());",
          "content_same": false
        },
        {
          "line": 3379,
          "old_api": null,
          "new_api": "getType",
          "old_text": null,
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n        parameter->getType(), \"arg_addr\", &b_)",
          "old_line_content": "  }",
          "new_line_content": "    llvm::Value* parameter_addr = llvm_ir::EmitAllocaAtFunctionEntry(",
          "content_same": false
        },
        {
          "line": 1333,
          "old_api": null,
          "new_api": "GetEmittedValueFor",
          "old_text": null,
          "new_text": "GetEmittedValueFor(operand)",
          "old_line_content": "  int64 input_batch = 1;",
          "new_line_content": "  llvm::Value* operand_address = GetEmittedValueFor(operand);",
          "content_same": false
        },
        {
          "line": 3380,
          "old_api": null,
          "new_api": "getType",
          "old_text": null,
          "new_text": "parameter->getType()",
          "old_line_content": "",
          "new_line_content": "        parameter->getType(), \"arg_addr\", &b_);",
          "content_same": false
        },
        {
          "line": 3381,
          "old_api": null,
          "new_api": "Store",
          "old_text": null,
          "new_text": "Store(parameter, parameter_addr)",
          "old_line_content": "  llvm::Type* return_value_buffer_type =",
          "new_line_content": "    Store(parameter, parameter_addr);",
          "content_same": false
        },
        {
          "line": 1336,
          "old_api": null,
          "new_api": "fft_length",
          "old_text": null,
          "new_text": "fft->fft_length()",
          "old_line_content": "  }",
          "new_line_content": "  const std::vector<int64>& fft_length = fft->fft_length();",
          "content_same": false
        },
        {
          "line": 1338,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "fft_length.size()",
          "old_line_content": "  // Args have been computed, make the call.",
          "new_line_content": "  for (int i = 0; i < fft->shape().dimensions_size() - fft_length.size(); i++) {",
          "content_same": false
        },
        {
          "line": 3387,
          "old_api": null,
          "new_api": "absl::StrCat(name, \"_return_value_addr\")",
          "old_text": null,
          "new_text": "absl::StrCat(name, \"_return_value_addr\")",
          "old_line_content": "          : 0;",
          "new_line_content": "  std::string retval_alloca_name = absl::StrCat(name, \"_return_value_addr\");",
          "content_same": false
        },
        {
          "line": 3390,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "return_shape.element_type()",
          "old_line_content": "",
          "new_line_content": "          ? MinimumAlignmentForPrimitiveType(return_shape.element_type())",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": null,
          "new_api": "getInt32Ty",
          "old_text": null,
          "new_text": "b_.getInt32Ty()",
          "old_line_content": "      {int8_ptr_type, int8_ptr_type, int8_ptr_type, int32_type, int32_type,",
          "new_line_content": "  llvm::Type* int32_type = b_.getInt32Ty();",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": null,
          "new_api": "getInt64Ty",
          "old_text": null,
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "       int64_type, int64_type, int64_type, int64_type},",
          "new_line_content": "  llvm::Type* int64_type = b_.getInt64Ty();",
          "content_same": false
        },
        {
          "line": 1346,
          "old_api": null,
          "new_api": "getVoidTy",
          "old_text": null,
          "new_text": "llvm::FunctionType::get(\n      b_.getVoidTy(),\n      {int8_ptr_type, int8_ptr_type, int8_ptr_type, int32_type, int32_type,\n       int64_type, int64_type, int64_type, int64_type},\n      /*isVarArg=*/false)",
          "old_line_content": "      /*isVarArg=*/false);",
          "new_line_content": "  llvm::FunctionType* fft_type = llvm::FunctionType::get(",
          "content_same": false
        },
        {
          "line": 1347,
          "old_api": null,
          "new_api": "getVoidTy",
          "old_text": null,
          "new_text": "b_.getVoidTy()",
          "old_line_content": "",
          "new_line_content": "      b_.getVoidTy(),",
          "content_same": false
        },
        {
          "line": 3392,
          "old_api": null,
          "new_api": "llvm_ir::EmitAllocaAtFunctionEntry(\n      return_value_buffer_type, retval_alloca_name, &b_, retval_alignment)",
          "old_text": null,
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n      return_value_buffer_type, retval_alloca_name, &b_, retval_alignment)",
          "old_line_content": "  if (is_scalar_return) {",
          "new_line_content": "  llvm::Value* return_value_buffer = llvm_ir::EmitAllocaAtFunctionEntry(",
          "content_same": false
        },
        {
          "line": 3397,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "allocas_for_returned_scalars.push_back(return_value_buffer)",
          "old_line_content": "        << \"Multivalue function can not return more than 1000 elements to avoid\"",
          "new_line_content": "    allocas_for_returned_scalars.push_back(return_value_buffer);",
          "content_same": false
        },
        {
          "line": 3399,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "    allocas_for_returned_scalars =",
          "new_line_content": "    constexpr int max_tuple_size = 1000;",
          "content_same": false
        },
        {
          "line": 1353,
          "old_api": null,
          "new_api": "debug_options",
          "old_text": null,
          "new_text": "hlo_module_config_.debug_options().xla_cpu_multi_thread_eigen()",
          "old_line_content": "",
          "new_line_content": "      hlo_module_config_.debug_options().xla_cpu_multi_thread_eigen();",
          "content_same": false
        },
        {
          "line": 3404,
          "old_api": null,
          "new_api": "llvm_ir::EmitTupleAllocasAtFunctionEntry(return_shape, &b_)",
          "old_text": null,
          "new_text": "llvm_ir::EmitTupleAllocasAtFunctionEntry(return_shape, &b_)",
          "old_line_content": "  }",
          "new_line_content": "        llvm_ir::EmitTupleAllocasAtFunctionEntry(return_shape, &b_);",
          "content_same": false
        },
        {
          "line": 3411,
          "old_api": null,
          "new_api": "getInt8PtrTy",
          "old_text": null,
          "new_text": "GetArrayFunctionCallArguments(\n           parameter_addrs, &b_, name,\n           /*return_value_buffer=*/return_value_buffer,\n           /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),\n           /*buffer_table_arg=*/\n           llvm::Constant::getNullValue(b_.getInt8PtrTy()->getPointerTo()),\n           /*profile_counters_arg=*/GetProfileCountersArgument())",
          "old_line_content": "           /*buffer_table_arg=*/",
          "new_line_content": "       GetArrayFunctionCallArguments(",
          "content_same": false
        },
        {
          "line": 3414,
          "old_api": null,
          "new_api": "GetExecutableRunOptionsArgument",
          "old_text": null,
          "new_text": "GetExecutableRunOptionsArgument()",
          "old_line_content": "",
          "new_line_content": "           /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),",
          "content_same": false
        },
        {
          "line": 1368,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "b_.getInt64(input_batch)",
          "old_line_content": "",
          "new_line_content": "        b_.getInt32(fft_rank), b_.getInt64(input_batch),",
          "content_same": false
        },
        {
          "line": 3417,
          "old_api": null,
          "new_api": "GetProfileCountersArgument",
          "old_text": null,
          "new_text": "GetProfileCountersArgument()",
          "old_line_content": "  for (llvm::Value* addr : allocas_for_returned_scalars) {",
          "new_line_content": "           /*profile_counters_arg=*/GetProfileCountersArgument()));",
          "content_same": false
        },
        {
          "line": 1370,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "b_.getInt64(fft_rank > 1 ? fft_length[1] : 0)",
          "old_line_content": "}",
          "new_line_content": "        b_.getInt64(fft_rank > 1 ? fft_length[1] : 0),",
          "content_same": false
        },
        {
          "line": 1371,
          "old_api": null,
          "new_api": "getInt64",
          "old_text": null,
          "new_text": "b_.getInt64(fft_rank > 2 ? fft_length[2] : 0)",
          "old_line_content": "",
          "new_line_content": "        b_.getInt64(fft_rank > 2 ? fft_length[2] : 0)});",
          "content_same": false
        },
        {
          "line": 3420,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "allocas_for_returned_scalars.size()",
          "old_line_content": "  return returned_scalars;",
          "new_line_content": "  returned_scalars.reserve(allocas_for_returned_scalars.size());",
          "content_same": false
        },
        {
          "line": 1373,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "  // When there is a single replica, a cross replica sum is the identity",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 3422,
          "old_api": null,
          "new_api": "Load",
          "old_text": null,
          "new_text": "Load(addr)",
          "old_line_content": "",
          "new_line_content": "    returned_scalars.push_back(Load(addr));",
          "content_same": false
        },
        {
          "line": 3429,
          "old_api": null,
          "new_api": "absl::c_binary_search(global_computations_, &callee)",
          "old_text": null,
          "new_text": "absl::c_binary_search(global_computations_, &callee)",
          "old_line_content": "           /*parameter_addresses=*/{}, &b_, name,",
          "new_line_content": "  CHECK(absl::c_binary_search(global_computations_, &callee));",
          "content_same": false
        },
        {
          "line": 1387,
          "old_api": null,
          "new_api": "operand_count",
          "old_text": null,
          "new_text": "crs->operand_count()",
          "old_line_content": "  // CRS with multiple operands and one replica produces a (one-deep) tuple.",
          "new_line_content": "  if (crs->operand_count() == 1) {",
          "content_same": false
        },
        {
          "line": 1388,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "crs->operand(0)",
          "old_line_content": "  std::vector<llvm::Value*> operand_ptrs;",
          "new_line_content": "    return EmitMemcpy(*crs->operand(0), *crs);",
          "content_same": false
        },
        {
          "line": 3435,
          "old_api": null,
          "new_api": "getInt8PtrTy",
          "old_text": null,
          "new_text": "b_.getInt8PtrTy()",
          "old_line_content": "}",
          "new_line_content": "           llvm::Constant::getNullValue(b_.getInt8PtrTy()),",
          "content_same": false
        },
        {
          "line": 3436,
          "old_api": null,
          "new_api": "GetExecutableRunOptionsArgument",
          "old_text": null,
          "new_text": "GetExecutableRunOptionsArgument()",
          "old_line_content": "",
          "new_line_content": "           /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),",
          "content_same": false
        },
        {
          "line": 3437,
          "old_api": null,
          "new_api": "GetBufferTableArgument",
          "old_text": null,
          "new_text": "GetBufferTableArgument()",
          "old_line_content": "llvm::Value* IrEmitter::GetBufferForGlobalCallReturnValue(",
          "new_line_content": "           /*buffer_table_arg=*/GetBufferTableArgument(),",
          "content_same": false
        },
        {
          "line": 3438,
          "old_api": null,
          "new_api": "GetProfileCountersArgument",
          "old_text": null,
          "new_text": "GetProfileCountersArgument()",
          "old_line_content": "    const HloComputation& callee) {",
          "new_line_content": "           /*profile_counters_arg=*/GetProfileCountersArgument()));",
          "content_same": false
        },
        {
          "line": 1393,
          "old_api": null,
          "new_api": "operand_count",
          "old_text": null,
          "new_text": "crs->operand_count()",
          "old_line_content": "",
          "new_line_content": "  for (int64 i = 0; i < crs->operand_count(); ++i) {",
          "content_same": false
        },
        {
          "line": 3443,
          "old_api": null,
          "new_api": "root_instruction",
          "old_text": null,
          "new_text": "callee.root_instruction()",
          "old_line_content": "",
          "new_line_content": "  const HloInstruction* root_inst = callee.root_instruction();",
          "content_same": false
        },
        {
          "line": 3444,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "root_inst->opcode()",
          "old_line_content": "  const BufferAllocation::Slice root_buffer =",
          "new_line_content": "  if (root_inst->opcode() == HloOpcode::kOutfeed) {",
          "content_same": false
        },
        {
          "line": 1398,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "crs->operand(i)->shape()",
          "old_line_content": "",
          "new_line_content": "    const Shape& operand_shape = crs->operand(i)->shape();",
          "content_same": false
        },
        {
          "line": 1399,
          "old_api": null,
          "new_api": "IsArray",
          "old_text": null,
          "new_text": "operand_shape.IsArray()",
          "old_line_content": "    // TODO(b/63762267): Be more aggressive about specifying alignment.",
          "new_line_content": "    CHECK(operand_shape.IsArray())",
          "content_same": false
        },
        {
          "line": 3449,
          "old_api": null,
          "new_api": "GetUniqueTopLevelSlice",
          "old_text": null,
          "new_text": "assignment_.GetUniqueTopLevelSlice(root_inst).ValueOrDie()",
          "old_line_content": "}  // namespace cpu",
          "new_line_content": "      assignment_.GetUniqueTopLevelSlice(root_inst).ValueOrDie();",
          "content_same": false
        },
        {
          "line": 3450,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "root_inst->shape()",
          "old_line_content": "}  // namespace xla",
          "new_line_content": "  return EmitBufferPointer(root_buffer, root_inst->shape());",
          "content_same": false
        },
        {
          "line": 1405,
          "old_api": null,
          "new_api": "ShapeUtil::ByteSizeOf(operand_shape)",
          "old_text": null,
          "new_text": "ShapeUtil::ByteSizeOf(operand_shape)",
          "old_line_content": "}",
          "new_line_content": "           /*SrcAlign=*/1, ShapeUtil::ByteSizeOf(operand_shape));",
          "content_same": false
        },
        {
          "line": 1407,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(crs)",
          "old_line_content": "Status IrEmitter::HandleAllReduceMultipleReplica(HloInstruction* crs) {",
          "new_line_content": "  llvm_ir::EmitTuple(GetIrArrayFor(crs), operand_ptrs, &b_);",
          "content_same": false
        },
        {
          "line": 1413,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "crs->operand(0)->shape().element_type()",
          "old_line_content": "    // TODO(cheshire): Fix duplication wrt. cpu_runtime",
          "new_line_content": "  PrimitiveType datatype = crs->operand(0)->shape().element_type();",
          "content_same": false
        },
        {
          "line": 1414,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(crs)",
          "old_line_content": "    switch (datatype) {",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(crs));",
          "content_same": false
        },
        {
          "line": 1416,
          "old_api": null,
          "new_api": "[&] {\n    // TODO(cheshire): Fix duplication wrt. cpu_runtime\n    switch (datatype) {\n      case S8:\n      case U8:\n      case S32:\n      case U32:\n      case S64:\n      case U64:\n      case F16:\n      case F32:\n      case F64:\n        return true;\n      default:\n        return false;\n    }\n  }()",
          "old_text": null,
          "new_text": "[&] {\n    // TODO(cheshire): Fix duplication wrt. cpu_runtime\n    switch (datatype) {\n      case S8:\n      case U8:\n      case S32:\n      case U32:\n      case S64:\n      case U64:\n      case F16:\n      case F32:\n      case F64:\n        return true;\n      default:\n        return false;\n    }\n  }()",
          "old_line_content": "      case U8:",
          "new_line_content": "  bool is_datatype_supported = [&] {",
          "content_same": false
        },
        {
          "line": 1439,
          "old_api": null,
          "new_api": "to_apply",
          "old_text": null,
          "new_text": "crs->to_apply()",
          "old_line_content": "",
          "new_line_content": "  if (!MatchReductionComputation(crs->to_apply()).has_value()) {",
          "content_same": false
        },
        {
          "line": 1445,
          "old_api": null,
          "new_api": "getInt32Ty",
          "old_text": null,
          "new_text": "b_.getInt32Ty()",
          "old_line_content": "                              {/*run_options=*/i8_ptr_type,",
          "new_line_content": "  llvm::Type* int32_type = b_.getInt32Ty();",
          "content_same": false
        },
        {
          "line": 1446,
          "old_api": null,
          "new_api": "getInt64Ty",
          "old_text": null,
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "                               /*replica_groups=*/i8_ptr_type,",
          "new_line_content": "  llvm::Type* int64_type = b_.getInt64Ty();",
          "content_same": false
        },
        {
          "line": 1448,
          "old_api": null,
          "new_api": "getVoidTy",
          "old_text": null,
          "new_text": "b_.getVoidTy()",
          "old_line_content": "                               /*channel_id_present=*/int32_type,",
          "new_line_content": "      llvm::FunctionType::get(b_.getVoidTy(),",
          "content_same": false
        },
        {
          "line": 1461,
          "old_api": null,
          "new_api": "getCallee",
          "old_text": null,
          "new_text": "llvm::dyn_cast<llvm::Function>(\n      module_\n          ->getOrInsertFunction(runtime::kAllReduceSymbolName,\n                                all_reduce_func_ty)\n          .getCallee())",
          "old_line_content": "          .getCallee());",
          "new_line_content": "  auto all_reduce_func = llvm::dyn_cast<llvm::Function>(",
          "content_same": false
        },
        {
          "line": 1469,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "replica_groups.size()",
          "old_line_content": "  int32 shape_length;",
          "new_line_content": "  int32 replica_groups_size = replica_groups.size();",
          "content_same": false
        },
        {
          "line": 1474,
          "old_api": null,
          "new_api": "TF_ASSIGN_OR_RETURN",
          "old_text": null,
          "new_text": "TF_ASSIGN_OR_RETURN(\n      llvm::Value * shape_ptr,\n      llvm_ir::EncodeSelfDescribingShapeConstant(shape, &shape_length, &b_))",
          "old_line_content": "  TF_ASSIGN_OR_RETURN(BufferAllocation::Slice input_slice,",
          "new_line_content": "  TF_ASSIGN_OR_RETURN(",
          "content_same": false
        },
        {
          "line": 1484,
          "old_api": null,
          "new_api": "EmitBufferPointer",
          "old_text": null,
          "new_text": "EmitBufferPointer(output_slice, shape)",
          "old_line_content": "        /*replica_groups=*/replica_groups_v,",
          "new_line_content": "  llvm::Value* output_buffer = EmitBufferPointer(output_slice, shape);",
          "content_same": false
        },
        {
          "line": 1486,
          "old_api": null,
          "new_api": "getInt32",
          "old_text": null,
          "new_text": "Call(all_reduce_func,\n       {/*run_options=*/GetExecutableRunOptionsArgument(),\n        /*replica_groups=*/replica_groups_v,\n        /*replica_groups_size=*/b_.getInt32(replica_groups_size),\n\n        /*channel_id_present=*/\n        b_.getInt32(static_cast<int32>(crs->channel_id().has_value())),\n        /*op_id=*/\n        b_.getInt64(crs->channel_id().has_value()\n                        ? *crs->channel_id()\n                        : crs->GetModule()->unique_id()),\n\n        /*reduction_kind=*/\n        b_.getInt32(\n            static_cast<int32>(*MatchReductionComputation(crs->to_apply()))),\n\n        /*shape_ptr=*/shape_ptr,\n        /*shape_length=*/b_.getInt32(shape_length),\n\n        /*input_buffer=*/b_.CreateBitCast(input_buffer, i8_ptr_type),\n        /*output_buffer=*/b_.CreateBitCast(output_buffer, i8_ptr_type)})",
          "old_line_content": "",
          "new_line_content": "  Call(all_reduce_func,",
          "content_same": false
        },
        {
          "line": 1487,
          "old_api": null,
          "new_api": "GetExecutableRunOptionsArgument",
          "old_text": null,
          "new_text": "GetExecutableRunOptionsArgument()",
          "old_line_content": "        /*channel_id_present=*/",
          "new_line_content": "       {/*run_options=*/GetExecutableRunOptionsArgument(),",
          "content_same": false
        },
        {
          "line": 1489,
          "old_api": null,
          "new_api": "getInt32",
          "old_text": null,
          "new_text": "b_.getInt32(replica_groups_size)",
          "old_line_content": "        /*op_id=*/",
          "new_line_content": "        /*replica_groups_size=*/b_.getInt32(replica_groups_size),",
          "content_same": false
        },
        {
          "line": 1494,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "crs->channel_id().has_value()",
          "old_line_content": "        /*reduction_kind=*/",
          "new_line_content": "        b_.getInt64(crs->channel_id().has_value()",
          "content_same": false
        },
        {
          "line": 1500,
          "old_api": null,
          "new_api": "to_apply",
          "old_text": null,
          "new_text": "crs->to_apply()",
          "old_line_content": "",
          "new_line_content": "            static_cast<int32>(*MatchReductionComputation(crs->to_apply()))),",
          "content_same": false
        },
        {
          "line": 1503,
          "old_api": null,
          "new_api": "getInt32",
          "old_text": null,
          "new_text": "b_.getInt32(shape_length)",
          "old_line_content": "",
          "new_line_content": "        /*shape_length=*/b_.getInt32(shape_length),",
          "content_same": false
        },
        {
          "line": 1505,
          "old_api": null,
          "new_api": "CreateBitCast",
          "old_text": null,
          "new_text": "b_.CreateBitCast(input_buffer, i8_ptr_type)",
          "old_line_content": "}",
          "new_line_content": "        /*input_buffer=*/b_.CreateBitCast(input_buffer, i8_ptr_type),",
          "content_same": false
        },
        {
          "line": 1506,
          "old_api": null,
          "new_api": "CreateBitCast",
          "old_text": null,
          "new_text": "b_.CreateBitCast(output_buffer, i8_ptr_type)",
          "old_line_content": "",
          "new_line_content": "        /*output_buffer=*/b_.CreateBitCast(output_buffer, i8_ptr_type)});",
          "content_same": false
        },
        {
          "line": 1512,
          "old_api": null,
          "new_api": "replica_count",
          "old_text": null,
          "new_text": "hlo_module_config_.replica_count()",
          "old_line_content": "}",
          "new_line_content": "  if (hlo_module_config_.replica_count() == 1) {",
          "content_same": false
        },
        {
          "line": 1513,
          "old_api": null,
          "new_api": "HandleAllReduceSingleReplica",
          "old_text": null,
          "new_text": "HandleAllReduceSingleReplica(crs)",
          "old_line_content": "",
          "new_line_content": "    return HandleAllReduceSingleReplica(crs);",
          "content_same": false
        },
        {
          "line": 1519,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(hlo)",
          "old_line_content": "                              {/*run_options=*/i8_ptr_type,",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(hlo));",
          "content_same": false
        },
        {
          "line": 1520,
          "old_api": null,
          "new_api": "getContext",
          "old_text": null,
          "new_text": "module_->getContext()",
          "old_line_content": "                               /*output_buffer=*/i8_ptr_type},",
          "new_line_content": "  llvm::Type* i8_ptr_type = llvm::Type::getInt8PtrTy(module_->getContext());",
          "content_same": false
        },
        {
          "line": 1526,
          "old_api": null,
          "new_api": "getCallee",
          "old_text": null,
          "new_text": "llvm::dyn_cast<llvm::Function>(\n      module_\n          ->getOrInsertFunction(runtime::kReplicaIdSymbolName,\n                                replica_id_function_ty)\n          .getCallee())",
          "old_line_content": "          .getCallee());",
          "new_line_content": "  auto* replica_id_func = llvm::dyn_cast<llvm::Function>(",
          "content_same": false
        },
        {
          "line": 1534,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "hlo->shape()",
          "old_line_content": "",
          "new_line_content": "  llvm::Value* output_buffer = EmitBufferPointer(output_slice, hlo->shape());",
          "content_same": false
        },
        {
          "line": 1536,
          "old_api": null,
          "new_api": "GetExecutableRunOptionsArgument",
          "old_text": null,
          "new_text": "GetExecutableRunOptionsArgument()",
          "old_line_content": "}",
          "new_line_content": "       {/*run_options=*/GetExecutableRunOptionsArgument(),",
          "content_same": false
        },
        {
          "line": 1537,
          "old_api": null,
          "new_api": "CreateBitCast",
          "old_text": null,
          "new_text": "b_.CreateBitCast(output_buffer, i8_ptr_type)",
          "old_line_content": "",
          "new_line_content": "        /*output_buffer=*/b_.CreateBitCast(output_buffer, i8_ptr_type)});",
          "content_same": false
        },
        {
          "line": 1543,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "parameter->ToString()",
          "old_line_content": "// Returns true if the relative order of the unreduced dimensions stays the same",
          "new_line_content": "  VLOG(2) << \"HandleParameter: \" << parameter->ToString();",
          "content_same": false
        },
        {
          "line": 1544,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(parameter)",
          "old_line_content": "// through the reduce operation.",
          "new_line_content": "  return EmitTargetAddressForOp(parameter);",
          "content_same": false
        },
        {
          "line": 1550,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "reduce.opcode()",
          "old_line_content": "  //",
          "new_line_content": "  DCHECK_EQ(reduce.opcode(), HloOpcode::kReduce);",
          "content_same": false
        },
        {
          "line": 1560,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "reduce.dimensions().end()",
          "old_line_content": "",
          "new_line_content": "                                          reduce.dimensions().end());",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "reduced_dims.contains(i)",
          "old_line_content": "    }",
          "new_line_content": "    if (reduced_dims.contains(i)) {",
          "content_same": false
        },
        {
          "line": 1570,
          "old_api": null,
          "new_api": "InsertOrDie",
          "old_text": null,
          "new_text": "InsertOrDie(&unreduced_dim_map, i, i - delta)",
          "old_line_content": "  // Iterate dimensions minor to major and check that the corresponding",
          "new_line_content": "      InsertOrDie(&unreduced_dim_map, i, i - delta);",
          "content_same": false
        },
        {
          "line": 1579,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "operand_shape.layout().minor_to_major(operand_dim_idx)",
          "old_line_content": "        return false;",
          "new_line_content": "    int64 operand_dim = operand_shape.layout().minor_to_major(operand_dim_idx);",
          "content_same": false
        },
        {
          "line": 1580,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "reduced_dims.contains(operand_dim)",
          "old_line_content": "      }",
          "new_line_content": "    if (!reduced_dims.contains(operand_dim)) {",
          "content_same": false
        },
        {
          "line": 1581,
          "old_api": null,
          "new_api": "FindOrDie",
          "old_text": null,
          "new_text": "FindOrDie(unreduced_dim_map, operand_dim)",
          "old_line_content": "    }",
          "new_line_content": "      if (FindOrDie(unreduced_dim_map, operand_dim) !=",
          "content_same": false
        },
        {
          "line": 1582,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "result_shape.layout().minor_to_major(result_dim_idx++)",
          "old_line_content": "  }",
          "new_line_content": "          result_shape.layout().minor_to_major(result_dim_idx++)) {",
          "content_same": false
        },
        {
          "line": 1588,
          "old_api": null,
          "new_api": "dimensions_size",
          "old_text": null,
          "new_text": "result_shape.dimensions_size()",
          "old_line_content": "",
          "new_line_content": "  CHECK_EQ(result_dim_idx, result_shape.dimensions_size());",
          "content_same": false
        },
        {
          "line": 1595,
          "old_api": null,
          "new_api": "num_parameters",
          "old_text": null,
          "new_text": "function->num_parameters()",
          "old_line_content": "",
          "new_line_content": "  CHECK_EQ(function->num_parameters(), 2);",
          "content_same": false
        },
        {
          "line": 1597,
          "old_api": null,
          "new_api": "root_instruction",
          "old_text": null,
          "new_text": "function->root_instruction()",
          "old_line_content": "    *failure_reason = \"root instruction is not a binary operation\";",
          "new_line_content": "  auto root_instruction = function->root_instruction();",
          "content_same": false
        },
        {
          "line": 1598,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "root_instruction->shape()",
          "old_line_content": "    return nullptr;",
          "new_line_content": "  CHECK(ShapeUtil::IsScalar(root_instruction->shape()));",
          "content_same": false
        },
        {
          "line": 1600,
          "old_api": null,
          "new_api": "operand_count",
          "old_text": null,
          "new_text": "root_instruction->operand_count()",
          "old_line_content": "",
          "new_line_content": "  if (root_instruction->operand_count() != 2) {",
          "content_same": false
        },
        {
          "line": 1605,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "root_instruction->shape()",
          "old_line_content": "    // strided load to get all reals in a vector, all images in a vector, or use",
          "new_line_content": "  const Shape& root_shape = root_instruction->shape();",
          "content_same": false
        },
        {
          "line": 1606,
          "old_api": null,
          "new_api": "ShapeUtil::ElementIsComplex(root_shape)",
          "old_text": null,
          "new_text": "ShapeUtil::ElementIsComplex(root_shape)",
          "old_line_content": "    // CreateShuffleVector on a bitcast to float x [2N].",
          "new_line_content": "  if (ShapeUtil::ElementIsComplex(root_shape)) {",
          "content_same": false
        },
        {
          "line": 1616,
          "old_api": null,
          "new_api": "ShapeUtil::ElementIsSigned(root_shape)",
          "old_text": null,
          "new_text": "ShapeUtil::ElementIsSigned(root_shape)",
          "old_line_content": "",
          "new_line_content": "  bool root_is_signed = ShapeUtil::ElementIsSigned(root_shape);",
          "content_same": false
        },
        {
          "line": 1619,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "root_instruction->operand(1)",
          "old_line_content": "  if (!(lhs == param_0 && rhs == param_1) &&",
          "new_line_content": "  auto rhs = root_instruction->operand(1);",
          "content_same": false
        },
        {
          "line": 1621,
          "old_api": null,
          "new_api": "parameter_instruction",
          "old_text": null,
          "new_text": "function->parameter_instruction(0)",
          "old_line_content": "    *failure_reason =",
          "new_line_content": "  auto param_0 = function->parameter_instruction(0);",
          "content_same": false
        },
        {
          "line": 1622,
          "old_api": null,
          "new_api": "parameter_instruction",
          "old_text": null,
          "new_text": "function->parameter_instruction(1)",
          "old_line_content": "        \"root instruction is not a binary operation on the incoming arguments\";",
          "new_line_content": "  auto param_1 = function->parameter_instruction(1);",
          "content_same": false
        },
        {
          "line": 1630,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "rhs->shape()",
          "old_line_content": "  // while these emit scalar or vector operations depending on the type of the",
          "new_line_content": "  CHECK(ShapeUtil::IsScalar(lhs->shape()) && ShapeUtil::IsScalar(rhs->shape()));",
          "content_same": false
        },
        {
          "line": 1636,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "root_instruction->opcode()",
          "old_line_content": "",
          "new_line_content": "  switch (root_instruction->opcode()) {",
          "content_same": false
        },
        {
          "line": 1644,
          "old_api": null,
          "new_api": "CreateAdd",
          "old_text": null,
          "new_text": "b->CreateAdd(lhs, rhs)",
          "old_line_content": "    case HloOpcode::kMultiply:",
          "new_line_content": "        return root_is_integral ? b->CreateAdd(lhs, rhs)",
          "content_same": false
        },
        {
          "line": 1645,
          "old_api": null,
          "new_api": "CreateFAdd",
          "old_text": null,
          "new_text": "b->CreateFAdd(lhs, rhs)",
          "old_line_content": "      return [root_is_integral](llvm::IRBuilder<>* b, llvm::Value* lhs,",
          "new_line_content": "                                : b->CreateFAdd(lhs, rhs);",
          "content_same": false
        },
        {
          "line": 1651,
          "old_api": null,
          "new_api": "CreateMul",
          "old_text": null,
          "new_text": "b->CreateMul(lhs, rhs)",
          "old_line_content": "    case HloOpcode::kAnd:",
          "new_line_content": "        return root_is_integral ? b->CreateMul(lhs, rhs)",
          "content_same": false
        },
        {
          "line": 1652,
          "old_api": null,
          "new_api": "CreateFMul",
          "old_text": null,
          "new_text": "b->CreateFMul(lhs, rhs)",
          "old_line_content": "      return [](llvm::IRBuilder<>* b, llvm::Value* lhs, llvm::Value* rhs) {",
          "new_line_content": "                                : b->CreateFMul(lhs, rhs);",
          "content_same": false
        },
        {
          "line": 1657,
          "old_api": null,
          "new_api": "CreateAnd",
          "old_text": null,
          "new_text": "b->CreateAnd(lhs, rhs)",
          "old_line_content": "      return [](llvm::IRBuilder<>* b, llvm::Value* lhs, llvm::Value* rhs) {",
          "new_line_content": "        return b->CreateAnd(lhs, rhs);",
          "content_same": false
        },
        {
          "line": 1662,
          "old_api": null,
          "new_api": "CreateOr",
          "old_text": null,
          "new_text": "b->CreateOr(lhs, rhs)",
          "old_line_content": "      return [](llvm::IRBuilder<>* b, llvm::Value* lhs, llvm::Value* rhs) {",
          "new_line_content": "        return b->CreateOr(lhs, rhs);",
          "content_same": false
        },
        {
          "line": 1667,
          "old_api": null,
          "new_api": "CreateXor",
          "old_text": null,
          "new_text": "b->CreateXor(lhs, rhs)",
          "old_line_content": "      return [root_is_floating_point, root_is_signed](",
          "new_line_content": "        return b->CreateXor(lhs, rhs);",
          "content_same": false
        },
        {
          "line": 1679,
          "old_api": null,
          "new_api": "CreateSelect",
          "old_text": null,
          "new_text": "b->CreateSelect(\n            b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SGE\n                                         : llvm::ICmpInst::ICMP_UGE,\n                          lhs, rhs),\n            lhs, rhs)",
          "old_line_content": "            lhs, rhs);",
          "new_line_content": "        return b->CreateSelect(",
          "content_same": false
        },
        {
          "line": 1680,
          "old_api": null,
          "new_api": "CreateICmp",
          "old_text": null,
          "new_text": "b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SGE\n                                         : llvm::ICmpInst::ICMP_UGE,\n                          lhs, rhs)",
          "old_line_content": "      };",
          "new_line_content": "            b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SGE",
          "content_same": false
        },
        {
          "line": 1695,
          "old_api": null,
          "new_api": "CreateSelect",
          "old_text": null,
          "new_text": "b->CreateSelect(\n            b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SLE\n                                         : llvm::ICmpInst::ICMP_ULE,\n                          lhs, rhs),\n            lhs, rhs)",
          "old_line_content": "            lhs, rhs);",
          "new_line_content": "        return b->CreateSelect(",
          "content_same": false
        },
        {
          "line": 1696,
          "old_api": null,
          "new_api": "CreateICmp",
          "old_text": null,
          "new_text": "b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SLE\n                                         : llvm::ICmpInst::ICMP_ULE,\n                          lhs, rhs)",
          "old_line_content": "      };",
          "new_line_content": "            b->CreateICmp(root_is_signed ? llvm::ICmpInst::ICMP_SLE",
          "content_same": false
        },
        {
          "line": 1707,
          "old_api": null,
          "new_api": "vector_register_byte_size",
          "old_text": null,
          "new_text": "target_machine_features_.vector_register_byte_size(\n          *compute_function_->function())",
          "old_line_content": "  ShardedVectorType sharded_vector_type;",
          "new_line_content": "      target_machine_features_.vector_register_byte_size(",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": null,
          "new_api": "function",
          "old_text": null,
          "new_text": "compute_function_->function()",
          "old_line_content": "  llvm::Type* element_ir_type =",
          "new_line_content": "          *compute_function_->function()) /",
          "content_same": false
        },
        {
          "line": 1713,
          "old_api": null,
          "new_api": "llvm_ir::PrimitiveTypeToIrType(element_type, module_)",
          "old_text": null,
          "new_text": "llvm_ir::PrimitiveTypeToIrType(element_type, module_)",
          "old_line_content": "    // vector or scalar types.",
          "new_line_content": "      llvm_ir::PrimitiveTypeToIrType(element_type, module_);",
          "content_same": false
        },
        {
          "line": 1715,
          "old_api": null,
          "new_api": "tensorflow::Log2Ceiling(element_count)",
          "old_text": null,
          "new_text": "tensorflow::Log2Ceiling(element_count)",
          "old_line_content": "    if (!(element_count & current_size_fragment)) {",
          "new_line_content": "  for (int i = 0, e = 1 + tensorflow::Log2Ceiling(element_count); i < e; i++) {",
          "content_same": false
        },
        {
          "line": 1726,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "sharded_vector_type.push_back(element_ir_type)",
          "old_line_content": "    // Lower \"current_size_fragment\" number of elements using (as few as",
          "new_line_content": "      sharded_vector_type.push_back(element_ir_type);",
          "content_same": false
        },
        {
          "line": 1734,
          "old_api": null,
          "new_api": "llvm::VectorType::get(\n          element_ir_type, vector_register_size_in_elements)",
          "old_text": null,
          "new_text": "llvm::VectorType::get(\n          element_ir_type, vector_register_size_in_elements)",
          "old_line_content": "          current_size_fragment / vector_register_size_in_elements,",
          "new_line_content": "      auto vector_type = llvm::VectorType::get(",
          "content_same": false
        },
        {
          "line": 1736,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "sharded_vector_type.insert(\n          sharded_vector_type.end(),\n          current_size_fragment / vector_register_size_in_elements,\n          vector_type)",
          "old_line_content": "",
          "new_line_content": "      sharded_vector_type.insert(",
          "content_same": false
        },
        {
          "line": 1737,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "sharded_vector_type.end()",
          "old_line_content": "      // Both current_size_fragment and vector_register_size_in_elements are",
          "new_line_content": "          sharded_vector_type.end(),",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": null,
          "new_api": "CHECK_EQ",
          "old_text": null,
          "new_text": "CHECK_EQ(current_size_fragment % vector_register_size_in_elements, 0)",
          "old_line_content": "    // For now we assume that vector_register_size_in_elements and lower powers",
          "new_line_content": "      CHECK_EQ(current_size_fragment % vector_register_size_in_elements, 0);",
          "content_same": false
        },
        {
          "line": 1750,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "sharded_vector_type.push_back(\n        llvm::VectorType::get(element_ir_type, current_size_fragment))",
          "old_line_content": "}",
          "new_line_content": "    sharded_vector_type.push_back(",
          "content_same": false
        },
        {
          "line": 1751,
          "old_api": null,
          "new_api": "llvm::VectorType::get(element_ir_type, current_size_fragment)",
          "old_text": null,
          "new_text": "llvm::VectorType::get(element_ir_type, current_size_fragment)",
          "old_line_content": "",
          "new_line_content": "        llvm::VectorType::get(element_ir_type, current_size_fragment));",
          "content_same": false
        },
        {
          "line": 1764,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "accumulator_type.size()",
          "old_line_content": "  }",
          "new_line_content": "  accumulator.reserve(accumulator_type.size());",
          "content_same": false
        },
        {
          "line": 1774,
          "old_api": null,
          "new_api": "getType",
          "old_text": null,
          "new_text": "accumulator_shard->getType()->getPointerElementType()",
          "old_line_content": "    } else {",
          "new_line_content": "    auto shard_type = accumulator_shard->getType()->getPointerElementType();",
          "content_same": false
        },
        {
          "line": 1775,
          "old_api": null,
          "new_api": "llvm::dyn_cast<llvm::VectorType>(shard_type)",
          "old_text": null,
          "new_text": "llvm::dyn_cast<llvm::VectorType>(shard_type)",
          "old_line_content": "      initial_value = init_value_ssa;",
          "new_line_content": "    if (auto vector_type = llvm::dyn_cast<llvm::VectorType>(shard_type)) {",
          "content_same": false
        },
        {
          "line": 1777,
          "old_api": null,
          "new_api": "getNumElements",
          "old_text": null,
          "new_text": "vector_type->getNumElements()",
          "old_line_content": "",
          "new_line_content": "          VectorSplat(vector_type->getNumElements(), init_value_ssa);",
          "content_same": false
        },
        {
          "line": 1782,
          "old_api": null,
          "new_api": "AlignedStore",
          "old_text": null,
          "new_text": "AlignedStore(initial_value, accumulator_shard, element_alignment)",
          "old_line_content": "                                           &b_);",
          "new_line_content": "    AlignedStore(initial_value, accumulator_shard, element_alignment);",
          "content_same": false
        },
        {
          "line": 1785,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(arg, \"vectorized_inner\")",
          "old_line_content": "                                                       \"reduction_dim\");",
          "new_line_content": "  llvm_ir::ForLoopNest reduction_loop_nest(IrName(arg, \"vectorized_inner\"),",
          "content_same": false
        },
        {
          "line": 1788,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "arg->shape()",
          "old_line_content": "",
          "new_line_content": "      reduction_loop_nest.AddLoopsForShapeOnDimensions(arg->shape(), dimensions,",
          "content_same": false
        },
        {
          "line": 1791,
          "old_api": null,
          "new_api": "GetInnerLoopBodyBasicBlock",
          "old_text": null,
          "new_text": "reduction_loop_nest.GetInnerLoopBodyBasicBlock()",
          "old_line_content": "",
          "new_line_content": "  SetToFirstInsertPoint(reduction_loop_nest.GetInnerLoopBodyBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 1794,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "output_index.begin()",
          "old_line_content": "      i = *it++;",
          "new_line_content": "  llvm_ir::IrArray::Index::const_iterator it = output_index.begin();",
          "content_same": false
        },
        {
          "line": 1803,
          "old_api": null,
          "new_api": "getInt64Ty",
          "old_text": null,
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "",
          "new_line_content": "                                      b_.getInt64Ty());",
          "content_same": false
        },
        {
          "line": 1805,
          "old_api": null,
          "new_api": "EmitArrayElementAddress",
          "old_text": null,
          "new_text": "BitCast(\n      arg_array.EmitArrayElementAddress(input_index, &b_), b_.getInt8PtrTy())",
          "old_line_content": "    auto input_address_typed =",
          "new_line_content": "  llvm::Value* input_address = BitCast(",
          "content_same": false
        },
        {
          "line": 1812,
          "old_api": null,
          "new_api": "AlignedLoad",
          "old_text": null,
          "new_text": "AlignedLoad(accumulator[i], element_alignment)",
          "old_line_content": "    auto reduced_result =",
          "new_line_content": "        AlignedLoad(accumulator[i], element_alignment);",
          "content_same": false
        },
        {
          "line": 1818,
          "old_api": null,
          "new_api": "AlignedStore",
          "old_text": null,
          "new_text": "AlignedStore(reduced_result, accumulator[i], element_alignment)",
          "old_line_content": "                                           input_address_typed, 1);",
          "new_line_content": "    AlignedStore(reduced_result, accumulator[i], element_alignment);",
          "content_same": false
        },
        {
          "line": 1820,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "accumulator.size()",
          "old_line_content": "  }",
          "new_line_content": "    if (i != (accumulator.size() - 1)) {",
          "content_same": false
        },
        {
          "line": 1821,
          "old_api": null,
          "new_api": "getType",
          "old_text": null,
          "new_text": "reduced_result->getType()",
          "old_line_content": "",
          "new_line_content": "      input_address = ConstInBoundsGEP1_32(reduced_result->getType(),",
          "content_same": false
        },
        {
          "line": 1826,
          "old_api": null,
          "new_api": "GetOuterLoopExitBasicBlock",
          "old_text": null,
          "new_text": "reduction_loop_nest.GetOuterLoopExitBasicBlock()",
          "old_line_content": "  for (auto accumulator_shard : accumulator) {",
          "new_line_content": "  SetToFirstInsertPoint(reduction_loop_nest.GetOuterLoopExitBasicBlock(), &b_);",
          "content_same": false
        },
        {
          "line": 1829,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "accumulator.size()",
          "old_line_content": "  return result_ssa;",
          "new_line_content": "  result_ssa.reserve(accumulator.size());",
          "content_same": false
        },
        {
          "line": 1831,
          "old_api": null,
          "new_api": "AlignedLoad",
          "old_text": null,
          "new_text": "AlignedLoad(accumulator_shard, element_alignment)",
          "old_line_content": "",
          "new_line_content": "    result_ssa.push_back(AlignedLoad(accumulator_shard, element_alignment));",
          "content_same": false
        },
        {
          "line": 1839,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "value_to_store.size()",
          "old_line_content": "",
          "new_line_content": "  for (int i = 0; i < value_to_store.size(); i++) {",
          "content_same": false
        },
        {
          "line": 1849,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "value_to_store.size()",
          "old_line_content": "  }",
          "new_line_content": "    if (i != (value_to_store.size() - 1)) {",
          "content_same": false
        },
        {
          "line": 1850,
          "old_api": null,
          "new_api": "getType",
          "old_text": null,
          "new_text": "value_to_store[i]->getType()",
          "old_line_content": "}",
          "new_line_content": "      store_address = ConstInBoundsGEP1_32(value_to_store[i]->getType(),",
          "content_same": false
        },
        {
          "line": 1860,
          "old_api": null,
          "new_api": "IsArray",
          "old_text": null,
          "new_text": "reduce->shape().IsArray()",
          "old_line_content": "",
          "new_line_content": "  if (!reduce->shape().IsArray()) {",
          "content_same": false
        },
        {
          "line": 1865,
          "old_api": null,
          "new_api": "ReductionPreservesLayout",
          "old_text": null,
          "new_text": "ReductionPreservesLayout(*reduce)",
          "old_line_content": "  ReductionGenerator reduction_generator =",
          "new_line_content": "  if (!ReductionPreservesLayout(*reduce)) {",
          "content_same": false
        },
        {
          "line": 1870,
          "old_api": null,
          "new_api": "MatchReductionGenerator",
          "old_text": null,
          "new_text": "MatchReductionGenerator(function, failure_reason)",
          "old_line_content": "",
          "new_line_content": "      MatchReductionGenerator(function, failure_reason);",
          "content_same": false
        },
        {
          "line": 1876,
          "old_api": null,
          "new_api": "vector_register_byte_size",
          "old_text": null,
          "new_text": "target_machine_features_.vector_register_byte_size(\n          *compute_function_->function())",
          "old_line_content": "    // Either we don't know the vector register width for the target or the",
          "new_line_content": "      target_machine_features_.vector_register_byte_size(",
          "content_same": false
        },
        {
          "line": 1877,
          "old_api": null,
          "new_api": "function",
          "old_text": null,
          "new_text": "compute_function_->function()",
          "old_line_content": "    // vector register is smaller than the size of the primitive type.",
          "new_line_content": "          *compute_function_->function()) /",
          "content_same": false
        },
        {
          "line": 1878,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "reduce->shape().element_type()",
          "old_line_content": "    return false;",
          "new_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(reduce->shape().element_type());",
          "content_same": false
        },
        {
          "line": 1886,
          "old_api": null,
          "new_api": "vectorization_factor_in_bytes",
          "old_text": null,
          "new_text": "target_machine_features_.vectorization_factor_in_bytes()",
          "old_line_content": "      vectorization_factor_in_bytes /",
          "new_line_content": "      target_machine_features_.vectorization_factor_in_bytes();",
          "content_same": false
        },
        {
          "line": 1891,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "reduce->shape().element_type()",
          "old_line_content": "",
          "new_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(reduce->shape().element_type());",
          "content_same": false
        },
        {
          "line": 1896,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "tensorflow::MathUtil::GCD<unsigned>(\n      ShapeUtil::ByteSizeOfPrimitiveType(reduce->shape().element_type()),\n      MinimumAlignmentForPrimitiveType(reduce->shape().element_type()))",
          "old_line_content": "  if (is_reduction_over_minor_dimension) {",
          "new_line_content": "  unsigned element_alignment = tensorflow::MathUtil::GCD<unsigned>(",
          "content_same": false
        },
        {
          "line": 1897,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "reduce->shape().element_type()",
          "old_line_content": "    // TODO(sanjoy): Implement vectorized reduction over the minor dimension.",
          "new_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(reduce->shape().element_type()),",
          "content_same": false
        },
        {
          "line": 1898,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "reduce->shape().element_type()",
          "old_line_content": "    *failure_reason = \"reduction over minor dimension not implemented\";",
          "new_line_content": "      MinimumAlignmentForPrimitiveType(reduce->shape().element_type()));",
          "content_same": false
        },
        {
          "line": 1906,
          "old_api": null,
          "new_api": "IsTuple",
          "old_text": null,
          "new_text": "reduce->shape().IsTuple()",
          "old_line_content": "  // can lower the reduction loop as:",
          "new_line_content": "  CHECK(!reduce->shape().IsTuple());",
          "content_same": false
        },
        {
          "line": 1907,
          "old_api": null,
          "new_api": "EmitTargetAddressForOp",
          "old_text": null,
          "new_text": "EmitTargetAddressForOp(reduce)",
          "old_line_content": "  //",
          "new_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(reduce));",
          "content_same": false
        },
        {
          "line": 1929,
          "old_api": null,
          "new_api": "IrName",
          "old_text": null,
          "new_text": "IrName(reduce)",
          "old_line_content": "       --i) {",
          "new_line_content": "  llvm_ir::ForLoopNest loop_nest(IrName(reduce), &b_);",
          "content_same": false
        },
        {
          "line": 1931,
          "old_api": null,
          "new_api": "dimensions_size",
          "old_text": null,
          "new_text": "reduce->shape().dimensions_size()",
          "old_line_content": "    int64 start_index = 0;",
          "new_line_content": "      reduce->shape().dimensions_size());",
          "content_same": false
        },
        {
          "line": 1936,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "reduce->shape().dimensions(dimension)",
          "old_line_content": "  }",
          "new_line_content": "    int64 end_index = reduce->shape().dimensions(dimension);",
          "content_same": false
        },
        {
          "line": 1937,
          "old_api": null,
          "new_api": "AddLoop",
          "old_text": null,
          "new_text": "loop_nest.AddLoop(\n        start_index, end_index, absl::StrFormat(\"dim.%d\", dimension))",
          "old_line_content": "",
          "new_line_content": "    std::unique_ptr<llvm_ir::ForLoop> loop = loop_nest.AddLoop(",
          "content_same": false
        },
        {
          "line": 1939,
          "old_api": null,
          "new_api": "GetIndVarValue",
          "old_text": null,
          "new_text": "loop->GetIndVarValue()",
          "old_line_content": "  int64 innermost_dimension_size =",
          "new_line_content": "    array_multi_index[dimension] = loop->GetIndVarValue();",
          "content_same": false
        },
        {
          "line": 1942,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "reduce->shape().layout()",
          "old_line_content": "  if (llvm::BasicBlock* innermost_body_bb =",
          "new_line_content": "  int64 innermost_dimension = LayoutUtil::Minor(reduce->shape().layout(), 0);",
          "content_same": false
        },
        {
          "line": 1948,
          "old_api": null,
          "new_api": "SetToFirstInsertPoint",
          "old_text": null,
          "new_text": "SetToFirstInsertPoint(innermost_body_bb, &b_)",
          "old_line_content": "",
          "new_line_content": "    SetToFirstInsertPoint(innermost_body_bb, &b_);",
          "content_same": false
        },
        {
          "line": 1951,
          "old_api": null,
          "new_api": "GetOuterLoopExitBasicBlock",
          "old_text": null,
          "new_text": "loop_nest.GetOuterLoopExitBasicBlock()",
          "old_line_content": "    int64 end_index = (innermost_dimension_size / vectorization_factor) *",
          "new_line_content": "  auto outermost_loop_exit_block = loop_nest.GetOuterLoopExitBasicBlock();",
          "content_same": false
        },
        {
          "line": 1959,
          "old_api": null,
          "new_api": "absl::StrFormat(\"dim.%d\", innermost_dimension)",
          "old_text": null,
          "new_text": "absl::StrFormat(\"dim.%d\", innermost_dimension)",
          "old_line_content": "",
          "new_line_content": "                          absl::StrFormat(\"dim.%d\", innermost_dimension));",
          "content_same": false
        },
        {
          "line": 1964,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "CreateShardedVectorType(\n        reduce->shape().element_type(), vectorization_factor)",
          "old_line_content": "    TF_ASSIGN_OR_RETURN(std::vector<llvm::Value*> accumulator,",
          "new_line_content": "    ShardedVectorType vector_type = CreateShardedVectorType(",
          "content_same": false
        },
        {
          "line": 1965,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "reduce->shape().element_type()",
          "old_line_content": "                        EmitInnerLoopForVectorizedReduction(",
          "new_line_content": "        reduce->shape().element_type(), vectorization_factor);",
          "content_same": false
        },
        {
          "line": 1966,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "reduce->shape()",
          "old_line_content": "                            reduction_generator, array_index, vector_type,",
          "new_line_content": "    llvm_ir::IrArray::Index array_index(array_multi_index, reduce->shape(),",
          "content_same": false
        },
        {
          "line": 1967,
          "old_api": null,
          "new_api": "getInt64Ty",
          "old_text": null,
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "                            init_value, arg, dimensions, element_alignment));",
          "new_line_content": "                                        b_.getInt64Ty());",
          "content_same": false
        },
        {
          "line": 1973,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(reduce)",
          "old_line_content": "                           target_array);",
          "new_line_content": "    llvm_ir::IrArray target_array = GetIrArrayFor(reduce);",
          "content_same": false
        },
        {
          "line": 1981,
          "old_api": null,
          "new_api": "SetInsertPoint",
          "old_text": null,
          "new_text": "b_.SetInsertPoint(exit_terminator)",
          "old_line_content": "    }",
          "new_line_content": "      b_.SetInsertPoint(exit_terminator);",
          "content_same": false
        },
        {
          "line": 1983,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "reduce->shape()",
          "old_line_content": "",
          "new_line_content": "      CHECK_EQ(LayoutUtil::MinorToMajor(reduce->shape()).size(), 1);",
          "content_same": false
        },
        {
          "line": 1984,
          "old_api": null,
          "new_api": "GetExitBasicBlock",
          "old_text": null,
          "new_text": "loop->GetExitBasicBlock()",
          "old_line_content": "  // Since we increment the stride for the inner dimension by more than 1, we",
          "new_line_content": "      b_.SetInsertPoint(loop->GetExitBasicBlock());",
          "content_same": false
        },
        {
          "line": 1998,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "reduce->shape().element_type()",
          "old_line_content": "    TF_ASSIGN_OR_RETURN(std::vector<llvm::Value*> accumulator,",
          "new_line_content": "        reduce->shape().element_type(),",
          "content_same": false
        },
        {
          "line": 2000,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "reduce->shape()",
          "old_line_content": "                            reduction_generator, array_index, vector_type,",
          "new_line_content": "    llvm_ir::IrArray::Index array_index(array_multi_index, reduce->shape(),",
          "content_same": false
        },
        {
          "line": 2001,
          "old_api": null,
          "new_api": "getInt64Ty",
          "old_text": null,
          "new_text": "b_.getInt64Ty()",
          "old_line_content": "                            init_value, arg, dimensions, element_alignment));",
          "new_line_content": "                                        b_.getInt64Ty());",
          "content_same": false
        },
        {
          "line": 2007,
          "old_api": null,
          "new_api": "GetIrArrayFor",
          "old_text": null,
          "new_text": "GetIrArrayFor(reduce)",
          "old_line_content": "                           target_array);",
          "new_line_content": "    llvm_ir::IrArray target_array = GetIrArrayFor(reduce);",
          "content_same": false
        },
        {
          "line": 2009,
          "old_api": null,
          "new_api": "EmitArrayElementAddress",
          "old_text": null,
          "new_text": "target_array.EmitArrayElementAddress(array_index, &b_)",
          "old_line_content": "",
          "new_line_content": "        target_array.EmitArrayElementAddress(array_index, &b_);",
          "content_same": false
        },
        {
          "line": 2010,
          "old_api": null,
          "new_api": "EmitShardedVectorStore",
          "old_text": null,
          "new_text": "EmitShardedVectorStore(output_address, accumulator, element_alignment,\n                           target_array)",
          "old_line_content": "  if (outermost_loop_exit_block) {",
          "new_line_content": "    EmitShardedVectorStore(output_address, accumulator, element_alignment,",
          "content_same": false
        },
        {
          "line": 2015,
          "old_api": null,
          "new_api": "SetInsertPoint",
          "old_text": null,
          "new_text": "b_.SetInsertPoint(outermost_loop_exit_block)",
          "old_line_content": "}",
          "new_line_content": "    b_.SetInsertPoint(outermost_loop_exit_block);",
          "content_same": false
        },
        {
          "line": 2031,
          "old_api": null,
          "new_api": "tuple_shapes_size",
          "old_text": null,
          "new_text": "out_shape.tuple_shapes_size()",
          "old_line_content": "",
          "new_line_content": "    accumulators_count = out_shape.tuple_shapes_size();",
          "content_same": false
        },
        {
          "line": 2034,
          "old_api": null,
          "new_api": "dimensions",
          "old_text": null,
          "new_text": "reduce->dimensions()",
          "old_line_content": "  for (int i = 0; i < accumulators_count; i++) {",
          "new_line_content": "  absl::Span<const int64> reduced_dimensions(reduce->dimensions());",
          "content_same": false
        },
        {
          "line": 2041,
          "old_api": null,
          "new_api": "element_type",
          "old_text": null,
          "new_text": "element_shape.element_type()",
          "old_line_content": "",
          "new_line_content": "    PrimitiveType accumulator_type = element_shape.element_type();",
          "content_same": false
        },
        {
          "line": 2047,
          "old_api": null,
          "new_api": "llvm_ir::EmitAllocaAtFunctionEntry(\n        accumulator_llvm_type, \"accumulator_\" + std::to_string(i), &b_,\n        MinimumAlignmentForPrimitiveType(accumulator_type))",
          "old_text": null,
          "new_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n        accumulator_llvm_type, \"accumulator_\" + std::to_string(i), &b_,\n        MinimumAlignmentForPrimitiveType(accumulator_type))",
          "old_line_content": "        llvm::Value* const init_value,",
          "new_line_content": "    llvm::AllocaInst* accumulator_addr = llvm_ir::EmitAllocaAtFunctionEntry(",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2050,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "accumulator_addrs.push_back(accumulator_addr)",
          "new_text": null,
          "old_line_content": "    accumulator_addrs.push_back(accumulator_addr);",
          "new_line_content": "    TF_ASSIGN_OR_RETURN(",
          "content_same": false
        },
        {
          "line": 2058,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(reduce, \"inner\")",
          "new_text": null,
          "old_line_content": "  llvm_ir::ForLoopNest loops(IrName(reduce, \"inner\"), &b_);",
          "new_line_content": "  // the actual target element. For this, we build a new loop nest to iterate",
          "content_same": false
        },
        {
          "line": 2059,
          "old_api": "operand",
          "new_api": null,
          "old_text": "reduce->operand(0)",
          "new_text": null,
          "old_line_content": "  const HloInstruction* arg = reduce->operand(0);",
          "new_line_content": "  // over all the reduction dimensions in the argument.",
          "content_same": false
        },
        {
          "line": 2061,
          "old_api": "shape",
          "new_api": null,
          "old_text": "arg->shape()",
          "new_text": null,
          "old_line_content": "      loops.AddLoopsForShapeOnDimensions(arg->shape(), reduced_dimensions,",
          "new_line_content": "  // are placed for each dimension in dimensions, and all the rest are nullptrs.",
          "content_same": false
        },
        {
          "line": 2064,
          "old_api": "GetInnerLoopBodyBasicBlock",
          "new_api": null,
          "old_text": "loops.GetInnerLoopBodyBasicBlock()",
          "new_text": null,
          "old_line_content": "  SetToFirstInsertPoint(loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "new_line_content": "  std::vector<llvm::Value*> input_multi_index =",
          "content_same": false
        },
        {
          "line": 2071,
          "old_api": "begin",
          "new_api": null,
          "old_text": "index.begin()",
          "new_text": null,
          "old_line_content": "  llvm_ir::IrArray::Index::const_iterator it = index.begin();",
          "new_line_content": "  // base. In input_multi_index only the reduction dimensions are filled in. We",
          "content_same": false
        },
        {
          "line": 2078,
          "old_api": "end",
          "new_api": null,
          "old_text": "index.end()",
          "new_text": null,
          "old_line_content": "  CHECK(index.end() == it);",
          "new_line_content": "    if (i == nullptr) {",
          "content_same": false
        },
        {
          "line": 2079,
          "old_api": "shape",
          "new_api": null,
          "old_text": "arg->shape()",
          "new_text": null,
          "old_line_content": "  llvm_ir::IrArray::Index input_index(input_multi_index, arg->shape(),",
          "new_line_content": "      i = *it++;",
          "content_same": false
        },
        {
          "line": 2080,
          "old_api": "getInt64Ty",
          "new_api": null,
          "old_text": "b_.getInt64Ty()",
          "new_text": null,
          "old_line_content": "                                      b_.getInt64Ty());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2085,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "reduction_operands.push_back(accum_value)",
          "new_text": null,
          "old_line_content": "    reduction_operands.push_back(accum_value);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2091,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "reduction_operands.push_back(input_element)",
          "new_text": null,
          "old_line_content": "    reduction_operands.push_back(input_element);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2094,
          "old_api": "to_apply",
          "new_api": null,
          "old_text": "EmitThreadLocalCall(\n      *reduce->to_apply(), reduction_operands, \"reduce_function\")",
          "new_text": null,
          "old_line_content": "  std::vector<llvm::Value*> results = EmitThreadLocalCall(",
          "new_line_content": "                        input_generators[i](input_index));",
          "content_same": false
        },
        {
          "line": 2097,
          "old_api": "size",
          "new_api": null,
          "old_text": "results.size()",
          "new_text": null,
          "old_line_content": "  CHECK(results.size() == accumulators_count);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2106,
          "old_api": "getContext",
          "new_api": null,
          "old_text": "b_.getContext()",
          "new_text": null,
          "old_line_content": "        llvm::StructType::get(b_.getContext(), accumulator_types));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2108,
          "old_api": "Load",
          "new_api": null,
          "old_text": "Load(accumulator_addrs[i])",
          "new_text": null,
          "old_line_content": "      llvm::Value* accumulator_value = Load(accumulator_addrs[i]);",
          "new_line_content": "    // Emit a structure, as that what the LoopEmitter expects.",
          "content_same": false
        },
        {
          "line": 2115,
          "old_api": "Load",
          "new_api": null,
          "old_text": "Load(accumulator_addrs[0])",
          "new_text": null,
          "old_line_content": "    return Load(accumulator_addrs[0]);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2120,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "reduce->mutable_operand(0)",
          "new_text": null,
          "old_line_content": "  auto arg = reduce->mutable_operand(0);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2121,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "reduce->mutable_operand(1)",
          "new_text": null,
          "old_line_content": "  auto init_value = reduce->mutable_operand(1);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2122,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "reduce->dimensions()",
          "new_text": null,
          "old_line_content": "  absl::Span<const int64> dimensions(reduce->dimensions());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2123,
          "old_api": "to_apply",
          "new_api": null,
          "old_text": "reduce->to_apply()",
          "new_text": null,
          "old_line_content": "  HloComputation* function = reduce->to_apply();",
          "new_line_content": "Status IrEmitter::HandleReduce(HloInstruction* reduce) {",
          "content_same": false
        },
        {
          "line": 2131,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "reduce->ToString()",
          "new_text": null,
          "old_line_content": "      VLOG(1) << \"Successfully vectorized reduction \" << reduce->ToString()",
          "new_line_content": "        bool vectorization_successful,",
          "content_same": false
        },
        {
          "line": 2133,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "      return Status::OK();",
          "new_line_content": "                             &vectorization_failure_reason));",
          "content_same": false
        },
        {
          "line": 2140,
          "old_api": "DefaultAction",
          "new_api": null,
          "old_text": "DefaultAction(reduce)",
          "new_text": null,
          "old_line_content": "  return DefaultAction(reduce);",
          "new_line_content": "              << vectorization_failure_reason;",
          "content_same": false
        },
        {
          "line": 2149,
          "old_api": "Unimplemented",
          "new_api": null,
          "old_text": "Unimplemented(\"Send is not implemented on CPU.\")",
          "new_text": null,
          "old_line_content": "  return Unimplemented(\"Send is not implemented on CPU.\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2154,
          "old_api": "Unimplemented",
          "new_api": null,
          "old_text": "Unimplemented(\"Send-done is not implemented on CPU.\")",
          "new_text": null,
          "old_line_content": "  return Unimplemented(\"Send-done is not implemented on CPU.\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2163,
          "old_api": "operand",
          "new_api": null,
          "old_text": "slice->operand(0)",
          "new_text": null,
          "old_line_content": "  auto operand = slice->operand(0);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2172,
          "old_api": "DefaultAction",
          "new_api": null,
          "old_text": "DefaultAction(slice)",
          "new_text": null,
          "old_line_content": "    return DefaultAction(slice);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2177,
          "old_api": "shape",
          "new_api": null,
          "old_text": "slice->shape()",
          "new_text": null,
          "old_line_content": "  if (ShapeUtil::IsZeroElementArray(slice->shape())) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2178,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "    return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2197,
          "old_api": "LayoutUtil::MinorToMajor(layout)",
          "new_api": null,
          "old_text": "LayoutUtil::MinorToMajor(layout)",
          "new_text": null,
          "old_line_content": "  for (int64 dim : LayoutUtil::MinorToMajor(layout)) {",
          "new_line_content": "  //",
          "content_same": false
        },
        {
          "line": 2198,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "slice->shape().dimensions(dim)",
          "new_text": null,
          "old_line_content": "    if (operand->shape().dimensions(dim) != slice->shape().dimensions(dim)) {",
          "new_line_content": "  // * Implement the memcpy within the innermost loop.",
          "content_same": false
        },
        {
          "line": 2204,
          "old_api": "size",
          "new_api": null,
          "old_text": "inner_dims.size()",
          "new_text": null,
          "old_line_content": "  const bool is_trivial_copy = (inner_dims.size() == num_dims);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2206,
          "old_api": "shape",
          "new_api": null,
          "old_text": "slice->shape()",
          "new_text": null,
          "old_line_content": "    if (ShapeUtil::IsEffectiveScalar(slice->shape())) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2207,
          "old_api": "DefaultAction",
          "new_api": null,
          "old_text": "DefaultAction(slice)",
          "new_text": null,
          "old_line_content": "      return DefaultAction(slice);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2209,
          "old_api": "EmitMemcpy",
          "new_api": null,
          "old_text": "EmitMemcpy(*slice, *operand)",
          "new_text": null,
          "old_line_content": "      return EmitMemcpy(*slice, *operand);",
          "new_line_content": "  if (is_trivial_copy) {",
          "content_same": false
        },
        {
          "line": 2215,
          "old_api": "contains",
          "new_api": null,
          "old_text": "ShapeUtil::FilterDimensions(\n      [&inner_dims](int64 dim) { return inner_dims.contains(dim); },\n      operand->shape())",
          "new_text": null,
          "old_line_content": "  const Shape logical_element_shape = ShapeUtil::FilterDimensions(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2216,
          "old_api": "contains",
          "new_api": null,
          "old_text": "inner_dims.contains(dim)",
          "new_text": null,
          "old_line_content": "      [&inner_dims](int64 dim) { return inner_dims.contains(dim); },",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2217,
          "old_api": "shape",
          "new_api": null,
          "old_text": "operand->shape()",
          "new_text": null,
          "old_line_content": "      operand->shape());",
          "new_line_content": "  // The memcpy will copy elements that are logically this shape (allowed to be",
          "content_same": false
        },
        {
          "line": 2226,
          "old_api": "slice_strides",
          "new_api": null,
          "old_text": "slice->slice_strides(memcpy_dim)",
          "new_text": null,
          "old_line_content": "  const bool memcpy_is_contiguous = slice->slice_strides(memcpy_dim) == 1;",
          "new_line_content": "  // memcpy_dim is the innermost (in terms of layout) dimension for which the",
          "content_same": false
        },
        {
          "line": 2232,
          "old_api": "slice_starts",
          "new_api": null,
          "old_text": "slice->slice_starts(memcpy_dim)",
          "new_text": null,
          "old_line_content": "          ? slice->slice_limits(memcpy_dim) - slice->slice_starts(memcpy_dim)",
          "new_line_content": "  // to memcpy. We can only copy 1 element at a time if there is a non-trivial",
          "content_same": false
        },
        {
          "line": 2237,
          "old_api": "size",
          "new_api": null,
          "old_text": "inner_dims.size()",
          "new_text": null,
          "old_line_content": "  for (int64 i = 0; i < num_dims - inner_dims.size() - 1; ++i) {",
          "new_line_content": "          : 1;",
          "content_same": false
        },
        {
          "line": 2238,
          "old_api": "LayoutUtil::Major(layout, i)",
          "new_api": null,
          "old_text": "LayoutUtil::Major(layout, i)",
          "new_text": null,
          "old_line_content": "    outer_dims.push_back(LayoutUtil::Major(layout, i));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2244,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "outer_dims.push_back(memcpy_dim)",
          "new_text": null,
          "old_line_content": "    outer_dims.push_back(memcpy_dim);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2247,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(slice)",
          "new_text": null,
          "old_line_content": "  llvm_ir::IrArray target_array = GetIrArrayFor(slice);",
          "new_line_content": "  if (!memcpy_is_contiguous) {",
          "content_same": false
        },
        {
          "line": 2249,
          "old_api": "size",
          "new_api": null,
          "old_text": "outer_dims.size()",
          "new_text": null,
          "old_line_content": "  const int64 num_outer_loops = outer_dims.size();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2250,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(slice)",
          "new_text": null,
          "old_line_content": "  llvm_ir::ForLoopNest loops(IrName(slice), &b_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2252,
          "old_api": "shape",
          "new_api": null,
          "old_text": "slice->shape()",
          "new_text": null,
          "old_line_content": "      loops.AddLoopsForShapeOnDimensions(slice->shape(), outer_dims, \"slice\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2257,
          "old_api": "end",
          "new_api": null,
          "old_text": "target_multi_index.end()",
          "new_text": null,
          "old_line_content": "  std::replace(target_multi_index.begin(), target_multi_index.end(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2258,
          "old_api": "static_cast<llvm::Value*>(nullptr)",
          "new_api": null,
          "old_text": "static_cast<llvm::Value*>(nullptr)",
          "new_text": null,
          "old_line_content": "               static_cast<llvm::Value*>(nullptr),",
          "new_line_content": "  // Only the indices for the outer dimensions have been initialized in",
          "content_same": false
        },
        {
          "line": 2259,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "b_.getInt64(0)",
          "new_text": null,
          "old_line_content": "               static_cast<llvm::Value*>(b_.getInt64(0)));",
          "new_line_content": "  // target_index. The rest of the indices should get initialized to 0, since",
          "content_same": false
        },
        {
          "line": 2260,
          "old_api": "shape",
          "new_api": null,
          "old_text": "slice->shape()",
          "new_text": null,
          "old_line_content": "  llvm_ir::IrArray::Index target_index(target_multi_index, slice->shape(),",
          "new_line_content": "  // for the rest of the dimensions the copy writes to the full dimension.",
          "content_same": false
        },
        {
          "line": 2267,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(operand)",
          "new_text": null,
          "old_line_content": "  llvm_ir::IrArray source_array = GetIrArrayFor(operand);",
          "new_line_content": "  if (num_outer_loops > 0) {",
          "content_same": false
        },
        {
          "line": 2269,
          "old_api": "slice_starts",
          "new_api": null,
          "old_text": "slice->slice_starts()",
          "new_text": null,
          "old_line_content": "      /*operand_shape=*/operand->shape(), /*starts=*/slice->slice_starts(),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2270,
          "old_api": "slice_strides",
          "new_api": null,
          "old_text": "slice->slice_strides()",
          "new_text": null,
          "old_line_content": "      /*strides=*/slice->slice_strides(), /*builder=*/&b_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2275,
          "old_api": "EmitArrayElementAddress",
          "new_api": null,
          "old_text": "source_array.EmitArrayElementAddress(source_index, &b_, \"slice.source\")",
          "new_text": null,
          "old_line_content": "      source_array.EmitArrayElementAddress(source_index, &b_, \"slice.source\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2280,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "EmitTransferElements(memcpy_dest, memcpy_source, memcpy_elements,\n                       slice->shape().element_type(), target_array,\n                       source_array)",
          "new_text": null,
          "old_line_content": "  EmitTransferElements(memcpy_dest, memcpy_source, memcpy_elements,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2281,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "slice->shape().element_type()",
          "new_text": null,
          "old_line_content": "                       slice->shape().element_type(), target_array,",
          "new_line_content": "  const int64 memcpy_elements =",
          "content_same": false
        },
        {
          "line": 2286,
          "old_api": "ShapeUtil::ByteSizeOf(logical_element_shape)",
          "new_api": null,
          "old_text": "ShapeUtil::ByteSizeOf(logical_element_shape)",
          "new_text": null,
          "old_line_content": "        ShapeUtil::ByteSizeOf(logical_element_shape) * memcpy_elements;",
          "new_line_content": "                       source_array);",
          "content_same": false
        },
        {
          "line": 2287,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(2)",
          "new_text": null,
          "old_line_content": "    VLOG(2) << \"  emitted copy of \" << memcpy_bytes << \" bytes inside \"",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2292,
          "old_api": "GetOuterLoopExitBasicBlock",
          "new_api": null,
          "old_text": "loops.GetOuterLoopExitBasicBlock()",
          "new_text": null,
          "old_line_content": "    SetToFirstInsertPoint(loops.GetOuterLoopExitBasicBlock(), &b_);",
          "new_line_content": "            << num_outer_loops << \" loops\";",
          "content_same": false
        },
        {
          "line": 2295,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  if (num_outer_loops > 0) {",
          "content_same": false
        },
        {
          "line": 2300,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(dynamic_slice)",
          "new_text": null,
          "old_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(dynamic_slice));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2301,
          "old_api": "operand",
          "new_api": null,
          "old_text": "dynamic_slice->operand(0)",
          "new_text": null,
          "old_line_content": "    return EmitMemcpy(*dynamic_slice->operand(0), *dynamic_slice);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2308,
          "old_api": "operand",
          "new_api": null,
          "old_text": "dynamic_update_slice->operand(1)",
          "new_text": null,
          "old_line_content": "  auto update = dynamic_update_slice->operand(1);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2309,
          "old_api": "shape",
          "new_api": null,
          "old_text": "dynamic_update_slice->shape()",
          "new_text": null,
          "old_line_content": "  if (ShapeUtil::IsScalar(dynamic_update_slice->shape())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2310,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(dynamic_update_slice)",
          "new_text": null,
          "old_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(dynamic_update_slice));",
          "new_line_content": "Status IrEmitter::HandleDynamicUpdateSlice(",
          "content_same": false
        },
        {
          "line": 2311,
          "old_api": "EmitMemcpy",
          "new_api": null,
          "old_text": "EmitMemcpy(*update, *dynamic_update_slice)",
          "new_text": null,
          "old_line_content": "    return EmitMemcpy(*update, *dynamic_update_slice);",
          "new_line_content": "    HloInstruction* dynamic_update_slice) {",
          "content_same": false
        },
        {
          "line": 2317,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(dynamic_update_slice)",
          "new_text": null,
          "old_line_content": "        operands, GetIrArrayFor(dynamic_update_slice),",
          "new_line_content": "                                                   assignment_)) {",
          "content_same": false
        },
        {
          "line": 2325,
          "old_api": "Unimplemented",
          "new_api": null,
          "old_text": "Unimplemented(\"Recv is not implemented on CPU.\")",
          "new_text": null,
          "old_line_content": "  return Unimplemented(\"Recv is not implemented on CPU.\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2330,
          "old_api": "Unimplemented",
          "new_api": null,
          "old_text": "Unimplemented(\"Recv-done is not implemented on CPU.\")",
          "new_text": null,
          "old_line_content": "  return Unimplemented(\"Recv-done is not implemented on CPU.\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": "IsArray",
          "new_api": null,
          "old_text": "copy->shape().IsArray()",
          "new_text": null,
          "old_line_content": "  } else if (copy->shape().IsArray()) {",
          "new_line_content": "    // If the layouts are equal this is just a memcpy. kCopy shallow copies a",
          "content_same": false
        },
        {
          "line": 2336,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "pad->padding_config().dimensions()",
          "new_text": null,
          "old_line_content": "  for (auto& padding_dimension : pad->padding_config().dimensions()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2337,
          "old_api": "edge_padding_low",
          "new_api": null,
          "old_text": "padding_dimension.edge_padding_low()",
          "new_text": null,
          "old_line_content": "    if (padding_dimension.edge_padding_low() < 0 ||",
          "new_line_content": "Status IrEmitter::HandlePad(HloInstruction* pad) {",
          "content_same": false
        },
        {
          "line": 290,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "copy->shape().element_type()",
          "new_text": null,
          "old_line_content": "                       PrimitiveType_Name(copy->shape().element_type()));",
          "new_line_content": "    // Use the elemental emitter for array shapes.",
          "content_same": false
        },
        {
          "line": 2338,
          "old_api": "edge_padding_high",
          "new_api": null,
          "old_text": "padding_dimension.edge_padding_high()",
          "new_text": null,
          "old_line_content": "        padding_dimension.edge_padding_high() < 0) {",
          "new_line_content": "  // CPU backend does not properly handle negative padding but this is ok",
          "content_same": false
        },
        {
          "line": 2339,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "InternalErrorStrCat(\n          \"Encountered negative padding in IrEmitter on CPU. \"\n          \"This should have been eliminated at the HLO level. \",\n          pad->ToString())",
          "new_text": null,
          "old_line_content": "      return InternalErrorStrCat(",
          "new_line_content": "  // because negative padding should be removed by the algebraic simplifier.",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "new_api": null,
          "old_text": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "new_text": null,
          "old_line_content": "  int64 byte_size = ShapeUtil::ByteSizeOfPrimitiveType(primitive_type);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": "DCHECK_GE",
          "new_api": null,
          "old_text": "DCHECK_GE(byte_size, 0)",
          "new_text": null,
          "old_line_content": "  DCHECK_GE(byte_size, 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2347,
          "old_api": "operand",
          "new_api": null,
          "old_text": "EmitTargetElementLoop(\n      pad, \"initialize\",\n      [this, pad](const llvm_ir::IrArray::Index& target_index) {\n        const HloInstruction* padding_value = pad->operand(1);\n        llvm::Value* padding_value_addr = GetEmittedValueFor(padding_value);\n        return Load(padding_value_addr);\n      })",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetElementLoop(",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": "std::min(int64{8}, byte_size)",
          "new_api": null,
          "old_text": "std::min(int64{8}, byte_size)",
          "new_text": null,
          "old_line_content": "  return std::min(int64{8}, byte_size);",
          "new_line_content": "  // int64->int truncation here.",
          "content_same": false
        },
        {
          "line": 2350,
          "old_api": "operand",
          "new_api": null,
          "old_text": "pad->operand(1)",
          "new_text": null,
          "old_line_content": "        const HloInstruction* padding_value = pad->operand(1);",
          "new_line_content": "  // First, fill in the padding value to all output elements.",
          "content_same": false
        },
        {
          "line": 2352,
          "old_api": "Load",
          "new_api": null,
          "old_text": "Load(padding_value_addr)",
          "new_text": null,
          "old_line_content": "        return Load(padding_value_addr);",
          "new_line_content": "      pad, \"initialize\",",
          "content_same": false
        },
        {
          "line": 2357,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(pad, \"assign\")",
          "new_text": null,
          "old_line_content": "  llvm_ir::ForLoopNest loops(IrName(pad, \"assign\"), &b_);",
          "new_line_content": "      }));",
          "content_same": false
        },
        {
          "line": 2358,
          "old_api": "operand",
          "new_api": null,
          "old_text": "pad->operand(0)",
          "new_text": null,
          "old_line_content": "  const HloInstruction* operand = pad->operand(0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 311,
          "old_api": "ShapeUtil::IsScalar(shape)",
          "new_api": null,
          "old_text": "ShapeUtil::IsScalar(shape)",
          "new_text": null,
          "old_line_content": "  if (ShapeUtil::IsScalar(shape)) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "shape.element_type()",
          "new_text": null,
          "old_line_content": "    return MinimumAlignmentForPrimitiveType(shape.element_type());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2360,
          "old_api": "shape",
          "new_api": null,
          "old_text": "operand->shape()",
          "new_text": null,
          "old_line_content": "      loops.AddLoopsForShape(operand->shape(), \"operand\");",
          "new_line_content": "  // locations where the operand elements should be stored.",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": "DCHECK_LE",
          "new_api": null,
          "old_text": "DCHECK_LE(buffer_size, SIZE_MAX)",
          "new_text": null,
          "old_line_content": "  DCHECK_LE(buffer_size, SIZE_MAX);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2367,
          "old_api": "EmitReadArrayElement",
          "new_api": null,
          "old_text": "operand_array.EmitReadArrayElement(operand_index, &b_)",
          "new_text": null,
          "old_line_content": "      operand_array.EmitReadArrayElement(operand_index, &b_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": "MinimumAlignmentForShape",
          "new_api": null,
          "old_text": "MinimumAlignmentForShape(shape)",
          "new_text": null,
          "old_line_content": "  int alignment = MinimumAlignmentForShape(shape);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2373,
          "old_api": "size",
          "new_api": null,
          "old_text": "operand_index.size()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 0; i < operand_index.size(); ++i) {",
          "new_line_content": "  // Compute the output index the operand element should be assigned to.",
          "content_same": false
        },
        {
          "line": 326,
          "old_api": "llvm_ir::SetAlignmentMetadataForLoad(load, alignment)",
          "new_api": null,
          "old_text": "llvm_ir::SetAlignmentMetadataForLoad(load, alignment)",
          "new_text": null,
          "old_line_content": "    llvm_ir::SetAlignmentMetadataForLoad(load, alignment);",
          "new_line_content": "void IrEmitter::AttachAlignmentMetadataForLoad(llvm::LoadInst* load,",
          "content_same": false
        },
        {
          "line": 2376,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "padding_config.dimensions(i).interior_padding()",
          "new_text": null,
          "old_line_content": "            b_.getInt64(padding_config.dimensions(i).interior_padding() + 1));",
          "new_line_content": "  std::vector<llvm::Value*> output_multi_index;",
          "content_same": false
        },
        {
          "line": 2378,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "padding_config.dimensions(i).edge_padding_low()",
          "new_text": null,
          "old_line_content": "        offset, b_.getInt64(padding_config.dimensions(i).edge_padding_low()));",
          "new_line_content": "    llvm::Value* offset =",
          "content_same": false
        },
        {
          "line": 333,
          "old_api": "minimum_alignment_for_allocation",
          "new_api": null,
          "old_text": "target_machine_features_.minimum_alignment_for_allocation(buffer_size)",
          "new_text": null,
          "old_line_content": "      target_machine_features_.minimum_alignment_for_allocation(buffer_size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 335,
          "old_api": "llvm_ir::SetAlignmentMetadataForLoad(load, alignment)",
          "new_api": null,
          "old_text": "llvm_ir::SetAlignmentMetadataForLoad(load, alignment)",
          "new_text": null,
          "old_line_content": "    llvm_ir::SetAlignmentMetadataForLoad(load, alignment);",
          "new_line_content": "                                               int64 buffer_size) {",
          "content_same": false
        },
        {
          "line": 2385,
          "old_api": "GetType",
          "new_api": null,
          "old_text": "operand_index.GetType()",
          "new_text": null,
          "old_line_content": "      output_multi_index, output_array.GetShape(), operand_index.GetType());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2386,
          "old_api": "EmitWriteArrayElement",
          "new_api": null,
          "old_text": "output_array.EmitWriteArrayElement(output_index, operand_data, &b_)",
          "new_text": null,
          "old_line_content": "  output_array.EmitWriteArrayElement(output_index, operand_data, &b_);",
          "new_line_content": "  // Store the operand element to the computed output location.",
          "content_same": false
        },
        {
          "line": 2388,
          "old_api": "GetOuterLoopExitBasicBlock",
          "new_api": null,
          "old_text": "loops.GetOuterLoopExitBasicBlock()",
          "new_text": null,
          "old_line_content": "  SetToFirstInsertPoint(loops.GetOuterLoopExitBasicBlock(), &b_);",
          "new_line_content": "  llvm_ir::IrArray::Index output_index(",
          "content_same": false
        },
        {
          "line": 341,
          "old_api": "ByteSizeOf",
          "new_api": null,
          "old_text": "ByteSizeOf(shape)",
          "new_text": null,
          "old_line_content": "  AttachDereferenceableMetadataForLoad(load, ByteSizeOf(shape));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2394,
          "old_api": "llvm_ir::CanEmitFusedDynamicUpdateSliceInPlace(fusion, assignment_)",
          "new_api": null,
          "old_text": "llvm_ir::CanEmitFusedDynamicUpdateSliceInPlace(fusion, assignment_)",
          "new_text": null,
          "old_line_content": "  if (llvm_ir::CanEmitFusedDynamicUpdateSliceInPlace(fusion, assignment_)) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 347,
          "old_api": "llvm_ir::SetDereferenceableMetadataForLoad(load, buffer_size)",
          "new_api": null,
          "old_text": "llvm_ir::SetDereferenceableMetadataForLoad(load, buffer_size)",
          "new_text": null,
          "old_line_content": "    llvm_ir::SetDereferenceableMetadataForLoad(load, buffer_size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2395,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \"HandleFusion FusedDynamicUpdateSliceInPlace\";",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2400,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(fusion)",
          "new_text": null,
          "old_line_content": "        fusion, GetGeneratorForOperandIrArrays(fusion), GetIrArrayFor(fusion),",
          "new_line_content": "    CpuElementalIrEmitter elemental_emitter(hlo_module_config_, this, module_);",
          "content_same": false
        },
        {
          "line": 2402,
          "old_api": "IsLoopFusion",
          "new_api": null,
          "old_text": "fusion->IsLoopFusion()",
          "new_text": null,
          "old_line_content": "  } else if (fusion->IsLoopFusion()) {",
          "new_line_content": "    // Delegate to common implementation of fused in-place dynamic-update-slice.",
          "content_same": false
        },
        {
          "line": 356,
          "old_api": "operand",
          "new_api": null,
          "old_text": "get_tuple_element->operand(0)",
          "new_text": null,
          "old_line_content": "  auto operand = get_tuple_element->operand(0);",
          "new_line_content": "  // A tuple is an array of pointers, one for each operand. Each pointer points",
          "content_same": false
        },
        {
          "line": 357,
          "old_api": "shape",
          "new_api": null,
          "old_text": "get_tuple_element->shape()",
          "new_text": null,
          "old_line_content": "  const Shape& shape = get_tuple_element->shape();",
          "new_line_content": "  // to the output buffer of its corresponding operand. A GetTupleElement",
          "content_same": false
        },
        {
          "line": 358,
          "old_api": "tuple_index",
          "new_api": null,
          "old_text": "llvm_ir::EmitGetTupleElement(\n      shape, get_tuple_element->tuple_index(), MinimumAlignmentForShape(shape),\n      GetEmittedValueFor(operand), &b_)",
          "new_text": null,
          "old_line_content": "  emitted_value_[get_tuple_element] = llvm_ir::EmitGetTupleElement(",
          "new_line_content": "  // instruction forwards a pointer to the tuple element buffer at the given",
          "content_same": false
        },
        {
          "line": 359,
          "old_api": "MinimumAlignmentForShape",
          "new_api": null,
          "old_text": "MinimumAlignmentForShape(shape)",
          "new_text": null,
          "old_line_content": "      shape, get_tuple_element->tuple_index(), MinimumAlignmentForShape(shape),",
          "new_line_content": "  // index.",
          "content_same": false
        },
        {
          "line": 2405,
          "old_api": "GetIrArraysForOperandsOf",
          "new_api": null,
          "old_text": "GetIrArraysForOperandsOf(fusion)",
          "new_text": null,
          "old_line_content": "    auto operands = GetIrArraysForOperandsOf(fusion);",
          "new_line_content": "        &elemental_emitter, &b_);",
          "content_same": false
        },
        {
          "line": 2408,
          "old_api": "fused_expression_root",
          "new_api": null,
          "old_text": "fusion->fused_expression_root()->Accept(&fused_emitter)",
          "new_text": null,
          "old_line_content": "    TF_RETURN_IF_ERROR(fusion->fused_expression_root()->Accept(&fused_emitter));",
          "new_line_content": "    CpuElementalIrEmitter elemental_emitter(hlo_module_config_, this, module_);",
          "content_same": false
        },
        {
          "line": 2411,
          "old_api": "IsOutputFusion",
          "new_api": null,
          "old_text": "fusion->IsOutputFusion()",
          "new_text": null,
          "old_line_content": "  } else if (fusion->IsOutputFusion()) {",
          "new_line_content": "                                 &elemental_emitter);",
          "content_same": false
        },
        {
          "line": 2413,
          "old_api": "operand",
          "new_api": null,
          "old_text": "root->operand(0)->opcode()",
          "new_text": null,
          "old_line_content": "    int64 dot_op_index = root->operand(0)->opcode() == HloOpcode::kDot ? 0 : 1;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 366,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "pred->shape().element_type()",
          "new_text": null,
          "old_line_content": "  TF_RET_CHECK(pred->shape().element_type() == PRED);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 367,
          "old_api": "DefaultAction",
          "new_api": null,
          "old_text": "DefaultAction(select)",
          "new_text": null,
          "old_line_content": "  return DefaultAction(select);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": "operand",
          "new_api": null,
          "old_text": "tuple_select->operand(1)",
          "new_text": null,
          "old_line_content": "  auto on_true = tuple_select->operand(1);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 373,
          "old_api": "operand",
          "new_api": null,
          "old_text": "tuple_select->operand(2)",
          "new_text": null,
          "old_line_content": "  auto on_false = tuple_select->operand(2);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "pred->shape().element_type()",
          "new_text": null,
          "old_line_content": "  TF_RET_CHECK(pred->shape().element_type() == PRED);",
          "new_line_content": "Status IrEmitter::HandleTupleSelect(HloInstruction* tuple_select) {",
          "content_same": false
        },
        {
          "line": 2422,
          "old_api": "operand",
          "new_api": null,
          "old_text": "root->operand(1 - dot_op_index)->parameter_number()",
          "new_text": null,
          "old_line_content": "        root->operand(1 - dot_op_index)->parameter_number();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2425,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(fusion)",
          "new_text": null,
          "old_line_content": "    TF_RETURN_IF_ERROR(EmitTargetAddressForOp(fusion));",
          "new_line_content": "    int64 addend_param_number =",
          "content_same": false
        },
        {
          "line": 2431,
          "old_api": "operand",
          "new_api": null,
          "old_text": "fusion->operand(dot_rhs_param_number)",
          "new_text": null,
          "old_line_content": "        GetIrArrayFor(fusion->operand(dot_rhs_param_number)));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 386,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "infeed->ToString()",
          "new_text": null,
          "old_line_content": "  VLOG(2) << \"HandleInfeed: \" << infeed->ToString();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2436,
          "old_api": "EmitDotOperation",
          "new_api": null,
          "old_text": "EmitDotOperation(*dot, target_array, lhs_array, rhs_array,\n                         &addend_array, GetExecutableRunOptionsArgument(), &b_,\n                         hlo_module_config_, target_machine_features_)",
          "new_text": null,
          "old_line_content": "        EmitDotOperation(*dot, target_array, lhs_array, rhs_array,",
          "new_line_content": "    llvm_ir::IrArray addend_array(",
          "content_same": false
        },
        {
          "line": 391,
          "old_api": "shape",
          "new_api": null,
          "old_text": "ShapeUtil::Equal(data_shape,\n                          ShapeUtil::GetTupleElementShape(infeed->shape(), 0))",
          "new_text": null,
          "old_line_content": "  DCHECK(ShapeUtil::Equal(data_shape,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 392,
          "old_api": "shape",
          "new_api": null,
          "old_text": "infeed->shape()",
          "new_text": null,
          "old_line_content": "                          ShapeUtil::GetTupleElementShape(infeed->shape(), 0)));",
          "new_line_content": "  // The infeed operation produces a two-element tuple containing data and a",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(infeed)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(infeed));",
          "new_line_content": "  // token value. HloInfeedInstruction::infeed_shape gives us the data shape.",
          "content_same": false
        },
        {
          "line": 2446,
          "old_api": "to_apply",
          "new_api": null,
          "old_text": "call->to_apply()",
          "new_text": null,
          "old_line_content": "  HloComputation* computation = call->to_apply();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2447,
          "old_api": "FindOrDie",
          "new_api": null,
          "old_text": "FindOrDie(emitted_functions_, computation)",
          "new_text": null,
          "old_line_content": "  llvm::Function* call_ir_function = FindOrDie(emitted_functions_, computation);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2449,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(call)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(call));",
          "new_line_content": "Status IrEmitter::HandleCall(HloInstruction* call) {",
          "content_same": false
        },
        {
          "line": 2454,
          "old_api": "name",
          "new_api": null,
          "old_text": "GetArrayFunctionCallArguments(\n        {}, &b_, computation->name(),\n        /*return_value_buffer=*/emitted_value_[call],\n        /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),\n        /*buffer_table_arg=*/GetBufferTableArgument(),\n        /*profile_counters_arg=*/GetProfileCountersArgument())",
          "new_text": null,
          "old_line_content": "    std::vector<llvm::Value*> call_args = GetArrayFunctionCallArguments(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2457,
          "old_api": "GetExecutableRunOptionsArgument",
          "new_api": null,
          "old_text": "GetExecutableRunOptionsArgument()",
          "new_text": null,
          "old_line_content": "        /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),",
          "new_line_content": "    // ParallelForkJoin.",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": "tuple_shapes_size",
          "new_api": null,
          "old_text": "data_shape.tuple_shapes_size()",
          "new_text": null,
          "old_line_content": "    for (int64 i = 0; i < data_shape.tuple_shapes_size(); ++i) {",
          "new_line_content": "    // their corresponding target locations. We then construct the",
          "content_same": false
        },
        {
          "line": 2464,
          "old_api": "name",
          "new_api": null,
          "old_text": "computation->name()",
          "new_text": null,
          "old_line_content": "        call_ir_function, computation->name()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": "ShapeUtil::GetTupleElementShape(data_shape, i)",
          "new_api": null,
          "old_text": "ShapeUtil::GetTupleElementShape(data_shape, i)",
          "new_text": null,
          "old_line_content": "          ShapeUtil::GetTupleElementShape(data_shape, i);",
          "new_line_content": "      TF_ASSIGN_OR_RETURN(BufferAllocation::Slice buffer,",
          "content_same": false
        },
        {
          "line": 2469,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": "EmitBufferPointer",
          "new_api": null,
          "old_text": "EmitBufferPointer(buffer, tuple_element_shape)",
          "new_text": null,
          "old_line_content": "          EmitBufferPointer(buffer, tuple_element_shape);",
          "new_line_content": "      // GetEmittedValueFor, to handle the case when Infeed is the root",
          "content_same": false
        },
        {
          "line": 2474,
          "old_api": "getInt8PtrTy",
          "new_api": null,
          "old_text": "b_.getInt8PtrTy()",
          "new_text": null,
          "old_line_content": "  llvm::Type* i8_ptr_type = b_.getInt8PtrTy();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": "EmitXfeedTransfer",
          "new_api": null,
          "old_text": "EmitXfeedTransfer(\n          XfeedKind::kInfeed, tuple_element_shape, tuple_element_address)",
          "new_text": null,
          "old_line_content": "      TF_RETURN_IF_ERROR(EmitXfeedTransfer(",
          "new_line_content": "      // from EmitBufferPointer.",
          "content_same": false
        },
        {
          "line": 2476,
          "old_api": "getInt32",
          "new_api": null,
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntryWithCount(\n          i8_ptr_type, b_.getInt32(operands.size()), \"cc_operands_alloca\", &b_)",
          "new_text": null,
          "old_line_content": "      llvm_ir::EmitAllocaAtFunctionEntryWithCount(",
          "new_line_content": "Status IrEmitter::HandleCustomCall(HloInstruction* custom_call) {",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "tuple_element_addresses.push_back(tuple_element_address)",
          "new_text": null,
          "old_line_content": "      tuple_element_addresses.push_back(tuple_element_address);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": "llvm_ir::IrArray(data_address, data_shape)",
          "new_api": null,
          "old_text": "llvm_ir::IrArray(data_address, data_shape)",
          "new_text": null,
          "old_line_content": "    llvm_ir::EmitTuple(llvm_ir::IrArray(data_address, data_shape),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2483,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "b_.getInt64(i)",
          "new_text": null,
          "old_line_content": "        InBoundsGEP(operands_alloca, {b_.getInt64(i)});",
          "new_line_content": "    const HloInstruction* operand = operands[i];",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": "TF_RETURN_IF_ERROR",
          "new_api": null,
          "old_text": "TF_RETURN_IF_ERROR(\n        EmitXfeedTransfer(XfeedKind::kInfeed, data_shape, data_address))",
          "new_text": null,
          "old_line_content": "    TF_RETURN_IF_ERROR(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2484,
          "old_api": "Store",
          "new_api": null,
          "old_text": "Store(operand_as_i8ptr, slot_in_operands_alloca)",
          "new_text": null,
          "old_line_content": "    Store(operand_as_i8ptr, slot_in_operands_alloca);",
          "new_line_content": "    llvm::Value* operand_as_i8ptr =",
          "content_same": false
        },
        {
          "line": 2490,
          "old_api": "getDataLayout",
          "new_api": null,
          "old_text": "module_->getDataLayout()",
          "new_text": null,
          "old_line_content": "    const llvm::DataLayout& dl = module_->getDataLayout();",
          "new_line_content": "  if (emit_code_for_msan_) {",
          "content_same": false
        },
        {
          "line": 2491,
          "old_api": "getIntPtrTy",
          "new_api": null,
          "old_text": "b_.getIntPtrTy(dl)",
          "new_text": null,
          "old_line_content": "    llvm::Type* intptr_type = b_.getIntPtrTy(dl);",
          "new_line_content": "    // Mark the alloca as initialized for msan. The buffer gets read by the",
          "content_same": false
        },
        {
          "line": 2492,
          "old_api": "getVoidTy",
          "new_api": null,
          "old_text": "llvm::cast<llvm::Function>(\n        module_\n            ->getOrInsertFunction(\n                \"__msan_unpoison\",\n                llvm::FunctionType::get(\n                    /*Result=*/b_.getVoidTy(),\n                    /*Params=*/{i8_ptr_type, intptr_type}, /*isVarArg=*/false))\n            .getCallee())",
          "new_text": null,
          "old_line_content": "    auto* msan_unpoison_ir_function = llvm::cast<llvm::Function>(",
          "new_line_content": "    // custom callee, which might be msan-instrumented.",
          "content_same": false
        },
        {
          "line": 445,
          "old_api": "ByteSizeOf",
          "new_api": null,
          "old_text": "ByteSizeOf(shape)",
          "new_text": null,
          "old_line_content": "  int64 length = ByteSizeOf(shape);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": "std::numeric_limits<int32>::max()",
          "new_api": null,
          "old_text": "std::numeric_limits<int32>::max()",
          "new_text": null,
          "old_line_content": "  if (length <= 0 || length > std::numeric_limits<int32>::max()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 447,
          "old_api": "InvalidArgument",
          "new_api": null,
          "old_text": "InvalidArgument(\n        \"xfeed (infeed or outfeed) buffer length %d is outside the valid \"\n        \"size range\",\n        length)",
          "new_text": null,
          "old_line_content": "    return InvalidArgument(",
          "new_line_content": "Status IrEmitter::EmitXfeedTransfer(XfeedKind kind, const Shape& shape,",
          "content_same": false
        },
        {
          "line": 2493,
          "old_api": "getVoidTy",
          "new_api": null,
          "old_text": "module_\n            ->getOrInsertFunction(\n                \"__msan_unpoison\",\n                llvm::FunctionType::get(\n                    /*Result=*/b_.getVoidTy(),\n                    /*Params=*/{i8_ptr_type, intptr_type}, /*isVarArg=*/false))\n            .getCallee()",
          "new_text": null,
          "old_line_content": "        module_",
          "new_line_content": "    // TODO(b/66051036): Run the msan instrumentation pass instead.",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": "static_cast<int32>(length)",
          "new_api": null,
          "old_text": "static_cast<int32>(length)",
          "new_text": null,
          "old_line_content": "  int32 length_32 = static_cast<int32>(length);",
          "new_line_content": "        \"xfeed (infeed or outfeed) buffer length %d is outside the valid \"",
          "content_same": false
        },
        {
          "line": 2502,
          "old_api": "getAllocationSizeInBits",
          "new_api": null,
          "old_text": "llvm::ConstantInt::get(\n              intptr_type, *operands_alloca->getAllocationSizeInBits(dl) / 8)",
          "new_text": null,
          "old_line_content": "          llvm::ConstantInt::get(",
          "new_line_content": "                    /*Params=*/{i8_ptr_type, intptr_type}, /*isVarArg=*/false))",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": "TF_ASSIGN_OR_RETURN",
          "new_api": null,
          "old_text": "TF_ASSIGN_OR_RETURN(\n      llvm::Value * shape_ptr,\n      llvm_ir::EncodeSelfDescribingShapeConstant(shape, &shape_length, &b_))",
          "new_text": null,
          "old_line_content": "  TF_ASSIGN_OR_RETURN(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2503,
          "old_api": "getAllocationSizeInBits",
          "new_api": null,
          "old_text": "operands_alloca->getAllocationSizeInBits(dl)",
          "new_text": null,
          "old_line_content": "              intptr_type, *operands_alloca->getAllocationSizeInBits(dl) / 8)});",
          "new_line_content": "            .getCallee());",
          "content_same": false
        },
        {
          "line": 457,
          "old_api": "llvm_ir::EncodeSelfDescribingShapeConstant(shape, &shape_length, &b_)",
          "new_api": null,
          "old_text": "llvm_ir::EncodeSelfDescribingShapeConstant(shape, &shape_length, &b_)",
          "new_text": null,
          "old_line_content": "      llvm_ir::EncodeSelfDescribingShapeConstant(shape, &shape_length, &b_));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": "getContext",
          "new_api": null,
          "old_text": "module_->getContext()",
          "new_text": null,
          "old_line_content": "  llvm::Type* i8_ptr_type = llvm::Type::getInt8PtrTy(module_->getContext());",
          "new_line_content": "      llvm::Value * shape_ptr,",
          "content_same": false
        },
        {
          "line": 2508,
          "old_api": "custom_call_target",
          "new_api": null,
          "old_text": "custom_call->custom_call_target()",
          "new_text": null,
          "old_line_content": "              custom_call->custom_call_target(),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2511,
          "old_api": "getType",
          "new_api": null,
          "old_text": "operands_alloca->getType()",
          "new_text": null,
          "old_line_content": "                  /*Params=*/{i8_ptr_type, operands_alloca->getType()},",
          "new_line_content": "          ->getOrInsertFunction(",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "llvm::dyn_cast<llvm::Function>(\n        module_\n            ->getOrInsertFunction(\n                runtime::kAcquireInfeedBufferForDequeueSymbolName, acquire_type)\n            .getCallee())",
          "new_text": null,
          "old_line_content": "    acquire_func = llvm::dyn_cast<llvm::Function>(",
          "new_line_content": "      /*isVarArg=*/false);",
          "content_same": false
        },
        {
          "line": 470,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "module_\n            ->getOrInsertFunction(\n                runtime::kAcquireInfeedBufferForDequeueSymbolName, acquire_type)\n            .getCallee()",
          "new_text": null,
          "old_line_content": "        module_",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2517,
          "old_api": "IsTuple",
          "new_api": null,
          "old_text": "custom_call->shape().IsTuple()",
          "new_text": null,
          "old_line_content": "  if (custom_call->shape().IsTuple()) {",
          "new_line_content": "          .getCallee());",
          "content_same": false
        },
        {
          "line": 2522,
          "old_api": "shape",
          "new_api": null,
          "old_text": "custom_call->shape()",
          "new_text": null,
          "old_line_content": "          ShapeUtil::GetTupleElementShape(custom_call->shape(), i);",
          "new_line_content": "    std::vector<llvm::Value*> base_ptrs;",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "llvm::dyn_cast<llvm::Function>(\n        module_\n            ->getOrInsertFunction(\n                runtime::kAcquireOutfeedBufferForPopulationSymbolName,\n                acquire_type)\n            .getCallee())",
          "new_text": null,
          "old_line_content": "    acquire_func = llvm::dyn_cast<llvm::Function>(",
          "new_line_content": "            ->getOrInsertFunction(",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "module_\n            ->getOrInsertFunction(\n                runtime::kAcquireOutfeedBufferForPopulationSymbolName,\n                acquire_type)\n            .getCallee()",
          "new_text": null,
          "old_line_content": "        module_",
          "new_line_content": "                runtime::kAcquireInfeedBufferForDequeueSymbolName, acquire_type)",
          "content_same": false
        },
        {
          "line": 2529,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(custom_call)",
          "new_text": null,
          "old_line_content": "    llvm_ir::EmitTuple(GetIrArrayFor(custom_call), base_ptrs, &b_);",
          "new_line_content": "                          assignment_.GetUniqueSlice(custom_call, {i}));",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": "setCallingConv",
          "new_api": null,
          "old_text": "acquire_func->setCallingConv(llvm::CallingConv::C)",
          "new_text": null,
          "old_line_content": "  acquire_func->setCallingConv(llvm::CallingConv::C);",
          "new_line_content": "                runtime::kAcquireOutfeedBufferForPopulationSymbolName,",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": "getVoidTy",
          "new_api": null,
          "old_text": "llvm::FunctionType::get(\n      b_.getVoidTy(),\n      {/*run_options*/ i8_ptr_type, /*buffer_length*/ int32_type,\n       /*buffer_ptr*/ i8_ptr_type, /*shape_ptr*/ i8_ptr_type,\n       /*shape_length*/ int32_type},\n      /*isVarArg=*/false)",
          "new_text": null,
          "old_line_content": "  llvm::FunctionType* release_type = llvm::FunctionType::get(",
          "new_line_content": "            .getCallee());",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": "getVoidTy",
          "new_api": null,
          "old_text": "b_.getVoidTy()",
          "new_text": null,
          "old_line_content": "      b_.getVoidTy(),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2532,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(custom_call)",
          "new_text": null,
          "old_line_content": "      PointerCast(GetEmittedValueFor(custom_call), i8_ptr_type);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2534,
          "old_api": "Call",
          "new_api": null,
          "old_text": "Call(custom_call_ir_function, {output_address_arg, operands_alloca})",
          "new_text": null,
          "old_line_content": "  Call(custom_call_ir_function, {output_address_arg, operands_alloca});",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "llvm::dyn_cast<llvm::Function>(\n        module_\n            ->getOrInsertFunction(\n                runtime::kReleaseInfeedBufferAfterDequeueSymbolName,\n                release_type)\n            .getCallee())",
          "new_text": null,
          "old_line_content": "    release_func = llvm::dyn_cast<llvm::Function>(",
          "new_line_content": "      /*isVarArg=*/false);",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "module_\n            ->getOrInsertFunction(\n                runtime::kReleaseInfeedBufferAfterDequeueSymbolName,\n                release_type)\n            .getCallee()",
          "new_text": null,
          "old_line_content": "        module_",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2541,
          "old_api": "while_condition",
          "new_api": null,
          "old_text": "xla_while->while_condition()",
          "new_text": null,
          "old_line_content": "  HloComputation* condition = xla_while->while_condition();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2542,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "condition->root_instruction()->shape()",
          "new_text": null,
          "old_line_content": "  TF_RET_CHECK(ShapeUtil::IsScalar(condition->root_instruction()->shape()) &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2543,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "condition->root_instruction()->shape().element_type()",
          "new_text": null,
          "old_line_content": "               condition->root_instruction()->shape().element_type() == PRED)",
          "new_line_content": "Status IrEmitter::HandleWhile(HloInstruction* xla_while) {",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "llvm::dyn_cast<llvm::Function>(\n        module_\n            ->getOrInsertFunction(\n                runtime::kReleaseOutfeedBufferAfterPopulationSymbolName,\n                release_type)\n            .getCallee())",
          "new_text": null,
          "old_line_content": "    release_func = llvm::dyn_cast<llvm::Function>(",
          "new_line_content": "                runtime::kReleaseInfeedBufferAfterDequeueSymbolName,",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "module_\n            ->getOrInsertFunction(\n                runtime::kReleaseOutfeedBufferAfterPopulationSymbolName,\n                release_type)\n            .getCallee()",
          "new_text": null,
          "old_line_content": "        module_",
          "new_line_content": "                release_type)",
          "content_same": false
        },
        {
          "line": 2548,
          "old_api": "shape",
          "new_api": null,
          "old_text": "xla_while->shape()",
          "new_text": null,
          "old_line_content": "      xla_while->shape(),",
          "new_line_content": "      << \"While condition computation must return bool; got: \"",
          "content_same": false
        },
        {
          "line": 2554,
          "old_api": "GetUniqueSlice",
          "new_api": null,
          "old_text": "assignment_.GetUniqueSlice(a, index).ConsumeValueOrDie()",
          "new_text": null,
          "old_line_content": "              assignment_.GetUniqueSlice(a, index).ConsumeValueOrDie();",
          "new_line_content": "                         const ShapeIndex& index) -> Status {",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": "setCallingConv",
          "new_api": null,
          "old_text": "release_func->setCallingConv(llvm::CallingConv::C)",
          "new_text": null,
          "old_line_content": "  release_func->setCallingConv(llvm::CallingConv::C);",
          "new_line_content": "                runtime::kReleaseOutfeedBufferAfterPopulationSymbolName,",
          "content_same": false
        },
        {
          "line": 2556,
          "old_api": "GetUniqueSlice",
          "new_api": null,
          "old_text": "assignment_.GetUniqueSlice(b, index).ConsumeValueOrDie()",
          "new_text": null,
          "old_line_content": "              assignment_.GetUniqueSlice(b, index).ConsumeValueOrDie();",
          "new_line_content": "                            const ShapeIndex& index) {",
          "content_same": false
        },
        {
          "line": 513,
          "old_api": "getInt32",
          "new_api": null,
          "old_text": "Call(\n      acquire_func, {GetExecutableRunOptionsArgument(), b_.getInt32(length_32),\n                     shape_ptr, b_.getInt32(shape_length)})",
          "new_text": null,
          "old_line_content": "  llvm::Value* acquired_pointer = Call(",
          "new_line_content": "  // Implementation note: this call informs the runtime that it wants a buffer",
          "content_same": false
        },
        {
          "line": 514,
          "old_api": "getInt32",
          "new_api": null,
          "old_text": "b_.getInt32(length_32)",
          "new_text": null,
          "old_line_content": "      acquire_func, {GetExecutableRunOptionsArgument(), b_.getInt32(length_32),",
          "new_line_content": "  // of size exactly 'length_32', and the runtime is responsible for",
          "content_same": false
        },
        {
          "line": 515,
          "old_api": "getInt32",
          "new_api": null,
          "old_text": "b_.getInt32(shape_length)",
          "new_text": null,
          "old_line_content": "                     shape_ptr, b_.getInt32(shape_length)});",
          "new_line_content": "  // check-failing the process if there is a mismatch, versus passing us back a",
          "content_same": false
        },
        {
          "line": 2561,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "b->ToString()",
          "new_text": null,
          "old_line_content": "                a->ToString(), slice_a.ToString(), b->ToString(),",
          "new_line_content": "          if (slice_a != slice_b) {",
          "content_same": false
        },
        {
          "line": 2564,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "          return Status::OK();",
          "new_line_content": "                \"instruction %s %s\",",
          "content_same": false
        },
        {
          "line": 2567,
          "old_api": "while_condition",
          "new_api": null,
          "old_text": "check(\n            xla_while, xla_while->while_condition()->parameter_instruction(0),\n            index)",
          "new_text": null,
          "old_line_content": "        TF_RETURN_IF_ERROR(check(",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 2573,
          "old_api": "while_body",
          "new_api": null,
          "old_text": "check(\n            xla_while, xla_while->while_body()->root_instruction(), index)",
          "new_text": null,
          "old_line_content": "        TF_RETURN_IF_ERROR(check(",
          "new_line_content": "            index));",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": "getInt32",
          "new_api": null,
          "old_text": "b_.getInt32(shape_length)",
          "new_text": null,
          "old_line_content": "                      acquired_pointer, shape_ptr, b_.getInt32(shape_length)});",
          "new_line_content": "           /*SrcAlign=*/1, length_32);",
          "content_same": false
        },
        {
          "line": 530,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2580,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(init)",
          "new_text": null,
          "old_line_content": "  emitted_value_[xla_while] = GetEmittedValueFor(init);",
          "new_line_content": "      }));",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(outfeed)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(outfeed));",
          "new_line_content": "  // Outfeed produces no useful result, but it does return a token[] that can be",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": "operands",
          "new_api": null,
          "old_text": "outfeed->operands()",
          "new_text": null,
          "old_line_content": "  HloInstruction* operand = outfeed->operands()[0];",
          "new_line_content": "  // the IR emitter we treat this token as a normal u8[] and thus need to insert",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": "shape",
          "new_api": null,
          "old_text": "operand->shape()",
          "new_text": null,
          "old_line_content": "  const Shape& operand_shape = operand->shape();",
          "new_line_content": "  // an entry for it in emitted_value_.",
          "content_same": false
        },
        {
          "line": 2590,
          "old_api": "getContext",
          "new_api": null,
          "old_text": "llvm::BasicBlock::Create(\n      module_->getContext(), IrName(xla_while, \"header\"),\n      compute_function_->function())",
          "new_text": null,
          "old_line_content": "  llvm::BasicBlock* header_bb = llvm::BasicBlock::Create(",
          "new_line_content": "  //     while_result = Body(while_result);  // Insert",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(operand)",
          "new_text": null,
          "old_line_content": "  llvm::Value* value = GetEmittedValueFor(operand);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2591,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(xla_while, \"header\")",
          "new_text": null,
          "old_line_content": "      module_->getContext(), IrName(xla_while, \"header\"),",
          "new_line_content": "  //   }",
          "content_same": false
        },
        {
          "line": 2592,
          "old_api": "function",
          "new_api": null,
          "old_text": "compute_function_->function()",
          "new_text": null,
          "old_line_content": "      compute_function_->function());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2593,
          "old_api": "Br",
          "new_api": null,
          "old_text": "Br(header_bb)",
          "new_text": null,
          "old_line_content": "  Br(header_bb);",
          "new_line_content": "  // Terminates the current block with a branch to a while header.",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": "tuple_shapes_size",
          "new_api": null,
          "old_text": "operand_shape.tuple_shapes_size()",
          "new_text": null,
          "old_line_content": "  for (int64 i = 0; i < operand_shape.tuple_shapes_size(); ++i) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2599,
          "old_api": "while_condition",
          "new_api": null,
          "old_text": "ICmpNE(\n      Load(GetBufferForGlobalCallReturnValue(*xla_while->while_condition())),\n      llvm::ConstantInt::get(llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0))",
          "new_text": null,
          "old_line_content": "  llvm::Value* while_predicate = ICmpNE(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2600,
          "old_api": "while_condition",
          "new_api": null,
          "old_text": "xla_while->while_condition()",
          "new_text": null,
          "old_line_content": "      Load(GetBufferForGlobalCallReturnValue(*xla_while->while_condition())),",
          "new_line_content": "  // Calls the condition function to determine whether to proceed with the",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": "llvm_ir::EmitGetTupleElement(\n        tuple_element_shape, i, MinimumAlignmentForShape(tuple_element_shape),\n        value, &b_)",
          "new_api": null,
          "old_text": "llvm_ir::EmitGetTupleElement(\n        tuple_element_shape, i, MinimumAlignmentForShape(tuple_element_shape),\n        value, &b_)",
          "new_text": null,
          "old_line_content": "    llvm::Value* tuple_element = llvm_ir::EmitGetTupleElement(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2601,
          "old_api": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "new_api": null,
          "old_text": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "new_text": null,
          "old_line_content": "      llvm::ConstantInt::get(llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0));",
          "new_line_content": "  // body.  It must return a bool, so use the scalar call form.",
          "content_same": false
        },
        {
          "line": 2606,
          "old_api": "function",
          "new_api": null,
          "old_text": "compute_function_->function()",
          "new_text": null,
          "old_line_content": "                               compute_function_->function());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2607,
          "old_api": "getContext",
          "new_api": null,
          "old_text": "llvm::BasicBlock::Create(\n      module_->getContext(), IrName(xla_while, \"exit\"))",
          "new_text": null,
          "old_line_content": "  llvm::BasicBlock* exit_bb = llvm::BasicBlock::Create(",
          "new_line_content": "  // Branches to the body or to the while exit depending on the condition.",
          "content_same": false
        },
        {
          "line": 2608,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(xla_while, \"exit\")",
          "new_text": null,
          "old_line_content": "      module_->getContext(), IrName(xla_while, \"exit\"));",
          "new_line_content": "  llvm::BasicBlock* body_bb =",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(sort)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(sort));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": "keys",
          "new_api": null,
          "old_text": "sort->keys()->shape()",
          "new_text": null,
          "old_line_content": "  Shape keys_shape = sort->keys()->shape();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "keys_shape.element_type()",
          "new_text": null,
          "old_line_content": "  PrimitiveType keys_type = keys_shape.element_type();",
          "new_line_content": "Status IrEmitter::HandleSort(HloInstruction* hlo) {",
          "content_same": false
        },
        {
          "line": 2615,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(xla_while, \"body\")",
          "new_text": null,
          "old_line_content": "  EmitGlobalCall(*xla_while->while_body(), IrName(xla_while, \"body\"));",
          "new_line_content": "  // Calls the body function from the body block.",
          "content_same": false
        },
        {
          "line": 2618,
          "old_api": "Br",
          "new_api": null,
          "old_text": "Br(header_bb)",
          "new_text": null,
          "old_line_content": "  Br(header_bb);",
          "new_line_content": "  // Calls the body function.",
          "content_same": false
        },
        {
          "line": 2621,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "compute_function_->function()->getBasicBlockList().push_back(exit_bb)",
          "new_text": null,
          "old_line_content": "  compute_function_->function()->getBasicBlockList().push_back(exit_bb);",
          "new_line_content": "  // Finishes with a branch back to the header.",
          "content_same": false
        },
        {
          "line": 2624,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  // Adds the exit block to the function and sets the insert point there.",
          "content_same": false
        },
        {
          "line": 2630,
          "old_api": "ShouldEmitParallelLoopFor",
          "new_api": null,
          "old_text": "ShouldEmitParallelLoopFor(*concatenate)",
          "new_text": null,
          "old_line_content": "  if (ShouldEmitParallelLoopFor(*concatenate)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": "Unimplemented",
          "new_api": null,
          "old_text": "Unimplemented(\n          \"Element type %s not supported in the Sort op on CPU.\",\n          PrimitiveType_Name(keys_type))",
          "new_text": null,
          "old_line_content": "      return Unimplemented(",
          "new_line_content": "    case U64:",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": "PrimitiveType_Name",
          "new_api": null,
          "old_text": "PrimitiveType_Name(keys_type)",
          "new_text": null,
          "old_line_content": "          PrimitiveType_Name(keys_type));",
          "new_line_content": "      break;",
          "content_same": false
        },
        {
          "line": 2636,
          "old_api": "shape",
          "new_api": null,
          "old_text": "concatenate->shape()",
          "new_text": null,
          "old_line_content": "  const Shape& output_shape = concatenate->shape();",
          "new_line_content": "        \"cannot generate memcpy-based concat for the parallel CPU backend\";",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": "operand_count",
          "new_api": null,
          "old_text": "sort->operand_count()",
          "new_text": null,
          "old_line_content": "  for (int64 i = 0; i < sort->operand_count(); ++i) {",
          "new_line_content": "          \"Element type %s not supported in the Sort op on CPU.\",",
          "content_same": false
        },
        {
          "line": 2638,
          "old_api": "layout",
          "new_api": null,
          "old_text": "output_shape.layout()",
          "new_text": null,
          "old_line_content": "    if (!LayoutUtil::Equal(op->shape().layout(), output_shape.layout())) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": "ShapeIndex",
          "new_api": null,
          "old_text": "ShapeIndex({})",
          "new_text": null,
          "old_line_content": "        sort->values_count() > 0 ? ShapeIndex({i}) : ShapeIndex({});",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 597,
          "old_api": "shape",
          "new_api": null,
          "old_text": "LayoutUtil::LayoutsInShapesEqual(\n        keys_shape, ShapeUtil::GetSubshape(sort->shape(), shape_index))",
          "new_text": null,
          "old_line_content": "    TF_RET_CHECK(LayoutUtil::LayoutsInShapesEqual(",
          "new_line_content": "    // We assume that the layout of all involved operands and outputs is the",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": "shape",
          "new_api": null,
          "old_text": "sort->shape()",
          "new_text": null,
          "old_line_content": "        keys_shape, ShapeUtil::GetSubshape(sort->shape(), shape_index)));",
          "new_line_content": "    // same.",
          "content_same": false
        },
        {
          "line": 2648,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "concatenate->dimensions(0)",
          "new_text": null,
          "old_line_content": "  int64 concat_dim = concatenate->dimensions(0);",
          "new_line_content": "  // We split the dimensions into three categories: the dimension over which we",
          "content_same": false
        },
        {
          "line": 2649,
          "old_api": "layout",
          "new_api": null,
          "old_text": "output_shape.layout()",
          "new_text": null,
          "old_line_content": "  const Layout& output_layout = output_shape.layout();",
          "new_line_content": "  // are concatenating (concat_dim), the dimensions that are minor to it",
          "content_same": false
        },
        {
          "line": 2650,
          "old_api": "LayoutUtil::MinorToMajor(output_layout)",
          "new_api": null,
          "old_text": "LayoutUtil::MinorToMajor(output_layout)",
          "new_text": null,
          "old_line_content": "  auto output_min2maj = LayoutUtil::MinorToMajor(output_layout);",
          "new_line_content": "  // (inner_dims) and the dimensions that are major to it (outer_dims).",
          "content_same": false
        },
        {
          "line": 2651,
          "old_api": "absl::c_find(output_min2maj, concat_dim)",
          "new_api": null,
          "old_text": "absl::c_find(output_min2maj, concat_dim)",
          "new_text": null,
          "old_line_content": "  auto concat_dim_layout_itr = absl::c_find(output_min2maj, concat_dim);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": "shape",
          "new_api": null,
          "old_text": "operand->shape()",
          "new_text": null,
          "old_line_content": "        EmitBufferPointer(destination_buffer, operand->shape());",
          "new_line_content": "    // The sort is implemented in-place, therefore we first copy the operand",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": "GetAllocationSlice",
          "new_api": null,
          "old_text": "GetAllocationSlice(*operand)",
          "new_text": null,
          "old_line_content": "    auto source_address = GetAllocationSlice(*operand);",
          "new_line_content": "    // buffer to the output buffer if they are not the same.",
          "content_same": false
        },
        {
          "line": 610,
          "old_api": "shape",
          "new_api": null,
          "old_text": "operand->shape()",
          "new_text": null,
          "old_line_content": "      int64 size = ByteSizeOf(operand->shape());",
          "new_line_content": "    if (destination_buffer != source_address) {",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": "MemCpy",
          "new_api": null,
          "old_text": "MemCpy(destination_addresses[i], /*DstAlign=*/primitive_type_size,\n             source_buffer,\n             /*SrcAlign=*/primitive_type_size, size)",
          "new_text": null,
          "old_line_content": "      MemCpy(destination_addresses[i], /*DstAlign=*/primitive_type_size,",
          "new_line_content": "      int64 primitive_type_size =",
          "content_same": false
        },
        {
          "line": 2660,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(concatenate)",
          "new_text": null,
          "old_line_content": "  llvm_ir::IrArray target_array = GetIrArrayFor(concatenate);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2662,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(concatenate)",
          "new_text": null,
          "old_line_content": "  llvm_ir::ForLoopNest loops(IrName(concatenate), &b_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2665,
          "old_api": "end",
          "new_api": null,
          "old_text": "target_multi_index.end()",
          "new_text": null,
          "old_line_content": "  std::replace(target_multi_index.begin(), target_multi_index.end(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": "ShapeUtil::MakeShapeWithDescendingLayoutAndSamePhysicalLayout(keys_shape)",
          "new_api": null,
          "old_text": "ShapeUtil::MakeShapeWithDescendingLayoutAndSamePhysicalLayout(keys_shape)",
          "new_text": null,
          "old_line_content": "      ShapeUtil::MakeShapeWithDescendingLayoutAndSamePhysicalLayout(keys_shape);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 620,
          "old_api": "layout",
          "new_api": null,
          "old_text": "LayoutUtil::MakeLogicalToPhysical(\n      keys_shape.layout())",
          "new_text": null,
          "old_line_content": "  int64 physical_dimension_to_sort = LayoutUtil::MakeLogicalToPhysical(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 621,
          "old_api": "sort_dimension",
          "new_api": null,
          "old_text": "sort->sort_dimension()",
          "new_text": null,
          "old_line_content": "      keys_shape.layout())[sort->sort_dimension()];",
          "new_line_content": "  // Normalize the shape and the dimension to sort.",
          "content_same": false
        },
        {
          "line": 2667,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "b_.getInt64(0)",
          "new_text": null,
          "old_line_content": "               static_cast<llvm::Value*>(b_.getInt64(0)));",
          "new_line_content": "  std::vector<llvm::Value*> target_multi_index =",
          "content_same": false
        },
        {
          "line": 2672,
          "old_api": "GetInnerLoopBodyBasicBlock",
          "new_api": null,
          "old_text": "loops.GetInnerLoopBodyBasicBlock()",
          "new_text": null,
          "old_line_content": "    SetToFirstInsertPoint(loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "new_line_content": "  llvm_ir::IrArray::Index target_index(target_multi_index, output_shape,",
          "content_same": false
        },
        {
          "line": 627,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "normalized_keys_shape.dimensions(i)",
          "new_text": null,
          "old_line_content": "    higher_dimensions *= normalized_keys_shape.dimensions(i);",
          "new_line_content": "  int64 sort_dimension_elements =",
          "content_same": false
        },
        {
          "line": 2677,
          "old_api": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "new_api": null,
          "old_text": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "new_text": null,
          "old_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(primitive_type);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 630,
          "old_api": "rank",
          "new_api": null,
          "old_text": "normalized_keys_shape.rank()",
          "new_text": null,
          "old_line_content": "  for (int64 i = normalized_keys_shape.rank() - 1;",
          "new_line_content": "  for (int64 i = 0; i < physical_dimension_to_sort; ++i) {",
          "content_same": false
        },
        {
          "line": 632,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "normalized_keys_shape.dimensions(i)",
          "new_text": null,
          "old_line_content": "    lower_dimensions *= normalized_keys_shape.dimensions(i);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2682,
          "old_api": "EmitArrayElementAddress",
          "new_api": null,
          "old_text": "target_array.EmitArrayElementAddress(target_index, &b_, \"target_region\")",
          "new_text": null,
          "old_line_content": "      target_array.EmitArrayElementAddress(target_index, &b_, \"target_region\"),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": "to_apply",
          "new_api": null,
          "old_text": "sort->to_apply()",
          "new_text": null,
          "old_line_content": "  auto less_than_function = FindOrDie(emitted_functions_, sort->to_apply());",
          "new_line_content": "       i > physical_dimension_to_sort; --i) {",
          "content_same": false
        },
        {
          "line": 637,
          "old_api": "getVoidTy",
          "new_api": null,
          "old_text": "llvm::FunctionType::get(\n      b_.getVoidTy(),\n      {b_.getInt64Ty(), b_.getInt64Ty(), b_.getInt64Ty(),\n       b_.getInt8PtrTy()->getPointerTo(), b_.getInt32Ty(),\n       b_.getInt32Ty()->getPointerTo(), b_.getInt1Ty(), b_.getInt8PtrTy(),\n       b_.getInt64Ty()->getPointerTo(), less_than_function->getType()},\n      /*isVarArg=*/false)",
          "new_text": null,
          "old_line_content": "  llvm::FunctionType* key_value_sort_type = llvm::FunctionType::get(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": "getVoidTy",
          "new_api": null,
          "old_text": "b_.getVoidTy()",
          "new_text": null,
          "old_line_content": "      b_.getVoidTy(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2687,
          "old_api": "end",
          "new_api": null,
          "old_text": "inner_dims.end()",
          "new_text": null,
          "old_line_content": "      std::accumulate(inner_dims.begin(), inner_dims.end(), 1l,",
          "new_line_content": "      i8_ptr_type);",
          "content_same": false
        },
        {
          "line": 2689,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "output_shape.dimensions(inner_dim)",
          "new_text": null,
          "old_line_content": "                        return product * output_shape.dimensions(inner_dim);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2695,
          "old_api": "shape",
          "new_api": null,
          "old_text": "operand->shape()",
          "new_text": null,
          "old_line_content": "    const Shape& input_shape = operand->shape();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2696,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(operand)",
          "new_text": null,
          "old_line_content": "    llvm_ir::IrArray source_array = GetIrArrayFor(operand);",
          "new_line_content": "  // For each operand, emit a memcpy from the operand to the target of size",
          "content_same": false
        },
        {
          "line": 2697,
          "old_api": "shape",
          "new_api": null,
          "old_text": "operand->shape()",
          "new_text": null,
          "old_line_content": "    llvm_ir::IrArray::Index source_index(target_multi_index, operand->shape(),",
          "new_line_content": "  // equal to the product of inner dimensions.",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": "setDoesNotThrow",
          "new_api": null,
          "old_text": "key_value_sort_func->setDoesNotThrow()",
          "new_text": null,
          "old_line_content": "  key_value_sort_func->setDoesNotThrow();",
          "new_line_content": "          ->getOrInsertFunction(runtime::kKeyValueSortSymbolName,",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": "getInt8PtrTy",
          "new_api": null,
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntryWithCount(\n      b_.getInt8PtrTy(), b_.getInt32(sort->operand_count()), \"cc_values_alloca\",\n      &b_)",
          "new_text": null,
          "old_line_content": "  llvm::Value* values = llvm_ir::EmitAllocaAtFunctionEntryWithCount(",
          "new_line_content": "                                key_value_sort_type)",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": "operand_count",
          "new_api": null,
          "old_text": "sort->operand_count()",
          "new_text": null,
          "old_line_content": "      b_.getInt8PtrTy(), b_.getInt32(sort->operand_count()), \"cc_values_alloca\",",
          "new_line_content": "          .getCallee());",
          "content_same": false
        },
        {
          "line": 2698,
          "old_api": "getInt64Ty",
          "new_api": null,
          "old_text": "b_.getInt64Ty()",
          "new_text": null,
          "old_line_content": "                                         b_.getInt64Ty());",
          "new_line_content": "  for (HloInstruction* operand : operands) {",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": "operand_count",
          "new_api": null,
          "old_text": "sort->operand_count()",
          "new_text": null,
          "old_line_content": "  for (int64 i = 0; i < sort->operand_count(); ++i) {",
          "new_line_content": "      &b_);",
          "content_same": false
        },
        {
          "line": 2706,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "EmitTransferElements(\n        copy_target_address, copy_source_address,\n        inner_dims_product * input_shape.dimensions(concat_dim), primitive_type,\n        target_array, source_array)",
          "new_text": null,
          "old_line_content": "    EmitTransferElements(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": "Store",
          "new_api": null,
          "old_text": "Store(value_as_i8ptr, slot_in_values_alloca)",
          "new_text": null,
          "old_line_content": "    Store(value_as_i8ptr, slot_in_values_alloca);",
          "new_line_content": "    llvm::Value* value_as_i8ptr =",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": "getInt32Ty",
          "new_api": null,
          "old_text": "b_.getInt32Ty()",
          "new_text": null,
          "old_line_content": "        ConstInBoundsGEP1_32(b_.getInt32Ty(), sizes, i);",
          "new_line_content": "    llvm::Value* slot_in_values_alloca =",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": "Store",
          "new_api": null,
          "old_text": "Store(size, slot_in_sizes_alloca)",
          "new_text": null,
          "old_line_content": "    Store(size, slot_in_sizes_alloca);",
          "new_line_content": "    llvm::Value* slot_in_sizes_alloca =",
          "content_same": false
        },
        {
          "line": 2717,
          "old_api": "GetOuterLoopExitBasicBlock",
          "new_api": null,
          "old_text": "loops.GetOuterLoopExitBasicBlock()",
          "new_text": null,
          "old_line_content": "    SetToFirstInsertPoint(loops.GetOuterLoopExitBasicBlock(), &b_);",
          "new_line_content": "                                      primitive_type_size;",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "b_.getInt64(lower_dimensions)",
          "new_text": null,
          "old_line_content": "        b_.getInt64(lower_dimensions), values,",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 673,
          "old_api": "operand_count",
          "new_api": null,
          "old_text": "sort->operand_count()",
          "new_text": null,
          "old_line_content": "        b_.getInt32(sort->operand_count()), sizes,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 680,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2729,
          "old_api": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "new_api": null,
          "old_text": "ShapeUtil::ByteSizeOfPrimitiveType(primitive_type)",
          "new_text": null,
          "old_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(primitive_type);",
          "new_line_content": "                                     PrimitiveType primitive_type,",
          "content_same": false
        },
        {
          "line": 2730,
          "old_api": "tensorflow::MathUtil::GCD<unsigned>(\n      primitive_type_size, MinimumAlignmentForPrimitiveType(primitive_type))",
          "new_api": null,
          "old_text": "tensorflow::MathUtil::GCD<unsigned>(\n      primitive_type_size, MinimumAlignmentForPrimitiveType(primitive_type))",
          "new_text": null,
          "old_line_content": "  unsigned element_alignment = tensorflow::MathUtil::GCD<unsigned>(",
          "new_line_content": "                                     const llvm_ir::IrArray& target_array,",
          "content_same": false
        },
        {
          "line": 2731,
          "old_api": "MinimumAlignmentForPrimitiveType",
          "new_api": null,
          "old_text": "MinimumAlignmentForPrimitiveType(primitive_type)",
          "new_text": null,
          "old_line_content": "      primitive_type_size, MinimumAlignmentForPrimitiveType(primitive_type));",
          "new_line_content": "                                     const llvm_ir::IrArray& source_array) {",
          "content_same": false
        },
        {
          "line": 2732,
          "old_api": "llvm::PointerType::getUnqual(\n      llvm_ir::PrimitiveTypeToIrType(primitive_type, module_))",
          "new_api": null,
          "old_text": "llvm::PointerType::getUnqual(\n      llvm_ir::PrimitiveTypeToIrType(primitive_type, module_))",
          "new_text": null,
          "old_line_content": "  llvm::Type* primitive_ptr_type = llvm::PointerType::getUnqual(",
          "new_line_content": "  unsigned primitive_type_size =",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": "operands",
          "new_api": null,
          "old_text": "tuple->operands()",
          "new_text": null,
          "old_line_content": "  for (auto operand : tuple->operands()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(operand)",
          "new_text": null,
          "old_line_content": "    base_ptrs.push_back(GetEmittedValueFor(operand));",
          "new_line_content": "Status IrEmitter::HandleTuple(HloInstruction* tuple) {",
          "content_same": false
        },
        {
          "line": 689,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(tuple)",
          "new_text": null,
          "old_line_content": "  llvm_ir::EmitTuple(GetIrArrayFor(tuple), base_ptrs, &b_);",
          "new_line_content": "  std::vector<llvm::Value*> base_ptrs;",
          "content_same": false
        },
        {
          "line": 2738,
          "old_api": "AnnotateLoadStoreInstructionWithMetadata",
          "new_api": null,
          "old_text": "source_array.AnnotateLoadStoreInstructionWithMetadata(load_instruction)",
          "new_text": null,
          "old_line_content": "    source_array.AnnotateLoadStoreInstructionWithMetadata(load_instruction);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2740,
          "old_api": "BitCast",
          "new_api": null,
          "old_text": "BitCast(target, primitive_ptr_type)",
          "new_text": null,
          "old_line_content": "        AlignedStore(load_instruction, BitCast(target, primitive_ptr_type),",
          "new_line_content": "    auto* load_instruction =",
          "content_same": false
        },
        {
          "line": 696,
          "old_api": "to_apply",
          "new_api": null,
          "old_text": "map_instr.to_apply()",
          "new_text": null,
          "old_line_content": "  return EmitScalarReturningThreadLocalCall(*map_instr.to_apply(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2751,
          "old_api": "metadata",
          "new_api": null,
          "old_text": "source_array.metadata()",
          "new_text": null,
          "old_line_content": "        llvm_ir::MergeMetadata(&module_->getContext(), source_array.metadata(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 704,
          "old_api": "operand",
          "new_api": null,
          "old_text": "reduce_window->operand(0)",
          "new_text": null,
          "old_line_content": "  const HloInstruction* operand = reduce_window->operand(0);",
          "new_line_content": "StatusOr<llvm::Value*> IrEmitter::EmitElementalReduceWindow(",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": "window",
          "new_api": null,
          "old_text": "reduce_window->window()",
          "new_text": null,
          "old_line_content": "  const Window& window = reduce_window->window();",
          "new_line_content": "    const HloReduceWindowInstruction* reduce_window,",
          "content_same": false
        },
        {
          "line": 2752,
          "old_api": "metadata",
          "new_api": null,
          "old_text": "target_array.metadata()",
          "new_text": null,
          "old_line_content": "                               target_array.metadata());",
          "new_line_content": "    // The memcpy does the load and the store internally.  The aliasing related",
          "content_same": false
        },
        {
          "line": 2754,
          "old_api": "setMetadata",
          "new_api": null,
          "old_text": "memcpy_instruction->setMetadata(kind_md_pair.first, kind_md_pair.second)",
          "new_text": null,
          "old_line_content": "      memcpy_instruction->setMetadata(kind_md_pair.first, kind_md_pair.second);",
          "new_line_content": "    std::map<int, llvm::MDNode*> merged_metadata =",
          "content_same": false
        },
        {
          "line": 710,
          "old_api": "llvm_ir::EmitAllocaAtFunctionEntry(\n      llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_),\n      \"reduce_window_accumulator_address\", &b_,\n      MinimumAlignmentForPrimitiveType(operand_element_type))",
          "new_api": null,
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n      llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_),\n      \"reduce_window_accumulator_address\", &b_,\n      MinimumAlignmentForPrimitiveType(operand_element_type))",
          "new_text": null,
          "old_line_content": "  llvm::Value* accumulator_address = llvm_ir::EmitAllocaAtFunctionEntry(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": "llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_)",
          "new_api": null,
          "old_text": "llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_)",
          "new_text": null,
          "old_line_content": "      llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_),",
          "new_line_content": "  // We fold inputs into the accumulator and initialize it to",
          "content_same": false
        },
        {
          "line": 2760,
          "old_api": "operands",
          "new_api": null,
          "old_text": "concatenate->operands()",
          "new_text": null,
          "old_line_content": "  absl::Span<HloInstruction* const> operands(concatenate->operands());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2766,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "concatenate->ToString()",
          "new_text": null,
          "old_line_content": "    VLOG(1) << \"Emitted fast concatenate for \" << concatenate->ToString();",
          "new_line_content": "  TF_ASSIGN_OR_RETURN(",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "window.dimensions()",
          "new_text": null,
          "old_line_content": "  for (const auto& dim : window.dimensions()) {",
          "new_line_content": "        accumulator_address);",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": "size",
          "new_api": null,
          "old_text": "dim.size()",
          "new_text": null,
          "old_line_content": "    window_size.push_back(dim.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2767,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "    return Status::OK();",
          "new_line_content": "      bool successful,",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": "AddLoopsForShape",
          "new_api": null,
          "old_text": "loops.AddLoopsForShape(\n      ShapeUtil::MakeShape(operand_element_type, window_size), \"window\")",
          "new_text": null,
          "old_line_content": "  const llvm_ir::IrArray::Index window_index = loops.AddLoopsForShape(",
          "new_line_content": "  std::vector<int64> window_size;",
          "content_same": false
        },
        {
          "line": 2773,
          "old_api": "DefaultAction",
          "new_api": null,
          "old_text": "DefaultAction(concatenate)",
          "new_text": null,
          "old_line_content": "  return DefaultAction(concatenate);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2778,
          "old_api": "branch_count",
          "new_api": null,
          "old_text": "conditional->branch_count()",
          "new_text": null,
          "old_line_content": "  int num_branches = conditional->branch_count();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2779,
          "old_api": "shape",
          "new_api": null,
          "old_text": "branch_index->shape()",
          "new_text": null,
          "old_line_content": "  TF_RET_CHECK(ShapeUtil::IsScalar(branch_index->shape()) &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2780,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "branch_index->shape().element_type()",
          "new_text": null,
          "old_line_content": "               (branch_index->shape().element_type() == PRED ||",
          "new_line_content": "Status IrEmitter::HandleConditional(HloInstruction* conditional) {",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "NSWSub(\n        NSWAdd(strided_index,\n               NSWMul(window_index[i],\n                      b_.getInt64(window.dimensions(i).window_dilation()))),\n        b_.getInt64(window.dimensions(i).padding_low()))",
          "new_text": null,
          "old_line_content": "    input_multi_index[i] = NSWSub(",
          "new_line_content": "  llvm::Value* in_bounds_condition = nullptr;",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "NSWMul(window_index[i],\n                      b_.getInt64(window.dimensions(i).window_dilation()))",
          "new_text": null,
          "old_line_content": "               NSWMul(window_index[i],",
          "new_line_content": "    llvm::Value* strided_index =",
          "content_same": false
        },
        {
          "line": 2786,
          "old_api": "branch_computation",
          "new_api": null,
          "old_text": "conditional->branch_computation(b)",
          "new_text": null,
          "old_line_content": "    HloComputation* br_computation = conditional->branch_computation(b);",
          "new_line_content": "      << \"Branch index on a conditional must be scalar bool or int32; got: \"",
          "content_same": false
        },
        {
          "line": 2788,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "br_computation->root_instruction()->shape()",
          "new_text": null,
          "old_line_content": "                                  br_computation->root_instruction()->shape()))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "window.dimensions(i).base_dilation()",
          "new_text": null,
          "old_line_content": "                    b_.getInt64(window.dimensions(i).base_dilation())),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "b_.getInt64(0)",
          "new_text": null,
          "old_line_content": "               b_.getInt64(0));",
          "new_line_content": "    // We need to verify that we are not in the dilated base area.",
          "content_same": false
        },
        {
          "line": 2797,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "branch_index->shape().element_type()",
          "new_text": null,
          "old_line_content": "  if (branch_index->shape().element_type() == PRED) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "SDiv(input_multi_index[i],\n             b_.getInt64(window.dimensions(i).base_dilation()))",
          "new_text": null,
          "old_line_content": "        SDiv(input_multi_index[i],",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "window.dimensions(i).base_dilation()",
          "new_text": null,
          "old_line_content": "             b_.getInt64(window.dimensions(i).base_dilation()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2803,
          "old_api": "GetBasePointer",
          "new_api": null,
          "old_text": "Load(\n        GetIrArrayFor(branch_index).GetBasePointer(), \"load_predicate_value\")",
          "new_text": null,
          "old_line_content": "    llvm::LoadInst* pred_value = Load(",
          "new_line_content": "    //   if (pred)",
          "content_same": false
        },
        {
          "line": 2804,
          "old_api": "GetBasePointer",
          "new_api": null,
          "old_text": "GetIrArrayFor(branch_index).GetBasePointer()",
          "new_text": null,
          "old_line_content": "        GetIrArrayFor(branch_index).GetBasePointer(), \"load_predicate_value\");",
          "new_line_content": "    //     cond_result = true_computation(true_operand)",
          "content_same": false
        },
        {
          "line": 2806,
          "old_api": "ICmpNE",
          "new_api": null,
          "old_text": "ICmpNE(pred_value,\n               llvm::ConstantInt::get(\n                   llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0),\n               \"boolean_predicate\")",
          "new_text": null,
          "old_line_content": "        ICmpNE(pred_value,",
          "new_line_content": "    //     cond_result = false_computation(false_operand)",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "ICmpULT(input_multi_index[i],\n                b_.getInt64(ShapeUtil::GetDimension(operand->shape(), i)))",
          "new_text": null,
          "old_line_content": "        ICmpULT(input_multi_index[i],",
          "new_line_content": "    // are in the padding so that we can skip the computation. That is",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": "shape",
          "new_api": null,
          "old_text": "operand->shape()",
          "new_text": null,
          "old_line_content": "                b_.getInt64(ShapeUtil::GetDimension(operand->shape(), i)));",
          "new_line_content": "    // equivalent to input_multi_index[i] < bound as an *unsigned* comparison,",
          "content_same": false
        },
        {
          "line": 2813,
          "old_api": "SetToFirstInsertPoint",
          "new_api": null,
          "old_text": "SetToFirstInsertPoint(if_data.true_block, &b_)",
          "new_text": null,
          "old_line_content": "    SetToFirstInsertPoint(if_data.true_block, &b_);",
          "new_line_content": "               \"boolean_predicate\");",
          "content_same": false
        },
        {
          "line": 2814,
          "old_api": "branch_computation",
          "new_api": null,
          "old_text": "conditional->branch_computation(0)",
          "new_text": null,
          "old_line_content": "    EmitGlobalCall(*conditional->branch_computation(0),",
          "new_line_content": "    llvm_ir::LlvmIfData if_data =",
          "content_same": false
        },
        {
          "line": 768,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(in_bounds_condition != nullptr)",
          "new_text": null,
          "old_line_content": "  CHECK(in_bounds_condition != nullptr);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": "llvm_ir::EmitIfThenElse(in_bounds_condition, \"in-bounds\", &b_)",
          "new_api": null,
          "old_text": "llvm_ir::EmitIfThenElse(in_bounds_condition, \"in-bounds\", &b_)",
          "new_text": null,
          "old_line_content": "      llvm_ir::EmitIfThenElse(in_bounds_condition, \"in-bounds\", &b_);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": "Store",
          "new_api": null,
          "old_text": "Store(result, accumulator_address)",
          "new_text": null,
          "old_line_content": "  Store(result, accumulator_address);",
          "new_line_content": "                      input_generator(input_index));",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": "Load",
          "new_api": null,
          "old_text": "Load(accumulator_address)",
          "new_text": null,
          "old_line_content": "  return Load(accumulator_address);",
          "new_line_content": "      \"reducer_function\");",
          "content_same": false
        },
        {
          "line": 2838,
          "old_api": "GetBasePointer",
          "new_api": null,
          "old_text": "Load(\n      GetIrArrayFor(branch_index).GetBasePointer(), \"load_branch_index_value\")",
          "new_text": null,
          "old_line_content": "  llvm::LoadInst* branch_index_value = Load(",
          "new_line_content": "  //   case [[num_branches-2]]:",
          "content_same": false
        },
        {
          "line": 2839,
          "old_api": "GetBasePointer",
          "new_api": null,
          "old_text": "GetIrArrayFor(branch_index).GetBasePointer()",
          "new_text": null,
          "old_line_content": "      GetIrArrayFor(branch_index).GetBasePointer(), \"load_branch_index_value\");",
          "new_line_content": "  //     result = branch_computations[num_branches-2](operands[num_branches-2]);",
          "content_same": false
        },
        {
          "line": 2841,
          "old_api": "GetInsertBlock",
          "new_api": null,
          "old_text": "b_.GetInsertBlock()",
          "new_text": null,
          "old_line_content": "  auto case_block = b_.GetInsertBlock();",
          "new_line_content": "  // }",
          "content_same": false
        },
        {
          "line": 2844,
          "old_api": "getTerminator",
          "new_api": null,
          "old_text": "case_block->getTerminator()",
          "new_text": null,
          "old_line_content": "  if (case_block->getTerminator() == nullptr) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2846,
          "old_api": "SetInsertPoint",
          "new_api": null,
          "old_text": "b_.SetInsertPoint(case_block)",
          "new_text": null,
          "old_line_content": "    b_.SetInsertPoint(case_block);",
          "new_line_content": "  llvm::BasicBlock* after_block;",
          "content_same": false
        },
        {
          "line": 2847,
          "old_api": "CreateBr",
          "new_api": null,
          "old_text": "b_.CreateBr(after_block)",
          "new_text": null,
          "old_line_content": "    b_.CreateBr(after_block);",
          "new_line_content": "  // Add a terminator to the case block, if necessary.",
          "content_same": false
        },
        {
          "line": 802,
          "old_api": "DefaultAction",
          "new_api": null,
          "old_text": "DefaultAction(reduce_window)",
          "new_text": null,
          "old_line_content": "  return DefaultAction(reduce_window);",
          "new_line_content": "  //     output(O) = value;",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": "operand",
          "new_api": null,
          "old_text": "select_and_scatter->operand(0)",
          "new_text": null,
          "old_line_content": "  const auto operand = select_and_scatter->operand(0);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": "operand",
          "new_api": null,
          "old_text": "select_and_scatter->operand(1)",
          "new_text": null,
          "old_line_content": "  const auto source = select_and_scatter->operand(1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": "operand",
          "new_api": null,
          "old_text": "select_and_scatter->operand(2)",
          "new_text": null,
          "old_line_content": "  const auto init_value = select_and_scatter->operand(2);",
          "new_line_content": "Status IrEmitter::HandleSelectAndScatter(HloInstruction* select_and_scatter) {",
          "content_same": false
        },
        {
          "line": 2857,
          "old_api": "llvm_ir::CreateBasicBlock(nullptr, \"case-default\", &b_)",
          "new_api": null,
          "old_text": "llvm_ir::CreateBasicBlock(nullptr, \"case-default\", &b_)",
          "new_text": null,
          "old_line_content": "  auto default_block = llvm_ir::CreateBasicBlock(nullptr, \"case-default\", &b_);",
          "new_line_content": "  // we're going to replace it with a switch based branch.",
          "content_same": false
        },
        {
          "line": 2859,
          "old_api": "branch_computation",
          "new_api": null,
          "old_text": "conditional->branch_computation(num_branches - 1)",
          "new_text": null,
          "old_line_content": "  EmitGlobalCall(*conditional->branch_computation(num_branches - 1),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2860,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(conditional, \"_default\")",
          "new_text": null,
          "old_line_content": "                 IrName(conditional, \"_default\"));",
          "new_line_content": "  // Lower the default branch computation.",
          "content_same": false
        },
        {
          "line": 2866,
          "old_api": "CreateSwitch",
          "new_api": null,
          "old_text": "b_.CreateSwitch(branch_index_value, default_block, num_branches - 1)",
          "new_text": null,
          "old_line_content": "      b_.CreateSwitch(branch_index_value, default_block, num_branches - 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2871,
          "old_api": "absl::StrCat(\"case-branch\", b)",
          "new_api": null,
          "old_text": "absl::StrCat(\"case-branch\", b)",
          "new_text": null,
          "old_line_content": "        llvm_ir::CreateBasicBlock(nullptr, absl::StrCat(\"case-branch\", b), &b_);",
          "new_line_content": "  // Lower each branch's computation.",
          "content_same": false
        },
        {
          "line": 2872,
          "old_api": "SetInsertPoint",
          "new_api": null,
          "old_text": "b_.SetInsertPoint(branch_block)",
          "new_text": null,
          "old_line_content": "    b_.SetInsertPoint(branch_block);",
          "new_line_content": "  for (int b = 0; b < num_branches - 1; ++b) {  // last branch is default",
          "content_same": false
        },
        {
          "line": 2873,
          "old_api": "branch_computation",
          "new_api": null,
          "old_text": "conditional->branch_computation(b)",
          "new_text": null,
          "old_line_content": "    EmitGlobalCall(*conditional->branch_computation(b),",
          "new_line_content": "    // Lower the case b: { ... ; break; } computation.",
          "content_same": false
        },
        {
          "line": 2874,
          "old_api": "absl::StrCat(\"_branch\", b)",
          "new_api": null,
          "old_text": "absl::StrCat(\"_branch\", b)",
          "new_text": null,
          "old_line_content": "                   IrName(conditional, absl::StrCat(\"_branch\", b)));",
          "new_line_content": "    auto branch_block =",
          "content_same": false
        },
        {
          "line": 2886,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(after_all)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(after_all));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2887,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "Status IrEmitter::HandleAfterAll(HloInstruction* after_all) {",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": "EmitTargetElementLoop",
          "new_api": null,
          "old_text": "EmitTargetElementLoop(\n      select_and_scatter, /*desc=*/IrName(select_and_scatter, \"init\"),\n      [this, init_value](const llvm_ir::IrArray::Index& target_index) {\n        llvm::Value* init_value_addr = GetEmittedValueFor(init_value);\n        return Load(init_value_addr);\n      })",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetElementLoop(",
          "new_line_content": "  // }",
          "content_same": false
        },
        {
          "line": 844,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(select_and_scatter, \"init\")",
          "new_text": null,
          "old_line_content": "      select_and_scatter, /*desc=*/IrName(select_and_scatter, \"init\"),",
          "new_line_content": "  //",
          "content_same": false
        },
        {
          "line": 2893,
          "old_api": "operand",
          "new_api": null,
          "old_text": "add_dependency->operand(0)",
          "new_text": null,
          "old_line_content": "      GetEmittedValueFor(add_dependency->operand(0));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 846,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(init_value)",
          "new_text": null,
          "old_line_content": "        llvm::Value* init_value_addr = GetEmittedValueFor(init_value);",
          "new_line_content": "  // Initialize the output array with the given init_value.",
          "content_same": false
        },
        {
          "line": 2894,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "Status IrEmitter::HandleAddDependency(HloInstruction* add_dependency) {",
          "content_same": false
        },
        {
          "line": 853,
          "old_api": "shape",
          "new_api": null,
          "old_text": "source->shape()",
          "new_text": null,
          "old_line_content": "      source_loops.AddLoopsForShape(source->shape(), \"source\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 854,
          "old_api": "GetInnerLoopBodyBasicBlock",
          "new_api": null,
          "old_text": "source_loops.GetInnerLoopBodyBasicBlock()",
          "new_text": null,
          "old_line_content": "  SetToFirstInsertPoint(source_loops.GetInnerLoopBodyBasicBlock(), &b_);",
          "new_line_content": "  // Create a loop to iterate over the source array to scatter to the output.",
          "content_same": false
        },
        {
          "line": 2903,
          "old_api": "delta",
          "new_api": null,
          "old_text": "llvm_ir::RngGetAndUpdateState(\n      Cast<HloRngGetAndUpdateStateInstruction>(rng_state)->delta(), module_,\n      &b_)",
          "new_text": null,
          "old_line_content": "  llvm::Value* old_state = llvm_ir::RngGetAndUpdateState(",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2904,
          "old_api": "delta",
          "new_api": null,
          "old_text": "Cast<HloRngGetAndUpdateStateInstruction>(rng_state)->delta()",
          "new_text": null,
          "old_line_content": "      Cast<HloRngGetAndUpdateStateInstruction>(rng_state)->delta(), module_,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": "llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_)",
          "new_api": null,
          "old_text": "llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_)",
          "new_text": null,
          "old_line_content": "      llvm_ir::PrimitiveTypeToIrType(operand_element_type, module_),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": "MinimumAlignmentForPrimitiveType",
          "new_api": null,
          "old_text": "MinimumAlignmentForPrimitiveType(operand_element_type)",
          "new_text": null,
          "old_line_content": "      MinimumAlignmentForPrimitiveType(operand_element_type));",
          "new_line_content": "  // the boolean initialized_flag, which is initially set to false.",
          "content_same": false
        },
        {
          "line": 864,
          "old_api": "getInt32",
          "new_api": null,
          "old_text": "b_.getInt32(rank)",
          "new_text": null,
          "old_line_content": "          b_.getInt64Ty(), b_.getInt32(rank), \"selected_index_address\", &b_);",
          "new_line_content": "      \"selected_value_address\", &b_,",
          "content_same": false
        },
        {
          "line": 2913,
          "old_api": "getType",
          "new_api": null,
          "old_text": "old_state->getType()->getScalarType()",
          "new_text": null,
          "old_line_content": "                                 old_state->getType()->getScalarType(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": "getInt1Ty",
          "new_api": null,
          "old_text": "b_.getInt1Ty()",
          "new_text": null,
          "old_line_content": "      b_.getInt1Ty(), \"initialized_flag_address\", &b_);",
          "new_line_content": "  llvm::Value* selected_index_address =",
          "content_same": false
        },
        {
          "line": 2914,
          "old_api": "getType",
          "new_api": null,
          "old_text": "address->getType()->getPointerAddressSpace()",
          "new_text": null,
          "old_line_content": "                                 address->getType()->getPointerAddressSpace()));",
          "new_line_content": "  // The buffer has an array type while the value has a i128. Cast the",
          "content_same": false
        },
        {
          "line": 2915,
          "old_api": "Store",
          "new_api": null,
          "old_text": "Store(old_state, address)",
          "new_text": null,
          "old_line_content": "  llvm::StoreInst* store = Store(old_state, address);",
          "new_line_content": "  // buffer to i128 type to store the value.",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "window.dimensions()",
          "new_text": null,
          "old_line_content": "  for (const auto& dim : window.dimensions()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": "size",
          "new_api": null,
          "old_text": "dim.size()",
          "new_text": null,
          "old_line_content": "    window_size.push_back(dim.size());",
          "new_line_content": "  // Create the inner loop to iterate over the window.",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": "AddLoopsForShape",
          "new_api": null,
          "old_text": "window_loops.AddLoopsForShape(\n      ShapeUtil::MakeShape(operand_element_type, window_size), \"window\")",
          "new_text": null,
          "old_line_content": "  const llvm_ir::IrArray::Index window_index = window_loops.AddLoopsForShape(",
          "new_line_content": "  std::vector<int64> window_size;",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": "size",
          "new_api": null,
          "old_text": "source_index.size()",
          "new_text": null,
          "old_line_content": "  std::vector<llvm::Value*> operand_multi_index(source_index.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 883,
          "old_api": "getTrue",
          "new_api": null,
          "old_text": "b_.getTrue()",
          "new_text": null,
          "old_line_content": "  llvm::Value* in_bounds_condition = b_.getTrue();",
          "new_line_content": "  // Compute the operand index to visit and evaluate the condition whether the",
          "content_same": false
        },
        {
          "line": 2930,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "root->ToString()",
          "new_text": null,
          "old_line_content": "  VLOG(2) << \"FinishVisit root: \" << root->ToString();",
          "new_line_content": "  // the value. If the root is a constant or parameter, we perform a memcpy from",
          "content_same": false
        },
        {
          "line": 2931,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "root->opcode()",
          "new_text": null,
          "old_line_content": "  if (root->opcode() == HloOpcode::kOutfeed) {",
          "new_line_content": "  // this buffer to the retval buffer of the computation. Otherwise, there's",
          "content_same": false
        },
        {
          "line": 2932,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(2)",
          "new_text": null,
          "old_line_content": "    VLOG(2) << \"  outfeed with value: \"",
          "new_line_content": "  // nothing to do since the result was already written directly into the output",
          "content_same": false
        },
        {
          "line": 2933,
          "old_api": "operand",
          "new_api": null,
          "old_text": "root->operand(0)",
          "new_text": null,
          "old_line_content": "            << llvm_ir::DumpToString(*GetEmittedValueFor(root->operand(0)));",
          "new_line_content": "  // buffer.",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": "NSWAdd",
          "new_api": null,
          "old_text": "NSWAdd(strided_index, window_index[i])",
          "new_text": null,
          "old_line_content": "        NSWSub(NSWAdd(strided_index, window_index[i]),",
          "new_line_content": "  for (int64 i = 0; i < rank; ++i) {",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "window.dimensions(i).padding_low()",
          "new_text": null,
          "old_line_content": "               b_.getInt64(window.dimensions(i).padding_low()));",
          "new_line_content": "    llvm::Value* strided_index =",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "ICmpULT(operand_multi_index[i],\n                b_.getInt64(ShapeUtil::GetDimension(operand->shape(), i)))",
          "new_text": null,
          "old_line_content": "        ICmpULT(operand_multi_index[i],",
          "new_line_content": "    operand_multi_index[i] =",
          "content_same": false
        },
        {
          "line": 2940,
          "old_api": "RecordCompleteComputation",
          "new_api": null,
          "old_text": "profiling_state_.RecordCompleteComputation(&b_, prof_counter)",
          "new_text": null,
          "old_line_content": "      profiling_state_.RecordCompleteComputation(&b_, prof_counter);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2947,
          "old_api": "parent",
          "new_api": null,
          "old_text": "root->parent()",
          "new_text": null,
          "old_line_content": "  record_complete_computation(GetProfileCounterFor(*root->parent()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 900,
          "old_api": "llvm_ir::EmitIfThenElse(in_bounds_condition, \"in-bounds\", &b_)",
          "new_api": null,
          "old_text": "llvm_ir::EmitIfThenElse(in_bounds_condition, \"in-bounds\", &b_)",
          "new_text": null,
          "old_line_content": "      llvm_ir::EmitIfThenElse(in_bounds_condition, \"in-bounds\", &b_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 901,
          "old_api": "SetToFirstInsertPoint",
          "new_api": null,
          "old_text": "SetToFirstInsertPoint(if_in_bounds.true_block, &b_)",
          "new_text": null,
          "old_line_content": "  SetToFirstInsertPoint(if_in_bounds.true_block, &b_);",
          "new_line_content": "  // Only need to do something if the operand index is within the bounds. First",
          "content_same": false
        },
        {
          "line": 902,
          "old_api": "llvm_ir::EmitIfThenElse(\n      Load(initialized_flag_address), \"initialized\", &b_)",
          "new_api": null,
          "old_text": "llvm_ir::EmitIfThenElse(\n      Load(initialized_flag_address), \"initialized\", &b_)",
          "new_text": null,
          "old_line_content": "  llvm_ir::LlvmIfData if_initialized = llvm_ir::EmitIfThenElse(",
          "new_line_content": "  // check if the initialized_flag is set.",
          "content_same": false
        },
        {
          "line": 903,
          "old_api": "Load",
          "new_api": null,
          "old_text": "Load(initialized_flag_address)",
          "new_text": null,
          "old_line_content": "      Load(initialized_flag_address), \"initialized\", &b_);",
          "new_line_content": "  llvm_ir::LlvmIfData if_in_bounds =",
          "content_same": false
        },
        {
          "line": 2948,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  // For the entry computation this increment is cumulative of embedded",
          "content_same": false
        },
        {
          "line": 2955,
          "old_api": "find",
          "new_api": null,
          "old_text": "profile_index_map.find(&hlo)",
          "new_text": null,
          "old_line_content": "  auto it = profile_index_map.find(&hlo);",
          "new_line_content": "template <typename T>",
          "content_same": false
        },
        {
          "line": 2956,
          "old_api": "end",
          "new_api": null,
          "old_text": "profile_index_map.end()",
          "new_text": null,
          "old_line_content": "  if (it == profile_index_map.end()) {",
          "new_line_content": "llvm::Value* IrEmitter::GetProfileCounterCommon(",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": "getInt32",
          "new_api": null,
          "old_text": "b_.getInt32(i)",
          "new_text": null,
          "old_line_content": "              InBoundsGEP(selected_index_address, {b_.getInt32(i)});",
          "new_line_content": "  const auto save_operand_index =",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": "Store",
          "new_api": null,
          "old_text": "Store(operand_index[i], selected_index_address_slot)",
          "new_text": null,
          "old_line_content": "          Store(operand_index[i], selected_index_address_slot);",
          "new_line_content": "      [&](const llvm_ir::IrArray::Index& operand_index) {",
          "content_same": false
        },
        {
          "line": 2961,
          "old_api": "name",
          "new_api": null,
          "old_text": "hlo.name()",
          "new_text": null,
          "old_line_content": "  string counter_name = IrName(\"prof_counter\", hlo.name());",
          "new_line_content": "    return nullptr;",
          "content_same": false
        },
        {
          "line": 2962,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "b_.getInt64(prof_counter_idx)",
          "new_text": null,
          "old_line_content": "  return GEP(GetProfileCountersArgument(), b_.getInt64(prof_counter_idx),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 918,
          "old_api": "getInt64Ty",
          "new_api": null,
          "old_text": "b_.getInt64Ty()",
          "new_text": null,
          "old_line_content": "      operand_multi_index, operand_array.GetShape(), b_.getInt64Ty());",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": "EmitReadArrayElement",
          "new_api": null,
          "old_text": "operand_array.EmitReadArrayElement(operand_index, &b_)",
          "new_text": null,
          "old_line_content": "      operand_array.EmitReadArrayElement(operand_index, &b_);",
          "new_line_content": "  llvm_ir::IrArray operand_array(GetIrArrayFor(operand));",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": "Store",
          "new_api": null,
          "old_text": "Store(operand_data, selected_value_address)",
          "new_text": null,
          "old_line_content": "  Store(operand_data, selected_value_address);",
          "new_line_content": "  llvm_ir::IrArray::Index operand_index(",
          "content_same": false
        },
        {
          "line": 2968,
          "old_api": "GetProfileCounterCommon<HloInstruction>(instruction,\n                                                 instruction_to_profile_idx_)",
          "new_api": null,
          "old_text": "GetProfileCounterCommon<HloInstruction>(instruction,\n                                                 instruction_to_profile_idx_)",
          "new_text": null,
          "old_line_content": "  return GetProfileCounterCommon<HloInstruction>(instruction,",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 923,
          "old_api": "getInt1",
          "new_api": null,
          "old_text": "b_.getInt1(true)",
          "new_text": null,
          "old_line_content": "  Store(b_.getInt1(true), initialized_flag_address);",
          "new_line_content": "  llvm::Value* operand_data =",
          "content_same": false
        },
        {
          "line": 2974,
          "old_api": "GetProfileCounterCommon<HloComputation>(computation,\n                                                 computation_to_profile_idx_)",
          "new_api": null,
          "old_text": "GetProfileCounterCommon<HloComputation>(computation,\n                                                 computation_to_profile_idx_)",
          "new_text": null,
          "old_line_content": "  return GetProfileCounterCommon<HloComputation>(computation,",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 929,
          "old_api": "EmitArrayElementAddress",
          "new_api": null,
          "old_text": "operand_array.EmitArrayElementAddress(operand_index, &b_)",
          "new_text": null,
          "old_line_content": "      operand_array.EmitArrayElementAddress(operand_index, &b_);",
          "new_line_content": "  // If the initialized_flag is true, call the `select` function to potentially",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": "Load",
          "new_api": null,
          "old_text": "Load(operand_address)",
          "new_text": null,
          "old_line_content": "  llvm::Value* operand_element = Load(operand_address);",
          "new_line_content": "  // update the selected value and index with the currently visiting operand.",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": "select",
          "new_api": null,
          "old_text": "select_and_scatter->select()",
          "new_text": null,
          "old_line_content": "      *select_and_scatter->select(),",
          "new_line_content": "  llvm::Value* operand_address =",
          "content_same": false
        },
        {
          "line": 2982,
          "old_api": "CreateSub",
          "new_api": null,
          "old_text": "b->CreateSub(cycle_end, cycle_start)",
          "new_text": null,
          "old_line_content": "  auto* cycle_diff = b->CreateSub(cycle_end, cycle_start);",
          "new_line_content": "void IrEmitter::ProfilingState::UpdateProfileCounter(llvm::IRBuilder<>* b,",
          "content_same": false
        },
        {
          "line": 2984,
          "old_api": "CreateLoad",
          "new_api": null,
          "old_text": "b->CreateLoad(prof_counter, \"old_cycle_count\")",
          "new_text": null,
          "old_line_content": "      b->CreateLoad(prof_counter, \"old_cycle_count\");",
          "new_line_content": "                                                     llvm::Value* cycle_end,",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "new_api": null,
          "old_text": "llvm_ir::PrimitiveTypeToIrType(PRED, module_)",
          "new_text": null,
          "old_line_content": "      llvm::ConstantInt::get(llvm_ir::PrimitiveTypeToIrType(PRED, module_), 0),",
          "new_line_content": "  // If the 'select' function returns false, update the selected value and the",
          "content_same": false
        },
        {
          "line": 2987,
          "old_api": "CreateStore",
          "new_api": null,
          "old_text": "b->CreateStore(new_cycle_count, prof_counter)",
          "new_text": null,
          "old_line_content": "  b->CreateStore(new_cycle_count, prof_counter);",
          "new_line_content": "  llvm::LoadInst* old_cycle_count =",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": "llvm_ir::EmitIfThenElse(cond, \"if-select-lhs\", &b_)",
          "new_api": null,
          "old_text": "llvm_ir::EmitIfThenElse(cond, \"if-select-lhs\", &b_)",
          "new_text": null,
          "old_line_content": "      llvm_ir::EmitIfThenElse(cond, \"if-select-lhs\", &b_);",
          "new_line_content": "      result,",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": "Load",
          "new_api": null,
          "old_text": "Load(operand_address)",
          "new_text": null,
          "old_line_content": "  Store(Load(operand_address), selected_value_address);",
          "new_line_content": "      \"boolean_predicate\");",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": "save_operand_index",
          "new_api": null,
          "old_text": "save_operand_index(operand_index)",
          "new_text": null,
          "old_line_content": "  save_operand_index(operand_index);",
          "new_line_content": "  llvm_ir::LlvmIfData if_select_lhs =",
          "content_same": false
        },
        {
          "line": 2994,
          "old_api": "llvm::Intrinsic::getDeclaration(module,\n                                        llvm::Intrinsic::readcyclecounter)",
          "new_api": null,
          "old_text": "llvm::Intrinsic::getDeclaration(module,\n                                        llvm::Intrinsic::readcyclecounter)",
          "new_text": null,
          "old_line_content": "        llvm::Intrinsic::getDeclaration(module,",
          "new_line_content": "llvm::Value* IrEmitter::ProfilingState::ReadCycleCounter(llvm::IRBuilder<>* b) {",
          "content_same": false
        },
        {
          "line": 2996,
          "old_api": "CreateCall",
          "new_api": null,
          "old_text": "b->CreateCall(func_llvm_readcyclecounter)",
          "new_text": null,
          "old_line_content": "    return b->CreateCall(func_llvm_readcyclecounter);",
          "new_line_content": "  if (!use_rdtscp_) {",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": "GetOuterLoopExitBasicBlock",
          "new_api": null,
          "old_text": "window_loops.GetOuterLoopExitBasicBlock()",
          "new_text": null,
          "old_line_content": "  SetToFirstInsertPoint(window_loops.GetOuterLoopExitBasicBlock(), &b_);",
          "new_line_content": "  // After iterating over the window elements, scatter the source element to",
          "content_same": false
        },
        {
          "line": 2999,
          "old_api": "llvm::Intrinsic::getDeclaration(module, llvm::Intrinsic::x86_rdtscp)",
          "new_api": null,
          "old_text": "llvm::Intrinsic::getDeclaration(module, llvm::Intrinsic::x86_rdtscp)",
          "new_text": null,
          "old_line_content": "      llvm::Intrinsic::getDeclaration(module, llvm::Intrinsic::x86_rdtscp);",
          "new_line_content": "                                        llvm::Intrinsic::readcyclecounter);",
          "content_same": false
        },
        {
          "line": 3001,
          "old_api": "CreateExtractValue",
          "new_api": null,
          "old_text": "b->CreateExtractValue(rdtscp_call, {0})",
          "new_text": null,
          "old_line_content": "  return b->CreateExtractValue(rdtscp_call, {0});",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": "Load",
          "new_api": null,
          "old_text": "Load(selected_index_address_slot)",
          "new_text": null,
          "old_line_content": "    selected_multi_index.push_back(Load(selected_index_address_slot));",
          "new_line_content": "  std::vector<llvm::Value*> selected_multi_index;",
          "content_same": false
        },
        {
          "line": 3006,
          "old_api": "ReadCycleCounter",
          "new_api": null,
          "old_text": "ReadCycleCounter(b)",
          "new_text": null,
          "old_line_content": "  auto* cycle_start = ReadCycleCounter(b);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3007,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(hlo, \"cycle_start\")",
          "new_text": null,
          "old_line_content": "  cycle_start->setName(IrName(hlo, \"cycle_start\"));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": "GetType",
          "new_api": null,
          "old_text": "source_index.GetType()",
          "new_text": null,
          "old_line_content": "      selected_multi_index, output_array.GetShape(), source_index.GetType());",
          "new_line_content": "  llvm::Value* source_value =",
          "content_same": false
        },
        {
          "line": 965,
          "old_api": "EmitReadArrayElement",
          "new_api": null,
          "old_text": "output_array.EmitReadArrayElement(selected_index, &b_)",
          "new_text": null,
          "old_line_content": "      output_array.EmitReadArrayElement(selected_index, &b_);",
          "new_line_content": "  llvm_ir::IrArray output_array(GetIrArrayFor(select_and_scatter));",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": "scatter",
          "new_api": null,
          "old_text": "EmitScalarReturningThreadLocalCall(\n      *select_and_scatter->scatter(), {output_value, source_value},\n      \"scatter_function\")",
          "new_text": null,
          "old_line_content": "  llvm::Value* scatter_value = EmitScalarReturningThreadLocalCall(",
          "new_line_content": "  llvm_ir::IrArray::Index selected_index(",
          "content_same": false
        },
        {
          "line": 3017,
          "old_api": "ReadCycleCounter",
          "new_api": null,
          "old_text": "ReadCycleCounter(b)",
          "new_text": null,
          "old_line_content": "  auto* cycle_end = ReadCycleCounter(b);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3018,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(hlo, \"cycle_end\")",
          "new_text": null,
          "old_line_content": "  cycle_end->setName(IrName(hlo, \"cycle_end\"));",
          "new_line_content": "void IrEmitter::ProfilingState::RecordCycleDelta(llvm::IRBuilder<>* b,",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "      \"scatter_function\");",
          "content_same": false
        },
        {
          "line": 3020,
          "old_api": "UpdateProfileCounter",
          "new_api": null,
          "old_text": "UpdateProfileCounter(b, prof_counter, cycle_end, cycle_start)",
          "new_text": null,
          "old_line_content": "  UpdateProfileCounter(b, prof_counter, cycle_end, cycle_start);",
          "new_line_content": "                                                 llvm::Value* prof_counter) {",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": "operand",
          "new_api": null,
          "old_text": "dot->operand(1)",
          "new_text": null,
          "old_line_content": "  auto rhs = dot->operand(1);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "ElementTypesSameAndSupported",
          "new_api": null,
          "old_text": "ElementTypesSameAndSupported(\n      /*instruction=*/*dot, /*operands=*/{lhs, rhs},\n      /*supported_types=*/{S32, F16, F32, F64, C64, C128})",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(ElementTypesSameAndSupported(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3027,
          "old_api": "UpdateProfileCounter",
          "new_api": null,
          "old_text": "UpdateProfileCounter(b, prof_counter, last_read_cycle_end_,\n                         first_read_cycle_start_)",
          "new_text": null,
          "old_line_content": "    UpdateProfileCounter(b, prof_counter, last_read_cycle_end_,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": "lhs_contracting_dimensions_size",
          "new_api": null,
          "old_text": "dnums.lhs_contracting_dimensions_size()",
          "new_text": null,
          "old_line_content": "  if (dnums.lhs_contracting_dimensions_size() != 1) {",
          "new_line_content": "      /*instruction=*/*dot, /*operands=*/{lhs, rhs},",
          "content_same": false
        },
        {
          "line": 3039,
          "old_api": "getInt8Ty",
          "new_api": null,
          "old_text": "b->getInt8Ty()->getPointerTo()",
          "new_text": null,
          "old_line_content": "  llvm::Type* int8_ptr_type = b->getInt8Ty()->getPointerTo();",
          "new_line_content": "  if (!enabled_) {",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(dot)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(dot));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(dot)",
          "new_text": null,
          "old_line_content": "  llvm_ir::IrArray target_array = GetIrArrayFor(dot);",
          "new_line_content": "  llvm_ir::IrArray lhs_array(GetIrArrayFor(lhs));",
          "content_same": false
        },
        {
          "line": 3040,
          "old_api": "getVoidTy",
          "new_api": null,
          "old_text": "b->getVoidTy()->getPointerTo()",
          "new_text": null,
          "old_line_content": "  llvm::Type* void_ptr_type = b->getVoidTy()->getPointerTo();",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(2)",
          "new_text": null,
          "old_line_content": "  VLOG(2) << \"HandleDot: \";",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3042,
          "old_api": "getInt64Ty",
          "new_api": null,
          "old_text": "b->getInt64Ty()",
          "new_text": null,
          "old_line_content": "      llvm::FunctionType::get(b->getInt64Ty(), {void_ptr_type, int8_ptr_type},",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3045,
          "old_api": "GetInsertBlock",
          "new_api": null,
          "old_text": "b->GetInsertBlock()->getParent()",
          "new_text": null,
          "old_line_content": "  llvm::Function* function = b->GetInsertBlock()->getParent();",
          "new_line_content": "  llvm::FunctionType* fn_type =",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(2)",
          "new_text": null,
          "old_line_content": "  VLOG(2) << \"  rhs operand: \"",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3051,
          "old_api": "setCallingConv",
          "new_api": null,
          "old_text": "fn->setCallingConv(llvm::CallingConv::C)",
          "new_text": null,
          "old_line_content": "    fn->setCallingConv(llvm::CallingConv::C);",
          "new_line_content": "  const char* fn_name = runtime::kTracingStartSymbolName;",
          "content_same": false
        },
        {
          "line": 3052,
          "old_api": "setDoesNotThrow",
          "new_api": null,
          "old_text": "fn->setDoesNotThrow()",
          "new_text": null,
          "old_line_content": "    fn->setDoesNotThrow();",
          "new_line_content": "  llvm::FunctionCallee trace_func =",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": "GetExecutableRunOptionsArgument",
          "new_api": null,
          "old_text": "GetExecutableRunOptionsArgument()",
          "new_text": null,
          "old_line_content": "                          GetExecutableRunOptionsArgument(), &b_,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3058,
          "old_api": "CreateBitCast",
          "new_api": null,
          "old_text": "b->CreateBitCast(hlo_name, int8_ptr_type)",
          "new_text": null,
          "old_line_content": "                                 b->CreateBitCast(hlo_name, int8_ptr_type)});",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1015,
          "old_api": "operand",
          "new_api": null,
          "old_text": "convolution->operand(0)",
          "new_text": null,
          "old_line_content": "  const HloInstruction* lhs = convolution->operand(0);",
          "new_line_content": "    const HloConvolutionInstruction* convolution,",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": "operand",
          "new_api": null,
          "old_text": "convolution->operand(1)",
          "new_text": null,
          "old_line_content": "  const HloInstruction* rhs = convolution->operand(1);",
          "new_line_content": "    const llvm_ir::ElementGenerator& input_generator,",
          "content_same": false
        },
        {
          "line": 1017,
          "old_api": "window",
          "new_api": null,
          "old_text": "convolution->window()",
          "new_text": null,
          "old_line_content": "  const Window& window = convolution->window();",
          "new_line_content": "    const llvm_ir::ElementGenerator& kernel_generator,",
          "content_same": false
        },
        {
          "line": 3070,
          "old_api": "getVoidTy",
          "new_api": null,
          "old_text": "b->getVoidTy()->getPointerTo()",
          "new_text": null,
          "old_line_content": "  llvm::Type* void_ptr_type = b->getVoidTy()->getPointerTo();",
          "new_line_content": "  if (!enabled_) {",
          "content_same": false
        },
        {
          "line": 3072,
          "old_api": "getInt64Ty",
          "new_api": null,
          "old_text": "b->getInt64Ty()",
          "new_text": null,
          "old_line_content": "      llvm::FunctionType::get(b->getVoidTy(), {void_ptr_type, b->getInt64Ty()},",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": "output_feature_dimension",
          "new_api": null,
          "old_text": "dnums.output_feature_dimension()",
          "new_text": null,
          "old_line_content": "  llvm::Value* output_feature = index[dnums.output_feature_dimension()];",
          "new_line_content": "  std::vector<llvm::Value*> output_spatial(num_spatial_dims);",
          "content_same": false
        },
        {
          "line": 1027,
          "old_api": "output_batch_dimension",
          "new_api": null,
          "old_text": "dnums.output_batch_dimension()",
          "new_text": null,
          "old_line_content": "  llvm::Value* batch = index[dnums.output_batch_dimension()];",
          "new_line_content": "  for (int i = 0; i < num_spatial_dims; ++i) {",
          "content_same": false
        },
        {
          "line": 3075,
          "old_api": "GetInsertBlock",
          "new_api": null,
          "old_text": "b->GetInsertBlock()->getParent()",
          "new_text": null,
          "old_line_content": "  llvm::Function* function = b->GetInsertBlock()->getParent();",
          "new_line_content": "  llvm::FunctionType* fn_type =",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": "llvm_ir::PrimitiveTypeToIrType(lhs_element_type, module_)",
          "new_api": null,
          "old_text": "llvm_ir::PrimitiveTypeToIrType(lhs_element_type, module_)",
          "new_text": null,
          "old_line_content": "      llvm_ir::PrimitiveTypeToIrType(lhs_element_type, module_);",
          "new_line_content": "  // We will accumulate the products into this sum to calculate the output entry",
          "content_same": false
        },
        {
          "line": 3081,
          "old_api": "setCallingConv",
          "new_api": null,
          "old_text": "fn->setCallingConv(llvm::CallingConv::C)",
          "new_text": null,
          "old_line_content": "    fn->setCallingConv(llvm::CallingConv::C);",
          "new_line_content": "  const char* fn_name = runtime::kTracingEndSymbolName;",
          "content_same": false
        },
        {
          "line": 3082,
          "old_api": "setDoesNotThrow",
          "new_api": null,
          "old_text": "fn->setDoesNotThrow()",
          "new_text": null,
          "old_line_content": "    fn->setDoesNotThrow();",
          "new_line_content": "  llvm::FunctionCallee trace_func =",
          "content_same": false
        },
        {
          "line": 1036,
          "old_api": "getFloatTy",
          "new_api": null,
          "old_text": "b_.getFloatTy()",
          "new_text": null,
          "old_line_content": "      lhs_element_type == F16 ? b_.getFloatTy() : lhs_llvm_type;",
          "new_line_content": "  llvm::Type* lhs_llvm_type =",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": "MinimumAlignmentForPrimitiveType",
          "new_api": null,
          "old_text": "MinimumAlignmentForPrimitiveType(lhs_element_type)",
          "new_text": null,
          "old_line_content": "      MinimumAlignmentForPrimitiveType(lhs_element_type));",
          "new_line_content": "  llvm::Type* accumulator_type =",
          "content_same": false
        },
        {
          "line": 3092,
          "old_api": "count",
          "new_api": null,
          "old_text": "instruction_to_profile_idx_.count(hlo)",
          "new_text": null,
          "old_line_content": "  if (instruction_to_profile_idx_.count(hlo)) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3094,
          "old_api": "EmitTracingStart",
          "new_api": null,
          "old_text": "tracing_state_.EmitTracingStart(&b_, hlo,\n                                    GetExecutableRunOptionsArgument())",
          "new_text": null,
          "old_line_content": "    tracing_state_.EmitTracingStart(&b_, hlo,",
          "new_line_content": "Status IrEmitter::Preprocess(HloInstruction* hlo) {",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": "kernel_spatial_dimensions",
          "new_api": null,
          "old_text": "dnums.kernel_spatial_dimensions(i)",
          "new_text": null,
          "old_line_content": "                0, rhs->shape().dimensions(dnums.kernel_spatial_dimensions(i)),",
          "new_line_content": "  for (int i = 0; i < num_spatial_dims; ++i) {",
          "content_same": false
        },
        {
          "line": 1050,
          "old_api": "absl::StrCat(\"k\", i)",
          "new_api": null,
          "old_text": "absl::StrCat(\"k\", i)",
          "new_text": null,
          "old_line_content": "                absl::StrCat(\"k\", i))",
          "new_line_content": "    kernel_spatial[i] =",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": "input_feature_dimension",
          "new_api": null,
          "old_text": "dnums.input_feature_dimension()",
          "new_text": null,
          "old_line_content": "          .AddLoop(0, lhs->shape().dimensions(dnums.input_feature_dimension()),",
          "new_line_content": "            ->GetIndVarValue();",
          "content_same": false
        },
        {
          "line": 3103,
          "old_api": "RecordCycleDelta",
          "new_api": null,
          "old_text": "profiling_state_.RecordCycleDelta(&b_, hlo, prof_counter)",
          "new_text": null,
          "old_line_content": "    profiling_state_.RecordCycleDelta(&b_, hlo, prof_counter);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3109,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "  // Only trace the same HLOs that the profiler does.",
          "content_same": false
        },
        {
          "line": 3115,
          "old_api": "shape",
          "new_api": null,
          "old_text": "hlo->shape()",
          "new_text": null,
          "old_line_content": "  llvm_ir::IrArray array(value_for_op, hlo->shape());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1068,
          "old_api": "stride",
          "new_api": null,
          "old_text": "window_dim.stride()",
          "new_text": null,
          "old_line_content": "        NSWMul(output_index, b_.getInt64(window_dim.stride()));",
          "new_line_content": "  const auto calculate_input_index = [this](llvm::Value* output_index,",
          "content_same": false
        },
        {
          "line": 3116,
          "old_api": "AddAliasingInformationToIrArray",
          "new_api": null,
          "old_text": "AddAliasingInformationToIrArray(*hlo, &array)",
          "new_text": null,
          "old_line_content": "  AddAliasingInformationToIrArray(*hlo, &array);",
          "new_line_content": "llvm_ir::IrArray IrEmitter::GetIrArrayFor(const HloInstruction* hlo) {",
          "content_same": false
        },
        {
          "line": 1070,
          "old_api": "window_dilation",
          "new_api": null,
          "old_text": "window_dim.window_dilation()",
          "new_text": null,
          "old_line_content": "        NSWMul(kernel_index, b_.getInt64(window_dim.window_dilation()));",
          "new_line_content": "                                            const WindowDimension& window_dim) {",
          "content_same": false
        },
        {
          "line": 1071,
          "old_api": "NSWAdd",
          "new_api": null,
          "old_text": "NSWAdd(strided_index, dilated_kernel_index)",
          "new_text": null,
          "old_line_content": "    return NSWSub(NSWAdd(strided_index, dilated_kernel_index),",
          "new_line_content": "    llvm::Value* strided_index =",
          "content_same": false
        },
        {
          "line": 3123,
          "old_api": "begin",
          "new_api": null,
          "old_text": "std::transform(\n      hlo->operands().begin(), hlo->operands().end(),\n      std::back_inserter(arrays),\n      [&](const HloInstruction* operand) { return GetIrArrayFor(operand); })",
          "new_text": null,
          "old_line_content": "  std::transform(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3124,
          "old_api": "end",
          "new_api": null,
          "old_text": "hlo->operands().end()",
          "new_text": null,
          "old_line_content": "      hlo->operands().begin(), hlo->operands().end(),",
          "new_line_content": "std::vector<llvm_ir::IrArray> IrEmitter::GetIrArraysForOperandsOf(",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "window.dimensions(i)",
          "new_text": null,
          "old_line_content": "        output_spatial[i], kernel_spatial[i], window.dimensions(i));",
          "new_line_content": "  };",
          "content_same": false
        },
        {
          "line": 3125,
          "old_api": "std::back_inserter(arrays)",
          "new_api": null,
          "old_text": "std::back_inserter(arrays)",
          "new_text": null,
          "old_line_content": "      std::back_inserter(arrays),",
          "new_line_content": "    const HloInstruction* hlo) {",
          "content_same": false
        },
        {
          "line": 3126,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(operand)",
          "new_text": null,
          "old_line_content": "      [&](const HloInstruction* operand) { return GetIrArrayFor(operand); });",
          "new_line_content": "  std::vector<llvm_ir::IrArray> arrays;",
          "content_same": false
        },
        {
          "line": 3131,
          "old_api": "find",
          "new_api": null,
          "old_text": "emitted_value_.find(hlo)",
          "new_text": null,
          "old_line_content": "  auto it = emitted_value_.find(hlo);",
          "new_line_content": "  return arrays;",
          "content_same": false
        },
        {
          "line": 3132,
          "old_api": "end",
          "new_api": null,
          "old_text": "emitted_value_.end()",
          "new_text": null,
          "old_line_content": "  if (it == emitted_value_.end()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3133,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "hlo->ToString()",
          "new_text": null,
          "old_line_content": "    LOG(FATAL) << \"could not find emitted value for: \" << hlo->ToString();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1089,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "b_.getInt64(base_dilation)",
          "new_text": null,
          "old_line_content": "    llvm::Value* remainder = SRem(input_index, b_.getInt64(base_dilation));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1090,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "b_.getInt64(0)",
          "new_text": null,
          "old_line_content": "    return ICmpEQ(remainder, b_.getInt64(0));",
          "new_line_content": "  // Also need to check that the input coordinates are not in one of the",
          "content_same": false
        },
        {
          "line": 3139,
          "old_api": "llvm_ir::ShapeToIrType(shape, module_)",
          "new_api": null,
          "old_text": "llvm_ir::ShapeToIrType(shape, module_)",
          "new_text": null,
          "old_line_content": "  return llvm_ir::ShapeToIrType(shape, module_);",
          "new_line_content": "  return it->second;",
          "content_same": false
        },
        {
          "line": 1095,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "window_util::DilatedBound(\n        lhs->shape().dimensions(dnums.input_spatial_dimensions(i)),\n        window.dimensions(i).base_dilation())",
          "new_text": null,
          "old_line_content": "    llvm::ConstantInt* input_bound = b_.getInt64(window_util::DilatedBound(",
          "new_line_content": "  };",
          "content_same": false
        },
        {
          "line": 1096,
          "old_api": "input_spatial_dimensions",
          "new_api": null,
          "old_text": "dnums.input_spatial_dimensions(i)",
          "new_text": null,
          "old_line_content": "        lhs->shape().dimensions(dnums.input_spatial_dimensions(i)),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1098,
          "old_api": "ICmpULT",
          "new_api": null,
          "old_text": "ICmpULT(input_spatial[i], input_bound)",
          "new_text": null,
          "old_line_content": "    llvm::Value* dim_in_bound = ICmpULT(input_spatial[i], input_bound);",
          "new_line_content": "  for (int i = 0; i < num_spatial_dims; ++i) {",
          "content_same": false
        },
        {
          "line": 1108,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "b_.getInt64(base_dilation)",
          "new_text": null,
          "old_line_content": "    return SDiv(input_index, b_.getInt64(base_dilation));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3156,
          "old_api": "allocation",
          "new_api": null,
          "old_text": "slice.allocation()",
          "new_text": null,
          "old_line_content": "  const BufferAllocation& allocation = *slice.allocation();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3157,
          "old_api": "find",
          "new_api": null,
          "old_text": "() -> llvm::Value* {\n    auto param_it =\n        computation_parameter_allocations_.find(slice.allocation()->index());\n    if (param_it != computation_parameter_allocations_.end()) {\n      int64 param_number = param_it->second;\n      // We have to access the parameter at offset param_number in the params\n      // array. The code generated here is equivalent to this C code:\n      //\n      //   i8* param_address_untyped = params[param_number];\n      //   Param* param_address_typed = (Param*)param_address_untyped;\n      //\n      // Where Param is the actual element type of the underlying buffer (for\n      // example, float for an XLA F32 element type).\n      llvm::Value* params = compute_function_->parameters_arg();\n      llvm::Value* param_address_offset =\n          llvm_ir::EmitBufferIndexingGEP(params, param_number, &b_);\n      llvm::LoadInst* param_address_untyped = Load(param_address_offset);\n\n      if (!target_shape.IsOpaque()) {\n        AttachAlignmentMetadataForLoad(param_address_untyped, target_shape);\n        AttachDereferenceableMetadataForLoad(param_address_untyped,\n                                             target_shape);\n      }\n      return param_address_untyped;\n    }\n\n    // Thread-local allocations should only be assigned a single buffer.\n    const auto& assigned_buffers = allocation.assigned_buffers();\n    CHECK_EQ(1, assigned_buffers.size());\n    const Shape& shape = assigned_buffers.begin()->first->shape();\n\n    std::pair<llvm::Function*, BufferAllocation::Slice> key = {\n        compute_function_->function(), slice};\n    auto buf_it = thread_local_buffers_.find(key);\n    if (buf_it == thread_local_buffers_.end()) {\n      llvm::Value* buffer = llvm_ir::EmitAllocaAtFunctionEntry(\n          IrShapeType(shape), absl::StrCat(\"thread_local\", slice.ToString()),\n          &b_, MinimumAlignmentForShape(target_shape));\n      auto it_inserted_pair = thread_local_buffers_.insert({key, buffer});\n      CHECK(it_inserted_pair.second);\n      buf_it = it_inserted_pair.first;\n    }\n    return buf_it->second;\n  }()",
          "new_text": null,
          "old_line_content": "  llvm::Value* tempbuf_address = [&]() -> llvm::Value* {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3159,
          "old_api": "allocation",
          "new_api": null,
          "old_text": "slice.allocation()->index()",
          "new_text": null,
          "old_line_content": "        computation_parameter_allocations_.find(slice.allocation()->index());",
          "new_line_content": "    const BufferAllocation::Slice& slice, const Shape& target_shape) {",
          "content_same": false
        },
        {
          "line": 1117,
          "old_api": "SetToFirstInsertPoint",
          "new_api": null,
          "old_text": "SetToFirstInsertPoint(if_data.true_block, &b_)",
          "new_text": null,
          "old_line_content": "  SetToFirstInsertPoint(if_data.true_block, &b_);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3170,
          "old_api": "parameters_arg",
          "new_api": null,
          "old_text": "compute_function_->parameters_arg()",
          "new_text": null,
          "old_line_content": "      llvm::Value* params = compute_function_->parameters_arg();",
          "new_line_content": "      //   Param* param_address_typed = (Param*)param_address_untyped;",
          "content_same": false
        },
        {
          "line": 1123,
          "old_api": "input_spatial_dimensions",
          "new_api": null,
          "old_text": "dnums.input_spatial_dimensions(i)",
          "new_text": null,
          "old_line_content": "    input_multi_index[dnums.input_spatial_dimensions(i)] = input_spatial[i];",
          "new_line_content": "  // We are not in the padding, so carry out the computation.",
          "content_same": false
        },
        {
          "line": 3172,
          "old_api": "llvm_ir::EmitBufferIndexingGEP(params, param_number, &b_)",
          "new_api": null,
          "old_text": "llvm_ir::EmitBufferIndexingGEP(params, param_number, &b_)",
          "new_text": null,
          "old_line_content": "          llvm_ir::EmitBufferIndexingGEP(params, param_number, &b_);",
          "new_line_content": "      // Where Param is the actual element type of the underlying buffer (for",
          "content_same": false
        },
        {
          "line": 1125,
          "old_api": "input_feature_dimension",
          "new_api": null,
          "old_text": "dnums.input_feature_dimension()",
          "new_text": null,
          "old_line_content": "  input_multi_index[dnums.input_feature_dimension()] = input_feature;",
          "new_line_content": "  std::vector<llvm::Value*> input_multi_index(num_dims);",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": "input_batch_dimension",
          "new_api": null,
          "old_text": "dnums.input_batch_dimension()",
          "new_text": null,
          "old_line_content": "  input_multi_index[dnums.input_batch_dimension()] = batch;",
          "new_line_content": "  for (int i = 0; i < num_spatial_dims; ++i) {",
          "content_same": false
        },
        {
          "line": 3173,
          "old_api": "Load",
          "new_api": null,
          "old_text": "Load(param_address_offset)",
          "new_text": null,
          "old_line_content": "      llvm::LoadInst* param_address_untyped = Load(param_address_offset);",
          "new_line_content": "      // example, float for an XLA F32 element type).",
          "content_same": false
        },
        {
          "line": 3175,
          "old_api": "IsOpaque",
          "new_api": null,
          "old_text": "target_shape.IsOpaque()",
          "new_text": null,
          "old_line_content": "      if (!target_shape.IsOpaque()) {",
          "new_line_content": "      llvm::Value* param_address_offset =",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "window.dimensions(i).window_reversal()",
          "new_text": null,
          "old_line_content": "        window.dimensions(i).window_reversal()",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "window.dimensions(i).size()",
          "new_text": null,
          "old_line_content": "            ? NSWSub(b_.getInt64(window.dimensions(i).size() - 1),",
          "new_line_content": "  std::vector<llvm::Value*> kernel_multi_index(num_dims);",
          "content_same": false
        },
        {
          "line": 3184,
          "old_api": "assigned_buffers",
          "new_api": null,
          "old_text": "allocation.assigned_buffers()",
          "new_text": null,
          "old_line_content": "    const auto& assigned_buffers = allocation.assigned_buffers();",
          "new_line_content": "      return param_address_untyped;",
          "content_same": false
        },
        {
          "line": 1137,
          "old_api": "kernel_input_feature_dimension",
          "new_api": null,
          "old_text": "dnums.kernel_input_feature_dimension()",
          "new_text": null,
          "old_line_content": "  kernel_multi_index[dnums.kernel_input_feature_dimension()] = input_feature;",
          "new_line_content": "                     kernel_spatial[i])",
          "content_same": false
        },
        {
          "line": 1138,
          "old_api": "kernel_output_feature_dimension",
          "new_api": null,
          "old_text": "dnums.kernel_output_feature_dimension()",
          "new_text": null,
          "old_line_content": "  kernel_multi_index[dnums.kernel_output_feature_dimension()] = output_feature;",
          "new_line_content": "            : kernel_spatial[i];",
          "content_same": false
        },
        {
          "line": 3185,
          "old_api": "size",
          "new_api": null,
          "old_text": "assigned_buffers.size()",
          "new_text": null,
          "old_line_content": "    CHECK_EQ(1, assigned_buffers.size());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1140,
          "old_api": "shape",
          "new_api": null,
          "old_text": "lhs->shape()",
          "new_text": null,
          "old_line_content": "  llvm_ir::IrArray::Index input_index(input_multi_index, lhs->shape(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3186,
          "old_api": "begin",
          "new_api": null,
          "old_text": "assigned_buffers.begin()->first->shape()",
          "new_text": null,
          "old_line_content": "    const Shape& shape = assigned_buffers.begin()->first->shape();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3191,
          "old_api": "end",
          "new_api": null,
          "old_text": "thread_local_buffers_.end()",
          "new_text": null,
          "old_line_content": "    if (buf_it == thread_local_buffers_.end()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3192,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n          IrShapeType(shape), absl::StrCat(\"thread_local\", slice.ToString()),\n          &b_, MinimumAlignmentForShape(target_shape))",
          "new_text": null,
          "old_line_content": "      llvm::Value* buffer = llvm_ir::EmitAllocaAtFunctionEntry(",
          "new_line_content": "    std::pair<llvm::Function*, BufferAllocation::Slice> key = {",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": "Store",
          "new_api": null,
          "old_text": "Store(sum, sum_address)",
          "new_text": null,
          "old_line_content": "  Store(sum, sum_address);",
          "new_line_content": "  TF_ASSIGN_OR_RETURN(llvm::Value* const kernel_value,",
          "content_same": false
        },
        {
          "line": 3201,
          "old_api": "getPointerTo",
          "new_api": null,
          "old_text": "IrShapeType(target_shape)->getPointerTo()",
          "new_text": null,
          "old_line_content": "  return BitCast(tempbuf_address, IrShapeType(target_shape)->getPointerTo());",
          "new_line_content": "      buf_it = it_inserted_pair.first;",
          "content_same": false
        },
        {
          "line": 1158,
          "old_api": "operand",
          "new_api": null,
          "old_text": "convolution->operand(1)",
          "new_text": null,
          "old_line_content": "  auto rhs = convolution->operand(1);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": "ElementTypesSameAndSupported",
          "new_api": null,
          "old_text": "ElementTypesSameAndSupported(\n      /*instruction=*/*convolution, /*operands=*/{lhs, rhs},\n      /*supported_types=*/{F16, F32, F64, C64, C128})",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(ElementTypesSameAndSupported(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3206,
          "old_api": "allocation",
          "new_api": null,
          "old_text": "slice.allocation()",
          "new_text": null,
          "old_line_content": "  const BufferAllocation& allocation = *slice.allocation();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3207,
          "old_api": "index",
          "new_api": null,
          "old_text": "llvm_ir::EmitBufferIndexingGEP(\n      GetBufferTableArgument(), slice.index(), &b_)",
          "new_text": null,
          "old_line_content": "  llvm::Value* tempbuf_address_ptr = llvm_ir::EmitBufferIndexingGEP(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3208,
          "old_api": "index",
          "new_api": null,
          "old_text": "slice.index()",
          "new_text": null,
          "old_line_content": "      GetBufferTableArgument(), slice.index(), &b_);",
          "new_line_content": "llvm::Value* IrEmitter::EmitGlobalBufferPointer(",
          "content_same": false
        },
        {
          "line": 3209,
          "old_api": "Load",
          "new_api": null,
          "old_text": "Load(tempbuf_address_ptr)",
          "new_text": null,
          "old_line_content": "  llvm::LoadInst* tempbuf_address_base = Load(tempbuf_address_ptr);",
          "new_line_content": "    const BufferAllocation::Slice& slice, const Shape& target_shape) {",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": "PotentiallyImplementedAsEigenConvolution",
          "new_api": null,
          "old_text": "PotentiallyImplementedAsEigenConvolution(*convolution,\n                                               target_machine_features_)",
          "new_text": null,
          "old_line_content": "  if (PotentiallyImplementedAsEigenConvolution(*convolution,",
          "new_line_content": "      /*supported_types=*/{F16, F32, F64, C64, C128}));",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": "shape",
          "new_api": null,
          "old_text": "lhs->shape()",
          "new_text": null,
          "old_line_content": "    const Shape& lhs_shape = lhs->shape();",
          "new_line_content": "  // TODO(tonywy): Add PotentiallyImplementedAsMKLConvolution to support",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": "shape",
          "new_api": null,
          "old_text": "rhs->shape()",
          "new_text": null,
          "old_line_content": "    const Shape& rhs_shape = rhs->shape();",
          "new_line_content": "  // different data layouts.",
          "content_same": false
        },
        {
          "line": 3217,
          "old_api": "size",
          "new_api": null,
          "old_text": "allocation.size()",
          "new_text": null,
          "old_line_content": "  AttachDereferenceableMetadataForLoad(tempbuf_address_base, allocation.size());",
          "new_line_content": "        llvm::LLVMContext::MD_invariant_load,",
          "content_same": false
        },
        {
          "line": 3223,
          "old_api": "offset",
          "new_api": null,
          "old_text": "slice.offset()",
          "new_text": null,
          "old_line_content": "        InBoundsGEP(tempbuf_address_base, b_.getInt64(slice.offset()));",
          "new_line_content": "  llvm::Value* tempbuf_address_untyped = tempbuf_address_base;",
          "content_same": false
        },
        {
          "line": 3225,
          "old_api": "getPointerTo",
          "new_api": null,
          "old_text": "BitCast(tempbuf_address_untyped,\n                 IrShapeType(target_shape)->getPointerTo())",
          "new_text": null,
          "old_line_content": "  return BitCast(tempbuf_address_untyped,",
          "new_line_content": "    // Adjust the address to account for the slice offset.",
          "content_same": false
        },
        {
          "line": 1178,
          "old_api": "dimensions_size",
          "new_api": null,
          "old_text": "lhs_shape.dimensions_size()",
          "new_text": null,
          "old_line_content": "      bool one_dim_convolution = lhs_shape.dimensions_size() == 3;",
          "new_line_content": "      // We lower 1D convolutions into calls to the same Eigen function as 2D",
          "content_same": false
        },
        {
          "line": 1179,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(lhs)",
          "new_text": null,
          "old_line_content": "      llvm::Value* lhs_address = GetEmittedValueFor(lhs);",
          "new_line_content": "      // convolutions, except that we pretend that the 1D convolution is really",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(rhs)",
          "new_text": null,
          "old_line_content": "      llvm::Value* rhs_address = GetEmittedValueFor(rhs);",
          "new_line_content": "      // a 2D convolution with the missing dimension set to 1.  We also adjust",
          "content_same": false
        },
        {
          "line": 1181,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(convolution)",
          "new_text": null,
          "old_line_content": "      TF_RETURN_IF_ERROR(EmitTargetAddressForOp(convolution));",
          "new_line_content": "      // the padding, dilation parameters as needed.",
          "content_same": false
        },
        {
          "line": 3226,
          "old_api": "getPointerTo",
          "new_api": null,
          "old_text": "IrShapeType(target_shape)->getPointerTo()",
          "new_text": null,
          "old_line_content": "                 IrShapeType(target_shape)->getPointerTo());",
          "new_line_content": "    tempbuf_address_untyped =",
          "content_same": false
        },
        {
          "line": 3231,
          "old_api": "allocation",
          "new_api": null,
          "old_text": "slice.allocation()->is_thread_local()",
          "new_text": null,
          "old_line_content": "  if (slice.allocation()->is_thread_local()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3232,
          "old_api": "EmitThreadLocalBufferPointer",
          "new_api": null,
          "old_text": "EmitThreadLocalBufferPointer(slice, target_shape)",
          "new_text": null,
          "old_line_content": "    return EmitThreadLocalBufferPointer(slice, target_shape);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3233,
          "old_api": "allocation",
          "new_api": null,
          "old_text": "slice.allocation()->is_constant()",
          "new_text": null,
          "old_line_content": "  } else if (slice.allocation()->is_constant()) {",
          "new_line_content": "llvm::Value* IrEmitter::EmitBufferPointer(const BufferAllocation::Slice& slice,",
          "content_same": false
        },
        {
          "line": 3234,
          "old_api": "allocation",
          "new_api": null,
          "old_text": "BitCast(\n        FindOrDie(constant_buffer_to_global_, slice.allocation()->index()),\n        IrShapeType(target_shape)->getPointerTo())",
          "new_text": null,
          "old_line_content": "    return BitCast(",
          "new_line_content": "                                          const Shape& target_shape) {",
          "content_same": false
        },
        {
          "line": 1187,
          "old_api": "operand",
          "new_api": null,
          "old_text": "convolution->operand(0)->shape()",
          "new_text": null,
          "old_line_content": "      const Shape& input_shape = convolution->operand(0)->shape();",
          "new_line_content": "      const ConvolutionDimensionNumbers& dnums =",
          "content_same": false
        },
        {
          "line": 1190,
          "old_api": "input_spatial_dimensions",
          "new_api": null,
          "old_text": "dnums.input_spatial_dimensions(0)",
          "new_text": null,
          "old_line_content": "          input_shape.dimensions(dnums.input_spatial_dimensions(0));",
          "new_line_content": "      // Input tensor.",
          "content_same": false
        },
        {
          "line": 3243,
          "old_api": "shape",
          "new_api": null,
          "old_text": "op->shape()",
          "new_text": null,
          "old_line_content": "  const Shape& target_shape = op->shape();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1196,
          "old_api": "input_feature_dimension",
          "new_api": null,
          "old_text": "dnums.input_feature_dimension()",
          "new_text": null,
          "old_line_content": "          input_shape.dimensions(dnums.input_feature_dimension());",
          "new_line_content": "          one_dim_convolution",
          "content_same": false
        },
        {
          "line": 3246,
          "old_api": "EmitBufferPointer",
          "new_api": null,
          "old_text": "EmitBufferPointer(slice, target_shape)",
          "new_text": null,
          "old_line_content": "  llvm::Value* addr = EmitBufferPointer(slice, target_shape);",
          "new_line_content": "Status IrEmitter::EmitTargetAddressForOp(const HloInstruction* op) {",
          "content_same": false
        },
        {
          "line": 1199,
          "old_api": "operand",
          "new_api": null,
          "old_text": "convolution->operand(1)->shape()",
          "new_text": null,
          "old_line_content": "      const Shape& kernel_shape = convolution->operand(1)->shape();",
          "new_line_content": "      int64 input_channels =",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": "kernel_spatial_dimensions",
          "new_api": null,
          "old_text": "dnums.kernel_spatial_dimensions(0)",
          "new_text": null,
          "old_line_content": "          kernel_shape.dimensions(dnums.kernel_spatial_dimensions(0));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3249,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "                      assignment_.GetUniqueTopLevelSlice(op));",
          "content_same": false
        },
        {
          "line": 1207,
          "old_api": "kernel_input_feature_dimension",
          "new_api": null,
          "old_text": "dnums.kernel_input_feature_dimension()",
          "new_text": null,
          "old_line_content": "          kernel_shape.dimensions(dnums.kernel_input_feature_dimension());",
          "new_line_content": "          one_dim_convolution",
          "content_same": false
        },
        {
          "line": 3255,
          "old_api": "EmitTargetElementLoop",
          "new_api": null,
          "old_text": "EmitTargetElementLoop(target_op, /*desc=*/\"\", element_generator)",
          "new_text": null,
          "old_line_content": "  return EmitTargetElementLoop(target_op, /*desc=*/\"\", element_generator);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1212,
          "old_api": "shape",
          "new_api": null,
          "old_text": "convolution->shape()",
          "new_text": null,
          "old_line_content": "      const Shape& convolution_shape = convolution->shape();",
          "new_line_content": "      int64 kernel_filters =",
          "content_same": false
        },
        {
          "line": 3261,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "target_op->ToString()",
          "new_text": null,
          "old_line_content": "  VLOG(2) << \"EmitTargetElementLoop: \" << target_op->ToString();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": "output_spatial_dimensions",
          "new_api": null,
          "old_text": "dnums.output_spatial_dimensions(0)",
          "new_text": null,
          "old_line_content": "          convolution_shape.dimensions(dnums.output_spatial_dimensions(0));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3263,
          "old_api": "shape",
          "new_api": null,
          "old_text": "target_op->shape()",
          "new_text": null,
          "old_line_content": "  const Shape& target_shape = target_op->shape();",
          "new_line_content": "    HloInstruction* target_op, absl::string_view desc,",
          "content_same": false
        },
        {
          "line": 3264,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(target_op)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(target_op));",
          "new_line_content": "    const llvm_ir::ElementGenerator& element_generator) {",
          "content_same": false
        },
        {
          "line": 1217,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "convolution_shape.dimensions(\n                                    dnums.output_spatial_dimensions(1))",
          "new_text": null,
          "old_line_content": "                              : convolution_shape.dimensions(",
          "new_line_content": "      int64 output_rows =",
          "content_same": false
        },
        {
          "line": 3270,
          "old_api": "TF_RET_CHECK",
          "new_api": null,
          "old_text": "TF_RET_CHECK(num_dynamic_loop_bounds_ == 0)",
          "new_text": null,
          "old_line_content": "    TF_RET_CHECK(num_dynamic_loop_bounds_ == 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1224,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "window.dimensions(1).stride()",
          "new_text": null,
          "old_line_content": "          one_dim_convolution ? 1 : window.dimensions(1).stride();",
          "new_line_content": "      // Extract the window stride for the convolution.",
          "content_same": false
        },
        {
          "line": 1227,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "window.dimensions(0).padding_high()",
          "new_text": null,
          "old_line_content": "      int64 padding_bottom = window.dimensions(0).padding_high();",
          "new_line_content": "      int64 col_stride =",
          "content_same": false
        },
        {
          "line": 3275,
          "old_api": "ShapeUtil::GetSubshape(target_shape, {i})",
          "new_api": null,
          "old_text": "ShapeUtil::GetSubshape(target_shape, {i})",
          "new_text": null,
          "old_line_content": "      const Shape& element_shape = ShapeUtil::GetSubshape(target_shape, {i});",
          "new_line_content": "    std::vector<llvm_ir::IrArray> output_arrays;",
          "content_same": false
        },
        {
          "line": 1229,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "window.dimensions(1).padding_low()",
          "new_text": null,
          "old_line_content": "          one_dim_convolution ? 0 : window.dimensions(1).padding_low();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3277,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "output_arrays.push_back(\n          llvm_ir::IrArray(op_target_address, element_shape))",
          "new_text": null,
          "old_line_content": "      output_arrays.push_back(",
          "new_line_content": "      TF_ASSIGN_OR_RETURN(BufferAllocation::Slice slice,",
          "content_same": false
        },
        {
          "line": 3278,
          "old_api": "llvm_ir::IrArray(op_target_address, element_shape)",
          "new_api": null,
          "old_text": "llvm_ir::IrArray(op_target_address, element_shape)",
          "new_text": null,
          "old_line_content": "          llvm_ir::IrArray(op_target_address, element_shape));",
          "new_line_content": "                          assignment_.GetUniqueSlice(target_op, {i}));",
          "content_same": false
        },
        {
          "line": 1236,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "window.dimensions(0).window_dilation()",
          "new_text": null,
          "old_line_content": "      int64 rhs_row_dilation = window.dimensions(0).window_dilation();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1238,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "window.dimensions(1).window_dilation()",
          "new_text": null,
          "old_line_content": "          one_dim_convolution ? 1 : window.dimensions(1).window_dilation();",
          "new_line_content": "      int64 lhs_col_dilation =",
          "content_same": false
        },
        {
          "line": 3288,
          "old_api": "llvm_ir::EmitTuple(target_array, tuple_operand_ptrs, &b_)",
          "new_api": null,
          "old_text": "llvm_ir::EmitTuple(target_array, tuple_operand_ptrs, &b_)",
          "new_text": null,
          "old_line_content": "    llvm_ir::EmitTuple(target_array, tuple_operand_ptrs, &b_);",
          "new_line_content": "    std::vector<llvm::Value*> tuple_operand_ptrs;",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": "getFloatTy",
          "new_api": null,
          "old_text": "b_.getFloatTy()->getPointerTo()",
          "new_text": null,
          "old_line_content": "                                    : b_.getFloatTy()->getPointerTo();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3291,
          "old_api": "ShouldEmitParallelLoopFor",
          "new_api": null,
          "old_text": "ShouldEmitParallelLoopFor(*target_op)",
          "new_text": null,
          "old_line_content": "    if (ShouldEmitParallelLoopFor(*target_op)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": "getInt8Ty",
          "new_api": null,
          "old_text": "b_.getInt8Ty()->getPointerTo()",
          "new_text": null,
          "old_line_content": "      llvm::Type* int8_ptr_type = b_.getInt8Ty()->getPointerTo();",
          "new_line_content": "      llvm::Type* ir_ptr_type = primitive_type == F16",
          "content_same": false
        },
        {
          "line": 3294,
          "old_api": "GetDynamicLoopBounds",
          "new_api": null,
          "old_text": "compute_function_->GetDynamicLoopBounds()",
          "new_text": null,
          "old_line_content": "          compute_function_->GetDynamicLoopBounds();",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 3296,
          "old_api": "EmitLoop",
          "new_api": null,
          "old_text": "ParallelLoopEmitter(element_generator, target_array,\n                                             &dynamic_loop_bounds, &b_)\n                             .EmitLoop(IrName(target_op))",
          "new_text": null,
          "old_line_content": "      TF_RETURN_IF_ERROR(ParallelLoopEmitter(element_generator, target_array,",
          "new_line_content": "      // Emit code to read dynamic loop bounds from compute function argument.",
          "content_same": false
        },
        {
          "line": 3301,
          "old_api": "EmitLoop",
          "new_api": null,
          "old_text": "llvm_ir::LoopEmitter(element_generator, target_array, &b_)\n              .EmitLoop(IrName(target_op))",
          "new_text": null,
          "old_line_content": "          llvm_ir::LoopEmitter(element_generator, target_array, &b_)",
          "new_line_content": "                                             &dynamic_loop_bounds, &b_)",
          "content_same": false
        },
        {
          "line": 1255,
          "old_api": "debug_options",
          "new_api": null,
          "old_text": "hlo_module_config_.debug_options().xla_cpu_multi_thread_eigen()",
          "new_text": null,
          "old_line_content": "          hlo_module_config_.debug_options().xla_cpu_multi_thread_eigen();",
          "new_line_content": "           int64_type,    int64_type,  int64_type,  int64_type,  int64_type,",
          "content_same": false
        },
        {
          "line": 1257,
          "old_api": "debug_options",
          "new_api": null,
          "old_text": "hlo_module_config_.debug_options().xla_cpu_use_mkl_dnn()",
          "new_text": null,
          "old_line_content": "          hlo_module_config_.debug_options().xla_cpu_use_mkl_dnn();",
          "new_line_content": "          /*isVarArg=*/false);",
          "content_same": false
        },
        {
          "line": 3310,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(&source)",
          "new_text": null,
          "old_line_content": "  llvm::Value* source_value = GetEmittedValueFor(&source);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3311,
          "old_api": "GetEmittedValueFor",
          "new_api": null,
          "old_text": "GetEmittedValueFor(&destination)",
          "new_text": null,
          "old_line_content": "  llvm::Value* destination_value = GetEmittedValueFor(&destination);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3312,
          "old_api": "shape",
          "new_api": null,
          "old_text": "source.shape()",
          "new_text": null,
          "old_line_content": "  int64 source_size = ByteSizeOf(source.shape());",
          "new_line_content": "Status IrEmitter::EmitMemcpy(const HloInstruction& source,",
          "content_same": false
        },
        {
          "line": 1271,
          "old_api": "LOG",
          "new_api": null,
          "old_text": "LOG(WARNING)",
          "new_text": null,
          "old_line_content": "        LOG(WARNING) << \"Using Eigen instead of MKL-DNN for single-threaded \"",
          "new_line_content": "                     ? (use_mkl_dnn ? runtime::kMKLConvF32SymbolName",
          "content_same": false
        },
        {
          "line": 1274,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "llvm::dyn_cast<llvm::Function>(\n          module_->getOrInsertFunction(fn_name, conv_type).getCallee())",
          "new_text": null,
          "old_line_content": "      llvm::Function* conv_func = llvm::dyn_cast<llvm::Function>(",
          "new_line_content": "      if (!multi_threaded && use_mkl_dnn) {",
          "content_same": false
        },
        {
          "line": 1276,
          "old_api": "setCallingConv",
          "new_api": null,
          "old_text": "conv_func->setCallingConv(llvm::CallingConv::C)",
          "new_text": null,
          "old_line_content": "      conv_func->setCallingConv(llvm::CallingConv::C);",
          "new_line_content": "                        \"conv2d function.\";",
          "content_same": false
        },
        {
          "line": 1277,
          "old_api": "setDoesNotThrow",
          "new_api": null,
          "old_text": "conv_func->setDoesNotThrow()",
          "new_text": null,
          "old_line_content": "      conv_func->setDoesNotThrow();",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3324,
          "old_api": "shape",
          "new_api": null,
          "old_text": "TF_RET_CHECK(\n        ShapeUtil::SameElementType(operands[0]->shape(), operand->shape()))",
          "new_text": null,
          "old_line_content": "    TF_RET_CHECK(",
          "new_line_content": "    const HloInstruction& instruction,",
          "content_same": false
        },
        {
          "line": 3325,
          "old_api": "shape",
          "new_api": null,
          "old_text": "operand->shape()",
          "new_text": null,
          "old_line_content": "        ShapeUtil::SameElementType(operands[0]->shape(), operand->shape()));",
          "new_line_content": "    absl::Span<const HloInstruction* const> operands,",
          "content_same": false
        },
        {
          "line": 3330,
          "old_api": "absl::c_linear_search(supported_types, primitive_type)",
          "new_api": null,
          "old_text": "absl::c_linear_search(supported_types, primitive_type)",
          "new_text": null,
          "old_line_content": "  if (!absl::c_linear_search(supported_types, primitive_type)) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3331,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "Unimplemented(\"unsupported operand type %s in op %s\",\n                         PrimitiveType_Name(primitive_type),\n                         HloOpcodeString(instruction.opcode()))",
          "new_text": null,
          "old_line_content": "    return Unimplemented(\"unsupported operand type %s in op %s\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3340,
          "old_api": "operands",
          "new_api": null,
          "old_text": "hlo->operands()",
          "new_text": null,
          "old_line_content": "  for (const HloInstruction* operand : hlo->operands()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3342,
          "old_api": "EmitReadArrayElement",
          "new_api": null,
          "old_text": "GetIrArrayFor(operand).EmitReadArrayElement(index, &b_)",
          "new_text": null,
          "old_line_content": "      return GetIrArrayFor(operand).EmitReadArrayElement(index, &b_);",
          "new_line_content": "Status IrEmitter::DefaultAction(HloInstruction* hlo) {",
          "content_same": false
        },
        {
          "line": 3347,
          "old_api": "MakeElementGenerator",
          "new_api": null,
          "old_text": "elemental_emitter.MakeElementGenerator(hlo, operand_to_generator)",
          "new_text": null,
          "old_line_content": "      hlo, elemental_emitter.MakeElementGenerator(hlo, operand_to_generator));",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 3354,
          "old_api": "EmitThreadLocalCall",
          "new_api": null,
          "old_text": "EmitThreadLocalCall(callee, parameters, name)",
          "new_text": null,
          "old_line_content": "      EmitThreadLocalCall(callee, parameters, name);",
          "new_line_content": "llvm::Value* IrEmitter::EmitScalarReturningThreadLocalCall(",
          "content_same": false
        },
        {
          "line": 3355,
          "old_api": "size",
          "new_api": null,
          "old_text": "return_value.size()",
          "new_text": null,
          "old_line_content": "  CHECK_EQ(return_value.size(), 1);",
          "new_line_content": "    const HloComputation& callee, absl::Span<llvm::Value* const> parameters,",
          "content_same": false
        },
        {
          "line": 3362,
          "old_api": "absl::c_binary_search(thread_local_computations_, &callee)",
          "new_api": null,
          "old_text": "absl::c_binary_search(thread_local_computations_, &callee)",
          "new_text": null,
          "old_line_content": "  CHECK(absl::c_binary_search(thread_local_computations_, &callee));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3363,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "callee.root_instruction()->shape()",
          "new_text": null,
          "old_line_content": "  const Shape& return_shape = callee.root_instruction()->shape();",
          "new_line_content": "std::vector<llvm::Value*> IrEmitter::EmitThreadLocalCall(",
          "content_same": false
        },
        {
          "line": 1316,
          "old_api": "DefaultAction",
          "new_api": null,
          "old_text": "DefaultAction(convolution)",
          "new_text": null,
          "old_line_content": "  return DefaultAction(convolution);",
          "new_line_content": "  // padding calculation is not hoisted out of the inner loop.",
          "content_same": false
        },
        {
          "line": 3364,
          "old_api": "ShapeUtil::IsScalar(return_shape)",
          "new_api": null,
          "old_text": "ShapeUtil::IsScalar(return_shape)",
          "new_text": null,
          "old_line_content": "  bool is_scalar_return = ShapeUtil::IsScalar(return_shape);",
          "new_line_content": "    const HloComputation& callee, absl::Span<llvm::Value* const> parameters,",
          "content_same": false
        },
        {
          "line": 1321,
          "old_api": "ElementTypesSameAndSupported",
          "new_api": null,
          "old_text": "ElementTypesSameAndSupported(\n      /*instruction=*/*fft, /*operands=*/{operand},\n      /*supported_types=*/{F32, C64})",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(ElementTypesSameAndSupported(",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1326,
          "old_api": "shape",
          "new_api": null,
          "old_text": "operand->shape()",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"operand=\" << ShapeUtil::HumanStringWithLayout(operand->shape());",
          "new_line_content": "      /*instruction=*/*fft, /*operands=*/{operand},",
          "content_same": false
        },
        {
          "line": 1327,
          "old_api": "shape",
          "new_api": null,
          "old_text": "fft->shape()",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"fft=\" << ShapeUtil::HumanStringWithLayout(fft->shape());",
          "new_line_content": "      /*supported_types=*/{F32, C64}));",
          "content_same": false
        },
        {
          "line": 3375,
          "old_api": "getType",
          "new_api": null,
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n        parameter->getType(), \"arg_addr\", &b_)",
          "new_text": null,
          "old_line_content": "    llvm::Value* parameter_addr = llvm_ir::EmitAllocaAtFunctionEntry(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3376,
          "old_api": "getType",
          "new_api": null,
          "old_text": "parameter->getType()",
          "new_text": null,
          "old_line_content": "        parameter->getType(), \"arg_addr\", &b_);",
          "new_line_content": "  std::vector<llvm::Value*> parameter_addrs;",
          "content_same": false
        },
        {
          "line": 3377,
          "old_api": "Store",
          "new_api": null,
          "old_text": "Store(parameter, parameter_addr)",
          "new_text": null,
          "old_line_content": "    Store(parameter, parameter_addr);",
          "new_line_content": "  for (llvm::Value* parameter : parameters) {",
          "content_same": false
        },
        {
          "line": 1332,
          "old_api": "fft_length",
          "new_api": null,
          "old_text": "fft->fft_length()",
          "new_text": null,
          "old_line_content": "  const std::vector<int64>& fft_length = fft->fft_length();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1335,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "fft->shape().dimensions(i)",
          "new_text": null,
          "old_line_content": "    input_batch *= fft->shape().dimensions(i);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3383,
          "old_api": "absl::StrCat(name, \"_return_value_addr\")",
          "new_api": null,
          "old_text": "absl::StrCat(name, \"_return_value_addr\")",
          "new_text": null,
          "old_line_content": "  std::string retval_alloca_name = absl::StrCat(name, \"_return_value_addr\");",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1340,
          "old_api": "getInt32Ty",
          "new_api": null,
          "old_text": "b_.getInt32Ty()",
          "new_text": null,
          "old_line_content": "  llvm::Type* int32_type = b_.getInt32Ty();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1341,
          "old_api": "getInt64Ty",
          "new_api": null,
          "old_text": "b_.getInt64Ty()",
          "new_text": null,
          "old_line_content": "  llvm::Type* int64_type = b_.getInt64Ty();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1342,
          "old_api": "getVoidTy",
          "new_api": null,
          "old_text": "llvm::FunctionType::get(\n      b_.getVoidTy(),\n      {int8_ptr_type, int8_ptr_type, int8_ptr_type, int32_type, int32_type,\n       int64_type, int64_type, int64_type, int64_type},\n      /*isVarArg=*/false)",
          "new_text": null,
          "old_line_content": "  llvm::FunctionType* fft_type = llvm::FunctionType::get(",
          "new_line_content": "  // Args have been computed, make the call.",
          "content_same": false
        },
        {
          "line": 3388,
          "old_api": "llvm_ir::EmitAllocaAtFunctionEntry(\n      return_value_buffer_type, retval_alloca_name, &b_, retval_alignment)",
          "new_api": null,
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n      return_value_buffer_type, retval_alloca_name, &b_, retval_alignment)",
          "new_text": null,
          "old_line_content": "  llvm::Value* return_value_buffer = llvm_ir::EmitAllocaAtFunctionEntry(",
          "new_line_content": "  int retval_alignment =",
          "content_same": false
        },
        {
          "line": 3393,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "allocas_for_returned_scalars.push_back(return_value_buffer)",
          "new_text": null,
          "old_line_content": "    allocas_for_returned_scalars.push_back(return_value_buffer);",
          "new_line_content": "      return_value_buffer_type, retval_alloca_name, &b_, retval_alignment);",
          "content_same": false
        },
        {
          "line": 3395,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "    constexpr int max_tuple_size = 1000;",
          "new_line_content": "  std::vector<llvm::Value*> allocas_for_returned_scalars;",
          "content_same": false
        },
        {
          "line": 3396,
          "old_api": "tuple_shapes_size",
          "new_api": null,
          "old_text": "return_shape.tuple_shapes_size()",
          "new_text": null,
          "old_line_content": "    CHECK_LT(return_shape.tuple_shapes_size(), max_tuple_size)",
          "new_line_content": "  if (is_scalar_return) {",
          "content_same": false
        },
        {
          "line": 1349,
          "old_api": "debug_options",
          "new_api": null,
          "old_text": "hlo_module_config_.debug_options().xla_cpu_multi_thread_eigen()",
          "new_text": null,
          "old_line_content": "      hlo_module_config_.debug_options().xla_cpu_multi_thread_eigen();",
          "new_line_content": "       int64_type, int64_type, int64_type, int64_type},",
          "content_same": false
        },
        {
          "line": 1354,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "llvm::dyn_cast<llvm::Function>(\n      module_->getOrInsertFunction(fn_name, fft_type).getCallee())",
          "new_text": null,
          "old_line_content": "  llvm::Function* fft_func = llvm::dyn_cast<llvm::Function>(",
          "new_line_content": "  const char* fn_name = multi_threaded_eigen",
          "content_same": false
        },
        {
          "line": 1355,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "module_->getOrInsertFunction(fn_name, fft_type).getCallee()",
          "new_text": null,
          "old_line_content": "      module_->getOrInsertFunction(fn_name, fft_type).getCallee());",
          "new_line_content": "                            ? runtime::kEigenFftSymbolName",
          "content_same": false
        },
        {
          "line": 1356,
          "old_api": "setCallingConv",
          "new_api": null,
          "old_text": "fft_func->setCallingConv(llvm::CallingConv::C)",
          "new_text": null,
          "old_line_content": "  fft_func->setCallingConv(llvm::CallingConv::C);",
          "new_line_content": "                            : runtime::kEigenSingleThreadedFftSymbolName;",
          "content_same": false
        },
        {
          "line": 1357,
          "old_api": "setDoesNotThrow",
          "new_api": null,
          "old_text": "fft_func->setDoesNotThrow()",
          "new_text": null,
          "old_line_content": "  fft_func->setDoesNotThrow();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3403,
          "old_api": "EmitTuple",
          "new_api": null,
          "old_text": "EmitTuple(tuple_array, allocas_for_returned_scalars, &b_)",
          "new_text": null,
          "old_line_content": "    EmitTuple(tuple_array, allocas_for_returned_scalars, &b_);",
          "new_line_content": "    allocas_for_returned_scalars =",
          "content_same": false
        },
        {
          "line": 3406,
          "old_api": "FindOrDie",
          "new_api": null,
          "old_text": "FindOrDie(emitted_functions_, &callee)",
          "new_text": null,
          "old_line_content": "  Call(FindOrDie(emitted_functions_, &callee),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3412,
          "old_api": "getInt8PtrTy",
          "new_api": null,
          "old_text": "b_.getInt8PtrTy()->getPointerTo()",
          "new_text": null,
          "old_line_content": "           llvm::Constant::getNullValue(b_.getInt8PtrTy()->getPointerTo()),",
          "new_line_content": "           parameter_addrs, &b_, name,",
          "content_same": false
        },
        {
          "line": 3413,
          "old_api": "GetProfileCountersArgument",
          "new_api": null,
          "old_text": "GetProfileCountersArgument()",
          "new_text": null,
          "old_line_content": "           /*profile_counters_arg=*/GetProfileCountersArgument()));",
          "new_line_content": "           /*return_value_buffer=*/return_value_buffer,",
          "content_same": false
        },
        {
          "line": 3418,
          "old_api": "Load",
          "new_api": null,
          "old_text": "Load(addr)",
          "new_text": null,
          "old_line_content": "    returned_scalars.push_back(Load(addr));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3425,
          "old_api": "absl::c_binary_search(global_computations_, &callee)",
          "new_api": null,
          "old_text": "absl::c_binary_search(global_computations_, &callee)",
          "new_text": null,
          "old_line_content": "  CHECK(absl::c_binary_search(global_computations_, &callee));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3427,
          "old_api": "FindOrDie",
          "new_api": null,
          "old_text": "FindOrDie(emitted_functions_, &callee)",
          "new_text": null,
          "old_line_content": "  Call(FindOrDie(emitted_functions_, &callee),",
          "new_line_content": "void IrEmitter::EmitGlobalCall(const HloComputation& callee,",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(crs)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(crs));",
          "new_line_content": "  // TODO(b/80100934): We would like to eliminate one-replica CRS nodes entirely",
          "content_same": false
        },
        {
          "line": 3428,
          "old_api": "getInt8PtrTy",
          "new_api": null,
          "old_text": "GetArrayFunctionCallArguments(\n           /*parameter_addresses=*/{}, &b_, name,\n           /*return_value_buffer=*/\n           llvm::Constant::getNullValue(b_.getInt8PtrTy()),\n           /*exec_run_options_arg=*/GetExecutableRunOptionsArgument(),\n           /*buffer_table_arg=*/GetBufferTableArgument(),\n           /*profile_counters_arg=*/GetProfileCountersArgument())",
          "new_text": null,
          "old_line_content": "       GetArrayFunctionCallArguments(",
          "new_line_content": "                               absl::string_view name) {",
          "content_same": false
        },
        {
          "line": 1383,
          "old_api": "operand_count",
          "new_api": null,
          "old_text": "crs->operand_count()",
          "new_text": null,
          "old_line_content": "  if (crs->operand_count() == 1) {",
          "new_line_content": "  // and when it's run.",
          "content_same": false
        },
        {
          "line": 3433,
          "old_api": "GetBufferTableArgument",
          "new_api": null,
          "old_text": "GetBufferTableArgument()",
          "new_text": null,
          "old_line_content": "           /*buffer_table_arg=*/GetBufferTableArgument(),",
          "new_line_content": "           /*parameter_addresses=*/{}, &b_, name,",
          "content_same": false
        },
        {
          "line": 3434,
          "old_api": "GetProfileCountersArgument",
          "new_api": null,
          "old_text": "GetProfileCountersArgument()",
          "new_text": null,
          "old_line_content": "           /*profile_counters_arg=*/GetProfileCountersArgument()));",
          "new_line_content": "           /*return_value_buffer=*/",
          "content_same": false
        },
        {
          "line": 1389,
          "old_api": "operand_count",
          "new_api": null,
          "old_text": "crs->operand_count()",
          "new_text": null,
          "old_line_content": "  for (int64 i = 0; i < crs->operand_count(); ++i) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1390,
          "old_api": "operand",
          "new_api": null,
          "old_text": "crs->operand(i)",
          "new_text": null,
          "old_line_content": "    llvm::Value* in_ptr = GetEmittedValueFor(crs->operand(i));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3439,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "callee.root_instruction()",
          "new_text": null,
          "old_line_content": "  const HloInstruction* root_inst = callee.root_instruction();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3440,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "root_inst->opcode()",
          "new_text": null,
          "old_line_content": "  if (root_inst->opcode() == HloOpcode::kOutfeed) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3441,
          "old_api": "getInt8PtrTy",
          "new_api": null,
          "old_text": "b_.getInt8PtrTy()",
          "new_text": null,
          "old_line_content": "    return llvm::Constant::getNullValue(b_.getInt8PtrTy());",
          "new_line_content": "llvm::Value* IrEmitter::GetBufferForGlobalCallReturnValue(",
          "content_same": false
        },
        {
          "line": 1395,
          "old_api": "IsArray",
          "new_api": null,
          "old_text": "operand_shape.IsArray()",
          "new_text": null,
          "old_line_content": "    CHECK(operand_shape.IsArray())",
          "new_line_content": "    TF_ASSIGN_OR_RETURN(const BufferAllocation::Slice out_slice,",
          "content_same": false
        },
        {
          "line": 1396,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "crs->ToString()",
          "new_text": null,
          "old_line_content": "        << \"Operands to all-reduce must be arrays: \" << crs->ToString();",
          "new_line_content": "                        assignment_.GetUniqueSlice(crs, {i}));",
          "content_same": false
        },
        {
          "line": 1397,
          "old_api": "EmitBufferPointer",
          "new_api": null,
          "old_text": "EmitBufferPointer(out_slice, operand_shape)",
          "new_text": null,
          "old_line_content": "    operand_ptrs.push_back(EmitBufferPointer(out_slice, operand_shape));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3446,
          "old_api": "shape",
          "new_api": null,
          "old_text": "root_inst->shape()",
          "new_text": null,
          "old_line_content": "  return EmitBufferPointer(root_buffer, root_inst->shape());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1403,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(crs)",
          "new_text": null,
          "old_line_content": "  llvm_ir::EmitTuple(GetIrArrayFor(crs), operand_ptrs, &b_);",
          "new_line_content": "    // TODO(b/63762267): Be more aggressive about specifying alignment.",
          "content_same": false
        },
        {
          "line": 1409,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "crs->operand(0)->shape().element_type()",
          "new_text": null,
          "old_line_content": "  PrimitiveType datatype = crs->operand(0)->shape().element_type();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1410,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(crs)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(crs));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1431,
          "old_api": "Unimplemented",
          "new_api": null,
          "old_text": "Unimplemented(\"AllReduce for datatype '%s' is not supported\",\n                         primitive_util::LowercasePrimitiveTypeName(datatype))",
          "new_text": null,
          "old_line_content": "    return Unimplemented(\"AllReduce for datatype '%s' is not supported\",",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1432,
          "old_api": "primitive_util::LowercasePrimitiveTypeName(datatype)",
          "new_api": null,
          "old_text": "primitive_util::LowercasePrimitiveTypeName(datatype)",
          "new_text": null,
          "old_line_content": "                         primitive_util::LowercasePrimitiveTypeName(datatype));",
          "new_line_content": "  }();",
          "content_same": false
        },
        {
          "line": 1437,
          "old_api": "to_apply",
          "new_api": null,
          "old_text": "crs->to_apply()->ToString()",
          "new_text": null,
          "old_line_content": "                         crs->to_apply()->ToString());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1442,
          "old_api": "getInt64Ty",
          "new_api": null,
          "old_text": "b_.getInt64Ty()",
          "new_text": null,
          "old_line_content": "  llvm::Type* int64_type = b_.getInt64Ty();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1457,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "llvm::dyn_cast<llvm::Function>(\n      module_\n          ->getOrInsertFunction(runtime::kAllReduceSymbolName,\n                                all_reduce_func_ty)\n          .getCallee())",
          "new_text": null,
          "old_line_content": "  auto all_reduce_func = llvm::dyn_cast<llvm::Function>(",
          "new_line_content": "                               /*input_buffer=*/i8_ptr_type,",
          "content_same": false
        },
        {
          "line": 1458,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "module_\n          ->getOrInsertFunction(runtime::kAllReduceSymbolName,\n                                all_reduce_func_ty)\n          .getCallee()",
          "new_text": null,
          "old_line_content": "      module_",
          "new_line_content": "                               /*output_buffer=*/i8_ptr_type},",
          "content_same": false
        },
        {
          "line": 1464,
          "old_api": "replica_groups",
          "new_api": null,
          "old_text": "crs->replica_groups()",
          "new_text": null,
          "old_line_content": "  std::string replica_groups = ReplicaGroupsToString(crs->replica_groups());",
          "new_line_content": "                                all_reduce_func_ty)",
          "content_same": false
        },
        {
          "line": 1465,
          "old_api": "size",
          "new_api": null,
          "old_text": "replica_groups.size()",
          "new_text": null,
          "old_line_content": "  int32 replica_groups_size = replica_groups.size();",
          "new_line_content": "          .getCallee());",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": "getInt32",
          "new_api": null,
          "old_text": "Call(all_reduce_func,\n       {/*run_options=*/GetExecutableRunOptionsArgument(),\n        /*replica_groups=*/replica_groups_v,\n        /*replica_groups_size=*/b_.getInt32(replica_groups_size),\n\n        /*channel_id_present=*/\n        b_.getInt32(static_cast<int32>(crs->channel_id().has_value())),\n        /*op_id=*/\n        b_.getInt64(crs->channel_id().has_value()\n                        ? *crs->channel_id()\n                        : crs->GetModule()->unique_id()),\n\n        /*reduction_kind=*/\n        b_.getInt32(\n            static_cast<int32>(*MatchReductionComputation(crs->to_apply()))),\n\n        /*shape_ptr=*/shape_ptr,\n        /*shape_length=*/b_.getInt32(shape_length),\n\n        /*input_buffer=*/b_.CreateBitCast(input_buffer, i8_ptr_type),\n        /*output_buffer=*/b_.CreateBitCast(output_buffer, i8_ptr_type)})",
          "new_text": null,
          "old_line_content": "  Call(all_reduce_func,",
          "new_line_content": "  TF_ASSIGN_OR_RETURN(BufferAllocation::Slice output_slice,",
          "content_same": false
        },
        {
          "line": 1483,
          "old_api": "GetExecutableRunOptionsArgument",
          "new_api": null,
          "old_text": "GetExecutableRunOptionsArgument()",
          "new_text": null,
          "old_line_content": "       {/*run_options=*/GetExecutableRunOptionsArgument(),",
          "new_line_content": "                      assignment_.GetUniqueSlice(crs, {}));",
          "content_same": false
        },
        {
          "line": 1485,
          "old_api": "getInt32",
          "new_api": null,
          "old_text": "b_.getInt32(replica_groups_size)",
          "new_text": null,
          "old_line_content": "        /*replica_groups_size=*/b_.getInt32(replica_groups_size),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1488,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "crs->channel_id().has_value()",
          "new_text": null,
          "old_line_content": "        b_.getInt32(static_cast<int32>(crs->channel_id().has_value())),",
          "new_line_content": "        /*replica_groups=*/replica_groups_v,",
          "content_same": false
        },
        {
          "line": 1490,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "crs->channel_id().has_value()",
          "new_text": null,
          "old_line_content": "        b_.getInt64(crs->channel_id().has_value()",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": "channel_id",
          "new_api": null,
          "old_text": "crs->channel_id()",
          "new_text": null,
          "old_line_content": "                        ? *crs->channel_id()",
          "new_line_content": "        /*channel_id_present=*/",
          "content_same": false
        },
        {
          "line": 1501,
          "old_api": "CreateBitCast",
          "new_api": null,
          "old_text": "b_.CreateBitCast(input_buffer, i8_ptr_type)",
          "new_text": null,
          "old_line_content": "        /*input_buffer=*/b_.CreateBitCast(input_buffer, i8_ptr_type),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1502,
          "old_api": "CreateBitCast",
          "new_api": null,
          "old_text": "b_.CreateBitCast(output_buffer, i8_ptr_type)",
          "new_text": null,
          "old_line_content": "        /*output_buffer=*/b_.CreateBitCast(output_buffer, i8_ptr_type)});",
          "new_line_content": "        /*shape_ptr=*/shape_ptr,",
          "content_same": false
        },
        {
          "line": 1504,
          "old_api": "Status::OK()",
          "new_api": null,
          "old_text": "Status::OK()",
          "new_text": null,
          "old_line_content": "  return Status::OK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1509,
          "old_api": "HandleAllReduceSingleReplica",
          "new_api": null,
          "old_text": "HandleAllReduceSingleReplica(crs)",
          "new_text": null,
          "old_line_content": "    return HandleAllReduceSingleReplica(crs);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1511,
          "old_api": "HandleAllReduceMultipleReplica",
          "new_api": null,
          "old_text": "HandleAllReduceMultipleReplica(crs)",
          "new_text": null,
          "old_line_content": "  return HandleAllReduceMultipleReplica(crs);",
          "new_line_content": "Status IrEmitter::HandleAllReduce(HloInstruction* crs) {",
          "content_same": false
        },
        {
          "line": 1516,
          "old_api": "getContext",
          "new_api": null,
          "old_text": "module_->getContext()",
          "new_text": null,
          "old_line_content": "  llvm::Type* i8_ptr_type = llvm::Type::getInt8PtrTy(module_->getContext());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1518,
          "old_api": "getVoidTy",
          "new_api": null,
          "old_text": "b_.getVoidTy()",
          "new_text": null,
          "old_line_content": "      llvm::FunctionType::get(b_.getVoidTy(),",
          "new_line_content": "Status IrEmitter::HandleReplicaId(HloInstruction* hlo) {",
          "content_same": false
        },
        {
          "line": 1523,
          "old_api": "getCallee",
          "new_api": null,
          "old_text": "module_\n          ->getOrInsertFunction(runtime::kReplicaIdSymbolName,\n                                replica_id_function_ty)\n          .getCallee()",
          "new_text": null,
          "old_line_content": "      module_",
          "new_line_content": "                              {/*run_options=*/i8_ptr_type,",
          "content_same": false
        },
        {
          "line": 1530,
          "old_api": "shape",
          "new_api": null,
          "old_text": "hlo->shape()",
          "new_text": null,
          "old_line_content": "  llvm::Value* output_buffer = EmitBufferPointer(output_slice, hlo->shape());",
          "new_line_content": "          .getCallee());",
          "content_same": false
        },
        {
          "line": 1532,
          "old_api": "GetExecutableRunOptionsArgument",
          "new_api": null,
          "old_text": "GetExecutableRunOptionsArgument()",
          "new_text": null,
          "old_line_content": "       {/*run_options=*/GetExecutableRunOptionsArgument(),",
          "new_line_content": "  TF_ASSIGN_OR_RETURN(BufferAllocation::Slice output_slice,",
          "content_same": false
        },
        {
          "line": 1533,
          "old_api": "CreateBitCast",
          "new_api": null,
          "old_text": "b_.CreateBitCast(output_buffer, i8_ptr_type)",
          "new_text": null,
          "old_line_content": "        /*output_buffer=*/b_.CreateBitCast(output_buffer, i8_ptr_type)});",
          "new_line_content": "                      assignment_.GetUniqueSlice(hlo, {}));",
          "content_same": false
        },
        {
          "line": 1540,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(parameter)",
          "new_text": null,
          "old_line_content": "  return EmitTargetAddressForOp(parameter);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1546,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "reduce.opcode()",
          "new_text": null,
          "old_line_content": "  DCHECK_EQ(reduce.opcode(), HloOpcode::kReduce);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1555,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "reduce.dimensions().begin()",
          "new_text": null,
          "old_line_content": "  absl::flat_hash_set<int64> reduced_dims(reduce.dimensions().begin(),",
          "new_line_content": "  // So if we reduce f32[A,B,C,D] on dimensions 1 and 2, this map contains",
          "content_same": false
        },
        {
          "line": 1556,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "reduce.dimensions().end()",
          "new_text": null,
          "old_line_content": "                                          reduce.dimensions().end());",
          "new_line_content": "  // [0->0, 3->1].",
          "content_same": false
        },
        {
          "line": 1558,
          "old_api": "operand",
          "new_api": null,
          "old_text": "reduce.operand(0)->shape()",
          "new_text": null,
          "old_line_content": "  const Shape& operand_shape = reduce.operand(0)->shape();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1574,
          "old_api": "dimensions_size",
          "new_api": null,
          "old_text": "operand_shape.dimensions_size()",
          "new_text": null,
          "old_line_content": "       operand_dim_idx < operand_shape.dimensions_size(); operand_dim_idx++) {",
          "new_line_content": "  // Iterate dimensions minor to major and check that the corresponding",
          "content_same": false
        },
        {
          "line": 1575,
          "old_api": "layout",
          "new_api": null,
          "old_text": "operand_shape.layout().minor_to_major(operand_dim_idx)",
          "new_text": null,
          "old_line_content": "    int64 operand_dim = operand_shape.layout().minor_to_major(operand_dim_idx);",
          "new_line_content": "  // dimensions in the source and target shapes are equivalent.",
          "content_same": false
        },
        {
          "line": 1576,
          "old_api": "contains",
          "new_api": null,
          "old_text": "reduced_dims.contains(operand_dim)",
          "new_text": null,
          "old_line_content": "    if (!reduced_dims.contains(operand_dim)) {",
          "new_line_content": "  int64 result_dim_idx = 0;",
          "content_same": false
        },
        {
          "line": 1577,
          "old_api": "FindOrDie",
          "new_api": null,
          "old_text": "FindOrDie(unreduced_dim_map, operand_dim)",
          "new_text": null,
          "old_line_content": "      if (FindOrDie(unreduced_dim_map, operand_dim) !=",
          "new_line_content": "  for (int64 operand_dim_idx = 0;",
          "content_same": false
        },
        {
          "line": 1584,
          "old_api": "dimensions_size",
          "new_api": null,
          "old_text": "result_shape.dimensions_size()",
          "new_text": null,
          "old_line_content": "  CHECK_EQ(result_dim_idx, result_shape.dimensions_size());",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1591,
          "old_api": "num_parameters",
          "new_api": null,
          "old_text": "function->num_parameters()",
          "new_text": null,
          "old_line_content": "  CHECK_EQ(function->num_parameters(), 2);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1593,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "function->root_instruction()",
          "new_text": null,
          "old_line_content": "  auto root_instruction = function->root_instruction();",
          "new_line_content": "IrEmitter::ReductionGenerator IrEmitter::MatchReductionGenerator(",
          "content_same": false
        },
        {
          "line": 1594,
          "old_api": "shape",
          "new_api": null,
          "old_text": "root_instruction->shape()",
          "new_text": null,
          "old_line_content": "  CHECK(ShapeUtil::IsScalar(root_instruction->shape()));",
          "new_line_content": "    HloComputation* function, string* failure_reason) const {",
          "content_same": false
        },
        {
          "line": 1596,
          "old_api": "operand_count",
          "new_api": null,
          "old_text": "root_instruction->operand_count()",
          "new_text": null,
          "old_line_content": "  if (root_instruction->operand_count() != 2) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1601,
          "old_api": "shape",
          "new_api": null,
          "old_text": "root_instruction->shape()",
          "new_text": null,
          "old_line_content": "  const Shape& root_shape = root_instruction->shape();",
          "new_line_content": "    *failure_reason = \"root instruction is not a binary operation\";",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": "ShapeUtil::ElementIsComplex(root_shape)",
          "new_api": null,
          "old_text": "ShapeUtil::ElementIsComplex(root_shape)",
          "new_text": null,
          "old_line_content": "  if (ShapeUtil::ElementIsComplex(root_shape)) {",
          "new_line_content": "    return nullptr;",
          "content_same": false
        },
        {
          "line": 1610,
          "old_api": "ShapeUtil::ElementIsFloating(root_shape)",
          "new_api": null,
          "old_text": "ShapeUtil::ElementIsFloating(root_shape)",
          "new_text": null,
          "old_line_content": "  bool root_is_floating_point = ShapeUtil::ElementIsFloating(root_shape);",
          "new_line_content": "    // CreateShuffleVector on a bitcast to float x [2N].",
          "content_same": false
        },
        {
          "line": 1611,
          "old_api": "ShapeUtil::ElementIsIntegral(root_shape)",
          "new_api": null,
          "old_text": "ShapeUtil::ElementIsIntegral(root_shape)",
          "new_text": null,
          "old_line_content": "  bool root_is_integral = ShapeUtil::ElementIsIntegral(root_shape);",
          "new_line_content": "    *failure_reason = \"complex values not supported\";",
          "content_same": false
        },
        {
          "line": 1612,
          "old_api": "ShapeUtil::ElementIsSigned(root_shape)",
          "new_api": null,
          "old_text": "ShapeUtil::ElementIsSigned(root_shape)",
          "new_text": null,
          "old_line_content": "  bool root_is_signed = ShapeUtil::ElementIsSigned(root_shape);",
          "new_line_content": "    return nullptr;",
          "content_same": false
        },
        {
          "line": 1617,
          "old_api": "parameter_instruction",
          "new_api": null,
          "old_text": "function->parameter_instruction(0)",
          "new_text": null,
          "old_line_content": "  auto param_0 = function->parameter_instruction(0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1626,
          "old_api": "shape",
          "new_api": null,
          "old_text": "rhs->shape()",
          "new_text": null,
          "old_line_content": "  CHECK(ShapeUtil::IsScalar(lhs->shape()) && ShapeUtil::IsScalar(rhs->shape()));",
          "new_line_content": "        \"root instruction is not a binary operation on the incoming arguments\";",
          "content_same": false
        },
        {
          "line": 1632,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "root_instruction->opcode()",
          "new_text": null,
          "old_line_content": "  switch (root_instruction->opcode()) {",
          "new_line_content": "  // This is visually similar to ElementalIrEmitter, though conceptually we're",
          "content_same": false
        },
        {
          "line": 1640,
          "old_api": "CreateAdd",
          "new_api": null,
          "old_text": "b->CreateAdd(lhs, rhs)",
          "new_text": null,
          "old_line_content": "        return root_is_integral ? b->CreateAdd(lhs, rhs)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1641,
          "old_api": "CreateFAdd",
          "new_api": null,
          "old_text": "b->CreateFAdd(lhs, rhs)",
          "new_text": null,
          "old_line_content": "                                : b->CreateFAdd(lhs, rhs);",
          "new_line_content": "    case HloOpcode::kAdd:",
          "content_same": false
        },
        {
          "line": 1647,
          "old_api": "CreateMul",
          "new_api": null,
          "old_text": "b->CreateMul(lhs, rhs)",
          "new_text": null,
          "old_line_content": "        return root_is_integral ? b->CreateMul(lhs, rhs)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1648,
          "old_api": "CreateFMul",
          "new_api": null,
          "old_text": "b->CreateFMul(lhs, rhs)",
          "new_text": null,
          "old_line_content": "                                : b->CreateFMul(lhs, rhs);",
          "new_line_content": "    case HloOpcode::kMultiply:",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": "CreateAnd",
          "new_api": null,
          "old_text": "b->CreateAnd(lhs, rhs)",
          "new_text": null,
          "old_line_content": "        return b->CreateAnd(lhs, rhs);",
          "new_line_content": "      };",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": "CreateOr",
          "new_api": null,
          "old_text": "b->CreateOr(lhs, rhs)",
          "new_text": null,
          "old_line_content": "        return b->CreateOr(lhs, rhs);",
          "new_line_content": "      };",
          "content_same": false
        },
        {
          "line": 1663,
          "old_api": "CreateXor",
          "new_api": null,
          "old_text": "b->CreateXor(lhs, rhs)",
          "new_text": null,
          "old_line_content": "        return b->CreateXor(lhs, rhs);",
          "new_line_content": "      };",
          "content_same": false
        },
        {
          "line": 1671,
          "old_api": "getType",
          "new_api": null,
          "old_text": "llvm_ir::EmitCallToIntrinsic(llvm::Intrinsic::maxnum,\n                                              {lhs, rhs}, {lhs->getType()}, b)",
          "new_text": null,
          "old_line_content": "          return llvm_ir::EmitCallToIntrinsic(llvm::Intrinsic::maxnum,",
          "new_line_content": "      return [root_is_floating_point, root_is_signed](",
          "content_same": false
        },
        {
          "line": 1672,
          "old_api": "getType",
          "new_api": null,
          "old_text": "lhs->getType()",
          "new_text": null,
          "old_line_content": "                                              {lhs, rhs}, {lhs->getType()}, b);",
          "new_line_content": "                 llvm::IRBuilder<>* b, llvm::Value* lhs,",
          "content_same": false
        },
        {
          "line": 1687,
          "old_api": "getType",
          "new_api": null,
          "old_text": "llvm_ir::EmitCallToIntrinsic(llvm::Intrinsic::minnum,\n                                              {lhs, rhs}, {lhs->getType()}, b)",
          "new_text": null,
          "old_line_content": "          return llvm_ir::EmitCallToIntrinsic(llvm::Intrinsic::minnum,",
          "new_line_content": "      return [root_is_floating_point, root_is_signed](",
          "content_same": false
        },
        {
          "line": 1688,
          "old_api": "getType",
          "new_api": null,
          "old_text": "lhs->getType()",
          "new_text": null,
          "old_line_content": "                                              {lhs, rhs}, {lhs->getType()}, b);",
          "new_line_content": "                 llvm::IRBuilder<>* b, llvm::Value* lhs,",
          "content_same": false
        },
        {
          "line": 1703,
          "old_api": "vector_register_byte_size",
          "new_api": null,
          "old_text": "target_machine_features_.vector_register_byte_size(\n          *compute_function_->function())",
          "new_text": null,
          "old_line_content": "      target_machine_features_.vector_register_byte_size(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1704,
          "old_api": "function",
          "new_api": null,
          "old_text": "compute_function_->function()",
          "new_text": null,
          "old_line_content": "          *compute_function_->function()) /",
          "new_line_content": "IrEmitter::ShardedVectorType IrEmitter::CreateShardedVectorType(",
          "content_same": false
        },
        {
          "line": 1705,
          "old_api": "ShapeUtil::ByteSizeOfPrimitiveType(element_type)",
          "new_api": null,
          "old_text": "ShapeUtil::ByteSizeOfPrimitiveType(element_type)",
          "new_text": null,
          "old_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(element_type);",
          "new_line_content": "    PrimitiveType element_type, unsigned element_count) {",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": "tensorflow::Log2Ceiling(element_count)",
          "new_api": null,
          "old_text": "tensorflow::Log2Ceiling(element_count)",
          "new_text": null,
          "old_line_content": "  for (int i = 0, e = 1 + tensorflow::Log2Ceiling(element_count); i < e; i++) {",
          "new_line_content": "  ShardedVectorType sharded_vector_type;",
          "content_same": false
        },
        {
          "line": 1722,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "sharded_vector_type.push_back(element_ir_type)",
          "new_text": null,
          "old_line_content": "      sharded_vector_type.push_back(element_ir_type);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1730,
          "old_api": "llvm::VectorType::get(\n          element_ir_type, vector_register_size_in_elements)",
          "new_api": null,
          "old_text": "llvm::VectorType::get(\n          element_ir_type, vector_register_size_in_elements)",
          "new_text": null,
          "old_line_content": "      auto vector_type = llvm::VectorType::get(",
          "new_line_content": "    // Lower \"current_size_fragment\" number of elements using (as few as",
          "content_same": false
        },
        {
          "line": 1732,
          "old_api": "insert",
          "new_api": null,
          "old_text": "sharded_vector_type.insert(\n          sharded_vector_type.end(),\n          current_size_fragment / vector_register_size_in_elements,\n          vector_type)",
          "new_text": null,
          "old_line_content": "      sharded_vector_type.insert(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1733,
          "old_api": "end",
          "new_api": null,
          "old_text": "sharded_vector_type.end()",
          "new_text": null,
          "old_line_content": "          sharded_vector_type.end(),",
          "new_line_content": "    if (current_size_fragment >= vector_register_size_in_elements) {",
          "content_same": false
        },
        {
          "line": 1739,
          "old_api": "CHECK_EQ",
          "new_api": null,
          "old_text": "CHECK_EQ(current_size_fragment % vector_register_size_in_elements, 0)",
          "new_text": null,
          "old_line_content": "      CHECK_EQ(current_size_fragment % vector_register_size_in_elements, 0);",
          "new_line_content": "          vector_type);",
          "content_same": false
        },
        {
          "line": 1746,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "sharded_vector_type.push_back(\n        llvm::VectorType::get(element_ir_type, current_size_fragment))",
          "new_text": null,
          "old_line_content": "    sharded_vector_type.push_back(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1747,
          "old_api": "llvm::VectorType::get(element_ir_type, current_size_fragment)",
          "new_api": null,
          "old_text": "llvm::VectorType::get(element_ir_type, current_size_fragment)",
          "new_text": null,
          "old_line_content": "        llvm::VectorType::get(element_ir_type, current_size_fragment));",
          "new_line_content": "    // For now we assume that vector_register_size_in_elements and lower powers",
          "content_same": false
        },
        {
          "line": 1760,
          "old_api": "size",
          "new_api": null,
          "old_text": "accumulator_type.size()",
          "new_text": null,
          "old_line_content": "  accumulator.reserve(accumulator_type.size());",
          "new_line_content": "    const ShardedVectorType& accumulator_type, HloInstruction* init_value,",
          "content_same": false
        },
        {
          "line": 1762,
          "old_api": "llvm_ir::EmitAllocaAtFunctionEntry(\n        accumulator_shard_type, \"accumulator\", &b_, 0)",
          "new_api": null,
          "old_text": "llvm_ir::EmitAllocaAtFunctionEntry(\n        accumulator_shard_type, \"accumulator\", &b_, 0)",
          "new_text": null,
          "old_line_content": "    accumulator.push_back(llvm_ir::EmitAllocaAtFunctionEntry(",
          "new_line_content": "    unsigned element_alignment) {",
          "content_same": false
        },
        {
          "line": 1771,
          "old_api": "llvm::dyn_cast<llvm::VectorType>(shard_type)",
          "new_api": null,
          "old_text": "llvm::dyn_cast<llvm::VectorType>(shard_type)",
          "new_text": null,
          "old_line_content": "    if (auto vector_type = llvm::dyn_cast<llvm::VectorType>(shard_type)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1773,
          "old_api": "getNumElements",
          "new_api": null,
          "old_text": "vector_type->getNumElements()",
          "new_text": null,
          "old_line_content": "          VectorSplat(vector_type->getNumElements(), init_value_ssa);",
          "new_line_content": "    llvm::Value* initial_value;",
          "content_same": false
        },
        {
          "line": 1778,
          "old_api": "AlignedStore",
          "new_api": null,
          "old_text": "AlignedStore(initial_value, accumulator_shard, element_alignment)",
          "new_text": null,
          "old_line_content": "    AlignedStore(initial_value, accumulator_shard, element_alignment);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1781,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(arg, \"vectorized_inner\")",
          "new_text": null,
          "old_line_content": "  llvm_ir::ForLoopNest reduction_loop_nest(IrName(arg, \"vectorized_inner\"),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1784,
          "old_api": "shape",
          "new_api": null,
          "old_text": "arg->shape()",
          "new_text": null,
          "old_line_content": "      reduction_loop_nest.AddLoopsForShapeOnDimensions(arg->shape(), dimensions,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1787,
          "old_api": "GetInnerLoopBodyBasicBlock",
          "new_api": null,
          "old_text": "reduction_loop_nest.GetInnerLoopBodyBasicBlock()",
          "new_text": null,
          "old_line_content": "  SetToFirstInsertPoint(reduction_loop_nest.GetInnerLoopBodyBasicBlock(), &b_);",
          "new_line_content": "  std::vector<llvm::Value*> input_multi_index =",
          "content_same": false
        },
        {
          "line": 1790,
          "old_api": "begin",
          "new_api": null,
          "old_text": "output_index.begin()",
          "new_text": null,
          "old_line_content": "  llvm_ir::IrArray::Index::const_iterator it = output_index.begin();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1797,
          "old_api": "end",
          "new_api": null,
          "old_text": "output_index.end()",
          "new_text": null,
          "old_line_content": "  CHECK(output_index.end() == it);",
          "new_line_content": "    if (i == nullptr) {",
          "content_same": false
        },
        {
          "line": 1798,
          "old_api": "shape",
          "new_api": null,
          "old_text": "arg->shape()",
          "new_text": null,
          "old_line_content": "  llvm_ir::IrArray::Index input_index(input_multi_index, arg->shape(),",
          "new_line_content": "      i = *it++;",
          "content_same": false
        },
        {
          "line": 1799,
          "old_api": "getInt64Ty",
          "new_api": null,
          "old_text": "b_.getInt64Ty()",
          "new_text": null,
          "old_line_content": "                                      b_.getInt64Ty());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1804,
          "old_api": "size",
          "new_api": null,
          "old_text": "accumulator.size()",
          "new_text": null,
          "old_line_content": "  for (int i = 0; i < accumulator.size(); i++) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1809,
          "old_api": "AlignedLoad",
          "new_api": null,
          "old_text": "AlignedLoad(input_address_typed, element_alignment)",
          "new_text": null,
          "old_line_content": "    auto addend = AlignedLoad(input_address_typed, element_alignment);",
          "new_line_content": "    auto input_address_typed =",
          "content_same": false
        },
        {
          "line": 1816,
          "old_api": "size",
          "new_api": null,
          "old_text": "accumulator.size()",
          "new_text": null,
          "old_line_content": "    if (i != (accumulator.size() - 1)) {",
          "new_line_content": "    auto reduced_result =",
          "content_same": false
        },
        {
          "line": 1822,
          "old_api": "GetOuterLoopExitBasicBlock",
          "new_api": null,
          "old_text": "reduction_loop_nest.GetOuterLoopExitBasicBlock()",
          "new_text": null,
          "old_line_content": "  SetToFirstInsertPoint(reduction_loop_nest.GetOuterLoopExitBasicBlock(), &b_);",
          "new_line_content": "                                           input_address_typed, 1);",
          "content_same": false
        },
        {
          "line": 1825,
          "old_api": "size",
          "new_api": null,
          "old_text": "accumulator.size()",
          "new_text": null,
          "old_line_content": "  result_ssa.reserve(accumulator.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1827,
          "old_api": "AlignedLoad",
          "new_api": null,
          "old_text": "AlignedLoad(accumulator_shard, element_alignment)",
          "new_text": null,
          "old_line_content": "    result_ssa.push_back(AlignedLoad(accumulator_shard, element_alignment));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1835,
          "old_api": "size",
          "new_api": null,
          "old_text": "value_to_store.size()",
          "new_text": null,
          "old_line_content": "  for (int i = 0; i < value_to_store.size(); i++) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1837,
          "old_api": "getType",
          "new_api": null,
          "old_text": "BitCast(store_address,\n                llvm::PointerType::getUnqual(value_to_store[i]->getType()))",
          "new_text": null,
          "old_line_content": "        BitCast(store_address,",
          "new_line_content": "    llvm::Value* store_address, const std::vector<llvm::Value*>& value_to_store,",
          "content_same": false
        },
        {
          "line": 1838,
          "old_api": "getType",
          "new_api": null,
          "old_text": "value_to_store[i]->getType()",
          "new_text": null,
          "old_line_content": "                llvm::PointerType::getUnqual(value_to_store[i]->getType()));",
          "new_line_content": "    const int alignment, const llvm_ir::IrArray& containing_array) {",
          "content_same": false
        },
        {
          "line": 1856,
          "old_api": "IsArray",
          "new_api": null,
          "old_text": "reduce->shape().IsArray()",
          "new_text": null,
          "old_line_content": "  if (!reduce->shape().IsArray()) {",
          "new_line_content": "StatusOr<bool> IrEmitter::EmitVectorizedReduce(",
          "content_same": false
        },
        {
          "line": 1861,
          "old_api": "ReductionPreservesLayout",
          "new_api": null,
          "old_text": "ReductionPreservesLayout(*reduce)",
          "new_text": null,
          "old_line_content": "  if (!ReductionPreservesLayout(*reduce)) {",
          "new_line_content": "    *failure_reason = \"vectorization of variadic reduce not implemented\";",
          "content_same": false
        },
        {
          "line": 1866,
          "old_api": "MatchReductionGenerator",
          "new_api": null,
          "old_text": "MatchReductionGenerator(function, failure_reason)",
          "new_text": null,
          "old_line_content": "      MatchReductionGenerator(function, failure_reason);",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 1872,
          "old_api": "vector_register_byte_size",
          "new_api": null,
          "old_text": "target_machine_features_.vector_register_byte_size(\n          *compute_function_->function())",
          "new_text": null,
          "old_line_content": "      target_machine_features_.vector_register_byte_size(",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 1873,
          "old_api": "function",
          "new_api": null,
          "old_text": "compute_function_->function()",
          "new_text": null,
          "old_line_content": "          *compute_function_->function()) /",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1874,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "reduce->shape().element_type()",
          "new_text": null,
          "old_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(reduce->shape().element_type());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1882,
          "old_api": "vectorization_factor_in_bytes",
          "new_api": null,
          "old_text": "target_machine_features_.vectorization_factor_in_bytes()",
          "new_text": null,
          "old_line_content": "      target_machine_features_.vectorization_factor_in_bytes();",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 1887,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "reduce->shape().element_type()",
          "new_text": null,
          "old_line_content": "      ShapeUtil::ByteSizeOfPrimitiveType(reduce->shape().element_type());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1889,
          "old_api": "layout",
          "new_api": null,
          "old_text": "absl::c_linear_search(\n      dimensions, LayoutUtil::Minor(arg->shape().layout(), 0))",
          "new_text": null,
          "old_line_content": "  bool is_reduction_over_minor_dimension = absl::c_linear_search(",
          "new_line_content": "  const int vectorization_factor =",
          "content_same": false
        },
        {
          "line": 1890,
          "old_api": "layout",
          "new_api": null,
          "old_text": "arg->shape().layout()",
          "new_text": null,
          "old_line_content": "      dimensions, LayoutUtil::Minor(arg->shape().layout(), 0));",
          "new_line_content": "      vectorization_factor_in_bytes /",
          "content_same": false
        },
        {
          "line": 1892,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "tensorflow::MathUtil::GCD<unsigned>(\n      ShapeUtil::ByteSizeOfPrimitiveType(reduce->shape().element_type()),\n      MinimumAlignmentForPrimitiveType(reduce->shape().element_type()))",
          "new_text": null,
          "old_line_content": "  unsigned element_alignment = tensorflow::MathUtil::GCD<unsigned>(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1902,
          "old_api": "IsTuple",
          "new_api": null,
          "old_text": "reduce->shape().IsTuple()",
          "new_text": null,
          "old_line_content": "  CHECK(!reduce->shape().IsTuple());",
          "new_line_content": "    *failure_reason = \"reduction over minor dimension not implemented\";",
          "content_same": false
        },
        {
          "line": 1903,
          "old_api": "EmitTargetAddressForOp",
          "new_api": null,
          "old_text": "EmitTargetAddressForOp(reduce)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(EmitTargetAddressForOp(reduce));",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 1925,
          "old_api": "IrName",
          "new_api": null,
          "old_text": "IrName(reduce)",
          "new_text": null,
          "old_line_content": "  llvm_ir::ForLoopNest loop_nest(IrName(reduce), &b_);",
          "new_line_content": "  //      output[d1, d0] = vector_acc",
          "content_same": false
        },
        {
          "line": 1927,
          "old_api": "dimensions_size",
          "new_api": null,
          "old_text": "reduce->shape().dimensions_size()",
          "new_text": null,
          "old_line_content": "      reduce->shape().dimensions_size());",
          "new_line_content": "  //  }",
          "content_same": false
        },
        {
          "line": 1928,
          "old_api": "shape",
          "new_api": null,
          "old_text": "reduce->shape()",
          "new_text": null,
          "old_line_content": "  for (int i = LayoutUtil::MinorToMajor(reduce->shape()).size() - 1; i > 0;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1930,
          "old_api": "layout",
          "new_api": null,
          "old_text": "reduce->shape().layout()",
          "new_text": null,
          "old_line_content": "    int64 dimension = LayoutUtil::Minor(reduce->shape().layout(), i);",
          "new_line_content": "  std::vector<llvm::Value*> array_multi_index(",
          "content_same": false
        },
        {
          "line": 1933,
          "old_api": "AddLoop",
          "new_api": null,
          "old_text": "loop_nest.AddLoop(\n        start_index, end_index, absl::StrFormat(\"dim.%d\", dimension))",
          "new_text": null,
          "old_line_content": "    std::unique_ptr<llvm_ir::ForLoop> loop = loop_nest.AddLoop(",
          "new_line_content": "       --i) {",
          "content_same": false
        },
        {
          "line": 1935,
          "old_api": "GetIndVarValue",
          "new_api": null,
          "old_text": "loop->GetIndVarValue()",
          "new_text": null,
          "old_line_content": "    array_multi_index[dimension] = loop->GetIndVarValue();",
          "new_line_content": "    int64 start_index = 0;",
          "content_same": false
        },
        {
          "line": 1940,
          "old_api": "dimensions",
          "new_api": null,
          "old_text": "reduce->shape().dimensions(innermost_dimension)",
          "new_text": null,
          "old_line_content": "      reduce->shape().dimensions(innermost_dimension);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1943,
          "old_api": "GetInnerLoopBodyBasicBlock",
          "new_api": null,
          "old_text": "loop_nest.GetInnerLoopBodyBasicBlock()",
          "new_text": null,
          "old_line_content": "          loop_nest.GetInnerLoopBodyBasicBlock()) {",
          "new_line_content": "  int64 innermost_dimension_size =",
          "content_same": false
        },
        {
          "line": 1954,
          "old_api": "AddLoop",
          "new_api": null,
          "old_text": "loop_nest.AddLoop(start_index, end_index, vectorization_factor,\n                          absl::StrFormat(\"dim.%d\", innermost_dimension))",
          "new_text": null,
          "old_line_content": "        loop_nest.AddLoop(start_index, end_index, vectorization_factor,",
          "new_line_content": "    int64 start_index = 0;",
          "content_same": false
        },
        {
          "line": 1955,
          "old_api": "absl::StrFormat(\"dim.%d\", innermost_dimension)",
          "new_api": null,
          "old_text": "absl::StrFormat(\"dim.%d\", innermost_dimension)",
          "new_text": null,
          "old_line_content": "                          absl::StrFormat(\"dim.%d\", innermost_dimension));",
          "new_line_content": "    int64 end_index = (innermost_dimension_size / vectorization_factor) *",
          "content_same": false
        },
        {
          "line": 1956,
          "old_api": "GetIndVarValue",
          "new_api": null,
          "old_text": "loop->GetIndVarValue()",
          "new_text": null,
          "old_line_content": "    array_multi_index[innermost_dimension] = loop->GetIndVarValue();",
          "new_line_content": "                      vectorization_factor;",
          "content_same": false
        },
        {
          "line": 1961,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "reduce->shape().element_type()",
          "new_text": null,
          "old_line_content": "        reduce->shape().element_type(), vectorization_factor);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1963,
          "old_api": "getInt64Ty",
          "new_api": null,
          "old_text": "b_.getInt64Ty()",
          "new_text": null,
          "old_line_content": "                                        b_.getInt64Ty());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1969,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(reduce)",
          "new_text": null,
          "old_line_content": "    llvm_ir::IrArray target_array = GetIrArrayFor(reduce);",
          "new_line_content": "                        EmitInnerLoopForVectorizedReduction(",
          "content_same": false
        },
        {
          "line": 1971,
          "old_api": "EmitArrayElementAddress",
          "new_api": null,
          "old_text": "target_array.EmitArrayElementAddress(array_index, &b_)",
          "new_text": null,
          "old_line_content": "        target_array.EmitArrayElementAddress(array_index, &b_);",
          "new_line_content": "                            init_value, arg, dimensions, element_alignment));",
          "content_same": false
        },
        {
          "line": 1972,
          "old_api": "EmitShardedVectorStore",
          "new_api": null,
          "old_text": "EmitShardedVectorStore(output_address, accumulator, element_alignment,\n                           target_array)",
          "new_text": null,
          "old_line_content": "    EmitShardedVectorStore(output_address, accumulator, element_alignment,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1977,
          "old_api": "SetInsertPoint",
          "new_api": null,
          "old_text": "b_.SetInsertPoint(exit_terminator)",
          "new_text": null,
          "old_line_content": "      b_.SetInsertPoint(exit_terminator);",
          "new_line_content": "                           target_array);",
          "content_same": false
        },
        {
          "line": 1990,
          "old_api": "getInt64",
          "new_api": null,
          "old_text": "b_.getInt64(innermost_dimension_size -\n                    (innermost_dimension_size % vectorization_factor))",
          "new_text": null,
          "old_line_content": "        b_.getInt64(innermost_dimension_size -",
          "new_line_content": "  // in the following case:",
          "content_same": false
        },
        {
          "line": 1993,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "CreateShardedVectorType(\n        reduce->shape().element_type(),\n        innermost_dimension_size % vectorization_factor)",
          "new_text": null,
          "old_line_content": "    ShardedVectorType vector_type = CreateShardedVectorType(",
          "new_line_content": "    array_multi_index[innermost_dimension] =",
          "content_same": false
        },
        {
          "line": 1996,
          "old_api": "shape",
          "new_api": null,
          "old_text": "reduce->shape()",
          "new_text": null,
          "old_line_content": "    llvm_ir::IrArray::Index array_index(array_multi_index, reduce->shape(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2003,
          "old_api": "GetIrArrayFor",
          "new_api": null,
          "old_text": "GetIrArrayFor(reduce)",
          "new_text": null,
          "old_line_content": "    llvm_ir::IrArray target_array = GetIrArrayFor(reduce);",
          "new_line_content": "                        EmitInnerLoopForVectorizedReduction(",
          "content_same": false
        },
        {
          "line": 2005,
          "old_api": "EmitArrayElementAddress",
          "new_api": null,
          "old_text": "target_array.EmitArrayElementAddress(array_index, &b_)",
          "new_text": null,
          "old_line_content": "        target_array.EmitArrayElementAddress(array_index, &b_);",
          "new_line_content": "                            init_value, arg, dimensions, element_alignment));",
          "content_same": false
        },
        {
          "line": 2006,
          "old_api": "EmitShardedVectorStore",
          "new_api": null,
          "old_text": "EmitShardedVectorStore(output_address, accumulator, element_alignment,\n                           target_array)",
          "new_text": null,
          "old_line_content": "    EmitShardedVectorStore(output_address, accumulator, element_alignment,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2011,
          "old_api": "SetInsertPoint",
          "new_api": null,
          "old_text": "b_.SetInsertPoint(outermost_loop_exit_block)",
          "new_text": null,
          "old_line_content": "    b_.SetInsertPoint(outermost_loop_exit_block);",
          "new_line_content": "                           target_array);",
          "content_same": false
        },
        {
          "line": 2022,
          "old_api": "shape",
          "new_api": null,
          "old_text": "reduce->shape()",
          "new_text": null,
          "old_line_content": "  const Shape& out_shape = reduce->shape();",
          "new_line_content": "    const HloReduceInstruction* reduce,",
          "content_same": false
        },
        {
          "line": 2023,
          "old_api": "IsArray",
          "new_api": null,
          "old_text": "out_shape.IsArray()",
          "new_text": null,
          "old_line_content": "  bool is_variadic = !out_shape.IsArray();",
          "new_line_content": "    std::vector<llvm_ir::ElementGenerator> input_generators,",
          "content_same": false
        },
        {
          "line": 2036,
          "old_api": "tuple_shapes",
          "new_api": null,
          "old_text": "out_shape.tuple_shapes(i)",
          "new_text": null,
          "old_line_content": "        is_variadic ? out_shape.tuple_shapes(i) : out_shape;",
          "new_line_content": "  std::vector<llvm::Value*> accumulator_addrs;",
          "content_same": false
        },
        {
          "line": 2037,
          "old_api": "element_type",
          "new_api": null,
          "old_text": "element_shape.element_type()",
          "new_text": null,
          "old_line_content": "    PrimitiveType accumulator_type = element_shape.element_type();",
          "new_line_content": "  std::vector<llvm::Type*> accumulator_types;",
          "content_same": false
        },
        {
          "line": 2039,
          "old_api": "llvm_ir::PrimitiveTypeToIrType(accumulator_type, module_)",
          "new_api": null,
          "old_text": "llvm_ir::PrimitiveTypeToIrType(accumulator_type, module_)",
          "new_text": null,
          "old_line_content": "        llvm_ir::PrimitiveTypeToIrType(accumulator_type, module_);",
          "new_line_content": "    const Shape& element_shape =",
          "content_same": false
        },
        {
          "line": 2045,
          "old_api": "MinimumAlignmentForPrimitiveType",
          "new_api": null,
          "old_text": "MinimumAlignmentForPrimitiveType(accumulator_type)",
          "new_text": null,
          "old_line_content": "        MinimumAlignmentForPrimitiveType(accumulator_type));",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 497,
      "total_additions": 740,
      "total_deletions": 737,
      "total_api_changes": 1974
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 6,
        "api_related_lines": 1974,
        "non_api_lines": 2,
        "non_api_line_numbers": [
          281,
          286
        ]
      }
    },
    "api_calls_before": 1989,
    "api_calls_after": 1997,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 2,
      "total_diff_lines": 20
    }
  }
}