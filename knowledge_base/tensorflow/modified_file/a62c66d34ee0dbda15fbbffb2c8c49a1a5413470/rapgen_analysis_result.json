{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/a62c66d34ee0dbda15fbbffb2c8c49a1a5413470",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/a62c66d34ee0dbda15fbbffb2c8c49a1a5413470/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/a62c66d34ee0dbda15fbbffb2c8c49a1a5413470/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/a62c66d34ee0dbda15fbbffb2c8c49a1a5413470/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 639,
          "old_api": "std::make_unique<PmapCacheEntry>()",
          "new_api": "std::unique_ptr<PmapCacheEntry>()",
          "old_text": "std::make_unique<PmapCacheEntry>()",
          "new_text": "std::unique_ptr<PmapCacheEntry>()",
          "old_line_content": "      arguments.signature, std::make_unique<PmapCacheEntry>());",
          "new_line_content": "      arguments.signature, std::unique_ptr<PmapCacheEntry>());",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": "py::cast<py::tuple>(out_and_fastpath_data)",
          "new_api": "ptr",
          "old_text": "py::cast<py::tuple>(out_and_fastpath_data)",
          "new_text": "out_and_fastpath_data.ptr()",
          "old_line_content": "        out_tuple = py::cast<py::tuple>(out_and_fastpath_data);",
          "new_line_content": "        if (!out_and_fastpath_data.ptr()) {",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": "PopulateCacheEntry",
          "new_api": "py::error_already_set()",
          "old_text": "PopulateCacheEntry(cache_entry, arguments.signature, out_tuple)",
          "new_text": "py::error_already_set()",
          "old_line_content": "        PopulateCacheEntry(cache_entry, arguments.signature, out_tuple);",
          "new_line_content": "          throw py::error_already_set();",
          "content_same": false
        },
        {
          "line": 660,
          "old_api": "Notify",
          "new_api": "PopulateCacheEntry",
          "old_text": "cache_entry.compilation_complete.Notify()",
          "new_text": "PopulateCacheEntry(cache_entry, arguments.signature, out_tuple)",
          "old_line_content": "        cache_entry.compilation_complete.Notify();",
          "new_line_content": "        PopulateCacheEntry(cache_entry, arguments.signature, out_tuple);",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "std::move(sharded_arg.owning_sda)",
          "new_api": "std::move(owned_buffer)",
          "old_text": "std::move(sharded_arg.owning_sda)",
          "new_text": "std::move(owned_buffer)",
          "old_line_content": "      arguments.keep_alive_objects.push_back(std::move(sharded_arg.owning_sda));",
          "new_line_content": "      arguments.keep_alive.push_back(std::move(owned_buffer));",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": "options",
          "new_api": "pjrt_executable",
          "old_text": "cache_entry.executable->options()",
          "new_text": "cache_entry.executable->pjrt_executable()",
          "old_line_content": "                                            cache_entry.executable->options()));",
          "new_line_content": "    auto pjrt_executable = cache_entry.executable->pjrt_executable();",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": "reserve",
          "new_api": "size",
          "old_text": "flat_sharded_device_arrays.reserve(num_outputs)",
          "new_text": "output_buffers[0].size()",
          "old_line_content": "  flat_sharded_device_arrays.reserve(num_outputs);",
          "new_line_content": "  const int num_outputs = output_buffers[0].size();",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": "std::move(output_buffers[computation][output_id])",
          "new_api": "reserve",
          "old_text": "std::move(output_buffers[computation][output_id])",
          "new_text": "outputs[output_id].reserve(num_computations)",
          "old_line_content": "            client, std::move(output_buffers[computation][output_id]),",
          "new_line_content": "      outputs[output_id].reserve(num_computations);",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": "std::move(outputs[i])",
          "new_api": "ShardedDeviceArray::Make(\n          /*aval=*/result_spec.out_aval,\n          /*sharding_spec=*/result_spec.out_spec,\n          /*device_buffers=*/py::cast(std::move(outputs[i])),\n          /*indices=*/result_spec.out_indices,\n          /*weak_type=*/result_spec.weak_type)",
          "old_text": "std::move(outputs[i])",
          "new_text": "ShardedDeviceArray::Make(\n          /*aval=*/result_spec.out_aval,\n          /*sharding_spec=*/result_spec.out_spec,\n          /*device_buffers=*/py::cast(std::move(outputs[i])),\n          /*indices=*/result_spec.out_indices,\n          /*weak_type=*/result_spec.weak_type)",
          "old_line_content": "          /*device_buffers=*/py::cast(std::move(outputs[i])),",
          "new_line_content": "      flat_sharded_device_arrays.push_back(ShardedDeviceArray::Make(",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": "GetPostHook",
          "new_api": "Unflatten",
          "old_text": "GetPostHook()",
          "new_text": "cache_entry.out_pytree_def.Unflatten(flat_sharded_device_arrays)",
          "old_line_content": "  std::optional<py::object> post_hook = GetPostHook();",
          "new_line_content": "      cache_entry.out_pytree_def.Unflatten(flat_sharded_device_arrays);",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": "PmapFunction::AsPmapFunctionUnchecked(handle)",
          "new_api": "PmapFunction::IsPmapFunction(handle)",
          "old_text": "PmapFunction::AsPmapFunctionUnchecked(handle)",
          "new_text": "PmapFunction::IsPmapFunction(handle)",
          "old_line_content": "  return PmapFunction::AsPmapFunctionUnchecked(handle);",
          "new_line_content": "  if (!PmapFunction::IsPmapFunction(handle)) {",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": "Call",
          "new_api": "function_name",
          "old_text": "o->fun.Call(callable, args, nargs, kwnames)",
          "new_text": "o->fun.function_name()",
          "old_line_content": "    xla::StatusOr<py::object> out = o->fun.Call(callable, args, nargs, kwnames);",
          "new_line_content": "    return absl::StrCat(\"JaxPmapFunction(\", o->fun.function_name(), \")\");",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": "value",
          "new_api": "status",
          "old_text": "out.value().release().ptr()",
          "new_text": "out.status().ToString().c_str()",
          "old_line_content": "    return out.value().release().ptr();",
          "new_line_content": "      PyErr_SetString(PyExc_ValueError, out.status().ToString().c_str());",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": "what",
          "new_api": "restore",
          "old_text": "e.what()",
          "new_text": "e.restore()",
          "old_line_content": "    PyErr_SetString(PyExc_ValueError, e.what());",
          "new_line_content": "    e.restore();",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": "PyObject_ClearWeakRefs",
          "new_api": "Py_TYPE",
          "old_text": "PyObject_ClearWeakRefs(self)",
          "new_text": "Py_TYPE(self)",
          "old_line_content": "    PyObject_ClearWeakRefs(self);",
          "new_line_content": "  PyTypeObject* tp = Py_TYPE(self);",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": "o->fun.~PmapFunction()",
          "new_api": "PyObject_ClearWeakRefs",
          "old_text": "o->fun.~PmapFunction()",
          "new_text": "PyObject_ClearWeakRefs(self)",
          "old_line_content": "  o->fun.~PmapFunction();",
          "new_line_content": "    PyObject_ClearWeakRefs(self);",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": "Py_DECREF",
          "new_api": "Py_CLEAR",
          "old_text": "Py_DECREF(tp)",
          "new_text": "Py_CLEAR(o->dict)",
          "old_line_content": "  Py_DECREF(tp);",
          "new_line_content": "  Py_CLEAR(o->dict);",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": "Py_TYPE",
          "new_api": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "old_text": "Py_TYPE(self)",
          "new_text": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "old_line_content": "  Py_VISIT(Py_TYPE(self));",
          "new_line_content": "  JaxPmapFunctionObject* o = reinterpret_cast<JaxPmapFunctionObject*>(self);",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": "fun",
          "new_api": "Py_TYPE",
          "old_text": "o->fun.fun().ptr()",
          "new_text": "Py_TYPE(self)",
          "old_line_content": "  Py_VISIT(o->fun.fun().ptr());",
          "new_line_content": "  Py_VISIT(Py_TYPE(self));",
          "content_same": false
        },
        {
          "line": 973,
          "old_api": "PyMethod_New",
          "new_api": "Py_INCREF",
          "old_text": "PyMethod_New(self, obj)",
          "new_text": "Py_INCREF(self)",
          "old_line_content": "  return PyMethod_New(self, obj);",
          "new_line_content": "    Py_INCREF(self);",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": "Py_TYPE",
          "new_api": "PyDict_Check",
          "old_text": "Py_TYPE(new_dict)",
          "new_text": "PyDict_Check(new_dict)",
          "old_line_content": "                 Py_TYPE(new_dict)->tp_name);",
          "new_line_content": "  if (!PyDict_Check(new_dict)) {",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": "Py_INCREF",
          "new_api": "Py_TYPE",
          "old_text": "Py_INCREF(new_dict)",
          "new_text": "Py_TYPE(new_dict)",
          "old_line_content": "  Py_INCREF(new_dict);",
          "new_line_content": "                 Py_TYPE(new_dict)->tp_name);",
          "content_same": false
        },
        {
          "line": 1024,
          "old_api": "ptr",
          "new_api": "JaxPmapFunction_tp_new",
          "old_text": "obj.ptr()",
          "new_text": "JaxPmapFunction_tp_new(\n      reinterpret_cast<PyTypeObject*>(JaxPmapFunction_Type), nullptr, nullptr)",
          "old_line_content": "      reinterpret_cast<JaxPmapFunctionObject*>(obj.ptr());",
          "new_line_content": "  py::object obj = py::reinterpret_steal<py::object>(JaxPmapFunction_tp_new(",
          "content_same": false
        },
        {
          "line": 1025,
          "old_api": "std::move(cache_miss)",
          "new_api": "reinterpret_cast<PyTypeObject*>(JaxPmapFunction_Type)",
          "old_text": "std::move(cache_miss)",
          "new_text": "reinterpret_cast<PyTypeObject*>(JaxPmapFunction_Type)",
          "old_line_content": "  InitializePmapFunction(buf, std::move(fun), std::move(cache_miss),",
          "new_line_content": "      reinterpret_cast<PyTypeObject*>(JaxPmapFunction_Type), nullptr, nullptr));",
          "content_same": false
        },
        {
          "line": 1027,
          "old_api": "std::move(python_shard_arg_fallback)",
          "new_api": "ptr",
          "old_text": "std::move(python_shard_arg_fallback)",
          "new_text": "obj.ptr()",
          "old_line_content": "                         std::move(python_shard_arg_fallback));",
          "new_line_content": "      reinterpret_cast<JaxPmapFunctionObject*>(obj.ptr());",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": "py::init<>()",
          "new_api": "def_submodule",
          "old_text": "py::init<>()",
          "new_text": "m.def_submodule(\"pmap_lib\", \"Jax C++ pmap library\")",
          "old_line_content": "  no_sharding.def(py::init<>())",
          "new_line_content": "  py::module pmap_lib = m.def_submodule(\"pmap_lib\", \"Jax C++ pmap library\");",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": "absl::HashOf(self)",
          "new_api": "py::isinstance<NoSharding>(obj)",
          "old_text": "absl::HashOf(self)",
          "new_text": "py::isinstance<NoSharding>(obj)",
          "old_line_content": "        const size_t hash = absl::HashOf(self);",
          "new_line_content": "             return py::isinstance<NoSharding>(obj);",
          "content_same": false
        },
        {
          "line": 1059,
          "old_api": "t[0].cast<std::vector<int>>()",
          "new_api": "py::init<std::vector<int>>()",
          "old_text": "t[0].cast<std::vector<int>>()",
          "new_text": "py::init<std::vector<int>>()",
          "old_line_content": "          [](py::tuple t) { return Chunked{t[0].cast<std::vector<int>>()}; }))",
          "new_line_content": "  chunked.def(py::init<std::vector<int>>())",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": "py::isinstance<Chunked>(other)",
          "new_api": "absl::StrJoin(chuncked.chunks, \",\")",
          "old_text": "py::isinstance<Chunked>(other)",
          "new_text": "absl::StrJoin(chuncked.chunks, \",\")",
          "old_line_content": "        if (!py::isinstance<Chunked>(other)) {",
          "new_line_content": "                                 absl::StrJoin(chuncked.chunks, \",\"), \")\");",
          "content_same": false
        },
        {
          "line": 1070,
          "old_api": "py::cast<const Chunked&>(other)",
          "new_api": "py::isinstance<Chunked>(other)",
          "old_text": "py::cast<const Chunked&>(other)",
          "new_text": "py::isinstance<Chunked>(other)",
          "old_line_content": "        return self == py::cast<const Chunked&>(other);",
          "new_line_content": "        if (!py::isinstance<Chunked>(other)) {",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": "t[0].cast<int>()",
          "new_api": "py::init<int>()",
          "old_text": "t[0].cast<int>()",
          "new_text": "py::init<int>()",
          "old_line_content": "          [](py::tuple t) { return Unstacked{t[0].cast<int>()}; }))",
          "new_line_content": "  unstacked.def(py::init<int>())",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": "py::isinstance<Unstacked>(other)",
          "new_api": "absl::StrCat(\"Unstacked(\", x.size, \")\")",
          "old_text": "py::isinstance<Unstacked>(other)",
          "new_text": "absl::StrCat(\"Unstacked(\", x.size, \")\")",
          "old_line_content": "        if (!py::isinstance<Unstacked>(other)) {",
          "new_line_content": "             return absl::StrCat(\"Unstacked(\", x.size, \")\");",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": "py::cast<const Unstacked&>(other)",
          "new_api": "py::isinstance<Unstacked>(other)",
          "old_text": "py::cast<const Unstacked&>(other)",
          "new_text": "py::isinstance<Unstacked>(other)",
          "old_line_content": "        return self == py::cast<const Unstacked&>(other);",
          "new_line_content": "        if (!py::isinstance<Unstacked>(other)) {",
          "content_same": false
        },
        {
          "line": 1094,
          "old_api": "t[0].cast<int>()",
          "new_api": "py::init<int>()",
          "old_text": "t[0].cast<int>()",
          "new_text": "py::init<int>()",
          "old_line_content": "          [](py::tuple t) { return ShardedAxis{t[0].cast<int>()}; }))",
          "new_line_content": "  sharded_axis.def(py::init<int>())",
          "content_same": false
        },
        {
          "line": 1108,
          "old_api": "t[0].cast<int>()",
          "new_api": "py::init<int>()",
          "old_text": "t[0].cast<int>()",
          "new_text": "py::init<int>()",
          "old_line_content": "          [](py::tuple t) { return Replicated{t[0].cast<int>()}; }))",
          "new_line_content": "  replicated.def(py::init<int>())",
          "content_same": false
        },
        {
          "line": 1122,
          "old_api": "GetSharding",
          "new_api": "def",
          "old_text": "py::pickle(\n          [](const ShardingSpec& self) {\n            auto sharding =\n                xla::SpanToTuple(absl::MakeConstSpan(self.GetSharding()));\n            auto mesh_mapping =\n                xla::SpanToTuple(absl::MakeConstSpan(self.GetMeshMapping()));\n            return py::make_tuple(sharding, mesh_mapping);\n          },\n          [](py::tuple t) {\n            return ShardingSpec{t[0].cast<std::vector<AvalDimSharding>>(),\n                                t[1].cast<std::vector<MeshDimAssignment>>()};\n          })",
          "new_text": "sharding_spec\n      .def(py::init<py::iterable, py::iterable>(), py::arg(\"sharding\"),\n           py::arg(\"mesh_mapping\"))\n      .def(py::pickle(\n          [](const ShardingSpec& self) {\n            auto sharding =\n                xla::SpanToTuple(absl::MakeConstSpan(self.GetSharding()));\n            auto mesh_mapping =\n                xla::SpanToTuple(absl::MakeConstSpan(self.GetMeshMapping()));\n            return py::make_tuple(sharding, mesh_mapping);\n          },\n          [](py::tuple t) {\n            return ShardingSpec{t[0].cast<std::vector<AvalDimSharding>>(),\n                                t[1].cast<std::vector<MeshDimAssignment>>()};\n          }))\n      .def_property_readonly(\n          \"sharding\",\n          [](const ShardingSpec& self) {\n            return xla::SpanToTuple(absl::MakeConstSpan(self.GetSharding()));\n          })\n      .def_property_readonly(\n          \"mesh_mapping\",\n          [](const ShardingSpec& self) {\n            return xla::SpanToTuple(absl::MakeConstSpan(self.GetMeshMapping()));\n          })\n      .def(\"__eq__\", [](const ShardingSpec& self,\n                        const ShardingSpec& other) { return self == other; })\n      .def(\"__hash__\", [](const ShardingSpec& self) {\n        const size_t hash = absl::HashOf(self);\n        return py::int_(hash);\n      })",
          "old_line_content": "      .def(py::pickle(",
          "new_line_content": "  sharding_spec",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": "py::make_tuple(sharding, mesh_mapping)",
          "new_api": "GetSharding",
          "old_text": "py::make_tuple(sharding, mesh_mapping)",
          "new_text": "self.GetSharding()",
          "old_line_content": "            return py::make_tuple(sharding, mesh_mapping);",
          "new_line_content": "                xla::SpanToTuple(absl::MakeConstSpan(self.GetSharding()));",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": "t[0].cast<std::vector<AvalDimSharding>>()",
          "new_api": "py::make_tuple(sharding, mesh_mapping)",
          "old_text": "t[0].cast<std::vector<AvalDimSharding>>()",
          "new_text": "py::make_tuple(sharding, mesh_mapping)",
          "old_line_content": "            return ShardingSpec{t[0].cast<std::vector<AvalDimSharding>>(),",
          "new_line_content": "            return py::make_tuple(sharding, mesh_mapping);",
          "content_same": false
        },
        {
          "line": 1151,
          "old_api": "ShardedDeviceArray::RegisterTypes(pmap_lib)",
          "new_api": "py::int_(hash)",
          "old_text": "ShardedDeviceArray::RegisterTypes(pmap_lib)",
          "new_text": "py::int_(hash)",
          "old_line_content": "  TF_CHECK_OK(ShardedDeviceArray::RegisterTypes(pmap_lib));",
          "new_line_content": "        return py::int_(hash);",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": "tp_alloc",
          "new_api": "py::str(\"PmapFunction\")",
          "old_text": "PyType_Type.tp_alloc(&PyType_Type, 0)",
          "new_text": "py::str(\"PmapFunction\")",
          "old_line_content": "        PyType_Type.tp_alloc(&PyType_Type, 0));",
          "new_line_content": "    py::str name = py::str(\"PmapFunction\");",
          "content_same": false
        },
        {
          "line": 1184,
          "old_api": "py::reinterpret_borrow<py::object>(JaxPmapFunction_Type)",
          "new_api": "offsetof",
          "old_text": "py::reinterpret_borrow<py::object>(JaxPmapFunction_Type)",
          "new_text": "offsetof(JaxPmapFunctionObject, vectorcall)",
          "old_line_content": "    cfun = py::reinterpret_borrow<py::object>(JaxPmapFunction_Type);",
          "new_line_content": "    type->tp_vectorcall_offset = offsetof(JaxPmapFunctionObject, vectorcall);",
          "content_same": false
        },
        {
          "line": 1190,
          "old_api": "attr",
          "new_api": "py::reinterpret_borrow<py::object>(JaxPmapFunction_Type)",
          "old_text": "m.attr(\"PmapFunction\")",
          "new_text": "py::reinterpret_borrow<py::object>(JaxPmapFunction_Type)",
          "old_line_content": "  m.attr(\"PmapFunction\") = cfun_type;",
          "new_line_content": "      py::reinterpret_borrow<py::object>(JaxPmapFunction_Type);",
          "content_same": false
        },
        {
          "line": 1193,
          "old_api": "PythonSignature",
          "new_api": "attr",
          "old_text": "property_readonly([](py::handle self) -> xla::StatusOr<py::object> {\n        TF_ASSIGN_OR_RETURN(PmapFunction * fun, AsPmapFunction(self));\n        return fun->PythonSignature();\n      })",
          "new_text": "m.attr(\"PmapFunction\")",
          "old_line_content": "      property_readonly([](py::handle self) -> xla::StatusOr<py::object> {",
          "new_line_content": "  m.attr(\"PmapFunction\") = cfun_type;",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": "PythonSignature",
          "new_api": "attr",
          "old_text": "fun->PythonSignature()",
          "new_text": "cfun.attr(\"__signature__\")",
          "old_line_content": "        return fun->PythonSignature();",
          "new_line_content": "  cfun.attr(\"__signature__\") =",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": "attr",
          "new_api": "PythonSignature",
          "old_text": "cfun.attr(\"_cache_miss\")",
          "new_text": "fun->PythonSignature()",
          "old_line_content": "  cfun.attr(\"_cache_miss\") =",
          "new_line_content": "        return fun->PythonSignature();",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": "cache_miss",
          "new_api": "attr",
          "old_text": "fun->cache_miss()",
          "new_text": "cfun.attr(\"_cache_miss\")",
          "old_line_content": "        return fun->cache_miss();",
          "new_line_content": "  cfun.attr(\"_cache_miss\") =",
          "content_same": false
        },
        {
          "line": 1203,
          "old_api": "func",
          "new_api": "AsPmapFunction",
          "old_text": "py::cpp_function(\n      [](const PmapFunction::object& self) {\n        PmapFunction* fn = self.func();\n        py::dict pickle;\n        pickle[\"version\"] = kPmapFunctionPickleVersion;\n        pickle[\"fun\"] = fn->fun();\n        pickle[\"cache_miss\"] = fn->cache_miss();\n        pickle[\"static_argnums\"] = fn->static_argnums();\n        pickle[\"python_shard_arg_fallback\"] = fn->python_shard_arg_fallback();\n        return pickle;\n      },\n      py::is_method(cfun_type))",
          "new_text": "AsPmapFunction(self)",
          "old_line_content": "  cfun.attr(\"__getstate__\") = py::cpp_function(",
          "new_line_content": "        TF_ASSIGN_OR_RETURN(PmapFunction * fun, AsPmapFunction(self));",
          "content_same": false
        },
        {
          "line": 1208,
          "old_api": "fun",
          "new_api": "func",
          "old_text": "fn->fun()",
          "new_text": "self.func()",
          "old_line_content": "        pickle[\"fun\"] = fn->fun();",
          "new_line_content": "        PmapFunction* fn = self.func();",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": "python_shard_arg_fallback",
          "new_api": "fun",
          "old_text": "fn->python_shard_arg_fallback()",
          "new_text": "fn->fun()",
          "old_line_content": "        pickle[\"python_shard_arg_fallback\"] = fn->python_shard_arg_fallback();",
          "new_line_content": "        pickle[\"fun\"] = fn->fun();",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": "py::is_method(cfun_type)",
          "new_api": "python_shard_arg_fallback",
          "old_text": "py::is_method(cfun_type)",
          "new_text": "fn->python_shard_arg_fallback()",
          "old_line_content": "      py::is_method(cfun_type));",
          "new_line_content": "        pickle[\"python_shard_arg_fallback\"] = fn->python_shard_arg_fallback();",
          "content_same": false
        },
        {
          "line": 1217,
          "old_api": "py::cast<int>(pickle[\"version\"])",
          "new_api": "py::is_method(cfun_type)",
          "old_text": "py::cast<int>(pickle[\"version\"])",
          "new_text": "py::is_method(cfun_type)",
          "old_line_content": "        int version = py::cast<int>(pickle[\"version\"]);",
          "new_line_content": "      py::is_method(cfun_type));",
          "content_same": false
        },
        {
          "line": 1228,
          "old_api": "py::cast<std::vector<int>>(pickle[\"static_argnums\"])",
          "new_api": "py::cast<py::function>(pickle[\"fun\"])",
          "old_text": "py::cast<std::vector<int>>(pickle[\"static_argnums\"])",
          "new_text": "py::cast<py::function>(pickle[\"fun\"])",
          "old_line_content": "            py::cast<std::vector<int>>(pickle[\"static_argnums\"]);",
          "new_line_content": "        py::function fun = py::cast<py::function>(pickle[\"fun\"]);",
          "content_same": false
        },
        {
          "line": 1233,
          "old_api": "ptr",
          "new_api": "py::cast<py::function>(pickle[\"python_shard_arg_fallback\"])",
          "old_text": "self.ptr()",
          "new_text": "py::cast<py::function>(pickle[\"python_shard_arg_fallback\"])",
          "old_line_content": "            reinterpret_cast<JaxPmapFunctionObject*>(self.ptr()),",
          "new_line_content": "            py::cast<py::function>(pickle[\"python_shard_arg_fallback\"]);",
          "content_same": false
        },
        {
          "line": 1235,
          "old_api": "std::move(python_shard_arg_fallback)",
          "new_api": "ptr",
          "old_text": "std::move(python_shard_arg_fallback)",
          "new_text": "InitializePmapFunction(\n            reinterpret_cast<JaxPmapFunctionObject*>(self.ptr()),\n            std::move(fun), std::move(cache_miss), std::move(static_argnums),\n            std::move(python_shard_arg_fallback))",
          "old_line_content": "            std::move(python_shard_arg_fallback));",
          "new_line_content": "        InitializePmapFunction(",
          "content_same": false
        },
        {
          "line": 1237,
          "old_api": "py::is_method(cfun_type)",
          "new_api": "std::move(static_argnums)",
          "old_text": "py::is_method(cfun_type)",
          "new_text": "std::move(static_argnums)",
          "old_line_content": "      py::is_method(cfun_type));",
          "new_line_content": "            std::move(fun), std::move(cache_miss), std::move(static_argnums),",
          "content_same": false
        },
        {
          "line": 1240,
          "old_api": "attr",
          "new_api": "py::is_method(cfun_type)",
          "old_text": "cfun.attr(\"_cache_size\")",
          "new_text": "py::is_method(cfun_type)",
          "old_line_content": "  cfun.attr(\"_cache_size\") =",
          "new_line_content": "      py::is_method(cfun_type));",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": "cache_size",
          "new_api": "attr",
          "old_text": "fun->cache_size()",
          "new_text": "cfun.attr(\"_cache_size\")",
          "old_line_content": "        return py::cast<int>(fun->cache_size());",
          "new_line_content": "  cfun.attr(\"_cache_size\") =",
          "content_same": false
        },
        {
          "line": 1246,
          "old_api": "DebugCacheKeys",
          "new_api": "cache_size",
          "old_text": "py::cpp_function(\n      [](py::handle self) -> xla::StatusOr<std::string> {\n        TF_ASSIGN_OR_RETURN(PmapFunction * fun, AsPmapFunction(self));\n        return fun->DebugCacheKeys();\n      },\n      py::is_method(cfun_type))",
          "new_text": "fun->cache_size()",
          "old_line_content": "  cfun.attr(\"_debug_cache_keys\") = py::cpp_function(",
          "new_line_content": "        return py::cast<int>(fun->cache_size());",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": "py::is_method(cfun_type)",
          "new_api": "AsPmapFunction",
          "old_text": "py::is_method(cfun_type)",
          "new_text": "AsPmapFunction(self)",
          "old_line_content": "      py::is_method(cfun_type));",
          "new_line_content": "        TF_ASSIGN_OR_RETURN(PmapFunction * fun, AsPmapFunction(self));",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1028,
          "old_api": null,
          "new_api": "std::move(cache_miss)",
          "old_text": null,
          "new_text": "std::move(cache_miss)",
          "old_line_content": "  return obj;",
          "new_line_content": "  InitializePmapFunction(buf, std::move(fun), std::move(cache_miss),",
          "content_same": false
        },
        {
          "line": 1029,
          "old_api": null,
          "new_api": "std::move(static_argnums)",
          "old_text": null,
          "new_text": "std::move(static_argnums)",
          "old_line_content": "}",
          "new_line_content": "                         std::move(static_argnums),",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": null,
          "new_api": "std::move(python_shard_arg_fallback)",
          "old_text": null,
          "new_text": "std::move(python_shard_arg_fallback)",
          "old_line_content": "",
          "new_line_content": "                         std::move(python_shard_arg_fallback));",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": null,
          "new_api": "py::init<>()",
          "old_text": null,
          "new_text": "py::init<>()",
          "old_line_content": "      .def(\"__repr__\",",
          "new_line_content": "  no_sharding.def(py::init<>())",
          "content_same": false
        },
        {
          "line": 1045,
          "old_api": null,
          "new_api": "py::make_tuple()",
          "old_text": null,
          "new_text": "py::make_tuple()",
          "old_line_content": "           [](const NoSharding& chuncked) { return \"NoSharding()\"; })",
          "new_line_content": "      .def(py::pickle([](const NoSharding& self) { return py::make_tuple(); },",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": null,
          "new_api": "absl::HashOf(self)",
          "old_text": null,
          "new_text": "absl::HashOf(self)",
          "old_line_content": "",
          "new_line_content": "        const size_t hash = absl::HashOf(self);",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": null,
          "new_api": "py::int_(hash)",
          "old_text": null,
          "new_text": "py::int_(hash)",
          "old_line_content": "  py::class_<Chunked> chunked(pmap_lib, \"Chunked\");",
          "new_line_content": "        return py::int_(hash);",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": null,
          "new_api": "py::pickle(\n          [](const Chunked& self) { return py::make_tuple(self.chunks); },\n          [](py::tuple t) { return Chunked{t[0].cast<std::vector<int>>()}; })",
          "old_text": null,
          "new_text": "py::pickle(\n          [](const Chunked& self) { return py::make_tuple(self.chunks); },\n          [](py::tuple t) { return Chunked{t[0].cast<std::vector<int>>()}; })",
          "old_line_content": "      .def_readonly(\"chunks\", &Chunked::chunks)",
          "new_line_content": "      .def(py::pickle(",
          "content_same": false
        },
        {
          "line": 1061,
          "old_api": null,
          "new_api": "py::make_tuple(self.chunks)",
          "old_text": null,
          "new_text": "py::make_tuple(self.chunks)",
          "old_line_content": "      .def(\"__repr__\",",
          "new_line_content": "          [](const Chunked& self) { return py::make_tuple(self.chunks); },",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": null,
          "new_api": "t[0].cast<std::vector<int>>()",
          "old_text": null,
          "new_text": "t[0].cast<std::vector<int>>()",
          "old_line_content": "           [](const Chunked& chuncked) {",
          "new_line_content": "          [](py::tuple t) { return Chunked{t[0].cast<std::vector<int>>()}; }))",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": null,
          "new_api": "absl::StrCat(\"Chunked(\",\n                                 absl::StrJoin(chuncked.chunks, \",\"), \")\")",
          "old_text": null,
          "new_text": "absl::StrCat(\"Chunked(\",\n                                 absl::StrJoin(chuncked.chunks, \",\"), \")\")",
          "old_line_content": "      .def(\"__eq__\", [](const Chunked& self, py::object other) {",
          "new_line_content": "             return absl::StrCat(\"Chunked(\",",
          "content_same": false
        },
        {
          "line": 1073,
          "old_api": null,
          "new_api": "py::cast<const Chunked&>(other)",
          "old_text": null,
          "new_text": "py::cast<const Chunked&>(other)",
          "old_line_content": "  py::class_<Unstacked> unstacked(pmap_lib, \"Unstacked\");",
          "new_line_content": "        return self == py::cast<const Chunked&>(other);",
          "content_same": false
        },
        {
          "line": 1078,
          "old_api": null,
          "new_api": "py::pickle(\n          [](const Unstacked& self) { return py::make_tuple(self.size); },\n          [](py::tuple t) { return Unstacked{t[0].cast<int>()}; })",
          "old_text": null,
          "new_text": "py::pickle(\n          [](const Unstacked& self) { return py::make_tuple(self.size); },\n          [](py::tuple t) { return Unstacked{t[0].cast<int>()}; })",
          "old_line_content": "      .def_readonly(\"size\", &Unstacked::size)",
          "new_line_content": "      .def(py::pickle(",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": null,
          "new_api": "py::make_tuple(self.size)",
          "old_text": null,
          "new_text": "py::make_tuple(self.size)",
          "old_line_content": "      .def(\"__repr__\",",
          "new_line_content": "          [](const Unstacked& self) { return py::make_tuple(self.size); },",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": null,
          "new_api": "t[0].cast<int>()",
          "old_text": null,
          "new_text": "t[0].cast<int>()",
          "old_line_content": "           [](const Unstacked& x) {",
          "new_line_content": "          [](py::tuple t) { return Unstacked{t[0].cast<int>()}; }))",
          "content_same": false
        },
        {
          "line": 1090,
          "old_api": null,
          "new_api": "py::cast<const Unstacked&>(other)",
          "old_text": null,
          "new_text": "py::cast<const Unstacked&>(other)",
          "old_line_content": "  py::class_<ShardedAxis> sharded_axis(pmap_lib, \"ShardedAxis\");",
          "new_line_content": "        return self == py::cast<const Unstacked&>(other);",
          "content_same": false
        },
        {
          "line": 1095,
          "old_api": null,
          "new_api": "py::pickle(\n          [](const ShardedAxis& self) { return py::make_tuple(self.axis); },\n          [](py::tuple t) { return ShardedAxis{t[0].cast<int>()}; })",
          "old_text": null,
          "new_text": "py::pickle(\n          [](const ShardedAxis& self) { return py::make_tuple(self.axis); },\n          [](py::tuple t) { return ShardedAxis{t[0].cast<int>()}; })",
          "old_line_content": "      .def_readonly(\"axis\", &ShardedAxis::axis)",
          "new_line_content": "      .def(py::pickle(",
          "content_same": false
        },
        {
          "line": 1096,
          "old_api": null,
          "new_api": "py::make_tuple(self.axis)",
          "old_text": null,
          "new_text": "py::make_tuple(self.axis)",
          "old_line_content": "      .def(\"__repr__\",",
          "new_line_content": "          [](const ShardedAxis& self) { return py::make_tuple(self.axis); },",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": null,
          "new_api": "t[0].cast<int>()",
          "old_text": null,
          "new_text": "t[0].cast<int>()",
          "old_line_content": "           [](const ShardedAxis& x) {",
          "new_line_content": "          [](py::tuple t) { return ShardedAxis{t[0].cast<int>()}; }))",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": null,
          "new_api": "absl::StrCat(\"ShardedAxis(axis=\", x.axis, \")\")",
          "old_text": null,
          "new_text": "absl::StrCat(\"ShardedAxis(axis=\", x.axis, \")\")",
          "old_line_content": "        return self == other;",
          "new_line_content": "             return absl::StrCat(\"ShardedAxis(axis=\", x.axis, \")\");",
          "content_same": false
        },
        {
          "line": 1109,
          "old_api": null,
          "new_api": "py::pickle(\n          [](const Replicated& self) { return py::make_tuple(self.replicas); },\n          [](py::tuple t) { return Replicated{t[0].cast<int>()}; })",
          "old_text": null,
          "new_text": "py::pickle(\n          [](const Replicated& self) { return py::make_tuple(self.replicas); },\n          [](py::tuple t) { return Replicated{t[0].cast<int>()}; })",
          "old_line_content": "      .def_readonly(\"replicas\", &Replicated::replicas)",
          "new_line_content": "      .def(py::pickle(",
          "content_same": false
        },
        {
          "line": 1110,
          "old_api": null,
          "new_api": "py::make_tuple(self.replicas)",
          "old_text": null,
          "new_text": "py::make_tuple(self.replicas)",
          "old_line_content": "      .def(\"__repr__\",",
          "new_line_content": "          [](const Replicated& self) { return py::make_tuple(self.replicas); },",
          "content_same": false
        },
        {
          "line": 1111,
          "old_api": null,
          "new_api": "t[0].cast<int>()",
          "old_text": null,
          "new_text": "t[0].cast<int>()",
          "old_line_content": "           [](const Replicated& x) {",
          "new_line_content": "          [](py::tuple t) { return Replicated{t[0].cast<int>()}; }))",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": null,
          "new_api": "absl::StrCat(\"Replicated(replicas=\", x.replicas, \")\")",
          "old_text": null,
          "new_text": "absl::StrCat(\"Replicated(replicas=\", x.replicas, \")\")",
          "old_line_content": "        return self == other;",
          "new_line_content": "             return absl::StrCat(\"Replicated(replicas=\", x.replicas, \")\");",
          "content_same": false
        },
        {
          "line": 1123,
          "old_api": null,
          "new_api": "py::arg(\"sharding\")",
          "old_text": null,
          "new_text": "py::arg(\"sharding\")",
          "old_line_content": "          [](const ShardingSpec& self) {",
          "new_line_content": "      .def(py::init<py::iterable, py::iterable>(), py::arg(\"sharding\"),",
          "content_same": false
        },
        {
          "line": 1124,
          "old_api": null,
          "new_api": "py::arg(\"mesh_mapping\")",
          "old_text": null,
          "new_text": "py::arg(\"mesh_mapping\")",
          "old_line_content": "            auto sharding =",
          "new_line_content": "           py::arg(\"mesh_mapping\"))",
          "content_same": false
        },
        {
          "line": 1130,
          "old_api": null,
          "new_api": "GetMeshMapping",
          "old_text": null,
          "new_text": "self.GetMeshMapping()",
          "old_line_content": "          [](py::tuple t) {",
          "new_line_content": "                xla::SpanToTuple(absl::MakeConstSpan(self.GetMeshMapping()));",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": null,
          "new_api": "t[0].cast<std::vector<AvalDimSharding>>()",
          "old_text": null,
          "new_text": "t[0].cast<std::vector<AvalDimSharding>>()",
          "old_line_content": "      .def_property_readonly(",
          "new_line_content": "            return ShardingSpec{t[0].cast<std::vector<AvalDimSharding>>(),",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": null,
          "new_api": "t[1].cast<std::vector<MeshDimAssignment>>()",
          "old_text": null,
          "new_text": "t[1].cast<std::vector<MeshDimAssignment>>()",
          "old_line_content": "          \"sharding\",",
          "new_line_content": "                                t[1].cast<std::vector<MeshDimAssignment>>()};",
          "content_same": false
        },
        {
          "line": 1140,
          "old_api": null,
          "new_api": "GetSharding",
          "old_text": null,
          "new_text": "self.GetSharding()",
          "old_line_content": "          \"mesh_mapping\",",
          "new_line_content": "            return xla::SpanToTuple(absl::MakeConstSpan(self.GetSharding()));",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": null,
          "new_api": "GetMeshMapping",
          "old_text": null,
          "new_text": "self.GetMeshMapping()",
          "old_line_content": "                        const ShardingSpec& other) { return self == other; })",
          "new_line_content": "            return xla::SpanToTuple(absl::MakeConstSpan(self.GetMeshMapping()));",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": null,
          "new_api": "absl::HashOf(self)",
          "old_text": null,
          "new_text": "absl::HashOf(self)",
          "old_line_content": "",
          "new_line_content": "        const size_t hash = absl::HashOf(self);",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": null,
          "new_api": "std::make_unique<PmapCacheEntry>()",
          "old_text": null,
          "new_text": "std::make_unique<PmapCacheEntry>()",
          "old_line_content": "",
          "new_line_content": "    it->second = std::make_unique<PmapCacheEntry>();",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": null,
          "new_api": "ShardedDeviceArray::RegisterTypes(pmap_lib)",
          "old_text": null,
          "new_text": "ShardedDeviceArray::RegisterTypes(pmap_lib)",
          "old_line_content": "  // additional methods dynamically.",
          "new_line_content": "  TF_CHECK_OK(ShardedDeviceArray::RegisterTypes(pmap_lib));",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": null,
          "new_api": "HasBeenNotified",
          "old_text": null,
          "new_text": "cache_entry.compilation_complete.HasBeenNotified()",
          "old_line_content": "    if (inserted) {",
          "new_line_content": "  if (!cache_entry.compilation_complete.HasBeenNotified()) {",
          "content_same": false
        },
        {
          "line": 1161,
          "old_api": null,
          "new_api": "py::str(\"PmapFunction\")",
          "old_text": null,
          "new_text": "py::str(\"PmapFunction\")",
          "old_line_content": "    // Caution: we must not call any functions that might invoke the GC until",
          "new_line_content": "    py::str qualname = py::str(\"PmapFunction\");",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": null,
          "new_api": "tp_alloc",
          "old_text": null,
          "new_text": "reinterpret_cast<PyHeapTypeObject*>(\n        PyType_Type.tp_alloc(&PyType_Type, 0))",
          "old_line_content": "    // PyType_Ready() is called. Otherwise the GC might see a half-constructed",
          "new_line_content": "    PyHeapTypeObject* heap_type = reinterpret_cast<PyHeapTypeObject*>(",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": null,
          "new_api": "DebugString",
          "old_text": null,
          "new_text": "arguments.signature.DebugString()",
          "old_line_content": "        // compilation/tracing fails.",
          "new_line_content": "      VLOG(2) << \"Cache miss for \" << arguments.signature.DebugString();",
          "content_same": false
        },
        {
          "line": 1163,
          "old_api": null,
          "new_api": "tp_alloc",
          "old_text": null,
          "new_text": "PyType_Type.tp_alloc(&PyType_Type, 0)",
          "old_line_content": "    // type object.",
          "new_line_content": "        PyType_Type.tp_alloc(&PyType_Type, 0));",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": null,
          "new_api": "cache_miss",
          "old_text": null,
          "new_text": "cache_miss()",
          "old_line_content": "        }",
          "new_line_content": "        out_and_fastpath_data = cache_miss();",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(heap_type)",
          "old_line_content": "    PyTypeObject* type = &heap_type->ht_type;",
          "new_line_content": "    CHECK(heap_type) << \"Unable to create heap type object\";",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": null,
          "new_api": "release",
          "old_text": null,
          "new_text": "name.release().ptr()",
          "old_line_content": "    type->tp_name = \"PmapFunction\";",
          "new_line_content": "    heap_type->ht_name = name.release().ptr();",
          "content_same": false
        },
        {
          "line": 1169,
          "old_api": null,
          "new_api": "release",
          "old_text": null,
          "new_text": "qualname.release().ptr()",
          "old_line_content": "    type->tp_basicsize = sizeof(JaxPmapFunctionObject);",
          "new_line_content": "    heap_type->ht_qualname = qualname.release().ptr();",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": null,
          "new_api": "py::cast<py::tuple>(out_and_fastpath_data)",
          "old_text": null,
          "new_text": "py::cast<py::tuple>(out_and_fastpath_data)",
          "old_line_content": "        cache_entry.fall_back_to_python = true;",
          "new_line_content": "        out_tuple = py::cast<py::tuple>(out_and_fastpath_data);",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": null,
          "new_api": "Notify",
          "old_text": null,
          "new_text": "cache_entry.compilation_complete.Notify()",
          "old_line_content": "      // it. We are even *required* to do so if there are donated arguments,",
          "new_line_content": "      cache_entry.compilation_complete.Notify();",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": null,
          "new_api": "offsetof",
          "old_text": null,
          "new_text": "offsetof(JaxPmapFunctionObject, weakrefs)",
          "old_line_content": "    type->tp_call = PyVectorcall_Call;",
          "new_line_content": "    type->tp_weaklistoffset = offsetof(JaxPmapFunctionObject, weakrefs);",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": null,
          "new_api": "py::object(out_tuple[0])",
          "old_text": null,
          "new_text": "py::object(out_tuple[0])",
          "old_line_content": "      // lock it.",
          "new_line_content": "      return py::object(out_tuple[0]);",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": null,
          "new_api": "PyType_Ready",
          "old_text": null,
          "new_text": "PyType_Ready(type)",
          "old_line_content": "  }",
          "new_line_content": "    CHECK_EQ(PyType_Ready(type), 0);",
          "content_same": false
        },
        {
          "line": 1186,
          "old_api": null,
          "new_api": "reinterpret_cast<PyObject*>(type)",
          "old_text": null,
          "new_text": "reinterpret_cast<PyObject*>(type)",
          "old_line_content": "  py::object cfun_type =",
          "new_line_content": "    JaxPmapFunction_Type = reinterpret_cast<PyObject*>(type);",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": null,
          "new_api": "WaitForNotification",
          "old_text": null,
          "new_text": "cache_entry.compilation_complete.WaitForNotification()",
          "old_line_content": "  if (cache_entry.fall_back_to_python) {",
          "new_line_content": "      cache_entry.compilation_complete.WaitForNotification();",
          "content_same": false
        },
        {
          "line": 680,
          "old_api": null,
          "new_api": "fallback_to_cache_miss",
          "old_text": null,
          "new_text": "fallback_to_cache_miss()",
          "old_line_content": "  // 1. Parse arguments.",
          "new_line_content": "    return fallback_to_cache_miss();",
          "content_same": false
        },
        {
          "line": 1196,
          "old_api": null,
          "new_api": "PythonSignature",
          "old_text": null,
          "new_text": "property_readonly([](py::handle self) -> xla::StatusOr<py::object> {\n        TF_ASSIGN_OR_RETURN(PmapFunction * fun, AsPmapFunction(self));\n        return fun->PythonSignature();\n      })",
          "old_line_content": "      });",
          "new_line_content": "      property_readonly([](py::handle self) -> xla::StatusOr<py::object> {",
          "content_same": false
        },
        {
          "line": 1197,
          "old_api": null,
          "new_api": "AsPmapFunction",
          "old_text": null,
          "new_text": "AsPmapFunction(self)",
          "old_line_content": "  // Required by `post_hook`.",
          "new_line_content": "        TF_ASSIGN_OR_RETURN(PmapFunction * fun, AsPmapFunction(self));",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "cache_entry.executable->AddressableDevices().size()",
          "old_line_content": "",
          "new_line_content": "      cache_entry.executable->AddressableDevices().size();",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "arguments.flat_dynamic_args.size()",
          "old_line_content": "  // We need [num_args] for the `Execute` call below.",
          "new_line_content": "  const int num_args = arguments.flat_dynamic_args.size();",
          "content_same": false
        },
        {
          "line": 1202,
          "old_api": null,
          "new_api": "cache_miss",
          "old_text": null,
          "new_text": "property_readonly([](py::handle self) -> xla::StatusOr<py::object> {\n        TF_ASSIGN_OR_RETURN(PmapFunction * fun, AsPmapFunction(self));\n        return fun->cache_miss();\n      })",
          "old_line_content": "      });",
          "new_line_content": "      property_readonly([](py::handle self) -> xla::StatusOr<py::object> {",
          "content_same": false
        },
        {
          "line": 1204,
          "old_api": null,
          "new_api": "cache_miss",
          "old_text": null,
          "new_text": "fun->cache_miss()",
          "old_line_content": "      [](const PmapFunction::object& self) {",
          "new_line_content": "        return fun->cache_miss();",
          "content_same": false
        },
        {
          "line": 1206,
          "old_api": null,
          "new_api": "func",
          "old_text": null,
          "new_text": "py::cpp_function(\n      [](const PmapFunction::object& self) {\n        PmapFunction* fn = self.func();\n        py::dict pickle;\n        pickle[\"version\"] = kPmapFunctionPickleVersion;\n        pickle[\"fun\"] = fn->fun();\n        pickle[\"cache_miss\"] = fn->cache_miss();\n        pickle[\"static_argnums\"] = fn->static_argnums();\n        pickle[\"python_shard_arg_fallback\"] = fn->python_shard_arg_fallback();\n        return pickle;\n      },\n      py::is_method(cfun_type))",
          "old_line_content": "        py::dict pickle;",
          "new_line_content": "  cfun.attr(\"__getstate__\") = py::cpp_function(",
          "content_same": false
        },
        {
          "line": 699,
          "old_api": null,
          "new_api": "std::move(sharded_arg.ifrt_array)",
          "old_text": null,
          "new_text": "std::move(sharded_arg.ifrt_array)",
          "old_line_content": "    }",
          "new_line_content": "    num_args_arrays[i] = std::move(sharded_arg.ifrt_array);",
          "content_same": false
        },
        {
          "line": 1212,
          "old_api": null,
          "new_api": "cache_miss",
          "old_text": null,
          "new_text": "fn->cache_miss()",
          "old_line_content": "        return pickle;",
          "new_line_content": "        pickle[\"cache_miss\"] = fn->cache_miss();",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": null,
          "new_api": "std::move(sharded_arg.owning_sda)",
          "old_text": null,
          "new_text": "std::move(sharded_arg.owning_sda)",
          "old_line_content": "#else",
          "new_line_content": "      arguments.keep_alive_objects.push_back(std::move(sharded_arg.owning_sda));",
          "content_same": false
        },
        {
          "line": 1213,
          "old_api": null,
          "new_api": "static_argnums",
          "old_text": null,
          "new_text": "fn->static_argnums()",
          "old_line_content": "      },",
          "new_line_content": "        pickle[\"static_argnums\"] = fn->static_argnums();",
          "content_same": false
        },
        {
          "line": 1218,
          "old_api": null,
          "new_api": "ptr",
          "old_text": null,
          "new_text": "py::cpp_function(\n      [](PmapFunction::object& self, const py::dict& pickle) {\n        int version = py::cast<int>(pickle[\"version\"]);\n        if (version != kPmapFunctionPickleVersion) {\n          throw std::invalid_argument(absl::StrFormat(\n              \"Invalid PmapFunction pickle version, got %d, expected %d. \"\n              \"Pickling/Unpickling jitted functions using different JAX \"\n              \"versions is not supported.\",\n              version, kPmapFunctionPickleVersion));\n        }\n        py::function fun = py::cast<py::function>(pickle[\"fun\"]);\n        py::function cache_miss = py::cast<py::function>(pickle[\"cache_miss\"]);\n        std::vector<int> static_argnums =\n            py::cast<std::vector<int>>(pickle[\"static_argnums\"]);\n        py::function python_shard_arg_fallback =\n            py::cast<py::function>(pickle[\"python_shard_arg_fallback\"]);\n\n        InitializePmapFunction(\n            reinterpret_cast<JaxPmapFunctionObject*>(self.ptr()),\n            std::move(fun), std::move(cache_miss), std::move(static_argnums),\n            std::move(python_shard_arg_fallback));\n      },\n      py::is_method(cfun_type))",
          "old_line_content": "        if (version != kPmapFunctionPickleVersion) {",
          "new_line_content": "  cfun.attr(\"__setstate__\") = py::cpp_function(",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": null,
          "new_api": "py::cast<int>(pickle[\"version\"])",
          "old_text": null,
          "new_text": "py::cast<int>(pickle[\"version\"])",
          "old_line_content": "              \"Invalid PmapFunction pickle version, got %d, expected %d. \"",
          "new_line_content": "        int version = py::cast<int>(pickle[\"version\"]);",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "num_computation_num_args_buffers[computation].resize(num_args)",
          "old_line_content": "    TF_ASSIGN_OR_RETURN(",
          "new_line_content": "    num_computation_num_args_buffers[computation].resize(num_args);",
          "content_same": false
        },
        {
          "line": 1222,
          "old_api": null,
          "new_api": "absl::StrFormat(\n              \"Invalid PmapFunction pickle version, got %d, expected %d. \"\n              \"Pickling/Unpickling jitted functions using different JAX \"\n              \"versions is not supported.\",\n              version, kPmapFunctionPickleVersion)",
          "old_text": null,
          "new_text": "absl::StrFormat(\n              \"Invalid PmapFunction pickle version, got %d, expected %d. \"\n              \"Pickling/Unpickling jitted functions using different JAX \"\n              \"versions is not supported.\",\n              version, kPmapFunctionPickleVersion)",
          "old_line_content": "              \"versions is not supported.\",",
          "new_line_content": "          throw std::invalid_argument(absl::StrFormat(",
          "content_same": false
        },
        {
          "line": 1229,
          "old_api": null,
          "new_api": "py::cast<py::function>(pickle[\"cache_miss\"])",
          "old_text": null,
          "new_text": "py::cast<py::function>(pickle[\"cache_miss\"])",
          "old_line_content": "        py::function python_shard_arg_fallback =",
          "new_line_content": "        py::function cache_miss = py::cast<py::function>(pickle[\"cache_miss\"]);",
          "content_same": false
        },
        {
          "line": 1231,
          "old_api": null,
          "new_api": "py::cast<std::vector<int>>(pickle[\"static_argnums\"])",
          "old_text": null,
          "new_text": "py::cast<std::vector<int>>(pickle[\"static_argnums\"])",
          "old_line_content": "",
          "new_line_content": "            py::cast<std::vector<int>>(pickle[\"static_argnums\"]);",
          "content_same": false
        },
        {
          "line": 1236,
          "old_api": null,
          "new_api": "ptr",
          "old_text": null,
          "new_text": "self.ptr()",
          "old_line_content": "      },",
          "new_line_content": "            reinterpret_cast<JaxPmapFunctionObject*>(self.ptr()),",
          "content_same": false
        },
        {
          "line": 1238,
          "old_api": null,
          "new_api": "std::move(python_shard_arg_fallback)",
          "old_text": null,
          "new_text": "std::move(python_shard_arg_fallback)",
          "old_line_content": "",
          "new_line_content": "            std::move(python_shard_arg_fallback));",
          "content_same": false
        },
        {
          "line": 727,
          "old_api": null,
          "new_api": "std::move(sharded_arg.owning_sda)",
          "old_text": null,
          "new_text": "std::move(sharded_arg.owning_sda)",
          "old_line_content": "#endif",
          "new_line_content": "      arguments.keep_alive_objects.push_back(std::move(sharded_arg.owning_sda));",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": null,
          "new_api": "cache_size",
          "old_text": null,
          "new_text": "property_readonly([](py::handle self) -> xla::StatusOr<py::object> {\n        TF_ASSIGN_OR_RETURN(PmapFunction * fun, AsPmapFunction(self));\n        return py::cast<int>(fun->cache_size());\n      })",
          "old_line_content": "      });",
          "new_line_content": "      property_readonly([](py::handle self) -> xla::StatusOr<py::object> {",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": null,
          "new_api": "AsPmapFunction",
          "old_text": null,
          "new_text": "AsPmapFunction(self)",
          "old_line_content": "",
          "new_line_content": "        TF_ASSIGN_OR_RETURN(PmapFunction * fun, AsPmapFunction(self));",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": null,
          "new_api": "ifrt_executable",
          "old_text": null,
          "new_text": "cache_entry.executable->ifrt_executable()",
          "old_line_content": "                                              cache_entry.executable->options(),",
          "new_line_content": "    auto ifrt_executable = cache_entry.executable->ifrt_executable();",
          "content_same": false
        },
        {
          "line": 1252,
          "old_api": null,
          "new_api": "DebugCacheKeys",
          "old_text": null,
          "new_text": "fun->DebugCacheKeys()",
          "old_line_content": "",
          "new_line_content": "        return fun->DebugCacheKeys();",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": null,
          "new_api": "std::move(result.outputs)",
          "old_text": null,
          "new_text": "std::move(result.outputs)",
          "old_line_content": "  // A vector of [num_devices, num_outputs].",
          "new_line_content": "    output_arrays = std::move(result.outputs);",
          "content_same": false
        },
        {
          "line": 1254,
          "old_api": null,
          "new_api": "py::is_method(cfun_type)",
          "old_text": null,
          "new_text": "py::is_method(cfun_type)",
          "old_line_content": "               [](py::function fun, py::function cache_miss,",
          "new_line_content": "      py::is_method(cfun_type));",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": null,
          "new_api": "def",
          "old_text": null,
          "new_text": "pmap_lib.def(\"pmap\",\n               [](py::function fun, py::function cache_miss,\n                  std::vector<int> static_argnums,\n                  py::function python_shard_arg_fallback) -> py::object {\n                 return MakePmapFunction(std::move(fun), std::move(cache_miss),\n                                         std::move(static_argnums),\n                                         std::move(python_shard_arg_fallback));\n               })",
          "old_line_content": "                  py::function python_shard_arg_fallback) -> py::object {",
          "new_line_content": "  pmap_lib.def(\"pmap\",",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": null,
          "new_api": "std::move(cache_miss)",
          "old_text": null,
          "new_text": "std::move(cache_miss)",
          "old_line_content": "               });",
          "new_line_content": "                 return MakePmapFunction(std::move(fun), std::move(cache_miss),",
          "content_same": false
        },
        {
          "line": 1261,
          "old_api": null,
          "new_api": "std::move(static_argnums)",
          "old_text": null,
          "new_text": "std::move(static_argnums)",
          "old_line_content": "}",
          "new_line_content": "                                         std::move(static_argnums),",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": null,
          "new_api": "Execute",
          "old_text": null,
          "new_text": "pjrt_executable->Execute(\n                                            num_computation_num_args_buffers,\n                                            cache_entry.executable->options())",
          "old_line_content": "  }",
          "new_line_content": "    TF_ASSIGN_OR_RETURN(output_buffers, pjrt_executable->Execute(",
          "content_same": false
        },
        {
          "line": 1262,
          "old_api": null,
          "new_api": "std::move(python_shard_arg_fallback)",
          "old_text": null,
          "new_text": "std::move(python_shard_arg_fallback)",
          "old_line_content": "",
          "new_line_content": "                                         std::move(python_shard_arg_fallback));",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": null,
          "new_api": "options",
          "old_text": null,
          "new_text": "cache_entry.executable->options()",
          "old_line_content": "",
          "new_line_content": "                                            cache_entry.executable->options()));",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": null,
          "new_api": "xla::Traceback::Get()",
          "old_text": null,
          "new_text": "xla::Traceback::Get()",
          "old_line_content": "",
          "new_line_content": "  auto traceback = xla::Traceback::Get();",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": null,
          "new_api": "client",
          "old_text": null,
          "new_text": "cache_entry.executable->client()",
          "old_line_content": "  // [num_devices, num_args] to [num_args, num_devices].",
          "new_line_content": "  std::shared_ptr<xla::PyClient> client = cache_entry.executable->client();",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "output_arrays.size()",
          "old_line_content": "#endif",
          "new_line_content": "  const int num_outputs = output_arrays.size();",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "flat_sharded_device_arrays.reserve(num_outputs)",
          "old_line_content": "",
          "new_line_content": "  flat_sharded_device_arrays.reserve(num_outputs);",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "cache_entry.out_array_shardings.empty()",
          "old_line_content": "      const ResultSpec& result_spec = output_specs[i];",
          "new_line_content": "  if (!cache_entry.out_array_shardings.empty()) {",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": null,
          "new_api": "std::move(output_arrays[i])",
          "old_text": null,
          "new_text": "std::move(output_arrays[i])",
          "old_line_content": "    }",
          "new_line_content": "          std::move(output_arrays[i]), cache_entry.out_committed[i]);",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": null,
          "new_api": "std::move(py_array)",
          "old_text": null,
          "new_text": "std::move(py_array)",
          "old_line_content": "    for (int i = 0; i < num_outputs; ++i) {",
          "new_line_content": "      flat_sharded_device_arrays.push_back(std::move(py_array));",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "outputs.reserve(num_computations)",
          "old_line_content": "      }",
          "new_line_content": "      outputs.reserve(num_computations);",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": null,
          "new_api": "std::move(output_buffers[j][i])",
          "old_text": null,
          "new_text": "std::move(output_buffers[j][i])",
          "old_line_content": "      const ResultSpec& result_spec = output_specs[i];",
          "new_line_content": "        outputs.push_back(std::move(output_buffers[j][i]));",
          "content_same": false
        },
        {
          "line": 802,
          "old_api": null,
          "new_api": "std::move(outputs)",
          "old_text": null,
          "new_text": "std::move(outputs)",
          "old_line_content": "    }",
          "new_line_content": "          std::move(outputs), cache_entry.out_committed[i]);",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": null,
          "new_api": "std::move(py_array)",
          "old_text": null,
          "new_text": "std::move(py_array)",
          "old_line_content": "  } else {",
          "new_line_content": "      flat_sharded_device_arrays.push_back(std::move(py_array));",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "outputs.resize(num_outputs)",
          "old_line_content": "      TF_ASSIGN_OR_RETURN(",
          "new_line_content": "    outputs.resize(num_outputs);",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "outputs[output_id].reserve(num_computations)",
          "old_line_content": "          output_arrays[output_id]->DisassembleIntoSingleDeviceArrays(",
          "new_line_content": "      outputs[output_id].reserve(num_computations);",
          "content_same": false
        },
        {
          "line": 818,
          "old_api": null,
          "new_api": "xla::PyBuffer::Make(\n            client, std::move(single_device_array), traceback)",
          "old_text": null,
          "new_text": "xla::PyBuffer::Make(\n            client, std::move(single_device_array), traceback)",
          "old_line_content": "    }",
          "new_line_content": "        outputs[output_id].push_back(xla::PyBuffer::Make(",
          "content_same": false
        },
        {
          "line": 819,
          "old_api": null,
          "new_api": "std::move(single_device_array)",
          "old_text": null,
          "new_text": "std::move(single_device_array)",
          "old_line_content": "#else",
          "new_line_content": "            client, std::move(single_device_array), traceback));",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "outputs.resize(num_outputs)",
          "old_line_content": "      for (int computation = 0; computation < num_computations; ++computation) {",
          "new_line_content": "    outputs.resize(num_outputs);",
          "content_same": false
        },
        {
          "line": 828,
          "old_api": null,
          "new_api": "xla::PyBuffer::Make(\n            client, std::move(output_buffers[computation][output_id]),\n            traceback)",
          "old_text": null,
          "new_text": "xla::PyBuffer::Make(\n            client, std::move(output_buffers[computation][output_id]),\n            traceback)",
          "old_line_content": "      }",
          "new_line_content": "        outputs[output_id].push_back(xla::PyBuffer::Make(",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": null,
          "new_api": "std::move(output_buffers[computation][output_id])",
          "old_text": null,
          "new_text": "std::move(output_buffers[computation][output_id])",
          "old_line_content": "    }",
          "new_line_content": "            client, std::move(output_buffers[computation][output_id]),",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": null,
          "new_api": "std::move(outputs[i])",
          "old_text": null,
          "new_text": "std::move(outputs[i])",
          "old_line_content": "    }",
          "new_line_content": "          /*device_buffers=*/py::cast(std::move(outputs[i])),",
          "content_same": false
        },
        {
          "line": 850,
          "old_api": null,
          "new_api": "GetPostHook",
          "old_text": null,
          "new_text": "GetPostHook()",
          "old_line_content": "    for (size_t i = 0; i < num_positional_args; ++i) {",
          "new_line_content": "  std::optional<py::object> post_hook = GetPostHook();",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": null,
          "new_api": "PyTuple_GET_ITEM",
          "old_text": null,
          "new_text": "PyTuple_GET_ITEM(kwnames, i)",
          "old_line_content": "    }",
          "new_line_content": "        kwargs[py::handle(PyTuple_GET_ITEM(kwnames, i))] =",
          "content_same": false
        },
        {
          "line": 864,
          "old_api": null,
          "new_api": "*post_hook)(callable, args_tuple, kwargs, out)",
          "old_text": null,
          "new_text": "*post_hook)(callable, args_tuple, kwargs, out)",
          "old_line_content": "  return out;",
          "new_line_content": "    (*post_hook)(callable, args_tuple, kwargs, out);",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": null,
          "new_api": "get_type",
          "old_text": null,
          "new_text": "handle.get_type()",
          "old_line_content": "PmapFunction* PmapFunction::AsPmapFunctionUnchecked(py::handle handle) {",
          "new_line_content": "  return handle.get_type() == JaxPmapFunction_Type;",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": null,
          "new_api": "ptr",
          "old_text": null,
          "new_text": "handle.ptr()",
          "old_line_content": "xla::StatusOr<PmapFunction*> AsPmapFunction(py::handle handle) {",
          "new_line_content": "  return &(reinterpret_cast<JaxPmapFunctionObject*>(handle.ptr())->fun);",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": null,
          "new_api": "xla::InvalidArgument(\"Expected a PmapFunction\")",
          "old_text": null,
          "new_text": "xla::InvalidArgument(\"Expected a PmapFunction\")",
          "old_line_content": "}",
          "new_line_content": "    return xla::InvalidArgument(\"Expected a PmapFunction\");",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": null,
          "new_api": "PmapFunction::AsPmapFunctionUnchecked(handle)",
          "old_text": null,
          "new_text": "PmapFunction::AsPmapFunctionUnchecked(handle)",
          "old_line_content": "namespace {",
          "new_line_content": "  return PmapFunction::AsPmapFunctionUnchecked(handle);",
          "content_same": false
        },
        {
          "line": 902,
          "old_api": null,
          "new_api": "reinterpret_cast<JaxPmapFunctionObject*>(callable)",
          "old_text": null,
          "new_text": "reinterpret_cast<JaxPmapFunctionObject*>(callable)",
          "old_line_content": "  });",
          "new_line_content": "  JaxPmapFunctionObject* o = reinterpret_cast<JaxPmapFunctionObject*>(callable);",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": null,
          "new_api": "Call",
          "old_text": null,
          "new_text": "o->fun.Call(callable, args, nargs, kwnames)",
          "old_line_content": "      return nullptr;",
          "new_line_content": "    xla::StatusOr<py::object> out = o->fun.Call(callable, args, nargs, kwnames);",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": null,
          "new_api": "ok",
          "old_text": null,
          "new_text": "out.ok()",
          "old_line_content": "    }",
          "new_line_content": "    if (!out.ok()) {",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "out.value().release().ptr()",
          "old_line_content": "    return nullptr;",
          "new_line_content": "    return out.value().release().ptr();",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": null,
          "new_api": "what",
          "old_text": null,
          "new_text": "e.what()",
          "old_line_content": "}",
          "new_line_content": "    PyErr_SetString(PyExc_ValueError, e.what());",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": null,
          "new_api": "tp_alloc",
          "old_text": null,
          "new_text": "subtype->tp_alloc(subtype, 0)",
          "old_line_content": "  self->weakrefs = nullptr;",
          "new_line_content": "      reinterpret_cast<JaxPmapFunctionObject*>(subtype->tp_alloc(subtype, 0));",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": null,
          "new_api": "reinterpret_cast<PyObject*>(self)",
          "old_text": null,
          "new_text": "reinterpret_cast<PyObject*>(self)",
          "old_line_content": "void JaxPmapFunction_tp_dealloc(PyObject* self) {",
          "new_line_content": "  return reinterpret_cast<PyObject*>(self);",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": null,
          "new_api": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "old_text": null,
          "new_text": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "old_line_content": "  }",
          "new_line_content": "  JaxPmapFunctionObject* o = reinterpret_cast<JaxPmapFunctionObject*>(self);",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": null,
          "new_api": "o->fun.~PmapFunction()",
          "old_text": null,
          "new_text": "o->fun.~PmapFunction()",
          "old_line_content": "}",
          "new_line_content": "  o->fun.~PmapFunction();",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": null,
          "new_api": "tp_free",
          "old_text": null,
          "new_text": "tp->tp_free(self)",
          "old_line_content": "",
          "new_line_content": "  tp->tp_free(self);",
          "content_same": false
        },
        {
          "line": 945,
          "old_api": null,
          "new_api": "Py_DECREF",
          "old_text": null,
          "new_text": "Py_DECREF(tp)",
          "old_line_content": "int JaxPmapFunction_tp_traverse(PyObject* self, visitproc visit, void* arg) {",
          "new_line_content": "  Py_DECREF(tp);",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": null,
          "new_api": "Py_VISIT",
          "old_text": null,
          "new_text": "Py_VISIT(o->dict)",
          "old_line_content": "  return 0;",
          "new_line_content": "  Py_VISIT(o->dict);",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": null,
          "new_api": "fun",
          "old_text": null,
          "new_text": "o->fun.fun().ptr()",
          "old_line_content": "}",
          "new_line_content": "  Py_VISIT(o->fun.fun().ptr());",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": null,
          "new_api": "cache_miss",
          "old_text": null,
          "new_text": "o->fun.cache_miss().ptr()",
          "old_line_content": "",
          "new_line_content": "  Py_VISIT(o->fun.cache_miss().ptr());",
          "content_same": false
        },
        {
          "line": 961,
          "old_api": null,
          "new_api": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "old_text": null,
          "new_text": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "old_line_content": "  return 0;",
          "new_line_content": "  JaxPmapFunctionObject* o = reinterpret_cast<JaxPmapFunctionObject*>(self);",
          "content_same": false
        },
        {
          "line": 962,
          "old_api": null,
          "new_api": "Py_CLEAR",
          "old_text": null,
          "new_text": "Py_CLEAR(o->dict)",
          "old_line_content": "}",
          "new_line_content": "  Py_CLEAR(o->dict);",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": null,
          "new_api": "ClearPythonReferences",
          "old_text": null,
          "new_text": "o->fun.ClearPythonReferences()",
          "old_line_content": "",
          "new_line_content": "  o->fun.ClearPythonReferences();",
          "content_same": false
        },
        {
          "line": 976,
          "old_api": null,
          "new_api": "PyMethod_New",
          "old_text": null,
          "new_text": "PyMethod_New(self, obj)",
          "old_line_content": "// Support d = instance.__dict__.",
          "new_line_content": "  return PyMethod_New(self, obj);",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": null,
          "new_api": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "old_text": null,
          "new_text": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "old_line_content": "  }",
          "new_line_content": "  JaxPmapFunctionObject* o = reinterpret_cast<JaxPmapFunctionObject*>(self);",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": null,
          "new_api": "PyDict_New",
          "old_text": null,
          "new_text": "PyDict_New()",
          "old_line_content": "  return o->dict;",
          "new_line_content": "    o->dict = PyDict_New();",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": null,
          "new_api": "Py_XINCREF",
          "old_text": null,
          "new_text": "Py_XINCREF(o->dict)",
          "old_line_content": "",
          "new_line_content": "  Py_XINCREF(o->dict);",
          "content_same": false
        },
        {
          "line": 990,
          "old_api": null,
          "new_api": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "old_text": null,
          "new_text": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "old_line_content": "                 \"__dict__ must be set to a dictionary, not a '%s'\",",
          "new_line_content": "  JaxPmapFunctionObject* o = reinterpret_cast<JaxPmapFunctionObject*>(self);",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": null,
          "new_api": "PyErr_Format",
          "old_text": null,
          "new_text": "PyErr_Format(PyExc_TypeError,\n                 \"__dict__ must be set to a dictionary, not a '%s'\",\n                 Py_TYPE(new_dict)->tp_name)",
          "old_line_content": "    return -1;",
          "new_line_content": "    PyErr_Format(PyExc_TypeError,",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": null,
          "new_api": "Py_INCREF",
          "old_text": null,
          "new_text": "Py_INCREF(new_dict)",
          "old_line_content": "  return 0;",
          "new_line_content": "  Py_INCREF(new_dict);",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": null,
          "new_api": "Py_CLEAR",
          "old_text": null,
          "new_text": "Py_CLEAR(o->dict)",
          "old_line_content": "}",
          "new_line_content": "  Py_CLEAR(o->dict);",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": null,
          "new_api": "const_cast<char*>(\"__dict__\")",
          "old_text": null,
          "new_text": "const_cast<char*>(\"__dict__\")",
          "old_line_content": "",
          "new_line_content": "    {const_cast<char*>(\"__dict__\"), JaxPmapFunction_get_dict,",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": null,
          "new_api": "std::move(cache_miss)",
          "old_text": null,
          "new_text": "std::move(cache_miss)",
          "old_line_content": "}",
          "new_line_content": "  new (&cfun->fun) PmapFunction(std::move(fun), std::move(cache_miss),",
          "content_same": false
        },
        {
          "line": 1015,
          "old_api": null,
          "new_api": "std::move(static_argnums)",
          "old_text": null,
          "new_text": "std::move(static_argnums)",
          "old_line_content": "",
          "new_line_content": "                                std::move(static_argnums),",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": null,
          "new_api": "std::move(python_shard_arg_fallback)",
          "old_text": null,
          "new_text": "std::move(python_shard_arg_fallback)",
          "old_line_content": "}  // extern \"C\"",
          "new_line_content": "                                std::move(python_shard_arg_fallback));",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1026,
          "old_api": "std::move(static_argnums)",
          "new_api": null,
          "old_text": "std::move(static_argnums)",
          "new_text": null,
          "old_line_content": "                         std::move(static_argnums),",
          "new_line_content": "  JaxPmapFunctionObject* buf =",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": "def_submodule",
          "new_api": null,
          "old_text": "m.def_submodule(\"pmap_lib\", \"Jax C++ pmap library\")",
          "new_text": null,
          "old_line_content": "  py::module pmap_lib = m.def_submodule(\"pmap_lib\", \"Jax C++ pmap library\");",
          "new_line_content": "}  // namespace",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": "py::make_tuple()",
          "new_api": null,
          "old_text": "py::make_tuple()",
          "new_text": null,
          "old_line_content": "      .def(py::pickle([](const NoSharding& self) { return py::make_tuple(); },",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1048,
          "old_api": "py::isinstance<NoSharding>(obj)",
          "new_api": null,
          "old_text": "py::isinstance<NoSharding>(obj)",
          "new_text": null,
          "old_line_content": "             return py::isinstance<NoSharding>(obj);",
          "new_line_content": "           [](const NoSharding& chuncked) { return \"NoSharding()\"; })",
          "content_same": false
        },
        {
          "line": 1052,
          "old_api": "py::int_(hash)",
          "new_api": null,
          "old_text": "py::int_(hash)",
          "new_text": null,
          "old_line_content": "        return py::int_(hash);",
          "new_line_content": "           })",
          "content_same": false
        },
        {
          "line": 1056,
          "old_api": "py::init<std::vector<int>>()",
          "new_api": null,
          "old_text": "py::init<std::vector<int>>()",
          "new_text": null,
          "old_line_content": "  chunked.def(py::init<std::vector<int>>())",
          "new_line_content": "      });",
          "content_same": false
        },
        {
          "line": 1057,
          "old_api": "py::pickle(\n          [](const Chunked& self) { return py::make_tuple(self.chunks); },\n          [](py::tuple t) { return Chunked{t[0].cast<std::vector<int>>()}; })",
          "new_api": null,
          "old_text": "py::pickle(\n          [](const Chunked& self) { return py::make_tuple(self.chunks); },\n          [](py::tuple t) { return Chunked{t[0].cast<std::vector<int>>()}; })",
          "new_text": null,
          "old_line_content": "      .def(py::pickle(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": "py::make_tuple(self.chunks)",
          "new_api": null,
          "old_text": "py::make_tuple(self.chunks)",
          "new_text": null,
          "old_line_content": "          [](const Chunked& self) { return py::make_tuple(self.chunks); },",
          "new_line_content": "  py::class_<Chunked> chunked(pmap_lib, \"Chunked\");",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": "absl::StrCat(\"Chunked(\",\n                                 absl::StrJoin(chuncked.chunks, \",\"), \")\")",
          "new_api": null,
          "old_text": "absl::StrCat(\"Chunked(\",\n                                 absl::StrJoin(chuncked.chunks, \",\"), \")\")",
          "new_text": null,
          "old_line_content": "             return absl::StrCat(\"Chunked(\",",
          "new_line_content": "      .def_readonly(\"chunks\", &Chunked::chunks)",
          "content_same": false
        },
        {
          "line": 1064,
          "old_api": "absl::StrJoin(chuncked.chunks, \",\")",
          "new_api": null,
          "old_text": "absl::StrJoin(chuncked.chunks, \",\")",
          "new_text": null,
          "old_line_content": "                                 absl::StrJoin(chuncked.chunks, \",\"), \")\");",
          "new_line_content": "      .def(\"__repr__\",",
          "content_same": false
        },
        {
          "line": 1074,
          "old_api": "py::init<int>()",
          "new_api": null,
          "old_text": "py::init<int>()",
          "new_text": null,
          "old_line_content": "  unstacked.def(py::init<int>())",
          "new_line_content": "      });",
          "content_same": false
        },
        {
          "line": 1075,
          "old_api": "py::pickle(\n          [](const Unstacked& self) { return py::make_tuple(self.size); },\n          [](py::tuple t) { return Unstacked{t[0].cast<int>()}; })",
          "new_api": null,
          "old_text": "py::pickle(\n          [](const Unstacked& self) { return py::make_tuple(self.size); },\n          [](py::tuple t) { return Unstacked{t[0].cast<int>()}; })",
          "new_text": null,
          "old_line_content": "      .def(py::pickle(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1076,
          "old_api": "py::make_tuple(self.size)",
          "new_api": null,
          "old_text": "py::make_tuple(self.size)",
          "new_text": null,
          "old_line_content": "          [](const Unstacked& self) { return py::make_tuple(self.size); },",
          "new_line_content": "  py::class_<Unstacked> unstacked(pmap_lib, \"Unstacked\");",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": "absl::StrCat(\"Unstacked(\", x.size, \")\")",
          "new_api": null,
          "old_text": "absl::StrCat(\"Unstacked(\", x.size, \")\")",
          "new_text": null,
          "old_line_content": "             return absl::StrCat(\"Unstacked(\", x.size, \")\");",
          "new_line_content": "      .def_readonly(\"size\", &Unstacked::size)",
          "content_same": false
        },
        {
          "line": 1091,
          "old_api": "py::init<int>()",
          "new_api": null,
          "old_text": "py::init<int>()",
          "new_text": null,
          "old_line_content": "  sharded_axis.def(py::init<int>())",
          "new_line_content": "      });",
          "content_same": false
        },
        {
          "line": 1092,
          "old_api": "py::pickle(\n          [](const ShardedAxis& self) { return py::make_tuple(self.axis); },\n          [](py::tuple t) { return ShardedAxis{t[0].cast<int>()}; })",
          "new_api": null,
          "old_text": "py::pickle(\n          [](const ShardedAxis& self) { return py::make_tuple(self.axis); },\n          [](py::tuple t) { return ShardedAxis{t[0].cast<int>()}; })",
          "new_text": null,
          "old_line_content": "      .def(py::pickle(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": "py::make_tuple(self.axis)",
          "new_api": null,
          "old_text": "py::make_tuple(self.axis)",
          "new_text": null,
          "old_line_content": "          [](const ShardedAxis& self) { return py::make_tuple(self.axis); },",
          "new_line_content": "  py::class_<ShardedAxis> sharded_axis(pmap_lib, \"ShardedAxis\");",
          "content_same": false
        },
        {
          "line": 1098,
          "old_api": "absl::StrCat(\"ShardedAxis(axis=\", x.axis, \")\")",
          "new_api": null,
          "old_text": "absl::StrCat(\"ShardedAxis(axis=\", x.axis, \")\")",
          "new_text": null,
          "old_line_content": "             return absl::StrCat(\"ShardedAxis(axis=\", x.axis, \")\");",
          "new_line_content": "      .def_readonly(\"axis\", &ShardedAxis::axis)",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": "py::init<int>()",
          "new_api": null,
          "old_text": "py::init<int>()",
          "new_text": null,
          "old_line_content": "  replicated.def(py::init<int>())",
          "new_line_content": "      });",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": "py::pickle(\n          [](const Replicated& self) { return py::make_tuple(self.replicas); },\n          [](py::tuple t) { return Replicated{t[0].cast<int>()}; })",
          "new_api": null,
          "old_text": "py::pickle(\n          [](const Replicated& self) { return py::make_tuple(self.replicas); },\n          [](py::tuple t) { return Replicated{t[0].cast<int>()}; })",
          "new_text": null,
          "old_line_content": "      .def(py::pickle(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1107,
          "old_api": "py::make_tuple(self.replicas)",
          "new_api": null,
          "old_text": "py::make_tuple(self.replicas)",
          "new_text": null,
          "old_line_content": "          [](const Replicated& self) { return py::make_tuple(self.replicas); },",
          "new_line_content": "  py::class_<Replicated> replicated(pmap_lib, \"Replicated\");",
          "content_same": false
        },
        {
          "line": 1112,
          "old_api": "absl::StrCat(\"Replicated(replicas=\", x.replicas, \")\")",
          "new_api": null,
          "old_text": "absl::StrCat(\"Replicated(replicas=\", x.replicas, \")\")",
          "new_text": null,
          "old_line_content": "             return absl::StrCat(\"Replicated(replicas=\", x.replicas, \")\");",
          "new_line_content": "      .def_readonly(\"replicas\", &Replicated::replicas)",
          "content_same": false
        },
        {
          "line": 1119,
          "old_api": "def",
          "new_api": null,
          "old_text": "sharding_spec\n      .def(py::init<py::iterable, py::iterable>(), py::arg(\"sharding\"),\n           py::arg(\"mesh_mapping\"))\n      .def(py::pickle(\n          [](const ShardingSpec& self) {\n            auto sharding =\n                xla::SpanToTuple(absl::MakeConstSpan(self.GetSharding()));\n            auto mesh_mapping =\n                xla::SpanToTuple(absl::MakeConstSpan(self.GetMeshMapping()));\n            return py::make_tuple(sharding, mesh_mapping);\n          },\n          [](py::tuple t) {\n            return ShardingSpec{t[0].cast<std::vector<AvalDimSharding>>(),\n                                t[1].cast<std::vector<MeshDimAssignment>>()};\n          }))\n      .def_property_readonly(\n          \"sharding\",\n          [](const ShardingSpec& self) {\n            return xla::SpanToTuple(absl::MakeConstSpan(self.GetSharding()));\n          })\n      .def_property_readonly(\n          \"mesh_mapping\",\n          [](const ShardingSpec& self) {\n            return xla::SpanToTuple(absl::MakeConstSpan(self.GetMeshMapping()));\n          })\n      .def(\"__eq__\", [](const ShardingSpec& self,\n                        const ShardingSpec& other) { return self == other; })\n      .def(\"__hash__\", [](const ShardingSpec& self) {\n        const size_t hash = absl::HashOf(self);\n        return py::int_(hash);\n      })",
          "new_text": null,
          "old_line_content": "  sharding_spec",
          "new_line_content": "      });",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": "py::arg(\"sharding\")",
          "new_api": null,
          "old_text": "py::arg(\"sharding\")",
          "new_text": null,
          "old_line_content": "      .def(py::init<py::iterable, py::iterable>(), py::arg(\"sharding\"),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1121,
          "old_api": "py::arg(\"mesh_mapping\")",
          "new_api": null,
          "old_text": "py::arg(\"mesh_mapping\")",
          "new_text": null,
          "old_line_content": "           py::arg(\"mesh_mapping\"))",
          "new_line_content": "  py::class_<ShardingSpec> sharding_spec(pmap_lib, \"ShardingSpec\");",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": "GetMeshMapping",
          "new_api": null,
          "old_text": "self.GetMeshMapping()",
          "new_text": null,
          "old_line_content": "                xla::SpanToTuple(absl::MakeConstSpan(self.GetMeshMapping()));",
          "new_line_content": "            auto sharding =",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": "t[1].cast<std::vector<MeshDimAssignment>>()",
          "new_api": null,
          "old_text": "t[1].cast<std::vector<MeshDimAssignment>>()",
          "new_text": null,
          "old_line_content": "                                t[1].cast<std::vector<MeshDimAssignment>>()};",
          "new_line_content": "          },",
          "content_same": false
        },
        {
          "line": 1137,
          "old_api": "GetSharding",
          "new_api": null,
          "old_text": "self.GetSharding()",
          "new_text": null,
          "old_line_content": "            return xla::SpanToTuple(absl::MakeConstSpan(self.GetSharding()));",
          "new_line_content": "      .def_property_readonly(",
          "content_same": false
        },
        {
          "line": 1142,
          "old_api": "GetMeshMapping",
          "new_api": null,
          "old_text": "self.GetMeshMapping()",
          "new_text": null,
          "old_line_content": "            return xla::SpanToTuple(absl::MakeConstSpan(self.GetMeshMapping()));",
          "new_line_content": "      .def_property_readonly(",
          "content_same": false
        },
        {
          "line": 1147,
          "old_api": "absl::HashOf(self)",
          "new_api": null,
          "old_text": "absl::HashOf(self)",
          "new_text": null,
          "old_line_content": "        const size_t hash = absl::HashOf(self);",
          "new_line_content": "      .def(\"__eq__\", [](const ShardingSpec& self,",
          "content_same": false
        },
        {
          "line": 1148,
          "old_api": "py::int_(hash)",
          "new_api": null,
          "old_text": "py::int_(hash)",
          "new_text": null,
          "old_line_content": "        return py::int_(hash);",
          "new_line_content": "                        const ShardingSpec& other) { return self == other; })",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": "HasBeenNotified",
          "new_api": null,
          "old_text": "cache_entry.compilation_complete.HasBeenNotified()",
          "new_text": null,
          "old_line_content": "  if (!cache_entry.compilation_complete.HasBeenNotified()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1157,
          "old_api": "py::str(\"PmapFunction\")",
          "new_api": null,
          "old_text": "py::str(\"PmapFunction\")",
          "new_text": null,
          "old_line_content": "    py::str name = py::str(\"PmapFunction\");",
          "new_line_content": "  // additional methods dynamically.",
          "content_same": false
        },
        {
          "line": 1158,
          "old_api": "py::str(\"PmapFunction\")",
          "new_api": null,
          "old_text": "py::str(\"PmapFunction\")",
          "new_text": null,
          "old_line_content": "    py::str qualname = py::str(\"PmapFunction\");",
          "new_line_content": "  py::object cfun;",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": "tp_alloc",
          "new_api": null,
          "old_text": "reinterpret_cast<PyHeapTypeObject*>(\n        PyType_Type.tp_alloc(&PyType_Type, 0))",
          "new_text": null,
          "old_line_content": "    PyHeapTypeObject* heap_type = reinterpret_cast<PyHeapTypeObject*>(",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": "DebugString",
          "new_api": null,
          "old_text": "arguments.signature.DebugString()",
          "new_text": null,
          "old_line_content": "      VLOG(2) << \"Cache miss for \" << arguments.signature.DebugString();",
          "new_line_content": "    if (inserted) {",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": "cache_miss",
          "new_api": null,
          "old_text": "cache_miss()",
          "new_text": null,
          "old_line_content": "        out_and_fastpath_data = cache_miss();",
          "new_line_content": "      try {",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": "ptr",
          "new_api": null,
          "old_text": "out_and_fastpath_data.ptr()",
          "new_text": null,
          "old_line_content": "        if (!out_and_fastpath_data.ptr()) {",
          "new_line_content": "        // Calls Python and may release the GIL. May also throw if",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": "py::error_already_set()",
          "new_api": null,
          "old_text": "py::error_already_set()",
          "new_text": null,
          "old_line_content": "          throw py::error_already_set();",
          "new_line_content": "        // compilation/tracing fails.",
          "content_same": false
        },
        {
          "line": 1164,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(heap_type)",
          "new_text": null,
          "old_line_content": "    CHECK(heap_type) << \"Unable to create heap type object\";",
          "new_line_content": "    // Caution: we must not call any functions that might invoke the GC until",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": "release",
          "new_api": null,
          "old_text": "name.release().ptr()",
          "new_text": null,
          "old_line_content": "    heap_type->ht_name = name.release().ptr();",
          "new_line_content": "    // PyType_Ready() is called. Otherwise the GC might see a half-constructed",
          "content_same": false
        },
        {
          "line": 1166,
          "old_api": "release",
          "new_api": null,
          "old_text": "qualname.release().ptr()",
          "new_text": null,
          "old_line_content": "    heap_type->ht_qualname = qualname.release().ptr();",
          "new_line_content": "    // type object.",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": "offsetof",
          "new_api": null,
          "old_text": "offsetof(JaxPmapFunctionObject, dict)",
          "new_text": null,
          "old_line_content": "    type->tp_dictoffset = offsetof(JaxPmapFunctionObject, dict);",
          "new_line_content": "                     Py_TPFLAGS_HAVE_GC | JAX_TPFLAGS_HAVE_VECTORCALL;",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": "py::object(out_tuple[0])",
          "new_api": null,
          "old_text": "py::object(out_tuple[0])",
          "new_text": null,
          "old_line_content": "      return py::object(out_tuple[0]);",
          "new_line_content": "      // We have already computed the result in the miss path so we can return",
          "content_same": false
        },
        {
          "line": 1181,
          "old_api": "offsetof",
          "new_api": null,
          "old_text": "offsetof(JaxPmapFunctionObject, vectorcall)",
          "new_text": null,
          "old_line_content": "    type->tp_vectorcall_offset = offsetof(JaxPmapFunctionObject, vectorcall);",
          "new_line_content": "    type->tp_getset = JaxPmapFunction_tp_getset;",
          "content_same": false
        },
        {
          "line": 1182,
          "old_api": "PyType_Ready",
          "new_api": null,
          "old_text": "PyType_Ready(type)",
          "new_text": null,
          "old_line_content": "    CHECK_EQ(PyType_Ready(type), 0);",
          "new_line_content": "    type->tp_descr_get = JaxPmapFunction_tp_descr_get;",
          "content_same": false
        },
        {
          "line": 1183,
          "old_api": "reinterpret_cast<PyObject*>(type)",
          "new_api": null,
          "old_text": "reinterpret_cast<PyObject*>(type)",
          "new_text": null,
          "old_line_content": "    JaxPmapFunction_Type = reinterpret_cast<PyObject*>(type);",
          "new_line_content": "    type->tp_call = PyVectorcall_Call;",
          "content_same": false
        },
        {
          "line": 673,
          "old_api": "WaitForNotification",
          "new_api": null,
          "old_text": "cache_entry.compilation_complete.WaitForNotification()",
          "new_text": null,
          "old_line_content": "      cache_entry.compilation_complete.WaitForNotification();",
          "new_line_content": "      // Release the GIL while we wait, making sure the compile thread can",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": "fallback_to_cache_miss",
          "new_api": null,
          "old_text": "fallback_to_cache_miss()",
          "new_text": null,
          "old_line_content": "    return fallback_to_cache_miss();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": "attr",
          "new_api": null,
          "old_text": "cfun.attr(\"__signature__\")",
          "new_text": null,
          "old_line_content": "  cfun.attr(\"__signature__\") =",
          "new_line_content": "  // Add PmapFunction to the xla_extension module so it can be pickled.",
          "content_same": false
        },
        {
          "line": 1194,
          "old_api": "AsPmapFunction",
          "new_api": null,
          "old_text": "AsPmapFunction(self)",
          "new_text": null,
          "old_line_content": "        TF_ASSIGN_OR_RETURN(PmapFunction * fun, AsPmapFunction(self));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": "size",
          "new_api": null,
          "old_text": "cache_entry.executable->AddressableDevices().size()",
          "new_text": null,
          "old_line_content": "      cache_entry.executable->AddressableDevices().size();",
          "new_line_content": "  // 1. Parse arguments.",
          "content_same": false
        },
        {
          "line": 685,
          "old_api": "size",
          "new_api": null,
          "old_text": "arguments.flat_dynamic_args.size()",
          "new_text": null,
          "old_line_content": "  const int num_args = arguments.flat_dynamic_args.size();",
          "new_line_content": "  const int num_computations =",
          "content_same": false
        },
        {
          "line": 1199,
          "old_api": "cache_miss",
          "new_api": null,
          "old_text": "property_readonly([](py::handle self) -> xla::StatusOr<py::object> {\n        TF_ASSIGN_OR_RETURN(PmapFunction * fun, AsPmapFunction(self));\n        return fun->cache_miss();\n      })",
          "new_text": null,
          "old_line_content": "      property_readonly([](py::handle self) -> xla::StatusOr<py::object> {",
          "new_line_content": "      });",
          "content_same": false
        },
        {
          "line": 1200,
          "old_api": "AsPmapFunction",
          "new_api": null,
          "old_text": "AsPmapFunction(self)",
          "new_text": null,
          "old_line_content": "        TF_ASSIGN_OR_RETURN(PmapFunction * fun, AsPmapFunction(self));",
          "new_line_content": "  // Required by `post_hook`.",
          "content_same": false
        },
        {
          "line": 1205,
          "old_api": "func",
          "new_api": null,
          "old_text": "self.func()",
          "new_text": null,
          "old_line_content": "        PmapFunction* fn = self.func();",
          "new_line_content": "      });",
          "content_same": false
        },
        {
          "line": 696,
          "old_api": "std::move(sharded_arg.ifrt_array)",
          "new_api": null,
          "old_text": "std::move(sharded_arg.ifrt_array)",
          "new_text": null,
          "old_line_content": "    num_args_arrays[i] = std::move(sharded_arg.ifrt_array);",
          "new_line_content": "        ShardArg(arguments.flat_dynamic_args[i], input_devices, input_specs[i],",
          "content_same": false
        },
        {
          "line": 1209,
          "old_api": "cache_miss",
          "new_api": null,
          "old_text": "fn->cache_miss()",
          "new_text": null,
          "old_line_content": "        pickle[\"cache_miss\"] = fn->cache_miss();",
          "new_line_content": "        py::dict pickle;",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": "std::move(sharded_arg.owning_sda)",
          "new_api": null,
          "old_text": "std::move(sharded_arg.owning_sda)",
          "new_text": null,
          "old_line_content": "      arguments.keep_alive_objects.push_back(std::move(sharded_arg.owning_sda));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1210,
          "old_api": "static_argnums",
          "new_api": null,
          "old_text": "fn->static_argnums()",
          "new_text": null,
          "old_line_content": "        pickle[\"static_argnums\"] = fn->static_argnums();",
          "new_line_content": "        pickle[\"version\"] = kPmapFunctionPickleVersion;",
          "content_same": false
        },
        {
          "line": 1215,
          "old_api": "ptr",
          "new_api": null,
          "old_text": "py::cpp_function(\n      [](PmapFunction::object& self, const py::dict& pickle) {\n        int version = py::cast<int>(pickle[\"version\"]);\n        if (version != kPmapFunctionPickleVersion) {\n          throw std::invalid_argument(absl::StrFormat(\n              \"Invalid PmapFunction pickle version, got %d, expected %d. \"\n              \"Pickling/Unpickling jitted functions using different JAX \"\n              \"versions is not supported.\",\n              version, kPmapFunctionPickleVersion));\n        }\n        py::function fun = py::cast<py::function>(pickle[\"fun\"]);\n        py::function cache_miss = py::cast<py::function>(pickle[\"cache_miss\"]);\n        std::vector<int> static_argnums =\n            py::cast<std::vector<int>>(pickle[\"static_argnums\"]);\n        py::function python_shard_arg_fallback =\n            py::cast<py::function>(pickle[\"python_shard_arg_fallback\"]);\n\n        InitializePmapFunction(\n            reinterpret_cast<JaxPmapFunctionObject*>(self.ptr()),\n            std::move(fun), std::move(cache_miss), std::move(static_argnums),\n            std::move(python_shard_arg_fallback));\n      },\n      py::is_method(cfun_type))",
          "new_text": null,
          "old_line_content": "  cfun.attr(\"__setstate__\") = py::cpp_function(",
          "new_line_content": "        return pickle;",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": "resize",
          "new_api": null,
          "old_text": "num_computation_num_args_buffers[computation].resize(num_args)",
          "new_text": null,
          "old_line_content": "    num_computation_num_args_buffers[computation].resize(num_args);",
          "new_line_content": "  std::vector<std::vector<xla::PjRtBuffer*>> num_computation_num_args_buffers(",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": "absl::StrFormat(\n              \"Invalid PmapFunction pickle version, got %d, expected %d. \"\n              \"Pickling/Unpickling jitted functions using different JAX \"\n              \"versions is not supported.\",\n              version, kPmapFunctionPickleVersion)",
          "new_api": null,
          "old_text": "absl::StrFormat(\n              \"Invalid PmapFunction pickle version, got %d, expected %d. \"\n              \"Pickling/Unpickling jitted functions using different JAX \"\n              \"versions is not supported.\",\n              version, kPmapFunctionPickleVersion)",
          "new_text": null,
          "old_line_content": "          throw std::invalid_argument(absl::StrFormat(",
          "new_line_content": "      [](PmapFunction::object& self, const py::dict& pickle) {",
          "content_same": false
        },
        {
          "line": 1225,
          "old_api": "py::cast<py::function>(pickle[\"fun\"])",
          "new_api": null,
          "old_text": "py::cast<py::function>(pickle[\"fun\"])",
          "new_text": null,
          "old_line_content": "        py::function fun = py::cast<py::function>(pickle[\"fun\"]);",
          "new_line_content": "              \"versions is not supported.\",",
          "content_same": false
        },
        {
          "line": 1226,
          "old_api": "py::cast<py::function>(pickle[\"cache_miss\"])",
          "new_api": null,
          "old_text": "py::cast<py::function>(pickle[\"cache_miss\"])",
          "new_text": null,
          "old_line_content": "        py::function cache_miss = py::cast<py::function>(pickle[\"cache_miss\"]);",
          "new_line_content": "              version, kPmapFunctionPickleVersion));",
          "content_same": false
        },
        {
          "line": 1230,
          "old_api": "py::cast<py::function>(pickle[\"python_shard_arg_fallback\"])",
          "new_api": null,
          "old_text": "py::cast<py::function>(pickle[\"python_shard_arg_fallback\"])",
          "new_text": null,
          "old_line_content": "            py::cast<py::function>(pickle[\"python_shard_arg_fallback\"]);",
          "new_line_content": "        std::vector<int> static_argnums =",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": "ptr",
          "new_api": null,
          "old_text": "InitializePmapFunction(\n            reinterpret_cast<JaxPmapFunctionObject*>(self.ptr()),\n            std::move(fun), std::move(cache_miss), std::move(static_argnums),\n            std::move(python_shard_arg_fallback))",
          "new_text": null,
          "old_line_content": "        InitializePmapFunction(",
          "new_line_content": "        py::function python_shard_arg_fallback =",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": "std::move(owned_buffer)",
          "new_api": null,
          "old_text": "std::move(owned_buffer)",
          "new_text": null,
          "old_line_content": "      arguments.keep_alive.push_back(std::move(owned_buffer));",
          "new_line_content": "          per_device_buffers[computation];",
          "content_same": false
        },
        {
          "line": 1234,
          "old_api": "std::move(static_argnums)",
          "new_api": null,
          "old_text": "std::move(static_argnums)",
          "new_text": null,
          "old_line_content": "            std::move(fun), std::move(cache_miss), std::move(static_argnums),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1241,
          "old_api": "cache_size",
          "new_api": null,
          "old_text": "property_readonly([](py::handle self) -> xla::StatusOr<py::object> {\n        TF_ASSIGN_OR_RETURN(PmapFunction * fun, AsPmapFunction(self));\n        return py::cast<int>(fun->cache_size());\n      })",
          "new_text": null,
          "old_line_content": "      property_readonly([](py::handle self) -> xla::StatusOr<py::object> {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1242,
          "old_api": "AsPmapFunction",
          "new_api": null,
          "old_text": "AsPmapFunction(self)",
          "new_text": null,
          "old_line_content": "        TF_ASSIGN_OR_RETURN(PmapFunction * fun, AsPmapFunction(self));",
          "new_line_content": "  // This is only for testing/debugging purposes.",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": "ifrt_executable",
          "new_api": null,
          "old_text": "cache_entry.executable->ifrt_executable()",
          "new_text": null,
          "old_line_content": "    auto ifrt_executable = cache_entry.executable->ifrt_executable();",
          "new_line_content": "  std::vector<tsl::RCReference<xla::ifrt::Array>> output_arrays;",
          "content_same": false
        },
        {
          "line": 1248,
          "old_api": "AsPmapFunction",
          "new_api": null,
          "old_text": "AsPmapFunction(self)",
          "new_text": null,
          "old_line_content": "        TF_ASSIGN_OR_RETURN(PmapFunction * fun, AsPmapFunction(self));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": "std::move(result.outputs)",
          "new_api": null,
          "old_text": "std::move(result.outputs)",
          "new_text": null,
          "old_line_content": "    output_arrays = std::move(result.outputs);",
          "new_line_content": "        auto result, ifrt_executable->Execute(absl::MakeSpan(num_args_arrays),",
          "content_same": false
        },
        {
          "line": 1253,
          "old_api": "def",
          "new_api": null,
          "old_text": "pmap_lib.def(\"pmap\",\n               [](py::function fun, py::function cache_miss,\n                  std::vector<int> static_argnums,\n                  py::function python_shard_arg_fallback) -> py::object {\n                 return MakePmapFunction(std::move(fun), std::move(cache_miss),\n                                         std::move(static_argnums),\n                                         std::move(python_shard_arg_fallback));\n               })",
          "new_text": null,
          "old_line_content": "  pmap_lib.def(\"pmap\",",
          "new_line_content": "      },",
          "content_same": false
        },
        {
          "line": 1257,
          "old_api": "std::move(cache_miss)",
          "new_api": null,
          "old_text": "std::move(cache_miss)",
          "new_text": null,
          "old_line_content": "                 return MakePmapFunction(std::move(fun), std::move(cache_miss),",
          "new_line_content": "               [](py::function fun, py::function cache_miss,",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": "pjrt_executable",
          "new_api": null,
          "old_text": "cache_entry.executable->pjrt_executable()",
          "new_text": null,
          "old_line_content": "    auto pjrt_executable = cache_entry.executable->pjrt_executable();",
          "new_line_content": "  std::vector<std::vector<std::unique_ptr<xla::PjRtBuffer>>> output_buffers;",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": "Execute",
          "new_api": null,
          "old_text": "pjrt_executable->Execute(\n                                            num_computation_num_args_buffers,\n                                            cache_entry.executable->options())",
          "new_text": null,
          "old_line_content": "    TF_ASSIGN_OR_RETURN(output_buffers, pjrt_executable->Execute(",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 1258,
          "old_api": "std::move(static_argnums)",
          "new_api": null,
          "old_text": "std::move(static_argnums)",
          "new_text": null,
          "old_line_content": "                                         std::move(static_argnums),",
          "new_line_content": "                  std::vector<int> static_argnums,",
          "content_same": false
        },
        {
          "line": 1259,
          "old_api": "std::move(python_shard_arg_fallback)",
          "new_api": null,
          "old_text": "std::move(python_shard_arg_fallback)",
          "new_text": null,
          "old_line_content": "                                         std::move(python_shard_arg_fallback));",
          "new_line_content": "                  py::function python_shard_arg_fallback) -> py::object {",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": "xla::Traceback::Get()",
          "new_api": null,
          "old_text": "xla::Traceback::Get()",
          "new_text": null,
          "old_line_content": "  auto traceback = xla::Traceback::Get();",
          "new_line_content": "  // Having a C++ `ShardedDeviceArray`, keeping internally the PjRtBuffer",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": "client",
          "new_api": null,
          "old_text": "cache_entry.executable->client()",
          "new_text": null,
          "old_line_content": "  std::shared_ptr<xla::PyClient> client = cache_entry.executable->client();",
          "new_line_content": "  // we access them from Python.",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": "size",
          "new_api": null,
          "old_text": "output_arrays.size()",
          "new_text": null,
          "old_line_content": "  const int num_outputs = output_arrays.size();",
          "new_line_content": "  // Convert the PjRtBuffer objects to PyBuffer, and invert the order from",
          "content_same": false
        },
        {
          "line": 766,
          "old_api": "size",
          "new_api": null,
          "old_text": "output_buffers[0].size()",
          "new_text": null,
          "old_line_content": "  const int num_outputs = output_buffers[0].size();",
          "new_line_content": "#ifdef JAX_ENABLE_IFRT",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": "empty",
          "new_api": null,
          "old_text": "cache_entry.out_array_shardings.empty()",
          "new_text": null,
          "old_line_content": "  if (!cache_entry.out_array_shardings.empty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": "std::move(output_arrays[i])",
          "new_api": null,
          "old_text": "std::move(output_arrays[i])",
          "new_text": null,
          "old_line_content": "          std::move(output_arrays[i]), cache_entry.out_committed[i]);",
          "new_line_content": "          result_spec.out_aval, result_spec.weak_type,",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": "std::move(py_array)",
          "new_api": null,
          "old_text": "std::move(py_array)",
          "new_text": null,
          "old_line_content": "      flat_sharded_device_arrays.push_back(std::move(py_array));",
          "new_line_content": "          cache_entry.out_array_shardings[i], client, traceback,",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "outputs.reserve(num_computations)",
          "new_text": null,
          "old_line_content": "      outputs.reserve(num_computations);",
          "new_line_content": "#else",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "std::move(output_buffers[j][i])",
          "new_api": null,
          "old_text": "std::move(output_buffers[j][i])",
          "new_text": null,
          "old_line_content": "        outputs.push_back(std::move(output_buffers[j][i]));",
          "new_line_content": "      std::vector<std::shared_ptr<xla::PjRtBuffer>> outputs;",
          "content_same": false
        },
        {
          "line": 799,
          "old_api": "std::move(outputs)",
          "new_api": null,
          "old_text": "std::move(outputs)",
          "new_text": null,
          "old_line_content": "          std::move(outputs), cache_entry.out_committed[i]);",
          "new_line_content": "          result_spec.out_aval, result_spec.weak_type,",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": "std::move(py_array)",
          "new_api": null,
          "old_text": "std::move(py_array)",
          "new_text": null,
          "old_line_content": "      flat_sharded_device_arrays.push_back(std::move(py_array));",
          "new_line_content": "          cache_entry.out_array_shardings[i], client, traceback,",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": "resize",
          "new_api": null,
          "old_text": "outputs.resize(num_outputs)",
          "new_text": null,
          "old_line_content": "    outputs.resize(num_outputs);",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "outputs[output_id].reserve(num_computations)",
          "new_text": null,
          "old_line_content": "      outputs[output_id].reserve(num_computations);",
          "new_line_content": "    std::vector<std::vector<xla::PyBuffer::object>> outputs;",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": "xla::PyBuffer::Make(\n            client, std::move(single_device_array), traceback)",
          "new_api": null,
          "old_text": "xla::PyBuffer::Make(\n            client, std::move(single_device_array), traceback)",
          "new_text": null,
          "old_line_content": "        outputs[output_id].push_back(xla::PyBuffer::Make(",
          "new_line_content": "          output_arrays[output_id]->DisassembleIntoSingleDeviceArrays(",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": "std::move(single_device_array)",
          "new_api": null,
          "old_text": "std::move(single_device_array)",
          "new_text": null,
          "old_line_content": "            client, std::move(single_device_array), traceback));",
          "new_line_content": "              xla::ifrt::ArrayCopySemantics::kReuseInput));",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": "resize",
          "new_api": null,
          "old_text": "outputs.resize(num_outputs)",
          "new_text": null,
          "old_line_content": "    outputs.resize(num_outputs);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "outputs[output_id].reserve(num_computations)",
          "new_text": null,
          "old_line_content": "      outputs[output_id].reserve(num_computations);",
          "new_line_content": "    std::vector<std::vector<xla::PyBuffer::object>> outputs;",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": "xla::PyBuffer::Make(\n            client, std::move(output_buffers[computation][output_id]),\n            traceback)",
          "new_api": null,
          "old_text": "xla::PyBuffer::Make(\n            client, std::move(output_buffers[computation][output_id]),\n            traceback)",
          "new_text": null,
          "old_line_content": "        outputs[output_id].push_back(xla::PyBuffer::Make(",
          "new_line_content": "    for (int output_id = 0; output_id < num_outputs; ++output_id) {",
          "content_same": false
        },
        {
          "line": 834,
          "old_api": "ShardedDeviceArray::Make(\n          /*aval=*/result_spec.out_aval,\n          /*sharding_spec=*/result_spec.out_spec,\n          /*device_buffers=*/py::cast(std::move(outputs[i])),\n          /*indices=*/result_spec.out_indices,\n          /*weak_type=*/result_spec.weak_type)",
          "new_api": null,
          "old_text": "ShardedDeviceArray::Make(\n          /*aval=*/result_spec.out_aval,\n          /*sharding_spec=*/result_spec.out_spec,\n          /*device_buffers=*/py::cast(std::move(outputs[i])),\n          /*indices=*/result_spec.out_indices,\n          /*weak_type=*/result_spec.weak_type)",
          "new_text": null,
          "old_line_content": "      flat_sharded_device_arrays.push_back(ShardedDeviceArray::Make(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 844,
          "old_api": "Unflatten",
          "new_api": null,
          "old_text": "cache_entry.out_pytree_def.Unflatten(flat_sharded_device_arrays)",
          "new_text": null,
          "old_line_content": "      cache_entry.out_pytree_def.Unflatten(flat_sharded_device_arrays);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": "PyTuple_GET_ITEM",
          "new_api": null,
          "old_text": "PyTuple_GET_ITEM(kwnames, i)",
          "new_text": null,
          "old_line_content": "        kwargs[py::handle(PyTuple_GET_ITEM(kwnames, i))] =",
          "new_line_content": "    py::dict kwargs;",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": "*post_hook)(callable, args_tuple, kwargs, out)",
          "new_api": null,
          "old_text": "*post_hook)(callable, args_tuple, kwargs, out)",
          "new_text": null,
          "old_line_content": "    (*post_hook)(callable, args_tuple, kwargs, out);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": "get_type",
          "new_api": null,
          "old_text": "handle.get_type()",
          "new_text": null,
          "old_line_content": "  return handle.get_type() == JaxPmapFunction_Type;",
          "new_line_content": "PyObject* JaxPmapFunction_Type = nullptr;",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": "ptr",
          "new_api": null,
          "old_text": "handle.ptr()",
          "new_text": null,
          "old_line_content": "  return &(reinterpret_cast<JaxPmapFunctionObject*>(handle.ptr())->fun);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": "PmapFunction::IsPmapFunction(handle)",
          "new_api": null,
          "old_text": "PmapFunction::IsPmapFunction(handle)",
          "new_text": null,
          "old_line_content": "  if (!PmapFunction::IsPmapFunction(handle)) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": "xla::InvalidArgument(\"Expected a PmapFunction\")",
          "new_api": null,
          "old_text": "xla::InvalidArgument(\"Expected a PmapFunction\")",
          "new_text": null,
          "old_line_content": "    return xla::InvalidArgument(\"Expected a PmapFunction\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": "reinterpret_cast<JaxPmapFunctionObject*>(callable)",
          "new_api": null,
          "old_text": "reinterpret_cast<JaxPmapFunctionObject*>(callable)",
          "new_text": null,
          "old_line_content": "  JaxPmapFunctionObject* o = reinterpret_cast<JaxPmapFunctionObject*>(callable);",
          "new_line_content": "PyObject* JaxPmapFunction_tp_vectorcall(PyObject* callable,",
          "content_same": false
        },
        {
          "line": 901,
          "old_api": "function_name",
          "new_api": null,
          "old_text": "o->fun.function_name()",
          "new_text": null,
          "old_line_content": "    return absl::StrCat(\"JaxPmapFunction(\", o->fun.function_name(), \")\");",
          "new_line_content": "                                        PyObject* kwnames) {",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": "ok",
          "new_api": null,
          "old_text": "out.ok()",
          "new_text": null,
          "old_line_content": "    if (!out.ok()) {",
          "new_line_content": "  });",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": "status",
          "new_api": null,
          "old_text": "out.status().ToString().c_str()",
          "new_text": null,
          "old_line_content": "      PyErr_SetString(PyExc_ValueError, out.status().ToString().c_str());",
          "new_line_content": "  try {",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": "restore",
          "new_api": null,
          "old_text": "e.restore()",
          "new_text": null,
          "old_line_content": "    e.restore();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": "tp_alloc",
          "new_api": null,
          "old_text": "subtype->tp_alloc(subtype, 0)",
          "new_text": null,
          "old_line_content": "      reinterpret_cast<JaxPmapFunctionObject*>(subtype->tp_alloc(subtype, 0));",
          "new_line_content": "PyObject* JaxPmapFunction_tp_new(PyTypeObject* subtype, PyObject* args,",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": "reinterpret_cast<PyObject*>(self)",
          "new_api": null,
          "old_text": "reinterpret_cast<PyObject*>(self)",
          "new_text": null,
          "old_line_content": "  return reinterpret_cast<PyObject*>(self);",
          "new_line_content": "  self->dict = nullptr;",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "Py_TYPE",
          "new_api": null,
          "old_text": "Py_TYPE(self)",
          "new_text": null,
          "old_line_content": "  PyTypeObject* tp = Py_TYPE(self);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "new_api": null,
          "old_text": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "new_text": null,
          "old_line_content": "  JaxPmapFunctionObject* o = reinterpret_cast<JaxPmapFunctionObject*>(self);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": "Py_CLEAR",
          "new_api": null,
          "old_text": "Py_CLEAR(o->dict)",
          "new_text": null,
          "old_line_content": "  Py_CLEAR(o->dict);",
          "new_line_content": "  if (o->weakrefs) {",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": "tp_free",
          "new_api": null,
          "old_text": "tp->tp_free(self)",
          "new_text": null,
          "old_line_content": "  tp->tp_free(self);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "new_api": null,
          "old_text": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "new_text": null,
          "old_line_content": "  JaxPmapFunctionObject* o = reinterpret_cast<JaxPmapFunctionObject*>(self);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": "Py_VISIT",
          "new_api": null,
          "old_text": "Py_VISIT(o->dict)",
          "new_text": null,
          "old_line_content": "  Py_VISIT(o->dict);",
          "new_line_content": "  // https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_traverse",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "cache_miss",
          "new_api": null,
          "old_text": "o->fun.cache_miss().ptr()",
          "new_text": null,
          "old_line_content": "  Py_VISIT(o->fun.cache_miss().ptr());",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "new_api": null,
          "old_text": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "new_text": null,
          "old_line_content": "  JaxPmapFunctionObject* o = reinterpret_cast<JaxPmapFunctionObject*>(self);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": "Py_CLEAR",
          "new_api": null,
          "old_text": "Py_CLEAR(o->dict)",
          "new_text": null,
          "old_line_content": "  Py_CLEAR(o->dict);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": "ClearPythonReferences",
          "new_api": null,
          "old_text": "o->fun.ClearPythonReferences()",
          "new_text": null,
          "old_line_content": "  o->fun.ClearPythonReferences();",
          "new_line_content": "int JaxPmapFunction_tp_clear(PyObject* self) {",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": "Py_INCREF",
          "new_api": null,
          "old_text": "Py_INCREF(self)",
          "new_text": null,
          "old_line_content": "    Py_INCREF(self);",
          "new_line_content": "PyObject* JaxPmapFunction_tp_descr_get(PyObject* self, PyObject* obj,",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "new_api": null,
          "old_text": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "new_text": null,
          "old_line_content": "  JaxPmapFunctionObject* o = reinterpret_cast<JaxPmapFunctionObject*>(self);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": "PyDict_New",
          "new_api": null,
          "old_text": "PyDict_New()",
          "new_text": null,
          "old_line_content": "    o->dict = PyDict_New();",
          "new_line_content": "PyObject* JaxPmapFunction_get_dict(PyObject* self, void*) {",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": "Py_XINCREF",
          "new_api": null,
          "old_text": "Py_XINCREF(o->dict)",
          "new_text": null,
          "old_line_content": "  Py_XINCREF(o->dict);",
          "new_line_content": "  if (!o->dict) {",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "new_api": null,
          "old_text": "reinterpret_cast<JaxPmapFunctionObject*>(self)",
          "new_text": null,
          "old_line_content": "  JaxPmapFunctionObject* o = reinterpret_cast<JaxPmapFunctionObject*>(self);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": "PyDict_Check",
          "new_api": null,
          "old_text": "PyDict_Check(new_dict)",
          "new_text": null,
          "old_line_content": "  if (!PyDict_Check(new_dict)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": "PyErr_Format",
          "new_api": null,
          "old_text": "PyErr_Format(PyExc_TypeError,\n                 \"__dict__ must be set to a dictionary, not a '%s'\",\n                 Py_TYPE(new_dict)->tp_name)",
          "new_text": null,
          "old_line_content": "    PyErr_Format(PyExc_TypeError,",
          "new_line_content": "int JaxPmapFunction_set_dict(PyObject* self, PyObject* new_dict, void*) {",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": "Py_CLEAR",
          "new_api": null,
          "old_text": "Py_CLEAR(o->dict)",
          "new_text": null,
          "old_line_content": "  Py_CLEAR(o->dict);",
          "new_line_content": "    return -1;",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": "const_cast<char*>(\"__dict__\")",
          "new_api": null,
          "old_text": "const_cast<char*>(\"__dict__\")",
          "new_text": null,
          "old_line_content": "    {const_cast<char*>(\"__dict__\"), JaxPmapFunction_get_dict,",
          "new_line_content": "static PyGetSetDef JaxPmapFunction_tp_getset[] = {",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": "std::move(cache_miss)",
          "new_api": null,
          "old_text": "std::move(cache_miss)",
          "new_text": null,
          "old_line_content": "  new (&cfun->fun) PmapFunction(std::move(fun), std::move(cache_miss),",
          "new_line_content": "                            py::function cache_miss,",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": "std::move(static_argnums)",
          "new_api": null,
          "old_text": "std::move(static_argnums)",
          "new_text": null,
          "old_line_content": "                                std::move(static_argnums),",
          "new_line_content": "                            std::vector<int> static_argnums,",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": "std::move(python_shard_arg_fallback)",
          "new_api": null,
          "old_text": "std::move(python_shard_arg_fallback)",
          "new_text": null,
          "old_line_content": "                                std::move(python_shard_arg_fallback));",
          "new_line_content": "                            py::function python_shard_arg_fallback) {",
          "content_same": false
        },
        {
          "line": 1021,
          "old_api": "JaxPmapFunction_tp_new",
          "new_api": null,
          "old_text": "JaxPmapFunction_tp_new(\n      reinterpret_cast<PyTypeObject*>(JaxPmapFunction_Type), nullptr, nullptr)",
          "new_text": null,
          "old_line_content": "  py::object obj = py::reinterpret_steal<py::object>(JaxPmapFunction_tp_new(",
          "new_line_content": "py::object MakePmapFunction(py::function fun, py::function cache_miss,",
          "content_same": false
        },
        {
          "line": 1022,
          "old_api": "reinterpret_cast<PyTypeObject*>(JaxPmapFunction_Type)",
          "new_api": null,
          "old_text": "reinterpret_cast<PyTypeObject*>(JaxPmapFunction_Type)",
          "new_text": null,
          "old_line_content": "      reinterpret_cast<PyTypeObject*>(JaxPmapFunction_Type), nullptr, nullptr));",
          "new_line_content": "                            std::vector<int> static_argnums,",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 59,
      "total_additions": 138,
      "total_deletions": 137,
      "total_api_changes": 334
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 4,
        "api_related_lines": 334,
        "non_api_lines": 1,
        "non_api_line_numbers": [
          640
        ]
      }
    },
    "api_calls_before": 568,
    "api_calls_after": 569,
    "diff_info": {
      "added_lines": 4,
      "removed_lines": 1,
      "total_diff_lines": 17
    }
  }
}