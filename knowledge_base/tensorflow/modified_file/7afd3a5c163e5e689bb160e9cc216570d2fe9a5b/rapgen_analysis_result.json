{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/7afd3a5c163e5e689bb160e9cc216570d2fe9a5b",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/7afd3a5c163e5e689bb160e9cc216570d2fe9a5b/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/7afd3a5c163e5e689bb160e9cc216570d2fe9a5b/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/7afd3a5c163e5e689bb160e9cc216570d2fe9a5b/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 2267,
          "old_api": "VLOG",
          "new_api": "shape",
          "old_text": "VLOG(2)",
          "new_text": "buffer->defining_position().shape()",
          "old_line_content": "  VLOG(2) << \"Total execution time = \" << total_execution_time",
          "new_line_content": "                                        buffer->defining_position().shape()));",
          "content_same": false
        },
        {
          "line": 2300,
          "old_api": "back",
          "new_api": "front",
          "old_text": "CHECK_EQ(cross_program_prefetch_offset->offset,\n             allocations.back()->chunk().offset)",
          "new_text": "allocations.front()",
          "old_line_content": "    CHECK_EQ(cross_program_prefetch_offset->offset,",
          "new_line_content": "    AddAsyncCopy(*allocations.front(), MemorySpace::kAlternate, chunk_candidate,",
          "content_same": false
        },
        {
          "line": 2306,
          "old_api": "memory_space",
          "new_api": "back",
          "old_text": "allocation->memory_space()",
          "new_text": "CHECK_EQ(cross_program_prefetch_offset->offset,\n             allocations.back()->chunk().offset)",
          "old_line_content": "    if (allocation->memory_space() == MemorySpace::kAlternate) {",
          "new_line_content": "    CHECK_EQ(cross_program_prefetch_offset->offset,",
          "content_same": false
        },
        {
          "line": 2310,
          "old_api": "chunk",
          "new_api": "size",
          "old_text": "allocation->chunk()",
          "new_text": "allocations_->size()",
          "old_line_content": "      buffer_interval.size = allocation->chunk().size;",
          "new_line_content": "  const int allocations_initial_size = allocations_->size();",
          "content_same": false
        },
        {
          "line": 2312,
          "old_api": "AddToPendingChunks",
          "new_api": "memory_space",
          "old_text": "AddToPendingChunks(buffer_interval, chunk_candidate)",
          "new_text": "allocation->memory_space()",
          "old_line_content": "      AddToPendingChunks(buffer_interval, chunk_candidate);",
          "new_line_content": "    if (allocation->memory_space() == MemorySpace::kAlternate) {",
          "content_same": false
        },
        {
          "line": 2314,
          "old_api": "std::move(allocation)",
          "new_api": "start_time",
          "old_text": "std::move(allocation)",
          "new_text": "allocation->start_time()",
          "old_line_content": "    allocations_->push_back(std::move(allocation));",
          "new_line_content": "      buffer_interval.start = allocation->start_time();",
          "content_same": false
        },
        {
          "line": 2320,
          "old_api": "size",
          "new_api": "std::move(allocation)",
          "old_text": "allocations_->size()",
          "new_text": "std::move(allocation)",
          "old_line_content": "  for (int i = allocations_initial_size; i < allocations_->size(); ++i) {",
          "new_line_content": "    allocations_->push_back(std::move(allocation));",
          "content_same": false
        },
        {
          "line": 2326,
          "old_api": "get",
          "new_api": "size",
          "old_text": "allocation.get()",
          "new_text": "allocations_->size()",
          "old_line_content": "          static_cast<int64_t>(colocations.size()), allocation.get()));",
          "new_line_content": "  for (int i = allocations_initial_size; i < allocations_->size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2327,
          "old_api": "back",
          "new_api": "at",
          "old_text": "repack_allocation_blocks_.back()",
          "new_text": "allocations_->at(i)",
          "old_line_content": "      RepackAllocationBlock* inserted = &repack_allocation_blocks_.back();",
          "new_line_content": "    const auto& allocation = allocations_->at(i);",
          "content_same": false
        },
        {
          "line": 2329,
          "old_api": "push_back",
          "new_api": "size",
          "old_text": "inserted->colocations.push_back(colocation)",
          "new_text": "MakeRepackAllocationBlock(\n          allocation->start_time(), allocation->end_time(),\n          allocation->chunk().size, allocation->chunk().offset,\n          static_cast<int64_t>(colocations.size()), allocation.get())",
          "old_line_content": "        inserted->colocations.push_back(colocation);",
          "new_line_content": "      repack_allocation_blocks_.push_back(MakeRepackAllocationBlock(",
          "content_same": false
        },
        {
          "line": 2330,
          "old_api": "push_back",
          "new_api": "end_time",
          "old_text": "colocation->colocations.push_back(inserted)",
          "new_text": "allocation->end_time()",
          "old_line_content": "        colocation->colocations.push_back(inserted);",
          "new_line_content": "          allocation->start_time(), allocation->end_time(),",
          "content_same": false
        },
        {
          "line": 2332,
          "old_api": "emplace_back",
          "new_api": "get",
          "old_text": "inserted->colocations.emplace_back(inserted)",
          "new_text": "allocation.get()",
          "old_line_content": "      inserted->colocations.emplace_back(inserted);",
          "new_line_content": "          static_cast<int64_t>(colocations.size()), allocation.get()));",
          "content_same": false
        },
        {
          "line": 2333,
          "old_api": "emplace_back",
          "new_api": "back",
          "old_text": "colocations.emplace_back(inserted)",
          "new_text": "repack_allocation_blocks_.back()",
          "old_line_content": "      colocations.emplace_back(inserted);",
          "new_line_content": "      RepackAllocationBlock* inserted = &repack_allocation_blocks_.back();",
          "content_same": false
        },
        {
          "line": 2350,
          "old_api": "name",
          "new_api": "size",
          "old_text": "instruction->name()",
          "new_text": "instruction_sequence.size()",
          "old_line_content": "              << instruction->name() << \"): \" << reserved_scoped_memory;",
          "new_line_content": "  for (int i = 0; i < instruction_sequence.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2369,
          "old_api": "std::make_unique<MemorySpaceAssignment::Allocation>(\n              HloPosition{instruction_sequence[i], {}}, MemorySpace::kAlternate,\n              chunk_candidate, i, i, /*is_scoped_allocation=*/true)",
          "new_api": "VLOG_IS_ON",
          "old_text": "std::make_unique<MemorySpaceAssignment::Allocation>(\n              HloPosition{instruction_sequence[i], {}}, MemorySpace::kAlternate,\n              chunk_candidate, i, i, /*is_scoped_allocation=*/true)",
          "new_text": "VLOG_IS_ON(3)",
          "old_line_content": "          std::make_unique<MemorySpaceAssignment::Allocation>(",
          "new_line_content": "      if (options_.dump_fn != nullptr || VLOG_IS_ON(3)) {",
          "content_same": false
        },
        {
          "line": 2398,
          "old_api": "find",
          "new_api": "ClearPendingChunks",
          "old_text": "required_assignments_.find(buffer)",
          "new_text": "ClearPendingChunks()",
          "old_line_content": "  auto required_assignment_it = required_assignments_.find(buffer);",
          "new_line_content": "  ClearPendingChunks();",
          "content_same": false
        },
        {
          "line": 2406,
          "old_api": "ToShortString",
          "new_api": "end",
          "old_text": "buffer->ToShortString()",
          "new_text": "required_assignments_.end()",
          "old_line_content": "            << buffer->ToShortString() << \" at time \" << time;",
          "new_line_content": "  if (required_assignment_it != required_assignments_.end()) {",
          "content_same": false
        },
        {
          "line": 2429,
          "old_api": "equals_ignoring_time",
          "new_api": "instruction_schedule",
          "old_text": "CHECK(required_assignment_for_alias == std::nullopt ||\n            required_assignment->equals_ignoring_time(\n                *required_assignment_for_alias))",
          "new_text": "hlo_live_range_.instruction_schedule().at(position.instruction)",
          "old_line_content": "      CHECK(required_assignment_for_alias == std::nullopt ||",
          "new_line_content": "        hlo_live_range_.instruction_schedule().at(position.instruction);",
          "content_same": false
        },
        {
          "line": 2460,
          "old_api": "VLOG",
          "new_api": "RequiredMemoryAssignmentAt",
          "old_text": "VLOG(3)",
          "new_text": "RequiredMemoryAssignmentAt(value, time)",
          "old_line_content": "    VLOG(3) << \"Not adding required assignment because there is one already: \"",
          "new_line_content": "  auto existing_required_assignment = RequiredMemoryAssignmentAt(value, time);",
          "content_same": false
        },
        {
          "line": 2464,
          "old_api": "ToShortString",
          "new_api": "CHECK",
          "old_text": "value->ToShortString()",
          "new_text": "CHECK((!offset && !existing_required_assignment->offset) ||\n          offset == existing_required_assignment->offset)",
          "old_line_content": "    VLOG(3) << \"Adding required assignment: \" << value->ToShortString()",
          "new_line_content": "    CHECK((!offset && !existing_required_assignment->offset) ||",
          "content_same": false
        },
        {
          "line": 2470,
          "old_api": "push_back",
          "new_api": "ToShortString",
          "old_text": "pending_required_assignments_.push_back({value, required_assignment})",
          "new_text": "value->ToShortString()",
          "old_line_content": "      pending_required_assignments_.push_back({value, required_assignment});",
          "new_line_content": "    VLOG(3) << \"Adding required assignment: \" << value->ToShortString()",
          "content_same": false
        },
        {
          "line": 2495,
          "old_api": "at",
          "new_api": "dataflow_analysis",
          "old_text": "instruction_schedule.at(parameter_instruction)",
          "new_text": "alias_analysis_.dataflow_analysis().module()",
          "old_line_content": "        instruction_schedule.at(parameter_instruction);",
          "new_line_content": "  const HloModule& module = alias_analysis_.dataflow_analysis().module();",
          "content_same": false
        },
        {
          "line": 2496,
          "old_api": "has_layout",
          "new_api": "instruction_schedule",
          "old_text": "ShapeUtil::ForEachSubshape(\n        parameter_instruction->shape(),\n        [&](const Shape& subshape, const ShapeIndex& index) {\n          MemorySpace memory_space = MemorySpace::kDefault;\n          if (subshape.has_layout() && subshape.layout().memory_space() ==\n                                           options_.alternate_memory_space) {\n            memory_space = MemorySpace::kAlternate;\n          }\n          for (const HloBuffer* buffer :\n               alias_analysis_.ComputeBuffersAt(parameter_instruction, index)) {\n            for (const HloValue* value : buffer->values()) {\n              VLOG(3) << \"Adding required assignment for parameter value = \"\n                      << value->ToShortString()\n                      << \" time = \" << parameter_instruction_time << \" space = \"\n                      << (memory_space == MemorySpace::kDefault ? \"def\"\n                                                                : \"alt\");\n              AddRequiredAssignment(value, parameter_instruction, memory_space,\n                                    parameter_instruction_time,\n                                    /*offset=*/nullptr,\n                                    /*add_to_pending=*/false);\n            }\n          }\n        })",
          "new_text": "hlo_live_range_.instruction_schedule()",
          "old_line_content": "    ShapeUtil::ForEachSubshape(",
          "new_line_content": "  const auto& instruction_schedule = hlo_live_range_.instruction_schedule();",
          "content_same": false
        },
        {
          "line": 2497,
          "old_api": "shape",
          "new_api": "entry_computation",
          "old_text": "parameter_instruction->shape()",
          "new_text": "module.entry_computation()",
          "old_line_content": "        parameter_instruction->shape(),",
          "new_line_content": "  HloComputation* entry_computation = module.entry_computation();",
          "content_same": false
        },
        {
          "line": 2506,
          "old_api": "values",
          "new_api": "layout",
          "old_text": "buffer->values()",
          "new_text": "subshape.layout().memory_space()",
          "old_line_content": "            for (const HloValue* value : buffer->values()) {",
          "new_line_content": "          if (subshape.has_layout() && subshape.layout().memory_space() ==",
          "content_same": false
        },
        {
          "line": 2512,
          "old_api": "AddRequiredAssignment",
          "new_api": "values",
          "old_text": "AddRequiredAssignment(value, parameter_instruction, memory_space,\n                                    parameter_instruction_time,\n                                    /*offset=*/nullptr,\n                                    /*add_to_pending=*/false)",
          "new_text": "buffer->values()",
          "old_line_content": "              AddRequiredAssignment(value, parameter_instruction, memory_space,",
          "new_line_content": "            for (const HloValue* value : buffer->values()) {",
          "content_same": false
        },
        {
          "line": 2526,
          "old_api": "layout",
          "new_api": "root_instruction",
          "old_text": "subshape.layout().memory_space()",
          "new_text": "entry_computation->root_instruction()",
          "old_line_content": "        if (subshape.has_layout() && subshape.layout().memory_space() ==",
          "new_line_content": "  HloInstruction* root_instruction = entry_computation->root_instruction();",
          "content_same": false
        },
        {
          "line": 2532,
          "old_api": "values",
          "new_api": "layout",
          "old_text": "buffer->values()",
          "new_text": "subshape.layout().memory_space()",
          "old_line_content": "          for (const HloValue* value : buffer->values()) {",
          "new_line_content": "        if (subshape.has_layout() && subshape.layout().memory_space() ==",
          "content_same": false
        },
        {
          "line": 2537,
          "old_api": "AddRequiredAssignment",
          "new_api": "ComputeBuffersAt",
          "old_text": "AddRequiredAssignment(value, root_instruction, memory_space,\n                                  root_instruction_time,\n                                  /*offset=*/nullptr, /*add_to_pending=*/false)",
          "new_text": "alias_analysis_.ComputeBuffersAt(root_instruction, index)",
          "old_line_content": "            AddRequiredAssignment(value, root_instruction, memory_space,",
          "new_line_content": "             alias_analysis_.ComputeBuffersAt(root_instruction, index)) {",
          "content_same": false
        },
        {
          "line": 2553,
          "old_api": "shape",
          "new_api": "find",
          "old_text": "instruction->shape()",
          "new_text": "instruction_schedule.find(instruction)",
          "old_line_content": "             ShapeUtil::GetLeafShapes(instruction->shape())) {",
          "new_line_content": "        auto constant_instruction_it = instruction_schedule.find(instruction);",
          "content_same": false
        },
        {
          "line": 2559,
          "old_api": "ToShortString",
          "new_api": "shape",
          "old_text": "value->ToShortString()",
          "new_text": "instruction->shape()",
          "old_line_content": "                      << value->ToShortString()",
          "new_line_content": "             ShapeUtil::GetLeafShapes(instruction->shape())) {",
          "content_same": false
        },
        {
          "line": 2562,
          "old_api": "AddRequiredAssignment",
          "new_api": "ComputeBuffersAt",
          "old_text": "AddRequiredAssignment(value, instruction, MemorySpace::kDefault,\n                                    constant_instruction_time,\n                                    /*offset=*/nullptr,\n                                    /*add_to_pending=*/false)",
          "new_text": "alias_analysis_.ComputeBuffersAt(instruction, index)",
          "old_line_content": "              AddRequiredAssignment(value, instruction, MemorySpace::kDefault,",
          "new_line_content": "               alias_analysis_.ComputeBuffersAt(instruction, index)) {",
          "content_same": false
        },
        {
          "line": 2581,
          "old_api": "end",
          "new_api": "dataflow_analysis",
          "old_text": "instruction_schedule.end()",
          "new_text": "alias_analysis_.dataflow_analysis().values()",
          "old_line_content": "      if (instruction_time_it == instruction_schedule.end()) {",
          "new_line_content": "  for (const HloValue* value : alias_analysis_.dataflow_analysis().values()) {",
          "content_same": false
        },
        {
          "line": 2595,
          "old_api": "CHECK",
          "new_api": "absl::c_find_if(\n          required_assignments,\n          [&](const RequiredMemoryAssignment& required_assignment) {\n            return required_assignment.time == instruction_time;\n          })",
          "old_text": "CHECK(matching_assignment->memory_space == MemorySpace::kDefault)",
          "new_text": "absl::c_find_if(\n          required_assignments,\n          [&](const RequiredMemoryAssignment& required_assignment) {\n            return required_assignment.time == instruction_time;\n          })",
          "old_line_content": "        CHECK(matching_assignment->memory_space == MemorySpace::kDefault)",
          "new_line_content": "      auto matching_assignment = absl::c_find_if(",
          "content_same": false
        },
        {
          "line": 2615,
          "old_api": "entry_computation",
          "new_api": "shape",
          "old_text": "module.entry_computation()",
          "new_text": "position.shape()",
          "old_line_content": "  const HloComputation* entry_computation = module.entry_computation();",
          "new_line_content": "    const Shape& shape = position.shape();",
          "content_same": false
        },
        {
          "line": 2617,
          "old_api": "root_instruction",
          "new_api": "layout",
          "old_text": "entry_computation->root_instruction()",
          "new_text": "shape.layout().memory_space()",
          "old_line_content": "      entry_computation->root_instruction();",
          "new_line_content": "           shape.layout().memory_space() == options_.alternate_memory_space;",
          "content_same": false
        },
        {
          "line": 2620,
          "old_api": "defining_instruction",
          "new_api": "dataflow_analysis",
          "old_text": "value->defining_instruction()->opcode()",
          "new_text": "alias_analysis_.dataflow_analysis().module()",
          "old_line_content": "    if (value->defining_instruction()->opcode() == HloOpcode::kParameter &&",
          "new_line_content": "  const HloModule& module = alias_analysis_.dataflow_analysis().module();",
          "content_same": false
        },
        {
          "line": 2621,
          "old_api": "defining_instruction",
          "new_api": "entry_computation",
          "old_text": "value->defining_instruction()->parent()",
          "new_text": "module.entry_computation()",
          "old_line_content": "        value->defining_instruction()->parent() == entry_computation &&",
          "new_line_content": "  const HloComputation* entry_computation = module.entry_computation();",
          "content_same": false
        },
        {
          "line": 2626,
          "old_api": "positions",
          "new_api": "defining_instruction",
          "old_text": "value->positions()",
          "new_text": "value->defining_instruction()->opcode()",
          "old_line_content": "    for (const HloPosition& position : value->positions()) {",
          "new_line_content": "    if (value->defining_instruction()->opcode() == HloOpcode::kParameter &&",
          "content_same": false
        },
        {
          "line": 2628,
          "old_api": "is_position_in_alternate_memory",
          "new_api": "defining_position",
          "old_text": "is_position_in_alternate_memory(position)",
          "new_text": "value->defining_position()",
          "old_line_content": "          is_position_in_alternate_memory(position)) {",
          "new_line_content": "        is_position_in_alternate_memory(value->defining_position())) {",
          "content_same": false
        },
        {
          "line": 2654,
          "old_api": "Add",
          "new_api": "chunk",
          "old_text": "interval_tree_.Add(allocation_block.start_time, allocation_block.end_time,\n                       {allocation_block.offset, allocation_block.size})",
          "new_text": "allocation->chunk()",
          "old_line_content": "    interval_tree_.Add(allocation_block.start_time, allocation_block.end_time,",
          "new_line_content": "            << allocation->chunk().size << \", (\" << allocation_block.start_time",
          "content_same": false
        },
        {
          "line": 2681,
          "old_api": "Remove",
          "new_api": "CHECK_GE",
          "old_text": "interval_tree_.Remove(interval.start, interval.end, chunk)",
          "new_text": "CHECK_GE(peak_memory_usage_[i], 0)",
          "old_line_content": "    interval_tree_.Remove(interval.start, interval.end, chunk);",
          "new_line_content": "      CHECK_GE(peak_memory_usage_[i], 0)",
          "content_same": false
        },
        {
          "line": 2687,
          "old_api": "RemoveCopy",
          "new_api": "Remove",
          "old_text": "prefetch_async_copy_resource_.RemoveCopy(interval)",
          "new_text": "interval_tree_.Remove(interval.start, interval.end, chunk)",
          "old_line_content": "      prefetch_async_copy_resource_.RemoveCopy(interval);",
          "new_line_content": "    interval_tree_.Remove(interval.start, interval.end, chunk);",
          "content_same": false
        },
        {
          "line": 2691,
          "old_api": "RemoveCopy",
          "new_api": "Remove",
          "old_text": "eviction_async_copy_resource_.RemoveCopy(interval)",
          "new_text": "prefetch_interval_tree_.Remove(interval.start_time, interval.end_time,\n                                     kDummyChunk)",
          "old_line_content": "      eviction_async_copy_resource_.RemoveCopy(interval);",
          "new_line_content": "      prefetch_interval_tree_.Remove(interval.start_time, interval.end_time,",
          "content_same": false
        },
        {
          "line": 2747,
          "old_api": "back",
          "new_api": "size",
          "old_text": "repack_allocation_blocks_.back()",
          "new_text": "MakeRepackAllocationBlock(\n          colocated_allocation->start_time(), colocated_allocation->end_time(),\n          colocated_allocation->chunk().size,\n          colocated_allocation->chunk().offset,\n          static_cast<int64_t>(repack_allocation_blocks_.size()),\n          colocated_allocation)",
          "old_line_content": "      colocations.push_back(&repack_allocation_blocks_.back());",
          "new_line_content": "      repack_allocation_blocks_.push_back(MakeRepackAllocationBlock(",
          "content_same": false
        },
        {
          "line": 2760,
          "old_api": "clear",
          "new_api": "ClearPendingChunks",
          "old_text": "pending_required_assignments_.clear()",
          "new_text": "ClearPendingChunks()",
          "old_line_content": "  pending_required_assignments_.clear();",
          "new_line_content": "  ClearPendingChunks();",
          "content_same": false
        },
        {
          "line": 2767,
          "old_api": "VLOG",
          "new_api": "clear",
          "old_text": "VLOG(3)",
          "new_text": "aliased_offset_map_.clear()",
          "old_line_content": "  VLOG(3) << \"Committing chunk: \" << buffer_interval.start << \"-\"",
          "new_line_content": "  aliased_offset_map_.clear();",
          "content_same": false
        },
        {
          "line": 2773,
          "old_api": "CHECK_LE",
          "new_api": "VLOG",
          "old_text": "CHECK_LE(peak_memory_usage_[i], options_.max_size_in_bytes)",
          "new_text": "VLOG(3)",
          "old_line_content": "    CHECK_LE(peak_memory_usage_[i], options_.max_size_in_bytes)",
          "new_line_content": "  VLOG(3) << \"Committing chunk: \" << buffer_interval.start << \"-\"",
          "content_same": false
        },
        {
          "line": 2779,
          "old_api": "CommitChunk",
          "new_api": "CHECK_LE",
          "old_text": "CommitChunk(buffer_interval, chunk_candidate)",
          "new_text": "CHECK_LE(peak_memory_usage_[i], options_.max_size_in_bytes)",
          "old_line_content": "  CommitChunk(buffer_interval, chunk_candidate);",
          "new_line_content": "    CHECK_LE(peak_memory_usage_[i], options_.max_size_in_bytes)",
          "content_same": false
        },
        {
          "line": 2805,
          "old_api": "GetLiveAllocationAt",
          "new_api": "allocation_sequence",
          "old_text": "GetLiveAllocationAt(*allocation_sequence, request.end_time)",
          "new_text": "request.allocation_value->allocation_sequence()",
          "old_line_content": "        GetLiveAllocationAt(*allocation_sequence, request.end_time);",
          "new_line_content": "  auto allocation_sequence = request.allocation_value->allocation_sequence();",
          "content_same": false
        },
        {
          "line": 2812,
          "old_api": "defining_position",
          "new_api": "CHECK_NE",
          "old_text": "request.allocation_value->defining_position()",
          "new_text": "CHECK_NE(allocation, nullptr)",
          "old_line_content": "      request.allocation_value->defining_position();",
          "new_line_content": "    CHECK_NE(allocation, nullptr);",
          "content_same": false
        },
        {
          "line": 2813,
          "old_api": "VLOG",
          "new_api": "AddUse",
          "old_text": "VLOG(2)",
          "new_text": "allocation->AddUse(request.use->hlo_use)",
          "old_line_content": "  VLOG(2) << \"Finding allocation for \"",
          "new_line_content": "    allocation->AddUse(request.use->hlo_use);",
          "content_same": false
        },
        {
          "line": 2818,
          "old_api": "ToString",
          "new_api": "defining_position",
          "old_text": "request.use->hlo_use.ToString()",
          "new_text": "request.allocation_value->defining_position()",
          "old_line_content": "          << \" use = \" << request.use->hlo_use.ToString()",
          "new_line_content": "      request.allocation_value->defining_position();",
          "content_same": false
        },
        {
          "line": 2820,
          "old_api": "ToString",
          "new_api": "ToShortString",
          "old_text": "defining_position.ToString()",
          "new_text": "request.allocation_value->ToShortString()",
          "old_line_content": "          << \", def pos = \" << defining_position.ToString();",
          "new_line_content": "          << request.allocation_value->ToShortString() << \" (\"",
          "content_same": false
        },
        {
          "line": 2823,
          "old_api": "VLOG",
          "new_api": "back",
          "old_text": "VLOG(3)",
          "new_text": "request.allocation_value->uses().back()",
          "old_line_content": "    VLOG(3) << \"Definition benefit = \"",
          "new_line_content": "          << \" last use = \" << request.allocation_value->uses().back().time",
          "content_same": false
        },
        {
          "line": 2824,
          "old_api": "GetAlternateMemoryBenefit",
          "new_api": "ToString",
          "old_text": "options_.cost_analysis->GetAlternateMemoryBenefit(\n                   request.allocation_value->defining_position())",
          "new_text": "request.use->hlo_use.ToString()",
          "old_line_content": "            << options_.cost_analysis->GetAlternateMemoryBenefit(",
          "new_line_content": "          << \" use = \" << request.use->hlo_use.ToString()",
          "content_same": false
        },
        {
          "line": 2827,
          "old_api": "GetAlternateMemoryBenefit",
          "new_api": "CHECK_LE",
          "old_text": "options_.cost_analysis->GetAlternateMemoryBenefit(\n                   request.use->hlo_use)",
          "new_text": "CHECK_LE(request.start_time, request.end_time)",
          "old_line_content": "            << options_.cost_analysis->GetAlternateMemoryBenefit(",
          "new_line_content": "  CHECK_LE(request.start_time, request.end_time);",
          "content_same": false
        },
        {
          "line": 2853,
          "old_api": "equals_ignoring_time",
          "new_api": "AliasedRequiredAssignmentForUse",
          "old_text": "aliased_required_assignment_at_end->equals_ignoring_time(\n                *required_assignment_at_end)",
          "new_text": "AliasedRequiredAssignmentForUse(*request.use)",
          "old_line_content": "            aliased_required_assignment_at_end->equals_ignoring_time(",
          "new_line_content": "      AliasedRequiredAssignmentForUse(*request.use);",
          "content_same": false
        },
        {
          "line": 2870,
          "old_api": "defining_position",
          "new_api": "empty",
          "old_text": "allocation->defining_position()",
          "new_text": "allocation_sequence->empty()",
          "old_line_content": "                   allocation->defining_position() == defining_position;",
          "new_line_content": "    if (!allocation_sequence->empty()) {",
          "content_same": false
        },
        {
          "line": 2891,
          "old_api": "back",
          "new_api": "std::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, required_assignment_at_start->memory_space,\n              aliased_chunk, request.start_time, request.start_time,\n              /*is_scoped_allocation=*/false)",
          "old_text": "allocation_sequence->back()",
          "new_text": "std::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, required_assignment_at_start->memory_space,\n              aliased_chunk, request.start_time, request.start_time,\n              /*is_scoped_allocation=*/false)",
          "old_line_content": "        CreateOrAddToAliasedOffset(*allocation_sequence->back(),",
          "new_line_content": "          std::make_unique<MemorySpaceAssignment::Allocation>(",
          "content_same": false
        },
        {
          "line": 2908,
          "old_api": "rbegin",
          "new_api": "AllocateInAlternateMemoryNoCopy",
          "old_text": "allocation_sequence->rbegin()",
          "new_text": "AllocateInAlternateMemoryNoCopy(request)",
          "old_line_content": "  auto prev_allocation_it = allocation_sequence->rbegin();",
          "new_line_content": "    allocation_result = AllocateInAlternateMemoryNoCopy(request);",
          "content_same": false
        },
        {
          "line": 2914,
          "old_api": "memory_space",
          "new_api": "rbegin",
          "old_text": "allocation->memory_space()",
          "new_text": "allocation_sequence->rbegin()",
          "old_line_content": "                     return allocation->memory_space() == MemorySpace::kDefault;",
          "new_line_content": "  auto prev_allocation_it = allocation_sequence->rbegin();",
          "content_same": false
        },
        {
          "line": 2920,
          "old_api": "defining_position",
          "new_api": "memory_space",
          "old_text": "*prev_allocation_it)->defining_position()",
          "new_text": "allocation->memory_space()",
          "old_line_content": "      (*prev_allocation_it)->defining_position() == defining_position &&",
          "new_line_content": "                     return allocation->memory_space() == MemorySpace::kDefault;",
          "content_same": false
        },
        {
          "line": 2924,
          "old_api": "Evict",
          "new_api": "rend",
          "old_text": "Evict(request)",
          "new_text": "allocation_sequence->rend()",
          "old_line_content": "    Result eviction_result = Evict(request);",
          "new_line_content": "      prev_allocation_it != allocation_sequence->rend() &&",
          "content_same": false
        },
        {
          "line": 2927,
          "old_api": "result_mark",
          "new_api": "requires_contiguous_allocation",
          "old_text": "result_mark(Result::kFailRequiresUncommit, eviction_result)",
          "new_text": "request.allocation_value->requires_contiguous_allocation()",
          "old_line_content": "      return result_mark(Result::kFailRequiresUncommit, eviction_result);",
          "new_line_content": "      !request.allocation_value->requires_contiguous_allocation()) {",
          "content_same": false
        },
        {
          "line": 2930,
          "old_api": "rend",
          "new_api": "Evict",
          "old_text": "allocation_sequence->rend()",
          "new_text": "Evict(request)",
          "old_line_content": "  } else if (prev_allocation_in_default_mem_it == allocation_sequence->rend()) {",
          "new_line_content": "    Result eviction_result = Evict(request);",
          "content_same": false
        },
        {
          "line": 2936,
          "old_api": "rbegin",
          "new_api": "rend",
          "old_text": "allocation_sequence->rbegin()",
          "new_text": "allocation_sequence->rend()",
          "old_line_content": "    prev_allocation_in_default_mem_it = allocation_sequence->rbegin();",
          "new_line_content": "  } else if (prev_allocation_in_default_mem_it == allocation_sequence->rend()) {",
          "content_same": false
        },
        {
          "line": 2946,
          "old_api": "requires_contiguous_allocation",
          "new_api": "memory_space",
          "old_text": "request.allocation_value->requires_contiguous_allocation()",
          "new_text": "*prev_allocation_in_default_mem_it)->memory_space()",
          "old_line_content": "  if (request.allocation_value->requires_contiguous_allocation() &&",
          "new_line_content": "  CHECK((*prev_allocation_in_default_mem_it)->memory_space() ==",
          "content_same": false
        },
        {
          "line": 2952,
          "old_api": "result_mark",
          "new_api": "requires_contiguous_allocation",
          "old_text": "result_mark(Result::kFailRequiresUncommit, allocation_result)",
          "new_text": "request.allocation_value->requires_contiguous_allocation()",
          "old_line_content": "    return result_mark(Result::kFailRequiresUncommit, allocation_result);",
          "new_line_content": "  if (request.allocation_value->requires_contiguous_allocation() &&",
          "content_same": false
        },
        {
          "line": 2965,
          "old_api": "requires_contiguous_allocation",
          "new_api": "Extend",
          "old_text": "request.allocation_value->requires_contiguous_allocation()",
          "new_text": "*prev_allocation_in_default_mem_it)->Extend(request.end_time)",
          "old_line_content": "  if (!request.allocation_value->requires_contiguous_allocation()) {",
          "new_line_content": "    (*prev_allocation_in_default_mem_it)->Extend(request.end_time);",
          "content_same": false
        },
        {
          "line": 2971,
          "old_api": "result_mark",
          "new_api": "requires_contiguous_allocation",
          "old_text": "result_mark(prefetch_result, allocation_result)",
          "new_text": "request.allocation_value->requires_contiguous_allocation()",
          "old_line_content": "    result_mark(prefetch_result, allocation_result);",
          "new_line_content": "  if (!request.allocation_value->requires_contiguous_allocation()) {",
          "content_same": false
        },
        {
          "line": 2990,
          "old_api": "Extend",
          "new_api": "requires_contiguous_allocation",
          "old_text": "*prev_allocation_in_default_mem_it)->Extend(request.end_time)",
          "new_text": "request.allocation_value->requires_contiguous_allocation()",
          "old_line_content": "  (*prev_allocation_in_default_mem_it)->Extend(request.end_time);",
          "new_line_content": "      request.allocation_value->requires_contiguous_allocation()) {",
          "content_same": false
        },
        {
          "line": 2991,
          "old_api": "AddUse",
          "new_api": "result_mark",
          "old_text": "*prev_allocation_in_default_mem_it)->AddUse(request.use->hlo_use)",
          "new_text": "result_mark(Result::kFailRequiresUncommit, allocation_result)",
          "old_line_content": "  (*prev_allocation_in_default_mem_it)->AddUse(request.use->hlo_use);",
          "new_line_content": "    return result_mark(Result::kFailRequiresUncommit, allocation_result);",
          "content_same": false
        },
        {
          "line": 3018,
          "old_api": "push_back",
          "new_api": "std::make_unique<MemorySpaceAssignment::CopyAllocation>(\n          prev_allocation, memory_space, chunk, start_time, end_time,\n          copy_done_schedule_before_time, cross_program_prefetch_index)",
          "old_text": "pending_async_copies_.push_back({start_time, copy_done_schedule_before_time,\n                                   resource, memory_space,\n                                   next_async_copy_id_++})",
          "new_text": "std::make_unique<MemorySpaceAssignment::CopyAllocation>(\n          prev_allocation, memory_space, chunk, start_time, end_time,\n          copy_done_schedule_before_time, cross_program_prefetch_index)",
          "old_line_content": "  pending_async_copies_.push_back({start_time, copy_done_schedule_before_time,",
          "new_line_content": "      std::make_unique<MemorySpaceAssignment::CopyAllocation>(",
          "content_same": false
        },
        {
          "line": 3024,
          "old_api": "back",
          "new_api": "push_back",
          "old_text": "pending_async_copies_.back()",
          "new_text": "pending_async_copies_.push_back({start_time, copy_done_schedule_before_time,\n                                   resource, memory_space,\n                                   next_async_copy_id_++})",
          "old_line_content": "    prefetch_async_copy_resource_.AddCopy(pending_async_copies_.back());",
          "new_line_content": "  pending_async_copies_.push_back({start_time, copy_done_schedule_before_time,",
          "content_same": false
        },
        {
          "line": 3073,
          "old_api": "get",
          "new_api": "is_allowed_in_alternate_mem_fn",
          "old_text": "request.allocation_value->allocation_sequence()->back().get()",
          "new_text": "options_.is_allowed_in_alternate_mem_fn(\n        *request.allocation_value->value())",
          "old_line_content": "        request.allocation_value->allocation_sequence()->back().get();",
          "new_line_content": "    can_eliminate_copy = options_.is_allowed_in_alternate_mem_fn(",
          "content_same": false
        },
        {
          "line": 3091,
          "old_api": "value",
          "new_api": "shape",
          "old_text": "request.allocation_value->value()",
          "new_text": "defining_position.shape()",
          "old_line_content": "  alternate_mem_interval.buffer = request.allocation_value->value();",
          "new_line_content": "          defining_position.shape(), request.start_time + 1,",
          "content_same": false
        },
        {
          "line": 3108,
          "old_api": "CHECK",
          "new_api": "end_time",
          "old_text": "CHECK(!preferred_offset || request.preferred_offset == preferred_offset)",
          "new_text": "prev_allocation->end_time()",
          "old_line_content": "    CHECK(!preferred_offset || request.preferred_offset == preferred_offset)",
          "new_line_content": "    alternate_mem_interval.start = prev_allocation->end_time() + 1;",
          "content_same": false
        },
        {
          "line": 3114,
          "old_api": "VLOG",
          "new_api": "CHECK",
          "old_text": "VLOG(3)",
          "new_text": "CHECK(!preferred_offset || request.preferred_offset == preferred_offset)",
          "old_line_content": "  VLOG(3) << \"We can eliminate copy to alternate memory. Preferred offset = \"",
          "new_line_content": "    CHECK(!preferred_offset || request.preferred_offset == preferred_offset)",
          "content_same": false
        },
        {
          "line": 3155,
          "old_api": "defining_position",
          "new_api": "AddToPendingChunks",
          "old_text": "prev_allocation->defining_position()",
          "new_text": "AddToPendingChunks(alternate_mem_interval, *chunk_candidate)",
          "old_line_content": "         prev_allocation->defining_position() == defining_position)) {",
          "new_line_content": "    AddToPendingChunks(alternate_mem_interval, *chunk_candidate);",
          "content_same": false
        },
        {
          "line": 3184,
          "old_api": "shape",
          "new_api": "get",
          "old_text": "options_.prefetch_interval_picker->PreferredEvictionEndTime(\n                   request.allocation_value->defining_position().shape(),\n                   eviction_start_time, request.end_time)",
          "new_text": "request.allocation_value->allocation_sequence()->back().get()",
          "old_line_content": "      std::max(options_.prefetch_interval_picker->PreferredEvictionEndTime(",
          "new_line_content": "      request.allocation_value->allocation_sequence()->back().get();",
          "content_same": false
        },
        {
          "line": 3185,
          "old_api": "shape",
          "new_api": "start_time",
          "old_text": "request.allocation_value->defining_position().shape()",
          "new_text": "prev_allocation->start_time()",
          "old_line_content": "                   request.allocation_value->defining_position().shape(),",
          "new_line_content": "  int64_t eviction_start_time = prev_allocation->start_time();",
          "content_same": false
        },
        {
          "line": 3190,
          "old_api": "std::min(preferred_eviction_end_time, request.latest_prefetch_time)",
          "new_api": "shape",
          "old_text": "std::min(preferred_eviction_end_time, request.latest_prefetch_time)",
          "new_text": "options_.prefetch_interval_picker->PreferredEvictionEndTime(\n                   request.allocation_value->defining_position().shape(),\n                   eviction_start_time, request.end_time)",
          "old_line_content": "      std::min(preferred_eviction_end_time, request.latest_prefetch_time);",
          "new_line_content": "      std::max(options_.prefetch_interval_picker->PreferredEvictionEndTime(",
          "content_same": false
        },
        {
          "line": 3199,
          "old_api": "chunk",
          "new_api": "value",
          "old_text": "prev_allocation->chunk()",
          "new_text": "request.allocation_value->value()",
          "old_line_content": "  int64_t preferred_offset = prev_allocation->chunk().offset;",
          "new_line_content": "  eviction_mem_interval.buffer = request.allocation_value->value();",
          "content_same": false
        },
        {
          "line": 3206,
          "old_api": "FindChunkCandidate",
          "new_api": "VLOG",
          "old_text": "FindChunkCandidate(eviction_mem_interval, preferred_offset)",
          "new_text": "VLOG(3)",
          "old_line_content": "        FindChunkCandidate(eviction_mem_interval, preferred_offset);",
          "new_line_content": "  VLOG(3) << \"Eviction (\" << eviction_start_time << \", \" << eviction_end_time",
          "content_same": false
        },
        {
          "line": 3214,
          "old_api": "chunk",
          "new_api": "AddToPendingChunks",
          "old_text": "prev_allocation->chunk()",
          "new_text": "AddToPendingChunks(eviction_mem_interval, chunk_candidate)",
          "old_line_content": "  VLOG(3) << \"Evicting buffer at \" << prev_allocation->chunk().offset << \" (\"",
          "new_line_content": "      AddToPendingChunks(eviction_mem_interval, chunk_candidate);",
          "content_same": false
        },
        {
          "line": 3220,
          "old_api": "shape",
          "new_api": "chunk",
          "old_text": "request.allocation_value->defining_position().shape()",
          "new_text": "prev_allocation->chunk()",
          "old_line_content": "                request.allocation_value->defining_position().shape())",
          "new_line_content": "  VLOG(3) << \"Evicting buffer at \" << prev_allocation->chunk().offset << \" (\"",
          "content_same": false
        },
        {
          "line": 3225,
          "old_api": "HasEnoughResource",
          "new_api": "shape",
          "old_text": "eviction_async_copy_resource_.HasEnoughResource(\n          eviction_start_time, eviction_end_time, eviction_resource)",
          "new_text": "options_.cost_analysis->GetAsyncCopyElapsed(\n                request.allocation_value->defining_position().shape())",
          "old_line_content": "      !eviction_async_copy_resource_.HasEnoughResource(",
          "new_line_content": "          ? options_.cost_analysis->GetAsyncCopyElapsed(",
          "content_same": false
        },
        {
          "line": 3231,
          "old_api": "VLOG",
          "new_api": "HasEnoughResource",
          "old_text": "VLOG(3)",
          "new_text": "eviction_async_copy_resource_.HasEnoughResource(\n          eviction_start_time, eviction_end_time, eviction_resource)",
          "old_line_content": "      VLOG(3) << \"Violates resource in last retry, setting resource = 0\";",
          "new_line_content": "      !eviction_async_copy_resource_.HasEnoughResource(",
          "content_same": false
        },
        {
          "line": 3235,
          "old_api": "HasEnoughResource",
          "new_api": "retry_number",
          "old_text": "eviction_async_copy_resource_.HasEnoughResource(\n            eviction_start_time, eviction_end_time, eviction_resource)",
          "new_text": "options_.prefetch_interval_picker->retry_number()",
          "old_line_content": "        !eviction_async_copy_resource_.HasEnoughResource(",
          "new_line_content": "    if (options_.prefetch_interval_picker->retry_number() ==",
          "content_same": false
        },
        {
          "line": 3256,
          "old_api": "VLOG",
          "new_api": "allocation_sequence",
          "old_text": "VLOG(3)",
          "new_text": "request.allocation_value->allocation_sequence()",
          "old_line_content": "      VLOG(3) << \"This violates resource.\";",
          "new_line_content": "                 request.allocation_value->allocation_sequence(),",
          "content_same": false
        },
        {
          "line": 3274,
          "old_api": "flattened_instruction_sequence",
          "new_api": "ToString",
          "old_text": "hlo_live_range_.flattened_instruction_sequence()\n                     .instructions()",
          "new_text": "request.use->hlo_use.ToString()",
          "old_line_content": "              << hlo_live_range_.flattened_instruction_sequence()",
          "new_line_content": "      VLOG(3) << \"Bailing: Could not evict \" << request.use->hlo_use.ToString()",
          "content_same": false
        },
        {
          "line": 3311,
          "old_api": "FindPrefetchEndTime",
          "new_api": "earliest_available_time",
          "old_text": "FindPrefetchEndTime(request, earliest_prefetch_time)",
          "new_text": "prev_allocation_in_default_mem.earliest_available_time()",
          "old_line_content": "      FindPrefetchEndTime(request, earliest_prefetch_time);",
          "new_line_content": "      prev_allocation_in_default_mem.earliest_available_time();",
          "content_same": false
        },
        {
          "line": 3338,
          "old_api": "value",
          "new_api": "VLOG",
          "old_text": "request.allocation_value->value()",
          "new_text": "VLOG(3)",
          "old_line_content": "  alternate_mem_interval.buffer = request.allocation_value->value();",
          "new_line_content": "  VLOG(3) << \"Trying prefetch picker = \"",
          "content_same": false
        },
        {
          "line": 3344,
          "old_api": "latest_time",
          "new_api": "value",
          "old_text": "options_.prefetch_interval_picker->latest_time()",
          "new_text": "request.allocation_value->value()",
          "old_line_content": "      options_.prefetch_interval_picker->latest_time();",
          "new_line_content": "  alternate_mem_interval.buffer = request.allocation_value->value();",
          "content_same": false
        },
        {
          "line": 3350,
          "old_api": "result_mark",
          "new_api": "latest_time",
          "old_text": "result_mark(Result::kFailOutOfMemory, result)",
          "new_text": "options_.prefetch_interval_picker->latest_time()",
          "old_line_content": "    result_mark(Result::kFailOutOfMemory, result);",
          "new_line_content": "      options_.prefetch_interval_picker->latest_time();",
          "content_same": false
        },
        {
          "line": 3354,
          "old_api": "operand",
          "new_api": "VLOG",
          "old_text": "ShapeUtil::GetSubshape(\n      use.instruction->operand(use.operand_number)->shape(), use.operand_index)",
          "new_text": "VLOG(3)",
          "old_line_content": "  const Shape& shape = ShapeUtil::GetSubshape(",
          "new_line_content": "    VLOG(3) << \"The latest prefetch (\" << alternate_mem_interval.start << \", \"",
          "content_same": false
        },
        {
          "line": 3371,
          "old_api": "result_mark",
          "new_api": "Done",
          "old_text": "result_mark(Result::kFailOutOfMemory, result)",
          "new_text": "options_.prefetch_interval_picker->Done()",
          "old_line_content": "      result_mark(Result::kFailOutOfMemory, result);",
          "new_line_content": "  while (!options_.prefetch_interval_picker->Done()) {",
          "content_same": false
        },
        {
          "line": 3377,
          "old_api": "VLOG",
          "new_api": "result_mark",
          "old_text": "VLOG(4)",
          "new_text": "result_mark(Result::kFailOutOfMemory, result)",
          "old_line_content": "    VLOG(4) << \"Trying alternate memory allocation (\"",
          "new_line_content": "      result_mark(Result::kFailOutOfMemory, result);",
          "content_same": false
        },
        {
          "line": 3383,
          "old_api": "GetAsyncCopyElapsed",
          "new_api": "VLOG",
          "old_text": "options_.cost_analysis->GetAsyncCopyElapsed(shape)",
          "new_text": "VLOG(4)",
          "old_line_content": "            ? options_.cost_analysis->GetAsyncCopyElapsed(shape)",
          "new_line_content": "    VLOG(4) << \"Trying alternate memory allocation (\"",
          "content_same": false
        },
        {
          "line": 3396,
          "old_api": "VLOG",
          "new_api": "result_mark",
          "old_text": "VLOG(4)",
          "new_text": "result_mark(Result::kFailViolatesAsyncCopyResource, result)",
          "old_line_content": "      VLOG(4) << \"This would violate the outstanding async copy limit.\";",
          "new_line_content": "      result_mark(Result::kFailViolatesAsyncCopyResource, result);",
          "content_same": false
        },
        {
          "line": 3411,
          "old_api": "ToDebugString",
          "new_api": "VLOG",
          "old_text": "options_.prefetch_interval_picker->ToDebugString()",
          "new_text": "VLOG(3)",
          "old_line_content": "              << options_.prefetch_interval_picker->ToDebugString();",
          "new_line_content": "      VLOG(3) << \"Move the buffer to alternate memory at \"",
          "content_same": false
        },
        {
          "line": 3417,
          "old_api": "allocation_sequence",
          "new_api": "ToDebugString",
          "old_text": "request.allocation_value->allocation_sequence()",
          "new_text": "options_.prefetch_interval_picker->ToDebugString()",
          "old_line_content": "                   request.allocation_value->allocation_sequence(),",
          "new_line_content": "              << options_.prefetch_interval_picker->ToDebugString();",
          "content_same": false
        },
        {
          "line": 3456,
          "old_api": "shape",
          "new_api": "end",
          "old_text": "request.allocation_value->defining_position().shape()",
          "new_text": "use_times.end()",
          "old_line_content": "    const Shape& shape = request.allocation_value->defining_position().shape();",
          "new_line_content": "    CHECK(use_time_it != use_times.end());",
          "content_same": false
        },
        {
          "line": 3469,
          "old_api": "chunk_end",
          "new_api": "end",
          "old_text": "std::lower_bound(\n        earliest_use_it, std::next(use_time_it), -1, [&](int64_t use, int64_t) {\n          alternate_mem_interval->end = use;\n          Chunk chunk_candidate = FindChunkCandidate(*alternate_mem_interval);\n          if (chunk_candidate.chunk_end() <= available_heap_size()) {\n            if (use > latest_matching_use) {\n              last_chunk_candidate = chunk_candidate;\n              latest_matching_use = use;\n            }\n            return true;\n          }\n          return false;\n        })",
          "new_text": "use_times.end()",
          "old_line_content": "    (void)std::lower_bound(",
          "new_line_content": "    CHECK(use_time_it != use_times.end());",
          "content_same": false
        },
        {
          "line": 3518,
          "old_api": "opcode",
          "new_api": "HloDataflowAnalysis::Run(*module_)",
          "old_text": "instruction->opcode()",
          "new_text": "HloDataflowAnalysis::Run(*module_)",
          "old_line_content": "      } else if (instruction->opcode() == HloOpcode::kCopyDone) {",
          "new_line_content": "                      HloDataflowAnalysis::Run(*module_));",
          "content_same": false
        },
        {
          "line": 3521,
          "old_api": "GetUniqueValueAt",
          "new_api": "instructions",
          "old_text": "dataflow_analysis->GetUniqueValueAt(instruction)",
          "new_text": "computation->instructions()",
          "old_line_content": "            options_.size_fn(dataflow_analysis->GetUniqueValueAt(instruction));",
          "new_line_content": "    for (HloInstruction* instruction : computation->instructions()) {",
          "content_same": false
        },
        {
          "line": 3522,
          "old_api": "layout",
          "new_api": "opcode",
          "old_text": "instruction->shape().layout().memory_space()",
          "new_text": "instruction->opcode()",
          "old_line_content": "        if (instruction->shape().layout().memory_space() ==",
          "new_line_content": "      if (instruction->opcode() == HloOpcode::kCopyStart) {",
          "content_same": false
        },
        {
          "line": 3550,
          "old_api": "GlobalDecreasingSizeBestFitHeap<\n        HloValue>::GetSpatialBufferIntervalCompare()(x, y)",
          "new_api": "GetMemoryBoundedness",
          "old_text": "GlobalDecreasingSizeBestFitHeap<\n        HloValue>::GetSpatialBufferIntervalCompare()(x, y)",
          "new_text": "cost_analysis.GetMemoryBoundedness(x, cache)",
          "old_line_content": "    return GlobalDecreasingSizeBestFitHeap<",
          "new_line_content": "    float x_memory_boundedness = cost_analysis.GetMemoryBoundedness(x, cache);",
          "content_same": false
        },
        {
          "line": 3567,
          "old_api": "RunMemorySpaceAssignment",
          "new_api": "VLOG",
          "old_text": "memory_space_assignment.RunMemorySpaceAssignment(hlo_live_range,\n                                                          alias_analysis)",
          "new_text": "VLOG(3)",
          "old_line_content": "  return memory_space_assignment.RunMemorySpaceAssignment(hlo_live_range,",
          "new_line_content": "  VLOG(3) << \"Module before memory space assignment: \";",
          "content_same": false
        },
        {
          "line": 3585,
          "old_api": "SimplifyGraph",
          "new_api": "ComputeEstimatedElapsedTime",
          "old_text": "SimplifyGraph()",
          "new_text": "ComputeEstimatedElapsedTime(hlo_live_range, allocations_)",
          "old_line_content": "  TF_RETURN_IF_ERROR(SimplifyGraph());",
          "new_line_content": "        ComputeEstimatedElapsedTime(hlo_live_range, allocations_);",
          "content_same": false
        },
        {
          "line": 3586,
          "old_api": "FixSchedule",
          "new_api": "VLOG",
          "old_text": "FixSchedule()",
          "new_text": "VLOG(1)",
          "old_line_content": "  TF_RETURN_IF_ERROR(FixSchedule());",
          "new_line_content": "    VLOG(1) << \"Estimated elapsed time (sec): \" << estimated_time;",
          "content_same": false
        },
        {
          "line": 3589,
          "old_api": "VLOG",
          "new_api": "Process",
          "old_text": "VLOG(3)",
          "new_text": "Process()",
          "old_line_content": "  VLOG(3) << \"Module after memory space assignment: \";",
          "new_line_content": "  TF_RETURN_IF_ERROR(Process());",
          "content_same": false
        },
        {
          "line": 3590,
          "old_api": "ToString",
          "new_api": "ScheduleAsynchronousCopies",
          "old_text": "module_->ToString()",
          "new_text": "ScheduleAsynchronousCopies()",
          "old_line_content": "  XLA_VLOG_LINES(3, module_->ToString());",
          "new_line_content": "  ScheduleAsynchronousCopies();",
          "content_same": false
        },
        {
          "line": 3591,
          "old_api": "Verify",
          "new_api": "SimplifyGraph",
          "old_text": "module_->schedule().Verify()",
          "new_text": "SimplifyGraph()",
          "old_line_content": "  TF_CHECK_OK(module_->schedule().Verify());",
          "new_line_content": "  TF_RETURN_IF_ERROR(SimplifyGraph());",
          "content_same": false
        },
        {
          "line": 3593,
          "old_api": "VLOG",
          "new_api": "ExportAndColorBuffers",
          "old_text": "VLOG(1)",
          "new_text": "ExportAndColorBuffers()",
          "old_line_content": "  VLOG(1) << \"Maximum number of outstanding async copies: \"",
          "new_line_content": "  TF_RETURN_IF_ERROR(ExportAndColorBuffers());",
          "content_same": false
        },
        {
          "line": 3597,
          "old_api": "VLOG",
          "new_api": "Verify",
          "old_text": "VLOG(1)",
          "new_text": "module_->schedule().Verify()",
          "old_line_content": "  VLOG(1) << \"Number of evictions: \" << stats.num_evictions",
          "new_line_content": "  TF_CHECK_OK(module_->schedule().Verify());",
          "content_same": false
        },
        {
          "line": 3608,
          "old_api": "std::make_unique<AlternateMemoryBestFitHeap>(\n      &allocations_, options_, alias_analysis, hlo_live_range)",
          "new_api": "std::move(preset_assignments_)",
          "old_text": "std::make_unique<AlternateMemoryBestFitHeap>(\n      &allocations_, options_, alias_analysis, hlo_live_range)",
          "new_text": "std::move(preset_assignments_)",
          "old_line_content": "  auto algorithm = std::make_unique<AlternateMemoryBestFitHeap>(",
          "new_line_content": "  return std::move(preset_assignments_);",
          "content_same": false
        },
        {
          "line": 3614,
          "old_api": "std::move(algorithm)",
          "new_api": "std::make_unique<AlternateMemoryBestFitHeap>(\n      &allocations_, options_, alias_analysis, hlo_live_range)",
          "old_text": "std::move(algorithm)",
          "new_text": "std::make_unique<AlternateMemoryBestFitHeap>(\n      &allocations_, options_, alias_analysis, hlo_live_range)",
          "old_line_content": "  TF_RETURN_IF_ERROR(HeapSimulator::Run(std::move(algorithm), *module_,",
          "new_line_content": "  auto algorithm = std::make_unique<AlternateMemoryBestFitHeap>(",
          "content_same": false
        },
        {
          "line": 3636,
          "old_api": "opcode",
          "new_api": "mutable_operand",
          "old_text": "instruction->opcode()",
          "new_text": "operand->mutable_operand(index)",
          "old_line_content": "    while (instruction->opcode() == HloOpcode::kGetTupleElement) {",
          "new_line_content": "    operand = operand->mutable_operand(index);",
          "content_same": false
        },
        {
          "line": 3672,
          "old_api": "std::make_pair(hlo_use.operand_number, hlo_use.operand_index)",
          "new_api": "defining_position",
          "old_text": "std::make_pair(hlo_use.operand_number, hlo_use.operand_index)",
          "new_text": "allocation->defining_position()",
          "old_line_content": "          std::make_pair(hlo_use.operand_number, hlo_use.operand_index));",
          "new_line_content": "            allocation->defining_position().index);",
          "content_same": false
        },
        {
          "line": 3677,
          "old_api": "flattened_instruction_sequence",
          "new_api": "push_back",
          "old_text": "hlo_live_range.flattened_instruction_sequence().instructions()",
          "new_text": "operands_in_alternate_memory_map[use_instruction].push_back(\n          std::make_pair(hlo_use.operand_number, hlo_use.operand_index))",
          "old_line_content": "      hlo_live_range.flattened_instruction_sequence().instructions();",
          "new_line_content": "      operands_in_alternate_memory_map[use_instruction].push_back(",
          "content_same": false
        },
        {
          "line": 3687,
          "old_api": "end",
          "new_api": "find",
          "old_text": "operands_in_alternate_memory_map.end()",
          "new_text": "outputs_in_alternate_memory_map.find(instruction)",
          "old_line_content": "    if (operand_it != operands_in_alternate_memory_map.end()) {",
          "new_line_content": "    auto output_it = outputs_in_alternate_memory_map.find(instruction);",
          "content_same": false
        },
        {
          "line": 3715,
          "old_api": "mutable_operand",
          "new_api": "AddGetTupleElements",
          "old_text": "TF_ASSIGN_OR_RETURN(\n          replacement_instruction,\n          TupleUtil::ReplaceTupleWith(\n              producing_instruction,\n              use.instruction->mutable_operand(use.operand_number),\n              use.operand_index))",
          "new_text": "AddGetTupleElements()",
          "old_line_content": "      TF_ASSIGN_OR_RETURN(",
          "new_line_content": "  HloInstruction* producing_instruction = AddGetTupleElements();",
          "content_same": false
        },
        {
          "line": 3721,
          "old_api": "shape",
          "new_api": "mutable_operand",
          "old_text": "producing_instruction->shape()",
          "new_text": "TF_ASSIGN_OR_RETURN(\n          replacement_instruction,\n          TupleUtil::ReplaceTupleWith(\n              producing_instruction,\n              use.instruction->mutable_operand(use.operand_number),\n              use.operand_index))",
          "old_line_content": "    } else if (operand_shape != producing_instruction->shape()) {",
          "new_line_content": "      TF_ASSIGN_OR_RETURN(",
          "content_same": false
        },
        {
          "line": 3723,
          "old_api": "ToString",
          "new_api": "mutable_operand",
          "old_text": "producing_instruction->shape().ToString()",
          "new_text": "TupleUtil::ReplaceTupleWith(\n              producing_instruction,\n              use.instruction->mutable_operand(use.operand_number),\n              use.operand_index)",
          "old_line_content": "              << \", new shape = \" << producing_instruction->shape().ToString()",
          "new_line_content": "          TupleUtil::ReplaceTupleWith(",
          "content_same": false
        },
        {
          "line": 3725,
          "old_api": "AddInstruction",
          "new_api": "mutable_operand",
          "old_text": "computation->AddInstruction(\n          HloInstruction::CreateBitcast(operand_shape, producing_instruction))",
          "new_text": "use.instruction->mutable_operand(use.operand_number)",
          "old_line_content": "      replacement_instruction = computation->AddInstruction(",
          "new_line_content": "              use.instruction->mutable_operand(use.operand_number),",
          "content_same": false
        },
        {
          "line": 3728,
          "old_api": "ReplaceOperandWith",
          "new_api": "ToString",
          "old_text": "use.instruction->ReplaceOperandWith(\n        use.operand_number, replacement_instruction)",
          "new_text": "operand_shape.ToString()",
          "old_line_content": "    TF_RETURN_IF_ERROR(use.instruction->ReplaceOperandWith(",
          "new_line_content": "      VLOG(4) << \"Old shape = \" << operand_shape.ToString()",
          "content_same": false
        },
        {
          "line": 3731,
          "old_api": "OkStatus",
          "new_api": "AddInstruction",
          "old_text": "OkStatus()",
          "new_text": "computation->AddInstruction(\n          HloInstruction::CreateBitcast(operand_shape, producing_instruction))",
          "old_line_content": "  return OkStatus();",
          "new_line_content": "      replacement_instruction = computation->AddInstruction(",
          "content_same": false
        },
        {
          "line": 3737,
          "old_api": "shape",
          "new_api": "OkStatus",
          "old_text": "defining_position().shape()",
          "new_text": "OkStatus()",
          "old_line_content": "  Shape shape = defining_position().shape();",
          "new_line_content": "  return OkStatus();",
          "content_same": false
        },
        {
          "line": 3747,
          "old_api": "absl::StrCat(\"alt (off: \", chunk_->offset, \")\")",
          "new_api": "defining_position",
          "old_text": "absl::StrCat(\"alt (off: \", chunk_->offset, \")\")",
          "new_text": "defining_position()",
          "old_line_content": "    memory_space_str = absl::StrCat(\"alt (off: \", chunk_->offset, \")\");",
          "new_line_content": "  return TupleUtil::AddGetTupleElements(defining_position());",
          "content_same": false
        },
        {
          "line": 3753,
          "old_api": "uses",
          "new_api": "absl::StrCat(\"alt (off: \", chunk_->offset, \")\")",
          "old_text": "uses()",
          "new_text": "absl::StrCat(\"alt (off: \", chunk_->offset, \")\")",
          "old_line_content": "                      \", uses: \", UsesToString(uses()));",
          "new_line_content": "    memory_space_str = absl::StrCat(\"alt (off: \", chunk_->offset, \")\");",
          "content_same": false
        },
        {
          "line": 3759,
          "old_api": "absl::StrCat(\"alt (off: \", chunk_->offset, \")\")",
          "new_api": "uses",
          "old_text": "absl::StrCat(\"alt (off: \", chunk_->offset, \")\")",
          "new_text": "uses()",
          "old_line_content": "    memory_space_str = absl::StrCat(\"alt (off: \", chunk_->offset, \")\");",
          "new_line_content": "                      \", uses: \", UsesToString(uses()));",
          "content_same": false
        },
        {
          "line": 3765,
          "old_api": "uses",
          "new_api": "absl::StrCat(\"alt (off: \", chunk_->offset, \")\")",
          "old_text": "uses()",
          "new_text": "absl::StrCat(\"alt (off: \", chunk_->offset, \")\")",
          "old_line_content": "                      \", uses: \", UsesToString(uses()), \", from \",",
          "new_line_content": "    memory_space_str = absl::StrCat(\"alt (off: \", chunk_->offset, \")\");",
          "content_same": false
        },
        {
          "line": 3770,
          "old_api": "ToString",
          "new_api": "copy_done_schedule_before",
          "old_text": "absl::StrCat(\"Mirrored Allocation for \",\n                      original_allocation_.ToString())",
          "new_text": "copy_done_schedule_before()",
          "old_line_content": "  return absl::StrCat(\"Mirrored Allocation for \",",
          "new_line_content": "                      \", copy_done_before_time: \", copy_done_schedule_before(),",
          "content_same": false
        },
        {
          "line": 3771,
          "old_api": "ToString",
          "new_api": "uses",
          "old_text": "original_allocation_.ToString()",
          "new_text": "uses()",
          "old_line_content": "                      original_allocation_.ToString());",
          "new_line_content": "                      \", uses: \", UsesToString(uses()), \", from \",",
          "content_same": false
        },
        {
          "line": 3782,
          "old_api": "shape",
          "new_api": "ToString",
          "old_text": "defining_position().shape()",
          "new_text": "defining_position_.ToString()",
          "old_line_content": "  Shape shape = defining_position().shape();",
          "new_line_content": "                      defining_position_.ToString(), \", originally \",",
          "content_same": false
        },
        {
          "line": 3783,
          "old_api": "AddGetTupleElements",
          "new_api": "ToString",
          "old_text": "AddGetTupleElements()",
          "new_text": "original_allocation_.ToString()",
          "old_line_content": "  HloInstruction* producing_instruction = AddGetTupleElements();",
          "new_line_content": "                      original_allocation_.ToString());",
          "content_same": false
        },
        {
          "line": 3788,
          "old_api": "AddInstruction",
          "new_api": "shape",
          "old_text": "computation->AddInstruction(\n      HloInstruction::CreateUnary(shape, HloOpcode::kCopyDone, copy_start_))",
          "new_text": "defining_position().shape()",
          "old_line_content": "  copy_done_ = computation->AddInstruction(",
          "new_line_content": "  Shape shape = defining_position().shape();",
          "content_same": false
        },
        {
          "line": 3789,
          "old_api": "HloInstruction::CreateUnary(shape, HloOpcode::kCopyDone, copy_start_)",
          "new_api": "AddGetTupleElements",
          "old_text": "HloInstruction::CreateUnary(shape, HloOpcode::kCopyDone, copy_start_)",
          "new_text": "AddGetTupleElements()",
          "old_line_content": "      HloInstruction::CreateUnary(shape, HloOpcode::kCopyDone, copy_start_));",
          "new_line_content": "  HloInstruction* producing_instruction = AddGetTupleElements();",
          "content_same": false
        },
        {
          "line": 3790,
          "old_api": "name",
          "new_api": "parent",
          "old_text": "copy_start_->name()",
          "new_text": "producing_instruction->parent()",
          "old_line_content": "  VLOG(4) << \"Created \" << copy_start_->name()",
          "new_line_content": "  HloComputation* computation = producing_instruction->parent();",
          "content_same": false
        },
        {
          "line": 3791,
          "old_api": "ToString",
          "new_api": "HloInstruction::CreateCopyStart(\n      ShapeUtil::MakeTupleShape({shape, shape, ShapeUtil::MakeShape(U32, {})}),\n      producing_instruction, cross_program_prefetch_index_)",
          "old_text": "ToString()",
          "new_text": "HloInstruction::CreateCopyStart(\n      ShapeUtil::MakeTupleShape({shape, shape, ShapeUtil::MakeShape(U32, {})}),\n      producing_instruction, cross_program_prefetch_index_)",
          "old_line_content": "          << \" for copy allocation: \" << ToString();",
          "new_line_content": "  copy_start_ = computation->AddInstruction(HloInstruction::CreateCopyStart(",
          "content_same": false
        },
        {
          "line": 3808,
          "old_api": "shape",
          "new_api": "IsTuple",
          "old_text": "copy_done_->shape()",
          "new_text": "operand_shape.IsTuple()",
          "old_line_content": "    } else if (operand_shape != copy_done_->shape()) {",
          "new_line_content": "    if (operand_shape.IsTuple()) {",
          "content_same": false
        },
        {
          "line": 3809,
          "old_api": "ToString",
          "new_api": "mutable_operand",
          "old_text": "operand_shape.ToString()",
          "new_text": "TF_ASSIGN_OR_RETURN(\n          replacement_instruction,\n          TupleUtil::ReplaceTupleWith(\n              copy_done_, use.instruction->mutable_operand(use.operand_number),\n              use.operand_index))",
          "old_line_content": "      VLOG(4) << \"Old shape = \" << operand_shape.ToString()",
          "new_line_content": "      TF_ASSIGN_OR_RETURN(",
          "content_same": false
        },
        {
          "line": 3812,
          "old_api": "AddInstruction",
          "new_api": "mutable_operand",
          "old_text": "computation->AddInstruction(\n          HloInstruction::CreateBitcast(operand_shape, copy_done_))",
          "new_text": "use.instruction->mutable_operand(use.operand_number)",
          "old_line_content": "      replacement_instruction = computation->AddInstruction(",
          "new_line_content": "              copy_done_, use.instruction->mutable_operand(use.operand_number),",
          "content_same": false
        },
        {
          "line": 3839,
          "old_api": "mutable_operand",
          "new_api": "AddGetTupleElements",
          "old_text": "calling_instruction_->mutable_operand(0)",
          "new_text": "original_allocation_.AddGetTupleElements()",
          "old_line_content": "                                  calling_instruction_->mutable_operand(0),",
          "new_line_content": "      original_allocation_.AddGetTupleElements();",
          "content_same": false
        },
        {
          "line": 3844,
          "old_api": "while_condition",
          "new_api": "mutable_operand",
          "old_text": "calling_instruction_->while_condition()\n       ->parameter_instruction(0)\n       ->mutable_shape()",
          "new_text": "TupleUtil::ReplaceTupleWith(producing_instruction,\n                                  calling_instruction_->mutable_operand(0),\n                                  {new_tuple_index})",
          "old_line_content": "  *calling_instruction_->while_condition()",
          "new_line_content": "      TupleUtil::ReplaceTupleWith(producing_instruction,",
          "content_same": false
        },
        {
          "line": 3847,
          "old_api": "while_body",
          "new_api": "ReplaceOperandWithDifferentShape",
          "old_text": "calling_instruction_->while_body()\n       ->parameter_instruction(0)\n       ->mutable_shape()",
          "new_text": "calling_instruction_->ReplaceOperandWithDifferentShape(\n      0, new_while_operand)",
          "old_line_content": "  *calling_instruction_->while_body()",
          "new_line_content": "  TF_RETURN_IF_ERROR(calling_instruction_->ReplaceOperandWithDifferentShape(",
          "content_same": false
        },
        {
          "line": 3875,
          "old_api": "OkStatus",
          "new_api": "root_instruction",
          "old_text": "OkStatus()",
          "new_text": "TF_ASSIGN_OR_RETURN(HloInstruction * new_while_body_root,\n                      TupleUtil::ReplaceTupleWith(\n                          AddGetTupleElements(), while_body->root_instruction(),\n                          defining_position_.index))",
          "old_line_content": "  return OkStatus();",
          "new_line_content": "  TF_ASSIGN_OR_RETURN(HloInstruction * new_while_body_root,",
          "content_same": false
        },
        {
          "line": 3891,
          "old_api": "MarkNeeded",
          "new_api": "insert",
          "old_text": "prev_allocation_.MarkNeeded(needed_allocations)",
          "new_text": "needed_allocations.insert(this)",
          "old_line_content": "  prev_allocation_.MarkNeeded(needed_allocations);",
          "new_line_content": "  needed_allocations.insert(this);",
          "content_same": false
        },
        {
          "line": 3906,
          "old_api": "insert",
          "new_api": "MarkNeeded",
          "old_text": "needed_allocations.insert(this)",
          "new_text": "MarkNeeded(needed_allocations)",
          "old_line_content": "  needed_allocations.insert(this);",
          "new_line_content": "    MarkNeeded(needed_allocations);",
          "content_same": false
        },
        {
          "line": 3930,
          "old_api": "VLOG",
          "new_api": "MarkIfNeeded",
          "old_text": "VLOG(3)",
          "new_text": "allocation->MarkIfNeeded(needed_allocations)",
          "old_line_content": "      VLOG(3) << \"Allocation not needed.\";",
          "new_line_content": "    allocation->MarkIfNeeded(needed_allocations);",
          "content_same": false
        },
        {
          "line": 3936,
          "old_api": "is_scoped_allocation",
          "new_api": "VLOG",
          "old_text": "allocation->is_scoped_allocation()",
          "new_text": "VLOG(3)",
          "old_line_content": "    if (allocation->is_scoped_allocation()) {",
          "new_line_content": "      VLOG(3) << \"Allocation not needed.\";",
          "content_same": false
        },
        {
          "line": 3939,
          "old_api": "chunk",
          "new_api": "Process",
          "old_text": "allocation->chunk()",
          "new_text": "allocation->Process()",
          "old_line_content": "          allocation->defining_position().instruction, allocation->chunk());",
          "new_line_content": "    TF_RETURN_IF_ERROR(allocation->Process());",
          "content_same": false
        },
        {
          "line": 3942,
          "old_api": "memory_space",
          "new_api": "is_scoped_allocation",
          "old_text": "allocation->memory_space()",
          "new_text": "allocation->is_scoped_allocation()",
          "old_line_content": "    } else if (allocation->memory_space() == MemorySpace::kAlternate) {",
          "new_line_content": "    if (allocation->is_scoped_allocation()) {",
          "content_same": false
        },
        {
          "line": 3943,
          "old_api": "emplace_back",
          "new_api": "memory_space",
          "old_text": "alternate_memory_assignments_.emplace_back(\n          allocation->defining_position(), allocation->chunk())",
          "new_text": "allocation->memory_space()",
          "old_line_content": "      alternate_memory_assignments_.emplace_back(",
          "new_line_content": "      CHECK(allocation->memory_space() == MemorySpace::kAlternate);",
          "content_same": false
        },
        {
          "line": 3944,
          "old_api": "chunk",
          "new_api": "emplace_back",
          "old_text": "allocation->chunk()",
          "new_text": "scoped_memory_assignments_.emplace_back(\n          allocation->defining_position().instruction, allocation->chunk())",
          "old_line_content": "          allocation->defining_position(), allocation->chunk());",
          "new_line_content": "      scoped_memory_assignments_.emplace_back(",
          "content_same": false
        },
        {
          "line": 3948,
          "old_api": "has_value",
          "new_api": "memory_space",
          "old_text": "allocation->cross_program_prefetch_index().has_value()",
          "new_text": "allocation->memory_space()",
          "old_line_content": "      if (allocation->cross_program_prefetch_index().has_value()) {",
          "new_line_content": "    } else if (allocation->memory_space() == MemorySpace::kAlternate) {",
          "content_same": false
        },
        {
          "line": 3949,
          "old_api": "SetCrossProgramPrefetchOffset",
          "new_api": "emplace_back",
          "old_text": "module_->SetCrossProgramPrefetchOffset(\n            *allocation->cross_program_prefetch_index(),\n            allocation->chunk().offset)",
          "new_text": "alternate_memory_assignments_.emplace_back(\n          allocation->defining_position(), allocation->chunk())",
          "old_line_content": "        TF_RETURN_IF_ERROR(module_->SetCrossProgramPrefetchOffset(",
          "new_line_content": "      alternate_memory_assignments_.emplace_back(",
          "content_same": false
        },
        {
          "line": 3950,
          "old_api": "cross_program_prefetch_index",
          "new_api": "chunk",
          "old_text": "allocation->cross_program_prefetch_index()",
          "new_text": "allocation->chunk()",
          "old_line_content": "            *allocation->cross_program_prefetch_index(),",
          "new_line_content": "          allocation->defining_position(), allocation->chunk());",
          "content_same": false
        },
        {
          "line": 3978,
          "old_api": "id",
          "new_api": "VLOG",
          "old_text": "buffer.id()",
          "new_text": "VLOG(3)",
          "old_line_content": "    auto seen_buffer_offset_it = seen_buffer_offsets.find(buffer.id());",
          "new_line_content": "  VLOG(3) << \"Exported alternate memory allocations:\";",
          "content_same": false
        },
        {
          "line": 3982,
          "old_api": "ToString",
          "new_api": "GetUniqueBufferAt",
          "old_text": "defining_position.ToString()",
          "new_text": "alias_analysis->GetUniqueBufferAt(\n        defining_position.instruction, defining_position.index)",
          "old_line_content": "          << buffer.ToString() << \", pos: \" << defining_position.ToString();",
          "new_line_content": "    const HloBuffer& buffer = alias_analysis->GetUniqueBufferAt(",
          "content_same": false
        },
        {
          "line": 3984,
          "old_api": "VLOG",
          "new_api": "id",
          "old_text": "VLOG(3)",
          "new_text": "buffer.id()",
          "old_line_content": "      VLOG(3) << \" [\" << chunk.offset << \", \" << chunk.size",
          "new_line_content": "    auto seen_buffer_offset_it = seen_buffer_offsets.find(buffer.id());",
          "content_same": false
        },
        {
          "line": 3985,
          "old_api": "ToString",
          "new_api": "end",
          "old_text": "defining_position.ToString()",
          "new_text": "seen_buffer_offsets.end()",
          "old_line_content": "              << \"] : \" << defining_position.ToString() << \" (\"",
          "new_line_content": "    if (seen_buffer_offset_it != seen_buffer_offsets.end()) {",
          "content_same": false
        },
        {
          "line": 3986,
          "old_api": "ToString",
          "new_api": "CHECK_EQ",
          "old_text": "buffer.ToString()",
          "new_text": "CHECK_EQ(chunk.offset, seen_buffer_offset_it->second)",
          "old_line_content": "              << buffer.ToString() << \")\";",
          "new_line_content": "      CHECK_EQ(chunk.offset, seen_buffer_offset_it->second)",
          "content_same": false
        },
        {
          "line": 3988,
          "old_api": "id",
          "new_api": "ToString",
          "old_text": "buffer.id()",
          "new_text": "defining_position.ToString()",
          "old_line_content": "      seen_buffer_offsets[buffer.id()] = chunk.offset;",
          "new_line_content": "          << buffer.ToString() << \", pos: \" << defining_position.ToString();",
          "content_same": false
        },
        {
          "line": 3992,
          "old_api": "VLOG",
          "new_api": "ToString",
          "old_text": "VLOG(3)",
          "new_text": "buffer.ToString()",
          "old_line_content": "  VLOG(3) << \"Exported scoped allocations in alternate memory:\";",
          "new_line_content": "              << buffer.ToString() << \")\";",
          "content_same": false
        },
        {
          "line": 3998,
          "old_api": "add_scoped_allocation_chunk",
          "new_api": "VLOG",
          "old_text": "preset_assignments_->add_scoped_allocation_chunk(instruction, chunk)",
          "new_text": "VLOG(3)",
          "old_line_content": "    preset_assignments_->add_scoped_allocation_chunk(instruction, chunk);",
          "new_line_content": "  VLOG(3) << \"Exported scoped allocations in alternate memory:\";",
          "content_same": false
        },
        {
          "line": 4002,
          "old_api": "empty",
          "new_api": "VLOG",
          "old_text": "preset_assignments_->scoped_allocation_chunks().empty()",
          "new_text": "VLOG(3)",
          "old_line_content": "      !preset_assignments_->scoped_allocation_chunks().empty()) {",
          "new_line_content": "    VLOG(3) << \" [\" << chunk.offset << \", \" << chunk.size",
          "content_same": false
        },
        {
          "line": 4003,
          "old_api": "assignment_information_for_space",
          "new_api": "name",
          "old_text": "preset_assignments_\n        ->assignment_information_for_space(options_.alternate_memory_space)",
          "new_text": "instruction->name()",
          "old_line_content": "    preset_assignments_",
          "new_line_content": "            << \"] : \" << instruction->name();",
          "content_same": false
        },
        {
          "line": 4008,
          "old_api": "VLOG",
          "new_api": "empty",
          "old_text": "VLOG(3)",
          "new_text": "preset_assignments_->scoped_allocation_chunks().empty()",
          "old_line_content": "  VLOG(3) << \"Exported alternate memory sizes:\";",
          "new_line_content": "      !preset_assignments_->scoped_allocation_chunks().empty()) {",
          "content_same": false
        },
        {
          "line": 4009,
          "old_api": "assignment_informations",
          "new_api": "assignment_information_for_space",
          "old_text": "preset_assignments_->assignment_informations()",
          "new_text": "preset_assignments_\n        ->assignment_information_for_space(options_.alternate_memory_space)",
          "old_line_content": "  for (auto& pair : preset_assignments_->assignment_informations()) {",
          "new_line_content": "    preset_assignments_",
          "content_same": false
        },
        {
          "line": 4016,
          "old_api": "chunks",
          "new_api": "VLOG",
          "old_text": "preset_assignments_->chunks()",
          "new_text": "VLOG(3)",
          "old_line_content": "       preset_assignments_->chunks()) {",
          "new_line_content": "    VLOG(3) << \"  space: \" << pair.first << \", size: \" << pair.second.size;",
          "content_same": false
        },
        {
          "line": 4022,
          "old_api": "ToString",
          "new_api": "chunks",
          "old_text": "position.ToString()",
          "new_text": "preset_assignments_->chunks()",
          "old_line_content": "          VLOG(4) << \"Coloring \" << position.ToString();",
          "new_line_content": "       preset_assignments_->chunks()) {",
          "content_same": false
        },
        {
          "line": 4024,
          "old_api": "mutable_shape",
          "new_api": "ComputeBuffersAt",
          "old_text": "position.instruction->mutable_shape()",
          "new_text": "alias_analysis->ComputeBuffersAt(\n             defining_position.instruction, defining_position.index)",
          "old_line_content": "              position.instruction->mutable_shape(), position.index);",
          "new_line_content": "    for (auto& buffer : alias_analysis->ComputeBuffersAt(",
          "content_same": false
        },
        {
          "line": 4026,
          "old_api": "ToString",
          "new_api": "values",
          "old_text": "position.ToString()",
          "new_text": "buffer->values()",
          "old_line_content": "                                  << position.ToString();",
          "new_line_content": "      for (auto& value : buffer->values()) {",
          "content_same": false
        },
        {
          "line": 4027,
          "old_api": "mutable_layout",
          "new_api": "positions",
          "old_text": "shape->mutable_layout()->set_memory_space(\n              options_.alternate_memory_space)",
          "new_text": "value->positions()",
          "old_line_content": "          shape->mutable_layout()->set_memory_space(",
          "new_line_content": "        for (auto& position : value->positions()) {",
          "content_same": false
        },
        {
          "line": 4033,
          "old_api": "OkStatus",
          "new_api": "mutable_layout",
          "old_text": "OkStatus()",
          "new_text": "shape->mutable_layout()->set_memory_space(\n              options_.alternate_memory_space)",
          "old_line_content": "  return OkStatus();",
          "new_line_content": "          shape->mutable_layout()->set_memory_space(",
          "content_same": false
        },
        {
          "line": 4039,
          "old_api": "end",
          "new_api": "OkStatus",
          "old_text": "alternate_memory_assignments_.end()",
          "new_text": "OkStatus()",
          "old_line_content": "  auto end = alternate_memory_assignments_.end();",
          "new_line_content": "  return OkStatus();",
          "content_same": false
        },
        {
          "line": 4044,
          "old_api": "std::next(it)",
          "new_api": "begin",
          "old_text": "std::next(it)",
          "new_text": "alternate_memory_assignments_.begin()",
          "old_line_content": "      if (std::next(it) == end) {",
          "new_line_content": "  auto it = alternate_memory_assignments_.begin();",
          "content_same": false
        },
        {
          "line": 4045,
          "old_api": "pop_back",
          "new_api": "end",
          "old_text": "alternate_memory_assignments_.pop_back()",
          "new_text": "alternate_memory_assignments_.end()",
          "old_line_content": "        alternate_memory_assignments_.pop_back();",
          "new_line_content": "  auto end = alternate_memory_assignments_.end();",
          "content_same": false
        },
        {
          "line": 4049,
          "old_api": "back",
          "new_api": "VLOG",
          "old_text": "alternate_memory_assignments_.back()",
          "new_text": "VLOG(3)",
          "old_line_content": "        *it = alternate_memory_assignments_.back();",
          "new_line_content": "      VLOG(3) << \"Removing instruction from alternate memory assignments.\";",
          "content_same": false
        },
        {
          "line": 4050,
          "old_api": "pop_back",
          "new_api": "std::next(it)",
          "old_text": "alternate_memory_assignments_.pop_back()",
          "new_text": "std::next(it)",
          "old_line_content": "        alternate_memory_assignments_.pop_back();",
          "new_line_content": "      if (std::next(it) == end) {",
          "content_same": false
        },
        {
          "line": 4051,
          "old_api": "end",
          "new_api": "pop_back",
          "old_text": "alternate_memory_assignments_.end()",
          "new_text": "alternate_memory_assignments_.pop_back()",
          "old_line_content": "        end = alternate_memory_assignments_.end();",
          "new_line_content": "        alternate_memory_assignments_.pop_back();",
          "content_same": false
        },
        {
          "line": 4092,
          "old_api": "opcode",
          "new_api": "name",
          "old_text": "instruction->opcode()",
          "new_text": "computation->name()",
          "old_line_content": "            instruction->opcode() != HloOpcode::kCopyDone) {",
          "new_line_content": "      VLOG(4) << \"Running simplify graph loop over \" << computation->name();",
          "content_same": false
        },
        {
          "line": 4096,
          "old_api": "RemoveAssignmentForInstruction",
          "new_api": "HasSideEffect",
          "old_text": "RemoveAssignmentForInstruction(instruction)",
          "new_text": "instruction->HasSideEffect()",
          "old_line_content": "          RemoveAssignmentForInstruction(instruction);",
          "new_line_content": "            instruction->IsDead() && !instruction->HasSideEffect() &&",
          "content_same": false
        },
        {
          "line": 4102,
          "old_api": "absl::c_find(flattened_instructions_, instruction)",
          "new_api": "RemoveAssignmentForInstruction",
          "old_text": "absl::c_find(flattened_instructions_, instruction)",
          "new_text": "RemoveAssignmentForInstruction(instruction)",
          "old_line_content": "              absl::c_find(flattened_instructions_, instruction);",
          "new_line_content": "          RemoveAssignmentForInstruction(instruction);",
          "content_same": false
        },
        {
          "line": 4108,
          "old_api": "opcode",
          "new_api": "absl::c_find(flattened_instructions_, instruction)",
          "old_text": "instruction->opcode()",
          "new_text": "absl::c_find(flattened_instructions_, instruction)",
          "old_line_content": "        } else if (instruction->opcode() == HloOpcode::kGetTupleElement) {",
          "new_line_content": "              absl::c_find(flattened_instructions_, instruction);",
          "content_same": false
        },
        {
          "line": 4109,
          "old_api": "mutable_operand",
          "new_api": "end",
          "old_text": "instruction->mutable_operand(0)",
          "new_text": "flattened_instructions_.end()",
          "old_line_content": "          HloInstruction* operand = instruction->mutable_operand(0);",
          "new_line_content": "          if (instruction_it != flattened_instructions_.end()) {",
          "content_same": false
        },
        {
          "line": 4112,
          "old_api": "tuple_index",
          "new_api": "RemoveInstruction",
          "old_text": "instruction->tuple_index()",
          "new_text": "computation->RemoveInstruction(instruction)",
          "old_line_content": "                operand->mutable_operand(instruction->tuple_index());",
          "new_line_content": "          TF_RETURN_IF_ERROR(computation->RemoveInstruction(instruction));",
          "content_same": false
        },
        {
          "line": 4114,
          "old_api": "ToString",
          "new_api": "opcode",
          "old_text": "forwarded_instruction->ToString()",
          "new_text": "instruction->opcode()",
          "old_line_content": "                    << \" with \" << forwarded_instruction->ToString();",
          "new_line_content": "        } else if (instruction->opcode() == HloOpcode::kGetTupleElement) {",
          "content_same": false
        },
        {
          "line": 4115,
          "old_api": "ReplaceAllUsesWith",
          "new_api": "mutable_operand",
          "old_text": "TF_RETURN_IF_ERROR(\n                instruction->ReplaceAllUsesWith(forwarded_instruction))",
          "new_text": "instruction->mutable_operand(0)",
          "old_line_content": "            TF_RETURN_IF_ERROR(",
          "new_line_content": "          HloInstruction* operand = instruction->mutable_operand(0);",
          "content_same": false
        },
        {
          "line": 4116,
          "old_api": "ReplaceAllUsesWith",
          "new_api": "opcode",
          "old_text": "instruction->ReplaceAllUsesWith(forwarded_instruction)",
          "new_text": "operand->opcode()",
          "old_line_content": "                instruction->ReplaceAllUsesWith(forwarded_instruction));",
          "new_line_content": "          if (operand->opcode() == HloOpcode::kTuple) {",
          "content_same": false
        },
        {
          "line": 4119,
          "old_api": "opcode",
          "new_api": "ToString",
          "old_text": "instruction->opcode()",
          "new_text": "instruction->ToString()",
          "old_line_content": "        } else if (instruction->opcode() == HloOpcode::kTuple) {",
          "new_line_content": "            VLOG(4) << \"Replacing uses of \" << instruction->ToString()",
          "content_same": false
        },
        {
          "line": 4135,
          "old_api": "opcode",
          "new_api": "operand_count",
          "old_text": "operand->opcode()",
          "new_text": "instruction->operand_count()",
          "old_line_content": "            if (operand->opcode() != HloOpcode::kGetTupleElement ||",
          "new_line_content": "                      .tuple_shapes_size() == instruction->operand_count();",
          "content_same": false
        },
        {
          "line": 4137,
          "old_api": "operand",
          "new_api": "operand_count",
          "old_text": "instruction->operand(0)->operand(0)",
          "new_text": "instruction->operand_count()",
          "old_line_content": "                operand->operand(0) != instruction->operand(0)->operand(0)) {",
          "new_line_content": "               operand_number < instruction->operand_count();",
          "content_same": false
        },
        {
          "line": 4166,
          "old_api": "get",
          "new_api": "VLOG",
          "old_text": "allocation.get()",
          "new_text": "VLOG(1)",
          "old_line_content": "        auto copy_allocation = static_cast<CopyAllocation*>(allocation.get());",
          "new_line_content": "  VLOG(1) << \"Scheduling asynchronous copies...\";",
          "content_same": false
        },
        {
          "line": 4173,
          "old_api": "copy_done_schedule_before",
          "new_api": "memory_space",
          "old_text": "absl::c_stable_sort(\n        copy_allocations, [](CopyAllocation* first, CopyAllocation* second) {\n          return std::forward_as_tuple(first->copy_done_schedule_before(),\n                                       first->copy_start_schedule_after()) <\n                 std::forward_as_tuple(second->copy_done_schedule_before(),\n                                       second->copy_start_schedule_after());\n        })",
          "new_text": "copy_allocation->memory_space()",
          "old_line_content": "    absl::c_stable_sort(",
          "new_line_content": "        if (copy_allocation->memory_space() == memory_space) {",
          "content_same": false
        },
        {
          "line": 4193,
          "old_api": "set_copy_start_schedule_after",
          "new_api": "defining_position",
          "old_text": "copy_allocation->set_copy_start_schedule_after(\n            ++copy_start_schedule_after)",
          "new_text": "copy_allocation->defining_position().instruction->parent()",
          "old_line_content": "        copy_allocation->set_copy_start_schedule_after(",
          "new_line_content": "      while (copy_allocation->defining_position().instruction->parent() !=",
          "content_same": false
        },
        {
          "line": 4197,
          "old_api": "copy_start_schedule_after",
          "new_api": "copy_start",
          "old_text": "copy_allocation->copy_start_schedule_after()",
          "new_text": "copy_allocation->copy_start()->ToString()",
          "old_line_content": "      schedule_after_[copy_allocation->copy_start_schedule_after()].push_back(",
          "new_line_content": "                << copy_allocation->copy_start()->ToString()",
          "content_same": false
        },
        {
          "line": 4199,
          "old_api": "copy_done_schedule_before",
          "new_api": "set_copy_start_schedule_after",
          "old_text": "copy_allocation->copy_done_schedule_before()",
          "new_text": "copy_allocation->set_copy_start_schedule_after(\n            ++copy_start_schedule_after)",
          "old_line_content": "      schedule_before_[copy_allocation->copy_done_schedule_before()].push_back(",
          "new_line_content": "        copy_allocation->set_copy_start_schedule_after(",
          "content_same": false
        },
        {
          "line": 4206,
          "old_api": "VLOG",
          "new_api": "copy_done",
          "old_text": "VLOG(1)",
          "new_text": "copy_allocation->copy_done()",
          "old_line_content": "  VLOG(1) << \"Fixing schedule...\";",
          "new_line_content": "          copy_allocation->copy_done());",
          "content_same": false
        },
        {
          "line": 4213,
          "old_api": "contains",
          "new_api": "has_schedule",
          "old_text": "computations_in_schedule_.contains(computation)",
          "new_text": "module_->has_schedule()",
          "old_line_content": "    if (!computations_in_schedule_.contains(computation)) {",
          "new_line_content": "  TF_RET_CHECK(module_->has_schedule());",
          "content_same": false
        },
        {
          "line": 4214,
          "old_api": "name",
          "new_api": "schedule",
          "old_text": "computation->name()",
          "new_text": "module_->schedule()",
          "old_line_content": "      VLOG(4) << \"Not scheduling \" << computation->name()",
          "new_line_content": "  HloSchedule& schedule = module_->schedule();",
          "content_same": false
        },
        {
          "line": 4229,
          "old_api": "parent",
          "new_api": "ToString",
          "old_text": "new_instruction->parent()",
          "new_text": "computation->ToString()",
          "old_line_content": "          if (new_instruction->parent() == computation) {",
          "new_line_content": "    VLOG(4) << \"Scheduling: \" << computation->ToString();",
          "content_same": false
        },
        {
          "line": 4232,
          "old_api": "InsertInstructionAndEnsureOperandsInserted",
          "new_api": "find",
          "old_text": "InsertInstructionAndEnsureOperandsInserted(\n                new_instruction, &new_sequence, &inserted_instructions)",
          "new_text": "schedule_before_.find(instruction_index)",
          "old_line_content": "            TF_RETURN_IF_ERROR(InsertInstructionAndEnsureOperandsInserted(",
          "new_line_content": "      auto insts_before_iter = schedule_before_.find(instruction_index);",
          "content_same": false
        },
        {
          "line": 4256,
          "old_api": "find",
          "new_api": "opcode",
          "old_text": "schedule_after_.find(instruction_index)",
          "new_text": "instruction->opcode()",
          "old_line_content": "      auto insts_after_iter = schedule_after_.find(instruction_index);",
          "new_line_content": "          instruction->opcode() != HloOpcode::kTuple &&",
          "content_same": false
        },
        {
          "line": 4257,
          "old_api": "end",
          "new_api": "contains",
          "old_text": "schedule_after_.end()",
          "new_text": "inserted_instructions.contains(instruction)",
          "old_line_content": "      if (insts_after_iter != schedule_after_.end()) {",
          "new_line_content": "          !inserted_instructions.contains(instruction)) {",
          "content_same": false
        },
        {
          "line": 4259,
          "old_api": "parent",
          "new_api": "InsertInstructionAndEnsureOperandsInserted",
          "old_text": "new_instruction->parent()",
          "new_text": "InsertInstructionAndEnsureOperandsInserted(\n            instruction, &new_sequence, &inserted_instructions)",
          "old_line_content": "          if (new_instruction->parent() == computation) {",
          "new_line_content": "        TF_RETURN_IF_ERROR(InsertInstructionAndEnsureOperandsInserted(",
          "content_same": false
        },
        {
          "line": 4262,
          "old_api": "InsertInstructionAndEnsureOperandsInserted",
          "new_api": "find",
          "old_text": "InsertInstructionAndEnsureOperandsInserted(\n                new_instruction, &new_sequence, &inserted_instructions)",
          "new_text": "schedule_after_.find(instruction_index)",
          "old_line_content": "            TF_RETURN_IF_ERROR(InsertInstructionAndEnsureOperandsInserted(",
          "new_line_content": "      auto insts_after_iter = schedule_after_.find(instruction_index);",
          "content_same": false
        },
        {
          "line": 4276,
          "old_api": "instruction_count",
          "new_api": "root_instruction",
          "old_text": "computation->instruction_count()",
          "new_text": "EnsureInstructionAndOperandsInserted(\n        computation->root_instruction(), &new_sequence,\n        &inserted_instructions)",
          "old_line_content": "        << computation->instruction_count() << \".\";",
          "new_line_content": "    TF_RETURN_IF_ERROR(EnsureInstructionAndOperandsInserted(",
          "content_same": false
        },
        {
          "line": 4277,
          "old_api": "set_sequence",
          "new_api": "root_instruction",
          "old_text": "schedule.set_sequence(computation, new_sequence)",
          "new_text": "computation->root_instruction()",
          "old_line_content": "    schedule.set_sequence(computation, new_sequence);",
          "new_line_content": "        computation->root_instruction(), &new_sequence,",
          "content_same": false
        },
        {
          "line": 4280,
          "old_api": "OkStatus",
          "new_api": "name",
          "old_text": "OkStatus()",
          "new_text": "computation->name()",
          "old_line_content": "  return OkStatus();",
          "new_line_content": "        << \"New sequence for computation \" << computation->name() << \" has \"",
          "content_same": false
        },
        {
          "line": 4286,
          "old_api": "HloAliasAnalysis::Run(module_)",
          "new_api": "OkStatus",
          "old_text": "HloAliasAnalysis::Run(module_)",
          "new_text": "OkStatus()",
          "old_line_content": "                      HloAliasAnalysis::Run(module_));",
          "new_line_content": "  return OkStatus();",
          "content_same": false
        },
        {
          "line": 4331,
          "old_api": "MakeNonfusionComputations",
          "new_api": "OkStatus",
          "old_text": "module_->MakeNonfusionComputations()",
          "new_text": "OkStatus()",
          "old_line_content": "       module_->MakeNonfusionComputations()) {",
          "new_line_content": "    return OkStatus();",
          "content_same": false
        },
        {
          "line": 4339,
          "old_api": "shape",
          "new_api": "opcode",
          "old_text": "instruction->shape()",
          "new_text": "instruction->opcode()",
          "old_line_content": "            ShapeUtil::GetSubshape(instruction->shape(), {0})",
          "new_line_content": "      if (instruction->opcode() == HloOpcode::kCopyStart) {",
          "content_same": false
        },
        {
          "line": 4360,
          "old_api": "values",
          "new_api": "id",
          "old_text": "buffer.values()",
          "new_text": "buffer.id()",
          "old_line_content": "    for (const HloValue* value : buffer.values()) {",
          "new_line_content": "    CHECK(!seen_buffers.contains(buffer.id()))",
          "content_same": false
        },
        {
          "line": 4362,
          "old_api": "at",
          "new_api": "ToString",
          "old_text": "hlo_live_range->buffer_live_ranges().at(value)",
          "new_text": "position.ToString()",
          "old_line_content": "          hlo_live_range->buffer_live_ranges().at(value);",
          "new_line_content": "        << buffer.ToString() << \", pos: \" << position.ToString()",
          "content_same": false
        },
        {
          "line": 4390,
          "old_api": "called_computations",
          "new_api": "ToString",
          "old_text": "use_instruction->called_computations()",
          "new_text": "buffer.ToString()",
          "old_line_content": "             use_instruction->called_computations()) {",
          "new_line_content": "                << \"Splitting conditional buffer: \" << buffer.ToString()",
          "content_same": false
        },
        {
          "line": 4396,
          "old_api": "std::min(earliest_computation_start_time, computation_start_time)",
          "new_api": "called_computations",
          "old_text": "std::min(earliest_computation_start_time, computation_start_time)",
          "new_text": "use_instruction->called_computations()",
          "old_line_content": "              std::min(earliest_computation_start_time, computation_start_time);",
          "new_line_content": "             use_instruction->called_computations()) {",
          "content_same": false
        },
        {
          "line": 4402,
          "old_api": "parent",
          "new_api": "std::min(earliest_computation_start_time, computation_start_time)",
          "old_text": "use.instruction->parent()",
          "new_text": "std::min(earliest_computation_start_time, computation_start_time)",
          "old_line_content": "            if (use.instruction->parent() == called_computation &&",
          "new_line_content": "              std::min(earliest_computation_start_time, computation_start_time);",
          "content_same": false
        },
        {
          "line": 4416,
          "old_api": "split_conditional_buffer",
          "new_api": "name",
          "old_text": "split_conditional_buffer(\n                  last_use_instruction, computation_start_time, last_use_time,\n                  absl::StrCat(indent_string, \"  \"))",
          "new_text": "called_computation->name()",
          "old_line_content": "              TF_RETURN_IF_ERROR(split_conditional_buffer(",
          "new_line_content": "                    << \" computation: \" << called_computation->name() << \": (\"",
          "content_same": false
        },
        {
          "line": 4418,
          "old_api": "absl::StrCat(indent_string, \"  \")",
          "new_api": "CHECK",
          "old_text": "absl::StrCat(indent_string, \"  \")",
          "new_text": "CHECK(last_use_instruction)",
          "old_line_content": "                  absl::StrCat(indent_string, \"  \")));",
          "new_line_content": "            CHECK(last_use_instruction);",
          "content_same": false
        },
        {
          "line": 4426,
          "old_api": "VLOG",
          "new_api": "std::min(last_use_time, end_time)",
          "old_text": "VLOG(3)",
          "new_text": "std::min(last_use_time, end_time)",
          "old_line_content": "        VLOG(3) << indent_string << \" from beginning until first computation: (\"",
          "new_line_content": "              last_use_time = std::min(last_use_time, end_time);",
          "content_same": false
        },
        {
          "line": 4435,
          "old_api": "opcode",
          "new_api": "add_allocation_and_verify",
          "old_text": "last_use_instruction->opcode()",
          "new_text": "add_allocation_and_verify(\n            start_time, earliest_computation_start_time - 1, chunk, value)",
          "old_line_content": "          last_use_instruction->opcode() == HloOpcode::kConditional) {",
          "new_line_content": "        TF_RETURN_IF_ERROR(add_allocation_and_verify(",
          "content_same": false
        },
        {
          "line": 4441,
          "old_api": "ToShortString",
          "new_api": "opcode",
          "old_text": "value->ToShortString()",
          "new_text": "last_use_instruction->opcode()",
          "old_line_content": "                << \" value: \" << value->ToShortString() << \": (\"",
          "new_line_content": "          last_use_instruction->opcode() == HloOpcode::kConditional) {",
          "content_same": false
        },
        {
          "line": 4444,
          "old_api": "add_allocation_and_verify",
          "new_api": "empty",
          "old_text": "add_allocation_and_verify(\n            time_bound.start, last_use_time, chunk, value)",
          "new_text": "value->GetUses().empty()",
          "old_line_content": "        TF_RETURN_IF_ERROR(add_allocation_and_verify(",
          "new_line_content": "      } else if (!value->GetUses().empty()) {",
          "content_same": false
        },
        {
          "line": 4466,
          "old_api": "set_kind",
          "new_api": "std::tie(time, is_free, buffer_id)",
          "old_text": "heap_trace_event->set_kind(kind)",
          "new_text": "std::tie(time, is_free, buffer_id)",
          "old_line_content": "    heap_trace_event->set_kind(kind);",
          "new_line_content": "    std::tie(time, is_free, buffer_id) = event.first;",
          "content_same": false
        },
        {
          "line": 4470,
          "old_api": "instruction",
          "new_api": "std::tie(value, chunk, kind)",
          "old_text": "value->instruction()->parent()->name()",
          "new_text": "std::tie(value, chunk, kind)",
          "old_line_content": "        value->instruction()->parent()->name());",
          "new_line_content": "    std::tie(value, chunk, kind) = event.second;",
          "content_same": false
        },
        {
          "line": 4475,
          "old_api": "CHECK_EQ",
          "new_api": "set_computation_name",
          "old_text": "CHECK_EQ(kind, HeapSimulatorTrace::Event::FREE)",
          "new_text": "heap_trace_event->set_computation_name(\n        value->instruction()->parent()->name())",
          "old_line_content": "      CHECK_EQ(kind, HeapSimulatorTrace::Event::FREE);",
          "new_line_content": "    heap_trace_event->set_computation_name(",
          "content_same": false
        },
        {
          "line": 4481,
          "old_api": "VLOG",
          "new_api": "CHECK_EQ",
          "old_text": "VLOG(1)",
          "new_text": "CHECK_EQ(kind, HeapSimulatorTrace::Event::FREE)",
          "old_line_content": "  VLOG(1) << \"Max memory usage ignoring fragmentation: \" << max_memory_usage;",
          "new_line_content": "      CHECK_EQ(kind, HeapSimulatorTrace::Event::FREE);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 4097,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "          // Instead of deleting the instruction from the schedule, replace it",
          "new_line_content": "            instruction->opcode() != HloOpcode::kCopyStart &&",
          "content_same": false
        },
        {
          "line": 4098,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "          // with a nullptr. This is needed because FixSchedule relies on the",
          "new_line_content": "            instruction->opcode() != HloOpcode::kCopyDone) {",
          "content_same": false
        },
        {
          "line": 4099,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "instruction->ToString()",
          "old_line_content": "          // logical time that is the index into flattened_instructions_ for",
          "new_line_content": "          VLOG(4) << \"Instruction removed: \" << instruction->ToString();",
          "content_same": false
        },
        {
          "line": 4118,
          "old_api": null,
          "new_api": "tuple_index",
          "old_text": null,
          "new_text": "instruction->tuple_index()",
          "old_line_content": "          }",
          "new_line_content": "                operand->mutable_operand(instruction->tuple_index());",
          "content_same": false
        },
        {
          "line": 4120,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "forwarded_instruction->ToString()",
          "old_line_content": "          // Replace Tuple(GetTupleElement(x), ..., GetTupleElement(x)) pattern",
          "new_line_content": "                    << \" with \" << forwarded_instruction->ToString();",
          "content_same": false
        },
        {
          "line": 4121,
          "old_api": null,
          "new_api": "ReplaceAllUsesWith",
          "old_text": null,
          "new_text": "TF_RETURN_IF_ERROR(\n                instruction->ReplaceAllUsesWith(forwarded_instruction))",
          "old_line_content": "          // with x.",
          "new_line_content": "            TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 4122,
          "old_api": null,
          "new_api": "ReplaceAllUsesWith",
          "old_text": null,
          "new_text": "instruction->ReplaceAllUsesWith(forwarded_instruction)",
          "old_line_content": "          bool can_replace =",
          "new_line_content": "                instruction->ReplaceAllUsesWith(forwarded_instruction));",
          "content_same": false
        },
        {
          "line": 4125,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "                  HloOpcode::kGetTupleElement &&",
          "new_line_content": "        } else if (instruction->opcode() == HloOpcode::kTuple) {",
          "content_same": false
        },
        {
          "line": 4130,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "instruction->operand(0)->opcode()",
          "old_line_content": "          for (int operand_number = 0;",
          "new_line_content": "              instruction->operand(0)->opcode() ==",
          "content_same": false
        },
        {
          "line": 4132,
          "old_api": null,
          "new_api": "tuple_shapes_size",
          "old_text": null,
          "new_text": "instruction->operand(0)\n                      ->operand(0)\n                      ->shape()\n                      .tuple_shapes_size()",
          "old_line_content": "               ++operand_number) {",
          "new_line_content": "              instruction->operand(0)",
          "content_same": false
        },
        {
          "line": 4140,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "instruction->operand(operand_number)",
          "old_line_content": "            }",
          "new_line_content": "                instruction->operand(operand_number);",
          "content_same": false
        },
        {
          "line": 4141,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "operand->opcode()",
          "old_line_content": "          }",
          "new_line_content": "            if (operand->opcode() != HloOpcode::kGetTupleElement ||",
          "content_same": false
        },
        {
          "line": 4142,
          "old_api": null,
          "new_api": "tuple_index",
          "old_text": null,
          "new_text": "operand->tuple_index()",
          "old_line_content": "          if (can_replace) {",
          "new_line_content": "                operand->tuple_index() != operand_number ||",
          "content_same": false
        },
        {
          "line": 4143,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "instruction->operand(0)->operand(0)",
          "old_line_content": "            HloInstruction* forwarded_instruction =",
          "new_line_content": "                operand->operand(0) != instruction->operand(0)->operand(0)) {",
          "content_same": false
        },
        {
          "line": 4150,
          "old_api": null,
          "new_api": "mutable_operand",
          "old_text": null,
          "new_text": "instruction->mutable_operand(0)->mutable_operand(0)",
          "old_line_content": "          }",
          "new_line_content": "                instruction->mutable_operand(0)->mutable_operand(0);",
          "content_same": false
        },
        {
          "line": 4151,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "instruction->ToString()",
          "old_line_content": "        }",
          "new_line_content": "            VLOG(4) << \"Replacing uses of \" << instruction->ToString()",
          "content_same": false
        },
        {
          "line": 4152,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "forwarded_instruction->ToString()",
          "old_line_content": "      }",
          "new_line_content": "                    << \" with \" << forwarded_instruction->ToString();",
          "content_same": false
        },
        {
          "line": 4153,
          "old_api": null,
          "new_api": "ReplaceAllUsesWith",
          "old_text": null,
          "new_text": "TF_RETURN_IF_ERROR(\n                instruction->ReplaceAllUsesWith(forwarded_instruction))",
          "old_line_content": "    }",
          "new_line_content": "            TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 4154,
          "old_api": null,
          "new_api": "ReplaceAllUsesWith",
          "old_text": null,
          "new_text": "instruction->ReplaceAllUsesWith(forwarded_instruction)",
          "old_line_content": "  }",
          "new_line_content": "                instruction->ReplaceAllUsesWith(forwarded_instruction));",
          "content_same": false
        },
        {
          "line": 4162,
          "old_api": null,
          "new_api": "OkStatus",
          "old_text": null,
          "new_text": "OkStatus()",
          "old_line_content": "       {MemorySpace::kDefault, MemorySpace::kAlternate}) {",
          "new_line_content": "  return OkStatus();",
          "content_same": false
        },
        {
          "line": 4171,
          "old_api": null,
          "new_api": "is_copy_allocation",
          "old_text": null,
          "new_text": "allocation->is_copy_allocation()",
          "old_line_content": "    }",
          "new_line_content": "      if (allocation->is_copy_allocation()) {",
          "content_same": false
        },
        {
          "line": 4172,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "allocation.get()",
          "old_line_content": "",
          "new_line_content": "        auto copy_allocation = static_cast<CopyAllocation*>(allocation.get());",
          "content_same": false
        },
        {
          "line": 4174,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "copy_allocations.push_back(copy_allocation)",
          "old_line_content": "        copy_allocations, [](CopyAllocation* first, CopyAllocation* second) {",
          "new_line_content": "          copy_allocations.push_back(copy_allocation);",
          "content_same": false
        },
        {
          "line": 4179,
          "old_api": null,
          "new_api": "copy_done_schedule_before",
          "old_text": null,
          "new_text": "absl::c_stable_sort(\n        copy_allocations, [](CopyAllocation* first, CopyAllocation* second) {\n          return std::forward_as_tuple(first->copy_done_schedule_before(),\n                                       first->copy_start_schedule_after()) <\n                 std::forward_as_tuple(second->copy_done_schedule_before(),\n                                       second->copy_start_schedule_after());\n        })",
          "old_line_content": "        });",
          "new_line_content": "    absl::c_stable_sort(",
          "content_same": false
        },
        {
          "line": 4181,
          "old_api": null,
          "new_api": "copy_done_schedule_before",
          "old_text": null,
          "new_text": "first->copy_done_schedule_before()",
          "old_line_content": "      // If the copy start doesn't happen to be scheduled at the correct",
          "new_line_content": "          return std::forward_as_tuple(first->copy_done_schedule_before(),",
          "content_same": false
        },
        {
          "line": 4182,
          "old_api": null,
          "new_api": "copy_start_schedule_after",
          "old_text": null,
          "new_text": "first->copy_start_schedule_after()",
          "old_line_content": "      // computation, delay it until the correct computation starts.",
          "new_line_content": "                                       first->copy_start_schedule_after()) <",
          "content_same": false
        },
        {
          "line": 4183,
          "old_api": null,
          "new_api": "copy_done_schedule_before",
          "old_text": null,
          "new_text": "second->copy_done_schedule_before()",
          "old_line_content": "      int64_t copy_start_schedule_after =",
          "new_line_content": "                 std::forward_as_tuple(second->copy_done_schedule_before(),",
          "content_same": false
        },
        {
          "line": 4190,
          "old_api": null,
          "new_api": "copy_start_schedule_after",
          "old_text": null,
          "new_text": "copy_allocation->copy_start_schedule_after()",
          "old_line_content": "                << (copy_start_schedule_after + 1) << \") for \"",
          "new_line_content": "          copy_allocation->copy_start_schedule_after();",
          "content_same": false
        },
        {
          "line": 4194,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "flattened_instructions_[copy_start_schedule_after]->parent()",
          "old_line_content": "            ++copy_start_schedule_after);",
          "new_line_content": "             flattened_instructions_[copy_start_schedule_after]->parent()) {",
          "content_same": false
        },
        {
          "line": 4195,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "      }",
          "new_line_content": "        VLOG(4) << \"Delaying CopyStart (\" << copy_start_schedule_after << \" to \"",
          "content_same": false
        },
        {
          "line": 4203,
          "old_api": null,
          "new_api": "copy_start_schedule_after",
          "old_text": null,
          "new_text": "copy_allocation->copy_start_schedule_after()",
          "old_line_content": "}",
          "new_line_content": "      schedule_after_[copy_allocation->copy_start_schedule_after()].push_back(",
          "content_same": false
        },
        {
          "line": 4204,
          "old_api": null,
          "new_api": "copy_start",
          "old_text": null,
          "new_text": "copy_allocation->copy_start()",
          "old_line_content": "",
          "new_line_content": "          copy_allocation->copy_start());",
          "content_same": false
        },
        {
          "line": 4205,
          "old_api": null,
          "new_api": "copy_done_schedule_before",
          "old_text": null,
          "new_text": "copy_allocation->copy_done_schedule_before()",
          "old_line_content": "Status MemorySpaceAssignment::FixSchedule() {",
          "new_line_content": "      schedule_before_[copy_allocation->copy_done_schedule_before()].push_back(",
          "content_same": false
        },
        {
          "line": 4212,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "    // modified.",
          "new_line_content": "  VLOG(1) << \"Fixing schedule...\";",
          "content_same": false
        },
        {
          "line": 4216,
          "old_api": null,
          "new_api": "MakeNonfusionComputations",
          "old_text": null,
          "new_text": "module_->MakeNonfusionComputations()",
          "old_line_content": "      continue;",
          "new_line_content": "       module_->MakeNonfusionComputations()) {",
          "content_same": false
        },
        {
          "line": 4219,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "computations_in_schedule_.contains(computation)",
          "old_line_content": "    HloInstructionSequence new_sequence;",
          "new_line_content": "    if (!computations_in_schedule_.contains(computation)) {",
          "content_same": false
        },
        {
          "line": 4220,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "computation->name()",
          "old_line_content": "",
          "new_line_content": "      VLOG(4) << \"Not scheduling \" << computation->name()",
          "content_same": false
        },
        {
          "line": 4224,
          "old_api": null,
          "new_api": "is_computation_scheduled",
          "old_text": null,
          "new_text": "schedule.is_computation_scheduled(computation)",
          "old_line_content": "",
          "new_line_content": "    TF_RET_CHECK(schedule.is_computation_scheduled(computation));",
          "content_same": false
        },
        {
          "line": 4233,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "schedule_before_.end()",
          "old_line_content": "                new_instruction, &new_sequence, &inserted_instructions));",
          "new_line_content": "      if (insts_before_iter != schedule_before_.end()) {",
          "content_same": false
        },
        {
          "line": 4235,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "new_instruction->parent()",
          "old_line_content": "        }",
          "new_line_content": "          if (new_instruction->parent() == computation) {",
          "content_same": false
        },
        {
          "line": 4236,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "      }",
          "new_line_content": "            VLOG(4) << \"before \" << instruction_index << \": \"",
          "content_same": false
        },
        {
          "line": 4237,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "new_instruction->name()",
          "old_line_content": "      // We allow scheduling copy dones past the root instruction (for",
          "new_line_content": "                    << new_instruction->name();",
          "content_same": false
        },
        {
          "line": 4238,
          "old_api": null,
          "new_api": "InsertInstructionAndEnsureOperandsInserted",
          "old_text": null,
          "new_text": "InsertInstructionAndEnsureOperandsInserted(\n                new_instruction, &new_sequence, &inserted_instructions)",
          "old_line_content": "      // end-of-program cross-program prefetch). So the loop exit condition is",
          "new_line_content": "            TF_RETURN_IF_ERROR(InsertInstructionAndEnsureOperandsInserted(",
          "content_same": false
        },
        {
          "line": 4246,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "flattened_instructions_.size()",
          "old_line_content": "      // are treated specially and only inserted as a result of operand",
          "new_line_content": "      if (instruction_index >= flattened_instructions_.size()) {",
          "content_same": false
        },
        {
          "line": 4254,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "instruction->parent()",
          "old_line_content": "            instruction, &new_sequence, &inserted_instructions));",
          "new_line_content": "      if (instruction != nullptr && instruction->parent() == computation &&",
          "content_same": false
        },
        {
          "line": 4255,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "      }",
          "new_line_content": "          instruction->opcode() != HloOpcode::kBitcast &&",
          "content_same": false
        },
        {
          "line": 4258,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "instruction->name()",
          "old_line_content": "        for (HloInstruction* new_instruction : insts_after_iter->second) {",
          "new_line_content": "        VLOG(4) << \"inst \" << instruction_index << \": \" << instruction->name();",
          "content_same": false
        },
        {
          "line": 4263,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "schedule_after_.end()",
          "old_line_content": "                new_instruction, &new_sequence, &inserted_instructions));",
          "new_line_content": "      if (insts_after_iter != schedule_after_.end()) {",
          "content_same": false
        },
        {
          "line": 4265,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "new_instruction->parent()",
          "old_line_content": "        }",
          "new_line_content": "          if (new_instruction->parent() == computation) {",
          "content_same": false
        },
        {
          "line": 4266,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "      }",
          "new_line_content": "            VLOG(4) << \"after \" << instruction_index << \": \"",
          "content_same": false
        },
        {
          "line": 4267,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "new_instruction->name()",
          "old_line_content": "    }",
          "new_line_content": "                    << new_instruction->name();",
          "content_same": false
        },
        {
          "line": 4268,
          "old_api": null,
          "new_api": "InsertInstructionAndEnsureOperandsInserted",
          "old_text": null,
          "new_text": "InsertInstructionAndEnsureOperandsInserted(\n                new_instruction, &new_sequence, &inserted_instructions)",
          "old_line_content": "    // For rare cases where the original sequence is empty, ensure the root",
          "new_line_content": "            TF_RETURN_IF_ERROR(InsertInstructionAndEnsureOperandsInserted(",
          "content_same": false
        },
        {
          "line": 4279,
          "old_api": null,
          "new_api": "instruction_count",
          "old_text": null,
          "new_text": "computation->instruction_count()",
          "old_line_content": "",
          "new_line_content": "    CHECK_EQ(new_sequence.size(), computation->instruction_count())",
          "content_same": false
        },
        {
          "line": 4281,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "new_sequence.size()",
          "old_line_content": "}",
          "new_line_content": "        << new_sequence.size() << \" instructions, expects \"",
          "content_same": false
        },
        {
          "line": 4282,
          "old_api": null,
          "new_api": "instruction_count",
          "old_text": null,
          "new_text": "computation->instruction_count()",
          "old_line_content": "",
          "new_line_content": "        << computation->instruction_count() << \".\";",
          "content_same": false
        },
        {
          "line": 4283,
          "old_api": null,
          "new_api": "set_sequence",
          "old_text": null,
          "new_text": "schedule.set_sequence(computation, new_sequence)",
          "old_line_content": "Status MemorySpaceAssignment::VerifyAndExportHeapSimulatorTrace() {",
          "new_line_content": "    schedule.set_sequence(computation, new_sequence);",
          "content_same": false
        },
        {
          "line": 4290,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "",
          "new_line_content": "  VLOG(1) << \"Verifying...\";",
          "content_same": false
        },
        {
          "line": 4291,
          "old_api": null,
          "new_api": "TF_ASSIGN_OR_RETURN",
          "old_text": null,
          "new_text": "TF_ASSIGN_OR_RETURN(std::unique_ptr<HloAliasAnalysis> alias_analysis,\n                      HloAliasAnalysis::Run(module_))",
          "old_line_content": "  BufferIntervalTree interval_tree;",
          "new_line_content": "  TF_ASSIGN_OR_RETURN(std::unique_ptr<HloAliasAnalysis> alias_analysis,",
          "content_same": false
        },
        {
          "line": 4292,
          "old_api": null,
          "new_api": "HloAliasAnalysis::Run(module_)",
          "old_text": null,
          "new_text": "HloAliasAnalysis::Run(module_)",
          "old_line_content": "  absl::flat_hash_set<int64_t> seen_buffers;",
          "new_line_content": "                      HloAliasAnalysis::Run(module_));",
          "content_same": false
        },
        {
          "line": 4293,
          "old_api": null,
          "new_api": "schedule",
          "old_text": null,
          "new_text": "TF_ASSIGN_OR_RETURN(std::unique_ptr<HloLiveRange> hlo_live_range,\n                      HloLiveRange::Run(module_->schedule(), *alias_analysis,\n                                        module_->entry_computation()))",
          "old_line_content": "  // The key for events is: time, is_free, value_id. This is so that the events",
          "new_line_content": "  TF_ASSIGN_OR_RETURN(std::unique_ptr<HloLiveRange> hlo_live_range,",
          "content_same": false
        },
        {
          "line": 4294,
          "old_api": null,
          "new_api": "schedule",
          "old_text": null,
          "new_text": "module_->schedule()",
          "old_line_content": "  // are sorted first by time, then within the same time, allocations are sorted",
          "new_line_content": "                      HloLiveRange::Run(module_->schedule(), *alias_analysis,",
          "content_same": false
        },
        {
          "line": 4295,
          "old_api": null,
          "new_api": "entry_computation",
          "old_text": null,
          "new_text": "module_->entry_computation()",
          "old_line_content": "  // earlier than frees, and finally the value id as a tie breaker.",
          "new_line_content": "                                        module_->entry_computation()));",
          "content_same": false
        },
        {
          "line": 4309,
          "old_api": null,
          "new_api": "id",
          "old_text": null,
          "new_text": "value->id()",
          "old_line_content": "    // as well.",
          "new_line_content": "    events[std::make_tuple(start_time, /*is_free=*/false, value->id())] =",
          "content_same": false
        },
        {
          "line": 4310,
          "old_api": null,
          "new_api": "std::make_tuple(value, chunk, HeapSimulatorTrace::Event::ALLOC)",
          "old_text": null,
          "new_text": "std::make_tuple(value, chunk, HeapSimulatorTrace::Event::ALLOC)",
          "old_line_content": "    // TODO(berkin): For now checking against end_time - 1 (exclusive), but we",
          "new_line_content": "        std::make_tuple(value, chunk, HeapSimulatorTrace::Event::ALLOC);",
          "content_same": false
        },
        {
          "line": 4311,
          "old_api": null,
          "new_api": "id",
          "old_text": null,
          "new_text": "value->id()",
          "old_line_content": "    // really should check against end_time (inclusive) for cases where the",
          "new_line_content": "    events[std::make_tuple(end_time, /*is_free=*/true, value->id())] =",
          "content_same": false
        },
        {
          "line": 4312,
          "old_api": null,
          "new_api": "std::make_tuple(value, chunk, HeapSimulatorTrace::Event::FREE)",
          "old_text": null,
          "new_text": "std::make_tuple(value, chunk, HeapSimulatorTrace::Event::FREE)",
          "old_line_content": "    // operand can't share buffer with user (see",
          "new_line_content": "        std::make_tuple(value, chunk, HeapSimulatorTrace::Event::FREE);",
          "content_same": false
        },
        {
          "line": 2265,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "std::max(buffer_occupied_time,\n                                    options_.cost_analysis->GetAsyncCopyElapsed(\n                                        buffer->defining_position().shape()))",
          "old_line_content": "          end_of_program_prefetch_start_time, end_of_program_prefetch_end_time);",
          "new_line_content": "    buffer_occupied_time = std::max(buffer_occupied_time,",
          "content_same": false
        },
        {
          "line": 2266,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "options_.cost_analysis->GetAsyncCopyElapsed(\n                                        buffer->defining_position().shape())",
          "old_line_content": "  float buffer_occupied_ratio = buffer_occupied_time / total_execution_time;",
          "new_line_content": "                                    options_.cost_analysis->GetAsyncCopyElapsed(",
          "content_same": false
        },
        {
          "line": 2270,
          "old_api": null,
          "new_api": "GetLogicalIntervalElapsed",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->GetLogicalIntervalElapsed(\n          0, last_use_time)",
          "old_line_content": "  // Freeing buffer only makes sense if the buffer will be free for a",
          "new_line_content": "      options_.prefetch_interval_picker->GetLogicalIntervalElapsed(",
          "content_same": false
        },
        {
          "line": 2273,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(2)",
          "old_line_content": "  bool free_buffer =",
          "new_line_content": "  VLOG(2) << \"Total execution time = \" << total_execution_time",
          "content_same": false
        },
        {
          "line": 4321,
          "old_api": null,
          "new_api": "ChunksOverlappingInTime",
          "old_text": null,
          "new_text": "interval_tree.ChunksOverlappingInTime(start_time, end_time - 1)",
          "old_line_content": "            chunk.size, overlapping_chunk.offset, overlapping_chunk.size);",
          "new_line_content": "         interval_tree.ChunksOverlappingInTime(start_time, end_time - 1)) {",
          "content_same": false
        },
        {
          "line": 4322,
          "old_api": null,
          "new_api": "OverlapsWith",
          "old_text": null,
          "new_text": "chunk.OverlapsWith(overlapping_chunk)",
          "old_line_content": "      }",
          "new_line_content": "      if (chunk.OverlapsWith(overlapping_chunk)) {",
          "content_same": false
        },
        {
          "line": 4323,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "InternalError(\n            (\"Value %s (%d, %d) off: %d size: %d overlaps with another chunk\"\n             \" off: %d size: %d\"),\n            value->ToShortString(), start_time, end_time, chunk.offset,\n            chunk.size, overlapping_chunk.offset, overlapping_chunk.size)",
          "old_line_content": "    }",
          "new_line_content": "        return InternalError(",
          "content_same": false
        },
        {
          "line": 4326,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "value->ToShortString()",
          "old_line_content": "  };",
          "new_line_content": "            value->ToShortString(), start_time, end_time, chunk.offset,",
          "content_same": false
        },
        {
          "line": 4330,
          "old_api": null,
          "new_api": "Add",
          "old_text": null,
          "new_text": "interval_tree.Add(start_time, end_time - 1, chunk)",
          "old_line_content": "  for (const HloComputation* computation :",
          "new_line_content": "    interval_tree.Add(start_time, end_time - 1, chunk);",
          "content_same": false
        },
        {
          "line": 2288,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "allocations.back()",
          "old_line_content": "  AliasedOffset* cross_program_prefetch_offset =",
          "new_line_content": "  AddAsyncCopy(*allocations.back(), MemorySpace::kAlternate, chunk_candidate,",
          "content_same": false
        },
        {
          "line": 4337,
          "old_api": null,
          "new_api": "MakeNonfusionComputations",
          "old_text": null,
          "new_text": "module_->MakeNonfusionComputations()",
          "old_line_content": "                .memory_space();",
          "new_line_content": "       module_->MakeNonfusionComputations()) {",
          "content_same": false
        },
        {
          "line": 4338,
          "old_api": null,
          "new_api": "instructions",
          "old_text": null,
          "new_text": "computation->instructions()",
          "old_line_content": "        int64_t to_memory_space =",
          "new_line_content": "    for (const HloInstruction* instruction : computation->instructions()) {",
          "content_same": false
        },
        {
          "line": 2293,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "allocations.back()->AddUse(use)",
          "old_line_content": "               \"cross-program-prefetched buffer.\";",
          "new_line_content": "  absl::c_for_each(uses, [&](auto& use) { allocations.back()->AddUse(use); });",
          "content_same": false
        },
        {
          "line": 4341,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "instruction->shape()",
          "old_line_content": "                .memory_space();",
          "new_line_content": "            ShapeUtil::GetSubshape(instruction->shape(), {1})",
          "content_same": false
        },
        {
          "line": 2295,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "allocations.back()",
          "old_line_content": "                 end_of_program_prefetch_start_time,",
          "new_line_content": "      GetAliasedOffset(*allocations.back());",
          "content_same": false
        },
        {
          "line": 4345,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "instruction->shape()",
          "old_line_content": "      }",
          "new_line_content": "            ShapeUtil::GetSubshape(instruction->shape(), {0})",
          "content_same": false
        },
        {
          "line": 2298,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(2)",
          "old_line_content": "                 cross_program_prefetch_offset,",
          "new_line_content": "    VLOG(2) << \"Adding an end-of-program prefetch for freed \"",
          "content_same": false
        },
        {
          "line": 4348,
          "old_api": null,
          "new_api": "CHECK_NE",
          "old_text": null,
          "new_text": "CHECK_NE(from_memory_space, to_memory_space)",
          "old_line_content": "",
          "new_line_content": "        CHECK_NE(from_memory_space, to_memory_space)",
          "content_same": false
        },
        {
          "line": 4350,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "instruction->ToString()",
          "old_line_content": "    const HloPosition& position = position_and_chunk.first;",
          "new_line_content": "            << instruction->ToString();",
          "content_same": false
        },
        {
          "line": 2307,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "allocations.back()->chunk()",
          "old_line_content": "      BufferInterval buffer_interval;",
          "new_line_content": "             allocations.back()->chunk().offset);",
          "content_same": false
        },
        {
          "line": 4355,
          "old_api": null,
          "new_api": "chunks",
          "old_text": null,
          "new_text": "preset_assignments_->chunks()",
          "old_line_content": "        << \"Multiple preset assignments for the same buffer: \"",
          "new_line_content": "  for (const auto& position_and_chunk : preset_assignments_->chunks()) {",
          "content_same": false
        },
        {
          "line": 4359,
          "old_api": null,
          "new_api": "GetUniqueBufferAt",
          "old_text": null,
          "new_text": "alias_analysis->GetUniqueBufferAt(position.instruction, position.index)",
          "old_line_content": "",
          "new_line_content": "        alias_analysis->GetUniqueBufferAt(position.instruction, position.index);",
          "content_same": false
        },
        {
          "line": 2315,
          "old_api": null,
          "new_api": "end_time",
          "old_text": null,
          "new_text": "allocation->end_time()",
          "old_line_content": "  }",
          "new_line_content": "      buffer_interval.end = allocation->end_time();",
          "content_same": false
        },
        {
          "line": 2316,
          "old_api": null,
          "new_api": "chunk",
          "old_text": null,
          "new_text": "allocation->chunk()",
          "old_line_content": "",
          "new_line_content": "      buffer_interval.size = allocation->chunk().size;",
          "content_same": false
        },
        {
          "line": 4364,
          "old_api": null,
          "new_api": "id",
          "old_text": null,
          "new_text": "buffer.id()",
          "old_line_content": "      int64_t last_use_time = time_bound.start;",
          "new_line_content": "    seen_buffers.insert(buffer.id());",
          "content_same": false
        },
        {
          "line": 2318,
          "old_api": null,
          "new_api": "AddToPendingChunks",
          "old_text": null,
          "new_text": "AddToPendingChunks(buffer_interval, chunk_candidate)",
          "old_line_content": "  // memory.",
          "new_line_content": "      AddToPendingChunks(buffer_interval, chunk_candidate);",
          "content_same": false
        },
        {
          "line": 4366,
          "old_api": null,
          "new_api": "values",
          "old_text": null,
          "new_text": "buffer.values()",
          "old_line_content": "        int64_t use_time =",
          "new_line_content": "    for (const HloValue* value : buffer.values()) {",
          "content_same": false
        },
        {
          "line": 4368,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "hlo_live_range->buffer_live_ranges().at(value)",
          "old_line_content": "        if (use_time > last_use_time) {",
          "new_line_content": "          hlo_live_range->buffer_live_ranges().at(value);",
          "content_same": false
        },
        {
          "line": 4371,
          "old_api": null,
          "new_api": "GetUses",
          "old_text": null,
          "new_text": "value->GetUses()",
          "old_line_content": "        }",
          "new_line_content": "      for (const HloUse& use : value->GetUses()) {",
          "content_same": false
        },
        {
          "line": 4373,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "hlo_live_range->instruction_schedule().at(use.instruction)",
          "old_line_content": "",
          "new_line_content": "            hlo_live_range->instruction_schedule().at(use.instruction);",
          "content_same": false
        },
        {
          "line": 2328,
          "old_api": null,
          "new_api": "memory_space",
          "old_text": null,
          "new_text": "allocation->memory_space()",
          "old_line_content": "      for (RepackAllocationBlock* colocation : colocations) {",
          "new_line_content": "    if (allocation->memory_space() == MemorySpace::kAlternate) {",
          "content_same": false
        },
        {
          "line": 2331,
          "old_api": null,
          "new_api": "chunk",
          "old_text": null,
          "new_text": "allocation->chunk()",
          "old_line_content": "      }",
          "new_line_content": "          allocation->chunk().size, allocation->chunk().offset,",
          "content_same": false
        },
        {
          "line": 2335,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "inserted->colocations.push_back(colocation)",
          "old_line_content": "  }",
          "new_line_content": "        inserted->colocations.push_back(colocation);",
          "content_same": false
        },
        {
          "line": 2336,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "colocation->colocations.push_back(inserted)",
          "old_line_content": "",
          "new_line_content": "        colocation->colocations.push_back(inserted);",
          "content_same": false
        },
        {
          "line": 2338,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "inserted->colocations.emplace_back(inserted)",
          "old_line_content": "}",
          "new_line_content": "      inserted->colocations.emplace_back(inserted);",
          "content_same": false
        },
        {
          "line": 2339,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "colocations.emplace_back(inserted)",
          "old_line_content": "",
          "new_line_content": "      colocations.emplace_back(inserted);",
          "content_same": false
        },
        {
          "line": 4389,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "        for (const HloComputation* called_computation :",
          "new_line_content": "        VLOG(3) << indent_string",
          "content_same": false
        },
        {
          "line": 2343,
          "old_api": null,
          "new_api": "ClearPendingChunks",
          "old_text": null,
          "new_text": "ClearPendingChunks()",
          "old_line_content": "  std::vector<MemorySpaceAssignmentRepacker::AllocationBlock*> colocations;",
          "new_line_content": "  ClearPendingChunks();",
          "content_same": false
        },
        {
          "line": 4391,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "value->ToShortString()",
          "old_line_content": "          int64_t computation_start_time =",
          "new_line_content": "                << \" value: \" << value->ToShortString() << \": (\" << start_time",
          "content_same": false
        },
        {
          "line": 2348,
          "old_api": null,
          "new_api": "flattened_instruction_sequence",
          "old_text": null,
          "new_text": "hlo_live_range_.flattened_instruction_sequence().instructions()",
          "old_line_content": "    if (reserved_scoped_memory != 0) {",
          "new_line_content": "      hlo_live_range_.flattened_instruction_sequence().instructions();",
          "content_same": false
        },
        {
          "line": 4398,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "hlo_live_range->computation_span_times()\n                  .at(called_computation)",
          "old_line_content": "          const HloInstruction* last_use_instruction = nullptr;",
          "new_line_content": "              hlo_live_range->computation_span_times()",
          "content_same": false
        },
        {
          "line": 2353,
          "old_api": null,
          "new_api": "reserved_scoped_memory_fn",
          "old_text": null,
          "new_text": "options_.reserved_scoped_memory_fn(instruction)",
          "old_line_content": "      interval.size = reserved_scoped_memory;",
          "new_line_content": "        options_.reserved_scoped_memory_fn(instruction);",
          "content_same": false
        },
        {
          "line": 2355,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "      interval.end = i;",
          "new_line_content": "      VLOG(1) << \"Allocate reserved scoped memory at \" << i << \" (\"",
          "content_same": false
        },
        {
          "line": 2356,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "instruction->name()",
          "old_line_content": "      interval.need_allocation = true;",
          "new_line_content": "              << instruction->name() << \"): \" << reserved_scoped_memory;",
          "content_same": false
        },
        {
          "line": 4405,
          "old_api": null,
          "new_api": "GetUses",
          "old_text": null,
          "new_text": "value->GetUses()",
          "old_line_content": "              last_use_instruction = use.instruction;",
          "new_line_content": "          for (const HloUse& use : value->GetUses()) {",
          "content_same": false
        },
        {
          "line": 4407,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "hlo_live_range->instruction_schedule().at(use.instruction)",
          "old_line_content": "          }",
          "new_line_content": "                hlo_live_range->instruction_schedule().at(use.instruction);",
          "content_same": false
        },
        {
          "line": 4408,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "use.instruction->parent()",
          "old_line_content": "          if (last_use_time != -1) {",
          "new_line_content": "            if (use.instruction->parent() == called_computation &&",
          "content_same": false
        },
        {
          "line": 2365,
          "old_api": null,
          "new_api": "FindChunkCandidate",
          "old_text": null,
          "new_text": "FindChunkCandidate(interval, /*preferred_offset=*/0)",
          "old_line_content": "            instruction, i, reserved_scoped_memory, buffer_info_str_);",
          "new_line_content": "          FindChunkCandidate(interval, /*preferred_offset=*/0);",
          "content_same": false
        },
        {
          "line": 2366,
          "old_api": null,
          "new_api": "CHECK_EQ",
          "old_text": null,
          "new_text": "CHECK_EQ(chunk_candidate.offset, 0)",
          "old_line_content": "      }",
          "new_line_content": "      CHECK_EQ(chunk_candidate.offset, 0);",
          "content_same": false
        },
        {
          "line": 2367,
          "old_api": null,
          "new_api": "AddToPendingChunks",
          "old_text": null,
          "new_text": "AddToPendingChunks(interval, chunk_candidate)",
          "old_line_content": "",
          "new_line_content": "      AddToPendingChunks(interval, chunk_candidate);",
          "content_same": false
        },
        {
          "line": 4415,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "              // function recursively.",
          "new_line_content": "            VLOG(3) << indent_string",
          "content_same": false
        },
        {
          "line": 2370,
          "old_api": null,
          "new_api": "AppendScopedAllocationBufferInfoDebugString",
          "old_text": null,
          "new_text": "AppendScopedAllocationBufferInfoDebugString(\n            instruction, i, reserved_scoped_memory, buffer_info_str_)",
          "old_line_content": "              HloPosition{instruction_sequence[i], {}}, MemorySpace::kAlternate,",
          "new_line_content": "        AppendScopedAllocationBufferInfoDebugString(",
          "content_same": false
        },
        {
          "line": 4419,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "last_use_instruction->opcode()",
          "old_line_content": "            } else {",
          "new_line_content": "            if (last_use_instruction->opcode() == HloOpcode::kConditional) {",
          "content_same": false
        },
        {
          "line": 2374,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "allocations_->push_back(\n          std::make_unique<MemorySpaceAssignment::Allocation>(\n              HloPosition{instruction_sequence[i], {}}, MemorySpace::kAlternate,\n              chunk_candidate, i, i, /*is_scoped_allocation=*/true))",
          "old_line_content": "          i, i, reserved_scoped_memory,",
          "new_line_content": "      allocations_->push_back(",
          "content_same": false
        },
        {
          "line": 2375,
          "old_api": null,
          "new_api": "std::make_unique<MemorySpaceAssignment::Allocation>(\n              HloPosition{instruction_sequence[i], {}}, MemorySpace::kAlternate,\n              chunk_candidate, i, i, /*is_scoped_allocation=*/true)",
          "old_text": null,
          "new_text": "std::make_unique<MemorySpaceAssignment::Allocation>(\n              HloPosition{instruction_sequence[i], {}}, MemorySpace::kAlternate,\n              chunk_candidate, i, i, /*is_scoped_allocation=*/true)",
          "old_line_content": "          /*initial_offset=*/0,",
          "new_line_content": "          std::make_unique<MemorySpaceAssignment::Allocation>(",
          "content_same": false
        },
        {
          "line": 4422,
          "old_api": null,
          "new_api": "split_conditional_buffer",
          "old_text": null,
          "new_text": "split_conditional_buffer(\n                  last_use_instruction, computation_start_time, last_use_time,\n                  absl::StrCat(indent_string, \"  \"))",
          "old_line_content": "                  computation_start_time, last_use_time, chunk, value));",
          "new_line_content": "              TF_RETURN_IF_ERROR(split_conditional_buffer(",
          "content_same": false
        },
        {
          "line": 4424,
          "old_api": null,
          "new_api": "absl::StrCat(indent_string, \"  \")",
          "old_text": null,
          "new_text": "absl::StrCat(indent_string, \"  \")",
          "old_line_content": "          }",
          "new_line_content": "                  absl::StrCat(indent_string, \"  \")));",
          "content_same": false
        },
        {
          "line": 2379,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "MakeRepackAllocationBlock(\n          i, i, reserved_scoped_memory,\n          /*initial_offset=*/0,\n          static_cast<int64_t>(repack_allocation_blocks_.size()),\n          allocations_->back().get())",
          "old_line_content": "    }",
          "new_line_content": "      repack_allocation_blocks_.push_back(MakeRepackAllocationBlock(",
          "content_same": false
        },
        {
          "line": 4427,
          "old_api": null,
          "new_api": "add_allocation_and_verify",
          "old_text": null,
          "new_text": "add_allocation_and_verify(\n                  computation_start_time, last_use_time, chunk, value)",
          "old_line_content": "                << start_time << \", \" << (earliest_computation_start_time - 1)",
          "new_line_content": "              TF_RETURN_IF_ERROR(add_allocation_and_verify(",
          "content_same": false
        },
        {
          "line": 2382,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "repack_allocation_blocks_.size()",
          "old_line_content": "  // that when we repack, all scoped allocations get the same offsets. Since",
          "new_line_content": "          static_cast<int64_t>(repack_allocation_blocks_.size()),",
          "content_same": false
        },
        {
          "line": 2383,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "allocations_->back().get()",
          "old_line_content": "  // they will all have the same scoped memory addresses, this increases the",
          "new_line_content": "          allocations_->back().get()));",
          "content_same": false
        },
        {
          "line": 2384,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "repack_allocation_blocks_.back()",
          "old_line_content": "  // opportunity to deduplicate different ops.  However, this may hurt the",
          "new_line_content": "      colocations.push_back(&repack_allocation_blocks_.back());",
          "content_same": false
        },
        {
          "line": 4432,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "      };",
          "new_line_content": "        VLOG(3) << indent_string << \" from beginning until first computation: (\"",
          "content_same": false
        },
        {
          "line": 4437,
          "old_api": null,
          "new_api": "OkStatus",
          "old_text": null,
          "new_text": "OkStatus()",
          "old_line_content": "            last_use_instruction, time_bound.start, time_bound.end, \" \"));",
          "new_line_content": "        return OkStatus();",
          "content_same": false
        },
        {
          "line": 4442,
          "old_api": null,
          "new_api": "split_conditional_buffer",
          "old_text": null,
          "new_text": "split_conditional_buffer(\n            last_use_instruction, time_bound.start, time_bound.end, \" \")",
          "old_line_content": "                << time_bound.start << \", \" << last_use_time",
          "new_line_content": "        TF_RETURN_IF_ERROR(split_conditional_buffer(",
          "content_same": false
        },
        {
          "line": 4445,
          "old_api": null,
          "new_api": "std::min(last_use_time, time_bound.end)",
          "old_text": null,
          "new_text": "std::min(last_use_time, time_bound.end)",
          "old_line_content": "            time_bound.start, last_use_time, chunk, value));",
          "new_line_content": "        last_use_time = std::min(last_use_time, time_bound.end);",
          "content_same": false
        },
        {
          "line": 4446,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "buffer.ToString()",
          "old_line_content": "      }",
          "new_line_content": "        VLOG(3) << \" buffer: \" << buffer.ToString()",
          "content_same": false
        },
        {
          "line": 4447,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "value->ToShortString()",
          "old_line_content": "    }",
          "new_line_content": "                << \" value: \" << value->ToShortString() << \": (\"",
          "content_same": false
        },
        {
          "line": 4450,
          "old_api": null,
          "new_api": "add_allocation_and_verify",
          "old_text": null,
          "new_text": "add_allocation_and_verify(\n            time_bound.start, last_use_time, chunk, value)",
          "old_line_content": "  HeapSimulatorTrace* heap_trace =",
          "new_line_content": "        TF_RETURN_IF_ERROR(add_allocation_and_verify(",
          "content_same": false
        },
        {
          "line": 2404,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "required_assignments_.find(buffer)",
          "old_line_content": "        // Sanity check that there is only one required at time.",
          "new_line_content": "  auto required_assignment_it = required_assignments_.find(buffer);",
          "content_same": false
        },
        {
          "line": 4457,
          "old_api": null,
          "new_api": "assignment_information_for_space",
          "old_text": null,
          "new_text": "preset_assignments_\n           ->assignment_information_for_space(options_.alternate_memory_space)",
          "old_line_content": "    int64_t time;",
          "new_line_content": "      &preset_assignments_",
          "content_same": false
        },
        {
          "line": 2411,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(!required_assignment_at_time)",
          "old_line_content": "  return required_assignment_at_time;",
          "new_line_content": "        CHECK(!required_assignment_at_time)",
          "content_same": false
        },
        {
          "line": 2412,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "buffer->ToShortString()",
          "old_line_content": "}",
          "new_line_content": "            << buffer->ToShortString() << \" at time \" << time;",
          "content_same": false
        },
        {
          "line": 4471,
          "old_api": null,
          "new_api": "add_events",
          "old_text": null,
          "new_text": "heap_trace->add_events()",
          "old_line_content": "",
          "new_line_content": "    HeapSimulatorTrace::Event* heap_trace_event = heap_trace->add_events();",
          "content_same": false
        },
        {
          "line": 4472,
          "old_api": null,
          "new_api": "set_kind",
          "old_text": null,
          "new_text": "heap_trace_event->set_kind(kind)",
          "old_line_content": "    if (kind == HeapSimulatorTrace::Event::ALLOC) {",
          "new_line_content": "    heap_trace_event->set_kind(kind);",
          "content_same": false
        },
        {
          "line": 4473,
          "old_api": null,
          "new_api": "set_buffer_id",
          "old_text": null,
          "new_text": "heap_trace_event->set_buffer_id(buffer_id)",
          "old_line_content": "      memory_usage += chunk.size;",
          "new_line_content": "    heap_trace_event->set_buffer_id(buffer_id);",
          "content_same": false
        },
        {
          "line": 2426,
          "old_api": null,
          "new_api": "dataflow_analysis",
          "old_text": null,
          "new_text": "alias_analysis_.dataflow_analysis().GetUniqueValueAt(\n            position.instruction, position.index)",
          "old_line_content": "    if (required_assignment == std::nullopt) {",
          "new_line_content": "        &alias_analysis_.dataflow_analysis().GetUniqueValueAt(",
          "content_same": false
        },
        {
          "line": 4474,
          "old_api": null,
          "new_api": "instruction",
          "old_text": null,
          "new_text": "value->instruction()->name()",
          "old_line_content": "    } else {",
          "new_line_content": "    heap_trace_event->set_instruction_name(value->instruction()->name());",
          "content_same": false
        },
        {
          "line": 4476,
          "old_api": null,
          "new_api": "instruction",
          "old_text": null,
          "new_text": "value->instruction()->parent()->name()",
          "old_line_content": "      memory_usage -= chunk.size;",
          "new_line_content": "        value->instruction()->parent()->name());",
          "content_same": false
        },
        {
          "line": 2431,
          "old_api": null,
          "new_api": "RequiredMemoryAssignmentAt",
          "old_text": null,
          "new_text": "RequiredMemoryAssignmentAt(value, time)",
          "old_line_content": "                *required_assignment_for_alias));",
          "new_line_content": "        RequiredMemoryAssignmentAt(value, time);",
          "content_same": false
        },
        {
          "line": 2435,
          "old_api": null,
          "new_api": "equals_ignoring_time",
          "old_text": null,
          "new_text": "CHECK(required_assignment_for_alias == std::nullopt ||\n            required_assignment->equals_ignoring_time(\n                *required_assignment_for_alias))",
          "old_line_content": "}",
          "new_line_content": "      CHECK(required_assignment_for_alias == std::nullopt ||",
          "content_same": false
        },
        {
          "line": 2436,
          "old_api": null,
          "new_api": "equals_ignoring_time",
          "old_text": null,
          "new_text": "required_assignment->equals_ignoring_time(\n                *required_assignment_for_alias)",
          "old_line_content": "",
          "new_line_content": "            required_assignment->equals_ignoring_time(",
          "content_same": false
        },
        {
          "line": 4484,
          "old_api": null,
          "new_api": "std::max(max_memory_usage, memory_usage)",
          "old_text": null,
          "new_text": "std::max(max_memory_usage, memory_usage)",
          "old_line_content": "}",
          "new_line_content": "    max_memory_usage = std::max(max_memory_usage, memory_usage);",
          "content_same": false
        },
        {
          "line": 4485,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "}  // namespace memory_space_assignment",
          "new_line_content": "    VLOG(4) << \"Memory usage: \" << memory_usage << \" at time: \" << time;",
          "content_same": false
        },
        {
          "line": 4487,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "",
          "new_line_content": "  VLOG(1) << \"Max memory usage ignoring fragmentation: \" << max_memory_usage;",
          "content_same": false
        },
        {
          "line": 4489,
          "old_api": null,
          "new_api": "OkStatus",
          "old_text": null,
          "new_text": "OkStatus()",
          "old_line_content": "",
          "new_line_content": "  return OkStatus();",
          "content_same": false
        },
        {
          "line": 2447,
          "old_api": null,
          "new_api": "memory_space",
          "old_text": null,
          "new_text": "aliased_allocation->memory_space()",
          "old_line_content": "",
          "new_line_content": "  if (aliased_allocation->memory_space() == MemorySpace::kAlternate) {",
          "content_same": false
        },
        {
          "line": 2448,
          "old_api": null,
          "new_api": "GetAliasedOffset",
          "old_text": null,
          "new_text": "GetAliasedOffset(*aliased_allocation)",
          "old_line_content": "void AlternateMemoryBestFitHeap::AddRequiredAssignment(",
          "new_line_content": "    offset = GetAliasedOffset(*aliased_allocation);",
          "content_same": false
        },
        {
          "line": 2450,
          "old_api": null,
          "new_api": "memory_space",
          "old_text": null,
          "new_text": "aliased_allocation->memory_space()",
          "old_line_content": "    MemorySpaceAssignment::MemorySpace memory_space, int64_t time,",
          "new_line_content": "  AddRequiredAssignment(instruction, index, aliased_allocation->memory_space(),",
          "content_same": false
        },
        {
          "line": 2462,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(memory_space == existing_required_assignment->memory_space)",
          "old_line_content": "            << (memory_space == MemorySpace::kDefault ? \"def\" : \"alt\");",
          "new_line_content": "    CHECK(memory_space == existing_required_assignment->memory_space)",
          "content_same": false
        },
        {
          "line": 2463,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "instruction->ToString()",
          "old_line_content": "  } else {",
          "new_line_content": "        << \"inst = \" << instruction->ToString() << \" at \" << time;",
          "content_same": false
        },
        {
          "line": 2466,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "            << (memory_space == MemorySpace::kDefault ? \"def\" : \"alt\");",
          "new_line_content": "    VLOG(3) << \"Not adding required assignment because there is one already: \"",
          "content_same": false
        },
        {
          "line": 2467,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "value->ToShortString()",
          "old_line_content": "    RequiredMemoryAssignment required_assignment{memory_space, time, offset};",
          "new_line_content": "            << value->ToShortString() << \" at \" << time << \" at \"",
          "content_same": false
        },
        {
          "line": 2474,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "required_assignments_[value].push_back(required_assignment)",
          "old_line_content": "",
          "new_line_content": "    required_assignments_[value].push_back(required_assignment);",
          "content_same": false
        },
        {
          "line": 2476,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "pending_required_assignments_.push_back({value, required_assignment})",
          "old_line_content": "    const HloInstruction* instruction, ShapeIndex index,",
          "new_line_content": "      pending_required_assignments_.push_back({value, required_assignment});",
          "content_same": false
        },
        {
          "line": 2485,
          "old_api": null,
          "new_api": "dataflow_analysis",
          "old_text": null,
          "new_text": "alias_analysis_.dataflow_analysis().GetUniqueValueAt(instruction, index)",
          "old_line_content": "",
          "new_line_content": "      &alias_analysis_.dataflow_analysis().GetUniqueValueAt(instruction, index);",
          "content_same": false
        },
        {
          "line": 2487,
          "old_api": null,
          "new_api": "instruction_schedule",
          "old_text": null,
          "new_text": "hlo_live_range_.instruction_schedule().at(instruction)",
          "old_line_content": "  // Go through the parameters, outputs, and constants and pin them to the",
          "new_line_content": "      hlo_live_range_.instruction_schedule().at(instruction);",
          "content_same": false
        },
        {
          "line": 2488,
          "old_api": null,
          "new_api": "AddRequiredAssignment",
          "old_text": null,
          "new_text": "AddRequiredAssignment(value, instruction, memory_space, instruction_time,\n                        offset)",
          "old_line_content": "  // corresponding memory by adding a required assignment.",
          "new_line_content": "  AddRequiredAssignment(value, instruction, memory_space, instruction_time,",
          "content_same": false
        },
        {
          "line": 2499,
          "old_api": null,
          "new_api": "parameter_instructions",
          "old_text": null,
          "new_text": "entry_computation->parameter_instructions()",
          "old_line_content": "          MemorySpace memory_space = MemorySpace::kDefault;",
          "new_line_content": "       entry_computation->parameter_instructions()) {",
          "content_same": false
        },
        {
          "line": 2501,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "instruction_schedule.at(parameter_instruction)",
          "old_line_content": "                                           options_.alternate_memory_space) {",
          "new_line_content": "        instruction_schedule.at(parameter_instruction);",
          "content_same": false
        },
        {
          "line": 2502,
          "old_api": null,
          "new_api": "has_layout",
          "old_text": null,
          "new_text": "ShapeUtil::ForEachSubshape(\n        parameter_instruction->shape(),\n        [&](const Shape& subshape, const ShapeIndex& index) {\n          MemorySpace memory_space = MemorySpace::kDefault;\n          if (subshape.has_layout() && subshape.layout().memory_space() ==\n                                           options_.alternate_memory_space) {\n            memory_space = MemorySpace::kAlternate;\n          }\n          for (const HloBuffer* buffer :\n               alias_analysis_.ComputeBuffersAt(parameter_instruction, index)) {\n            for (const HloValue* value : buffer->values()) {\n              VLOG(3) << \"Adding required assignment for parameter value = \"\n                      << value->ToShortString()\n                      << \" time = \" << parameter_instruction_time << \" space = \"\n                      << (memory_space == MemorySpace::kDefault ? \"def\"\n                                                                : \"alt\");\n              AddRequiredAssignment(value, parameter_instruction, memory_space,\n                                    parameter_instruction_time,\n                                    /*offset=*/nullptr,\n                                    /*add_to_pending=*/false);\n            }\n          }\n        })",
          "old_line_content": "            memory_space = MemorySpace::kAlternate;",
          "new_line_content": "    ShapeUtil::ForEachSubshape(",
          "content_same": false
        },
        {
          "line": 2503,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "parameter_instruction->shape()",
          "old_line_content": "          }",
          "new_line_content": "        parameter_instruction->shape(),",
          "content_same": false
        },
        {
          "line": 2511,
          "old_api": null,
          "new_api": "ComputeBuffersAt",
          "old_text": null,
          "new_text": "alias_analysis_.ComputeBuffersAt(parameter_instruction, index)",
          "old_line_content": "                                                                : \"alt\");",
          "new_line_content": "               alias_analysis_.ComputeBuffersAt(parameter_instruction, index)) {",
          "content_same": false
        },
        {
          "line": 2513,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "                                    parameter_instruction_time,",
          "new_line_content": "              VLOG(3) << \"Adding required assignment for parameter value = \"",
          "content_same": false
        },
        {
          "line": 2514,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "value->ToShortString()",
          "old_line_content": "                                    /*offset=*/nullptr,",
          "new_line_content": "                      << value->ToShortString()",
          "content_same": false
        },
        {
          "line": 2518,
          "old_api": null,
          "new_api": "AddRequiredAssignment",
          "old_text": null,
          "new_text": "AddRequiredAssignment(value, parameter_instruction, memory_space,\n                                    parameter_instruction_time,\n                                    /*offset=*/nullptr,\n                                    /*add_to_pending=*/false)",
          "old_line_content": "        });",
          "new_line_content": "              AddRequiredAssignment(value, parameter_instruction, memory_space,",
          "content_same": false
        },
        {
          "line": 2527,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "instruction_schedule.at(root_instruction)",
          "old_line_content": "                                         options_.alternate_memory_space) {",
          "new_line_content": "  int64_t root_instruction_time = instruction_schedule.at(root_instruction);",
          "content_same": false
        },
        {
          "line": 2528,
          "old_api": null,
          "new_api": "has_layout",
          "old_text": null,
          "new_text": "ShapeUtil::ForEachSubshape(\n      root_instruction->shape(),\n      [&](const Shape& subshape, const ShapeIndex& index) {\n        MemorySpace memory_space = MemorySpace::kDefault;\n        if (subshape.has_layout() && subshape.layout().memory_space() ==\n                                         options_.alternate_memory_space) {\n          memory_space = MemorySpace::kAlternate;\n        }\n        for (const HloBuffer* buffer :\n             alias_analysis_.ComputeBuffersAt(root_instruction, index)) {\n          for (const HloValue* value : buffer->values()) {\n            VLOG(3) << \"Adding required assignment for output value = \"\n                    << value->ToShortString()\n                    << \" time = \" << root_instruction_time << \" space = \"\n                    << (memory_space == MemorySpace::kDefault ? \"def\" : \"alt\");\n            AddRequiredAssignment(value, root_instruction, memory_space,\n                                  root_instruction_time,\n                                  /*offset=*/nullptr, /*add_to_pending=*/false);\n          }\n        }\n      })",
          "old_line_content": "          memory_space = MemorySpace::kAlternate;",
          "new_line_content": "  ShapeUtil::ForEachSubshape(",
          "content_same": false
        },
        {
          "line": 2529,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "root_instruction->shape()",
          "old_line_content": "        }",
          "new_line_content": "      root_instruction->shape(),",
          "content_same": false
        },
        {
          "line": 2538,
          "old_api": null,
          "new_api": "values",
          "old_text": null,
          "new_text": "buffer->values()",
          "old_line_content": "                                  root_instruction_time,",
          "new_line_content": "          for (const HloValue* value : buffer->values()) {",
          "content_same": false
        },
        {
          "line": 2539,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "                                  /*offset=*/nullptr, /*add_to_pending=*/false);",
          "new_line_content": "            VLOG(3) << \"Adding required assignment for output value = \"",
          "content_same": false
        },
        {
          "line": 2540,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "value->ToShortString()",
          "old_line_content": "          }",
          "new_line_content": "                    << value->ToShortString()",
          "content_same": false
        },
        {
          "line": 2543,
          "old_api": null,
          "new_api": "AddRequiredAssignment",
          "old_text": null,
          "new_text": "AddRequiredAssignment(value, root_instruction, memory_space,\n                                  root_instruction_time,\n                                  /*offset=*/nullptr, /*add_to_pending=*/false)",
          "old_line_content": "",
          "new_line_content": "            AddRequiredAssignment(value, root_instruction, memory_space,",
          "content_same": false
        },
        {
          "line": 2550,
          "old_api": null,
          "new_api": "MakeNonfusionComputations",
          "old_text": null,
          "new_text": "module.MakeNonfusionComputations()",
          "old_line_content": "        }",
          "new_line_content": "  for (const HloComputation* computation : module.MakeNonfusionComputations()) {",
          "content_same": false
        },
        {
          "line": 2551,
          "old_api": null,
          "new_api": "instructions",
          "old_text": null,
          "new_text": "computation->instructions()",
          "old_line_content": "        int64_t constant_instruction_time = constant_instruction_it->second;",
          "new_line_content": "    for (HloInstruction* instruction : computation->instructions()) {",
          "content_same": false
        },
        {
          "line": 2552,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "        for (const auto& indexed_shape :",
          "new_line_content": "      if (instruction->opcode() == HloOpcode::kConstant) {",
          "content_same": false
        },
        {
          "line": 2554,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "instruction_schedule.end()",
          "old_line_content": "          const ShapeIndex& index = indexed_shape.index;",
          "new_line_content": "        if (constant_instruction_it == instruction_schedule.end()) {",
          "content_same": false
        },
        {
          "line": 2563,
          "old_api": null,
          "new_api": "values",
          "old_text": null,
          "new_text": "buffer->values()",
          "old_line_content": "                                    constant_instruction_time,",
          "new_line_content": "            for (const HloValue* value : buffer->values()) {",
          "content_same": false
        },
        {
          "line": 2564,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "                                    /*offset=*/nullptr,",
          "new_line_content": "              VLOG(3) << \"Adding required assignment for constant value = \"",
          "content_same": false
        },
        {
          "line": 2565,
          "old_api": null,
          "new_api": "ToShortString",
          "old_text": null,
          "new_text": "value->ToShortString()",
          "old_line_content": "                                    /*add_to_pending=*/false);",
          "new_line_content": "                      << value->ToShortString()",
          "content_same": false
        },
        {
          "line": 2568,
          "old_api": null,
          "new_api": "AddRequiredAssignment",
          "old_text": null,
          "new_text": "AddRequiredAssignment(value, instruction, MemorySpace::kDefault,\n                                    constant_instruction_time,\n                                    /*offset=*/nullptr,\n                                    /*add_to_pending=*/false)",
          "old_line_content": "        }",
          "new_line_content": "              AddRequiredAssignment(value, instruction, MemorySpace::kDefault,",
          "content_same": false
        },
        {
          "line": 2582,
          "old_api": null,
          "new_api": "is_allowed_in_alternate_mem_fn",
          "old_text": null,
          "new_text": "options_.is_allowed_in_alternate_mem_fn(*value)",
          "old_line_content": "        continue;",
          "new_line_content": "    if (!options_.is_allowed_in_alternate_mem_fn(*value)) {",
          "content_same": false
        },
        {
          "line": 2586,
          "old_api": null,
          "new_api": "instruction",
          "old_text": null,
          "new_text": "value->instruction()",
          "old_line_content": "      // Check if there is an existing matching required assignment (e.g.",
          "new_line_content": "          instruction_schedule.find(value->instruction());",
          "content_same": false
        },
        {
          "line": 2587,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "instruction_schedule.end()",
          "old_line_content": "      // inserted by the logic above) and if so ensure it requires a default",
          "new_line_content": "      if (instruction_time_it == instruction_schedule.end()) {",
          "content_same": false
        },
        {
          "line": 2600,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "required_assignments.end()",
          "old_line_content": "            {MemorySpace::kDefault, instruction_time});",
          "new_line_content": "      if (matching_assignment != required_assignments.end()) {",
          "content_same": false
        },
        {
          "line": 2601,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(matching_assignment->memory_space == MemorySpace::kDefault)",
          "old_line_content": "      }",
          "new_line_content": "        CHECK(matching_assignment->memory_space == MemorySpace::kDefault)",
          "content_same": false
        },
        {
          "line": 2603,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "value->ToString()",
          "old_line_content": "  }",
          "new_line_content": "            << \" value: \" << value->ToString();",
          "content_same": false
        },
        {
          "line": 2605,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "required_assignments.push_back(\n            {MemorySpace::kDefault, instruction_time})",
          "old_line_content": "",
          "new_line_content": "        required_assignments.push_back(",
          "content_same": false
        },
        {
          "line": 2616,
          "old_api": null,
          "new_api": "has_layout",
          "old_text": null,
          "new_text": "shape.has_layout()",
          "old_line_content": "  const HloInstruction* root_instruction =",
          "new_line_content": "    return shape.has_layout() &&",
          "content_same": false
        },
        {
          "line": 2623,
          "old_api": null,
          "new_api": "root_instruction",
          "old_text": null,
          "new_text": "entry_computation->root_instruction()",
          "old_line_content": "      return true;",
          "new_line_content": "      entry_computation->root_instruction();",
          "content_same": false
        },
        {
          "line": 2627,
          "old_api": null,
          "new_api": "defining_instruction",
          "old_text": null,
          "new_text": "value->defining_instruction()->parent()",
          "old_line_content": "      if (position.instruction == root_instruction &&",
          "new_line_content": "        value->defining_instruction()->parent() == entry_computation &&",
          "content_same": false
        },
        {
          "line": 2632,
          "old_api": null,
          "new_api": "positions",
          "old_text": null,
          "new_text": "value->positions()",
          "old_line_content": "  }",
          "new_line_content": "    for (const HloPosition& position : value->positions()) {",
          "content_same": false
        },
        {
          "line": 2634,
          "old_api": null,
          "new_api": "is_position_in_alternate_memory",
          "old_text": null,
          "new_text": "is_position_in_alternate_memory(position)",
          "old_line_content": "}",
          "new_line_content": "          is_position_in_alternate_memory(position)) {",
          "content_same": false
        },
        {
          "line": 2645,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "allocations.push_back(&allocation_block)",
          "old_line_content": "  for (RepackAllocationBlock& allocation_block : repack_allocation_blocks_) {",
          "new_line_content": "    allocations.push_back(&allocation_block);",
          "content_same": false
        },
        {
          "line": 2653,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "allocation->ToString()",
          "old_line_content": "        allocation_block.offset;",
          "new_line_content": "    VLOG(3) << \"Moved \" << allocation->ToString() << \", size \"",
          "content_same": false
        },
        {
          "line": 2658,
          "old_api": null,
          "new_api": "mutable_chunk",
          "old_text": null,
          "new_text": "allocation_block.allocation->mutable_chunk()",
          "old_line_content": "  }",
          "new_line_content": "    allocation_block.allocation->mutable_chunk()->offset =",
          "content_same": false
        },
        {
          "line": 2660,
          "old_api": null,
          "new_api": "Add",
          "old_text": null,
          "new_text": "interval_tree_.Add(allocation_block.start_time, allocation_block.end_time,\n                       {allocation_block.offset, allocation_block.size})",
          "old_line_content": "",
          "new_line_content": "    interval_tree_.Add(allocation_block.start_time, allocation_block.end_time,",
          "content_same": false
        },
        {
          "line": 2672,
          "old_api": null,
          "new_api": "allocation_sequence",
          "old_text": null,
          "new_text": "allocation_value.allocation_sequence()->clear()",
          "old_line_content": "            << \") off = \" << chunk.offset << \" size = \" << chunk.size;",
          "new_line_content": "    allocation_value.allocation_sequence()->clear();",
          "content_same": false
        },
        {
          "line": 2677,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "          << \" is below zero after uncommitting. \" << interval.start << \"-\"",
          "new_line_content": "    VLOG(3) << \"Uncommitting: (\" << interval.start << \", \" << interval.end",
          "content_same": false
        },
        {
          "line": 2693,
          "old_api": null,
          "new_api": "RemoveCopy",
          "old_text": null,
          "new_text": "prefetch_async_copy_resource_.RemoveCopy(interval)",
          "old_line_content": "  }",
          "new_line_content": "      prefetch_async_copy_resource_.RemoveCopy(interval);",
          "content_same": false
        },
        {
          "line": 2695,
          "old_api": null,
          "new_api": "Remove",
          "old_text": null,
          "new_text": "eviction_interval_tree_.Remove(interval.start_time, interval.end_time,\n                                     kDummyChunk)",
          "old_line_content": "       pending_required_assignments_) {",
          "new_line_content": "      eviction_interval_tree_.Remove(interval.start_time, interval.end_time,",
          "content_same": false
        },
        {
          "line": 2697,
          "old_api": null,
          "new_api": "RemoveCopy",
          "old_text": null,
          "new_text": "eviction_async_copy_resource_.RemoveCopy(interval)",
          "old_line_content": "        required_assignments_[value_and_required_assignment.first];",
          "new_line_content": "      eviction_async_copy_resource_.RemoveCopy(interval);",
          "content_same": false
        },
        {
          "line": 2706,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "                                           : -1);",
          "new_line_content": "    VLOG(3) << \"Removing required assignment: \"",
          "content_same": false
        },
        {
          "line": 2713,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "required_assignment_vector.begin()",
          "old_line_content": "    }",
          "new_line_content": "    for (auto it = required_assignment_vector.begin();",
          "content_same": false
        },
        {
          "line": 2714,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "required_assignment_vector.end()",
          "old_line_content": "  }",
          "new_line_content": "         it != required_assignment_vector.end(); ++it) {",
          "content_same": false
        },
        {
          "line": 2716,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "required_assignment_vector.erase(it)",
          "old_line_content": "}",
          "new_line_content": "        required_assignment_vector.erase(it);",
          "content_same": false
        },
        {
          "line": 2721,
          "old_api": null,
          "new_api": "ClearPendingChunks",
          "old_text": null,
          "new_text": "ClearPendingChunks()",
          "old_line_content": "                      std::vector<MemorySpaceAssignment::Allocation*>>",
          "new_line_content": "  ClearPendingChunks();",
          "content_same": false
        },
        {
          "line": 2730,
          "old_api": null,
          "new_api": "allocation_sequence",
          "old_text": null,
          "new_text": "allocation_value.allocation_sequence()",
          "old_line_content": "            inserted_allocation);",
          "new_line_content": "    for (auto& allocation : *allocation_value.allocation_sequence()) {",
          "content_same": false
        },
        {
          "line": 2731,
          "old_api": null,
          "new_api": "std::move(allocation)",
          "old_text": null,
          "new_text": "std::move(allocation)",
          "old_line_content": "      }",
          "new_line_content": "      allocations_->push_back(std::move(allocation));",
          "content_same": false
        },
        {
          "line": 2733,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "allocations_->back().get()",
          "old_line_content": "  }",
          "new_line_content": "          allocations_->back().get();",
          "content_same": false
        },
        {
          "line": 2734,
          "old_api": null,
          "new_api": "memory_space",
          "old_text": null,
          "new_text": "inserted_allocation->memory_space()",
          "old_line_content": "  // The allocations that have the same AliasedOffset need to be colocated.",
          "new_line_content": "      if (inserted_allocation->memory_space() == MemorySpace::kAlternate) {",
          "content_same": false
        },
        {
          "line": 2735,
          "old_api": null,
          "new_api": "GetAliasedOffset",
          "old_text": null,
          "new_text": "GetAliasedOffset(*inserted_allocation)",
          "old_line_content": "  // Export these to repack_allocation_blocks_ so that we can repack them to",
          "new_line_content": "        colocation_map[GetAliasedOffset(*inserted_allocation)].push_back(",
          "content_same": false
        },
        {
          "line": 2748,
          "old_api": null,
          "new_api": "end_time",
          "old_text": null,
          "new_text": "colocated_allocation->end_time()",
          "old_line_content": "    }",
          "new_line_content": "          colocated_allocation->start_time(), colocated_allocation->end_time(),",
          "content_same": false
        },
        {
          "line": 2749,
          "old_api": null,
          "new_api": "chunk",
          "old_text": null,
          "new_text": "colocated_allocation->chunk()",
          "old_line_content": "    for (MemorySpaceAssignmentRepacker::AllocationBlock* repack_block :",
          "new_line_content": "          colocated_allocation->chunk().size,",
          "content_same": false
        },
        {
          "line": 2750,
          "old_api": null,
          "new_api": "chunk",
          "old_text": null,
          "new_text": "colocated_allocation->chunk()",
          "old_line_content": "         colocations) {",
          "new_line_content": "          colocated_allocation->chunk().offset,",
          "content_same": false
        },
        {
          "line": 2751,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "repack_allocation_blocks_.size()",
          "old_line_content": "      repack_block->colocations = colocations;",
          "new_line_content": "          static_cast<int64_t>(repack_allocation_blocks_.size()),",
          "content_same": false
        },
        {
          "line": 2753,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "repack_allocation_blocks_.back()",
          "old_line_content": "  }",
          "new_line_content": "      colocations.push_back(&repack_allocation_blocks_.back());",
          "content_same": false
        },
        {
          "line": 2764,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "pending_chunks_.clear()",
          "old_line_content": "",
          "new_line_content": "  pending_chunks_.clear();",
          "content_same": false
        },
        {
          "line": 2765,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "pending_async_copies_.clear()",
          "old_line_content": "void AlternateMemoryBestFitHeap::AddToPendingChunks(",
          "new_line_content": "  pending_async_copies_.clear();",
          "content_same": false
        },
        {
          "line": 2766,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "pending_required_assignments_.clear()",
          "old_line_content": "    const BufferInterval& buffer_interval, const Chunk& chunk_candidate) {",
          "new_line_content": "  pending_required_assignments_.clear();",
          "content_same": false
        },
        {
          "line": 2768,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "aliased_offsets_.clear()",
          "old_line_content": "          << buffer_interval.end << \" : [\" << chunk_candidate.offset << \", \"",
          "new_line_content": "  aliased_offsets_.clear();",
          "content_same": false
        },
        {
          "line": 2776,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "pending_chunks_.emplace_back(buffer_interval, chunk_candidate)",
          "old_line_content": "        << buffer_interval.start << \"-\" << buffer_interval.end << \" : [\"",
          "new_line_content": "  pending_chunks_.emplace_back(buffer_interval, chunk_candidate);",
          "content_same": false
        },
        {
          "line": 2785,
          "old_api": null,
          "new_api": "CommitChunk",
          "old_text": null,
          "new_text": "CommitChunk(buffer_interval, chunk_candidate)",
          "old_line_content": "  int earliest_time;",
          "new_line_content": "  CommitChunk(buffer_interval, chunk_candidate);",
          "content_same": false
        },
        {
          "line": 2811,
          "old_api": null,
          "new_api": "GetLiveAllocationAt",
          "old_text": null,
          "new_text": "GetLiveAllocationAt(*allocation_sequence, request.end_time)",
          "old_line_content": "  const HloPosition& defining_position =",
          "new_line_content": "        GetLiveAllocationAt(*allocation_sequence, request.end_time);",
          "content_same": false
        },
        {
          "line": 2819,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(2)",
          "old_line_content": "          << \". Size = \" << request.size",
          "new_line_content": "  VLOG(2) << \"Finding allocation for \"",
          "content_same": false
        },
        {
          "line": 2826,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "defining_position.ToString()",
          "old_line_content": "            << \" use benefit = \"",
          "new_line_content": "          << \", def pos = \" << defining_position.ToString();",
          "content_same": false
        },
        {
          "line": 2828,
          "old_api": null,
          "new_api": "VLOG_IS_ON",
          "old_text": null,
          "new_text": "VLOG_IS_ON(3)",
          "old_line_content": "                   request.use->hlo_use);",
          "new_line_content": "  if (VLOG_IS_ON(3) && options_.cost_analysis) {",
          "content_same": false
        },
        {
          "line": 2829,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "  }",
          "new_line_content": "    VLOG(3) << \"Definition benefit = \"",
          "content_same": false
        },
        {
          "line": 2830,
          "old_api": null,
          "new_api": "GetAlternateMemoryBenefit",
          "old_text": null,
          "new_text": "options_.cost_analysis->GetAlternateMemoryBenefit(\n                   request.allocation_value->defining_position())",
          "old_line_content": "",
          "new_line_content": "            << options_.cost_analysis->GetAlternateMemoryBenefit(",
          "content_same": false
        },
        {
          "line": 2831,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "request.allocation_value->defining_position()",
          "old_line_content": "  // There could be a requirement to pin this buffer to default memory either",
          "new_line_content": "                   request.allocation_value->defining_position())",
          "content_same": false
        },
        {
          "line": 2833,
          "old_api": null,
          "new_api": "GetAlternateMemoryBenefit",
          "old_text": null,
          "new_text": "options_.cost_analysis->GetAlternateMemoryBenefit(\n                   request.use->hlo_use)",
          "old_line_content": "  // we're allowed to prefetch. If the use expects the output to be in default",
          "new_line_content": "            << options_.cost_analysis->GetAlternateMemoryBenefit(",
          "content_same": false
        },
        {
          "line": 2842,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "RequiredMemoryAssignmentAt(\n      request.allocation_value->value(), request.start_time)",
          "old_line_content": "  // Find required assignment both for the use and its aliases. If they are both",
          "new_line_content": "  auto required_assignment_at_start = RequiredMemoryAssignmentAt(",
          "content_same": false
        },
        {
          "line": 2843,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "request.allocation_value->value()",
          "old_line_content": "  // non-nullopt, then make sure they require the same assignment.",
          "new_line_content": "      request.allocation_value->value(), request.start_time);",
          "content_same": false
        },
        {
          "line": 2850,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "RequiredMemoryAssignmentAt(\n      request.allocation_value->value(), request.end_time)",
          "old_line_content": "      required_assignment_at_end = aliased_required_assignment_at_end;",
          "new_line_content": "  auto required_assignment_at_end = RequiredMemoryAssignmentAt(",
          "content_same": false
        },
        {
          "line": 2851,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "request.allocation_value->value()",
          "old_line_content": "    } else {",
          "new_line_content": "      request.allocation_value->value(), request.end_time);",
          "content_same": false
        },
        {
          "line": 2858,
          "old_api": null,
          "new_api": "equals_ignoring_time",
          "old_text": null,
          "new_text": "CHECK(aliased_required_assignment_at_end == std::nullopt ||\n            aliased_required_assignment_at_end->equals_ignoring_time(\n                *required_assignment_at_end))",
          "old_line_content": "  if (required_assignment_at_end) {",
          "new_line_content": "      CHECK(aliased_required_assignment_at_end == std::nullopt ||",
          "content_same": false
        },
        {
          "line": 2859,
          "old_api": null,
          "new_api": "equals_ignoring_time",
          "old_text": null,
          "new_text": "aliased_required_assignment_at_end->equals_ignoring_time(\n                *required_assignment_at_end)",
          "old_line_content": "    required_memory_space_at_end = required_assignment_at_end->memory_space;",
          "new_line_content": "            aliased_required_assignment_at_end->equals_ignoring_time(",
          "content_same": false
        },
        {
          "line": 2871,
          "old_api": null,
          "new_api": "rbegin",
          "old_text": null,
          "new_text": "std::find_if(\n          allocation_sequence->rbegin(), allocation_sequence->rend(),\n          [&](const auto& allocation) {\n            return allocation->memory_space() ==\n                       required_memory_space_at_start &&\n                   allocation->defining_position() == defining_position;\n          })",
          "old_line_content": "          });",
          "new_line_content": "      auto prev_allocation_it = std::find_if(",
          "content_same": false
        },
        {
          "line": 2874,
          "old_api": null,
          "new_api": "memory_space",
          "old_text": null,
          "new_text": "allocation->memory_space()",
          "old_line_content": "        needs_required_allocation = false;",
          "new_line_content": "            return allocation->memory_space() ==",
          "content_same": false
        },
        {
          "line": 2876,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "allocation->defining_position()",
          "old_line_content": "    }",
          "new_line_content": "                   allocation->defining_position() == defining_position;",
          "content_same": false
        },
        {
          "line": 2878,
          "old_api": null,
          "new_api": "rend",
          "old_text": null,
          "new_text": "allocation_sequence->rend()",
          "old_line_content": "      std::optional<Chunk> aliased_chunk = std::nullopt;",
          "new_line_content": "      if (prev_allocation_it != allocation_sequence->rend()) {",
          "content_same": false
        },
        {
          "line": 2879,
          "old_api": null,
          "new_api": "Extend",
          "old_text": null,
          "new_text": "*prev_allocation_it)->Extend(request.start_time)",
          "old_line_content": "      if (required_assignment_at_start->memory_space ==",
          "new_line_content": "        (*prev_allocation_it)->Extend(request.start_time);",
          "content_same": false
        },
        {
          "line": 2890,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "allocation_sequence->push_back(\n          std::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, required_assignment_at_start->memory_space,\n              aliased_chunk, request.start_time, request.start_time,\n              /*is_scoped_allocation=*/false))",
          "old_line_content": "          MemorySpace::kAlternate) {",
          "new_line_content": "      allocation_sequence->push_back(",
          "content_same": false
        },
        {
          "line": 2897,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "allocation_sequence->back()",
          "old_line_content": "  Result allocation_result = Result::kSuccess;",
          "new_line_content": "        CreateOrAddToAliasedOffset(*allocation_sequence->back(),",
          "content_same": false
        },
        {
          "line": 2923,
          "old_api": null,
          "new_api": "rend",
          "old_text": null,
          "new_text": "allocation_sequence->rend()",
          "old_line_content": "    // memory space, we also need to perform an eviction.",
          "new_line_content": "  if (prev_allocation_in_default_mem_it == allocation_sequence->rend() &&",
          "content_same": false
        },
        {
          "line": 2925,
          "old_api": null,
          "new_api": "memory_space",
          "old_text": null,
          "new_text": "*prev_allocation_it)->memory_space()",
          "old_line_content": "    if (eviction_result != Result::kSuccess) {",
          "new_line_content": "      (*prev_allocation_it)->memory_space() == MemorySpace::kAlternate &&",
          "content_same": false
        },
        {
          "line": 2926,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "*prev_allocation_it)->defining_position()",
          "old_line_content": "      // A non-success eviction requires us to uncommit previous allocations.",
          "new_line_content": "      (*prev_allocation_it)->defining_position() == defining_position &&",
          "content_same": false
        },
        {
          "line": 2933,
          "old_api": null,
          "new_api": "result_mark",
          "old_text": null,
          "new_text": "result_mark(Result::kFailRequiresUncommit, eviction_result)",
          "old_line_content": "            defining_position, MemorySpace::kDefault,",
          "new_line_content": "      return result_mark(Result::kFailRequiresUncommit, eviction_result);",
          "content_same": false
        },
        {
          "line": 2935,
          "old_api": null,
          "new_api": "rbegin",
          "old_text": null,
          "new_text": "allocation_sequence->rbegin()",
          "old_line_content": "            /*is_scoped_allocation=*/false));",
          "new_line_content": "    prev_allocation_in_default_mem_it = allocation_sequence->rbegin();",
          "content_same": false
        },
        {
          "line": 2937,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "allocation_sequence->push_back(\n        std::make_unique<MemorySpaceAssignment::Allocation>(\n            defining_position, MemorySpace::kDefault,\n            /*chunk=*/std::nullopt, request.start_time, request.end_time,\n            /*is_scoped_allocation=*/false))",
          "old_line_content": "  }",
          "new_line_content": "    allocation_sequence->push_back(",
          "content_same": false
        },
        {
          "line": 2938,
          "old_api": null,
          "new_api": "std::make_unique<MemorySpaceAssignment::Allocation>(\n            defining_position, MemorySpace::kDefault,\n            /*chunk=*/std::nullopt, request.start_time, request.end_time,\n            /*is_scoped_allocation=*/false)",
          "old_text": null,
          "new_text": "std::make_unique<MemorySpaceAssignment::Allocation>(\n            defining_position, MemorySpace::kDefault,\n            /*chunk=*/std::nullopt, request.start_time, request.end_time,\n            /*is_scoped_allocation=*/false)",
          "old_line_content": "",
          "new_line_content": "        std::make_unique<MemorySpaceAssignment::Allocation>(",
          "content_same": false
        },
        {
          "line": 2942,
          "old_api": null,
          "new_api": "rbegin",
          "old_text": null,
          "new_text": "allocation_sequence->rbegin()",
          "old_line_content": "",
          "new_line_content": "    prev_allocation_in_default_mem_it = allocation_sequence->rbegin();",
          "content_same": false
        },
        {
          "line": 2945,
          "old_api": null,
          "new_api": "rend",
          "old_text": null,
          "new_text": "allocation_sequence->rend()",
          "old_line_content": "  // to uncommit.",
          "new_line_content": "  CHECK(prev_allocation_in_default_mem_it != allocation_sequence->rend());",
          "content_same": false
        },
        {
          "line": 2953,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "required_memory_space_at_start.has_value()",
          "old_line_content": "  }",
          "new_line_content": "      required_memory_space_at_start.has_value() &&",
          "content_same": false
        },
        {
          "line": 2954,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "required_memory_space_at_end.has_value()",
          "old_line_content": "",
          "new_line_content": "      required_memory_space_at_end.has_value() &&",
          "content_same": false
        },
        {
          "line": 2956,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "  if (required_memory_space_at_end == MemorySpace::kDefault) {",
          "new_line_content": "    VLOG(3) << \"Allocation requires contiguous allocation but has memory space \"",
          "content_same": false
        },
        {
          "line": 2958,
          "old_api": null,
          "new_api": "result_mark",
          "old_text": null,
          "new_text": "result_mark(Result::kFailRequiresUncommit, allocation_result)",
          "old_line_content": "        << \"Not trying to prefetch because use requires buffer in default mem.\";",
          "new_line_content": "    return result_mark(Result::kFailRequiresUncommit, allocation_result);",
          "content_same": false
        },
        {
          "line": 2963,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "",
          "new_line_content": "    VLOG(3)",
          "content_same": false
        },
        {
          "line": 2966,
          "old_api": null,
          "new_api": "AddUse",
          "old_text": null,
          "new_text": "*prev_allocation_in_default_mem_it)->AddUse(request.use->hlo_use)",
          "old_line_content": "    Result prefetch_result =",
          "new_line_content": "    (*prev_allocation_in_default_mem_it)->AddUse(request.use->hlo_use);",
          "content_same": false
        },
        {
          "line": 2973,
          "old_api": null,
          "new_api": "Prefetch",
          "old_text": null,
          "new_text": "Prefetch(request, **prev_allocation_in_default_mem_it)",
          "old_line_content": "",
          "new_line_content": "        Prefetch(request, **prev_allocation_in_default_mem_it);",
          "content_same": false
        },
        {
          "line": 2983,
          "old_api": null,
          "new_api": "result_mark",
          "old_text": null,
          "new_text": "result_mark(Result::kFailRequiresUncommit, allocation_result)",
          "old_line_content": "  if (required_memory_space_at_start == MemorySpace::kAlternate &&",
          "new_line_content": "    return result_mark(Result::kFailRequiresUncommit, allocation_result);",
          "content_same": false
        },
        {
          "line": 2996,
          "old_api": null,
          "new_api": "Extend",
          "old_text": null,
          "new_text": "*prev_allocation_in_default_mem_it)->Extend(request.end_time)",
          "old_line_content": "    const MemorySpaceAssignment::Allocation& prev_allocation,",
          "new_line_content": "  (*prev_allocation_in_default_mem_it)->Extend(request.end_time);",
          "content_same": false
        },
        {
          "line": 2997,
          "old_api": null,
          "new_api": "AddUse",
          "old_text": null,
          "new_text": "*prev_allocation_in_default_mem_it)->AddUse(request.use->hlo_use)",
          "old_line_content": "    MemorySpace memory_space, std::optional<Chunk> chunk, int64_t start_time,",
          "new_line_content": "  (*prev_allocation_in_default_mem_it)->AddUse(request.use->hlo_use);",
          "content_same": false
        },
        {
          "line": 3008,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "          << \", estimated copy resource is \" << resource;",
          "new_line_content": "  VLOG(3) << \"Copy to \"",
          "content_same": false
        },
        {
          "line": 3015,
          "old_api": null,
          "new_api": "CHECK_LT",
          "old_text": null,
          "new_text": "CHECK_LT(start_time, copy_done_schedule_before_time)",
          "old_line_content": "",
          "new_line_content": "  CHECK_LT(start_time, copy_done_schedule_before_time);",
          "content_same": false
        },
        {
          "line": 3017,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "allocations->push_back(\n      std::make_unique<MemorySpaceAssignment::CopyAllocation>(\n          prev_allocation, memory_space, chunk, start_time, end_time,\n          copy_done_schedule_before_time, cross_program_prefetch_index))",
          "old_line_content": "  // the limit at any given time.",
          "new_line_content": "  allocations->push_back(",
          "content_same": false
        },
        {
          "line": 3028,
          "old_api": null,
          "new_api": "Add",
          "old_text": null,
          "new_text": "prefetch_interval_tree_.Add(start_time, copy_done_schedule_before_time,\n                                kDummyChunk)",
          "old_line_content": "                                kDummyChunk);",
          "new_line_content": "    prefetch_interval_tree_.Add(start_time, copy_done_schedule_before_time,",
          "content_same": false
        },
        {
          "line": 3030,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "pending_async_copies_.back()",
          "old_line_content": "  }",
          "new_line_content": "    prefetch_async_copy_resource_.AddCopy(pending_async_copies_.back());",
          "content_same": false
        },
        {
          "line": 3031,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "allocations->back()",
          "old_line_content": "}",
          "new_line_content": "    CreateOrAddToAliasedOffset(*allocations->back(), aliased_offset);",
          "content_same": false
        },
        {
          "line": 3033,
          "old_api": null,
          "new_api": "Add",
          "old_text": null,
          "new_text": "eviction_interval_tree_.Add(start_time, copy_done_schedule_before_time,\n                                kDummyChunk)",
          "old_line_content": "bool AlternateMemoryBestFitHeap::ViolatesMaximumOutstandingAsyncCopies(",
          "new_line_content": "    eviction_interval_tree_.Add(start_time, copy_done_schedule_before_time,",
          "content_same": false
        },
        {
          "line": 3035,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "pending_async_copies_.back()",
          "old_line_content": "    int64_t extra_async_copy_limit) const {",
          "new_line_content": "    eviction_async_copy_resource_.AddCopy(pending_async_copies_.back());",
          "content_same": false
        },
        {
          "line": 3058,
          "old_api": null,
          "new_api": "ChunksOverlappingInTime",
          "old_text": null,
          "new_text": "eviction_interval_tree_.ChunksOverlappingInTime(start_time, end_time)\n            .size()",
          "old_line_content": "",
          "new_line_content": "        eviction_interval_tree_.ChunksOverlappingInTime(start_time, end_time)",
          "content_same": false
        },
        {
          "line": 3070,
          "old_api": null,
          "new_api": "allocation_sequence",
          "old_text": null,
          "new_text": "request.allocation_value->allocation_sequence()->empty()",
          "old_line_content": "    // If there has been a previous allocation, we can eliminate the copy if the",
          "new_line_content": "  if (request.allocation_value->allocation_sequence()->empty()) {",
          "content_same": false
        },
        {
          "line": 3074,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "request.allocation_value->value()",
          "old_line_content": "    can_eliminate_copy =",
          "new_line_content": "        *request.allocation_value->value());",
          "content_same": false
        },
        {
          "line": 3079,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "request.allocation_value->allocation_sequence()->back().get()",
          "old_line_content": "    return Result::kFailPrevAllocationNotInAlternateMem;",
          "new_line_content": "        request.allocation_value->allocation_sequence()->back().get();",
          "content_same": false
        },
        {
          "line": 3081,
          "old_api": null,
          "new_api": "memory_space",
          "old_text": null,
          "new_text": "prev_allocation->memory_space()",
          "old_line_content": "",
          "new_line_content": "        (prev_allocation->memory_space() == MemorySpace::kAlternate);",
          "content_same": false
        },
        {
          "line": 3089,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "request.allocation_value->defining_position()",
          "old_line_content": "",
          "new_line_content": "      request.allocation_value->defining_position();",
          "content_same": false
        },
        {
          "line": 3090,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(\n          defining_position.shape(), request.start_time + 1,\n          request.end_time)",
          "old_line_content": "  BufferInterval alternate_mem_interval;",
          "new_line_content": "  if (!options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(",
          "content_same": false
        },
        {
          "line": 3097,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "request.allocation_value->value()",
          "old_line_content": "  AliasedOffset* preferred_offset = nullptr;",
          "new_line_content": "  alternate_mem_interval.buffer = request.allocation_value->value();",
          "content_same": false
        },
        {
          "line": 3105,
          "old_api": null,
          "new_api": "GetAliasedOffset",
          "old_text": null,
          "new_text": "GetAliasedOffset(*prev_allocation)",
          "old_line_content": "  if (request.preferred_offset) {",
          "new_line_content": "    preferred_offset = GetAliasedOffset(*prev_allocation);",
          "content_same": false
        },
        {
          "line": 3120,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "  //                            +-------+",
          "new_line_content": "  VLOG(3) << \"We can eliminate copy to alternate memory. Preferred offset = \"",
          "content_same": false
        },
        {
          "line": 3143,
          "old_api": null,
          "new_api": "FindBestChunkCandidate",
          "old_text": null,
          "new_text": "FindBestChunkCandidate(\n      request, preferred_offset, &alternate_mem_interval)",
          "old_line_content": "            << chunk_candidate->offset << \", size = \" << chunk_candidate->size",
          "new_line_content": "  std::optional<Chunk> chunk_candidate = FindBestChunkCandidate(",
          "content_same": false
        },
        {
          "line": 3148,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "                   request.end_time);",
          "new_line_content": "    VLOG(3) << \"Keep the buffer in alternate memory. Offset = \"",
          "content_same": false
        },
        {
          "line": 3150,
          "old_api": null,
          "new_api": "UpdatedHeapSize",
          "old_text": null,
          "new_text": "result_.UpdatedHeapSize(*chunk_candidate)",
          "old_line_content": "",
          "new_line_content": "            << \", heap_size = \" << result_.UpdatedHeapSize(*chunk_candidate)",
          "content_same": false
        },
        {
          "line": 3152,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->ToNoCopyDebugString(\n                   defining_position.shape(), request.start_time,\n                   request.end_time)",
          "old_line_content": "    // same as the previous. Otherwise, it is the operand.",
          "new_line_content": "            << options_.prefetch_interval_picker->ToNoCopyDebugString(",
          "content_same": false
        },
        {
          "line": 3153,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "defining_position.shape()",
          "old_line_content": "    if (prev_allocation != nullptr &&",
          "new_line_content": "                   defining_position.shape(), request.start_time,",
          "content_same": false
        },
        {
          "line": 3160,
          "old_api": null,
          "new_api": "is_copy_allocation",
          "old_text": null,
          "new_text": "prev_allocation->is_copy_allocation()",
          "old_line_content": "              defining_position, MemorySpace::kAlternate, chunk_candidate,",
          "new_line_content": "        (prev_allocation->is_copy_allocation() ||",
          "content_same": false
        },
        {
          "line": 3161,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "prev_allocation->defining_position()",
          "old_line_content": "              request.start_time, request.end_time,",
          "new_line_content": "         prev_allocation->defining_position() == defining_position)) {",
          "content_same": false
        },
        {
          "line": 3162,
          "old_api": null,
          "new_api": "Extend",
          "old_text": null,
          "new_text": "prev_allocation->Extend(request.end_time)",
          "old_line_content": "              /*is_scoped_allocation=*/false));",
          "new_line_content": "      prev_allocation->Extend(request.end_time);",
          "content_same": false
        },
        {
          "line": 3165,
          "old_api": null,
          "new_api": "std::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, MemorySpace::kAlternate, chunk_candidate,\n              request.start_time, request.end_time,\n              /*is_scoped_allocation=*/false)",
          "old_text": null,
          "new_text": "std::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, MemorySpace::kAlternate, chunk_candidate,\n              request.start_time, request.end_time,\n              /*is_scoped_allocation=*/false)",
          "old_line_content": "          preferred_offset);",
          "new_line_content": "          std::make_unique<MemorySpaceAssignment::Allocation>(",
          "content_same": false
        },
        {
          "line": 3169,
          "old_api": null,
          "new_api": "allocation_sequence",
          "old_text": null,
          "new_text": "CreateOrAddToAliasedOffset(\n          *request.allocation_value->allocation_sequence()->back(),\n          preferred_offset)",
          "old_line_content": "    return Result::kSuccess;",
          "new_line_content": "      CreateOrAddToAliasedOffset(",
          "content_same": false
        },
        {
          "line": 3170,
          "old_api": null,
          "new_api": "allocation_sequence",
          "old_text": null,
          "new_text": "request.allocation_value->allocation_sequence()->back()",
          "old_line_content": "  }",
          "new_line_content": "          *request.allocation_value->allocation_sequence()->back(),",
          "content_same": false
        },
        {
          "line": 3173,
          "old_api": null,
          "new_api": "allocation_sequence",
          "old_text": null,
          "new_text": "request.allocation_value->allocation_sequence()->back()->AddUse(\n        request.use->hlo_use)",
          "old_line_content": "",
          "new_line_content": "    request.allocation_value->allocation_sequence()->back()->AddUse(",
          "content_same": false
        },
        {
          "line": 3182,
          "old_api": null,
          "new_api": "allocation_sequence",
          "old_text": null,
          "new_text": "request.allocation_value->allocation_sequence()->size()",
          "old_line_content": "",
          "new_line_content": "  CHECK_GT(request.allocation_value->allocation_sequence()->size(), 0);",
          "content_same": false
        },
        {
          "line": 3186,
          "old_api": null,
          "new_api": "end_time",
          "old_text": null,
          "new_text": "prev_allocation->end_time()",
          "old_line_content": "                   eviction_start_time, request.end_time),",
          "new_line_content": "  int64_t eviction_end_time = prev_allocation->end_time();",
          "content_same": false
        },
        {
          "line": 3187,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(eviction_start_time <= eviction_end_time)",
          "old_line_content": "               eviction_end_time);",
          "new_line_content": "  CHECK(eviction_start_time <= eviction_end_time);",
          "content_same": false
        },
        {
          "line": 3191,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "request.allocation_value->defining_position().shape()",
          "old_line_content": "",
          "new_line_content": "                   request.allocation_value->defining_position().shape(),",
          "content_same": false
        },
        {
          "line": 3196,
          "old_api": null,
          "new_api": "std::min(preferred_eviction_end_time, request.latest_prefetch_time)",
          "old_text": null,
          "new_text": "std::min(preferred_eviction_end_time, request.latest_prefetch_time)",
          "old_line_content": "  // preferred eviction end time.",
          "new_line_content": "      std::min(preferred_eviction_end_time, request.latest_prefetch_time);",
          "content_same": false
        },
        {
          "line": 3205,
          "old_api": null,
          "new_api": "chunk",
          "old_text": null,
          "new_text": "prev_allocation->chunk()",
          "old_line_content": "    Chunk chunk_candidate =",
          "new_line_content": "  int64_t preferred_offset = prev_allocation->chunk().offset;",
          "content_same": false
        },
        {
          "line": 3212,
          "old_api": null,
          "new_api": "FindChunkCandidate",
          "old_text": null,
          "new_text": "FindChunkCandidate(eviction_mem_interval, preferred_offset)",
          "old_line_content": "  eviction_end_time = eviction_mem_interval.end;",
          "new_line_content": "        FindChunkCandidate(eviction_mem_interval, preferred_offset);",
          "content_same": false
        },
        {
          "line": 3226,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "request.allocation_value->defining_position().shape()",
          "old_line_content": "          eviction_start_time, eviction_end_time, eviction_resource);",
          "new_line_content": "                request.allocation_value->defining_position().shape())",
          "content_same": false
        },
        {
          "line": 3237,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "  }",
          "new_line_content": "      VLOG(3) << \"Violates resource in last retry, setting resource = 0\";",
          "content_same": false
        },
        {
          "line": 3241,
          "old_api": null,
          "new_api": "HasEnoughResource",
          "old_text": null,
          "new_text": "eviction_async_copy_resource_.HasEnoughResource(\n            eviction_start_time, eviction_end_time, eviction_resource)",
          "old_line_content": "                                            /*is_prefetch=*/false);",
          "new_line_content": "        !eviction_async_copy_resource_.HasEnoughResource(",
          "content_same": false
        },
        {
          "line": 3245,
          "old_api": null,
          "new_api": "ViolatesMaximumOutstandingAsyncCopies",
          "old_text": null,
          "new_text": "ViolatesMaximumOutstandingAsyncCopies(eviction_start_time,\n                                            eviction_end_time,\n                                            /*is_prefetch=*/false)",
          "old_line_content": "      !eviction_violates_resource) {",
          "new_line_content": "      ViolatesMaximumOutstandingAsyncCopies(eviction_start_time,",
          "content_same": false
        },
        {
          "line": 3252,
          "old_api": null,
          "new_api": "Extend",
          "old_text": null,
          "new_text": "prev_allocation->Extend(eviction_end_time)",
          "old_line_content": "  } else {",
          "new_line_content": "    prev_allocation->Extend(eviction_end_time);",
          "content_same": false
        },
        {
          "line": 3253,
          "old_api": null,
          "new_api": "end_time",
          "old_text": null,
          "new_text": "AddAsyncCopy(*prev_allocation, MemorySpace::kDefault,\n                 /*chunk=*/std::nullopt, eviction_start_time,\n                 prev_allocation->end_time(), eviction_end_time,\n                 request.allocation_value->allocation_sequence(),\n                 /*aliased_offset=*/nullptr, eviction_resource)",
          "old_line_content": "    if (eviction_violates_outstanding_copies) {",
          "new_line_content": "    AddAsyncCopy(*prev_allocation, MemorySpace::kDefault,",
          "content_same": false
        },
        {
          "line": 3255,
          "old_api": null,
          "new_api": "end_time",
          "old_text": null,
          "new_text": "prev_allocation->end_time()",
          "old_line_content": "    } else if (eviction_violates_resource) {",
          "new_line_content": "                 prev_allocation->end_time(), eviction_end_time,",
          "content_same": false
        },
        {
          "line": 3260,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "    }",
          "new_line_content": "      VLOG(3) << \"This violates the maximum async copies.\";",
          "content_same": false
        },
        {
          "line": 3262,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "    // this interval.",
          "new_line_content": "      VLOG(3) << \"This violates resource.\";",
          "content_same": false
        },
        {
          "line": 3264,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "",
          "new_line_content": "      VLOG(3) << \"Eviction interval is too short (\" << eviction_start_time",
          "content_same": false
        },
        {
          "line": 3277,
          "old_api": null,
          "new_api": "flattened_instruction_sequence",
          "old_text": null,
          "new_text": "hlo_live_range_.flattened_instruction_sequence()\n                     .instructions()",
          "old_line_content": "      return Result::kFailOutOfAsyncCopies;",
          "new_line_content": "              << hlo_live_range_.flattened_instruction_sequence()",
          "content_same": false
        },
        {
          "line": 3280,
          "old_api": null,
          "new_api": "flattened_instruction_sequence",
          "old_text": null,
          "new_text": "hlo_live_range_.flattened_instruction_sequence()\n                     .instructions()",
          "old_line_content": "  // return true;",
          "new_line_content": "              << hlo_live_range_.flattened_instruction_sequence()",
          "content_same": false
        },
        {
          "line": 3314,
          "old_api": null,
          "new_api": "std::max(earliest_prefetch_time, *request.earliest_prefetch_time)",
          "old_text": null,
          "new_text": "std::max(earliest_prefetch_time, *request.earliest_prefetch_time)",
          "old_line_content": "  // allocation times that would push us to OOM.",
          "new_line_content": "        std::max(earliest_prefetch_time, *request.earliest_prefetch_time);",
          "content_same": false
        },
        {
          "line": 3317,
          "old_api": null,
          "new_api": "FindPrefetchEndTime",
          "old_text": null,
          "new_text": "FindPrefetchEndTime(request, earliest_prefetch_time)",
          "old_line_content": "                                          prefetch_end_time, request.size);",
          "new_line_content": "      FindPrefetchEndTime(request, earliest_prefetch_time);",
          "content_same": false
        },
        {
          "line": 3322,
          "old_api": null,
          "new_api": "FindEarliestTimeToSatisfyPeakMemory",
          "old_text": null,
          "new_text": "FindEarliestTimeToSatisfyPeakMemory(earliest_prefetch_time,\n                                          prefetch_end_time, request.size)",
          "old_line_content": "            << \" would go out of memory.\";",
          "new_line_content": "      FindEarliestTimeToSatisfyPeakMemory(earliest_prefetch_time,",
          "content_same": false
        },
        {
          "line": 3329,
          "old_api": null,
          "new_api": "result_mark",
          "old_text": null,
          "new_text": "result_mark(Result::kFailOutOfMemory, result)",
          "old_line_content": "  earliest_prefetch_time = *earliest_non_oom_prefetch_time;",
          "new_line_content": "    result_mark(Result::kFailOutOfMemory, result);",
          "content_same": false
        },
        {
          "line": 3336,
          "old_api": null,
          "new_api": "Begin",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->Begin(\n      request.use->hlo_use, earliest_prefetch_time, prefetch_end_time)",
          "old_line_content": "  // possible position, given by max_prefetch_interval.",
          "new_line_content": "  options_.prefetch_interval_picker->Begin(",
          "content_same": false
        },
        {
          "line": 3339,
          "old_api": null,
          "new_api": "ToDebugString",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->ToDebugString()",
          "old_line_content": "  alternate_mem_interval.size = request.size;",
          "new_line_content": "          << options_.prefetch_interval_picker->ToDebugString();",
          "content_same": false
        },
        {
          "line": 3351,
          "old_api": null,
          "new_api": "FindBestChunkCandidate",
          "old_text": null,
          "new_text": "FindBestChunkCandidate(\n      request, request.preferred_offset, &alternate_mem_interval)",
          "old_line_content": "    return result;",
          "new_line_content": "  auto chunk_candidate = FindBestChunkCandidate(",
          "content_same": false
        },
        {
          "line": 3356,
          "old_api": null,
          "new_api": "result_mark",
          "old_text": null,
          "new_text": "result_mark(Result::kFailOutOfMemory, result)",
          "old_line_content": "  // While uses might be allowed to have additional outstanding prefetches.",
          "new_line_content": "    result_mark(Result::kFailOutOfMemory, result);",
          "content_same": false
        },
        {
          "line": 3360,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "ShapeUtil::GetSubshape(\n      use.instruction->operand(use.operand_number)->shape(), use.operand_index)",
          "old_line_content": "          : 0;",
          "new_line_content": "  const Shape& shape = ShapeUtil::GetSubshape(",
          "content_same": false
        },
        {
          "line": 3361,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "use.instruction->operand(use.operand_number)->shape()",
          "old_line_content": "  // As a compilation time optimization, store the prefetch start time where we",
          "new_line_content": "      use.instruction->operand(use.operand_number)->shape(), use.operand_index);",
          "content_same": false
        },
        {
          "line": 3364,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "request.use->hlo_use.instruction->opcode()",
          "old_line_content": "  std::optional<int64_t> out_of_mem_start;",
          "new_line_content": "      request.use->hlo_use.instruction->opcode() == HloOpcode::kWhile",
          "content_same": false
        },
        {
          "line": 3372,
          "old_api": null,
          "new_api": "Next",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->Next()",
          "old_line_content": "      continue;",
          "new_line_content": "    alternate_mem_interval.start = options_.prefetch_interval_picker->Next();",
          "content_same": false
        },
        {
          "line": 3373,
          "old_api": null,
          "new_api": "CHECK_LT",
          "old_text": null,
          "new_text": "CHECK_LT(alternate_mem_interval.start, prefetch_end_time)",
          "old_line_content": "    }",
          "new_line_content": "    CHECK_LT(alternate_mem_interval.start, prefetch_end_time);",
          "content_same": false
        },
        {
          "line": 3374,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "out_of_mem_start.has_value()",
          "old_line_content": "    int64_t estimated_prefetch_end_time =",
          "new_line_content": "    if (out_of_mem_start.has_value() &&",
          "content_same": false
        },
        {
          "line": 3376,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "            shape, alternate_mem_interval.start, prefetch_end_time);",
          "new_line_content": "      VLOG(4) << \"This would OOM (cached).\";",
          "content_same": false
        },
        {
          "line": 3381,
          "old_api": null,
          "new_api": "EstimatedPrefetchEndTime",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->EstimatedPrefetchEndTime(\n            shape, alternate_mem_interval.start, prefetch_end_time)",
          "old_line_content": "    float prefetch_resource =",
          "new_line_content": "        options_.prefetch_interval_picker->EstimatedPrefetchEndTime(",
          "content_same": false
        },
        {
          "line": 3389,
          "old_api": null,
          "new_api": "GetAsyncCopyElapsed",
          "old_text": null,
          "new_text": "options_.cost_analysis->GetAsyncCopyElapsed(shape)",
          "old_line_content": "              << prefetch_resource;",
          "new_line_content": "            ? options_.cost_analysis->GetAsyncCopyElapsed(shape)",
          "content_same": false
        },
        {
          "line": 3391,
          "old_api": null,
          "new_api": "HasEnoughResource",
          "old_text": null,
          "new_text": "prefetch_async_copy_resource_.HasEnoughResource(\n            alternate_mem_interval.start, prefetch_end_time,\n            prefetch_resource)",
          "old_line_content": "      continue;",
          "new_line_content": "    if (!prefetch_async_copy_resource_.HasEnoughResource(",
          "content_same": false
        },
        {
          "line": 3394,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "            alternate_mem_interval.start, prefetch_end_time,",
          "new_line_content": "      VLOG(4) << \"This would violate asynchronous copy resource = \"",
          "content_same": false
        },
        {
          "line": 3399,
          "old_api": null,
          "new_api": "ViolatesMaximumOutstandingAsyncCopies",
          "old_text": null,
          "new_text": "ViolatesMaximumOutstandingAsyncCopies(\n            alternate_mem_interval.start, prefetch_end_time,\n            /*is_prefetch=*/true, extra_async_copy_limit)",
          "old_line_content": "    }",
          "new_line_content": "    if (ViolatesMaximumOutstandingAsyncCopies(",
          "content_same": false
        },
        {
          "line": 3402,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(4)",
          "old_line_content": "        request, request.preferred_offset, &alternate_mem_interval);",
          "new_line_content": "      VLOG(4) << \"This would violate the outstanding async copy limit.\";",
          "content_same": false
        },
        {
          "line": 3403,
          "old_api": null,
          "new_api": "result_mark",
          "old_text": null,
          "new_text": "result_mark(Result::kFailOutOfAsyncCopies, result)",
          "old_line_content": "    // Check if we could find a suitable chunk.",
          "new_line_content": "      result_mark(Result::kFailOutOfAsyncCopies, result);",
          "content_same": false
        },
        {
          "line": 3407,
          "old_api": null,
          "new_api": "FindBestChunkCandidate",
          "old_text": null,
          "new_text": "FindBestChunkCandidate(\n        request, request.preferred_offset, &alternate_mem_interval)",
          "old_line_content": "              << \". Offset = \" << chunk_candidate->offset",
          "new_line_content": "    auto chunk_candidate = FindBestChunkCandidate(",
          "content_same": false
        },
        {
          "line": 3415,
          "old_api": null,
          "new_api": "UpdatedHeapSize",
          "old_text": null,
          "new_text": "result_.UpdatedHeapSize(*chunk_candidate)",
          "old_line_content": "                   chunk_candidate, alternate_mem_interval.start,",
          "new_line_content": "              << \", heap_size = \" << result_.UpdatedHeapSize(*chunk_candidate)",
          "content_same": false
        },
        {
          "line": 3418,
          "old_api": null,
          "new_api": "AddToPendingChunks",
          "old_text": null,
          "new_text": "AddToPendingChunks(alternate_mem_interval, *chunk_candidate)",
          "old_line_content": "                   request.preferred_offset, prefetch_resource);",
          "new_line_content": "      AddToPendingChunks(alternate_mem_interval, *chunk_candidate);",
          "content_same": false
        },
        {
          "line": 3423,
          "old_api": null,
          "new_api": "allocation_sequence",
          "old_text": null,
          "new_text": "request.allocation_value->allocation_sequence()",
          "old_line_content": "    } else {",
          "new_line_content": "                   request.allocation_value->allocation_sequence(),",
          "content_same": false
        },
        {
          "line": 3426,
          "old_api": null,
          "new_api": "allocation_sequence",
          "old_text": null,
          "new_text": "request.allocation_value->allocation_sequence()->back()->AddUse(\n          request.use->hlo_use)",
          "old_line_content": "      out_of_mem_start =",
          "new_line_content": "      request.allocation_value->allocation_sequence()->back()->AddUse(",
          "content_same": false
        },
        {
          "line": 3433,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "out_of_mem_start.has_value()",
          "old_line_content": "  // short.",
          "new_line_content": "          std::max(out_of_mem_start.has_value() ? *out_of_mem_start : -1,",
          "content_same": false
        },
        {
          "line": 3436,
          "old_api": null,
          "new_api": "result_mark",
          "old_text": null,
          "new_text": "result_mark(Result::kFailOutOfMemory, result)",
          "old_line_content": "  } else {",
          "new_line_content": "    result_mark(Result::kFailOutOfMemory, result);",
          "content_same": false
        },
        {
          "line": 3455,
          "old_api": null,
          "new_api": "absl::c_lower_bound(use_times, end_time)",
          "old_text": null,
          "new_text": "absl::c_lower_bound(use_times, end_time)",
          "old_line_content": "    // copies.",
          "new_line_content": "    auto use_time_it = absl::c_lower_bound(use_times, end_time);",
          "content_same": false
        },
        {
          "line": 3462,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "request.allocation_value->defining_position().shape()",
          "old_line_content": "    }",
          "new_line_content": "    const Shape& shape = request.allocation_value->defining_position().shape();",
          "content_same": false
        },
        {
          "line": 3464,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "use_times.end()",
          "old_line_content": "    int64_t latest_contiguous_use_time = *use_time_it;",
          "new_line_content": "         (use_time_it + 1) != use_times.end() &&",
          "content_same": false
        },
        {
          "line": 3465,
          "old_api": null,
          "new_api": "CanAllocateInAlternateMemoryNoCopy",
          "old_text": null,
          "new_text": "options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(\n             shape, *use_time_it, *(use_time_it + 1))",
          "old_line_content": "",
          "new_line_content": "         options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(",
          "content_same": false
        },
        {
          "line": 3474,
          "old_api": null,
          "new_api": "std::numeric_limits<int64_t>::min()",
          "old_text": null,
          "new_text": "std::numeric_limits<int64_t>::min()",
          "old_line_content": "            if (use > latest_matching_use) {",
          "new_line_content": "    int64_t latest_matching_use = std::numeric_limits<int64_t>::min();",
          "content_same": false
        },
        {
          "line": 3475,
          "old_api": null,
          "new_api": "chunk_end",
          "old_text": null,
          "new_text": "std::lower_bound(\n        earliest_use_it, std::next(use_time_it), -1, [&](int64_t use, int64_t) {\n          alternate_mem_interval->end = use;\n          Chunk chunk_candidate = FindChunkCandidate(*alternate_mem_interval);\n          if (chunk_candidate.chunk_end() <= available_heap_size()) {\n            if (use > latest_matching_use) {\n              last_chunk_candidate = chunk_candidate;\n              latest_matching_use = use;\n            }\n            return true;\n          }\n          return false;\n        })",
          "old_line_content": "              last_chunk_candidate = chunk_candidate;",
          "new_line_content": "    (void)std::lower_bound(",
          "content_same": false
        },
        {
          "line": 3476,
          "old_api": null,
          "new_api": "std::next(use_time_it)",
          "old_text": null,
          "new_text": "std::next(use_time_it)",
          "old_line_content": "              latest_matching_use = use;",
          "new_line_content": "        earliest_use_it, std::next(use_time_it), -1, [&](int64_t use, int64_t) {",
          "content_same": false
        },
        {
          "line": 3478,
          "old_api": null,
          "new_api": "FindChunkCandidate",
          "old_text": null,
          "new_text": "FindChunkCandidate(*alternate_mem_interval)",
          "old_line_content": "            return true;",
          "new_line_content": "          Chunk chunk_candidate = FindChunkCandidate(*alternate_mem_interval);",
          "content_same": false
        },
        {
          "line": 3479,
          "old_api": null,
          "new_api": "available_heap_size",
          "old_text": null,
          "new_text": "available_heap_size()",
          "old_line_content": "          }",
          "new_line_content": "          if (chunk_candidate.chunk_end() <= available_heap_size()) {",
          "content_same": false
        },
        {
          "line": 3488,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "last_chunk_candidate.has_value()",
          "old_line_content": "    alternate_mem_interval->end = end_time;",
          "new_line_content": "    if (last_chunk_candidate.has_value()) {",
          "content_same": false
        },
        {
          "line": 3489,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "    return last_chunk_candidate;",
          "new_line_content": "      VLOG(3) << \"FindBestChunkCandidate earliest use = \" << earliest_use",
          "content_same": false
        },
        {
          "line": 3501,
          "old_api": null,
          "new_api": "FindChunkCandidate",
          "old_text": null,
          "new_text": "FindChunkCandidate(*alternate_mem_interval, preferred_offset->offset)",
          "old_line_content": "",
          "new_line_content": "      FindChunkCandidate(*alternate_mem_interval, preferred_offset->offset);",
          "content_same": false
        },
        {
          "line": 3517,
          "old_api": null,
          "new_api": "TF_ASSIGN_OR_RETURN",
          "old_text": null,
          "new_text": "TF_ASSIGN_OR_RETURN(std::unique_ptr<HloDataflowAnalysis> dataflow_analysis,\n                      HloDataflowAnalysis::Run(*module_))",
          "old_line_content": "        current_copies++;",
          "new_line_content": "  TF_ASSIGN_OR_RETURN(std::unique_ptr<HloDataflowAnalysis> dataflow_analysis,",
          "content_same": false
        },
        {
          "line": 3520,
          "old_api": null,
          "new_api": "MakeNonfusionComputations",
          "old_text": null,
          "new_text": "module_->MakeNonfusionComputations()",
          "old_line_content": "        int64_t size =",
          "new_line_content": "       module_->MakeNonfusionComputations()) {",
          "content_same": false
        },
        {
          "line": 3524,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "          ++stats.num_prefetches;",
          "new_line_content": "      } else if (instruction->opcode() == HloOpcode::kCopyDone) {",
          "content_same": false
        },
        {
          "line": 3527,
          "old_api": null,
          "new_api": "GetUniqueValueAt",
          "old_text": null,
          "new_text": "dataflow_analysis->GetUniqueValueAt(instruction)",
          "old_line_content": "          ++stats.num_evictions;",
          "new_line_content": "            options_.size_fn(dataflow_analysis->GetUniqueValueAt(instruction));",
          "content_same": false
        },
        {
          "line": 3528,
          "old_api": null,
          "new_api": "layout",
          "old_text": null,
          "new_text": "instruction->shape().layout().memory_space()",
          "old_line_content": "          stats.eviction_bytes += size;",
          "new_line_content": "        if (instruction->shape().layout().memory_space() ==",
          "content_same": false
        },
        {
          "line": 3538,
          "old_api": null,
          "new_api": "std::max(stats.max_outstanding_async_copies, current_copies)",
          "old_text": null,
          "new_text": "std::max(stats.max_outstanding_async_copies, current_copies)",
          "old_line_content": "/*static*/ MemorySpaceAssignment::BufferIntervalCompare",
          "new_line_content": "          std::max(stats.max_outstanding_async_copies, current_copies);",
          "content_same": false
        },
        {
          "line": 3551,
          "old_api": null,
          "new_api": "GetMemoryBoundedness",
          "old_text": null,
          "new_text": "cost_analysis.GetMemoryBoundedness(y, cache)",
          "old_line_content": "        HloValue>::GetSpatialBufferIntervalCompare()(x, y);",
          "new_line_content": "    float y_memory_boundedness = cost_analysis.GetMemoryBoundedness(y, cache);",
          "content_same": false
        },
        {
          "line": 3556,
          "old_api": null,
          "new_api": "GlobalDecreasingSizeBestFitHeap<\n        HloValue>::GetSpatialBufferIntervalCompare()(x, y)",
          "old_text": null,
          "new_text": "GlobalDecreasingSizeBestFitHeap<\n        HloValue>::GetSpatialBufferIntervalCompare()(x, y)",
          "old_line_content": "MemorySpaceAssignment::Run(HloModule* module,",
          "new_line_content": "    return GlobalDecreasingSizeBestFitHeap<",
          "content_same": false
        },
        {
          "line": 3566,
          "old_api": null,
          "new_api": "has_schedule",
          "old_text": null,
          "new_text": "module->has_schedule()",
          "old_line_content": "",
          "new_line_content": "  CHECK(module->has_schedule());",
          "content_same": false
        },
        {
          "line": 3568,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "module->ToString()",
          "old_line_content": "                                                          alias_analysis);",
          "new_line_content": "  XLA_VLOG_LINES(3, module->ToString());",
          "content_same": false
        },
        {
          "line": 3569,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "module->schedule().ToString()",
          "old_line_content": "}",
          "new_line_content": "  VLOG(3) << \"Schedule: \" << module->schedule().ToString();",
          "content_same": false
        },
        {
          "line": 3573,
          "old_api": null,
          "new_api": "RunMemorySpaceAssignment",
          "old_text": null,
          "new_text": "memory_space_assignment.RunMemorySpaceAssignment(hlo_live_range,\n                                                          alias_analysis)",
          "old_line_content": "    const HloLiveRange& hlo_live_range,",
          "new_line_content": "  return memory_space_assignment.RunMemorySpaceAssignment(hlo_live_range,",
          "content_same": false
        },
        {
          "line": 3581,
          "old_api": null,
          "new_api": "FindAllocationSequence",
          "old_text": null,
          "new_text": "FindAllocationSequence(hlo_live_range, alias_analysis)",
          "old_line_content": "  }",
          "new_line_content": "  TF_RETURN_IF_ERROR(FindAllocationSequence(hlo_live_range, alias_analysis));",
          "content_same": false
        },
        {
          "line": 3592,
          "old_api": null,
          "new_api": "FixSchedule",
          "old_text": null,
          "new_text": "FixSchedule()",
          "old_line_content": "  TF_ASSIGN_OR_RETURN(AsyncCopyStats stats, CalculateAsyncCopyStats());",
          "new_line_content": "  TF_RETURN_IF_ERROR(FixSchedule());",
          "content_same": false
        },
        {
          "line": 3596,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "module_->ToString()",
          "old_line_content": "          << \", in bytes: \" << stats.prefetch_bytes;",
          "new_line_content": "  XLA_VLOG_LINES(3, module_->ToString());",
          "content_same": false
        },
        {
          "line": 3599,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "",
          "new_line_content": "  VLOG(1) << \"Maximum number of outstanding async copies: \"",
          "content_same": false
        },
        {
          "line": 3601,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "",
          "new_line_content": "  VLOG(1) << \"Number of prefetches: \" << stats.num_prefetches",
          "content_same": false
        },
        {
          "line": 3603,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "}",
          "new_line_content": "  VLOG(1) << \"Number of evictions: \" << stats.num_evictions",
          "content_same": false
        },
        {
          "line": 3606,
          "old_api": null,
          "new_api": "VerifyAndExportHeapSimulatorTrace",
          "old_text": null,
          "new_text": "VerifyAndExportHeapSimulatorTrace()",
          "old_line_content": "    const HloLiveRange& hlo_live_range,",
          "new_line_content": "  TF_RETURN_IF_ERROR(VerifyAndExportHeapSimulatorTrace());",
          "content_same": false
        },
        {
          "line": 3620,
          "old_api": null,
          "new_api": "std::move(algorithm)",
          "old_text": null,
          "new_text": "std::move(algorithm)",
          "old_line_content": "}",
          "new_line_content": "  TF_RETURN_IF_ERROR(HeapSimulator::Run(std::move(algorithm), *module_,",
          "content_same": false
        },
        {
          "line": 3621,
          "old_api": null,
          "new_api": "schedule",
          "old_text": null,
          "new_text": "module_->schedule()",
          "old_line_content": "",
          "new_line_content": "                                        module_->schedule(), alias_analysis,",
          "content_same": false
        },
        {
          "line": 3625,
          "old_api": null,
          "new_api": "OkStatus",
          "old_text": null,
          "new_text": "OkStatus()",
          "old_line_content": "  // If the use is a tuple, look inside the tuple to find the actual use.",
          "new_line_content": "  return OkStatus();",
          "content_same": false
        },
        {
          "line": 3633,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "operand->opcode()",
          "old_line_content": "  // Look beyond GetTupleElement(Tuple()) pattern for any bitcasts.",
          "new_line_content": "    if (operand->opcode() != HloOpcode::kTuple) {",
          "content_same": false
        },
        {
          "line": 3642,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "instruction->opcode()",
          "old_line_content": "        return instruction;",
          "new_line_content": "    while (instruction->opcode() == HloOpcode::kGetTupleElement) {",
          "content_same": false
        },
        {
          "line": 3644,
          "old_api": null,
          "new_api": "mutable_operand",
          "old_text": null,
          "new_text": "instruction->mutable_operand(0)",
          "old_line_content": "    }",
          "new_line_content": "          get_simplified_operand(instruction->mutable_operand(0));",
          "content_same": false
        },
        {
          "line": 3645,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "operand->opcode()",
          "old_line_content": "    return instruction;",
          "new_line_content": "      if (operand->opcode() == HloOpcode::kTuple) {",
          "content_same": false
        },
        {
          "line": 3646,
          "old_api": null,
          "new_api": "tuple_index",
          "old_text": null,
          "new_text": "instruction->tuple_index()",
          "old_line_content": "  };",
          "new_line_content": "        instruction = operand->mutable_operand(instruction->tuple_index());",
          "content_same": false
        },
        {
          "line": 3653,
          "old_api": null,
          "new_api": "get_simplified_operand",
          "old_text": null,
          "new_text": "get_simplified_operand(operand)",
          "old_line_content": "    const HloLiveRange& hlo_live_range, const AllocationSequence& allocations) {",
          "new_line_content": "  operand = get_simplified_operand(operand);",
          "content_same": false
        },
        {
          "line": 3655,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "uses_.push_back(use)",
          "old_line_content": "      outputs_in_alternate_memory_map;",
          "new_line_content": "  uses_.push_back(use);",
          "content_same": false
        },
        {
          "line": 3667,
          "old_api": null,
          "new_api": "is_copy_allocation",
          "old_text": null,
          "new_text": "allocation->is_copy_allocation()",
          "old_line_content": "      }",
          "new_line_content": "    if (!allocation->is_copy_allocation()) {",
          "content_same": false
        },
        {
          "line": 3668,
          "old_api": null,
          "new_api": "memory_space",
          "old_text": null,
          "new_text": "allocation->memory_space()",
          "old_line_content": "    }",
          "new_line_content": "      if (allocation->memory_space() == MemorySpace::kAlternate) {",
          "content_same": false
        },
        {
          "line": 3670,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "allocation->defining_position()",
          "old_line_content": "      const HloInstruction* use_instruction = hlo_use.instruction;",
          "new_line_content": "            allocation->defining_position().instruction;",
          "content_same": false
        },
        {
          "line": 3675,
          "old_api": null,
          "new_api": "uses",
          "old_text": null,
          "new_text": "allocation->uses()",
          "old_line_content": "",
          "new_line_content": "    for (auto& hlo_use : allocation->uses()) {",
          "content_same": false
        },
        {
          "line": 3678,
          "old_api": null,
          "new_api": "std::make_pair(hlo_use.operand_number, hlo_use.operand_index)",
          "old_text": null,
          "new_text": "std::make_pair(hlo_use.operand_number, hlo_use.operand_index)",
          "old_line_content": "  float total_elapsed = 0.0;",
          "new_line_content": "          std::make_pair(hlo_use.operand_number, hlo_use.operand_index));",
          "content_same": false
        },
        {
          "line": 3683,
          "old_api": null,
          "new_api": "flattened_instruction_sequence",
          "old_text": null,
          "new_text": "hlo_live_range.flattened_instruction_sequence().instructions()",
          "old_line_content": "      outputs_in_alternate_memory = output_it->second;",
          "new_line_content": "      hlo_live_range.flattened_instruction_sequence().instructions();",
          "content_same": false
        },
        {
          "line": 3688,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "outputs_in_alternate_memory_map.end()",
          "old_line_content": "      operands_in_alternate_memory = operand_it->second;",
          "new_line_content": "    if (output_it != outputs_in_alternate_memory_map.end()) {",
          "content_same": false
        },
        {
          "line": 3692,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "operands_in_alternate_memory_map.find(instruction)",
          "old_line_content": "            *instruction, operands_in_alternate_memory,",
          "new_line_content": "    auto operand_it = operands_in_alternate_memory_map.find(instruction);",
          "content_same": false
        },
        {
          "line": 3693,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "operands_in_alternate_memory_map.end()",
          "old_line_content": "            outputs_in_alternate_memory);",
          "new_line_content": "    if (operand_it != operands_in_alternate_memory_map.end()) {",
          "content_same": false
        },
        {
          "line": 3697,
          "old_api": null,
          "new_api": "GetInstructionElapsedInAlternateMemory",
          "old_text": null,
          "new_text": "options_.cost_analysis->GetInstructionElapsedInAlternateMemory(\n            *instruction, operands_in_alternate_memory,\n            outputs_in_alternate_memory)",
          "old_line_content": "            instruction,",
          "new_line_content": "        options_.cost_analysis->GetInstructionElapsedInAlternateMemory(",
          "content_same": false
        },
        {
          "line": 3700,
          "old_api": null,
          "new_api": "CalculateComputationNestLevel",
          "old_text": null,
          "new_text": "IPow<float>(\n        options_.xla_tpu_memory_space_assignment_while_execution_count,\n        options_.cost_analysis->CalculateComputationNestLevel(\n            instruction,\n            /*while_only=*/true))",
          "old_line_content": "  }",
          "new_line_content": "    float while_nest_multiplier = IPow<float>(",
          "content_same": false
        },
        {
          "line": 3702,
          "old_api": null,
          "new_api": "CalculateComputationNestLevel",
          "old_text": null,
          "new_text": "options_.cost_analysis->CalculateComputationNestLevel(\n            instruction,\n            /*while_only=*/true)",
          "old_line_content": "}",
          "new_line_content": "        options_.cost_analysis->CalculateComputationNestLevel(",
          "content_same": false
        },
        {
          "line": 3711,
          "old_api": null,
          "new_api": "is_scoped_allocation",
          "old_text": null,
          "new_text": "is_scoped_allocation()",
          "old_line_content": "  for (const HloUse& use : uses_) {",
          "new_line_content": "  if (is_scoped_allocation()) {",
          "content_same": false
        },
        {
          "line": 3713,
          "old_api": null,
          "new_api": "OkStatus",
          "old_text": null,
          "new_text": "OkStatus()",
          "old_line_content": "    HloInstruction* replacement_instruction = producing_instruction;",
          "new_line_content": "    return OkStatus();",
          "content_same": false
        },
        {
          "line": 3716,
          "old_api": null,
          "new_api": "parent",
          "old_text": null,
          "new_text": "producing_instruction->parent()",
          "old_line_content": "          replacement_instruction,",
          "new_line_content": "  HloComputation* computation = producing_instruction->parent();",
          "content_same": false
        },
        {
          "line": 3718,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "use.instruction->operand(use.operand_number)->shape()",
          "old_line_content": "              producing_instruction,",
          "new_line_content": "    Shape operand_shape = use.instruction->operand(use.operand_number)->shape();",
          "content_same": false
        },
        {
          "line": 3720,
          "old_api": null,
          "new_api": "IsTuple",
          "old_text": null,
          "new_text": "operand_shape.IsTuple()",
          "old_line_content": "              use.operand_index));",
          "new_line_content": "    if (operand_shape.IsTuple()) {",
          "content_same": false
        },
        {
          "line": 3727,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "producing_instruction->shape()",
          "old_line_content": "    }",
          "new_line_content": "    } else if (operand_shape != producing_instruction->shape()) {",
          "content_same": false
        },
        {
          "line": 3729,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "producing_instruction->shape().ToString()",
          "old_line_content": "        use.operand_number, replacement_instruction));",
          "new_line_content": "              << \", new shape = \" << producing_instruction->shape().ToString()",
          "content_same": false
        },
        {
          "line": 3732,
          "old_api": null,
          "new_api": "HloInstruction::CreateBitcast(operand_shape, producing_instruction)",
          "old_text": null,
          "new_text": "HloInstruction::CreateBitcast(operand_shape, producing_instruction)",
          "old_line_content": "}",
          "new_line_content": "          HloInstruction::CreateBitcast(operand_shape, producing_instruction));",
          "content_same": false
        },
        {
          "line": 3734,
          "old_api": null,
          "new_api": "ReplaceOperandWith",
          "old_text": null,
          "new_text": "use.instruction->ReplaceOperandWith(\n        use.operand_number, replacement_instruction)",
          "old_line_content": "HloInstruction* MemorySpaceAssignment::Allocation::AddGetTupleElements() const {",
          "new_line_content": "    TF_RETURN_IF_ERROR(use.instruction->ReplaceOperandWith(",
          "content_same": false
        },
        {
          "line": 3743,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "defining_position().shape()",
          "old_line_content": "",
          "new_line_content": "  Shape shape = defining_position().shape();",
          "content_same": false
        },
        {
          "line": 3744,
          "old_api": null,
          "new_api": "IsArray",
          "old_text": null,
          "new_text": "shape.IsArray()",
          "old_line_content": "std::string MemorySpaceAssignment::Allocation::ToString() const {",
          "new_line_content": "  CHECK(shape.IsArray()) << \"Allocation shape is not an array. Shape = \"",
          "content_same": false
        },
        {
          "line": 3745,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "shape.ToString()",
          "old_line_content": "  std::string memory_space_str = \"def\";",
          "new_line_content": "                         << shape.ToString()",
          "content_same": false
        },
        {
          "line": 3746,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "defining_position().shape()",
          "old_line_content": "  if (memory_space_ == MemorySpace::kAlternate) {",
          "new_line_content": "                         << \" position = \" << defining_position().shape();",
          "content_same": false
        },
        {
          "line": 3755,
          "old_api": null,
          "new_api": "is_scoped_allocation",
          "old_text": null,
          "new_text": "is_scoped_allocation()",
          "old_line_content": "",
          "new_line_content": "  return absl::StrCat((is_scoped_allocation() ? \"Scoped \" : \"\"),",
          "content_same": false
        },
        {
          "line": 3757,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "defining_position_.ToString()",
          "old_line_content": "  std::string memory_space_str = \"def\";",
          "new_line_content": "                      defining_position_.ToString(),",
          "content_same": false
        },
        {
          "line": 3758,
          "old_api": null,
          "new_api": "end_time",
          "old_text": null,
          "new_text": "end_time()",
          "old_line_content": "  if (memory_space_ == MemorySpace::kAlternate) {",
          "new_line_content": "                      \", start_time:\", start_time(), \", end_time:\", end_time(),",
          "content_same": false
        },
        {
          "line": 3767,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "absl::StrCat(\"Copy Allocation in \", memory_space_str,\n                      \", start_time:\", start_time(), \", end_time:\", end_time(),\n                      \", copy_start_after_time: \", copy_start_schedule_after(),\n                      \", copy_done_before_time: \", copy_done_schedule_before(),\n                      \", uses: \", UsesToString(uses()), \", from \",\n                      prev_allocation_.ToString())",
          "old_line_content": "}",
          "new_line_content": "  return absl::StrCat(\"Copy Allocation in \", memory_space_str,",
          "content_same": false
        },
        {
          "line": 3768,
          "old_api": null,
          "new_api": "end_time",
          "old_text": null,
          "new_text": "end_time()",
          "old_line_content": "",
          "new_line_content": "                      \", start_time:\", start_time(), \", end_time:\", end_time(),",
          "content_same": false
        },
        {
          "line": 3769,
          "old_api": null,
          "new_api": "copy_start_schedule_after",
          "old_text": null,
          "new_text": "copy_start_schedule_after()",
          "old_line_content": "std::string MemorySpaceAssignment::MirroredAllocation::ToString() const {",
          "new_line_content": "                      \", copy_start_after_time: \", copy_start_schedule_after(),",
          "content_same": false
        },
        {
          "line": 3772,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "prev_allocation_.ToString()",
          "old_line_content": "}",
          "new_line_content": "                      prev_allocation_.ToString());",
          "content_same": false
        },
        {
          "line": 3781,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "absl::StrCat(\"Parent Allocation mirrored at \",\n                      defining_position_.ToString(), \", originally \",\n                      original_allocation_.ToString())",
          "old_line_content": "  // Copy allocations need to insert asynchronous copy nodes.",
          "new_line_content": "  return absl::StrCat(\"Parent Allocation mirrored at \",",
          "content_same": false
        },
        {
          "line": 3792,
          "old_api": null,
          "new_api": "ShapeUtil::MakeShape(U32, {})",
          "old_text": null,
          "new_text": "ShapeUtil::MakeShape(U32, {})",
          "old_line_content": "  // Update the allocation position with the copy done instruction so that if",
          "new_line_content": "      ShapeUtil::MakeTupleShape({shape, shape, ShapeUtil::MakeShape(U32, {})}),",
          "content_same": false
        },
        {
          "line": 3794,
          "old_api": null,
          "new_api": "AddInstruction",
          "old_text": null,
          "new_text": "computation->AddInstruction(\n      HloInstruction::CreateUnary(shape, HloOpcode::kCopyDone, copy_start_))",
          "old_line_content": "  defining_position_ = HloPosition{copy_done_, {}};",
          "new_line_content": "  copy_done_ = computation->AddInstruction(",
          "content_same": false
        },
        {
          "line": 3795,
          "old_api": null,
          "new_api": "HloInstruction::CreateUnary(shape, HloOpcode::kCopyDone, copy_start_)",
          "old_text": null,
          "new_text": "HloInstruction::CreateUnary(shape, HloOpcode::kCopyDone, copy_start_)",
          "old_line_content": "",
          "new_line_content": "      HloInstruction::CreateUnary(shape, HloOpcode::kCopyDone, copy_start_));",
          "content_same": false
        },
        {
          "line": 3796,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "copy_start_->name()",
          "old_line_content": "  // Replace all the uses with the new copy instruction.",
          "new_line_content": "  VLOG(4) << \"Created \" << copy_start_->name()",
          "content_same": false
        },
        {
          "line": 3797,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "ToString()",
          "old_line_content": "  for (HloUse use : uses_) {",
          "new_line_content": "          << \" for copy allocation: \" << ToString();",
          "content_same": false
        },
        {
          "line": 3807,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "use.instruction->operand(use.operand_number)->shape()",
          "old_line_content": "              use.operand_index));",
          "new_line_content": "    Shape operand_shape = use.instruction->operand(use.operand_number)->shape();",
          "content_same": false
        },
        {
          "line": 3811,
          "old_api": null,
          "new_api": "mutable_operand",
          "old_text": null,
          "new_text": "TupleUtil::ReplaceTupleWith(\n              copy_done_, use.instruction->mutable_operand(use.operand_number),\n              use.operand_index)",
          "old_line_content": "              << \"; inserting a bitcast.\";",
          "new_line_content": "          TupleUtil::ReplaceTupleWith(",
          "content_same": false
        },
        {
          "line": 3814,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "copy_done_->shape()",
          "old_line_content": "    } else {",
          "new_line_content": "    } else if (operand_shape != copy_done_->shape()) {",
          "content_same": false
        },
        {
          "line": 3815,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "operand_shape.ToString()",
          "old_line_content": "      replacement_instruction = copy_done_;",
          "new_line_content": "      VLOG(4) << \"Old shape = \" << operand_shape.ToString()",
          "content_same": false
        },
        {
          "line": 3816,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "copy_done_->shape().ToString()",
          "old_line_content": "    }",
          "new_line_content": "              << \", new shape = \" << copy_done_->shape().ToString()",
          "content_same": false
        },
        {
          "line": 3818,
          "old_api": null,
          "new_api": "AddInstruction",
          "old_text": null,
          "new_text": "computation->AddInstruction(\n          HloInstruction::CreateBitcast(operand_shape, copy_done_))",
          "old_line_content": "        use.operand_number, replacement_instruction));",
          "new_line_content": "      replacement_instruction = computation->AddInstruction(",
          "content_same": false
        },
        {
          "line": 3819,
          "old_api": null,
          "new_api": "HloInstruction::CreateBitcast(operand_shape, copy_done_)",
          "old_text": null,
          "new_text": "HloInstruction::CreateBitcast(operand_shape, copy_done_)",
          "old_line_content": "  }",
          "new_line_content": "          HloInstruction::CreateBitcast(operand_shape, copy_done_));",
          "content_same": false
        },
        {
          "line": 3823,
          "old_api": null,
          "new_api": "ReplaceOperandWith",
          "old_text": null,
          "new_text": "use.instruction->ReplaceOperandWith(\n        use.operand_number, replacement_instruction)",
          "old_line_content": "",
          "new_line_content": "    TF_RETURN_IF_ERROR(use.instruction->ReplaceOperandWith(",
          "content_same": false
        },
        {
          "line": 3827,
          "old_api": null,
          "new_api": "OkStatus",
          "old_text": null,
          "new_text": "OkStatus()",
          "old_line_content": "}",
          "new_line_content": "  return OkStatus();",
          "content_same": false
        },
        {
          "line": 3831,
          "old_api": null,
          "new_api": "defining_position",
          "old_text": null,
          "new_text": "original_allocation_.defining_position()",
          "old_line_content": "  // in the default memory space.",
          "new_line_content": "  defining_position_ = original_allocation_.defining_position();",
          "content_same": false
        },
        {
          "line": 3832,
          "old_api": null,
          "new_api": "Allocation::Process()",
          "old_text": null,
          "new_text": "Allocation::Process()",
          "old_line_content": "  HloInstruction* producing_instruction =",
          "new_line_content": "  return Allocation::Process();",
          "content_same": false
        },
        {
          "line": 3840,
          "old_api": null,
          "new_api": "tuple_shapes_size",
          "old_text": null,
          "new_text": "calling_instruction_->shape().tuple_shapes_size()",
          "old_line_content": "                                  {new_tuple_index}));",
          "new_line_content": "  int new_tuple_index = calling_instruction_->shape().tuple_shapes_size();",
          "content_same": false
        },
        {
          "line": 3842,
          "old_api": null,
          "new_api": "mutable_operand",
          "old_text": null,
          "new_text": "TF_ASSIGN_OR_RETURN(\n      HloInstruction * new_while_operand,\n      TupleUtil::ReplaceTupleWith(producing_instruction,\n                                  calling_instruction_->mutable_operand(0),\n                                  {new_tuple_index}))",
          "old_line_content": "      0, new_while_operand));",
          "new_line_content": "  TF_ASSIGN_OR_RETURN(",
          "content_same": false
        },
        {
          "line": 3845,
          "old_api": null,
          "new_api": "mutable_operand",
          "old_text": null,
          "new_text": "calling_instruction_->mutable_operand(0)",
          "old_line_content": "       ->parameter_instruction(0)",
          "new_line_content": "                                  calling_instruction_->mutable_operand(0),",
          "content_same": false
        },
        {
          "line": 3850,
          "old_api": null,
          "new_api": "while_condition",
          "old_text": null,
          "new_text": "calling_instruction_->while_condition()\n       ->parameter_instruction(0)\n       ->mutable_shape()",
          "old_line_content": "  defining_position_.index = {new_tuple_index};",
          "new_line_content": "  *calling_instruction_->while_condition()",
          "content_same": false
        },
        {
          "line": 3852,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "new_while_operand->shape()",
          "old_line_content": "  // need to first take a snapshot of the users before calling ExtractPrefix",
          "new_line_content": "       ->mutable_shape() = new_while_operand->shape();",
          "content_same": false
        },
        {
          "line": 3853,
          "old_api": null,
          "new_api": "while_body",
          "old_text": null,
          "new_text": "calling_instruction_->while_body()\n       ->parameter_instruction(0)\n       ->mutable_shape()",
          "old_line_content": "  // since ExtractPrefix introduces additional gte users.",
          "new_line_content": "  *calling_instruction_->while_body()",
          "content_same": false
        },
        {
          "line": 3855,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "new_while_operand->shape()",
          "old_line_content": "  HloInstruction* tuple_with_old_shape =",
          "new_line_content": "       ->mutable_shape() = new_while_operand->shape();",
          "content_same": false
        },
        {
          "line": 3860,
          "old_api": null,
          "new_api": "users",
          "old_text": null,
          "new_text": "calling_instruction_->users()",
          "old_line_content": "}",
          "new_line_content": "  std::vector<HloInstruction*> while_users = calling_instruction_->users();",
          "content_same": false
        },
        {
          "line": 3862,
          "old_api": null,
          "new_api": "TupleUtil::ExtractPrefix(calling_instruction_, new_tuple_index)",
          "old_text": null,
          "new_text": "TupleUtil::ExtractPrefix(calling_instruction_, new_tuple_index)",
          "old_line_content": "Status MemorySpaceAssignment::ParentAllocation::PostProcess() {",
          "new_line_content": "      TupleUtil::ExtractPrefix(calling_instruction_, new_tuple_index);",
          "content_same": false
        },
        {
          "line": 3863,
          "old_api": null,
          "new_api": "ReplaceAllUsesWithDifferentShape",
          "old_text": null,
          "new_text": "calling_instruction_->ReplaceAllUsesWithDifferentShape(\n      while_users, tuple_with_old_shape)",
          "old_line_content": "  // Update the root of the while body with the new parameter. The reason why we",
          "new_line_content": "  TF_RETURN_IF_ERROR(calling_instruction_->ReplaceAllUsesWithDifferentShape(",
          "content_same": false
        },
        {
          "line": 3865,
          "old_api": null,
          "new_api": "Allocation::Process()",
          "old_text": null,
          "new_text": "Allocation::Process()",
          "old_line_content": "  // while body root as a use, so they would update the old root instead of the",
          "new_line_content": "  return Allocation::Process();",
          "content_same": false
        },
        {
          "line": 3874,
          "old_api": null,
          "new_api": "while_body",
          "old_text": null,
          "new_text": "calling_instruction_->while_body()",
          "old_line_content": "                                   /*accept_different_shape=*/true);",
          "new_line_content": "  HloComputation* while_body = calling_instruction_->while_body();",
          "content_same": false
        },
        {
          "line": 3876,
          "old_api": null,
          "new_api": "root_instruction",
          "old_text": null,
          "new_text": "TupleUtil::ReplaceTupleWith(\n                          AddGetTupleElements(), while_body->root_instruction(),\n                          defining_position_.index)",
          "old_line_content": "}",
          "new_line_content": "                      TupleUtil::ReplaceTupleWith(",
          "content_same": false
        },
        {
          "line": 3877,
          "old_api": null,
          "new_api": "root_instruction",
          "old_text": null,
          "new_text": "while_body->root_instruction()",
          "old_line_content": "",
          "new_line_content": "                          AddGetTupleElements(), while_body->root_instruction(),",
          "content_same": false
        },
        {
          "line": 3879,
          "old_api": null,
          "new_api": "set_root_instruction",
          "old_text": null,
          "new_text": "while_body->set_root_instruction(new_while_body_root,\n                                   /*accept_different_shape=*/true)",
          "old_line_content": "    absl::flat_hash_set<const Allocation*>& needed_allocations) const {",
          "new_line_content": "  while_body->set_root_instruction(new_while_body_root,",
          "content_same": false
        },
        {
          "line": 3881,
          "old_api": null,
          "new_api": "OkStatus",
          "old_text": null,
          "new_text": "OkStatus()",
          "old_line_content": "}",
          "new_line_content": "  return OkStatus();",
          "content_same": false
        },
        {
          "line": 3886,
          "old_api": null,
          "new_api": "MarkNeeded",
          "old_text": null,
          "new_text": "MarkNeeded(needed_allocations)",
          "old_line_content": "}",
          "new_line_content": "  MarkNeeded(needed_allocations);",
          "content_same": false
        },
        {
          "line": 3896,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "needed_allocations.insert(this)",
          "old_line_content": "  // Parent allocations are only needed if they have any uses or if there is a",
          "new_line_content": "  needed_allocations.insert(this);",
          "content_same": false
        },
        {
          "line": 3897,
          "old_api": null,
          "new_api": "MarkNeeded",
          "old_text": null,
          "new_text": "prev_allocation_.MarkNeeded(needed_allocations)",
          "old_line_content": "  // copy allocation that copies this value (in that case, the copy allocation",
          "new_line_content": "  prev_allocation_.MarkNeeded(needed_allocations);",
          "content_same": false
        },
        {
          "line": 3905,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "uses_.empty()",
          "old_line_content": "    absl::flat_hash_set<const Allocation*>& needed_allocations) const {",
          "new_line_content": "  if (!uses_.empty()) {",
          "content_same": false
        },
        {
          "line": 3918,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "needed_allocations.insert(this)",
          "old_line_content": "  // Since some parent allocations may not be needed (e.g. when they don't have",
          "new_line_content": "  needed_allocations.insert(this);",
          "content_same": false
        },
        {
          "line": 3919,
          "old_api": null,
          "new_api": "MarkNeeded",
          "old_text": null,
          "new_text": "original_allocation_.MarkNeeded(needed_allocations)",
          "old_line_content": "  // any uses and if there is no other (non-parent) allocation that depends on",
          "new_line_content": "  original_allocation_.MarkNeeded(needed_allocations);",
          "content_same": false
        },
        {
          "line": 3923,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "  for (auto& allocation : allocations_) {",
          "new_line_content": "  VLOG(1) << \"Processing assigned buffers...\";",
          "content_same": false
        },
        {
          "line": 3934,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "allocation->ToString()",
          "old_line_content": "    // Add the offset and size of the allocation in the alternate memory to",
          "new_line_content": "    VLOG(3) << \"Processing: \" << allocation->ToString();",
          "content_same": false
        },
        {
          "line": 3935,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "allocation.get()",
          "old_line_content": "    // the output map.",
          "new_line_content": "    if (!needed_allocations.contains(allocation.get())) {",
          "content_same": false
        },
        {
          "line": 3945,
          "old_api": null,
          "new_api": "chunk",
          "old_text": null,
          "new_text": "allocation->chunk()",
          "old_line_content": "      alternate_memory_size_ =",
          "new_line_content": "          allocation->defining_position().instruction, allocation->chunk());",
          "content_same": false
        },
        {
          "line": 3947,
          "old_api": null,
          "new_api": "chunk_end",
          "old_text": null,
          "new_text": "allocation->chunk().chunk_end()",
          "old_line_content": "",
          "new_line_content": "          std::max(alternate_memory_size_, allocation->chunk().chunk_end());",
          "content_same": false
        },
        {
          "line": 3952,
          "old_api": null,
          "new_api": "chunk_end",
          "old_text": null,
          "new_text": "allocation->chunk().chunk_end()",
          "old_line_content": "      }",
          "new_line_content": "          std::max(alternate_memory_size_, allocation->chunk().chunk_end());",
          "content_same": false
        },
        {
          "line": 3954,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "allocation->cross_program_prefetch_index().has_value()",
          "old_line_content": "  }",
          "new_line_content": "      if (allocation->cross_program_prefetch_index().has_value()) {",
          "content_same": false
        },
        {
          "line": 3955,
          "old_api": null,
          "new_api": "SetCrossProgramPrefetchOffset",
          "old_text": null,
          "new_text": "module_->SetCrossProgramPrefetchOffset(\n            *allocation->cross_program_prefetch_index(),\n            allocation->chunk().offset)",
          "old_line_content": "",
          "new_line_content": "        TF_RETURN_IF_ERROR(module_->SetCrossProgramPrefetchOffset(",
          "content_same": false
        },
        {
          "line": 3956,
          "old_api": null,
          "new_api": "cross_program_prefetch_index",
          "old_text": null,
          "new_text": "allocation->cross_program_prefetch_index()",
          "old_line_content": "  // Post-process allocations. This is only used for parent allocations where we",
          "new_line_content": "            *allocation->cross_program_prefetch_index(),",
          "content_same": false
        },
        {
          "line": 3957,
          "old_api": null,
          "new_api": "chunk",
          "old_text": null,
          "new_text": "allocation->chunk()",
          "old_line_content": "  // update the body root with a reference to the buffer in default memory",
          "new_line_content": "            allocation->chunk().offset));",
          "content_same": false
        },
        {
          "line": 3966,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "allocation.get()",
          "old_line_content": "}",
          "new_line_content": "    if (needed_allocations.contains(allocation.get())) {",
          "content_same": false
        },
        {
          "line": 3967,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "allocation->ToString()",
          "old_line_content": "",
          "new_line_content": "      VLOG(3) << \"Post-Processing: \" << allocation->ToString();",
          "content_same": false
        },
        {
          "line": 3968,
          "old_api": null,
          "new_api": "PostProcess",
          "old_text": null,
          "new_text": "allocation->PostProcess()",
          "old_line_content": "Status MemorySpaceAssignment::ExportAndColorBuffers() {",
          "new_line_content": "      TF_RETURN_IF_ERROR(allocation->PostProcess());",
          "content_same": false
        },
        {
          "line": 3971,
          "old_api": null,
          "new_api": "OkStatus",
          "old_text": null,
          "new_text": "OkStatus()",
          "old_line_content": "  absl::flat_hash_map<int64_t, int64_t> seen_buffer_offsets;",
          "new_line_content": "  return OkStatus();",
          "content_same": false
        },
        {
          "line": 3975,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "    const Chunk& chunk = position_and_chunk.second;",
          "new_line_content": "  VLOG(1) << \"Exporting buffers...\";",
          "content_same": false
        },
        {
          "line": 3990,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "  }",
          "new_line_content": "      VLOG(3) << \" [\" << chunk.offset << \", \" << chunk.size",
          "content_same": false
        },
        {
          "line": 3991,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "defining_position.ToString()",
          "old_line_content": "",
          "new_line_content": "              << \"] : \" << defining_position.ToString() << \" (\"",
          "content_same": false
        },
        {
          "line": 3993,
          "old_api": null,
          "new_api": "add_chunk",
          "old_text": null,
          "new_text": "preset_assignments_->add_chunk(defining_position, chunk)",
          "old_line_content": "  for (const auto& instruction_and_chunk : scoped_memory_assignments_) {",
          "new_line_content": "      preset_assignments_->add_chunk(defining_position, chunk);",
          "content_same": false
        },
        {
          "line": 3994,
          "old_api": null,
          "new_api": "id",
          "old_text": null,
          "new_text": "buffer.id()",
          "old_line_content": "    HloInstruction* instruction = instruction_and_chunk.first;",
          "new_line_content": "      seen_buffer_offsets[buffer.id()] = chunk.offset;",
          "content_same": false
        },
        {
          "line": 4004,
          "old_api": null,
          "new_api": "add_scoped_allocation_chunk",
          "old_text": null,
          "new_text": "preset_assignments_->add_scoped_allocation_chunk(instruction, chunk)",
          "old_line_content": "        ->assignment_information_for_space(options_.alternate_memory_space)",
          "new_line_content": "    preset_assignments_->add_scoped_allocation_chunk(instruction, chunk);",
          "content_same": false
        },
        {
          "line": 4007,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "preset_assignments_->chunks().empty()",
          "old_line_content": "",
          "new_line_content": "  if (!preset_assignments_->chunks().empty() ||",
          "content_same": false
        },
        {
          "line": 4014,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(3)",
          "old_line_content": "  // Color the pending positions and all of their aliased buffers.",
          "new_line_content": "  VLOG(3) << \"Exported alternate memory sizes:\";",
          "content_same": false
        },
        {
          "line": 4015,
          "old_api": null,
          "new_api": "assignment_informations",
          "old_text": null,
          "new_text": "preset_assignments_->assignment_informations()",
          "old_line_content": "  for (const auto& defining_position_and_chunk :",
          "new_line_content": "  for (auto& pair : preset_assignments_->assignment_informations()) {",
          "content_same": false
        },
        {
          "line": 4019,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "             defining_position.instruction, defining_position.index)) {",
          "new_line_content": "  VLOG(1) << \"Coloring buffers...\";",
          "content_same": false
        },
        {
          "line": 4028,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "position.ToString()",
          "old_line_content": "              options_.alternate_memory_space);",
          "new_line_content": "          VLOG(4) << \"Coloring \" << position.ToString();",
          "content_same": false
        },
        {
          "line": 4029,
          "old_api": null,
          "new_api": "mutable_shape",
          "old_text": null,
          "new_text": "ShapeUtil::GetMutableSubshape(\n              position.instruction->mutable_shape(), position.index)",
          "old_line_content": "        }",
          "new_line_content": "          Shape* shape = ShapeUtil::GetMutableSubshape(",
          "content_same": false
        },
        {
          "line": 4030,
          "old_api": null,
          "new_api": "mutable_shape",
          "old_text": null,
          "new_text": "position.instruction->mutable_shape()",
          "old_line_content": "      }",
          "new_line_content": "              position.instruction->mutable_shape(), position.index);",
          "content_same": false
        },
        {
          "line": 4031,
          "old_api": null,
          "new_api": "IsArray",
          "old_text": null,
          "new_text": "shape->IsArray()",
          "old_line_content": "    }",
          "new_line_content": "          CHECK(shape->IsArray()) << \"Coloring a shape that is not an array: \"",
          "content_same": false
        },
        {
          "line": 4032,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "position.ToString()",
          "old_line_content": "  }",
          "new_line_content": "                                  << position.ToString();",
          "content_same": false
        },
        {
          "line": 4055,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "alternate_memory_assignments_.back()",
          "old_line_content": "    }",
          "new_line_content": "        *it = alternate_memory_assignments_.back();",
          "content_same": false
        },
        {
          "line": 4056,
          "old_api": null,
          "new_api": "pop_back",
          "old_text": null,
          "new_text": "alternate_memory_assignments_.pop_back()",
          "old_line_content": "  }",
          "new_line_content": "        alternate_memory_assignments_.pop_back();",
          "content_same": false
        },
        {
          "line": 4057,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "alternate_memory_assignments_.end()",
          "old_line_content": "}",
          "new_line_content": "        end = alternate_memory_assignments_.end();",
          "content_same": false
        },
        {
          "line": 4066,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "              << \" because it's not in the schedule.\";",
          "new_line_content": "  VLOG(1) << \"Simplifying graph...\";",
          "content_same": false
        },
        {
          "line": 4067,
          "old_api": null,
          "new_api": "MakeNonfusionComputations",
          "old_text": null,
          "new_text": "module_->MakeNonfusionComputations()",
          "old_line_content": "      continue;",
          "new_line_content": "  for (HloComputation* computation : module_->MakeNonfusionComputations()) {",
          "content_same": false
        },
        {
          "line": 4070,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "computations_in_schedule_.contains(computation)",
          "old_line_content": "    // don't need control dependencies anymore, and having control",
          "new_line_content": "    if (!computations_in_schedule_.contains(computation)) {",
          "content_same": false
        },
        {
          "line": 4071,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "computation->name()",
          "old_line_content": "    // predecessors/successors prevents us from removing instructions without",
          "new_line_content": "      VLOG(4) << \"Not simplifying \" << computation->name()",
          "content_same": false
        },
        {
          "line": 4081,
          "old_api": null,
          "new_api": "MakeInstructionPostOrder",
          "old_text": null,
          "new_text": "computation->MakeInstructionPostOrder()",
          "old_line_content": "    // simplification passes) and we don't want to generate redundant code.  Run",
          "new_line_content": "         computation->MakeInstructionPostOrder()) {",
          "content_same": false
        },
        {
          "line": 4082,
          "old_api": null,
          "new_api": "DropAllControlDeps",
          "old_text": null,
          "new_text": "instruction->DropAllControlDeps()",
          "old_line_content": "    // to fixed point.",
          "new_line_content": "      TF_RETURN_IF_ERROR(instruction->DropAllControlDeps());",
          "content_same": false
        },
        {
          "line": 4094,
          "old_api": null,
          "new_api": "MakeInstructionPostOrder",
          "old_text": null,
          "new_text": "computation->MakeInstructionPostOrder()",
          "old_line_content": "          // Ensure the alternate memory assignments don't contain a reference",
          "new_line_content": "           computation->MakeInstructionPostOrder()) {",
          "content_same": false
        },
        {
          "line": 4095,
          "old_api": null,
          "new_api": "IsSafelyRemovable",
          "old_text": null,
          "new_text": "computation->IsSafelyRemovable(instruction)",
          "old_line_content": "          // to the removed instruction.",
          "new_line_content": "        if (computation->IsSafelyRemovable(instruction) &&",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 4103,
          "old_api": "end",
          "new_api": null,
          "old_text": "flattened_instructions_.end()",
          "new_text": null,
          "old_line_content": "          if (instruction_it != flattened_instructions_.end()) {",
          "new_line_content": "          // Instead of deleting the instruction from the schedule, replace it",
          "content_same": false
        },
        {
          "line": 4106,
          "old_api": "RemoveInstruction",
          "new_api": null,
          "old_text": "computation->RemoveInstruction(instruction)",
          "new_text": null,
          "old_line_content": "          TF_RETURN_IF_ERROR(computation->RemoveInstruction(instruction));",
          "new_line_content": "          // scheduling asynchronous copies.",
          "content_same": false
        },
        {
          "line": 4110,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "operand->opcode()",
          "new_text": null,
          "old_line_content": "          if (operand->opcode() == HloOpcode::kTuple) {",
          "new_line_content": "            *instruction_it = nullptr;",
          "content_same": false
        },
        {
          "line": 4113,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "instruction->ToString()",
          "new_text": null,
          "old_line_content": "            VLOG(4) << \"Replacing uses of \" << instruction->ToString()",
          "new_line_content": "          computation_modified = true;",
          "content_same": false
        },
        {
          "line": 4123,
          "old_api": "operand_count",
          "new_api": null,
          "old_text": "instruction->operand_count()",
          "new_text": null,
          "old_line_content": "              instruction->operand_count() > 0 &&",
          "new_line_content": "            computation_modified = true;",
          "content_same": false
        },
        {
          "line": 4124,
          "old_api": "operand",
          "new_api": null,
          "old_text": "instruction->operand(0)->opcode()",
          "new_text": null,
          "old_line_content": "              instruction->operand(0)->opcode() ==",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 4126,
          "old_api": "tuple_shapes_size",
          "new_api": null,
          "old_text": "instruction->operand(0)\n                      ->operand(0)\n                      ->shape()\n                      .tuple_shapes_size()",
          "new_text": null,
          "old_line_content": "              instruction->operand(0)",
          "new_line_content": "          // Replace Tuple(GetTupleElement(x), ..., GetTupleElement(x)) pattern",
          "content_same": false
        },
        {
          "line": 4131,
          "old_api": "operand_count",
          "new_api": null,
          "old_text": "instruction->operand_count()",
          "new_text": null,
          "old_line_content": "               operand_number < instruction->operand_count();",
          "new_line_content": "                  HloOpcode::kGetTupleElement &&",
          "content_same": false
        },
        {
          "line": 4134,
          "old_api": "operand",
          "new_api": null,
          "old_text": "instruction->operand(operand_number)",
          "new_text": null,
          "old_line_content": "                instruction->operand(operand_number);",
          "new_line_content": "                      ->shape()",
          "content_same": false
        },
        {
          "line": 4136,
          "old_api": "tuple_index",
          "new_api": null,
          "old_text": "operand->tuple_index()",
          "new_text": null,
          "old_line_content": "                operand->tuple_index() != operand_number ||",
          "new_line_content": "          for (int operand_number = 0;",
          "content_same": false
        },
        {
          "line": 4144,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "instruction->mutable_operand(0)->mutable_operand(0)",
          "new_text": null,
          "old_line_content": "                instruction->mutable_operand(0)->mutable_operand(0);",
          "new_line_content": "              can_replace = false;",
          "content_same": false
        },
        {
          "line": 4145,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "instruction->ToString()",
          "new_text": null,
          "old_line_content": "            VLOG(4) << \"Replacing uses of \" << instruction->ToString()",
          "new_line_content": "              break;",
          "content_same": false
        },
        {
          "line": 4146,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "forwarded_instruction->ToString()",
          "new_text": null,
          "old_line_content": "                    << \" with \" << forwarded_instruction->ToString();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 4147,
          "old_api": "ReplaceAllUsesWith",
          "new_api": null,
          "old_text": "TF_RETURN_IF_ERROR(\n                instruction->ReplaceAllUsesWith(forwarded_instruction))",
          "new_text": null,
          "old_line_content": "            TF_RETURN_IF_ERROR(",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 4148,
          "old_api": "ReplaceAllUsesWith",
          "new_api": null,
          "old_text": "instruction->ReplaceAllUsesWith(forwarded_instruction)",
          "new_text": null,
          "old_line_content": "                instruction->ReplaceAllUsesWith(forwarded_instruction));",
          "new_line_content": "          if (can_replace) {",
          "content_same": false
        },
        {
          "line": 4156,
          "old_api": "OkStatus",
          "new_api": null,
          "old_text": "OkStatus()",
          "new_text": null,
          "old_line_content": "  return OkStatus();",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 4160,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(1)",
          "new_text": null,
          "old_line_content": "  VLOG(1) << \"Scheduling asynchronous copies...\";",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 4165,
          "old_api": "is_copy_allocation",
          "new_api": null,
          "old_text": "allocation->is_copy_allocation()",
          "new_text": null,
          "old_line_content": "      if (allocation->is_copy_allocation()) {",
          "new_line_content": "void MemorySpaceAssignment::ScheduleAsynchronousCopies() {",
          "content_same": false
        },
        {
          "line": 4167,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "copy_allocation->memory_space()",
          "new_text": null,
          "old_line_content": "        if (copy_allocation->memory_space() == memory_space) {",
          "new_line_content": "  for (MemorySpace memory_space :",
          "content_same": false
        },
        {
          "line": 4168,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "copy_allocations.push_back(copy_allocation)",
          "new_text": null,
          "old_line_content": "          copy_allocations.push_back(copy_allocation);",
          "new_line_content": "       {MemorySpace::kDefault, MemorySpace::kAlternate}) {",
          "content_same": false
        },
        {
          "line": 4175,
          "old_api": "copy_done_schedule_before",
          "new_api": null,
          "old_text": "first->copy_done_schedule_before()",
          "new_text": null,
          "old_line_content": "          return std::forward_as_tuple(first->copy_done_schedule_before(),",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 4176,
          "old_api": "copy_start_schedule_after",
          "new_api": null,
          "old_text": "first->copy_start_schedule_after()",
          "new_text": null,
          "old_line_content": "                                       first->copy_start_schedule_after()) <",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 4177,
          "old_api": "copy_done_schedule_before",
          "new_api": null,
          "old_text": "second->copy_done_schedule_before()",
          "new_text": null,
          "old_line_content": "                 std::forward_as_tuple(second->copy_done_schedule_before(),",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4178,
          "old_api": "copy_start_schedule_after",
          "new_api": null,
          "old_text": "second->copy_start_schedule_after()",
          "new_text": null,
          "old_line_content": "                                       second->copy_start_schedule_after());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4187,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "copy_allocation->defining_position().instruction->parent()",
          "new_text": null,
          "old_line_content": "      while (copy_allocation->defining_position().instruction->parent() !=",
          "new_line_content": "      // If the copy start doesn't happen to be scheduled at the correct",
          "content_same": false
        },
        {
          "line": 4188,
          "old_api": "parent",
          "new_api": null,
          "old_text": "flattened_instructions_[copy_start_schedule_after]->parent()",
          "new_text": null,
          "old_line_content": "             flattened_instructions_[copy_start_schedule_after]->parent()) {",
          "new_line_content": "      // computation, delay it until the correct computation starts.",
          "content_same": false
        },
        {
          "line": 4189,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(4)",
          "new_text": null,
          "old_line_content": "        VLOG(4) << \"Delaying CopyStart (\" << copy_start_schedule_after << \" to \"",
          "new_line_content": "      int64_t copy_start_schedule_after =",
          "content_same": false
        },
        {
          "line": 4191,
          "old_api": "copy_start",
          "new_api": null,
          "old_text": "copy_allocation->copy_start()->ToString()",
          "new_text": null,
          "old_line_content": "                << copy_allocation->copy_start()->ToString()",
          "new_line_content": "      // Accessing flattened_instructions_ here without checking if it is",
          "content_same": false
        },
        {
          "line": 4198,
          "old_api": "copy_start",
          "new_api": null,
          "old_text": "copy_allocation->copy_start()",
          "new_text": null,
          "old_line_content": "          copy_allocation->copy_start());",
          "new_line_content": "                << \" because it is not in the correct computation.\";",
          "content_same": false
        },
        {
          "line": 4200,
          "old_api": "copy_done",
          "new_api": null,
          "old_text": "copy_allocation->copy_done()",
          "new_text": null,
          "old_line_content": "          copy_allocation->copy_done());",
          "new_line_content": "            ++copy_start_schedule_after);",
          "content_same": false
        },
        {
          "line": 4207,
          "old_api": "has_schedule",
          "new_api": null,
          "old_text": "module_->has_schedule()",
          "new_text": null,
          "old_line_content": "  TF_RET_CHECK(module_->has_schedule());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4208,
          "old_api": "schedule",
          "new_api": null,
          "old_text": "module_->schedule()",
          "new_text": null,
          "old_line_content": "  HloSchedule& schedule = module_->schedule();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 4210,
          "old_api": "MakeNonfusionComputations",
          "new_api": null,
          "old_text": "module_->MakeNonfusionComputations()",
          "new_text": null,
          "old_line_content": "       module_->MakeNonfusionComputations()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4218,
          "old_api": "is_computation_scheduled",
          "new_api": null,
          "old_text": "schedule.is_computation_scheduled(computation)",
          "new_text": null,
          "old_line_content": "    TF_RET_CHECK(schedule.is_computation_scheduled(computation));",
          "new_line_content": "    // modified.",
          "content_same": false
        },
        {
          "line": 4223,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "computation->ToString()",
          "new_text": null,
          "old_line_content": "    VLOG(4) << \"Scheduling: \" << computation->ToString();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4226,
          "old_api": "find",
          "new_api": null,
          "old_text": "schedule_before_.find(instruction_index)",
          "new_text": null,
          "old_line_content": "      auto insts_before_iter = schedule_before_.find(instruction_index);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4227,
          "old_api": "end",
          "new_api": null,
          "old_text": "schedule_before_.end()",
          "new_text": null,
          "old_line_content": "      if (insts_before_iter != schedule_before_.end()) {",
          "new_line_content": "    absl::flat_hash_set<HloInstruction*> inserted_instructions;",
          "content_same": false
        },
        {
          "line": 4230,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(4)",
          "new_text": null,
          "old_line_content": "            VLOG(4) << \"before \" << instruction_index << \": \"",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4231,
          "old_api": "name",
          "new_api": null,
          "old_text": "new_instruction->name()",
          "new_text": null,
          "old_line_content": "                    << new_instruction->name();",
          "new_line_content": "    for (int64_t instruction_index = 0;; ++instruction_index) {",
          "content_same": false
        },
        {
          "line": 4240,
          "old_api": "size",
          "new_api": null,
          "old_text": "flattened_instructions_.size()",
          "new_text": null,
          "old_line_content": "      if (instruction_index >= flattened_instructions_.size()) {",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 4248,
          "old_api": "parent",
          "new_api": null,
          "old_text": "instruction->parent()",
          "new_text": null,
          "old_line_content": "      if (instruction != nullptr && instruction->parent() == computation &&",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 4249,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "instruction->opcode()",
          "new_text": null,
          "old_line_content": "          instruction->opcode() != HloOpcode::kBitcast &&",
          "new_line_content": "      HloInstruction* instruction = flattened_instructions_[instruction_index];",
          "content_same": false
        },
        {
          "line": 4250,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "instruction->opcode()",
          "new_text": null,
          "old_line_content": "          instruction->opcode() != HloOpcode::kTuple &&",
          "new_line_content": "      // Insert only if it is not deleted (SimplifyGraph sets it to nullptr if",
          "content_same": false
        },
        {
          "line": 4251,
          "old_api": "contains",
          "new_api": null,
          "old_text": "inserted_instructions.contains(instruction)",
          "new_text": null,
          "old_line_content": "          !inserted_instructions.contains(instruction)) {",
          "new_line_content": "      // it was deleted) and not previously inserted. Also bitcasts and tuples",
          "content_same": false
        },
        {
          "line": 4252,
          "old_api": "name",
          "new_api": null,
          "old_text": "instruction->name()",
          "new_text": null,
          "old_line_content": "        VLOG(4) << \"inst \" << instruction_index << \": \" << instruction->name();",
          "new_line_content": "      // are treated specially and only inserted as a result of operand",
          "content_same": false
        },
        {
          "line": 4253,
          "old_api": "InsertInstructionAndEnsureOperandsInserted",
          "new_api": null,
          "old_text": "InsertInstructionAndEnsureOperandsInserted(\n            instruction, &new_sequence, &inserted_instructions)",
          "new_text": null,
          "old_line_content": "        TF_RETURN_IF_ERROR(InsertInstructionAndEnsureOperandsInserted(",
          "new_line_content": "      // dependencies.",
          "content_same": false
        },
        {
          "line": 4260,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(4)",
          "new_text": null,
          "old_line_content": "            VLOG(4) << \"after \" << instruction_index << \": \"",
          "new_line_content": "            instruction, &new_sequence, &inserted_instructions));",
          "content_same": false
        },
        {
          "line": 4261,
          "old_api": "name",
          "new_api": null,
          "old_text": "new_instruction->name()",
          "new_text": null,
          "old_line_content": "                    << new_instruction->name();",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 4270,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "EnsureInstructionAndOperandsInserted(\n        computation->root_instruction(), &new_sequence,\n        &inserted_instructions)",
          "new_text": null,
          "old_line_content": "    TF_RETURN_IF_ERROR(EnsureInstructionAndOperandsInserted(",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 4271,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "computation->root_instruction()",
          "new_text": null,
          "old_line_content": "        computation->root_instruction(), &new_sequence,",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 4273,
          "old_api": "instruction_count",
          "new_api": null,
          "old_text": "computation->instruction_count()",
          "new_text": null,
          "old_line_content": "    CHECK_EQ(new_sequence.size(), computation->instruction_count())",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4274,
          "old_api": "name",
          "new_api": null,
          "old_text": "computation->name()",
          "new_text": null,
          "old_line_content": "        << \"New sequence for computation \" << computation->name() << \" has \"",
          "new_line_content": "    // For rare cases where the original sequence is empty, ensure the root",
          "content_same": false
        },
        {
          "line": 4275,
          "old_api": "size",
          "new_api": null,
          "old_text": "new_sequence.size()",
          "new_text": null,
          "old_line_content": "        << new_sequence.size() << \" instructions, expects \"",
          "new_line_content": "    // instruction and its dependencies are scheduled.",
          "content_same": false
        },
        {
          "line": 4284,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(1)",
          "new_text": null,
          "old_line_content": "  VLOG(1) << \"Verifying...\";",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 4285,
          "old_api": "TF_ASSIGN_OR_RETURN",
          "new_api": null,
          "old_text": "TF_ASSIGN_OR_RETURN(std::unique_ptr<HloAliasAnalysis> alias_analysis,\n                      HloAliasAnalysis::Run(module_))",
          "new_text": null,
          "old_line_content": "  TF_ASSIGN_OR_RETURN(std::unique_ptr<HloAliasAnalysis> alias_analysis,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4287,
          "old_api": "schedule",
          "new_api": null,
          "old_text": "TF_ASSIGN_OR_RETURN(std::unique_ptr<HloLiveRange> hlo_live_range,\n                      HloLiveRange::Run(module_->schedule(), *alias_analysis,\n                                        module_->entry_computation()))",
          "new_text": null,
          "old_line_content": "  TF_ASSIGN_OR_RETURN(std::unique_ptr<HloLiveRange> hlo_live_range,",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 4288,
          "old_api": "schedule",
          "new_api": null,
          "old_text": "module_->schedule()",
          "new_text": null,
          "old_line_content": "                      HloLiveRange::Run(module_->schedule(), *alias_analysis,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4289,
          "old_api": "entry_computation",
          "new_api": null,
          "old_text": "module_->entry_computation()",
          "new_text": null,
          "old_line_content": "                                        module_->entry_computation()));",
          "new_line_content": "Status MemorySpaceAssignment::VerifyAndExportHeapSimulatorTrace() {",
          "content_same": false
        },
        {
          "line": 4303,
          "old_api": "id",
          "new_api": null,
          "old_text": "value->id()",
          "new_text": null,
          "old_line_content": "    events[std::make_tuple(start_time, /*is_free=*/false, value->id())] =",
          "new_line_content": "           std::tuple<const HloValue*, Chunk, HeapSimulatorTrace::Event::Kind>>",
          "content_same": false
        },
        {
          "line": 4304,
          "old_api": "std::make_tuple(value, chunk, HeapSimulatorTrace::Event::ALLOC)",
          "new_api": null,
          "old_text": "std::make_tuple(value, chunk, HeapSimulatorTrace::Event::ALLOC)",
          "new_text": null,
          "old_line_content": "        std::make_tuple(value, chunk, HeapSimulatorTrace::Event::ALLOC);",
          "new_line_content": "      events;",
          "content_same": false
        },
        {
          "line": 4305,
          "old_api": "id",
          "new_api": null,
          "old_text": "value->id()",
          "new_text": null,
          "old_line_content": "    events[std::make_tuple(end_time, /*is_free=*/true, value->id())] =",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4306,
          "old_api": "std::make_tuple(value, chunk, HeapSimulatorTrace::Event::FREE)",
          "new_api": null,
          "old_text": "std::make_tuple(value, chunk, HeapSimulatorTrace::Event::FREE)",
          "new_text": null,
          "old_line_content": "        std::make_tuple(value, chunk, HeapSimulatorTrace::Event::FREE);",
          "new_line_content": "  auto add_allocation_and_verify = [&](int64_t start_time, int64_t end_time,",
          "content_same": false
        },
        {
          "line": 2264,
          "old_api": "GetLogicalIntervalElapsed",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->GetLogicalIntervalElapsed(\n          end_of_program_prefetch_start_time, end_of_program_prefetch_end_time)",
          "new_text": null,
          "old_line_content": "      options_.prefetch_interval_picker->GetLogicalIntervalElapsed(",
          "new_line_content": "  if (options_.cost_analysis) {",
          "content_same": false
        },
        {
          "line": 4315,
          "old_api": "ChunksOverlappingInTime",
          "new_api": null,
          "old_text": "interval_tree.ChunksOverlappingInTime(start_time, end_time - 1)",
          "new_text": null,
          "old_line_content": "         interval_tree.ChunksOverlappingInTime(start_time, end_time - 1)) {",
          "new_line_content": "    // as well.",
          "content_same": false
        },
        {
          "line": 4316,
          "old_api": "OverlapsWith",
          "new_api": null,
          "old_text": "chunk.OverlapsWith(overlapping_chunk)",
          "new_text": null,
          "old_line_content": "      if (chunk.OverlapsWith(overlapping_chunk)) {",
          "new_line_content": "    // TODO(berkin): For now checking against end_time - 1 (exclusive), but we",
          "content_same": false
        },
        {
          "line": 4317,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "InternalError(\n            (\"Value %s (%d, %d) off: %d size: %d overlaps with another chunk\"\n             \" off: %d size: %d\"),\n            value->ToShortString(), start_time, end_time, chunk.offset,\n            chunk.size, overlapping_chunk.offset, overlapping_chunk.size)",
          "new_text": null,
          "old_line_content": "        return InternalError(",
          "new_line_content": "    // really should check against end_time (inclusive) for cases where the",
          "content_same": false
        },
        {
          "line": 4320,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "value->ToShortString()",
          "new_text": null,
          "old_line_content": "            value->ToShortString(), start_time, end_time, chunk.offset,",
          "new_line_content": "    for (const Chunk& overlapping_chunk :",
          "content_same": false
        },
        {
          "line": 4324,
          "old_api": "Add",
          "new_api": null,
          "old_text": "interval_tree.Add(start_time, end_time - 1, chunk)",
          "new_text": null,
          "old_line_content": "    interval_tree.Add(start_time, end_time - 1, chunk);",
          "new_line_content": "            (\"Value %s (%d, %d) off: %d size: %d overlaps with another chunk\"",
          "content_same": false
        },
        {
          "line": 4325,
          "old_api": "OkStatus",
          "new_api": null,
          "old_text": "OkStatus()",
          "new_text": null,
          "old_line_content": "    return OkStatus();",
          "new_line_content": "             \" off: %d size: %d\"),",
          "content_same": false
        },
        {
          "line": 2282,
          "old_api": "back",
          "new_api": null,
          "old_text": "allocations.back()",
          "new_text": null,
          "old_line_content": "  AddAsyncCopy(*allocations.back(), MemorySpace::kAlternate, chunk_candidate,",
          "new_line_content": "       buffer_occupied_ratio < kCrossProgramPrefetchOccupyFreeingLimit &&",
          "content_same": false
        },
        {
          "line": 4332,
          "old_api": "instructions",
          "new_api": null,
          "old_text": "computation->instructions()",
          "new_text": null,
          "old_line_content": "    for (const HloInstruction* instruction : computation->instructions()) {",
          "new_line_content": "  };",
          "content_same": false
        },
        {
          "line": 4333,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "instruction->opcode()",
          "new_text": null,
          "old_line_content": "      if (instruction->opcode() == HloOpcode::kCopyStart) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2287,
          "old_api": "back",
          "new_api": null,
          "old_text": "allocations.back()->AddUse(use)",
          "new_text": null,
          "old_line_content": "  absl::c_for_each(uses, [&](auto& use) { allocations.back()->AddUse(use); });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4335,
          "old_api": "shape",
          "new_api": null,
          "old_text": "instruction->shape()",
          "new_text": null,
          "old_line_content": "            ShapeUtil::GetSubshape(instruction->shape(), {1})",
          "new_line_content": "  // instructions copy between alternate memory and default memory.",
          "content_same": false
        },
        {
          "line": 2289,
          "old_api": "back",
          "new_api": null,
          "old_text": "allocations.back()",
          "new_text": null,
          "old_line_content": "      GetAliasedOffset(*allocations.back());",
          "new_line_content": "               prefetch_candidate.start, cross_program_prefetch_end_time,",
          "content_same": false
        },
        {
          "line": 2292,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(2)",
          "new_text": null,
          "old_line_content": "    VLOG(2) << \"Adding an end-of-program prefetch for freed \"",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2294,
          "old_api": "front",
          "new_api": null,
          "old_text": "allocations.front()",
          "new_text": null,
          "old_line_content": "    AddAsyncCopy(*allocations.front(), MemorySpace::kAlternate, chunk_candidate,",
          "new_line_content": "  AliasedOffset* cross_program_prefetch_offset =",
          "content_same": false
        },
        {
          "line": 4342,
          "old_api": "CHECK_NE",
          "new_api": null,
          "old_text": "CHECK_NE(from_memory_space, to_memory_space)",
          "new_text": null,
          "old_line_content": "        CHECK_NE(from_memory_space, to_memory_space)",
          "new_line_content": "                .layout()",
          "content_same": false
        },
        {
          "line": 4344,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "instruction->ToString()",
          "new_text": null,
          "old_line_content": "            << instruction->ToString();",
          "new_line_content": "        int64_t to_memory_space =",
          "content_same": false
        },
        {
          "line": 2301,
          "old_api": "back",
          "new_api": null,
          "old_text": "allocations.back()->chunk()",
          "new_text": null,
          "old_line_content": "             allocations.back()->chunk().offset);",
          "new_line_content": "                 end_of_program_prefetch_start_time,",
          "content_same": false
        },
        {
          "line": 4349,
          "old_api": "chunks",
          "new_api": null,
          "old_text": "preset_assignments_->chunks()",
          "new_text": null,
          "old_line_content": "  for (const auto& position_and_chunk : preset_assignments_->chunks()) {",
          "new_line_content": "            << \"Asynchronous copy to the same memory space: \"",
          "content_same": false
        },
        {
          "line": 2304,
          "old_api": "size",
          "new_api": null,
          "old_text": "allocations_->size()",
          "new_text": null,
          "old_line_content": "  const int allocations_initial_size = allocations_->size();",
          "new_line_content": "                 cross_program_prefetch_offset,",
          "content_same": false
        },
        {
          "line": 4353,
          "old_api": "GetUniqueBufferAt",
          "new_api": null,
          "old_text": "alias_analysis->GetUniqueBufferAt(position.instruction, position.index)",
          "new_text": null,
          "old_line_content": "        alias_analysis->GetUniqueBufferAt(position.instruction, position.index);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 4354,
          "old_api": "id",
          "new_api": null,
          "old_text": "buffer.id()",
          "new_text": null,
          "old_line_content": "    CHECK(!seen_buffers.contains(buffer.id()))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2308,
          "old_api": "start_time",
          "new_api": null,
          "old_text": "allocation->start_time()",
          "new_text": null,
          "old_line_content": "      buffer_interval.start = allocation->start_time();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2309,
          "old_api": "end_time",
          "new_api": null,
          "old_text": "allocation->end_time()",
          "new_text": null,
          "old_line_content": "      buffer_interval.end = allocation->end_time();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4356,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "position.ToString()",
          "new_text": null,
          "old_line_content": "        << buffer.ToString() << \", pos: \" << position.ToString()",
          "new_line_content": "    const HloPosition& position = position_and_chunk.first;",
          "content_same": false
        },
        {
          "line": 4358,
          "old_api": "id",
          "new_api": null,
          "old_text": "buffer.id()",
          "new_text": null,
          "old_line_content": "    seen_buffers.insert(buffer.id());",
          "new_line_content": "    const HloBuffer& buffer =",
          "content_same": false
        },
        {
          "line": 4365,
          "old_api": "GetUses",
          "new_api": null,
          "old_text": "value->GetUses()",
          "new_text": null,
          "old_line_content": "      for (const HloUse& use : value->GetUses()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4367,
          "old_api": "at",
          "new_api": null,
          "old_text": "hlo_live_range->instruction_schedule().at(use.instruction)",
          "new_text": null,
          "old_line_content": "            hlo_live_range->instruction_schedule().at(use.instruction);",
          "new_line_content": "      const HloLiveRange::TimeBound& time_bound =",
          "content_same": false
        },
        {
          "line": 2321,
          "old_api": "at",
          "new_api": null,
          "old_text": "allocations_->at(i)",
          "new_text": null,
          "old_line_content": "    const auto& allocation = allocations_->at(i);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2322,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "allocation->memory_space()",
          "new_text": null,
          "old_line_content": "    if (allocation->memory_space() == MemorySpace::kAlternate) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2323,
          "old_api": "size",
          "new_api": null,
          "old_text": "MakeRepackAllocationBlock(\n          allocation->start_time(), allocation->end_time(),\n          allocation->chunk().size, allocation->chunk().offset,\n          static_cast<int64_t>(colocations.size()), allocation.get())",
          "new_text": null,
          "old_line_content": "      repack_allocation_blocks_.push_back(MakeRepackAllocationBlock(",
          "new_line_content": "  // Add a repack allocation block for the Allocation objects in alternate",
          "content_same": false
        },
        {
          "line": 2324,
          "old_api": "end_time",
          "new_api": null,
          "old_text": "allocation->end_time()",
          "new_text": null,
          "old_line_content": "          allocation->start_time(), allocation->end_time(),",
          "new_line_content": "  // memory.",
          "content_same": false
        },
        {
          "line": 2325,
          "old_api": "chunk",
          "new_api": null,
          "old_text": "allocation->chunk()",
          "new_text": null,
          "old_line_content": "          allocation->chunk().size, allocation->chunk().offset,",
          "new_line_content": "  std::vector<RepackAllocationBlock*> colocations;",
          "content_same": false
        },
        {
          "line": 4383,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "        VLOG(3) << indent_string",
          "new_line_content": "      split_conditional_buffer = [&](const HloInstruction* use_instruction,",
          "content_same": false
        },
        {
          "line": 4384,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "buffer.ToString()",
          "new_text": null,
          "old_line_content": "                << \"Splitting conditional buffer: \" << buffer.ToString()",
          "new_line_content": "                                     int64_t start_time, int64_t end_time,",
          "content_same": false
        },
        {
          "line": 2337,
          "old_api": "ClearPendingChunks",
          "new_api": null,
          "old_text": "ClearPendingChunks()",
          "new_text": null,
          "old_line_content": "  ClearPendingChunks();",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 4385,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "value->ToShortString()",
          "new_text": null,
          "old_line_content": "                << \" value: \" << value->ToShortString() << \": (\" << start_time",
          "new_line_content": "                                     absl::string_view indent_string) {",
          "content_same": false
        },
        {
          "line": 2342,
          "old_api": "flattened_instruction_sequence",
          "new_api": null,
          "old_text": "hlo_live_range_.flattened_instruction_sequence().instructions()",
          "new_text": null,
          "old_line_content": "      hlo_live_range_.flattened_instruction_sequence().instructions();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2344,
          "old_api": "size",
          "new_api": null,
          "old_text": "instruction_sequence.size()",
          "new_text": null,
          "old_line_content": "  for (int i = 0; i < instruction_sequence.size(); ++i) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 4392,
          "old_api": "at",
          "new_api": null,
          "old_text": "hlo_live_range->computation_span_times()\n                  .at(called_computation)",
          "new_text": null,
          "old_line_content": "              hlo_live_range->computation_span_times()",
          "new_line_content": "                << \", \" << end_time << \") off: \" << chunk.offset",
          "content_same": false
        },
        {
          "line": 2347,
          "old_api": "reserved_scoped_memory_fn",
          "new_api": null,
          "old_text": "options_.reserved_scoped_memory_fn(instruction)",
          "new_text": null,
          "old_line_content": "        options_.reserved_scoped_memory_fn(instruction);",
          "new_line_content": "  const auto& instruction_sequence =",
          "content_same": false
        },
        {
          "line": 2349,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(1)",
          "new_text": null,
          "old_line_content": "      VLOG(1) << \"Allocate reserved scoped memory at \" << i << \" (\"",
          "new_line_content": "  std::vector<MemorySpaceAssignmentRepacker::AllocationBlock*> colocations;",
          "content_same": false
        },
        {
          "line": 4399,
          "old_api": "GetUses",
          "new_api": null,
          "old_text": "value->GetUses()",
          "new_text": null,
          "old_line_content": "          for (const HloUse& use : value->GetUses()) {",
          "new_line_content": "                  .at(called_computation)",
          "content_same": false
        },
        {
          "line": 4401,
          "old_api": "at",
          "new_api": null,
          "old_text": "hlo_live_range->instruction_schedule().at(use.instruction)",
          "new_text": null,
          "old_line_content": "                hlo_live_range->instruction_schedule().at(use.instruction);",
          "new_line_content": "          earliest_computation_start_time =",
          "content_same": false
        },
        {
          "line": 2359,
          "old_api": "FindChunkCandidate",
          "new_api": null,
          "old_text": "FindChunkCandidate(interval, /*preferred_offset=*/0)",
          "new_text": null,
          "old_line_content": "          FindChunkCandidate(interval, /*preferred_offset=*/0);",
          "new_line_content": "      interval.size = reserved_scoped_memory;",
          "content_same": false
        },
        {
          "line": 2360,
          "old_api": "CHECK_EQ",
          "new_api": null,
          "old_text": "CHECK_EQ(chunk_candidate.offset, 0)",
          "new_text": null,
          "old_line_content": "      CHECK_EQ(chunk_candidate.offset, 0);",
          "new_line_content": "      interval.start = i;",
          "content_same": false
        },
        {
          "line": 2361,
          "old_api": "AddToPendingChunks",
          "new_api": null,
          "old_text": "AddToPendingChunks(interval, chunk_candidate)",
          "new_text": null,
          "old_line_content": "      AddToPendingChunks(interval, chunk_candidate);",
          "new_line_content": "      interval.end = i;",
          "content_same": false
        },
        {
          "line": 4409,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "            VLOG(3) << indent_string",
          "new_line_content": "                use_time > last_use_time) {",
          "content_same": false
        },
        {
          "line": 2363,
          "old_api": "VLOG_IS_ON",
          "new_api": null,
          "old_text": "VLOG_IS_ON(3)",
          "new_text": null,
          "old_line_content": "      if (options_.dump_fn != nullptr || VLOG_IS_ON(3)) {",
          "new_line_content": "      interval.colocations = {};",
          "content_same": false
        },
        {
          "line": 2364,
          "old_api": "AppendScopedAllocationBufferInfoDebugString",
          "new_api": null,
          "old_text": "AppendScopedAllocationBufferInfoDebugString(\n            instruction, i, reserved_scoped_memory, buffer_info_str_)",
          "new_text": null,
          "old_line_content": "        AppendScopedAllocationBufferInfoDebugString(",
          "new_line_content": "      Chunk chunk_candidate =",
          "content_same": false
        },
        {
          "line": 4410,
          "old_api": "name",
          "new_api": null,
          "old_text": "called_computation->name()",
          "new_text": null,
          "old_line_content": "                    << \" computation: \" << called_computation->name() << \": (\"",
          "new_line_content": "              last_use_time = use_time;",
          "content_same": false
        },
        {
          "line": 4412,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(last_use_instruction)",
          "new_text": null,
          "old_line_content": "            CHECK(last_use_instruction);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 4413,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "last_use_instruction->opcode()",
          "new_text": null,
          "old_line_content": "            if (last_use_instruction->opcode() == HloOpcode::kConditional) {",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 2368,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "allocations_->push_back(\n          std::make_unique<MemorySpaceAssignment::Allocation>(\n              HloPosition{instruction_sequence[i], {}}, MemorySpace::kAlternate,\n              chunk_candidate, i, i, /*is_scoped_allocation=*/true))",
          "new_text": null,
          "old_line_content": "      allocations_->push_back(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4420,
          "old_api": "std::min(last_use_time, end_time)",
          "new_api": null,
          "old_text": "std::min(last_use_time, end_time)",
          "new_text": null,
          "old_line_content": "              last_use_time = std::min(last_use_time, end_time);",
          "new_line_content": "              // The last use is another (nested) conditional. Call this",
          "content_same": false
        },
        {
          "line": 2373,
          "old_api": "size",
          "new_api": null,
          "old_text": "MakeRepackAllocationBlock(\n          i, i, reserved_scoped_memory,\n          /*initial_offset=*/0,\n          static_cast<int64_t>(repack_allocation_blocks_.size()),\n          allocations_->back().get())",
          "new_text": null,
          "old_line_content": "      repack_allocation_blocks_.push_back(MakeRepackAllocationBlock(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4421,
          "old_api": "add_allocation_and_verify",
          "new_api": null,
          "old_text": "add_allocation_and_verify(\n                  computation_start_time, last_use_time, chunk, value)",
          "new_text": null,
          "old_line_content": "              TF_RETURN_IF_ERROR(add_allocation_and_verify(",
          "new_line_content": "              // function recursively.",
          "content_same": false
        },
        {
          "line": 2376,
          "old_api": "size",
          "new_api": null,
          "old_text": "repack_allocation_blocks_.size()",
          "new_text": null,
          "old_line_content": "          static_cast<int64_t>(repack_allocation_blocks_.size()),",
          "new_line_content": "              HloPosition{instruction_sequence[i], {}}, MemorySpace::kAlternate,",
          "content_same": false
        },
        {
          "line": 2377,
          "old_api": "get",
          "new_api": null,
          "old_text": "allocations_->back().get()",
          "new_text": null,
          "old_line_content": "          allocations_->back().get()));",
          "new_line_content": "              chunk_candidate, i, i, /*is_scoped_allocation=*/true));",
          "content_same": false
        },
        {
          "line": 2378,
          "old_api": "back",
          "new_api": null,
          "old_text": "repack_allocation_blocks_.back()",
          "new_text": null,
          "old_line_content": "      colocations.push_back(&repack_allocation_blocks_.back());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4429,
          "old_api": "add_allocation_and_verify",
          "new_api": null,
          "old_text": "add_allocation_and_verify(\n            start_time, earliest_computation_start_time - 1, chunk, value)",
          "new_text": null,
          "old_line_content": "        TF_RETURN_IF_ERROR(add_allocation_and_verify(",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 4431,
          "old_api": "OkStatus",
          "new_api": null,
          "old_text": "OkStatus()",
          "new_text": null,
          "old_line_content": "        return OkStatus();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 4436,
          "old_api": "split_conditional_buffer",
          "new_api": null,
          "old_text": "split_conditional_buffer(\n            last_use_instruction, time_bound.start, time_bound.end, \" \")",
          "new_text": null,
          "old_line_content": "        TF_RETURN_IF_ERROR(split_conditional_buffer(",
          "new_line_content": "            start_time, earliest_computation_start_time - 1, chunk, value));",
          "content_same": false
        },
        {
          "line": 4438,
          "old_api": "empty",
          "new_api": null,
          "old_text": "value->GetUses().empty()",
          "new_text": null,
          "old_line_content": "      } else if (!value->GetUses().empty()) {",
          "new_line_content": "      };",
          "content_same": false
        },
        {
          "line": 4439,
          "old_api": "std::min(last_use_time, time_bound.end)",
          "new_api": null,
          "old_text": "std::min(last_use_time, time_bound.end)",
          "new_text": null,
          "old_line_content": "        last_use_time = std::min(last_use_time, time_bound.end);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2392,
          "old_api": "ClearPendingChunks",
          "new_api": null,
          "old_text": "ClearPendingChunks()",
          "new_text": null,
          "old_line_content": "  ClearPendingChunks();",
          "new_line_content": "  if (options_.allocate_reserved_scoped_memory_at_same_offset) {",
          "content_same": false
        },
        {
          "line": 4440,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "buffer.ToString()",
          "new_text": null,
          "old_line_content": "        VLOG(3) << \" buffer: \" << buffer.ToString()",
          "new_line_content": "      if (last_use_instruction &&",
          "content_same": false
        },
        {
          "line": 2400,
          "old_api": "end",
          "new_api": null,
          "old_text": "required_assignments_.end()",
          "new_text": null,
          "old_line_content": "  if (required_assignment_it != required_assignments_.end()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4451,
          "old_api": "assignment_information_for_space",
          "new_api": null,
          "old_text": "preset_assignments_\n           ->assignment_information_for_space(options_.alternate_memory_space)",
          "new_text": null,
          "old_line_content": "      &preset_assignments_",
          "new_line_content": "            time_bound.start, last_use_time, chunk, value));",
          "content_same": false
        },
        {
          "line": 2405,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(!required_assignment_at_time)",
          "new_text": null,
          "old_line_content": "        CHECK(!required_assignment_at_time)",
          "new_line_content": "  std::optional<RequiredMemoryAssignment> required_assignment_at_time;",
          "content_same": false
        },
        {
          "line": 4460,
          "old_api": "std::tie(time, is_free, buffer_id)",
          "new_api": null,
          "old_text": "std::tie(time, is_free, buffer_id)",
          "new_text": null,
          "old_line_content": "    std::tie(time, is_free, buffer_id) = event.first;",
          "new_line_content": "  int64_t memory_usage = 0;",
          "content_same": false
        },
        {
          "line": 4464,
          "old_api": "std::tie(value, chunk, kind)",
          "new_api": null,
          "old_text": "std::tie(value, chunk, kind)",
          "new_text": null,
          "old_line_content": "    std::tie(value, chunk, kind) = event.second;",
          "new_line_content": "    bool is_free;",
          "content_same": false
        },
        {
          "line": 4465,
          "old_api": "add_events",
          "new_api": null,
          "old_text": "heap_trace->add_events()",
          "new_text": null,
          "old_line_content": "    HeapSimulatorTrace::Event* heap_trace_event = heap_trace->add_events();",
          "new_line_content": "    int64_t buffer_id;",
          "content_same": false
        },
        {
          "line": 4467,
          "old_api": "set_buffer_id",
          "new_api": null,
          "old_text": "heap_trace_event->set_buffer_id(buffer_id)",
          "new_text": null,
          "old_line_content": "    heap_trace_event->set_buffer_id(buffer_id);",
          "new_line_content": "    const HloValue* value;",
          "content_same": false
        },
        {
          "line": 2420,
          "old_api": "dataflow_analysis",
          "new_api": null,
          "old_text": "alias_analysis_.dataflow_analysis().GetUniqueValueAt(\n            position.instruction, position.index)",
          "new_text": null,
          "old_line_content": "        &alias_analysis_.dataflow_analysis().GetUniqueValueAt(",
          "new_line_content": "std::optional<AlternateMemoryBestFitHeap::RequiredMemoryAssignment>",
          "content_same": false
        },
        {
          "line": 4468,
          "old_api": "instruction",
          "new_api": null,
          "old_text": "value->instruction()->name()",
          "new_text": null,
          "old_line_content": "    heap_trace_event->set_instruction_name(value->instruction()->name());",
          "new_line_content": "    Chunk chunk;",
          "content_same": false
        },
        {
          "line": 4469,
          "old_api": "set_computation_name",
          "new_api": null,
          "old_text": "heap_trace_event->set_computation_name(\n        value->instruction()->parent()->name())",
          "new_text": null,
          "old_line_content": "    heap_trace_event->set_computation_name(",
          "new_line_content": "    HeapSimulatorTrace::Event::Kind kind;",
          "content_same": false
        },
        {
          "line": 2423,
          "old_api": "instruction_schedule",
          "new_api": null,
          "old_text": "hlo_live_range_.instruction_schedule().at(position.instruction)",
          "new_text": null,
          "old_line_content": "        hlo_live_range_.instruction_schedule().at(position.instruction);",
          "new_line_content": "  std::optional<RequiredMemoryAssignment> required_assignment;",
          "content_same": false
        },
        {
          "line": 2425,
          "old_api": "RequiredMemoryAssignmentAt",
          "new_api": null,
          "old_text": "RequiredMemoryAssignmentAt(value, time)",
          "new_text": null,
          "old_line_content": "        RequiredMemoryAssignmentAt(value, time);",
          "new_line_content": "    const HloValue* value =",
          "content_same": false
        },
        {
          "line": 2430,
          "old_api": "equals_ignoring_time",
          "new_api": null,
          "old_text": "required_assignment->equals_ignoring_time(\n                *required_assignment_for_alias)",
          "new_text": null,
          "old_line_content": "            required_assignment->equals_ignoring_time(",
          "new_line_content": "    std::optional<RequiredMemoryAssignment> required_assignment_for_alias =",
          "content_same": false
        },
        {
          "line": 4478,
          "old_api": "std::max(max_memory_usage, memory_usage)",
          "new_api": null,
          "old_text": "std::max(max_memory_usage, memory_usage)",
          "new_text": null,
          "old_line_content": "    max_memory_usage = std::max(max_memory_usage, memory_usage);",
          "new_line_content": "    if (kind == HeapSimulatorTrace::Event::ALLOC) {",
          "content_same": false
        },
        {
          "line": 4479,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(4)",
          "new_text": null,
          "old_line_content": "    VLOG(4) << \"Memory usage: \" << memory_usage << \" at time: \" << time;",
          "new_line_content": "      memory_usage += chunk.size;",
          "content_same": false
        },
        {
          "line": 4483,
          "old_api": "OkStatus",
          "new_api": null,
          "old_text": "OkStatus()",
          "new_text": null,
          "old_line_content": "  return OkStatus();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2441,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "aliased_allocation->memory_space()",
          "new_text": null,
          "old_line_content": "  if (aliased_allocation->memory_space() == MemorySpace::kAlternate) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2442,
          "old_api": "GetAliasedOffset",
          "new_api": null,
          "old_text": "GetAliasedOffset(*aliased_allocation)",
          "new_text": null,
          "old_line_content": "    offset = GetAliasedOffset(*aliased_allocation);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2444,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "aliased_allocation->memory_space()",
          "new_text": null,
          "old_line_content": "  AddRequiredAssignment(instruction, index, aliased_allocation->memory_space(),",
          "new_line_content": "    const HloInstruction* instruction, ShapeIndex index,",
          "content_same": false
        },
        {
          "line": 2454,
          "old_api": "RequiredMemoryAssignmentAt",
          "new_api": null,
          "old_text": "RequiredMemoryAssignmentAt(value, time)",
          "new_text": null,
          "old_line_content": "  auto existing_required_assignment = RequiredMemoryAssignmentAt(value, time);",
          "new_line_content": "void AlternateMemoryBestFitHeap::AddRequiredAssignment(",
          "content_same": false
        },
        {
          "line": 2456,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(memory_space == existing_required_assignment->memory_space)",
          "new_text": null,
          "old_line_content": "    CHECK(memory_space == existing_required_assignment->memory_space)",
          "new_line_content": "    MemorySpaceAssignment::MemorySpace memory_space, int64_t time,",
          "content_same": false
        },
        {
          "line": 2457,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "instruction->ToString()",
          "new_text": null,
          "old_line_content": "        << \"inst = \" << instruction->ToString() << \" at \" << time;",
          "new_line_content": "    AliasedOffset* offset, bool add_to_pending) {",
          "content_same": false
        },
        {
          "line": 2458,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK((!offset && !existing_required_assignment->offset) ||\n          offset == existing_required_assignment->offset)",
          "new_text": null,
          "old_line_content": "    CHECK((!offset && !existing_required_assignment->offset) ||",
          "new_line_content": "  // Check for existing required assignment at this time and make sure it is the",
          "content_same": false
        },
        {
          "line": 2461,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "value->ToShortString()",
          "new_text": null,
          "old_line_content": "            << value->ToShortString() << \" at \" << time << \" at \"",
          "new_line_content": "  if (existing_required_assignment) {",
          "content_same": false
        },
        {
          "line": 2468,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "required_assignments_[value].push_back(required_assignment)",
          "new_text": null,
          "old_line_content": "    required_assignments_[value].push_back(required_assignment);",
          "new_line_content": "            << (memory_space == MemorySpace::kDefault ? \"def\" : \"alt\");",
          "content_same": false
        },
        {
          "line": 2479,
          "old_api": "dataflow_analysis",
          "new_api": null,
          "old_text": "alias_analysis_.dataflow_analysis().GetUniqueValueAt(instruction, index)",
          "new_text": null,
          "old_line_content": "      &alias_analysis_.dataflow_analysis().GetUniqueValueAt(instruction, index);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2481,
          "old_api": "instruction_schedule",
          "new_api": null,
          "old_text": "hlo_live_range_.instruction_schedule().at(instruction)",
          "new_text": null,
          "old_line_content": "      hlo_live_range_.instruction_schedule().at(instruction);",
          "new_line_content": "void AlternateMemoryBestFitHeap::AddRequiredAssignment(",
          "content_same": false
        },
        {
          "line": 2482,
          "old_api": "AddRequiredAssignment",
          "new_api": null,
          "old_text": "AddRequiredAssignment(value, instruction, memory_space, instruction_time,\n                        offset)",
          "new_text": null,
          "old_line_content": "  AddRequiredAssignment(value, instruction, memory_space, instruction_time,",
          "new_line_content": "    const HloInstruction* instruction, ShapeIndex index,",
          "content_same": false
        },
        {
          "line": 2489,
          "old_api": "dataflow_analysis",
          "new_api": null,
          "old_text": "alias_analysis_.dataflow_analysis().module()",
          "new_text": null,
          "old_line_content": "  const HloModule& module = alias_analysis_.dataflow_analysis().module();",
          "new_line_content": "                        offset);",
          "content_same": false
        },
        {
          "line": 2490,
          "old_api": "instruction_schedule",
          "new_api": null,
          "old_text": "hlo_live_range_.instruction_schedule()",
          "new_text": null,
          "old_line_content": "  const auto& instruction_schedule = hlo_live_range_.instruction_schedule();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2491,
          "old_api": "entry_computation",
          "new_api": null,
          "old_text": "module.entry_computation()",
          "new_text": null,
          "old_line_content": "  HloComputation* entry_computation = module.entry_computation();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2493,
          "old_api": "parameter_instructions",
          "new_api": null,
          "old_text": "entry_computation->parameter_instructions()",
          "new_text": null,
          "old_line_content": "       entry_computation->parameter_instructions()) {",
          "new_line_content": "  // Go through the parameters, outputs, and constants and pin them to the",
          "content_same": false
        },
        {
          "line": 2500,
          "old_api": "layout",
          "new_api": null,
          "old_text": "subshape.layout().memory_space()",
          "new_text": null,
          "old_line_content": "          if (subshape.has_layout() && subshape.layout().memory_space() ==",
          "new_line_content": "    int64_t parameter_instruction_time =",
          "content_same": false
        },
        {
          "line": 2505,
          "old_api": "ComputeBuffersAt",
          "new_api": null,
          "old_text": "alias_analysis_.ComputeBuffersAt(parameter_instruction, index)",
          "new_text": null,
          "old_line_content": "               alias_analysis_.ComputeBuffersAt(parameter_instruction, index)) {",
          "new_line_content": "          MemorySpace memory_space = MemorySpace::kDefault;",
          "content_same": false
        },
        {
          "line": 2507,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "              VLOG(3) << \"Adding required assignment for parameter value = \"",
          "new_line_content": "                                           options_.alternate_memory_space) {",
          "content_same": false
        },
        {
          "line": 2508,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "value->ToShortString()",
          "new_text": null,
          "old_line_content": "                      << value->ToShortString()",
          "new_line_content": "            memory_space = MemorySpace::kAlternate;",
          "content_same": false
        },
        {
          "line": 2520,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "entry_computation->root_instruction()",
          "new_text": null,
          "old_line_content": "  HloInstruction* root_instruction = entry_computation->root_instruction();",
          "new_line_content": "                                    /*offset=*/nullptr,",
          "content_same": false
        },
        {
          "line": 2521,
          "old_api": "at",
          "new_api": null,
          "old_text": "instruction_schedule.at(root_instruction)",
          "new_text": null,
          "old_line_content": "  int64_t root_instruction_time = instruction_schedule.at(root_instruction);",
          "new_line_content": "                                    /*add_to_pending=*/false);",
          "content_same": false
        },
        {
          "line": 2522,
          "old_api": "has_layout",
          "new_api": null,
          "old_text": "ShapeUtil::ForEachSubshape(\n      root_instruction->shape(),\n      [&](const Shape& subshape, const ShapeIndex& index) {\n        MemorySpace memory_space = MemorySpace::kDefault;\n        if (subshape.has_layout() && subshape.layout().memory_space() ==\n                                         options_.alternate_memory_space) {\n          memory_space = MemorySpace::kAlternate;\n        }\n        for (const HloBuffer* buffer :\n             alias_analysis_.ComputeBuffersAt(root_instruction, index)) {\n          for (const HloValue* value : buffer->values()) {\n            VLOG(3) << \"Adding required assignment for output value = \"\n                    << value->ToShortString()\n                    << \" time = \" << root_instruction_time << \" space = \"\n                    << (memory_space == MemorySpace::kDefault ? \"def\" : \"alt\");\n            AddRequiredAssignment(value, root_instruction, memory_space,\n                                  root_instruction_time,\n                                  /*offset=*/nullptr, /*add_to_pending=*/false);\n          }\n        }\n      })",
          "new_text": null,
          "old_line_content": "  ShapeUtil::ForEachSubshape(",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2523,
          "old_api": "shape",
          "new_api": null,
          "old_text": "root_instruction->shape()",
          "new_text": null,
          "old_line_content": "      root_instruction->shape(),",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 2531,
          "old_api": "ComputeBuffersAt",
          "new_api": null,
          "old_text": "alias_analysis_.ComputeBuffersAt(root_instruction, index)",
          "new_text": null,
          "old_line_content": "             alias_analysis_.ComputeBuffersAt(root_instruction, index)) {",
          "new_line_content": "        MemorySpace memory_space = MemorySpace::kDefault;",
          "content_same": false
        },
        {
          "line": 2533,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "            VLOG(3) << \"Adding required assignment for output value = \"",
          "new_line_content": "                                         options_.alternate_memory_space) {",
          "content_same": false
        },
        {
          "line": 2534,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "value->ToShortString()",
          "new_text": null,
          "old_line_content": "                    << value->ToShortString()",
          "new_line_content": "          memory_space = MemorySpace::kAlternate;",
          "content_same": false
        },
        {
          "line": 2544,
          "old_api": "MakeNonfusionComputations",
          "new_api": null,
          "old_text": "module.MakeNonfusionComputations()",
          "new_text": null,
          "old_line_content": "  for (const HloComputation* computation : module.MakeNonfusionComputations()) {",
          "new_line_content": "                                  root_instruction_time,",
          "content_same": false
        },
        {
          "line": 2545,
          "old_api": "instructions",
          "new_api": null,
          "old_text": "computation->instructions()",
          "new_text": null,
          "old_line_content": "    for (HloInstruction* instruction : computation->instructions()) {",
          "new_line_content": "                                  /*offset=*/nullptr, /*add_to_pending=*/false);",
          "content_same": false
        },
        {
          "line": 2546,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "instruction->opcode()",
          "new_text": null,
          "old_line_content": "      if (instruction->opcode() == HloOpcode::kConstant) {",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 2547,
          "old_api": "find",
          "new_api": null,
          "old_text": "instruction_schedule.find(instruction)",
          "new_text": null,
          "old_line_content": "        auto constant_instruction_it = instruction_schedule.find(instruction);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2548,
          "old_api": "end",
          "new_api": null,
          "old_text": "instruction_schedule.end()",
          "new_text": null,
          "old_line_content": "        if (constant_instruction_it == instruction_schedule.end()) {",
          "new_line_content": "      });",
          "content_same": false
        },
        {
          "line": 2556,
          "old_api": "ComputeBuffersAt",
          "new_api": null,
          "old_text": "alias_analysis_.ComputeBuffersAt(instruction, index)",
          "new_text": null,
          "old_line_content": "               alias_analysis_.ComputeBuffersAt(instruction, index)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2557,
          "old_api": "values",
          "new_api": null,
          "old_text": "buffer->values()",
          "new_text": null,
          "old_line_content": "            for (const HloValue* value : buffer->values()) {",
          "new_line_content": "        int64_t constant_instruction_time = constant_instruction_it->second;",
          "content_same": false
        },
        {
          "line": 2558,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "              VLOG(3) << \"Adding required assignment for constant value = \"",
          "new_line_content": "        for (const auto& indexed_shape :",
          "content_same": false
        },
        {
          "line": 2575,
          "old_api": "dataflow_analysis",
          "new_api": null,
          "old_text": "alias_analysis_.dataflow_analysis().values()",
          "new_text": null,
          "old_line_content": "  for (const HloValue* value : alias_analysis_.dataflow_analysis().values()) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2576,
          "old_api": "is_allowed_in_alternate_mem_fn",
          "new_api": null,
          "old_text": "options_.is_allowed_in_alternate_mem_fn(*value)",
          "new_text": null,
          "old_line_content": "    if (!options_.is_allowed_in_alternate_mem_fn(*value)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2580,
          "old_api": "instruction",
          "new_api": null,
          "old_text": "value->instruction()",
          "new_text": null,
          "old_line_content": "          instruction_schedule.find(value->instruction());",
          "new_line_content": "  // not allowed on the alternate memory.",
          "content_same": false
        },
        {
          "line": 2589,
          "old_api": "absl::c_find_if(\n          required_assignments,\n          [&](const RequiredMemoryAssignment& required_assignment) {\n            return required_assignment.time == instruction_time;\n          })",
          "new_api": null,
          "old_text": "absl::c_find_if(\n          required_assignments,\n          [&](const RequiredMemoryAssignment& required_assignment) {\n            return required_assignment.time == instruction_time;\n          })",
          "new_text": null,
          "old_line_content": "      auto matching_assignment = absl::c_find_if(",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2594,
          "old_api": "end",
          "new_api": null,
          "old_text": "required_assignments.end()",
          "new_text": null,
          "old_line_content": "      if (matching_assignment != required_assignments.end()) {",
          "new_line_content": "      // memory allocation.",
          "content_same": false
        },
        {
          "line": 2597,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "value->ToString()",
          "new_text": null,
          "old_line_content": "            << \" value: \" << value->ToString();",
          "new_line_content": "          [&](const RequiredMemoryAssignment& required_assignment) {",
          "content_same": false
        },
        {
          "line": 2599,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "required_assignments.push_back(\n            {MemorySpace::kDefault, instruction_time})",
          "new_text": null,
          "old_line_content": "        required_assignments.push_back(",
          "new_line_content": "          });",
          "content_same": false
        },
        {
          "line": 2609,
          "old_api": "shape",
          "new_api": null,
          "old_text": "position.shape()",
          "new_text": null,
          "old_line_content": "    const Shape& shape = position.shape();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2610,
          "old_api": "has_layout",
          "new_api": null,
          "old_text": "shape.has_layout()",
          "new_text": null,
          "old_line_content": "    return shape.has_layout() &&",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2611,
          "old_api": "layout",
          "new_api": null,
          "old_text": "shape.layout().memory_space()",
          "new_text": null,
          "old_line_content": "           shape.layout().memory_space() == options_.alternate_memory_space;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2614,
          "old_api": "dataflow_analysis",
          "new_api": null,
          "old_text": "alias_analysis_.dataflow_analysis().module()",
          "new_text": null,
          "old_line_content": "  const HloModule& module = alias_analysis_.dataflow_analysis().module();",
          "new_line_content": "  auto is_position_in_alternate_memory = [&](const HloPosition& position) {",
          "content_same": false
        },
        {
          "line": 2622,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "value->defining_position()",
          "new_text": null,
          "old_line_content": "        is_position_in_alternate_memory(value->defining_position())) {",
          "new_line_content": "  const HloInstruction* root_instruction =",
          "content_same": false
        },
        {
          "line": 2639,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "allocations.push_back(&allocation_block)",
          "new_text": null,
          "old_line_content": "    allocations.push_back(&allocation_block);",
          "new_line_content": "  return false;",
          "content_same": false
        },
        {
          "line": 2647,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "allocation->ToString()",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \"Moved \" << allocation->ToString() << \", size \"",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2648,
          "old_api": "chunk",
          "new_api": null,
          "old_text": "allocation->chunk()",
          "new_text": null,
          "old_line_content": "            << allocation->chunk().size << \", (\" << allocation_block.start_time",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2652,
          "old_api": "mutable_chunk",
          "new_api": null,
          "old_text": "allocation_block.allocation->mutable_chunk()",
          "new_text": null,
          "old_line_content": "    allocation_block.allocation->mutable_chunk()->offset =",
          "new_line_content": "    MemorySpaceAssignment::Allocation* allocation = allocation_block.allocation;",
          "content_same": false
        },
        {
          "line": 2666,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "allocation_value.allocation_sequence()->clear()",
          "new_text": null,
          "old_line_content": "    allocation_value.allocation_sequence()->clear();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2671,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \"Uncommitting: (\" << interval.start << \", \" << interval.end",
          "new_line_content": "  for (AllocationValue& allocation_value : allocation_values) {",
          "content_same": false
        },
        {
          "line": 2675,
          "old_api": "CHECK_GE",
          "new_api": null,
          "old_text": "CHECK_GE(peak_memory_usage_[i], 0)",
          "new_text": null,
          "old_line_content": "      CHECK_GE(peak_memory_usage_[i], 0)",
          "new_line_content": "    const BufferInterval& interval = interval_and_chunk.first;",
          "content_same": false
        },
        {
          "line": 2685,
          "old_api": "Remove",
          "new_api": null,
          "old_text": "prefetch_interval_tree_.Remove(interval.start_time, interval.end_time,\n                                     kDummyChunk)",
          "new_text": null,
          "old_line_content": "      prefetch_interval_tree_.Remove(interval.start_time, interval.end_time,",
          "new_line_content": "          << \"]\";",
          "content_same": false
        },
        {
          "line": 2689,
          "old_api": "Remove",
          "new_api": null,
          "old_text": "eviction_interval_tree_.Remove(interval.start_time, interval.end_time,\n                                     kDummyChunk)",
          "new_text": null,
          "old_line_content": "      eviction_interval_tree_.Remove(interval.start_time, interval.end_time,",
          "new_line_content": "  for (const auto& interval : pending_async_copies_) {",
          "content_same": false
        },
        {
          "line": 2700,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \"Removing required assignment: \"",
          "new_line_content": "  for (const auto& value_and_required_assignment :",
          "content_same": false
        },
        {
          "line": 2707,
          "old_api": "begin",
          "new_api": null,
          "old_text": "required_assignment_vector.begin()",
          "new_text": null,
          "old_line_content": "    for (auto it = required_assignment_vector.begin();",
          "new_line_content": "            << (required_assignment.memory_space == MemorySpace::kDefault",
          "content_same": false
        },
        {
          "line": 2708,
          "old_api": "end",
          "new_api": null,
          "old_text": "required_assignment_vector.end()",
          "new_text": null,
          "old_line_content": "         it != required_assignment_vector.end(); ++it) {",
          "new_line_content": "                    ? \"def\"",
          "content_same": false
        },
        {
          "line": 2710,
          "old_api": "erase",
          "new_api": null,
          "old_text": "required_assignment_vector.erase(it)",
          "new_text": null,
          "old_line_content": "        required_assignment_vector.erase(it);",
          "new_line_content": "            << \" time = \" << required_assignment.time << \" off = \"",
          "content_same": false
        },
        {
          "line": 2715,
          "old_api": "ClearPendingChunks",
          "new_api": null,
          "old_text": "ClearPendingChunks()",
          "new_text": null,
          "old_line_content": "  ClearPendingChunks();",
          "new_line_content": "      if (*it == value_and_required_assignment.second) {",
          "content_same": false
        },
        {
          "line": 2724,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "allocation_value.allocation_sequence()",
          "new_text": null,
          "old_line_content": "    for (auto& allocation : *allocation_value.allocation_sequence()) {",
          "new_line_content": "void AlternateMemoryBestFitHeap::FinalizeAllocations(",
          "content_same": false
        },
        {
          "line": 2725,
          "old_api": "std::move(allocation)",
          "new_api": null,
          "old_text": "std::move(allocation)",
          "new_text": null,
          "old_line_content": "      allocations_->push_back(std::move(allocation));",
          "new_line_content": "    absl::Span<AllocationValue> allocation_values) {",
          "content_same": false
        },
        {
          "line": 2727,
          "old_api": "get",
          "new_api": null,
          "old_text": "allocations_->back().get()",
          "new_text": null,
          "old_line_content": "          allocations_->back().get();",
          "new_line_content": "                      std::vector<MemorySpaceAssignment::Allocation*>>",
          "content_same": false
        },
        {
          "line": 2728,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "inserted_allocation->memory_space()",
          "new_text": null,
          "old_line_content": "      if (inserted_allocation->memory_space() == MemorySpace::kAlternate) {",
          "new_line_content": "      colocation_map;",
          "content_same": false
        },
        {
          "line": 2729,
          "old_api": "GetAliasedOffset",
          "new_api": null,
          "old_text": "GetAliasedOffset(*inserted_allocation)",
          "new_text": null,
          "old_line_content": "        colocation_map[GetAliasedOffset(*inserted_allocation)].push_back(",
          "new_line_content": "  for (AllocationValue& allocation_value : allocation_values) {",
          "content_same": false
        },
        {
          "line": 2741,
          "old_api": "size",
          "new_api": null,
          "old_text": "MakeRepackAllocationBlock(\n          colocated_allocation->start_time(), colocated_allocation->end_time(),\n          colocated_allocation->chunk().size,\n          colocated_allocation->chunk().offset,\n          static_cast<int64_t>(repack_allocation_blocks_.size()),\n          colocated_allocation)",
          "new_text": null,
          "old_line_content": "      repack_allocation_blocks_.push_back(MakeRepackAllocationBlock(",
          "new_line_content": "  // Export these to repack_allocation_blocks_ so that we can repack them to",
          "content_same": false
        },
        {
          "line": 2742,
          "old_api": "end_time",
          "new_api": null,
          "old_text": "colocated_allocation->end_time()",
          "new_text": null,
          "old_line_content": "          colocated_allocation->start_time(), colocated_allocation->end_time(),",
          "new_line_content": "  // reduce fragmentation.",
          "content_same": false
        },
        {
          "line": 2743,
          "old_api": "chunk",
          "new_api": null,
          "old_text": "colocated_allocation->chunk()",
          "new_text": null,
          "old_line_content": "          colocated_allocation->chunk().size,",
          "new_line_content": "  for (auto& colocation : colocation_map) {",
          "content_same": false
        },
        {
          "line": 2744,
          "old_api": "chunk",
          "new_api": null,
          "old_text": "colocated_allocation->chunk()",
          "new_text": null,
          "old_line_content": "          colocated_allocation->chunk().offset,",
          "new_line_content": "    std::vector<MemorySpaceAssignmentRepacker::AllocationBlock*> colocations;",
          "content_same": false
        },
        {
          "line": 2745,
          "old_api": "size",
          "new_api": null,
          "old_text": "repack_allocation_blocks_.size()",
          "new_text": null,
          "old_line_content": "          static_cast<int64_t>(repack_allocation_blocks_.size()),",
          "new_line_content": "    for (MemorySpaceAssignment::Allocation* colocated_allocation :",
          "content_same": false
        },
        {
          "line": 2754,
          "old_api": "ClearPendingChunks",
          "new_api": null,
          "old_text": "ClearPendingChunks()",
          "new_text": null,
          "old_line_content": "  ClearPendingChunks();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2758,
          "old_api": "clear",
          "new_api": null,
          "old_text": "pending_chunks_.clear()",
          "new_text": null,
          "old_line_content": "  pending_chunks_.clear();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2759,
          "old_api": "clear",
          "new_api": null,
          "old_text": "pending_async_copies_.clear()",
          "new_text": null,
          "old_line_content": "  pending_async_copies_.clear();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2761,
          "old_api": "clear",
          "new_api": null,
          "old_text": "aliased_offset_map_.clear()",
          "new_text": null,
          "old_line_content": "  aliased_offset_map_.clear();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2762,
          "old_api": "clear",
          "new_api": null,
          "old_text": "aliased_offsets_.clear()",
          "new_text": null,
          "old_line_content": "  aliased_offsets_.clear();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2770,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "pending_chunks_.emplace_back(buffer_interval, chunk_candidate)",
          "new_text": null,
          "old_line_content": "  pending_chunks_.emplace_back(buffer_interval, chunk_candidate);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2799,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "request.allocation_value->allocation_sequence()",
          "new_text": null,
          "old_line_content": "  auto allocation_sequence = request.allocation_value->allocation_sequence();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2806,
          "old_api": "CHECK_NE",
          "new_api": null,
          "old_text": "CHECK_NE(allocation, nullptr)",
          "new_text": null,
          "old_line_content": "    CHECK_NE(allocation, nullptr);",
          "new_line_content": "  // start_time == end_time is a special case where the value is consumed",
          "content_same": false
        },
        {
          "line": 2807,
          "old_api": "AddUse",
          "new_api": null,
          "old_text": "allocation->AddUse(request.use->hlo_use)",
          "new_text": null,
          "old_line_content": "    allocation->AddUse(request.use->hlo_use);",
          "new_line_content": "  // multiple times by the same instruction. We can just find the previous",
          "content_same": false
        },
        {
          "line": 2814,
          "old_api": "ToShortString",
          "new_api": null,
          "old_text": "request.allocation_value->ToShortString()",
          "new_text": null,
          "old_line_content": "          << request.allocation_value->ToShortString() << \" (\"",
          "new_line_content": "    return Result::kSuccess;",
          "content_same": false
        },
        {
          "line": 2817,
          "old_api": "back",
          "new_api": null,
          "old_text": "request.allocation_value->uses().back()",
          "new_text": null,
          "old_line_content": "          << \" last use = \" << request.allocation_value->uses().back().time",
          "new_line_content": "  const HloPosition& defining_position =",
          "content_same": false
        },
        {
          "line": 2821,
          "old_api": "CHECK_LE",
          "new_api": null,
          "old_text": "CHECK_LE(request.start_time, request.end_time)",
          "new_text": null,
          "old_line_content": "  CHECK_LE(request.start_time, request.end_time);",
          "new_line_content": "          << request.start_time << \", \" << request.end_time",
          "content_same": false
        },
        {
          "line": 2822,
          "old_api": "VLOG_IS_ON",
          "new_api": null,
          "old_text": "VLOG_IS_ON(3)",
          "new_text": null,
          "old_line_content": "  if (VLOG_IS_ON(3) && options_.cost_analysis) {",
          "new_line_content": "          << \") latest prefetch = \" << request.latest_prefetch_time",
          "content_same": false
        },
        {
          "line": 2825,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "request.allocation_value->defining_position()",
          "new_text": null,
          "old_line_content": "                   request.allocation_value->defining_position())",
          "new_line_content": "          << \". Size = \" << request.size",
          "content_same": false
        },
        {
          "line": 2836,
          "old_api": "value",
          "new_api": null,
          "old_text": "RequiredMemoryAssignmentAt(\n      request.allocation_value->value(), request.start_time)",
          "new_text": null,
          "old_line_content": "  auto required_assignment_at_start = RequiredMemoryAssignmentAt(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2837,
          "old_api": "value",
          "new_api": null,
          "old_text": "request.allocation_value->value()",
          "new_text": null,
          "old_line_content": "      request.allocation_value->value(), request.start_time);",
          "new_line_content": "  // There could be a requirement to pin this buffer to default memory either",
          "content_same": false
        },
        {
          "line": 2844,
          "old_api": "value",
          "new_api": null,
          "old_text": "RequiredMemoryAssignmentAt(\n      request.allocation_value->value(), request.end_time)",
          "new_text": null,
          "old_line_content": "  auto required_assignment_at_end = RequiredMemoryAssignmentAt(",
          "new_line_content": "  std::optional<MemorySpace> required_memory_space_at_start;",
          "content_same": false
        },
        {
          "line": 2845,
          "old_api": "value",
          "new_api": null,
          "old_text": "request.allocation_value->value()",
          "new_text": null,
          "old_line_content": "      request.allocation_value->value(), request.end_time);",
          "new_line_content": "  if (required_assignment_at_start) {",
          "content_same": false
        },
        {
          "line": 2847,
          "old_api": "AliasedRequiredAssignmentForUse",
          "new_api": null,
          "old_text": "AliasedRequiredAssignmentForUse(*request.use)",
          "new_text": null,
          "old_line_content": "      AliasedRequiredAssignmentForUse(*request.use);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2852,
          "old_api": "equals_ignoring_time",
          "new_api": null,
          "old_text": "CHECK(aliased_required_assignment_at_end == std::nullopt ||\n            aliased_required_assignment_at_end->equals_ignoring_time(\n                *required_assignment_at_end))",
          "new_text": null,
          "old_line_content": "      CHECK(aliased_required_assignment_at_end == std::nullopt ||",
          "new_line_content": "  auto aliased_required_assignment_at_end =",
          "content_same": false
        },
        {
          "line": 2864,
          "old_api": "empty",
          "new_api": null,
          "old_text": "allocation_sequence->empty()",
          "new_text": null,
          "old_line_content": "    if (!allocation_sequence->empty()) {",
          "new_line_content": "  if (required_assignment_at_end) {",
          "content_same": false
        },
        {
          "line": 2865,
          "old_api": "rbegin",
          "new_api": null,
          "old_text": "std::find_if(\n          allocation_sequence->rbegin(), allocation_sequence->rend(),\n          [&](const auto& allocation) {\n            return allocation->memory_space() ==\n                       required_memory_space_at_start &&\n                   allocation->defining_position() == defining_position;\n          })",
          "new_text": null,
          "old_line_content": "      auto prev_allocation_it = std::find_if(",
          "new_line_content": "    required_memory_space_at_end = required_assignment_at_end->memory_space;",
          "content_same": false
        },
        {
          "line": 2866,
          "old_api": "rend",
          "new_api": null,
          "old_text": "allocation_sequence->rend()",
          "new_text": null,
          "old_line_content": "          allocation_sequence->rbegin(), allocation_sequence->rend(),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2868,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "allocation->memory_space()",
          "new_text": null,
          "old_line_content": "            return allocation->memory_space() ==",
          "new_line_content": "  if (required_assignment_at_start) {",
          "content_same": false
        },
        {
          "line": 2873,
          "old_api": "Extend",
          "new_api": null,
          "old_text": "*prev_allocation_it)->Extend(request.start_time)",
          "new_text": null,
          "old_line_content": "        (*prev_allocation_it)->Extend(request.start_time);",
          "new_line_content": "          [&](const auto& allocation) {",
          "content_same": false
        },
        {
          "line": 2884,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "allocation_sequence->push_back(\n          std::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, required_assignment_at_start->memory_space,\n              aliased_chunk, request.start_time, request.start_time,\n              /*is_scoped_allocation=*/false))",
          "new_text": null,
          "old_line_content": "      allocation_sequence->push_back(",
          "new_line_content": "      std::optional<Chunk> aliased_chunk = std::nullopt;",
          "content_same": false
        },
        {
          "line": 2885,
          "old_api": "std::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, required_assignment_at_start->memory_space,\n              aliased_chunk, request.start_time, request.start_time,\n              /*is_scoped_allocation=*/false)",
          "new_api": null,
          "old_text": "std::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, required_assignment_at_start->memory_space,\n              aliased_chunk, request.start_time, request.start_time,\n              /*is_scoped_allocation=*/false)",
          "new_text": null,
          "old_line_content": "          std::make_unique<MemorySpaceAssignment::Allocation>(",
          "new_line_content": "      if (required_assignment_at_start->memory_space ==",
          "content_same": false
        },
        {
          "line": 2902,
          "old_api": "AllocateInAlternateMemoryNoCopy",
          "new_api": null,
          "old_text": "AllocateInAlternateMemoryNoCopy(request)",
          "new_text": null,
          "old_line_content": "    allocation_result = AllocateInAlternateMemoryNoCopy(request);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2912,
          "old_api": "rend",
          "new_api": null,
          "old_text": "allocation_sequence->rend()",
          "new_text": null,
          "old_line_content": "      std::find_if(allocation_sequence->rbegin(), allocation_sequence->rend(),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2917,
          "old_api": "rend",
          "new_api": null,
          "old_text": "allocation_sequence->rend()",
          "new_text": null,
          "old_line_content": "  if (prev_allocation_in_default_mem_it == allocation_sequence->rend() &&",
          "new_line_content": "  auto prev_allocation_in_default_mem_it =",
          "content_same": false
        },
        {
          "line": 2919,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "*prev_allocation_it)->memory_space()",
          "new_text": null,
          "old_line_content": "      (*prev_allocation_it)->memory_space() == MemorySpace::kAlternate &&",
          "new_line_content": "                   [&](const auto& allocation) {",
          "content_same": false
        },
        {
          "line": 2921,
          "old_api": "requires_contiguous_allocation",
          "new_api": null,
          "old_text": "request.allocation_value->requires_contiguous_allocation()",
          "new_text": null,
          "old_line_content": "      !request.allocation_value->requires_contiguous_allocation()) {",
          "new_line_content": "                   });",
          "content_same": false
        },
        {
          "line": 2929,
          "old_api": "rbegin",
          "new_api": null,
          "old_text": "allocation_sequence->rbegin()",
          "new_text": null,
          "old_line_content": "    prev_allocation_in_default_mem_it = allocation_sequence->rbegin();",
          "new_line_content": "    // memory space, we also need to perform an eviction.",
          "content_same": false
        },
        {
          "line": 2931,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "allocation_sequence->push_back(\n        std::make_unique<MemorySpaceAssignment::Allocation>(\n            defining_position, MemorySpace::kDefault,\n            /*chunk=*/std::nullopt, request.start_time, request.end_time,\n            /*is_scoped_allocation=*/false))",
          "new_text": null,
          "old_line_content": "    allocation_sequence->push_back(",
          "new_line_content": "    if (eviction_result != Result::kSuccess) {",
          "content_same": false
        },
        {
          "line": 2932,
          "old_api": "std::make_unique<MemorySpaceAssignment::Allocation>(\n            defining_position, MemorySpace::kDefault,\n            /*chunk=*/std::nullopt, request.start_time, request.end_time,\n            /*is_scoped_allocation=*/false)",
          "new_api": null,
          "old_text": "std::make_unique<MemorySpaceAssignment::Allocation>(\n            defining_position, MemorySpace::kDefault,\n            /*chunk=*/std::nullopt, request.start_time, request.end_time,\n            /*is_scoped_allocation=*/false)",
          "new_text": null,
          "old_line_content": "        std::make_unique<MemorySpaceAssignment::Allocation>(",
          "new_line_content": "      // A non-success eviction requires us to uncommit previous allocations.",
          "content_same": false
        },
        {
          "line": 2939,
          "old_api": "rend",
          "new_api": null,
          "old_text": "allocation_sequence->rend()",
          "new_text": null,
          "old_line_content": "  CHECK(prev_allocation_in_default_mem_it != allocation_sequence->rend());",
          "new_line_content": "            defining_position, MemorySpace::kDefault,",
          "content_same": false
        },
        {
          "line": 2940,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "*prev_allocation_in_default_mem_it)->memory_space()",
          "new_text": null,
          "old_line_content": "  CHECK((*prev_allocation_in_default_mem_it)->memory_space() ==",
          "new_line_content": "            /*chunk=*/std::nullopt, request.start_time, request.end_time,",
          "content_same": false
        },
        {
          "line": 2947,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "required_memory_space_at_start.has_value()",
          "new_text": null,
          "old_line_content": "      required_memory_space_at_start.has_value() &&",
          "new_line_content": "        MemorySpace::kDefault);",
          "content_same": false
        },
        {
          "line": 2948,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "required_memory_space_at_end.has_value()",
          "new_text": null,
          "old_line_content": "      required_memory_space_at_end.has_value() &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2950,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \"Allocation requires contiguous allocation but has memory space \"",
          "new_line_content": "  // space mismatch between the start and end required assignments, then we need",
          "content_same": false
        },
        {
          "line": 2957,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "    VLOG(3)",
          "new_line_content": "               \"mismatch.\";",
          "content_same": false
        },
        {
          "line": 2959,
          "old_api": "Extend",
          "new_api": null,
          "old_text": "*prev_allocation_in_default_mem_it)->Extend(request.end_time)",
          "new_text": null,
          "old_line_content": "    (*prev_allocation_in_default_mem_it)->Extend(request.end_time);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2960,
          "old_api": "AddUse",
          "new_api": null,
          "old_text": "*prev_allocation_in_default_mem_it)->AddUse(request.use->hlo_use)",
          "new_text": null,
          "old_line_content": "    (*prev_allocation_in_default_mem_it)->AddUse(request.use->hlo_use);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2967,
          "old_api": "Prefetch",
          "new_api": null,
          "old_text": "Prefetch(request, **prev_allocation_in_default_mem_it)",
          "new_text": null,
          "old_line_content": "        Prefetch(request, **prev_allocation_in_default_mem_it);",
          "new_line_content": "    return Result::kSuccess;",
          "content_same": false
        },
        {
          "line": 2984,
          "old_api": "requires_contiguous_allocation",
          "new_api": null,
          "old_text": "request.allocation_value->requires_contiguous_allocation()",
          "new_text": null,
          "old_line_content": "      request.allocation_value->requires_contiguous_allocation()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2985,
          "old_api": "result_mark",
          "new_api": null,
          "old_text": "result_mark(Result::kFailRequiresUncommit, allocation_result)",
          "new_text": null,
          "old_line_content": "    return result_mark(Result::kFailRequiresUncommit, allocation_result);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3002,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"Copy to \"",
          "new_line_content": "    const MemorySpaceAssignment::Allocation& prev_allocation,",
          "content_same": false
        },
        {
          "line": 3009,
          "old_api": "CHECK_LT",
          "new_api": null,
          "old_text": "CHECK_LT(start_time, copy_done_schedule_before_time)",
          "new_text": null,
          "old_line_content": "  CHECK_LT(start_time, copy_done_schedule_before_time);",
          "new_line_content": "          << (memory_space == MemorySpaceAssignment::MemorySpace::kDefault",
          "content_same": false
        },
        {
          "line": 3011,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "allocations->push_back(\n      std::make_unique<MemorySpaceAssignment::CopyAllocation>(\n          prev_allocation, memory_space, chunk, start_time, end_time,\n          copy_done_schedule_before_time, cross_program_prefetch_index))",
          "new_text": null,
          "old_line_content": "  allocations->push_back(",
          "new_line_content": "                  : \"alternate\")",
          "content_same": false
        },
        {
          "line": 3012,
          "old_api": "std::make_unique<MemorySpaceAssignment::CopyAllocation>(\n          prev_allocation, memory_space, chunk, start_time, end_time,\n          copy_done_schedule_before_time, cross_program_prefetch_index)",
          "new_api": null,
          "old_text": "std::make_unique<MemorySpaceAssignment::CopyAllocation>(\n          prev_allocation, memory_space, chunk, start_time, end_time,\n          copy_done_schedule_before_time, cross_program_prefetch_index)",
          "new_text": null,
          "old_line_content": "      std::make_unique<MemorySpaceAssignment::CopyAllocation>(",
          "new_line_content": "          << \" memory between \" << start_time << \" and \"",
          "content_same": false
        },
        {
          "line": 3022,
          "old_api": "Add",
          "new_api": null,
          "old_text": "prefetch_interval_tree_.Add(start_time, copy_done_schedule_before_time,\n                                kDummyChunk)",
          "new_text": null,
          "old_line_content": "    prefetch_interval_tree_.Add(start_time, copy_done_schedule_before_time,",
          "new_line_content": "  // Register the additional async copy with the interval tree to keep track of",
          "content_same": false
        },
        {
          "line": 3025,
          "old_api": "back",
          "new_api": null,
          "old_text": "allocations->back()",
          "new_text": null,
          "old_line_content": "    CreateOrAddToAliasedOffset(*allocations->back(), aliased_offset);",
          "new_line_content": "                                   resource, memory_space,",
          "content_same": false
        },
        {
          "line": 3027,
          "old_api": "Add",
          "new_api": null,
          "old_text": "eviction_interval_tree_.Add(start_time, copy_done_schedule_before_time,\n                                kDummyChunk)",
          "new_text": null,
          "old_line_content": "    eviction_interval_tree_.Add(start_time, copy_done_schedule_before_time,",
          "new_line_content": "  if (memory_space == MemorySpaceAssignment::MemorySpace::kAlternate) {",
          "content_same": false
        },
        {
          "line": 3029,
          "old_api": "back",
          "new_api": null,
          "old_text": "pending_async_copies_.back()",
          "new_text": null,
          "old_line_content": "    eviction_async_copy_resource_.AddCopy(pending_async_copies_.back());",
          "new_line_content": "                                kDummyChunk);",
          "content_same": false
        },
        {
          "line": 3046,
          "old_api": "ChunksOverlappingInTime",
          "new_api": null,
          "old_text": "prefetch_interval_tree_.ChunksOverlappingInTime(start_time, end_time)\n            .size()",
          "new_text": null,
          "old_line_content": "        prefetch_interval_tree_.ChunksOverlappingInTime(start_time, end_time)",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 3064,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "request.allocation_value->allocation_sequence()->empty()",
          "new_text": null,
          "old_line_content": "  if (request.allocation_value->allocation_sequence()->empty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3067,
          "old_api": "is_allowed_in_alternate_mem_fn",
          "new_api": null,
          "old_text": "options_.is_allowed_in_alternate_mem_fn(\n        *request.allocation_value->value())",
          "new_text": null,
          "old_line_content": "    can_eliminate_copy = options_.is_allowed_in_alternate_mem_fn(",
          "new_line_content": "    const AllocationRequest& request) {",
          "content_same": false
        },
        {
          "line": 3068,
          "old_api": "value",
          "new_api": null,
          "old_text": "request.allocation_value->value()",
          "new_text": null,
          "old_line_content": "        *request.allocation_value->value());",
          "new_line_content": "  MemorySpaceAssignment::Allocation* prev_allocation = nullptr;",
          "content_same": false
        },
        {
          "line": 3075,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "prev_allocation->memory_space()",
          "new_text": null,
          "old_line_content": "        (prev_allocation->memory_space() == MemorySpace::kAlternate);",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 3083,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "request.allocation_value->defining_position()",
          "new_text": null,
          "old_line_content": "      request.allocation_value->defining_position();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3084,
          "old_api": "shape",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(\n          defining_position.shape(), request.start_time + 1,\n          request.end_time)",
          "new_text": null,
          "old_line_content": "  if (!options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(",
          "new_line_content": "  if (!can_eliminate_copy) {",
          "content_same": false
        },
        {
          "line": 3085,
          "old_api": "shape",
          "new_api": null,
          "old_text": "defining_position.shape()",
          "new_text": null,
          "old_line_content": "          defining_position.shape(), request.start_time + 1,",
          "new_line_content": "    return Result::kFailPrevAllocationNotInAlternateMem;",
          "content_same": false
        },
        {
          "line": 3099,
          "old_api": "GetAliasedOffset",
          "new_api": null,
          "old_text": "GetAliasedOffset(*prev_allocation)",
          "new_text": null,
          "old_line_content": "    preferred_offset = GetAliasedOffset(*prev_allocation);",
          "new_line_content": "  alternate_mem_interval.end = request.end_time;",
          "content_same": false
        },
        {
          "line": 3102,
          "old_api": "end_time",
          "new_api": null,
          "old_text": "prev_allocation->end_time()",
          "new_text": null,
          "old_line_content": "    alternate_mem_interval.start = prev_allocation->end_time() + 1;",
          "new_line_content": "  // Prefer the offset that was previously used for the previous allocation.",
          "content_same": false
        },
        {
          "line": 3137,
          "old_api": "FindBestChunkCandidate",
          "new_api": null,
          "old_text": "FindBestChunkCandidate(\n      request, preferred_offset, &alternate_mem_interval)",
          "new_text": null,
          "old_line_content": "  std::optional<Chunk> chunk_candidate = FindBestChunkCandidate(",
          "new_line_content": "  // Because we allocate buffers greedily, Producer to Use1 segment first, and",
          "content_same": false
        },
        {
          "line": 3142,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \"Keep the buffer in alternate memory. Offset = \"",
          "new_line_content": "  // entire Producer to Use2 range.",
          "content_same": false
        },
        {
          "line": 3144,
          "old_api": "UpdatedHeapSize",
          "new_api": null,
          "old_text": "result_.UpdatedHeapSize(*chunk_candidate)",
          "new_text": null,
          "old_line_content": "            << \", heap_size = \" << result_.UpdatedHeapSize(*chunk_candidate)",
          "new_line_content": "      request, preferred_offset, &alternate_mem_interval);",
          "content_same": false
        },
        {
          "line": 3146,
          "old_api": "shape",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->ToNoCopyDebugString(\n                   defining_position.shape(), request.start_time,\n                   request.end_time)",
          "new_text": null,
          "old_line_content": "            << options_.prefetch_interval_picker->ToNoCopyDebugString(",
          "new_line_content": "  // preferred offset was provided, that offset was used.",
          "content_same": false
        },
        {
          "line": 3147,
          "old_api": "shape",
          "new_api": null,
          "old_text": "defining_position.shape()",
          "new_text": null,
          "old_line_content": "                   defining_position.shape(), request.start_time,",
          "new_line_content": "  if (chunk_candidate) {",
          "content_same": false
        },
        {
          "line": 3149,
          "old_api": "AddToPendingChunks",
          "new_api": null,
          "old_text": "AddToPendingChunks(alternate_mem_interval, *chunk_candidate)",
          "new_text": null,
          "old_line_content": "    AddToPendingChunks(alternate_mem_interval, *chunk_candidate);",
          "new_line_content": "            << chunk_candidate->offset << \", size = \" << chunk_candidate->size",
          "content_same": false
        },
        {
          "line": 3154,
          "old_api": "is_copy_allocation",
          "new_api": null,
          "old_text": "prev_allocation->is_copy_allocation()",
          "new_text": null,
          "old_line_content": "        (prev_allocation->is_copy_allocation() ||",
          "new_line_content": "                   request.end_time);",
          "content_same": false
        },
        {
          "line": 3156,
          "old_api": "Extend",
          "new_api": null,
          "old_text": "prev_allocation->Extend(request.end_time)",
          "new_text": null,
          "old_line_content": "      prev_allocation->Extend(request.end_time);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3158,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "request.allocation_value->allocation_sequence()->push_back(\n          std::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, MemorySpace::kAlternate, chunk_candidate,\n              request.start_time, request.end_time,\n              /*is_scoped_allocation=*/false))",
          "new_text": null,
          "old_line_content": "      request.allocation_value->allocation_sequence()->push_back(",
          "new_line_content": "    // same as the previous. Otherwise, it is the operand.",
          "content_same": false
        },
        {
          "line": 3159,
          "old_api": "std::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, MemorySpace::kAlternate, chunk_candidate,\n              request.start_time, request.end_time,\n              /*is_scoped_allocation=*/false)",
          "new_api": null,
          "old_text": "std::make_unique<MemorySpaceAssignment::Allocation>(\n              defining_position, MemorySpace::kAlternate, chunk_candidate,\n              request.start_time, request.end_time,\n              /*is_scoped_allocation=*/false)",
          "new_text": null,
          "old_line_content": "          std::make_unique<MemorySpaceAssignment::Allocation>(",
          "new_line_content": "    if (prev_allocation != nullptr &&",
          "content_same": false
        },
        {
          "line": 3163,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "CreateOrAddToAliasedOffset(\n          *request.allocation_value->allocation_sequence()->back(),\n          preferred_offset)",
          "new_text": null,
          "old_line_content": "      CreateOrAddToAliasedOffset(",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 3167,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "request.allocation_value->allocation_sequence()->back()->AddUse(\n        request.use->hlo_use)",
          "new_text": null,
          "old_line_content": "    request.allocation_value->allocation_sequence()->back()->AddUse(",
          "new_line_content": "              request.start_time, request.end_time,",
          "content_same": false
        },
        {
          "line": 3176,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "request.allocation_value->allocation_sequence()->size()",
          "new_text": null,
          "old_line_content": "  CHECK_GT(request.allocation_value->allocation_sequence()->size(), 0);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3178,
          "old_api": "get",
          "new_api": null,
          "old_text": "request.allocation_value->allocation_sequence()->back().get()",
          "new_text": null,
          "old_line_content": "      request.allocation_value->allocation_sequence()->back().get();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3179,
          "old_api": "start_time",
          "new_api": null,
          "old_text": "prev_allocation->start_time()",
          "new_text": null,
          "old_line_content": "  int64_t eviction_start_time = prev_allocation->start_time();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3180,
          "old_api": "end_time",
          "new_api": null,
          "old_text": "prev_allocation->end_time()",
          "new_text": null,
          "old_line_content": "  int64_t eviction_end_time = prev_allocation->end_time();",
          "new_line_content": "AlternateMemoryBestFitHeap::Result AlternateMemoryBestFitHeap::Evict(",
          "content_same": false
        },
        {
          "line": 3181,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(eviction_start_time <= eviction_end_time)",
          "new_text": null,
          "old_line_content": "  CHECK(eviction_start_time <= eviction_end_time);",
          "new_line_content": "    const AllocationRequest& request) {",
          "content_same": false
        },
        {
          "line": 3193,
          "old_api": "value",
          "new_api": null,
          "old_text": "request.allocation_value->value()",
          "new_text": null,
          "old_line_content": "  eviction_mem_interval.buffer = request.allocation_value->value();",
          "new_line_content": "               eviction_end_time);",
          "content_same": false
        },
        {
          "line": 3200,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"Eviction (\" << eviction_start_time << \", \" << eviction_end_time",
          "new_line_content": "  eviction_mem_interval.size = request.size;",
          "content_same": false
        },
        {
          "line": 3208,
          "old_api": "AddToPendingChunks",
          "new_api": null,
          "old_text": "AddToPendingChunks(eviction_mem_interval, chunk_candidate)",
          "new_text": null,
          "old_line_content": "      AddToPendingChunks(eviction_mem_interval, chunk_candidate);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3219,
          "old_api": "shape",
          "new_api": null,
          "old_text": "options_.cost_analysis->GetAsyncCopyElapsed(\n                request.allocation_value->defining_position().shape())",
          "new_text": null,
          "old_line_content": "          ? options_.cost_analysis->GetAsyncCopyElapsed(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3229,
          "old_api": "retry_number",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->retry_number()",
          "new_text": null,
          "old_line_content": "    if (options_.prefetch_interval_picker->retry_number() ==",
          "new_line_content": "  bool eviction_interval_too_short = (eviction_start_time == eviction_end_time);",
          "content_same": false
        },
        {
          "line": 3239,
          "old_api": "ViolatesMaximumOutstandingAsyncCopies",
          "new_api": null,
          "old_text": "ViolatesMaximumOutstandingAsyncCopies(eviction_start_time,\n                                            eviction_end_time,\n                                            /*is_prefetch=*/false)",
          "new_text": null,
          "old_line_content": "      ViolatesMaximumOutstandingAsyncCopies(eviction_start_time,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3246,
          "old_api": "Extend",
          "new_api": null,
          "old_text": "prev_allocation->Extend(eviction_end_time)",
          "new_text": null,
          "old_line_content": "    prev_allocation->Extend(eviction_end_time);",
          "new_line_content": "                                            eviction_end_time,",
          "content_same": false
        },
        {
          "line": 3247,
          "old_api": "end_time",
          "new_api": null,
          "old_text": "AddAsyncCopy(*prev_allocation, MemorySpace::kDefault,\n                 /*chunk=*/std::nullopt, eviction_start_time,\n                 prev_allocation->end_time(), eviction_end_time,\n                 request.allocation_value->allocation_sequence(),\n                 /*aliased_offset=*/nullptr, eviction_resource)",
          "new_text": null,
          "old_line_content": "    AddAsyncCopy(*prev_allocation, MemorySpace::kDefault,",
          "new_line_content": "                                            /*is_prefetch=*/false);",
          "content_same": false
        },
        {
          "line": 3249,
          "old_api": "end_time",
          "new_api": null,
          "old_text": "prev_allocation->end_time()",
          "new_text": null,
          "old_line_content": "                 prev_allocation->end_time(), eviction_end_time,",
          "new_line_content": "  // See if this interval would violate the asynchronous copy limit.",
          "content_same": false
        },
        {
          "line": 3250,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "request.allocation_value->allocation_sequence()",
          "new_text": null,
          "old_line_content": "                 request.allocation_value->allocation_sequence(),",
          "new_line_content": "  if (!eviction_interval_too_short && !eviction_violates_outstanding_copies &&",
          "content_same": false
        },
        {
          "line": 3254,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \"This violates the maximum async copies.\";",
          "new_line_content": "                 /*chunk=*/std::nullopt, eviction_start_time,",
          "content_same": false
        },
        {
          "line": 3258,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \"Eviction interval is too short (\" << eviction_start_time",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 3268,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "request.use->hlo_use.ToString()",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \"Bailing: Could not evict \" << request.use->hlo_use.ToString()",
          "new_line_content": "    // this interval.",
          "content_same": false
        },
        {
          "line": 3271,
          "old_api": "flattened_instruction_sequence",
          "new_api": null,
          "old_text": "hlo_live_range_.flattened_instruction_sequence()\n                     .instructions()",
          "new_text": null,
          "old_line_content": "              << hlo_live_range_.flattened_instruction_sequence()",
          "new_line_content": "    if (!eviction_scheduled) {",
          "content_same": false
        },
        {
          "line": 3305,
          "old_api": "earliest_available_time",
          "new_api": null,
          "old_text": "prev_allocation_in_default_mem.earliest_available_time()",
          "new_text": null,
          "old_line_content": "      prev_allocation_in_default_mem.earliest_available_time();",
          "new_line_content": "  // Alternate:                          +------+",
          "content_same": false
        },
        {
          "line": 3308,
          "old_api": "std::max(earliest_prefetch_time, *request.earliest_prefetch_time)",
          "new_api": null,
          "old_text": "std::max(earliest_prefetch_time, *request.earliest_prefetch_time)",
          "new_text": null,
          "old_line_content": "        std::max(earliest_prefetch_time, *request.earliest_prefetch_time);",
          "new_line_content": "  //                                   Copy    Copy",
          "content_same": false
        },
        {
          "line": 3316,
          "old_api": "FindEarliestTimeToSatisfyPeakMemory",
          "new_api": null,
          "old_text": "FindEarliestTimeToSatisfyPeakMemory(earliest_prefetch_time,\n                                          prefetch_end_time, request.size)",
          "new_text": null,
          "old_line_content": "      FindEarliestTimeToSatisfyPeakMemory(earliest_prefetch_time,",
          "new_line_content": "  int64_t prefetch_end_time =",
          "content_same": false
        },
        {
          "line": 3320,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \"Any prefetch in range (\" << earliest_prefetch_time << \", \"",
          "new_line_content": "  // allocation times that would push us to OOM.",
          "content_same": false
        },
        {
          "line": 3323,
          "old_api": "result_mark",
          "new_api": null,
          "old_text": "result_mark(Result::kFailOutOfMemory, result)",
          "new_text": null,
          "old_line_content": "    result_mark(Result::kFailOutOfMemory, result);",
          "new_line_content": "                                          prefetch_end_time, request.size);",
          "content_same": false
        },
        {
          "line": 3330,
          "old_api": "Begin",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->Begin(\n      request.use->hlo_use, earliest_prefetch_time, prefetch_end_time)",
          "new_text": null,
          "old_line_content": "  options_.prefetch_interval_picker->Begin(",
          "new_line_content": "    return result;",
          "content_same": false
        },
        {
          "line": 3333,
          "old_api": "ToDebugString",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->ToDebugString()",
          "new_text": null,
          "old_line_content": "          << options_.prefetch_interval_picker->ToDebugString();",
          "new_line_content": "          << *earliest_non_oom_prefetch_time << \", \" << prefetch_end_time",
          "content_same": false
        },
        {
          "line": 3345,
          "old_api": "FindBestChunkCandidate",
          "new_api": null,
          "old_text": "FindBestChunkCandidate(\n      request, request.preferred_offset, &alternate_mem_interval)",
          "new_text": null,
          "old_line_content": "  auto chunk_candidate = FindBestChunkCandidate(",
          "new_line_content": "  alternate_mem_interval.size = request.size;",
          "content_same": false
        },
        {
          "line": 3348,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \"The latest prefetch (\" << alternate_mem_interval.start << \", \"",
          "new_line_content": "  // earlier tries will succeed either.",
          "content_same": false
        },
        {
          "line": 3355,
          "old_api": "operand",
          "new_api": null,
          "old_text": "use.instruction->operand(use.operand_number)->shape()",
          "new_text": null,
          "old_line_content": "      use.instruction->operand(use.operand_number)->shape(), use.operand_index);",
          "new_line_content": "            << request.end_time << \") cannot find a valid chunk. Giving up.\";",
          "content_same": false
        },
        {
          "line": 3358,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "request.use->hlo_use.instruction->opcode()",
          "new_text": null,
          "old_line_content": "      request.use->hlo_use.instruction->opcode() == HloOpcode::kWhile",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3365,
          "old_api": "Done",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->Done()",
          "new_text": null,
          "old_line_content": "  while (!options_.prefetch_interval_picker->Done()) {",
          "new_line_content": "          ? options_.while_use_extra_outstanding_prefetch_limit",
          "content_same": false
        },
        {
          "line": 3366,
          "old_api": "Next",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->Next()",
          "new_text": null,
          "old_line_content": "    alternate_mem_interval.start = options_.prefetch_interval_picker->Next();",
          "new_line_content": "          : 0;",
          "content_same": false
        },
        {
          "line": 3367,
          "old_api": "CHECK_LT",
          "new_api": null,
          "old_text": "CHECK_LT(alternate_mem_interval.start, prefetch_end_time)",
          "new_text": null,
          "old_line_content": "    CHECK_LT(alternate_mem_interval.start, prefetch_end_time);",
          "new_line_content": "  // As a compilation time optimization, store the prefetch start time where we",
          "content_same": false
        },
        {
          "line": 3368,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "out_of_mem_start.has_value()",
          "new_text": null,
          "old_line_content": "    if (out_of_mem_start.has_value() &&",
          "new_line_content": "  // have first seen out of memory. There is no point of exploring prefetch",
          "content_same": false
        },
        {
          "line": 3370,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(4)",
          "new_text": null,
          "old_line_content": "      VLOG(4) << \"This would OOM (cached).\";",
          "new_line_content": "  std::optional<int64_t> out_of_mem_start;",
          "content_same": false
        },
        {
          "line": 3375,
          "old_api": "EstimatedPrefetchEndTime",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->EstimatedPrefetchEndTime(\n            shape, alternate_mem_interval.start, prefetch_end_time)",
          "new_text": null,
          "old_line_content": "        options_.prefetch_interval_picker->EstimatedPrefetchEndTime(",
          "new_line_content": "        alternate_mem_interval.start <= *out_of_mem_start) {",
          "content_same": false
        },
        {
          "line": 3385,
          "old_api": "HasEnoughResource",
          "new_api": null,
          "old_text": "prefetch_async_copy_resource_.HasEnoughResource(\n            alternate_mem_interval.start, prefetch_end_time,\n            prefetch_resource)",
          "new_text": null,
          "old_line_content": "    if (!prefetch_async_copy_resource_.HasEnoughResource(",
          "new_line_content": "            << \"), estimated prefetch end time = \"",
          "content_same": false
        },
        {
          "line": 3388,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(4)",
          "new_text": null,
          "old_line_content": "      VLOG(4) << \"This would violate asynchronous copy resource = \"",
          "new_line_content": "        options_.cost_analysis",
          "content_same": false
        },
        {
          "line": 3390,
          "old_api": "result_mark",
          "new_api": null,
          "old_text": "result_mark(Result::kFailViolatesAsyncCopyResource, result)",
          "new_text": null,
          "old_line_content": "      result_mark(Result::kFailViolatesAsyncCopyResource, result);",
          "new_line_content": "            : 0.1;",
          "content_same": false
        },
        {
          "line": 3393,
          "old_api": "ViolatesMaximumOutstandingAsyncCopies",
          "new_api": null,
          "old_text": "ViolatesMaximumOutstandingAsyncCopies(\n            alternate_mem_interval.start, prefetch_end_time,\n            /*is_prefetch=*/true, extra_async_copy_limit)",
          "new_text": null,
          "old_line_content": "    if (ViolatesMaximumOutstandingAsyncCopies(",
          "new_line_content": "            prefetch_resource)) {",
          "content_same": false
        },
        {
          "line": 3397,
          "old_api": "result_mark",
          "new_api": null,
          "old_text": "result_mark(Result::kFailOutOfAsyncCopies, result)",
          "new_text": null,
          "old_line_content": "      result_mark(Result::kFailOutOfAsyncCopies, result);",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 3401,
          "old_api": "FindBestChunkCandidate",
          "new_api": null,
          "old_text": "FindBestChunkCandidate(\n        request, request.preferred_offset, &alternate_mem_interval)",
          "new_text": null,
          "old_line_content": "    auto chunk_candidate = FindBestChunkCandidate(",
          "new_line_content": "            /*is_prefetch=*/true, extra_async_copy_limit)) {",
          "content_same": false
        },
        {
          "line": 3405,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \"Move the buffer to alternate memory at \"",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3409,
          "old_api": "UpdatedHeapSize",
          "new_api": null,
          "old_text": "result_.UpdatedHeapSize(*chunk_candidate)",
          "new_text": null,
          "old_line_content": "              << \", heap_size = \" << result_.UpdatedHeapSize(*chunk_candidate)",
          "new_line_content": "    // Check if we could find a suitable chunk.",
          "content_same": false
        },
        {
          "line": 3412,
          "old_api": "AddToPendingChunks",
          "new_api": null,
          "old_text": "AddToPendingChunks(alternate_mem_interval, *chunk_candidate)",
          "new_text": null,
          "old_line_content": "      AddToPendingChunks(alternate_mem_interval, *chunk_candidate);",
          "new_line_content": "              << alternate_mem_interval.start",
          "content_same": false
        },
        {
          "line": 3414,
          "old_api": "allocation_sequence",
          "new_api": null,
          "old_text": "AddAsyncCopy(prev_allocation_in_default_mem, MemorySpace::kAlternate,\n                   chunk_candidate, alternate_mem_interval.start,\n                   request.end_time, prefetch_end_time,\n                   request.allocation_value->allocation_sequence(),\n                   request.preferred_offset, prefetch_resource)",
          "new_text": null,
          "old_line_content": "      AddAsyncCopy(prev_allocation_in_default_mem, MemorySpace::kAlternate,",
          "new_line_content": "              << \", size = \" << chunk_candidate->size",
          "content_same": false
        },
        {
          "line": 3427,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "out_of_mem_start.has_value()",
          "new_text": null,
          "old_line_content": "          std::max(out_of_mem_start.has_value() ? *out_of_mem_start : -1,",
          "new_line_content": "          request.use->hlo_use);",
          "content_same": false
        },
        {
          "line": 3430,
          "old_api": "result_mark",
          "new_api": null,
          "old_text": "result_mark(Result::kFailOutOfMemory, result)",
          "new_text": null,
          "old_line_content": "    result_mark(Result::kFailOutOfMemory, result);",
          "new_line_content": "      // Mark the out of memory start with the prefetch start time so that we",
          "content_same": false
        },
        {
          "line": 3449,
          "old_api": "absl::c_lower_bound(use_times, end_time)",
          "new_api": null,
          "old_text": "absl::c_lower_bound(use_times, end_time)",
          "new_text": null,
          "old_line_content": "    auto use_time_it = absl::c_lower_bound(use_times, end_time);",
          "new_line_content": "    const AllocationRequest& request, const AliasedOffset* preferred_offset,",
          "content_same": false
        },
        {
          "line": 3450,
          "old_api": "end",
          "new_api": null,
          "old_text": "use_times.end()",
          "new_text": null,
          "old_line_content": "    CHECK(use_time_it != use_times.end());",
          "new_line_content": "    BufferInterval* alternate_mem_interval) const {",
          "content_same": false
        },
        {
          "line": 3458,
          "old_api": "end",
          "new_api": null,
          "old_text": "use_times.end()",
          "new_text": null,
          "old_line_content": "         (use_time_it + 1) != use_times.end() &&",
          "new_line_content": "    auto earliest_use_it = use_time_it;",
          "content_same": false
        },
        {
          "line": 3459,
          "old_api": "CanAllocateInAlternateMemoryNoCopy",
          "new_api": null,
          "old_text": "options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(\n             shape, *use_time_it, *(use_time_it + 1))",
          "new_text": null,
          "old_line_content": "         options_.prefetch_interval_picker->CanAllocateInAlternateMemoryNoCopy(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3463,
          "old_api": "end",
          "new_api": null,
          "old_text": "use_times.end()",
          "new_text": null,
          "old_line_content": "    CHECK(use_time_it != use_times.end());",
          "new_line_content": "    for (;",
          "content_same": false
        },
        {
          "line": 3468,
          "old_api": "std::numeric_limits<int64_t>::min()",
          "new_api": null,
          "old_text": "std::numeric_limits<int64_t>::min()",
          "new_text": null,
          "old_line_content": "    int64_t latest_matching_use = std::numeric_limits<int64_t>::min();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3470,
          "old_api": "std::next(use_time_it)",
          "new_api": null,
          "old_text": "std::next(use_time_it)",
          "new_text": null,
          "old_line_content": "        earliest_use_it, std::next(use_time_it), -1, [&](int64_t use, int64_t) {",
          "new_line_content": "    int64_t latest_contiguous_use_time = *use_time_it;",
          "content_same": false
        },
        {
          "line": 3472,
          "old_api": "FindChunkCandidate",
          "new_api": null,
          "old_text": "FindChunkCandidate(*alternate_mem_interval)",
          "new_text": null,
          "old_line_content": "          Chunk chunk_candidate = FindChunkCandidate(*alternate_mem_interval);",
          "new_line_content": "    // Find a chunk that's as long living as possible.",
          "content_same": false
        },
        {
          "line": 3473,
          "old_api": "available_heap_size",
          "new_api": null,
          "old_text": "available_heap_size()",
          "new_text": null,
          "old_line_content": "          if (chunk_candidate.chunk_end() <= available_heap_size()) {",
          "new_line_content": "    std::optional<Chunk> last_chunk_candidate;",
          "content_same": false
        },
        {
          "line": 3482,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "last_chunk_candidate.has_value()",
          "new_text": null,
          "old_line_content": "    if (last_chunk_candidate.has_value()) {",
          "new_line_content": "              latest_matching_use = use;",
          "content_same": false
        },
        {
          "line": 3483,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \"FindBestChunkCandidate earliest use = \" << earliest_use",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3495,
          "old_api": "FindChunkCandidate",
          "new_api": null,
          "old_text": "FindChunkCandidate(*alternate_mem_interval, preferred_offset->offset)",
          "new_text": null,
          "old_line_content": "      FindChunkCandidate(*alternate_mem_interval, preferred_offset->offset);",
          "new_line_content": "    return last_chunk_candidate;",
          "content_same": false
        },
        {
          "line": 3511,
          "old_api": "TF_ASSIGN_OR_RETURN",
          "new_api": null,
          "old_text": "TF_ASSIGN_OR_RETURN(std::unique_ptr<HloDataflowAnalysis> dataflow_analysis,\n                      HloDataflowAnalysis::Run(*module_))",
          "new_text": null,
          "old_line_content": "  TF_ASSIGN_OR_RETURN(std::unique_ptr<HloDataflowAnalysis> dataflow_analysis,",
          "new_line_content": "  stats.max_outstanding_async_copies = 0;",
          "content_same": false
        },
        {
          "line": 3512,
          "old_api": "HloDataflowAnalysis::Run(*module_)",
          "new_api": null,
          "old_text": "HloDataflowAnalysis::Run(*module_)",
          "new_text": null,
          "old_line_content": "                      HloDataflowAnalysis::Run(*module_));",
          "new_line_content": "  stats.num_prefetches = 0;",
          "content_same": false
        },
        {
          "line": 3514,
          "old_api": "MakeNonfusionComputations",
          "new_api": null,
          "old_text": "module_->MakeNonfusionComputations()",
          "new_text": null,
          "old_line_content": "       module_->MakeNonfusionComputations()) {",
          "new_line_content": "  stats.num_evictions = 0;",
          "content_same": false
        },
        {
          "line": 3515,
          "old_api": "instructions",
          "new_api": null,
          "old_text": "computation->instructions()",
          "new_text": null,
          "old_line_content": "    for (HloInstruction* instruction : computation->instructions()) {",
          "new_line_content": "  stats.eviction_bytes = 0;",
          "content_same": false
        },
        {
          "line": 3516,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "instruction->opcode()",
          "new_text": null,
          "old_line_content": "      if (instruction->opcode() == HloOpcode::kCopyStart) {",
          "new_line_content": "  int64_t current_copies = 0;",
          "content_same": false
        },
        {
          "line": 3532,
          "old_api": "std::max(stats.max_outstanding_async_copies, current_copies)",
          "new_api": null,
          "old_text": "std::max(stats.max_outstanding_async_copies, current_copies)",
          "new_text": null,
          "old_line_content": "          std::max(stats.max_outstanding_async_copies, current_copies);",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 3544,
          "old_api": "GetMemoryBoundedness",
          "new_api": null,
          "old_text": "cost_analysis.GetMemoryBoundedness(x, cache)",
          "new_text": null,
          "old_line_content": "    float x_memory_boundedness = cost_analysis.GetMemoryBoundedness(x, cache);",
          "new_line_content": "/*static*/ MemorySpaceAssignment::BufferIntervalCompare",
          "content_same": false
        },
        {
          "line": 3545,
          "old_api": "GetMemoryBoundedness",
          "new_api": null,
          "old_text": "cost_analysis.GetMemoryBoundedness(y, cache)",
          "new_text": null,
          "old_line_content": "    float y_memory_boundedness = cost_analysis.GetMemoryBoundedness(y, cache);",
          "new_line_content": "MemorySpaceAssignment::GetMemoryBoundednessBufferIntervalCompare(",
          "content_same": false
        },
        {
          "line": 3560,
          "old_api": "has_schedule",
          "new_api": null,
          "old_text": "module->has_schedule()",
          "new_text": null,
          "old_line_content": "  CHECK(module->has_schedule());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3561,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"Module before memory space assignment: \";",
          "new_line_content": "/*static*/ StatusOr<std::unique_ptr<PresetAssignments>>",
          "content_same": false
        },
        {
          "line": 3562,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "module->ToString()",
          "new_text": null,
          "old_line_content": "  XLA_VLOG_LINES(3, module->ToString());",
          "new_line_content": "MemorySpaceAssignment::Run(HloModule* module,",
          "content_same": false
        },
        {
          "line": 3563,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "module->schedule().ToString()",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"Schedule: \" << module->schedule().ToString();",
          "new_line_content": "                           const HloLiveRange& hlo_live_range,",
          "content_same": false
        },
        {
          "line": 3575,
          "old_api": "FindAllocationSequence",
          "new_api": null,
          "old_text": "FindAllocationSequence(hlo_live_range, alias_analysis)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(FindAllocationSequence(hlo_live_range, alias_analysis));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3579,
          "old_api": "ComputeEstimatedElapsedTime",
          "new_api": null,
          "old_text": "ComputeEstimatedElapsedTime(hlo_live_range, allocations_)",
          "new_text": null,
          "old_line_content": "        ComputeEstimatedElapsedTime(hlo_live_range, allocations_);",
          "new_line_content": "    const HloLiveRange& hlo_live_range,",
          "content_same": false
        },
        {
          "line": 3580,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(1)",
          "new_text": null,
          "old_line_content": "    VLOG(1) << \"Estimated elapsed time (sec): \" << estimated_time;",
          "new_line_content": "    const HloAliasAnalysis& alias_analysis) {",
          "content_same": false
        },
        {
          "line": 3583,
          "old_api": "Process",
          "new_api": null,
          "old_text": "Process()",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(Process());",
          "new_line_content": "  if (options_.cost_analysis) {",
          "content_same": false
        },
        {
          "line": 3584,
          "old_api": "ScheduleAsynchronousCopies",
          "new_api": null,
          "old_text": "ScheduleAsynchronousCopies()",
          "new_text": null,
          "old_line_content": "  ScheduleAsynchronousCopies();",
          "new_line_content": "    float estimated_time =",
          "content_same": false
        },
        {
          "line": 3587,
          "old_api": "ExportAndColorBuffers",
          "new_api": null,
          "old_text": "ExportAndColorBuffers()",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(ExportAndColorBuffers());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3600,
          "old_api": "VerifyAndExportHeapSimulatorTrace",
          "new_api": null,
          "old_text": "VerifyAndExportHeapSimulatorTrace()",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(VerifyAndExportHeapSimulatorTrace());",
          "new_line_content": "          << stats.max_outstanding_async_copies;",
          "content_same": false
        },
        {
          "line": 3602,
          "old_api": "std::move(preset_assignments_)",
          "new_api": null,
          "old_text": "std::move(preset_assignments_)",
          "new_text": null,
          "old_line_content": "  return std::move(preset_assignments_);",
          "new_line_content": "          << \", in bytes: \" << stats.prefetch_bytes;",
          "content_same": false
        },
        {
          "line": 3615,
          "old_api": "schedule",
          "new_api": null,
          "old_text": "module_->schedule()",
          "new_text": null,
          "old_line_content": "                                        module_->schedule(), alias_analysis,",
          "new_line_content": "      &allocations_, options_, alias_analysis, hlo_live_range);",
          "content_same": false
        },
        {
          "line": 3619,
          "old_api": "OkStatus",
          "new_api": null,
          "old_text": "OkStatus()",
          "new_text": null,
          "old_line_content": "  return OkStatus();",
          "new_line_content": "  heap_simulator_options.alloc_constants = true;",
          "content_same": false
        },
        {
          "line": 3624,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "use.instruction->mutable_operand(use.operand_number)",
          "new_text": null,
          "old_line_content": "      use.instruction->mutable_operand(use.operand_number);",
          "new_line_content": "                         .status());",
          "content_same": false
        },
        {
          "line": 3627,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "operand->opcode()",
          "new_text": null,
          "old_line_content": "    if (operand->opcode() != HloOpcode::kTuple) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3638,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "instruction->mutable_operand(0)",
          "new_text": null,
          "old_line_content": "          get_simplified_operand(instruction->mutable_operand(0));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3639,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "operand->opcode()",
          "new_text": null,
          "old_line_content": "      if (operand->opcode() == HloOpcode::kTuple) {",
          "new_line_content": "  // Look beyond GetTupleElement(Tuple()) pattern for any bitcasts.",
          "content_same": false
        },
        {
          "line": 3640,
          "old_api": "tuple_index",
          "new_api": null,
          "old_text": "instruction->tuple_index()",
          "new_text": null,
          "old_line_content": "        instruction = operand->mutable_operand(instruction->tuple_index());",
          "new_line_content": "  std::function<HloInstruction*(HloInstruction*)> get_simplified_operand;",
          "content_same": false
        },
        {
          "line": 3647,
          "old_api": "get_simplified_operand",
          "new_api": null,
          "old_text": "get_simplified_operand(operand)",
          "new_text": null,
          "old_line_content": "  operand = get_simplified_operand(operand);",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 3649,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "uses_.push_back(use)",
          "new_text": null,
          "old_line_content": "  uses_.push_back(use);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3661,
          "old_api": "is_copy_allocation",
          "new_api": null,
          "old_text": "allocation->is_copy_allocation()",
          "new_text": null,
          "old_line_content": "    if (!allocation->is_copy_allocation()) {",
          "new_line_content": "      outputs_in_alternate_memory_map;",
          "content_same": false
        },
        {
          "line": 3662,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "allocation->memory_space()",
          "new_text": null,
          "old_line_content": "      if (allocation->memory_space() == MemorySpace::kAlternate) {",
          "new_line_content": "  absl::flat_hash_map<const HloInstruction*,",
          "content_same": false
        },
        {
          "line": 3664,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "allocation->defining_position()",
          "new_text": null,
          "old_line_content": "            allocation->defining_position().instruction;",
          "new_line_content": "      operands_in_alternate_memory_map;",
          "content_same": false
        },
        {
          "line": 3665,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "outputs_in_alternate_memory_map[defining_instruction].push_back(\n            allocation->defining_position().index)",
          "new_text": null,
          "old_line_content": "        outputs_in_alternate_memory_map[defining_instruction].push_back(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3666,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "allocation->defining_position()",
          "new_text": null,
          "old_line_content": "            allocation->defining_position().index);",
          "new_line_content": "  for (auto& allocation : allocations) {",
          "content_same": false
        },
        {
          "line": 3669,
          "old_api": "uses",
          "new_api": null,
          "old_text": "allocation->uses()",
          "new_text": null,
          "old_line_content": "    for (auto& hlo_use : allocation->uses()) {",
          "new_line_content": "        const HloInstruction* defining_instruction =",
          "content_same": false
        },
        {
          "line": 3681,
          "old_api": "find",
          "new_api": null,
          "old_text": "outputs_in_alternate_memory_map.find(instruction)",
          "new_text": null,
          "old_line_content": "    auto output_it = outputs_in_alternate_memory_map.find(instruction);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3682,
          "old_api": "end",
          "new_api": null,
          "old_text": "outputs_in_alternate_memory_map.end()",
          "new_text": null,
          "old_line_content": "    if (output_it != outputs_in_alternate_memory_map.end()) {",
          "new_line_content": "  const auto& instruction_sequence =",
          "content_same": false
        },
        {
          "line": 3686,
          "old_api": "find",
          "new_api": null,
          "old_text": "operands_in_alternate_memory_map.find(instruction)",
          "new_text": null,
          "old_line_content": "    auto operand_it = operands_in_alternate_memory_map.find(instruction);",
          "new_line_content": "    std::vector<ShapeIndex> outputs_in_alternate_memory;",
          "content_same": false
        },
        {
          "line": 3691,
          "old_api": "GetInstructionElapsedInAlternateMemory",
          "new_api": null,
          "old_text": "options_.cost_analysis->GetInstructionElapsedInAlternateMemory(\n            *instruction, operands_in_alternate_memory,\n            outputs_in_alternate_memory)",
          "new_text": null,
          "old_line_content": "        options_.cost_analysis->GetInstructionElapsedInAlternateMemory(",
          "new_line_content": "    std::vector<std::pair<int64_t, ShapeIndex>> operands_in_alternate_memory;",
          "content_same": false
        },
        {
          "line": 3694,
          "old_api": "CalculateComputationNestLevel",
          "new_api": null,
          "old_text": "IPow<float>(\n        options_.xla_tpu_memory_space_assignment_while_execution_count,\n        options_.cost_analysis->CalculateComputationNestLevel(\n            instruction,\n            /*while_only=*/true))",
          "new_text": null,
          "old_line_content": "    float while_nest_multiplier = IPow<float>(",
          "new_line_content": "      operands_in_alternate_memory = operand_it->second;",
          "content_same": false
        },
        {
          "line": 3696,
          "old_api": "CalculateComputationNestLevel",
          "new_api": null,
          "old_text": "options_.cost_analysis->CalculateComputationNestLevel(\n            instruction,\n            /*while_only=*/true)",
          "new_text": null,
          "old_line_content": "        options_.cost_analysis->CalculateComputationNestLevel(",
          "new_line_content": "    float instruction_elapsed =",
          "content_same": false
        },
        {
          "line": 3705,
          "old_api": "is_scoped_allocation",
          "new_api": null,
          "old_text": "is_scoped_allocation()",
          "new_text": null,
          "old_line_content": "  if (is_scoped_allocation()) {",
          "new_line_content": "    total_elapsed += while_nest_multiplier * instruction_elapsed;",
          "content_same": false
        },
        {
          "line": 3707,
          "old_api": "OkStatus",
          "new_api": null,
          "old_text": "OkStatus()",
          "new_text": null,
          "old_line_content": "    return OkStatus();",
          "new_line_content": "  return total_elapsed;",
          "content_same": false
        },
        {
          "line": 3709,
          "old_api": "AddGetTupleElements",
          "new_api": null,
          "old_text": "AddGetTupleElements()",
          "new_text": null,
          "old_line_content": "  HloInstruction* producing_instruction = AddGetTupleElements();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3710,
          "old_api": "parent",
          "new_api": null,
          "old_text": "producing_instruction->parent()",
          "new_text": null,
          "old_line_content": "  HloComputation* computation = producing_instruction->parent();",
          "new_line_content": "Status MemorySpaceAssignment::Allocation::Process() {",
          "content_same": false
        },
        {
          "line": 3712,
          "old_api": "operand",
          "new_api": null,
          "old_text": "use.instruction->operand(use.operand_number)->shape()",
          "new_text": null,
          "old_line_content": "    Shape operand_shape = use.instruction->operand(use.operand_number)->shape();",
          "new_line_content": "    // Nothing to do here for scoped allocations.",
          "content_same": false
        },
        {
          "line": 3714,
          "old_api": "IsTuple",
          "new_api": null,
          "old_text": "operand_shape.IsTuple()",
          "new_text": null,
          "old_line_content": "    if (operand_shape.IsTuple()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3717,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "TupleUtil::ReplaceTupleWith(\n              producing_instruction,\n              use.instruction->mutable_operand(use.operand_number),\n              use.operand_index)",
          "new_text": null,
          "old_line_content": "          TupleUtil::ReplaceTupleWith(",
          "new_line_content": "  for (const HloUse& use : uses_) {",
          "content_same": false
        },
        {
          "line": 3719,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "use.instruction->mutable_operand(use.operand_number)",
          "new_text": null,
          "old_line_content": "              use.instruction->mutable_operand(use.operand_number),",
          "new_line_content": "    HloInstruction* replacement_instruction = producing_instruction;",
          "content_same": false
        },
        {
          "line": 3722,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "operand_shape.ToString()",
          "new_text": null,
          "old_line_content": "      VLOG(4) << \"Old shape = \" << operand_shape.ToString()",
          "new_line_content": "          replacement_instruction,",
          "content_same": false
        },
        {
          "line": 3726,
          "old_api": "HloInstruction::CreateBitcast(operand_shape, producing_instruction)",
          "new_api": null,
          "old_text": "HloInstruction::CreateBitcast(operand_shape, producing_instruction)",
          "new_text": null,
          "old_line_content": "          HloInstruction::CreateBitcast(operand_shape, producing_instruction));",
          "new_line_content": "              use.operand_index));",
          "content_same": false
        },
        {
          "line": 3735,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "defining_position()",
          "new_text": null,
          "old_line_content": "  CHECK_NE(defining_position().instruction, nullptr);",
          "new_line_content": "        use.operand_number, replacement_instruction));",
          "content_same": false
        },
        {
          "line": 3738,
          "old_api": "IsArray",
          "new_api": null,
          "old_text": "shape.IsArray()",
          "new_text": null,
          "old_line_content": "  CHECK(shape.IsArray()) << \"Allocation shape is not an array. Shape = \"",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3739,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "shape.ToString()",
          "new_text": null,
          "old_line_content": "                         << shape.ToString()",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3740,
          "old_api": "shape",
          "new_api": null,
          "old_text": "defining_position().shape()",
          "new_text": null,
          "old_line_content": "                         << \" position = \" << defining_position().shape();",
          "new_line_content": "HloInstruction* MemorySpaceAssignment::Allocation::AddGetTupleElements() const {",
          "content_same": false
        },
        {
          "line": 3749,
          "old_api": "is_scoped_allocation",
          "new_api": null,
          "old_text": "is_scoped_allocation()",
          "new_text": null,
          "old_line_content": "  return absl::StrCat((is_scoped_allocation() ? \"Scoped \" : \"\"),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3751,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "defining_position_.ToString()",
          "new_text": null,
          "old_line_content": "                      defining_position_.ToString(),",
          "new_line_content": "  std::string memory_space_str = \"def\";",
          "content_same": false
        },
        {
          "line": 3752,
          "old_api": "end_time",
          "new_api": null,
          "old_text": "end_time()",
          "new_text": null,
          "old_line_content": "                      \", start_time:\", start_time(), \", end_time:\", end_time(),",
          "new_line_content": "  if (memory_space_ == MemorySpace::kAlternate) {",
          "content_same": false
        },
        {
          "line": 3761,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "absl::StrCat(\"Copy Allocation in \", memory_space_str,\n                      \", start_time:\", start_time(), \", end_time:\", end_time(),\n                      \", copy_start_after_time: \", copy_start_schedule_after(),\n                      \", copy_done_before_time: \", copy_done_schedule_before(),\n                      \", uses: \", UsesToString(uses()), \", from \",\n                      prev_allocation_.ToString())",
          "new_text": null,
          "old_line_content": "  return absl::StrCat(\"Copy Allocation in \", memory_space_str,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3762,
          "old_api": "end_time",
          "new_api": null,
          "old_text": "end_time()",
          "new_text": null,
          "old_line_content": "                      \", start_time:\", start_time(), \", end_time:\", end_time(),",
          "new_line_content": "std::string MemorySpaceAssignment::CopyAllocation::ToString() const {",
          "content_same": false
        },
        {
          "line": 3763,
          "old_api": "copy_start_schedule_after",
          "new_api": null,
          "old_text": "copy_start_schedule_after()",
          "new_text": null,
          "old_line_content": "                      \", copy_start_after_time: \", copy_start_schedule_after(),",
          "new_line_content": "  std::string memory_space_str = \"def\";",
          "content_same": false
        },
        {
          "line": 3764,
          "old_api": "copy_done_schedule_before",
          "new_api": null,
          "old_text": "copy_done_schedule_before()",
          "new_text": null,
          "old_line_content": "                      \", copy_done_before_time: \", copy_done_schedule_before(),",
          "new_line_content": "  if (memory_space_ == MemorySpace::kAlternate) {",
          "content_same": false
        },
        {
          "line": 3766,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "prev_allocation_.ToString()",
          "new_text": null,
          "old_line_content": "                      prev_allocation_.ToString());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3775,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "absl::StrCat(\"Parent Allocation mirrored at \",\n                      defining_position_.ToString(), \", originally \",\n                      original_allocation_.ToString())",
          "new_text": null,
          "old_line_content": "  return absl::StrCat(\"Parent Allocation mirrored at \",",
          "new_line_content": "std::string MemorySpaceAssignment::MirroredAllocation::ToString() const {",
          "content_same": false
        },
        {
          "line": 3784,
          "old_api": "parent",
          "new_api": null,
          "old_text": "producing_instruction->parent()",
          "new_text": null,
          "old_line_content": "  HloComputation* computation = producing_instruction->parent();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3785,
          "old_api": "HloInstruction::CreateCopyStart(\n      ShapeUtil::MakeTupleShape({shape, shape, ShapeUtil::MakeShape(U32, {})}),\n      producing_instruction, cross_program_prefetch_index_)",
          "new_api": null,
          "old_text": "HloInstruction::CreateCopyStart(\n      ShapeUtil::MakeTupleShape({shape, shape, ShapeUtil::MakeShape(U32, {})}),\n      producing_instruction, cross_program_prefetch_index_)",
          "new_text": null,
          "old_line_content": "  copy_start_ = computation->AddInstruction(HloInstruction::CreateCopyStart(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3786,
          "old_api": "ShapeUtil::MakeShape(U32, {})",
          "new_api": null,
          "old_text": "ShapeUtil::MakeShape(U32, {})",
          "new_text": null,
          "old_line_content": "      ShapeUtil::MakeTupleShape({shape, shape, ShapeUtil::MakeShape(U32, {})}),",
          "new_line_content": "Status MemorySpaceAssignment::CopyAllocation::Process() {",
          "content_same": false
        },
        {
          "line": 3801,
          "old_api": "operand",
          "new_api": null,
          "old_text": "use.instruction->operand(use.operand_number)->shape()",
          "new_text": null,
          "old_line_content": "    Shape operand_shape = use.instruction->operand(use.operand_number)->shape();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3802,
          "old_api": "IsTuple",
          "new_api": null,
          "old_text": "operand_shape.IsTuple()",
          "new_text": null,
          "old_line_content": "    if (operand_shape.IsTuple()) {",
          "new_line_content": "  // Replace all the uses with the new copy instruction.",
          "content_same": false
        },
        {
          "line": 3803,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "TF_ASSIGN_OR_RETURN(\n          replacement_instruction,\n          TupleUtil::ReplaceTupleWith(\n              copy_done_, use.instruction->mutable_operand(use.operand_number),\n              use.operand_index))",
          "new_text": null,
          "old_line_content": "      TF_ASSIGN_OR_RETURN(",
          "new_line_content": "  for (HloUse use : uses_) {",
          "content_same": false
        },
        {
          "line": 3805,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "TupleUtil::ReplaceTupleWith(\n              copy_done_, use.instruction->mutable_operand(use.operand_number),\n              use.operand_index)",
          "new_text": null,
          "old_line_content": "          TupleUtil::ReplaceTupleWith(",
          "new_line_content": "    // we want to replace.",
          "content_same": false
        },
        {
          "line": 3806,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "use.instruction->mutable_operand(use.operand_number)",
          "new_text": null,
          "old_line_content": "              copy_done_, use.instruction->mutable_operand(use.operand_number),",
          "new_line_content": "    HloInstruction* replacement_instruction;",
          "content_same": false
        },
        {
          "line": 3810,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "copy_done_->shape().ToString()",
          "new_text": null,
          "old_line_content": "              << \", new shape = \" << copy_done_->shape().ToString()",
          "new_line_content": "          replacement_instruction,",
          "content_same": false
        },
        {
          "line": 3813,
          "old_api": "HloInstruction::CreateBitcast(operand_shape, copy_done_)",
          "new_api": null,
          "old_text": "HloInstruction::CreateBitcast(operand_shape, copy_done_)",
          "new_text": null,
          "old_line_content": "          HloInstruction::CreateBitcast(operand_shape, copy_done_));",
          "new_line_content": "              use.operand_index));",
          "content_same": false
        },
        {
          "line": 3817,
          "old_api": "ReplaceOperandWith",
          "new_api": null,
          "old_text": "use.instruction->ReplaceOperandWith(\n        use.operand_number, replacement_instruction)",
          "new_text": null,
          "old_line_content": "    TF_RETURN_IF_ERROR(use.instruction->ReplaceOperandWith(",
          "new_line_content": "              << \"; inserting a bitcast.\";",
          "content_same": false
        },
        {
          "line": 3821,
          "old_api": "OkStatus",
          "new_api": null,
          "old_text": "OkStatus()",
          "new_text": null,
          "old_line_content": "  return OkStatus();",
          "new_line_content": "      replacement_instruction = copy_done_;",
          "content_same": false
        },
        {
          "line": 3825,
          "old_api": "defining_position",
          "new_api": null,
          "old_text": "original_allocation_.defining_position()",
          "new_text": null,
          "old_line_content": "  defining_position_ = original_allocation_.defining_position();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3826,
          "old_api": "Allocation::Process()",
          "new_api": null,
          "old_text": "Allocation::Process()",
          "new_text": null,
          "old_line_content": "  return Allocation::Process();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3833,
          "old_api": "AddGetTupleElements",
          "new_api": null,
          "old_text": "original_allocation_.AddGetTupleElements()",
          "new_text": null,
          "old_line_content": "      original_allocation_.AddGetTupleElements();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3834,
          "old_api": "tuple_shapes_size",
          "new_api": null,
          "old_text": "calling_instruction_->shape().tuple_shapes_size()",
          "new_text": null,
          "old_line_content": "  int new_tuple_index = calling_instruction_->shape().tuple_shapes_size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3836,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "TF_ASSIGN_OR_RETURN(\n      HloInstruction * new_while_operand,\n      TupleUtil::ReplaceTupleWith(producing_instruction,\n                                  calling_instruction_->mutable_operand(0),\n                                  {new_tuple_index}))",
          "new_text": null,
          "old_line_content": "  TF_ASSIGN_OR_RETURN(",
          "new_line_content": "  // Add an additional parameter to the while HLO with a reference to the buffer",
          "content_same": false
        },
        {
          "line": 3838,
          "old_api": "mutable_operand",
          "new_api": null,
          "old_text": "TupleUtil::ReplaceTupleWith(producing_instruction,\n                                  calling_instruction_->mutable_operand(0),\n                                  {new_tuple_index})",
          "new_text": null,
          "old_line_content": "      TupleUtil::ReplaceTupleWith(producing_instruction,",
          "new_line_content": "  HloInstruction* producing_instruction =",
          "content_same": false
        },
        {
          "line": 3841,
          "old_api": "ReplaceOperandWithDifferentShape",
          "new_api": null,
          "old_text": "calling_instruction_->ReplaceOperandWithDifferentShape(\n      0, new_while_operand)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(calling_instruction_->ReplaceOperandWithDifferentShape(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3843,
          "old_api": "shape",
          "new_api": null,
          "old_text": "new_while_operand->shape()",
          "new_text": null,
          "old_line_content": "  *calling_instruction_->mutable_shape() = new_while_operand->shape();",
          "new_line_content": "      HloInstruction * new_while_operand,",
          "content_same": false
        },
        {
          "line": 3846,
          "old_api": "shape",
          "new_api": null,
          "old_text": "new_while_operand->shape()",
          "new_text": null,
          "old_line_content": "       ->mutable_shape() = new_while_operand->shape();",
          "new_line_content": "                                  {new_tuple_index}));",
          "content_same": false
        },
        {
          "line": 3854,
          "old_api": "users",
          "new_api": null,
          "old_text": "calling_instruction_->users()",
          "new_text": null,
          "old_line_content": "  std::vector<HloInstruction*> while_users = calling_instruction_->users();",
          "new_line_content": "       ->parameter_instruction(0)",
          "content_same": false
        },
        {
          "line": 3856,
          "old_api": "TupleUtil::ExtractPrefix(calling_instruction_, new_tuple_index)",
          "new_api": null,
          "old_text": "TupleUtil::ExtractPrefix(calling_instruction_, new_tuple_index)",
          "new_text": null,
          "old_line_content": "      TupleUtil::ExtractPrefix(calling_instruction_, new_tuple_index);",
          "new_line_content": "  defining_position_.index = {new_tuple_index};",
          "content_same": false
        },
        {
          "line": 3857,
          "old_api": "ReplaceAllUsesWithDifferentShape",
          "new_api": null,
          "old_text": "calling_instruction_->ReplaceAllUsesWithDifferentShape(\n      while_users, tuple_with_old_shape)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(calling_instruction_->ReplaceAllUsesWithDifferentShape(",
          "new_line_content": "  // Also replace the while op with a tuple that has the old shape. Note that we",
          "content_same": false
        },
        {
          "line": 3859,
          "old_api": "Allocation::Process()",
          "new_api": null,
          "old_text": "Allocation::Process()",
          "new_text": null,
          "old_line_content": "  return Allocation::Process();",
          "new_line_content": "  // since ExtractPrefix introduces additional gte users.",
          "content_same": false
        },
        {
          "line": 3868,
          "old_api": "while_body",
          "new_api": null,
          "old_text": "calling_instruction_->while_body()",
          "new_text": null,
          "old_line_content": "  HloComputation* while_body = calling_instruction_->while_body();",
          "new_line_content": "Status MemorySpaceAssignment::ParentAllocation::PostProcess() {",
          "content_same": false
        },
        {
          "line": 3869,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "TF_ASSIGN_OR_RETURN(HloInstruction * new_while_body_root,\n                      TupleUtil::ReplaceTupleWith(\n                          AddGetTupleElements(), while_body->root_instruction(),\n                          defining_position_.index))",
          "new_text": null,
          "old_line_content": "  TF_ASSIGN_OR_RETURN(HloInstruction * new_while_body_root,",
          "new_line_content": "  // Update the root of the while body with the new parameter. The reason why we",
          "content_same": false
        },
        {
          "line": 3870,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "TupleUtil::ReplaceTupleWith(\n                          AddGetTupleElements(), while_body->root_instruction(),\n                          defining_position_.index)",
          "new_text": null,
          "old_line_content": "                      TupleUtil::ReplaceTupleWith(",
          "new_line_content": "  // need a separate post-process for this is because other allocations may have",
          "content_same": false
        },
        {
          "line": 3871,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "while_body->root_instruction()",
          "new_text": null,
          "old_line_content": "                          AddGetTupleElements(), while_body->root_instruction(),",
          "new_line_content": "  // while body root as a use, so they would update the old root instead of the",
          "content_same": false
        },
        {
          "line": 3873,
          "old_api": "set_root_instruction",
          "new_api": null,
          "old_text": "while_body->set_root_instruction(new_while_body_root,\n                                   /*accept_different_shape=*/true)",
          "new_text": null,
          "old_line_content": "  while_body->set_root_instruction(new_while_body_root,",
          "new_line_content": "  // updated with other changes, and we can safely add the additional parameter.",
          "content_same": false
        },
        {
          "line": 3880,
          "old_api": "MarkNeeded",
          "new_api": null,
          "old_text": "MarkNeeded(needed_allocations)",
          "new_text": null,
          "old_line_content": "  MarkNeeded(needed_allocations);",
          "new_line_content": "                                   /*accept_different_shape=*/true);",
          "content_same": false
        },
        {
          "line": 3885,
          "old_api": "insert",
          "new_api": null,
          "old_text": "needed_allocations.insert(this)",
          "new_text": null,
          "old_line_content": "  needed_allocations.insert(this);",
          "new_line_content": "    absl::flat_hash_set<const Allocation*>& needed_allocations) const {",
          "content_same": false
        },
        {
          "line": 3890,
          "old_api": "insert",
          "new_api": null,
          "old_text": "needed_allocations.insert(this)",
          "new_text": null,
          "old_line_content": "  needed_allocations.insert(this);",
          "new_line_content": "    absl::flat_hash_set<const Allocation*>& needed_allocations) const {",
          "content_same": false
        },
        {
          "line": 3899,
          "old_api": "empty",
          "new_api": null,
          "old_text": "uses_.empty()",
          "new_text": null,
          "old_line_content": "  if (!uses_.empty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3900,
          "old_api": "MarkNeeded",
          "new_api": null,
          "old_text": "MarkNeeded(needed_allocations)",
          "new_text": null,
          "old_line_content": "    MarkNeeded(needed_allocations);",
          "new_line_content": "void MemorySpaceAssignment::ParentAllocation::MarkIfNeeded(",
          "content_same": false
        },
        {
          "line": 3907,
          "old_api": "MarkNeeded",
          "new_api": null,
          "old_text": "original_allocation_.MarkNeeded(needed_allocations)",
          "new_text": null,
          "old_line_content": "  original_allocation_.MarkNeeded(needed_allocations);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3917,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(1)",
          "new_text": null,
          "old_line_content": "  VLOG(1) << \"Processing assigned buffers...\";",
          "new_line_content": "    absl::flat_hash_set<const Allocation*>& needed_allocations) const {",
          "content_same": false
        },
        {
          "line": 3924,
          "old_api": "MarkIfNeeded",
          "new_api": null,
          "old_text": "allocation->MarkIfNeeded(needed_allocations)",
          "new_text": null,
          "old_line_content": "    allocation->MarkIfNeeded(needed_allocations);",
          "new_line_content": "  // Since some parent allocations may not be needed (e.g. when they don't have",
          "content_same": false
        },
        {
          "line": 3928,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "allocation->ToString()",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \"Processing: \" << allocation->ToString();",
          "new_line_content": "  absl::flat_hash_set<const Allocation*> needed_allocations;",
          "content_same": false
        },
        {
          "line": 3929,
          "old_api": "get",
          "new_api": null,
          "old_text": "allocation.get()",
          "new_text": null,
          "old_line_content": "    if (!needed_allocations.contains(allocation.get())) {",
          "new_line_content": "  for (auto& allocation : allocations_) {",
          "content_same": false
        },
        {
          "line": 3933,
          "old_api": "Process",
          "new_api": null,
          "old_text": "allocation->Process()",
          "new_text": null,
          "old_line_content": "    TF_RETURN_IF_ERROR(allocation->Process());",
          "new_line_content": "  for (auto& allocation : allocations_) {",
          "content_same": false
        },
        {
          "line": 3937,
          "old_api": "memory_space",
          "new_api": null,
          "old_text": "allocation->memory_space()",
          "new_text": null,
          "old_line_content": "      CHECK(allocation->memory_space() == MemorySpace::kAlternate);",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 3938,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "scoped_memory_assignments_.emplace_back(\n          allocation->defining_position().instruction, allocation->chunk())",
          "new_text": null,
          "old_line_content": "      scoped_memory_assignments_.emplace_back(",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3941,
          "old_api": "chunk_end",
          "new_api": null,
          "old_text": "allocation->chunk().chunk_end()",
          "new_text": null,
          "old_line_content": "          std::max(alternate_memory_size_, allocation->chunk().chunk_end());",
          "new_line_content": "    // the output map.",
          "content_same": false
        },
        {
          "line": 3946,
          "old_api": "chunk_end",
          "new_api": null,
          "old_text": "allocation->chunk().chunk_end()",
          "new_text": null,
          "old_line_content": "          std::max(alternate_memory_size_, allocation->chunk().chunk_end());",
          "new_line_content": "      alternate_memory_size_ =",
          "content_same": false
        },
        {
          "line": 3951,
          "old_api": "chunk",
          "new_api": null,
          "old_text": "allocation->chunk()",
          "new_text": null,
          "old_line_content": "            allocation->chunk().offset));",
          "new_line_content": "      alternate_memory_size_ =",
          "content_same": false
        },
        {
          "line": 3960,
          "old_api": "get",
          "new_api": null,
          "old_text": "allocation.get()",
          "new_text": null,
          "old_line_content": "    if (needed_allocations.contains(allocation.get())) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3961,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "allocation->ToString()",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \"Post-Processing: \" << allocation->ToString();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3962,
          "old_api": "PostProcess",
          "new_api": null,
          "old_text": "allocation->PostProcess()",
          "new_text": null,
          "old_line_content": "      TF_RETURN_IF_ERROR(allocation->PostProcess());",
          "new_line_content": "  // Post-process allocations. This is only used for parent allocations where we",
          "content_same": false
        },
        {
          "line": 3965,
          "old_api": "OkStatus",
          "new_api": null,
          "old_text": "OkStatus()",
          "new_text": null,
          "old_line_content": "  return OkStatus();",
          "new_line_content": "  for (auto& allocation : allocations_) {",
          "content_same": false
        },
        {
          "line": 3969,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(1)",
          "new_text": null,
          "old_line_content": "  VLOG(1) << \"Exporting buffers...\";",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3972,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "  VLOG(3) << \"Exported alternate memory allocations:\";",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3976,
          "old_api": "GetUniqueBufferAt",
          "new_api": null,
          "old_text": "alias_analysis->GetUniqueBufferAt(\n        defining_position.instruction, defining_position.index)",
          "new_text": null,
          "old_line_content": "    const HloBuffer& buffer = alias_analysis->GetUniqueBufferAt(",
          "new_line_content": "  TF_ASSIGN_OR_RETURN(auto alias_analysis, HloAliasAnalysis::Run(module_));",
          "content_same": false
        },
        {
          "line": 3979,
          "old_api": "end",
          "new_api": null,
          "old_text": "seen_buffer_offsets.end()",
          "new_text": null,
          "old_line_content": "    if (seen_buffer_offset_it != seen_buffer_offsets.end()) {",
          "new_line_content": "  for (const auto& position_and_chunk : alternate_memory_assignments_) {",
          "content_same": false
        },
        {
          "line": 3980,
          "old_api": "CHECK_EQ",
          "new_api": null,
          "old_text": "CHECK_EQ(chunk.offset, seen_buffer_offset_it->second)",
          "new_text": null,
          "old_line_content": "      CHECK_EQ(chunk.offset, seen_buffer_offset_it->second)",
          "new_line_content": "    const HloPosition& defining_position = position_and_chunk.first;",
          "content_same": false
        },
        {
          "line": 3987,
          "old_api": "add_chunk",
          "new_api": null,
          "old_text": "preset_assignments_->add_chunk(defining_position, chunk)",
          "new_text": null,
          "old_line_content": "      preset_assignments_->add_chunk(defining_position, chunk);",
          "new_line_content": "          << \"Mismatch in offset for positions that map to the same value: \"",
          "content_same": false
        },
        {
          "line": 3996,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \" [\" << chunk.offset << \", \" << chunk.size",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3997,
          "old_api": "name",
          "new_api": null,
          "old_text": "instruction->name()",
          "new_text": null,
          "old_line_content": "            << \"] : \" << instruction->name();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4001,
          "old_api": "empty",
          "new_api": null,
          "old_text": "preset_assignments_->chunks().empty()",
          "new_text": null,
          "old_line_content": "  if (!preset_assignments_->chunks().empty() ||",
          "new_line_content": "    const Chunk& chunk = instruction_and_chunk.second;",
          "content_same": false
        },
        {
          "line": 4010,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "    VLOG(3) << \"  space: \" << pair.first << \", size: \" << pair.second.size;",
          "new_line_content": "        ->assignment_information_for_space(options_.alternate_memory_space)",
          "content_same": false
        },
        {
          "line": 4013,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(1)",
          "new_text": null,
          "old_line_content": "  VLOG(1) << \"Coloring buffers...\";",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4018,
          "old_api": "ComputeBuffersAt",
          "new_api": null,
          "old_text": "alias_analysis->ComputeBuffersAt(\n             defining_position.instruction, defining_position.index)",
          "new_text": null,
          "old_line_content": "    for (auto& buffer : alias_analysis->ComputeBuffersAt(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4020,
          "old_api": "values",
          "new_api": null,
          "old_text": "buffer->values()",
          "new_text": null,
          "old_line_content": "      for (auto& value : buffer->values()) {",
          "new_line_content": "  // Color the pending positions and all of their aliased buffers.",
          "content_same": false
        },
        {
          "line": 4021,
          "old_api": "positions",
          "new_api": null,
          "old_text": "value->positions()",
          "new_text": null,
          "old_line_content": "        for (auto& position : value->positions()) {",
          "new_line_content": "  for (const auto& defining_position_and_chunk :",
          "content_same": false
        },
        {
          "line": 4023,
          "old_api": "mutable_shape",
          "new_api": null,
          "old_text": "ShapeUtil::GetMutableSubshape(\n              position.instruction->mutable_shape(), position.index)",
          "new_text": null,
          "old_line_content": "          Shape* shape = ShapeUtil::GetMutableSubshape(",
          "new_line_content": "    const HloPosition& defining_position = defining_position_and_chunk.first;",
          "content_same": false
        },
        {
          "line": 4025,
          "old_api": "IsArray",
          "new_api": null,
          "old_text": "shape->IsArray()",
          "new_text": null,
          "old_line_content": "          CHECK(shape->IsArray()) << \"Coloring a shape that is not an array: \"",
          "new_line_content": "             defining_position.instruction, defining_position.index)) {",
          "content_same": false
        },
        {
          "line": 4038,
          "old_api": "begin",
          "new_api": null,
          "old_text": "alternate_memory_assignments_.begin()",
          "new_text": null,
          "old_line_content": "  auto it = alternate_memory_assignments_.begin();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 4043,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(3)",
          "new_text": null,
          "old_line_content": "      VLOG(3) << \"Removing instruction from alternate memory assignments.\";",
          "new_line_content": "    const HloInstruction* instruction) {",
          "content_same": false
        },
        {
          "line": 4060,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(1)",
          "new_text": null,
          "old_line_content": "  VLOG(1) << \"Simplifying graph...\";",
          "new_line_content": "      ++it;",
          "content_same": false
        },
        {
          "line": 4061,
          "old_api": "MakeNonfusionComputations",
          "new_api": null,
          "old_text": "module_->MakeNonfusionComputations()",
          "new_text": null,
          "old_line_content": "  for (HloComputation* computation : module_->MakeNonfusionComputations()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4064,
          "old_api": "contains",
          "new_api": null,
          "old_text": "computations_in_schedule_.contains(computation)",
          "new_text": null,
          "old_line_content": "    if (!computations_in_schedule_.contains(computation)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4065,
          "old_api": "name",
          "new_api": null,
          "old_text": "computation->name()",
          "new_text": null,
          "old_line_content": "      VLOG(4) << \"Not simplifying \" << computation->name()",
          "new_line_content": "Status MemorySpaceAssignment::SimplifyGraph() {",
          "content_same": false
        },
        {
          "line": 4075,
          "old_api": "MakeInstructionPostOrder",
          "new_api": null,
          "old_text": "computation->MakeInstructionPostOrder()",
          "new_text": null,
          "old_line_content": "         computation->MakeInstructionPostOrder()) {",
          "new_line_content": "    // Drop control dependencies. Since the computation is already scheduled, we",
          "content_same": false
        },
        {
          "line": 4076,
          "old_api": "DropAllControlDeps",
          "new_api": null,
          "old_text": "instruction->DropAllControlDeps()",
          "new_text": null,
          "old_line_content": "      TF_RETURN_IF_ERROR(instruction->DropAllControlDeps());",
          "new_line_content": "    // don't need control dependencies anymore, and having control",
          "content_same": false
        },
        {
          "line": 4086,
          "old_api": "name",
          "new_api": null,
          "old_text": "computation->name()",
          "new_text": null,
          "old_line_content": "      VLOG(4) << \"Running simplify graph loop over \" << computation->name();",
          "new_line_content": "    // assignment is ran late in compilation (after DCE and arithmetic",
          "content_same": false
        },
        {
          "line": 4088,
          "old_api": "MakeInstructionPostOrder",
          "new_api": null,
          "old_text": "computation->MakeInstructionPostOrder()",
          "new_text": null,
          "old_line_content": "           computation->MakeInstructionPostOrder()) {",
          "new_line_content": "    // to fixed point.",
          "content_same": false
        },
        {
          "line": 4089,
          "old_api": "IsSafelyRemovable",
          "new_api": null,
          "old_text": "computation->IsSafelyRemovable(instruction)",
          "new_text": null,
          "old_line_content": "        if (computation->IsSafelyRemovable(instruction) &&",
          "new_line_content": "    bool computation_modified = true;",
          "content_same": false
        },
        {
          "line": 4090,
          "old_api": "HasSideEffect",
          "new_api": null,
          "old_text": "instruction->HasSideEffect()",
          "new_text": null,
          "old_line_content": "            instruction->IsDead() && !instruction->HasSideEffect() &&",
          "new_line_content": "    while (computation_modified) {",
          "content_same": false
        },
        {
          "line": 4091,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "instruction->opcode()",
          "new_text": null,
          "old_line_content": "            instruction->opcode() != HloOpcode::kCopyStart &&",
          "new_line_content": "      computation_modified = false;",
          "content_same": false
        },
        {
          "line": 4093,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "instruction->ToString()",
          "new_text": null,
          "old_line_content": "          VLOG(4) << \"Instruction removed: \" << instruction->ToString();",
          "new_line_content": "      for (HloInstruction* instruction :",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 231,
      "total_additions": 499,
      "total_deletions": 496,
      "total_api_changes": 1226
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 10,
        "api_related_lines": 1226,
        "non_api_lines": 5,
        "non_api_line_numbers": [
          2262,
          2263,
          2268,
          2269,
          2271
        ]
      }
    },
    "api_calls_before": 1873,
    "api_calls_after": 1877,
    "diff_info": {
      "added_lines": 8,
      "removed_lines": 2,
      "total_diff_lines": 24
    }
  }
}