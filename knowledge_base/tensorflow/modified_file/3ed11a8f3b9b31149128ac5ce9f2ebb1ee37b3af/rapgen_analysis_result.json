{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/3ed11a8f3b9b31149128ac5ce9f2ebb1ee37b3af",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/3ed11a8f3b9b31149128ac5ce9f2ebb1ee37b3af/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/3ed11a8f3b9b31149128ac5ce9f2ebb1ee37b3af/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/3ed11a8f3b9b31149128ac5ce9f2ebb1ee37b3af/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 104,
          "old_api": "replica_ids",
          "new_api": "clear",
          "old_text": "group.replica_ids()",
          "new_text": "visited_partitions.clear()",
          "old_line_content": "          for (int64_t id : group.replica_ids()) {",
          "new_line_content": "          visited_partitions.clear();",
          "content_same": false
        },
        {
          "line": 107,
          "old_api": "insert",
          "new_api": "replica_ids",
          "old_text": "visited_partitions.insert(pid)",
          "new_text": "group.replica_ids().size()",
          "old_line_content": "            visited_partitions.insert(pid);",
          "new_line_content": "          visited_partitions.reserve(group.replica_ids().size());",
          "content_same": false
        },
        {
          "line": 108,
          "old_api": "insert",
          "new_api": "replica_ids",
          "old_text": "visited_replicas.insert(rid)",
          "new_text": "group.replica_ids()",
          "old_line_content": "            visited_replicas.insert(rid);",
          "new_line_content": "          for (int64_t id : group.replica_ids()) {",
          "content_same": false
        },
        {
          "line": 111,
          "old_api": "size",
          "new_api": "insert",
          "old_text": "visited_partitions.size()",
          "new_text": "visited_partitions.insert(pid)",
          "old_line_content": "              visited_partitions.size() == num_partitions;",
          "new_line_content": "            visited_partitions.insert(pid);",
          "content_same": false
        },
        {
          "line": 118,
          "old_api": "HloReplication::ReplicatedOnAllDevices()",
          "new_api": "replica_count",
          "old_text": "HloReplication::ReplicatedOnAllDevices()",
          "new_text": "hlo->GetModule()->config().replica_count()",
          "old_line_content": "          return HloReplication::ReplicatedOnAllDevices();",
          "new_line_content": "              hlo->GetModule()->config().replica_count();",
          "content_same": false
        },
        {
          "line": 124,
          "old_api": "HloReplication::ReplicatedOnAllDevices()",
          "new_api": "HloReplication::UniqueOnAllDevices()",
          "old_text": "HloReplication::ReplicatedOnAllDevices()",
          "new_text": "HloReplication::UniqueOnAllDevices()",
          "old_line_content": "        return HloReplication::ReplicatedOnAllDevices();",
          "new_line_content": "          return HloReplication::UniqueOnAllDevices();",
          "content_same": false
        },
        {
          "line": 133,
          "old_api": "HasSideEffectNoRecurse",
          "new_api": "HloReplication::UniqueOnAllDevices()",
          "old_text": "hlo->HasSideEffectNoRecurse()",
          "new_text": "HloReplication::UniqueOnAllDevices()",
          "old_line_content": "  if (hlo->HasSideEffectNoRecurse()) {",
          "new_line_content": "        return HloReplication::UniqueOnAllDevices();",
          "content_same": false
        },
        {
          "line": 138,
          "old_api": "HloReplication::ReplicatedOnAllDevices()",
          "new_api": "HloReplication::UniqueOnAllDevices()",
          "old_text": "HloReplication::ReplicatedOnAllDevices()",
          "new_text": "HloReplication::UniqueOnAllDevices()",
          "old_line_content": "    return cross_partition_spmd ? HloReplication::ReplicatedOnAllDevices()",
          "new_line_content": "    return HloReplication::UniqueOnAllDevices();",
          "content_same": false
        },
        {
          "line": 147,
          "old_api": "opcode",
          "new_api": "HloReplication::UniqueOnAllDevices()",
          "old_text": "hlo->opcode()",
          "new_text": "HloReplication::UniqueOnAllDevices()",
          "old_line_content": "  if (hlo->opcode() == HloOpcode::kParameter) {",
          "new_line_content": "    return cross_partition_spmd ? HloReplication::UniqueOnAllDevices()",
          "content_same": false
        },
        {
          "line": 150,
          "old_api": "element",
          "new_api": "find",
          "old_text": "it->second.element(index)",
          "new_text": "hlo_replication.find(hlo)",
          "old_line_content": "    return it->second.element(index);",
          "new_line_content": "  auto it = hlo_replication.find(hlo);",
          "content_same": false
        },
        {
          "line": 153,
          "old_api": "element",
          "new_api": "end",
          "old_text": "it->second.element(index).IsUniqueOnAllDevices()",
          "new_text": "hlo_replication.end()",
          "old_line_content": "      it->second.element(index).IsUniqueOnAllDevices()) {",
          "new_line_content": "    CHECK(it != hlo_replication.end());",
          "content_same": false
        },
        {
          "line": 159,
          "old_api": "HloReplication::ReplicatedOnAllDevices()",
          "new_api": "element",
          "old_text": "HloReplication::ReplicatedOnAllDevices()",
          "new_text": "it->second.element(index)",
          "old_line_content": "    return HloReplication::ReplicatedOnAllDevices();",
          "new_line_content": "    return it->second.element(index);",
          "content_same": false
        },
        {
          "line": 163,
          "old_api": "custom_call_target",
          "new_api": "HloReplication::ReplicatedOnAllDevices()",
          "old_text": "hlo->custom_call_target()",
          "new_text": "HloReplication::ReplicatedOnAllDevices()",
          "old_line_content": "      (hlo->custom_call_target() == \"X64SplitLow\" ||",
          "new_line_content": "    return HloReplication::ReplicatedOnAllDevices();",
          "content_same": false
        },
        {
          "line": 166,
          "old_api": "merge_operand_replication",
          "new_api": "opcode",
          "old_text": "merge_operand_replication(hlo)",
          "new_text": "hlo->opcode()",
          "old_line_content": "    return merge_operand_replication(hlo);",
          "new_line_content": "  if (hlo->opcode() == HloOpcode::kCustomCall &&",
          "content_same": false
        },
        {
          "line": 177,
          "old_api": "rank",
          "new_api": "operand",
          "old_text": "ds_buffer->shape().rank()",
          "new_text": "hlo->operand(0)",
          "old_line_content": "          ds_buffer->shape().rank() == 1 &&",
          "new_line_content": "      const HloInstruction* ds_buffer = hlo->operand(0);",
          "content_same": false
        },
        {
          "line": 178,
          "old_api": "element_type",
          "new_api": "size",
          "old_text": "ds_buffer->shape().element_type()",
          "new_text": "hlo->dynamic_slice_sizes().size()",
          "old_line_content": "          ds_buffer->shape().element_type() == PrimitiveType::S32 &&",
          "new_line_content": "      if (hlo->dynamic_slice_sizes().size() == 1 &&",
          "content_same": false
        },
        {
          "line": 180,
          "old_api": "operand",
          "new_api": "opcode",
          "old_text": "hlo->operand(1)->opcode()",
          "new_text": "ds_buffer->opcode()",
          "old_line_content": "            hlo->operand(1)->opcode() == HloOpcode::kPartitionId) ||",
          "new_line_content": "          ds_buffer->opcode() == HloOpcode::kConstant &&",
          "content_same": false
        },
        {
          "line": 182,
          "old_api": "operand",
          "new_api": "element_type",
          "old_text": "hlo->operand(1)->opcode()",
          "new_text": "ds_buffer->shape().element_type()",
          "old_line_content": "            hlo->operand(1)->opcode() == HloOpcode::kReplicaId))) {",
          "new_line_content": "          ds_buffer->shape().element_type() == PrimitiveType::S32 &&",
          "content_same": false
        },
        {
          "line": 186,
          "old_api": "replica_count",
          "new_api": "operand",
          "old_text": "hlo_module->config().replica_count()",
          "new_text": "hlo->operand(1)->opcode()",
          "old_line_content": "                                  : hlo_module->config().replica_count();",
          "new_line_content": "            hlo->operand(1)->opcode() == HloOpcode::kReplicaId))) {",
          "content_same": false
        },
        {
          "line": 190,
          "old_api": "GetIntegralAsS64",
          "new_api": "replica_count",
          "old_text": "ds_buffer->literal().GetIntegralAsS64({device_id})",
          "new_text": "hlo_module->config().replica_count()",
          "old_line_content": "              ds_buffer->literal().GetIntegralAsS64({device_id});",
          "new_line_content": "                                  : hlo_module->config().replica_count();",
          "content_same": false
        },
        {
          "line": 207,
          "old_api": "opcode",
          "new_api": "IsElementwise",
          "old_text": "hlo->opcode()",
          "new_text": "hlo->IsElementwise()",
          "old_line_content": "      hlo->opcode() == HloOpcode::kReduce ||              //",
          "new_line_content": "  if (hlo->IsElementwise() ||                             //",
          "content_same": false
        },
        {
          "line": 222,
          "old_api": "merge_operand_replication",
          "new_api": "opcode",
          "old_text": "merge_operand_replication(hlo)",
          "new_text": "hlo->opcode()",
          "old_line_content": "    return merge_operand_replication(hlo);",
          "new_line_content": "      hlo->opcode() == HloOpcode::kDynamicSlice ||        //",
          "content_same": false
        },
        {
          "line": 224,
          "old_api": "HloReplication::UniqueOnAllDevices()",
          "new_api": "opcode",
          "old_text": "HloReplication::UniqueOnAllDevices()",
          "new_text": "hlo->opcode()",
          "old_line_content": "  return HloReplication::UniqueOnAllDevices();",
          "new_line_content": "      hlo->opcode() == HloOpcode::kReduceWindow ||        //",
          "content_same": false
        },
        {
          "line": 242,
          "old_api": "ForEachMutableElement",
          "new_api": "std::move(to_combine)",
          "old_text": "it->second.ForEachMutableElement(\n              [&](const ShapeIndex& index, HloReplication* element) {\n                HloReplication new_replication =\n                    element->Merge(to_combine.element(index));\n                if (!element->Equal(new_replication)) {\n                  *element = std::move(new_replication);\n                  updated = true;\n                }\n              })",
          "new_text": "std::move(to_combine)",
          "old_line_content": "          it->second.ForEachMutableElement(",
          "new_line_content": "            hlo_replication_[dest] = std::move(to_combine);",
          "content_same": false
        },
        {
          "line": 246,
          "old_api": "Equal",
          "new_api": "ForEachMutableElement",
          "old_text": "element->Equal(new_replication)",
          "new_text": "it->second.ForEachMutableElement(\n              [&](const ShapeIndex& index, HloReplication* element) {\n                HloReplication new_replication =\n                    element->Merge(to_combine.element(index));\n                if (!element->Equal(new_replication)) {\n                  *element = std::move(new_replication);\n                  updated = true;\n                }\n              })",
          "old_line_content": "                if (!element->Equal(new_replication)) {",
          "new_line_content": "          it->second.ForEachMutableElement(",
          "content_same": false
        },
        {
          "line": 261,
          "old_api": "assign_or_combine_shapetree",
          "new_api": "find",
          "old_text": "assign_or_combine_shapetree(\n          ShapeTree<HloReplication>(source_it->second), dest)",
          "new_text": "hlo_replication_.find(source)",
          "old_line_content": "      return assign_or_combine_shapetree(",
          "new_line_content": "      auto source_it = hlo_replication_.find(source);",
          "content_same": false
        },
        {
          "line": 262,
          "old_api": "ShapeTree<HloReplication>(source_it->second)",
          "new_api": "end",
          "old_text": "ShapeTree<HloReplication>(source_it->second)",
          "new_text": "hlo_replication_.end()",
          "old_line_content": "          ShapeTree<HloReplication>(source_it->second), dest);",
          "new_line_content": "      if (source_it == hlo_replication_.end()) {",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": "while_body",
          "new_api": "operand",
          "old_text": "inst->while_body()->root_instruction()",
          "new_text": "propagate_shapetree(\n            inst->operand(0),\n            inst->while_condition()->parameter_instruction(0))",
          "old_line_content": "            inst->while_body()->root_instruction(),",
          "new_line_content": "        bool updated = propagate_shapetree(",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": "while_condition",
          "new_api": "operand",
          "old_text": "inst->while_condition()->parameter_instruction(0)",
          "new_text": "inst->operand(0)",
          "old_line_content": "            inst->while_condition()->parameter_instruction(0));",
          "new_line_content": "            inst->operand(0),",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": "operand",
          "new_api": "while_condition",
          "old_text": "propagate_shapetree(\n            inst->operand(0), inst->while_body()->parameter_instruction(0))",
          "new_text": "inst->while_condition()->parameter_instruction(0)",
          "old_line_content": "        updated |= propagate_shapetree(",
          "new_line_content": "            inst->while_condition()->parameter_instruction(0));",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": "while_body",
          "new_api": "while_condition",
          "old_text": "inst->while_body()->root_instruction()",
          "new_text": "inst->while_condition()->parameter_instruction(0)",
          "old_line_content": "            propagate_shapetree(inst->while_body()->root_instruction(),",
          "new_line_content": "            inst->while_condition()->parameter_instruction(0));",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": "while_body",
          "new_api": "operand",
          "old_text": "inst->while_body()->parameter_instruction(0)",
          "new_text": "propagate_shapetree(\n            inst->operand(0), inst->while_body()->parameter_instruction(0))",
          "old_line_content": "                                inst->while_body()->parameter_instruction(0));",
          "new_line_content": "        updated |= propagate_shapetree(",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": "while_condition",
          "new_api": "while_body",
          "old_text": "inst->while_condition()",
          "new_text": "inst->while_body()->root_instruction()",
          "old_line_content": "            inst->while_condition(), mark_everything_not_replicated);",
          "new_line_content": "            propagate_shapetree(inst->while_body()->root_instruction(),",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": "ContainsKey",
          "new_api": "while_condition",
          "old_text": "ContainsKey(loops_known_with_same_iterations_, inst)",
          "new_text": "ComputeHloReplicationOnComputation(\n            inst->while_condition(), mark_everything_not_replicated)",
          "old_line_content": "        if (!ContainsKey(loops_known_with_same_iterations_, inst) &&",
          "new_line_content": "        updated |= ComputeHloReplicationOnComputation(",
          "content_same": false
        },
        {
          "line": 293,
          "old_api": "while_body",
          "new_api": "ContainsKey",
          "old_text": "ComputeHloReplicationOnComputation(\n              inst->while_body(), /*mark_everything_not_replicated=*/true)",
          "new_text": "ContainsKey(loops_known_with_same_iterations_, inst)",
          "old_line_content": "          updated |= ComputeHloReplicationOnComputation(",
          "new_line_content": "        if (!ContainsKey(loops_known_with_same_iterations_, inst) &&",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": "while_body",
          "new_api": "while_condition",
          "old_text": "inst->while_body()",
          "new_text": "inst->while_condition()->root_instruction()",
          "old_line_content": "              inst->while_body(), /*mark_everything_not_replicated=*/true);",
          "new_line_content": "            !hlo_replication_[inst->while_condition()->root_instruction()]",
          "content_same": false
        },
        {
          "line": 309,
          "old_api": "opcode",
          "new_api": "operand",
          "old_text": "inst->opcode()",
          "new_text": "inst->operand(0)",
          "old_line_content": "               inst->opcode() == HloOpcode::kFusion) {",
          "new_line_content": "      changed |= propagate_shapetree(inst->operand(0), inst);",
          "content_same": false
        },
        {
          "line": 311,
          "old_api": "operand_count",
          "new_api": "while_body",
          "old_text": "inst->operand_count()",
          "new_text": "inst->while_body()->root_instruction()",
          "old_line_content": "      for (int64_t i = 0; i < inst->operand_count(); ++i) {",
          "new_line_content": "          propagate_shapetree(inst->while_body()->root_instruction(), inst);",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": "operand",
          "new_api": "opcode",
          "old_text": "inst->operand(i)",
          "new_text": "inst->opcode()",
          "old_line_content": "        changed |= propagate_shapetree(inst->operand(i),",
          "new_line_content": "    } else if (inst->opcode() == HloOpcode::kCall ||",
          "content_same": false
        },
        {
          "line": 313,
          "old_api": "parameter_instruction",
          "new_api": "opcode",
          "old_text": "called->parameter_instruction(i)",
          "new_text": "inst->opcode()",
          "old_line_content": "                                       called->parameter_instruction(i));",
          "new_line_content": "               inst->opcode() == HloOpcode::kFusion) {",
          "content_same": false
        },
        {
          "line": 315,
          "old_api": "ComputeHloReplicationOnComputation",
          "new_api": "operand_count",
          "old_text": "ComputeHloReplicationOnComputation(\n          called, mark_everything_not_replicated)",
          "new_text": "inst->operand_count()",
          "old_line_content": "      changed |= ComputeHloReplicationOnComputation(",
          "new_line_content": "      for (int64_t i = 0; i < inst->operand_count(); ++i) {",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": "root_instruction",
          "new_api": "parameter_instruction",
          "old_text": "called->root_instruction()",
          "new_text": "called->parameter_instruction(i)",
          "old_line_content": "      changed |= propagate_shapetree(called->root_instruction(), inst);",
          "new_line_content": "                                       called->parameter_instruction(i));",
          "content_same": false
        },
        {
          "line": 321,
          "old_api": "operand",
          "new_api": "root_instruction",
          "old_text": "propagate_shapetree(\n            inst->operand(i + 1),\n            inst->called_computations()[i]->parameter_instruction(0))",
          "new_text": "called->root_instruction()",
          "old_line_content": "        changed |= propagate_shapetree(",
          "new_line_content": "      changed |= propagate_shapetree(called->root_instruction(), inst);",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": "operand",
          "new_api": "opcode",
          "old_text": "inst->operand(i + 1)",
          "new_text": "inst->opcode()",
          "old_line_content": "            inst->operand(i + 1),",
          "new_line_content": "    } else if (inst->opcode() == HloOpcode::kConditional) {",
          "content_same": false
        },
        {
          "line": 327,
          "old_api": "operand",
          "new_api": "called_computations",
          "old_text": "inst->operand(0)",
          "new_text": "inst->called_computations()[i]->parameter_instruction(0)",
          "old_line_content": "      if (!hlo_replication_[inst->operand(0)]",
          "new_line_content": "            inst->called_computations()[i]->parameter_instruction(0));",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": "ComputeHloReplicationOnComputation",
          "new_api": "operand",
          "old_text": "ComputeHloReplicationOnComputation(\n              called,\n              /*mark_everything_not_replicated=*/true)",
          "new_text": "inst->operand(0)",
          "old_line_content": "          changed |= ComputeHloReplicationOnComputation(",
          "new_line_content": "      if (!hlo_replication_[inst->operand(0)]",
          "content_same": false
        },
        {
          "line": 335,
          "old_api": "shape",
          "new_api": "ComputeHloReplicationOnComputation",
          "old_text": "assign_or_combine_shapetree(\n            ShapeTree<HloReplication>(inst->shape(),\n                                      HloReplication::UniqueOnAllDevices()),\n            inst)",
          "new_text": "ComputeHloReplicationOnComputation(\n              called,\n              /*mark_everything_not_replicated=*/true)",
          "old_line_content": "        changed |= assign_or_combine_shapetree(",
          "new_line_content": "          changed |= ComputeHloReplicationOnComputation(",
          "content_same": false
        },
        {
          "line": 340,
          "old_api": "called_computations",
          "new_api": "shape",
          "old_text": "inst->called_computations()",
          "new_text": "inst->shape()",
          "old_line_content": "        for (auto called : inst->called_computations()) {",
          "new_line_content": "            ShapeTree<HloReplication>(inst->shape(),",
          "content_same": false
        },
        {
          "line": 341,
          "old_api": "ComputeHloReplicationOnComputation",
          "new_api": "HloReplication::UniqueOnAllDevices()",
          "old_text": "ComputeHloReplicationOnComputation(\n              called, mark_everything_not_replicated)",
          "new_text": "HloReplication::UniqueOnAllDevices()",
          "old_line_content": "          changed |= ComputeHloReplicationOnComputation(",
          "new_line_content": "                                      HloReplication::UniqueOnAllDevices()),",
          "content_same": false
        },
        {
          "line": 350,
          "old_api": "operand",
          "new_api": "opcode",
          "old_text": "inst->operand(i)",
          "new_text": "inst->opcode()",
          "old_line_content": "        shape_tree.CopySubtreeFrom(hlo_replication_[inst->operand(i)], {}, {i});",
          "new_line_content": "    } else if (inst->opcode() == HloOpcode::kTuple) {",
          "content_same": false
        },
        {
          "line": 352,
          "old_api": "std::move(shape_tree)",
          "new_api": "HloReplication::ReplicatedOnAllDevices()",
          "old_text": "std::move(shape_tree)",
          "new_text": "HloReplication::ReplicatedOnAllDevices()",
          "old_line_content": "      changed |= assign_or_combine_shapetree(std::move(shape_tree), inst);",
          "new_line_content": "          inst->shape(), HloReplication::ReplicatedOnAllDevices());",
          "content_same": false
        },
        {
          "line": 353,
          "old_api": "opcode",
          "new_api": "operand_count",
          "old_text": "inst->opcode()",
          "new_text": "inst->operand_count()",
          "old_line_content": "    } else if (inst->opcode() == HloOpcode::kGetTupleElement) {",
          "new_line_content": "      for (int64_t i = 0; i < inst->operand_count(); ++i) {",
          "content_same": false
        },
        {
          "line": 356,
          "old_api": "operand",
          "new_api": "std::move(shape_tree)",
          "old_text": "inst->operand(0)",
          "new_text": "std::move(shape_tree)",
          "old_line_content": "      shape_tree.CopySubtreeFrom(hlo_replication_[inst->operand(0)],",
          "new_line_content": "      changed |= assign_or_combine_shapetree(std::move(shape_tree), inst);",
          "content_same": false
        },
        {
          "line": 357,
          "old_api": "tuple_index",
          "new_api": "opcode",
          "old_text": "inst->tuple_index()",
          "new_text": "inst->opcode()",
          "old_line_content": "                                 {inst->tuple_index()}, {});",
          "new_line_content": "    } else if (inst->opcode() == HloOpcode::kGetTupleElement) {",
          "content_same": false
        },
        {
          "line": 359,
          "old_api": "opcode",
          "new_api": "HloReplication::ReplicatedOnAllDevices()",
          "old_text": "inst->opcode()",
          "new_text": "HloReplication::ReplicatedOnAllDevices()",
          "old_line_content": "    } else if (inst->opcode() == HloOpcode::kInfeed && cross_partition_spmd_) {",
          "new_line_content": "          inst->shape(), HloReplication::ReplicatedOnAllDevices());",
          "content_same": false
        },
        {
          "line": 361,
          "old_api": "HloReplication::UniqueOnAllDevices()",
          "new_api": "tuple_index",
          "old_text": "HloReplication::UniqueOnAllDevices()",
          "new_text": "inst->tuple_index()",
          "old_line_content": "          inst->shape(), HloReplication::UniqueOnAllDevices());",
          "new_line_content": "                                 {inst->tuple_index()}, {});",
          "content_same": false
        },
        {
          "line": 362,
          "old_api": "has_sharding",
          "new_api": "std::move(shape_tree)",
          "old_text": "inst->has_sharding()",
          "new_text": "std::move(shape_tree)",
          "old_line_content": "      if (inst->has_sharding()) {",
          "new_line_content": "      changed |= assign_or_combine_shapetree(std::move(shape_tree), inst);",
          "content_same": false
        },
        {
          "line": 363,
          "old_api": "shape",
          "new_api": "opcode",
          "old_text": "inst->shape()",
          "new_text": "inst->opcode()",
          "old_line_content": "        auto sharding = inst->sharding().GetAsShapeTree(inst->shape());",
          "new_line_content": "    } else if (inst->opcode() == HloOpcode::kInfeed && cross_partition_spmd_) {",
          "content_same": false
        },
        {
          "line": 366,
          "old_api": "element",
          "new_api": "has_sharding",
          "old_text": "sharding.element(index).IsReplicated()",
          "new_text": "inst->has_sharding()",
          "old_line_content": "              *data = sharding.element(index).IsReplicated()",
          "new_line_content": "      if (inst->has_sharding()) {",
          "content_same": false
        },
        {
          "line": 367,
          "old_api": "HloReplication::ReplicatedOnAllDevices()",
          "new_api": "shape",
          "old_text": "HloReplication::ReplicatedOnAllDevices()",
          "new_text": "inst->shape()",
          "old_line_content": "                          ? HloReplication::ReplicatedOnAllDevices()",
          "new_line_content": "        auto sharding = inst->sharding().GetAsShapeTree(inst->shape());",
          "content_same": false
        },
        {
          "line": 368,
          "old_api": "HloReplication::UniqueOnAllDevices()",
          "new_api": "ForEachMutableElement",
          "old_text": "HloReplication::UniqueOnAllDevices()",
          "new_text": "shape_tree.ForEachMutableElement(\n            [&sharding](const ShapeIndex& index, HloReplication* data) {\n              *data = sharding.element(index).IsReplicated()\n                          ? HloReplication::ReplicatedOnAllDevices()\n                          : HloReplication::UniqueOnAllDevices();\n            })",
          "old_line_content": "                          : HloReplication::UniqueOnAllDevices();",
          "new_line_content": "        shape_tree.ForEachMutableElement(",
          "content_same": false
        },
        {
          "line": 371,
          "old_api": "std::move(shape_tree)",
          "new_api": "HloReplication::ReplicatedOnAllDevices()",
          "old_text": "std::move(shape_tree)",
          "new_text": "HloReplication::ReplicatedOnAllDevices()",
          "old_line_content": "      changed |= assign_or_combine_shapetree(std::move(shape_tree), inst);",
          "new_line_content": "                          ? HloReplication::ReplicatedOnAllDevices()",
          "content_same": false
        },
        {
          "line": 375,
          "old_api": "shape",
          "new_api": "std::move(shape_tree)",
          "old_text": "inst->shape()",
          "new_text": "std::move(shape_tree)",
          "old_line_content": "            ShapeTree<HloReplication>(inst->shape(),",
          "new_line_content": "      changed |= assign_or_combine_shapetree(std::move(shape_tree), inst);",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": "HloReplication::ReplicatedOnAllDevices()",
          "new_api": "HloReplication::UniqueOnAllDevices()",
          "old_text": "HloReplication::ReplicatedOnAllDevices()",
          "new_text": "HloReplication::UniqueOnAllDevices()",
          "old_line_content": "            inst->shape(), HloReplication::ReplicatedOnAllDevices());",
          "new_line_content": "                                      HloReplication::UniqueOnAllDevices()),",
          "content_same": false
        },
        {
          "line": 384,
          "old_api": "DetermineHloInstructionIsReplicated",
          "new_api": "HloReplication::ReplicatedOnAllDevices()",
          "old_text": "DetermineHloInstructionIsReplicated(\n                      inst, index, cross_partition_spmd_, hlo_replication_,\n                      support_partial_replication_)",
          "new_text": "HloReplication::ReplicatedOnAllDevices()",
          "old_line_content": "                  DetermineHloInstructionIsReplicated(",
          "new_line_content": "            inst->shape(), HloReplication::ReplicatedOnAllDevices());",
          "content_same": false
        },
        {
          "line": 388,
          "old_api": "std::move(shape_tree)",
          "new_api": "DetermineHloInstructionIsReplicated",
          "old_text": "std::move(shape_tree)",
          "new_text": "DetermineHloInstructionIsReplicated(\n                      inst, index, cross_partition_spmd_, hlo_replication_,\n                      support_partial_replication_)",
          "old_line_content": "        changed |= assign_or_combine_shapetree(std::move(shape_tree), inst);",
          "new_line_content": "                  DetermineHloInstructionIsReplicated(",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": "HloReplication::UniqueOnAllDevices()",
          "new_api": "entry_computation",
          "old_text": "HloReplication::UniqueOnAllDevices()",
          "new_text": "module_->entry_computation()",
          "old_line_content": "                                         HloReplication::UniqueOnAllDevices());",
          "new_line_content": "  auto entry = module_->entry_computation();",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": "parameter_replicated_at_leaf_buffers",
          "new_api": "num_parameters",
          "old_text": "param->parameter_replicated_at_leaf_buffers()",
          "new_text": "entry->num_parameters()",
          "old_line_content": "    const auto& replication = param->parameter_replicated_at_leaf_buffers();",
          "new_line_content": "  for (int i = 0; i < entry->num_parameters(); ++i) {",
          "content_same": false
        },
        {
          "line": 406,
          "old_api": "AsShapeTree",
          "new_api": "shape",
          "old_text": "ShapeUtil::ForEachSubshapeWithStatus(\n        param->shape(), [&](const Shape& subshape, const ShapeIndex& index) {\n          if (!ShapeUtil::IsLeafIndex(param->shape(), index)) {\n            return OkStatus();\n          }\n          if (cross_partition_spmd_ && param->has_sharding()) {\n            // In cross-partition spmd mode, set parameter replication status\n            // based on the parameter's sharding.\n            TF_ASSIGN_OR_RETURN(auto sharding_tree,\n                                param->sharding().AsShapeTree(param->shape()));\n            *shape_tree.mutable_element(index) =\n                sharding_tree.element(index).IsReplicated()\n                    ? HloReplication::ReplicatedOnAllDevices()\n                    : HloReplication::UniqueOnAllDevices();\n          }\n          if (replication) {\n            // If parameter replication status has been set explicitly, use that\n            // instead.\n            if (!cross_partition_spmd_ && (*replication)[leaf_index]) {\n              // Setting parameter replication status for replicas in\n              // non cross-partition spmd mode.\n              *shape_tree.mutable_element(index) =\n                  HloReplication::ReplicatedOnAllDevices();\n            }\n            if (cross_partition_spmd_ && !(*replication)[leaf_index]) {\n              // Setting paramemter replication status for partitions in\n              // cross-partition spmd mode.\n              *shape_tree.mutable_element(index) =\n                  HloReplication::UniqueOnAllDevices();\n            }\n            ++leaf_index;\n          }\n          return OkStatus();\n        })",
          "new_text": "param->shape()",
          "old_line_content": "    Status status = ShapeUtil::ForEachSubshapeWithStatus(",
          "new_line_content": "    ShapeTree<HloReplication> shape_tree(param->shape(),",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": "shape",
          "new_api": "HloReplication::UniqueOnAllDevices()",
          "old_text": "param->shape()",
          "new_text": "HloReplication::UniqueOnAllDevices()",
          "old_line_content": "        param->shape(), [&](const Shape& subshape, const ShapeIndex& index) {",
          "new_line_content": "                                         HloReplication::UniqueOnAllDevices());",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": "shape",
          "new_api": "parameter_replicated_at_leaf_buffers",
          "old_text": "param->shape()",
          "new_text": "param->parameter_replicated_at_leaf_buffers()",
          "old_line_content": "          if (!ShapeUtil::IsLeafIndex(param->shape(), index)) {",
          "new_line_content": "    const auto& replication = param->parameter_replicated_at_leaf_buffers();",
          "content_same": false
        },
        {
          "line": 411,
          "old_api": "has_sharding",
          "new_api": "shape",
          "old_text": "param->has_sharding()",
          "new_text": "param->shape()",
          "old_line_content": "          if (cross_partition_spmd_ && param->has_sharding()) {",
          "new_line_content": "        param->shape(), [&](const Shape& subshape, const ShapeIndex& index) {",
          "content_same": false
        },
        {
          "line": 415,
          "old_api": "shape",
          "new_api": "has_sharding",
          "old_text": "param->shape()",
          "new_text": "param->has_sharding()",
          "old_line_content": "                                param->sharding().AsShapeTree(param->shape()));",
          "new_line_content": "          if (cross_partition_spmd_ && param->has_sharding()) {",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": "HloReplication::UniqueOnAllDevices()",
          "new_api": "shape",
          "old_text": "HloReplication::UniqueOnAllDevices()",
          "new_text": "param->shape()",
          "old_line_content": "                    : HloReplication::UniqueOnAllDevices();",
          "new_line_content": "                                param->sharding().AsShapeTree(param->shape()));",
          "content_same": false
        },
        {
          "line": 438,
          "old_api": "OkStatus",
          "new_api": "HloReplication::UniqueOnAllDevices()",
          "old_text": "OkStatus()",
          "new_text": "HloReplication::UniqueOnAllDevices()",
          "old_line_content": "          return OkStatus();",
          "new_line_content": "                  HloReplication::UniqueOnAllDevices();",
          "content_same": false
        },
        {
          "line": 445,
          "old_api": "OkStatus",
          "new_api": "std::move(shape_tree)",
          "old_text": "OkStatus()",
          "new_text": "std::move(shape_tree)",
          "old_line_content": "  return OkStatus();",
          "new_line_content": "    hlo_replication_[param] = std::move(shape_tree);",
          "content_same": false
        },
        {
          "line": 454,
          "old_api": "element",
          "new_api": "find",
          "old_text": "it->second.element(index).IsReplicatedOnAllDevices()",
          "new_text": "hlo_replication_.find(inst)",
          "old_line_content": "  return it->second.element(index).IsReplicatedOnAllDevices();",
          "new_line_content": "  auto it = hlo_replication_.find(inst);",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": "name",
          "new_api": "find",
          "old_text": "inst->name()",
          "new_text": "hlo_replication_.find(inst)",
          "old_line_content": "  VLOG(5) << \"HloInstructionIsReplicatedAt is called on \" << inst->name()",
          "new_line_content": "  auto it = hlo_replication_.find(inst);",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": "ToString",
          "new_api": "end",
          "old_text": "index.ToString()",
          "new_text": "hlo_replication_.end()",
          "old_line_content": "          << \", index: \" << index.ToString()",
          "new_line_content": "  if (it == hlo_replication_.end()) {",
          "content_same": false
        },
        {
          "line": 468,
          "old_api": "element",
          "new_api": "name",
          "old_text": "it->second.element(index).IsReplicatedOnAllDevices()",
          "new_text": "inst->name()",
          "old_line_content": "    return it->second.element(index).IsReplicatedOnAllDevices();",
          "new_line_content": "  VLOG(5) << \"HloInstructionIsReplicatedAt is called on \" << inst->name()",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": "resize",
          "new_api": "std::max(max_device_id, device_id)",
          "old_text": "device_set_root.resize(max_device_id + 1)",
          "new_text": "std::max(max_device_id, device_id)",
          "old_line_content": "  device_set_root.resize(max_device_id + 1);",
          "new_line_content": "      max_device_id = std::max(max_device_id, device_id);",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": "push_back",
          "new_api": "size",
          "old_text": "value_to_device_set[new_value].push_back(device_id)",
          "new_text": "device_set_root_.size()",
          "old_line_content": "            value_to_device_set[new_value].push_back(device_id);",
          "new_line_content": "          size_t num_devices = device_set_root_.size();",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": "ReplicatedOnAllDevices",
          "new_api": "push_back",
          "old_text": "ReplicatedOnAllDevices()",
          "new_text": "value_to_device_set[new_value].push_back(device_id)",
          "old_line_content": "            return ReplicatedOnAllDevices();",
          "new_line_content": "            value_to_device_set[new_value].push_back(device_id);",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": "push_back",
          "new_api": "ReplicatedOnAllDevices",
          "old_text": "device_sets.push_back(\n                  absl::Span<const int64_t>(value_and_device_set.second))",
          "new_text": "ReplicatedOnAllDevices()",
          "old_line_content": "              device_sets.push_back(",
          "new_line_content": "            return ReplicatedOnAllDevices();",
          "content_same": false
        },
        {
          "line": 585,
          "old_api": "absl::Span<const int64_t>(value_and_device_set.second)",
          "new_api": "size",
          "old_text": "absl::Span<const int64_t>(value_and_device_set.second)",
          "new_text": "value_to_device_set.size()",
          "old_line_content": "                  absl::Span<const int64_t>(value_and_device_set.second));",
          "new_line_content": "          } else if (value_to_device_set.size() < num_devices) {",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": "UniqueOnAllDevices",
          "new_api": "absl::Span<const int64_t>(value_and_device_set.second)",
          "old_text": "UniqueOnAllDevices()",
          "new_text": "absl::Span<const int64_t>(value_and_device_set.second)",
          "old_line_content": "            return UniqueOnAllDevices();",
          "new_line_content": "                  absl::Span<const int64_t>(value_and_device_set.second));",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 514,
          "old_api": null,
          "new_api": "ComputeHloReplication",
          "old_text": null,
          "new_text": "analysis->ComputeHloReplication()",
          "old_line_content": "HloReplicationAnalysis::HloReplication::HloReplication()",
          "new_line_content": "  TF_RETURN_IF_ERROR(analysis->ComputeHloReplication());",
          "content_same": false
        },
        {
          "line": 525,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "device_set_root.end()",
          "old_line_content": "HloReplicationAnalysis::HloReplication",
          "new_line_content": "      device_set_root_(device_set_root.begin(), device_set_root.end()) {",
          "content_same": false
        },
        {
          "line": 526,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "device_set_root_.empty()",
          "old_line_content": "HloReplicationAnalysis::HloReplication::ReplicatedOnAllDevices() {",
          "new_line_content": "  CHECK(state == State::kPartiallyReplicated || device_set_root_.empty());",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": null,
          "new_api": "HloReplication",
          "old_text": null,
          "new_text": "HloReplication(State::kReplicatedOnAllDevices, {})",
          "old_line_content": "HloReplicationAnalysis::HloReplication::UniqueOnAllDevices() {",
          "new_line_content": "  return HloReplication(State::kReplicatedOnAllDevices, {});",
          "content_same": false
        },
        {
          "line": 536,
          "old_api": null,
          "new_api": "HloReplication",
          "old_text": null,
          "new_text": "HloReplication(State::kUniqueOnAllDevices, {})",
          "old_line_content": "HloReplicationAnalysis::HloReplication::PartiallyReplicated(",
          "new_line_content": "  return HloReplication(State::kUniqueOnAllDevices, {});",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "device_set_root.resize(max_device_id + 1)",
          "old_line_content": "      device_set_root[device_id] = min_device_id;",
          "new_line_content": "  device_set_root.resize(max_device_id + 1);",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": null,
          "new_api": "absl::c_min_element(device_set)",
          "old_text": null,
          "new_text": "absl::c_min_element(device_set)",
          "old_line_content": "  }",
          "new_line_content": "    int64_t min_device_id = *absl::c_min_element(device_set);",
          "content_same": false
        },
        {
          "line": 556,
          "old_api": null,
          "new_api": "HloReplication",
          "old_text": null,
          "new_text": "HloReplication(State::kPartiallyReplicated, device_set_root)",
          "old_line_content": "HloReplicationAnalysis::HloReplication::Merge(",
          "new_line_content": "  return HloReplication(State::kPartiallyReplicated, device_set_root);",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "value_to_device_set.size()",
          "old_line_content": "            std::vector<absl::Span<const int64_t>> device_sets;",
          "new_line_content": "          CHECK_LE(value_to_device_set.size(), num_devices);",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "value_to_device_set.size()",
          "old_line_content": "            for (const auto& value_and_device_set : value_to_device_set) {",
          "new_line_content": "          if (value_to_device_set.size() == 1) {",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "device_sets.push_back(\n                  absl::Span<const int64_t>(value_and_device_set.second))",
          "old_line_content": "          } else {",
          "new_line_content": "              device_sets.push_back(",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": null,
          "new_api": "PartiallyReplicated",
          "old_text": null,
          "new_text": "PartiallyReplicated(device_sets)",
          "old_line_content": "        }",
          "new_line_content": "            return PartiallyReplicated(device_sets);",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": null,
          "new_api": "UniqueOnAllDevices",
          "old_text": null,
          "new_text": "UniqueOnAllDevices()",
          "old_line_content": "    }",
          "new_line_content": "            return UniqueOnAllDevices();",
          "content_same": false
        },
        {
          "line": 606,
          "old_api": null,
          "new_api": "absl::c_equal(device_set_root_, other.device_set_root_)",
          "old_text": null,
          "new_text": "absl::c_equal(device_set_root_, other.device_set_root_)",
          "old_line_content": "  return state_ == State::kReplicatedOnAllDevices;",
          "new_line_content": "  return absl::c_equal(device_set_root_, other.device_set_root_);",
          "content_same": false
        },
        {
          "line": 103,
          "old_api": null,
          "new_api": "replica_groups",
          "old_text": null,
          "new_text": "hlo->replica_groups()",
          "old_line_content": "          absl::flat_hash_set<int64_t> visited_replicas;",
          "new_line_content": "        for (const auto& group : hlo->replica_groups()) {",
          "content_same": false
        },
        {
          "line": 105,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "visited_replicas.clear()",
          "old_line_content": "            int64_t rid = id / num_partitions;",
          "new_line_content": "          visited_replicas.clear();",
          "content_same": false
        },
        {
          "line": 106,
          "old_api": null,
          "new_api": "replica_ids",
          "old_text": null,
          "new_text": "group.replica_ids().size()",
          "old_line_content": "            int64_t pid = id % num_partitions;",
          "new_line_content": "          visited_replicas.reserve(group.replica_ids().size());",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "device_ids.empty()",
          "old_line_content": "}",
          "new_line_content": "  if (device_ids.empty()) return true;",
          "content_same": false
        },
        {
          "line": 620,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "absl::c_all_of(device_ids, [this, &device_ids](int device_id) {\n    return device_set_root_[device_id] == device_set_root_[device_ids.front()];\n  })",
          "old_line_content": "",
          "new_line_content": "  return absl::c_all_of(device_ids, [this, &device_ids](int device_id) {",
          "content_same": false
        },
        {
          "line": 621,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "device_ids.front()",
          "old_line_content": "std::string HloReplicationAnalysis::HloReplication::ToString() const {",
          "new_line_content": "    return device_set_root_[device_id] == device_set_root_[device_ids.front()];",
          "content_same": false
        },
        {
          "line": 112,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "visited_replicas.insert(rid)",
          "old_line_content": "          replicated_across_replicas &=",
          "new_line_content": "            visited_replicas.insert(rid);",
          "content_same": false
        },
        {
          "line": 115,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "visited_partitions.size()",
          "old_line_content": "        }",
          "new_line_content": "              visited_partitions.size() == num_partitions;",
          "content_same": false
        },
        {
          "line": 117,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "visited_replicas.size()",
          "old_line_content": "            (!cross_partition_spmd && replicated_across_replicas)) {",
          "new_line_content": "              visited_replicas.size() ==",
          "content_same": false
        },
        {
          "line": 632,
          "old_api": null,
          "new_api": "absl::StrCat(\"PartiallyReplicated{\",\n                          absl::StrJoin(device_set_root_, \",\"), \"}\")",
          "old_text": null,
          "new_text": "absl::StrCat(\"PartiallyReplicated{\",\n                          absl::StrJoin(device_set_root_, \",\"), \"}\")",
          "old_line_content": "",
          "new_line_content": "      return absl::StrCat(\"PartiallyReplicated{\",",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": null,
          "new_api": "absl::StrJoin(device_set_root_, \",\")",
          "old_text": null,
          "new_text": "absl::StrJoin(device_set_root_, \",\")",
          "old_line_content": "}  // namespace xla",
          "new_line_content": "                          absl::StrJoin(device_set_root_, \",\"), \"}\");",
          "content_same": false
        },
        {
          "line": 122,
          "old_api": null,
          "new_api": "HloReplication::ReplicatedOnAllDevices()",
          "old_text": null,
          "new_text": "HloReplication::ReplicatedOnAllDevices()",
          "old_line_content": "      }",
          "new_line_content": "          return HloReplication::ReplicatedOnAllDevices();",
          "content_same": false
        },
        {
          "line": 128,
          "old_api": null,
          "new_api": "HloReplication::ReplicatedOnAllDevices()",
          "old_text": null,
          "new_text": "HloReplication::ReplicatedOnAllDevices()",
          "old_line_content": "      } else {",
          "new_line_content": "        return HloReplication::ReplicatedOnAllDevices();",
          "content_same": false
        },
        {
          "line": 130,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "hlo->replica_groups().size()",
          "old_line_content": "      }",
          "new_line_content": "      if (hlo->replica_groups().empty() || hlo->replica_groups().size() == 1) {",
          "content_same": false
        },
        {
          "line": 131,
          "old_api": null,
          "new_api": "HloReplication::ReplicatedOnAllDevices()",
          "old_text": null,
          "new_text": "HloReplication::ReplicatedOnAllDevices()",
          "old_line_content": "    }",
          "new_line_content": "        return HloReplication::ReplicatedOnAllDevices();",
          "content_same": false
        },
        {
          "line": 137,
          "old_api": null,
          "new_api": "HasSideEffectNoRecurse",
          "old_text": null,
          "new_text": "hlo->HasSideEffectNoRecurse()",
          "old_line_content": "    // ReplicaId returns the same value for all partitions in each replica.",
          "new_line_content": "  if (hlo->HasSideEffectNoRecurse()) {",
          "content_same": false
        },
        {
          "line": 140,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "hlo->opcode()",
          "old_line_content": "  }",
          "new_line_content": "  if (hlo->opcode() == HloOpcode::kReplicaId) {",
          "content_same": false
        },
        {
          "line": 142,
          "old_api": null,
          "new_api": "HloReplication::ReplicatedOnAllDevices()",
          "old_text": null,
          "new_text": "HloReplication::ReplicatedOnAllDevices()",
          "old_line_content": "    // PartitionId returns the same value for all replicas in each partition.",
          "new_line_content": "    return cross_partition_spmd ? HloReplication::ReplicatedOnAllDevices()",
          "content_same": false
        },
        {
          "line": 145,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "hlo->opcode()",
          "old_line_content": "  }",
          "new_line_content": "  if (hlo->opcode() == HloOpcode::kPartitionId) {",
          "content_same": false
        },
        {
          "line": 148,
          "old_api": null,
          "new_api": "HloReplication::ReplicatedOnAllDevices()",
          "old_text": null,
          "new_text": "HloReplication::ReplicatedOnAllDevices()",
          "old_line_content": "    // Parameters should have been processed.",
          "new_line_content": "                                : HloReplication::ReplicatedOnAllDevices();",
          "content_same": false
        },
        {
          "line": 151,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "hlo->opcode()",
          "old_line_content": "  }",
          "new_line_content": "  if (hlo->opcode() == HloOpcode::kParameter) {",
          "content_same": false
        },
        {
          "line": 154,
          "old_api": null,
          "new_api": "element",
          "old_text": null,
          "new_text": "it->second.element(index)",
          "old_line_content": "    // The HLO is already marked as non-replicated.",
          "new_line_content": "    return it->second.element(index);",
          "content_same": false
        },
        {
          "line": 156,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "hlo_replication.end()",
          "old_line_content": "  }",
          "new_line_content": "  if (it != hlo_replication.end() &&",
          "content_same": false
        },
        {
          "line": 157,
          "old_api": null,
          "new_api": "element",
          "old_text": null,
          "new_text": "it->second.element(index).IsUniqueOnAllDevices()",
          "old_line_content": "",
          "new_line_content": "      it->second.element(index).IsUniqueOnAllDevices()) {",
          "content_same": false
        },
        {
          "line": 167,
          "old_api": null,
          "new_api": "custom_call_target",
          "old_text": null,
          "new_text": "hlo->custom_call_target()",
          "old_line_content": "  }",
          "new_line_content": "      (hlo->custom_call_target() == \"X64SplitLow\" ||",
          "content_same": false
        },
        {
          "line": 168,
          "old_api": null,
          "new_api": "custom_call_target",
          "old_text": null,
          "new_text": "hlo->custom_call_target()",
          "old_line_content": "",
          "new_line_content": "       hlo->custom_call_target() == \"X64SplitHigh\" ||",
          "content_same": false
        },
        {
          "line": 169,
          "old_api": null,
          "new_api": "custom_call_target",
          "old_text": null,
          "new_text": "hlo->custom_call_target()",
          "old_line_content": "  // Pattern-match and process cases where the HLO is partially replicated.",
          "new_line_content": "       hlo->custom_call_target() == \"X64Combine\")) {",
          "content_same": false
        },
        {
          "line": 170,
          "old_api": null,
          "new_api": "merge_operand_replication",
          "old_text": null,
          "new_text": "merge_operand_replication(hlo)",
          "old_line_content": "  if (support_partial_replication) {",
          "new_line_content": "    return merge_operand_replication(hlo);",
          "content_same": false
        },
        {
          "line": 179,
          "old_api": null,
          "new_api": "dynamic_slice_sizes",
          "old_text": null,
          "new_text": "hlo->dynamic_slice_sizes()",
          "old_line_content": "          ((cross_partition_spmd &&",
          "new_line_content": "          hlo->dynamic_slice_sizes()[0] == 1 &&",
          "content_same": false
        },
        {
          "line": 181,
          "old_api": null,
          "new_api": "rank",
          "old_text": null,
          "new_text": "ds_buffer->shape().rank()",
          "old_line_content": "           (!cross_partition_spmd &&",
          "new_line_content": "          ds_buffer->shape().rank() == 1 &&",
          "content_same": false
        },
        {
          "line": 184,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "hlo->operand(1)->opcode()",
          "old_line_content": "        int64_t num_devices = cross_partition_spmd",
          "new_line_content": "            hlo->operand(1)->opcode() == HloOpcode::kPartitionId) ||",
          "content_same": false
        },
        {
          "line": 187,
          "old_api": null,
          "new_api": "GetModule",
          "old_text": null,
          "new_text": "hlo->GetModule()",
          "old_line_content": "        absl::flat_hash_map<int64_t, std::vector<int64_t>> value_to_device_set;",
          "new_line_content": "        const HloModule* hlo_module = hlo->GetModule();",
          "content_same": false
        },
        {
          "line": 189,
          "old_api": null,
          "new_api": "num_partitions",
          "old_text": null,
          "new_text": "hlo_module->config().num_partitions()",
          "old_line_content": "          std::optional<int64_t> value =",
          "new_line_content": "                                  ? hlo_module->config().num_partitions()",
          "content_same": false
        },
        {
          "line": 194,
          "old_api": null,
          "new_api": "GetIntegralAsS64",
          "old_text": null,
          "new_text": "ds_buffer->literal().GetIntegralAsS64({device_id})",
          "old_line_content": "        for (const auto& value_and_device_set : value_to_device_set) {",
          "new_line_content": "              ds_buffer->literal().GetIntegralAsS64({device_id});",
          "content_same": false
        },
        {
          "line": 199,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "device_sets.push_back(\n              absl::Span<const int64_t>(value_and_device_set.second))",
          "old_line_content": "      }",
          "new_line_content": "          device_sets.push_back(",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": null,
          "new_api": "absl::Span<const int64_t>(value_and_device_set.second)",
          "old_text": null,
          "new_text": "absl::Span<const int64_t>(value_and_device_set.second)",
          "old_line_content": "    }",
          "new_line_content": "              absl::Span<const int64_t>(value_and_device_set.second));",
          "content_same": false
        },
        {
          "line": 202,
          "old_api": null,
          "new_api": "HloReplication::PartiallyReplicated(device_sets)",
          "old_text": null,
          "new_text": "HloReplication::PartiallyReplicated(device_sets)",
          "old_line_content": "",
          "new_line_content": "        return HloReplication::PartiallyReplicated(device_sets);",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "hlo->opcode()",
          "old_line_content": "  }",
          "new_line_content": "      hlo->opcode() == HloOpcode::kDynamicUpdateSlice ||  //",
          "content_same": false
        },
        {
          "line": 225,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "hlo->opcode()",
          "old_line_content": "}",
          "new_line_content": "      hlo->opcode() == HloOpcode::kCopy) {",
          "content_same": false
        },
        {
          "line": 226,
          "old_api": null,
          "new_api": "merge_operand_replication",
          "old_text": null,
          "new_text": "merge_operand_replication(hlo)",
          "old_line_content": "",
          "new_line_content": "    return merge_operand_replication(hlo);",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": null,
          "new_api": "HloReplication::UniqueOnAllDevices()",
          "old_text": null,
          "new_text": "HloReplication::UniqueOnAllDevices()",
          "old_line_content": "    const HloComputation* computation, bool mark_everything_not_replicated) {",
          "new_line_content": "  return HloReplication::UniqueOnAllDevices();",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": null,
          "new_api": "MakeInstructionPostOrder",
          "old_text": null,
          "new_text": "computation->MakeInstructionPostOrder()",
          "old_line_content": "        [&](ShapeTree<HloReplication>&& to_combine,",
          "new_line_content": "  for (HloInstruction* inst : computation->MakeInstructionPostOrder()) {",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "hlo_replication_.find(dest)",
          "old_line_content": "          }",
          "new_line_content": "          auto it = hlo_replication_.find(dest);",
          "content_same": false
        },
        {
          "line": 241,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "hlo_replication_.end()",
          "old_line_content": "          bool updated = false;",
          "new_line_content": "          if (it == hlo_replication_.end()) {",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": null,
          "new_api": "element",
          "old_text": null,
          "new_text": "to_combine.element(index)",
          "old_line_content": "                }",
          "new_line_content": "                    element->Merge(to_combine.element(index));",
          "content_same": false
        },
        {
          "line": 250,
          "old_api": null,
          "new_api": "Equal",
          "old_text": null,
          "new_text": "element->Equal(new_replication)",
          "old_line_content": "              });",
          "new_line_content": "                if (!element->Equal(new_replication)) {",
          "content_same": false
        },
        {
          "line": 251,
          "old_api": null,
          "new_api": "std::move(new_replication)",
          "old_text": null,
          "new_text": "std::move(new_replication)",
          "old_line_content": "          return updated;",
          "new_line_content": "                  *element = std::move(new_replication);",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": null,
          "new_api": "assign_or_combine_shapetree",
          "old_text": null,
          "new_text": "assign_or_combine_shapetree(\n          ShapeTree<HloReplication>(source_it->second), dest)",
          "old_line_content": "    // explicitly check mark_everything_not_replicated because if it is set, the",
          "new_line_content": "      return assign_or_combine_shapetree(",
          "content_same": false
        },
        {
          "line": 266,
          "old_api": null,
          "new_api": "ShapeTree<HloReplication>(source_it->second)",
          "old_text": null,
          "new_text": "ShapeTree<HloReplication>(source_it->second)",
          "old_line_content": "    // operands should already be marked as not replicated.",
          "new_line_content": "          ShapeTree<HloReplication>(source_it->second), dest);",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "inst->opcode()",
          "old_line_content": "        // First, propagate the input's and body root's shape trees to the",
          "new_line_content": "    if (inst->opcode() == HloOpcode::kWhile) {",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": null,
          "new_api": "while_body",
          "old_text": null,
          "new_text": "inst->while_body()->root_instruction()",
          "old_line_content": "        updated |=",
          "new_line_content": "            inst->while_body()->root_instruction(),",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": null,
          "new_api": "while_body",
          "old_text": null,
          "new_text": "inst->while_body()->parameter_instruction(0)",
          "old_line_content": "        // Compute the condition.",
          "new_line_content": "            inst->operand(0), inst->while_body()->parameter_instruction(0));",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": null,
          "new_api": "while_body",
          "old_text": null,
          "new_text": "inst->while_body()->parameter_instruction(0)",
          "old_line_content": "        // Compute the body. If the condition is not replicated, the while body",
          "new_line_content": "                                inst->while_body()->parameter_instruction(0));",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": null,
          "new_api": "while_body",
          "old_text": null,
          "new_text": "inst->while_body()",
          "old_line_content": "        }",
          "new_line_content": "              inst->while_body(), /*mark_everything_not_replicated=*/true);",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": null,
          "new_api": "while_body",
          "old_text": null,
          "new_text": "ComputeHloReplicationOnComputation(\n              inst->while_body(), mark_everything_not_replicated)",
          "old_line_content": "          break;",
          "new_line_content": "          updated |= ComputeHloReplicationOnComputation(",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": null,
          "new_api": "while_body",
          "old_text": null,
          "new_text": "inst->while_body()",
          "old_line_content": "        }",
          "new_line_content": "              inst->while_body(), mark_everything_not_replicated);",
          "content_same": false
        },
        {
          "line": 314,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "inst->called_computations().front()",
          "old_line_content": "      }",
          "new_line_content": "      auto called = inst->called_computations().front();",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "inst->operand(i)",
          "old_line_content": "          called, mark_everything_not_replicated);",
          "new_line_content": "        changed |= propagate_shapetree(inst->operand(i),",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": null,
          "new_api": "ComputeHloReplicationOnComputation",
          "old_text": null,
          "new_text": "ComputeHloReplicationOnComputation(\n          called, mark_everything_not_replicated)",
          "old_line_content": "      // Propagate inputs' shape trees to the called computations' parameters.",
          "new_line_content": "      changed |= ComputeHloReplicationOnComputation(",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "inst->called_computations().size()",
          "old_line_content": "      }",
          "new_line_content": "      for (int64_t i = 0; i < inst->called_computations().size(); ++i) {",
          "content_same": false
        },
        {
          "line": 325,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "propagate_shapetree(\n            inst->operand(i + 1),\n            inst->called_computations()[i]->parameter_instruction(0))",
          "old_line_content": "      // If the condition is not replicated, the conditional result should be",
          "new_line_content": "        changed |= propagate_shapetree(",
          "content_same": false
        },
        {
          "line": 326,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "inst->operand(i + 1)",
          "old_line_content": "      // different across replicas.",
          "new_line_content": "            inst->operand(i + 1),",
          "content_same": false
        },
        {
          "line": 334,
          "old_api": null,
          "new_api": "called_computations",
          "old_text": null,
          "new_text": "inst->called_computations()",
          "old_line_content": "        }",
          "new_line_content": "        for (auto called : inst->called_computations()) {",
          "content_same": false
        },
        {
          "line": 339,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "assign_or_combine_shapetree(\n            ShapeTree<HloReplication>(inst->shape(),\n                                      HloReplication::UniqueOnAllDevices()),\n            inst)",
          "old_line_content": "      } else {",
          "new_line_content": "        changed |= assign_or_combine_shapetree(",
          "content_same": false
        },
        {
          "line": 344,
          "old_api": null,
          "new_api": "called_computations",
          "old_text": null,
          "new_text": "inst->called_computations()",
          "old_line_content": "        }",
          "new_line_content": "        for (auto called : inst->called_computations()) {",
          "content_same": false
        },
        {
          "line": 345,
          "old_api": null,
          "new_api": "ComputeHloReplicationOnComputation",
          "old_text": null,
          "new_text": "ComputeHloReplicationOnComputation(\n              called, mark_everything_not_replicated)",
          "old_line_content": "      }",
          "new_line_content": "          changed |= ComputeHloReplicationOnComputation(",
          "content_same": false
        },
        {
          "line": 347,
          "old_api": null,
          "new_api": "root_instruction",
          "old_text": null,
          "new_text": "called->root_instruction()",
          "old_line_content": "      ShapeTree<HloReplication> shape_tree(",
          "new_line_content": "          changed |= propagate_shapetree(called->root_instruction(), inst);",
          "content_same": false
        },
        {
          "line": 354,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "inst->operand(i)",
          "old_line_content": "      ShapeTree<HloReplication> shape_tree(",
          "new_line_content": "        shape_tree.CopySubtreeFrom(hlo_replication_[inst->operand(i)], {}, {i});",
          "content_same": false
        },
        {
          "line": 360,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "inst->operand(0)",
          "old_line_content": "      ShapeTree<HloReplication> shape_tree(",
          "new_line_content": "      shape_tree.CopySubtreeFrom(hlo_replication_[inst->operand(0)],",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": null,
          "new_api": "HloReplication::UniqueOnAllDevices()",
          "old_text": null,
          "new_text": "HloReplication::UniqueOnAllDevices()",
          "old_line_content": "            [&sharding](const ShapeIndex& index, HloReplication* data) {",
          "new_line_content": "          inst->shape(), HloReplication::UniqueOnAllDevices());",
          "content_same": false
        },
        {
          "line": 370,
          "old_api": null,
          "new_api": "element",
          "old_text": null,
          "new_text": "sharding.element(index).IsReplicated()",
          "old_line_content": "      }",
          "new_line_content": "              *data = sharding.element(index).IsReplicated()",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": null,
          "new_api": "HloReplication::UniqueOnAllDevices()",
          "old_text": null,
          "new_text": "HloReplication::UniqueOnAllDevices()",
          "old_line_content": "    } else {",
          "new_line_content": "                          : HloReplication::UniqueOnAllDevices();",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "assign_or_combine_shapetree(\n            ShapeTree<HloReplication>(inst->shape(),\n                                      HloReplication::UniqueOnAllDevices()),\n            inst)",
          "old_line_content": "      } else {",
          "new_line_content": "        changed |= assign_or_combine_shapetree(",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "inst->shape()",
          "old_line_content": "        ShapeTree<HloReplication> shape_tree(",
          "new_line_content": "            ShapeTree<HloReplication>(inst->shape(),",
          "content_same": false
        },
        {
          "line": 385,
          "old_api": null,
          "new_api": "mutable_element",
          "old_text": null,
          "new_text": "ShapeUtil::ForEachSubshape(\n            inst->shape(), [&](const Shape& subshape, const ShapeIndex& index) {\n              *shape_tree.mutable_element(index) =\n                  DetermineHloInstructionIsReplicated(\n                      inst, index, cross_partition_spmd_, hlo_replication_,\n                      support_partial_replication_);\n            })",
          "old_line_content": "                      inst, index, cross_partition_spmd_, hlo_replication_,",
          "new_line_content": "        ShapeUtil::ForEachSubshape(",
          "content_same": false
        },
        {
          "line": 386,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "inst->shape()",
          "old_line_content": "                      support_partial_replication_);",
          "new_line_content": "            inst->shape(), [&](const Shape& subshape, const ShapeIndex& index) {",
          "content_same": false
        },
        {
          "line": 387,
          "old_api": null,
          "new_api": "mutable_element",
          "old_text": null,
          "new_text": "shape_tree.mutable_element(index)",
          "old_line_content": "            });",
          "new_line_content": "              *shape_tree.mutable_element(index) =",
          "content_same": false
        },
        {
          "line": 392,
          "old_api": null,
          "new_api": "std::move(shape_tree)",
          "old_text": null,
          "new_text": "std::move(shape_tree)",
          "old_line_content": "  return changed;",
          "new_line_content": "        changed |= assign_or_combine_shapetree(std::move(shape_tree), inst);",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": null,
          "new_api": "parameter_instruction",
          "old_text": null,
          "new_text": "entry->parameter_instruction(i)",
          "old_line_content": "    int leaf_index = 0;",
          "new_line_content": "    auto param = entry->parameter_instruction(i);",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": null,
          "new_api": "AsShapeTree",
          "old_text": null,
          "new_text": "ShapeUtil::ForEachSubshapeWithStatus(\n        param->shape(), [&](const Shape& subshape, const ShapeIndex& index) {\n          if (!ShapeUtil::IsLeafIndex(param->shape(), index)) {\n            return OkStatus();\n          }\n          if (cross_partition_spmd_ && param->has_sharding()) {\n            // In cross-partition spmd mode, set parameter replication status\n            // based on the parameter's sharding.\n            TF_ASSIGN_OR_RETURN(auto sharding_tree,\n                                param->sharding().AsShapeTree(param->shape()));\n            *shape_tree.mutable_element(index) =\n                sharding_tree.element(index).IsReplicated()\n                    ? HloReplication::ReplicatedOnAllDevices()\n                    : HloReplication::UniqueOnAllDevices();\n          }\n          if (replication) {\n            // If parameter replication status has been set explicitly, use that\n            // instead.\n            if (!cross_partition_spmd_ && (*replication)[leaf_index]) {\n              // Setting parameter replication status for replicas in\n              // non cross-partition spmd mode.\n              *shape_tree.mutable_element(index) =\n                  HloReplication::ReplicatedOnAllDevices();\n            }\n            if (cross_partition_spmd_ && !(*replication)[leaf_index]) {\n              // Setting paramemter replication status for partitions in\n              // cross-partition spmd mode.\n              *shape_tree.mutable_element(index) =\n                  HloReplication::UniqueOnAllDevices();\n            }\n            ++leaf_index;\n          }\n          return OkStatus();\n        })",
          "old_line_content": "          }",
          "new_line_content": "    Status status = ShapeUtil::ForEachSubshapeWithStatus(",
          "content_same": false
        },
        {
          "line": 412,
          "old_api": null,
          "new_api": "shape",
          "old_text": null,
          "new_text": "param->shape()",
          "old_line_content": "            // In cross-partition spmd mode, set parameter replication status",
          "new_line_content": "          if (!ShapeUtil::IsLeafIndex(param->shape(), index)) {",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": null,
          "new_api": "OkStatus",
          "old_text": null,
          "new_text": "OkStatus()",
          "old_line_content": "            // based on the parameter's sharding.",
          "new_line_content": "            return OkStatus();",
          "content_same": false
        },
        {
          "line": 420,
          "old_api": null,
          "new_api": "mutable_element",
          "old_text": null,
          "new_text": "shape_tree.mutable_element(index)",
          "old_line_content": "          }",
          "new_line_content": "            *shape_tree.mutable_element(index) =",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": null,
          "new_api": "element",
          "old_text": null,
          "new_text": "sharding_tree.element(index).IsReplicated()",
          "old_line_content": "          if (replication) {",
          "new_line_content": "                sharding_tree.element(index).IsReplicated()",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": null,
          "new_api": "HloReplication::ReplicatedOnAllDevices()",
          "old_text": null,
          "new_text": "HloReplication::ReplicatedOnAllDevices()",
          "old_line_content": "            // If parameter replication status has been set explicitly, use that",
          "new_line_content": "                    ? HloReplication::ReplicatedOnAllDevices()",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": null,
          "new_api": "HloReplication::UniqueOnAllDevices()",
          "old_text": null,
          "new_text": "HloReplication::UniqueOnAllDevices()",
          "old_line_content": "            // instead.",
          "new_line_content": "                    : HloReplication::UniqueOnAllDevices();",
          "content_same": false
        },
        {
          "line": 431,
          "old_api": null,
          "new_api": "mutable_element",
          "old_text": null,
          "new_text": "shape_tree.mutable_element(index)",
          "old_line_content": "              // Setting paramemter replication status for partitions in",
          "new_line_content": "              *shape_tree.mutable_element(index) =",
          "content_same": false
        },
        {
          "line": 432,
          "old_api": null,
          "new_api": "HloReplication::ReplicatedOnAllDevices()",
          "old_text": null,
          "new_text": "HloReplication::ReplicatedOnAllDevices()",
          "old_line_content": "              // cross-partition spmd mode.",
          "new_line_content": "                  HloReplication::ReplicatedOnAllDevices();",
          "content_same": false
        },
        {
          "line": 437,
          "old_api": null,
          "new_api": "mutable_element",
          "old_text": null,
          "new_text": "shape_tree.mutable_element(index)",
          "old_line_content": "          }",
          "new_line_content": "              *shape_tree.mutable_element(index) =",
          "content_same": false
        },
        {
          "line": 442,
          "old_api": null,
          "new_api": "OkStatus",
          "old_text": null,
          "new_text": "OkStatus()",
          "old_line_content": "  }",
          "new_line_content": "          return OkStatus();",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": null,
          "new_api": "TF_RETURN_IF_ERROR",
          "old_text": null,
          "new_text": "TF_RETURN_IF_ERROR(status)",
          "old_line_content": "                                     /*mark_everything_not_replicated=*/false);",
          "new_line_content": "    TF_RETURN_IF_ERROR(status);",
          "content_same": false
        },
        {
          "line": 447,
          "old_api": null,
          "new_api": "ComputeHloReplicationOnComputation",
          "old_text": null,
          "new_text": "ComputeHloReplicationOnComputation(entry,\n                                     /*mark_everything_not_replicated=*/false)",
          "old_line_content": "",
          "new_line_content": "  ComputeHloReplicationOnComputation(entry,",
          "content_same": false
        },
        {
          "line": 449,
          "old_api": null,
          "new_api": "OkStatus",
          "old_text": null,
          "new_text": "OkStatus()",
          "old_line_content": "    const HloInstruction* inst, const ShapeIndex& index) const {",
          "new_line_content": "  return OkStatus();",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "hlo_replication_.end()",
          "old_line_content": "}",
          "new_line_content": "  if (it == hlo_replication_.end()) {",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": null,
          "new_api": "element",
          "old_text": null,
          "new_text": "it->second.element(index).IsReplicatedOnAllDevices()",
          "old_line_content": "    const HloInstruction* inst, const ShapeIndex& index,",
          "new_line_content": "  return it->second.element(index).IsReplicatedOnAllDevices();",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "index.ToString()",
          "old_line_content": "  }",
          "new_line_content": "          << \", index: \" << index.ToString()",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "replica_groups.empty()",
          "old_line_content": "    return true;",
          "new_line_content": "  if (replica_groups.empty()) {",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": null,
          "new_api": "element",
          "old_text": null,
          "new_text": "it->second.element(index).IsReplicatedOnAllDevices()",
          "old_line_content": "  }",
          "new_line_content": "    return it->second.element(index).IsReplicatedOnAllDevices();",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": null,
          "new_api": "element",
          "old_text": null,
          "new_text": "it->second.element(index).IsReplicatedOnAllDevices()",
          "old_line_content": "    return false;",
          "new_line_content": "  if (it->second.element(index).IsReplicatedOnAllDevices()) {",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": null,
          "new_api": "element",
          "old_text": null,
          "new_text": "it->second.element(index).IsReplicatedWithinSubgroup(\n            replica_group.replica_ids())",
          "old_line_content": "  }",
          "new_line_content": "    if (!it->second.element(index).IsReplicatedWithinSubgroup(",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": null,
          "new_api": "replica_ids",
          "old_text": null,
          "new_text": "replica_group.replica_ids()",
          "old_line_content": "  return true;",
          "new_line_content": "            replica_group.replica_ids())) {",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": null,
          "new_api": "Run",
          "old_text": null,
          "new_text": "Run(module, cross_partition_spmd, &empty)",
          "old_line_content": "HloReplicationAnalysis::Run(const HloModule* module, bool cross_partition_spmd,",
          "new_line_content": "  return Run(module, cross_partition_spmd, &empty);",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": null,
          "new_api": "absl::WrapUnique(new HloReplicationAnalysis(\n      module, cross_partition_spmd, loops_known_with_same_iterations,\n      /*support_partial_replication=*/false))",
          "old_text": null,
          "new_text": "absl::WrapUnique(new HloReplicationAnalysis(\n      module, cross_partition_spmd, loops_known_with_same_iterations,\n      /*support_partial_replication=*/false))",
          "old_line_content": "  return analysis;",
          "new_line_content": "  auto analysis = absl::WrapUnique(new HloReplicationAnalysis(",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": null,
          "new_api": "ComputeHloReplication",
          "old_text": null,
          "new_text": "analysis->ComputeHloReplication()",
          "old_line_content": "/* static */ absl::StatusOr<std::unique_ptr<HloReplicationAnalysis>>",
          "new_line_content": "  TF_RETURN_IF_ERROR(analysis->ComputeHloReplication());",
          "content_same": false
        },
        {
          "line": 511,
          "old_api": null,
          "new_api": "absl::WrapUnique(\n      new HloReplicationAnalysis(module, cross_partition_spmd, &empty,\n                                 /*support_partial_replication=*/true))",
          "old_text": null,
          "new_text": "absl::WrapUnique(\n      new HloReplicationAnalysis(module, cross_partition_spmd, &empty,\n                                 /*support_partial_replication=*/true))",
          "old_line_content": "  return analysis;",
          "new_line_content": "  auto analysis = absl::WrapUnique(",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 521,
          "old_api": "end",
          "new_api": null,
          "old_text": "device_set_root.end()",
          "new_text": null,
          "old_line_content": "      device_set_root_(device_set_root.begin(), device_set_root.end()) {",
          "new_line_content": "HloReplicationAnalysis::HloReplication::HloReplication(",
          "content_same": false
        },
        {
          "line": 522,
          "old_api": "empty",
          "new_api": null,
          "old_text": "device_set_root_.empty()",
          "new_text": null,
          "old_line_content": "  CHECK(state == State::kPartiallyReplicated || device_set_root_.empty());",
          "new_line_content": "    HloReplicationAnalysis::HloReplication::State state,",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": "HloReplication",
          "new_api": null,
          "old_text": "HloReplication(State::kReplicatedOnAllDevices, {})",
          "new_text": null,
          "old_line_content": "  return HloReplication(State::kReplicatedOnAllDevices, {});",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": "HloReplication",
          "new_api": null,
          "old_text": "HloReplication(State::kUniqueOnAllDevices, {})",
          "new_text": null,
          "old_line_content": "  return HloReplication(State::kUniqueOnAllDevices, {});",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": "std::max(max_device_id, device_id)",
          "new_api": null,
          "old_text": "std::max(max_device_id, device_id)",
          "new_text": null,
          "old_line_content": "      max_device_id = std::max(max_device_id, device_id);",
          "new_line_content": "    absl::Span<const absl::Span<const int64_t>> device_sets) {",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": "absl::c_min_element(device_set)",
          "new_api": null,
          "old_text": "absl::c_min_element(device_set)",
          "new_text": null,
          "old_line_content": "    int64_t min_device_id = *absl::c_min_element(device_set);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": "HloReplication",
          "new_api": null,
          "old_text": "HloReplication(State::kPartiallyReplicated, device_set_root)",
          "new_text": null,
          "old_line_content": "  return HloReplication(State::kPartiallyReplicated, device_set_root);",
          "new_line_content": "    for (int64_t device_id : device_set) {",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": "size",
          "new_api": null,
          "old_text": "device_set_root_.size()",
          "new_text": null,
          "old_line_content": "          size_t num_devices = device_set_root_.size();",
          "new_line_content": "          return other;",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": "size",
          "new_api": null,
          "old_text": "value_to_device_set.size()",
          "new_text": null,
          "old_line_content": "          CHECK_LE(value_to_device_set.size(), num_devices);",
          "new_line_content": "            int64_t new_value = device_set_root_[device_id] * num_devices +",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": "size",
          "new_api": null,
          "old_text": "value_to_device_set.size()",
          "new_text": null,
          "old_line_content": "          if (value_to_device_set.size() == 1) {",
          "new_line_content": "                                other.device_set_root_[device_id];",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": "size",
          "new_api": null,
          "old_text": "value_to_device_set.size()",
          "new_text": null,
          "old_line_content": "          } else if (value_to_device_set.size() < num_devices) {",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": "PartiallyReplicated",
          "new_api": null,
          "old_text": "PartiallyReplicated(device_sets)",
          "new_text": null,
          "old_line_content": "            return PartiallyReplicated(device_sets);",
          "new_line_content": "            for (const auto& value_and_device_set : value_to_device_set) {",
          "content_same": false
        },
        {
          "line": 602,
          "old_api": "absl::c_equal(device_set_root_, other.device_set_root_)",
          "new_api": null,
          "old_text": "absl::c_equal(device_set_root_, other.device_set_root_)",
          "new_text": null,
          "old_line_content": "  return absl::c_equal(device_set_root_, other.device_set_root_);",
          "new_line_content": "    const HloReplication& other) const {",
          "content_same": false
        },
        {
          "line": 101,
          "old_api": "replica_groups",
          "new_api": null,
          "old_text": "hlo->replica_groups()",
          "new_text": null,
          "old_line_content": "        for (const auto& group : hlo->replica_groups()) {",
          "new_line_content": "        absl::flat_hash_set<int64_t> visited_partitions;",
          "content_same": false
        },
        {
          "line": 615,
          "old_api": "empty",
          "new_api": null,
          "old_text": "device_ids.empty()",
          "new_text": null,
          "old_line_content": "  if (device_ids.empty()) return true;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": "front",
          "new_api": null,
          "old_text": "absl::c_all_of(device_ids, [this, &device_ids](int device_id) {\n    return device_set_root_[device_id] == device_set_root_[device_ids.front()];\n  })",
          "new_text": null,
          "old_line_content": "  return absl::c_all_of(device_ids, [this, &device_ids](int device_id) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 617,
          "old_api": "front",
          "new_api": null,
          "old_text": "device_ids.front()",
          "new_text": null,
          "old_line_content": "    return device_set_root_[device_id] == device_set_root_[device_ids.front()];",
          "new_line_content": "bool HloReplicationAnalysis::HloReplication::IsReplicatedWithinSubgroup(",
          "content_same": false
        },
        {
          "line": 113,
          "old_api": "size",
          "new_api": null,
          "old_text": "visited_replicas.size()",
          "new_text": null,
          "old_line_content": "              visited_replicas.size() ==",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 114,
          "old_api": "replica_count",
          "new_api": null,
          "old_text": "hlo->GetModule()->config().replica_count()",
          "new_text": null,
          "old_line_content": "              hlo->GetModule()->config().replica_count();",
          "new_line_content": "          replicated_across_partitions &=",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": "absl::StrCat(\"PartiallyReplicated{\",\n                          absl::StrJoin(device_set_root_, \",\"), \"}\")",
          "new_api": null,
          "old_text": "absl::StrCat(\"PartiallyReplicated{\",\n                          absl::StrJoin(device_set_root_, \",\"), \"}\")",
          "new_text": null,
          "old_line_content": "      return absl::StrCat(\"PartiallyReplicated{\",",
          "new_line_content": "      return \"ReplicatedOnAllDevices\";",
          "content_same": false
        },
        {
          "line": 629,
          "old_api": "absl::StrJoin(device_set_root_, \",\")",
          "new_api": null,
          "old_text": "absl::StrJoin(device_set_root_, \",\")",
          "new_text": null,
          "old_line_content": "                          absl::StrJoin(device_set_root_, \",\"), \"}\");",
          "new_line_content": "    case State::kUniqueOnAllDevices:",
          "content_same": false
        },
        {
          "line": 120,
          "old_api": "HloReplication::UniqueOnAllDevices()",
          "new_api": null,
          "old_text": "HloReplication::UniqueOnAllDevices()",
          "new_text": null,
          "old_line_content": "          return HloReplication::UniqueOnAllDevices();",
          "new_line_content": "        if ((cross_partition_spmd && replicated_across_partitions) ||",
          "content_same": false
        },
        {
          "line": 126,
          "old_api": "size",
          "new_api": null,
          "old_text": "hlo->replica_groups().size()",
          "new_text": null,
          "old_line_content": "      if (hlo->replica_groups().empty() || hlo->replica_groups().size() == 1) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 127,
          "old_api": "HloReplication::ReplicatedOnAllDevices()",
          "new_api": null,
          "old_text": "HloReplication::ReplicatedOnAllDevices()",
          "new_text": null,
          "old_line_content": "        return HloReplication::ReplicatedOnAllDevices();",
          "new_line_content": "      if (cross_partition_spmd) {",
          "content_same": false
        },
        {
          "line": 129,
          "old_api": "HloReplication::UniqueOnAllDevices()",
          "new_api": null,
          "old_text": "HloReplication::UniqueOnAllDevices()",
          "new_text": null,
          "old_line_content": "        return HloReplication::UniqueOnAllDevices();",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 134,
          "old_api": "HloReplication::UniqueOnAllDevices()",
          "new_api": null,
          "old_text": "HloReplication::UniqueOnAllDevices()",
          "new_text": null,
          "old_line_content": "    return HloReplication::UniqueOnAllDevices();",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 136,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "hlo->opcode()",
          "new_text": null,
          "old_line_content": "  if (hlo->opcode() == HloOpcode::kReplicaId) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 139,
          "old_api": "HloReplication::UniqueOnAllDevices()",
          "new_api": null,
          "old_text": "HloReplication::UniqueOnAllDevices()",
          "new_text": null,
          "old_line_content": "                                : HloReplication::UniqueOnAllDevices();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 141,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "hlo->opcode()",
          "new_text": null,
          "old_line_content": "  if (hlo->opcode() == HloOpcode::kPartitionId) {",
          "new_line_content": "    // ReplicaId returns the same value for all partitions in each replica.",
          "content_same": false
        },
        {
          "line": 144,
          "old_api": "HloReplication::ReplicatedOnAllDevices()",
          "new_api": null,
          "old_text": "HloReplication::ReplicatedOnAllDevices()",
          "new_text": null,
          "old_line_content": "                                : HloReplication::ReplicatedOnAllDevices();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 146,
          "old_api": "find",
          "new_api": null,
          "old_text": "hlo_replication.find(hlo)",
          "new_text": null,
          "old_line_content": "  auto it = hlo_replication.find(hlo);",
          "new_line_content": "    // PartitionId returns the same value for all replicas in each partition.",
          "content_same": false
        },
        {
          "line": 149,
          "old_api": "end",
          "new_api": null,
          "old_text": "hlo_replication.end()",
          "new_text": null,
          "old_line_content": "    CHECK(it != hlo_replication.end());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 152,
          "old_api": "end",
          "new_api": null,
          "old_text": "hlo_replication.end()",
          "new_text": null,
          "old_line_content": "  if (it != hlo_replication.end() &&",
          "new_line_content": "    // Parameters should have been processed.",
          "content_same": false
        },
        {
          "line": 155,
          "old_api": "element",
          "new_api": null,
          "old_text": "it->second.element(index)",
          "new_text": null,
          "old_line_content": "    return it->second.element(index);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 158,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "hlo->opcode()",
          "new_text": null,
          "old_line_content": "  if (hlo->opcode() == HloOpcode::kConstant) {",
          "new_line_content": "    // The HLO is already marked as non-replicated.",
          "content_same": false
        },
        {
          "line": 164,
          "old_api": "custom_call_target",
          "new_api": null,
          "old_text": "hlo->custom_call_target()",
          "new_text": null,
          "old_line_content": "       hlo->custom_call_target() == \"X64SplitHigh\" ||",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 165,
          "old_api": "custom_call_target",
          "new_api": null,
          "old_text": "hlo->custom_call_target()",
          "new_text": null,
          "old_line_content": "       hlo->custom_call_target() == \"X64Combine\")) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 172,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "hlo->opcode()",
          "new_text": null,
          "old_line_content": "    if (hlo->opcode() == HloOpcode::kDynamicSlice) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 173,
          "old_api": "operand",
          "new_api": null,
          "old_text": "hlo->operand(0)",
          "new_text": null,
          "old_line_content": "      const HloInstruction* ds_buffer = hlo->operand(0);",
          "new_line_content": "  // Pattern-match and process cases where the HLO is partially replicated.",
          "content_same": false
        },
        {
          "line": 174,
          "old_api": "size",
          "new_api": null,
          "old_text": "hlo->dynamic_slice_sizes().size()",
          "new_text": null,
          "old_line_content": "      if (hlo->dynamic_slice_sizes().size() == 1 &&",
          "new_line_content": "  if (support_partial_replication) {",
          "content_same": false
        },
        {
          "line": 175,
          "old_api": "dynamic_slice_sizes",
          "new_api": null,
          "old_text": "hlo->dynamic_slice_sizes()",
          "new_text": null,
          "old_line_content": "          hlo->dynamic_slice_sizes()[0] == 1 &&",
          "new_line_content": "    // Below is a very specific pattern to match the SPMD pipeline case.",
          "content_same": false
        },
        {
          "line": 183,
          "old_api": "GetModule",
          "new_api": null,
          "old_text": "hlo->GetModule()",
          "new_text": null,
          "old_line_content": "        const HloModule* hlo_module = hlo->GetModule();",
          "new_line_content": "          ((cross_partition_spmd &&",
          "content_same": false
        },
        {
          "line": 185,
          "old_api": "num_partitions",
          "new_api": null,
          "old_text": "hlo_module->config().num_partitions()",
          "new_text": null,
          "old_line_content": "                                  ? hlo_module->config().num_partitions()",
          "new_line_content": "           (!cross_partition_spmd &&",
          "content_same": false
        },
        {
          "line": 191,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "value_to_device_set[*value].push_back(device_id)",
          "new_text": null,
          "old_line_content": "          value_to_device_set[*value].push_back(device_id);",
          "new_line_content": "        absl::flat_hash_map<int64_t, std::vector<int64_t>> value_to_device_set;",
          "content_same": false
        },
        {
          "line": 196,
          "old_api": "absl::Span<const int64_t>(value_and_device_set.second)",
          "new_api": null,
          "old_text": "absl::Span<const int64_t>(value_and_device_set.second)",
          "new_text": null,
          "old_line_content": "              absl::Span<const int64_t>(value_and_device_set.second));",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 198,
          "old_api": "HloReplication::PartiallyReplicated(device_sets)",
          "new_api": null,
          "old_text": "HloReplication::PartiallyReplicated(device_sets)",
          "new_text": null,
          "old_line_content": "        return HloReplication::PartiallyReplicated(device_sets);",
          "new_line_content": "        for (const auto& value_and_device_set : value_to_device_set) {",
          "content_same": false
        },
        {
          "line": 203,
          "old_api": "IsElementwise",
          "new_api": null,
          "old_text": "hlo->IsElementwise()",
          "new_text": null,
          "old_line_content": "  if (hlo->IsElementwise() ||                             //",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "hlo->opcode()",
          "new_text": null,
          "old_line_content": "      hlo->opcode() == HloOpcode::kConcatenate ||         //",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 205,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "hlo->opcode()",
          "new_text": null,
          "old_line_content": "      hlo->opcode() == HloOpcode::kConvolution ||         //",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 206,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "hlo->opcode()",
          "new_text": null,
          "old_line_content": "      hlo->opcode() == HloOpcode::kDot ||                 //",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": "MakeInstructionPostOrder",
          "new_api": null,
          "old_text": "computation->MakeInstructionPostOrder()",
          "new_text": null,
          "old_line_content": "  for (HloInstruction* inst : computation->MakeInstructionPostOrder()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": "find",
          "new_api": null,
          "old_text": "hlo_replication_.find(dest)",
          "new_text": null,
          "old_line_content": "          auto it = hlo_replication_.find(dest);",
          "new_line_content": "    // it with the existing one by and'ing them. Returns if anything is updated.",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": "end",
          "new_api": null,
          "old_text": "hlo_replication_.end()",
          "new_text": null,
          "old_line_content": "          if (it == hlo_replication_.end()) {",
          "new_line_content": "    auto assign_or_combine_shapetree =",
          "content_same": false
        },
        {
          "line": 238,
          "old_api": "std::move(to_combine)",
          "new_api": null,
          "old_text": "std::move(to_combine)",
          "new_text": null,
          "old_line_content": "            hlo_replication_[dest] = std::move(to_combine);",
          "new_line_content": "        [&](ShapeTree<HloReplication>&& to_combine,",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": "element",
          "new_api": null,
          "old_text": "to_combine.element(index)",
          "new_text": null,
          "old_line_content": "                    element->Merge(to_combine.element(index));",
          "new_line_content": "          bool updated = false;",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": "std::move(new_replication)",
          "new_api": null,
          "old_text": "std::move(new_replication)",
          "new_text": null,
          "old_line_content": "                  *element = std::move(new_replication);",
          "new_line_content": "              [&](const ShapeIndex& index, HloReplication* element) {",
          "content_same": false
        },
        {
          "line": 257,
          "old_api": "find",
          "new_api": null,
          "old_text": "hlo_replication_.find(source)",
          "new_text": null,
          "old_line_content": "      auto source_it = hlo_replication_.find(source);",
          "new_line_content": "    // Assigns or combines source's shape tree to dest. Returns if anything is",
          "content_same": false
        },
        {
          "line": 258,
          "old_api": "end",
          "new_api": null,
          "old_text": "hlo_replication_.end()",
          "new_text": null,
          "old_line_content": "      if (source_it == hlo_replication_.end()) {",
          "new_line_content": "    // updated.",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "inst->opcode()",
          "new_text": null,
          "old_line_content": "    if (inst->opcode() == HloOpcode::kWhile) {",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": "operand",
          "new_api": null,
          "old_text": "propagate_shapetree(\n            inst->operand(0),\n            inst->while_condition()->parameter_instruction(0))",
          "new_text": null,
          "old_line_content": "        bool updated = propagate_shapetree(",
          "new_line_content": "      // multiple times until a fixed point is reached.",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": "operand",
          "new_api": null,
          "old_text": "inst->operand(0)",
          "new_text": null,
          "old_line_content": "            inst->operand(0),",
          "new_line_content": "      while (true) {",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": "while_condition",
          "new_api": null,
          "old_text": "inst->while_condition()->parameter_instruction(0)",
          "new_text": null,
          "old_line_content": "            inst->while_condition()->parameter_instruction(0));",
          "new_line_content": "        // First, propagate the input's and body root's shape trees to the",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": "while_body",
          "new_api": null,
          "old_text": "propagate_shapetree(\n            inst->while_body()->root_instruction(),\n            inst->while_condition()->parameter_instruction(0))",
          "new_text": null,
          "old_line_content": "        updated |= propagate_shapetree(",
          "new_line_content": "        // parameters of the body and condition.",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": "while_condition",
          "new_api": null,
          "old_text": "ComputeHloReplicationOnComputation(\n            inst->while_condition(), mark_everything_not_replicated)",
          "new_text": null,
          "old_line_content": "        updated |= ComputeHloReplicationOnComputation(",
          "new_line_content": "        updated |=",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": "while_body",
          "new_api": null,
          "old_text": "ComputeHloReplicationOnComputation(\n              inst->while_body(), mark_everything_not_replicated)",
          "new_text": null,
          "old_line_content": "          updated |= ComputeHloReplicationOnComputation(",
          "new_line_content": "                 .IsReplicatedOnAllDevices()) {",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": "operand",
          "new_api": null,
          "old_text": "inst->operand(0)",
          "new_text": null,
          "old_line_content": "      changed |= propagate_shapetree(inst->operand(0), inst);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": "while_body",
          "new_api": null,
          "old_text": "inst->while_body()->root_instruction()",
          "new_text": null,
          "old_line_content": "          propagate_shapetree(inst->while_body()->root_instruction(), inst);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 308,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "inst->opcode()",
          "new_text": null,
          "old_line_content": "    } else if (inst->opcode() == HloOpcode::kCall ||",
          "new_line_content": "      // Propagate the input's and body root's shape trees to the while HLO.",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": "front",
          "new_api": null,
          "old_text": "inst->called_computations().front()",
          "new_text": null,
          "old_line_content": "      auto called = inst->called_computations().front();",
          "new_line_content": "      changed |=",
          "content_same": false
        },
        {
          "line": 318,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "inst->opcode()",
          "new_text": null,
          "old_line_content": "    } else if (inst->opcode() == HloOpcode::kConditional) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 320,
          "old_api": "size",
          "new_api": null,
          "old_text": "inst->called_computations().size()",
          "new_text": null,
          "old_line_content": "      for (int64_t i = 0; i < inst->called_computations().size(); ++i) {",
          "new_line_content": "          called, mark_everything_not_replicated);",
          "content_same": false
        },
        {
          "line": 323,
          "old_api": "called_computations",
          "new_api": null,
          "old_text": "inst->called_computations()[i]->parameter_instruction(0)",
          "new_text": null,
          "old_line_content": "            inst->called_computations()[i]->parameter_instruction(0));",
          "new_line_content": "      // Propagate inputs' shape trees to the called computations' parameters.",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": "called_computations",
          "new_api": null,
          "old_text": "inst->called_computations()",
          "new_text": null,
          "old_line_content": "        for (auto called : inst->called_computations()) {",
          "new_line_content": "      // different across replicas.",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": "shape",
          "new_api": null,
          "old_text": "inst->shape()",
          "new_text": null,
          "old_line_content": "            ShapeTree<HloReplication>(inst->shape(),",
          "new_line_content": "              called,",
          "content_same": false
        },
        {
          "line": 337,
          "old_api": "HloReplication::UniqueOnAllDevices()",
          "new_api": null,
          "old_text": "HloReplication::UniqueOnAllDevices()",
          "new_text": null,
          "old_line_content": "                                      HloReplication::UniqueOnAllDevices()),",
          "new_line_content": "              /*mark_everything_not_replicated=*/true);",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": "root_instruction",
          "new_api": null,
          "old_text": "called->root_instruction()",
          "new_text": null,
          "old_line_content": "          changed |= propagate_shapetree(called->root_instruction(), inst);",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 346,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "inst->opcode()",
          "new_text": null,
          "old_line_content": "    } else if (inst->opcode() == HloOpcode::kTuple) {",
          "new_line_content": "              called, mark_everything_not_replicated);",
          "content_same": false
        },
        {
          "line": 348,
          "old_api": "HloReplication::ReplicatedOnAllDevices()",
          "new_api": null,
          "old_text": "HloReplication::ReplicatedOnAllDevices()",
          "new_text": null,
          "old_line_content": "          inst->shape(), HloReplication::ReplicatedOnAllDevices());",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": "operand_count",
          "new_api": null,
          "old_text": "inst->operand_count()",
          "new_text": null,
          "old_line_content": "      for (int64_t i = 0; i < inst->operand_count(); ++i) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 355,
          "old_api": "HloReplication::ReplicatedOnAllDevices()",
          "new_api": null,
          "old_text": "HloReplication::ReplicatedOnAllDevices()",
          "new_text": null,
          "old_line_content": "          inst->shape(), HloReplication::ReplicatedOnAllDevices());",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 358,
          "old_api": "std::move(shape_tree)",
          "new_api": null,
          "old_text": "std::move(shape_tree)",
          "new_text": null,
          "old_line_content": "      changed |= assign_or_combine_shapetree(std::move(shape_tree), inst);",
          "new_line_content": "      ShapeTree<HloReplication> shape_tree(",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": "ForEachMutableElement",
          "new_api": null,
          "old_text": "shape_tree.ForEachMutableElement(\n            [&sharding](const ShapeIndex& index, HloReplication* data) {\n              *data = sharding.element(index).IsReplicated()\n                          ? HloReplication::ReplicatedOnAllDevices()\n                          : HloReplication::UniqueOnAllDevices();\n            })",
          "new_text": null,
          "old_line_content": "        shape_tree.ForEachMutableElement(",
          "new_line_content": "      ShapeTree<HloReplication> shape_tree(",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": "shape",
          "new_api": null,
          "old_text": "assign_or_combine_shapetree(\n            ShapeTree<HloReplication>(inst->shape(),\n                                      HloReplication::UniqueOnAllDevices()),\n            inst)",
          "new_text": null,
          "old_line_content": "        changed |= assign_or_combine_shapetree(",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 376,
          "old_api": "HloReplication::UniqueOnAllDevices()",
          "new_api": null,
          "old_text": "HloReplication::UniqueOnAllDevices()",
          "new_text": null,
          "old_line_content": "                                      HloReplication::UniqueOnAllDevices()),",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": "mutable_element",
          "new_api": null,
          "old_text": "ShapeUtil::ForEachSubshape(\n            inst->shape(), [&](const Shape& subshape, const ShapeIndex& index) {\n              *shape_tree.mutable_element(index) =\n                  DetermineHloInstructionIsReplicated(\n                      inst, index, cross_partition_spmd_, hlo_replication_,\n                      support_partial_replication_);\n            })",
          "new_text": null,
          "old_line_content": "        ShapeUtil::ForEachSubshape(",
          "new_line_content": "            inst);",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": "shape",
          "new_api": null,
          "old_text": "inst->shape()",
          "new_text": null,
          "old_line_content": "            inst->shape(), [&](const Shape& subshape, const ShapeIndex& index) {",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": "mutable_element",
          "new_api": null,
          "old_text": "shape_tree.mutable_element(index)",
          "new_text": null,
          "old_line_content": "              *shape_tree.mutable_element(index) =",
          "new_line_content": "        ShapeTree<HloReplication> shape_tree(",
          "content_same": false
        },
        {
          "line": 399,
          "old_api": "entry_computation",
          "new_api": null,
          "old_text": "module_->entry_computation()",
          "new_text": null,
          "old_line_content": "  auto entry = module_->entry_computation();",
          "new_line_content": "Status HloReplicationAnalysis::ComputeHloReplication() {",
          "content_same": false
        },
        {
          "line": 400,
          "old_api": "num_parameters",
          "new_api": null,
          "old_text": "entry->num_parameters()",
          "new_text": null,
          "old_line_content": "  for (int i = 0; i < entry->num_parameters(); ++i) {",
          "new_line_content": "  // Add entry parameters to the above sets according to user annotation.",
          "content_same": false
        },
        {
          "line": 401,
          "old_api": "parameter_instruction",
          "new_api": null,
          "old_text": "entry->parameter_instruction(i)",
          "new_text": null,
          "old_line_content": "    auto param = entry->parameter_instruction(i);",
          "new_line_content": "  // Replicated modules read from `parameter_replicated_at_leaf_buffers` whereas",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": "shape",
          "new_api": null,
          "old_text": "param->shape()",
          "new_text": null,
          "old_line_content": "    ShapeTree<HloReplication> shape_tree(param->shape(),",
          "new_line_content": "  // SPMD partitioned modules read from HloSharding attributes.",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": "OkStatus",
          "new_api": null,
          "old_text": "OkStatus()",
          "new_text": null,
          "old_line_content": "            return OkStatus();",
          "new_line_content": "    int leaf_index = 0;",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": "mutable_element",
          "new_api": null,
          "old_text": "shape_tree.mutable_element(index)",
          "new_text": null,
          "old_line_content": "            *shape_tree.mutable_element(index) =",
          "new_line_content": "            // In cross-partition spmd mode, set parameter replication status",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": "element",
          "new_api": null,
          "old_text": "sharding_tree.element(index).IsReplicated()",
          "new_text": null,
          "old_line_content": "                sharding_tree.element(index).IsReplicated()",
          "new_line_content": "            // based on the parameter's sharding.",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": "HloReplication::ReplicatedOnAllDevices()",
          "new_api": null,
          "old_text": "HloReplication::ReplicatedOnAllDevices()",
          "new_text": null,
          "old_line_content": "                    ? HloReplication::ReplicatedOnAllDevices()",
          "new_line_content": "            TF_ASSIGN_OR_RETURN(auto sharding_tree,",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": "mutable_element",
          "new_api": null,
          "old_text": "shape_tree.mutable_element(index)",
          "new_text": null,
          "old_line_content": "              *shape_tree.mutable_element(index) =",
          "new_line_content": "            // instead.",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": "HloReplication::ReplicatedOnAllDevices()",
          "new_api": null,
          "old_text": "HloReplication::ReplicatedOnAllDevices()",
          "new_text": null,
          "old_line_content": "                  HloReplication::ReplicatedOnAllDevices();",
          "new_line_content": "            if (!cross_partition_spmd_ && (*replication)[leaf_index]) {",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": "mutable_element",
          "new_api": null,
          "old_text": "shape_tree.mutable_element(index)",
          "new_text": null,
          "old_line_content": "              *shape_tree.mutable_element(index) =",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": "HloReplication::UniqueOnAllDevices()",
          "new_api": null,
          "old_text": "HloReplication::UniqueOnAllDevices()",
          "new_text": null,
          "old_line_content": "                  HloReplication::UniqueOnAllDevices();",
          "new_line_content": "            if (cross_partition_spmd_ && !(*replication)[leaf_index]) {",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": "TF_RETURN_IF_ERROR",
          "new_api": null,
          "old_text": "TF_RETURN_IF_ERROR(status)",
          "new_text": null,
          "old_line_content": "    TF_RETURN_IF_ERROR(status);",
          "new_line_content": "            ++leaf_index;",
          "content_same": false
        },
        {
          "line": 441,
          "old_api": "std::move(shape_tree)",
          "new_api": null,
          "old_text": "std::move(shape_tree)",
          "new_text": null,
          "old_line_content": "    hlo_replication_[param] = std::move(shape_tree);",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": "ComputeHloReplicationOnComputation",
          "new_api": null,
          "old_text": "ComputeHloReplicationOnComputation(entry,\n                                     /*mark_everything_not_replicated=*/false)",
          "new_text": null,
          "old_line_content": "  ComputeHloReplicationOnComputation(entry,",
          "new_line_content": "        });",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": "find",
          "new_api": null,
          "old_text": "hlo_replication_.find(inst)",
          "new_text": null,
          "old_line_content": "  auto it = hlo_replication_.find(inst);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": "end",
          "new_api": null,
          "old_text": "hlo_replication_.end()",
          "new_text": null,
          "old_line_content": "  if (it == hlo_replication_.end()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": "find",
          "new_api": null,
          "old_text": "hlo_replication_.find(inst)",
          "new_text": null,
          "old_line_content": "  auto it = hlo_replication_.find(inst);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 461,
          "old_api": "end",
          "new_api": null,
          "old_text": "hlo_replication_.end()",
          "new_text": null,
          "old_line_content": "  if (it == hlo_replication_.end()) {",
          "new_line_content": "bool HloReplicationAnalysis::HloInstructionIsReplicatedAt(",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": "element",
          "new_api": null,
          "old_text": "it->second.element(index).ToString()",
          "new_text": null,
          "old_line_content": "          << \", replication: \" << it->second.element(index).ToString();",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": "empty",
          "new_api": null,
          "old_text": "replica_groups.empty()",
          "new_text": null,
          "old_line_content": "  if (replica_groups.empty()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": "element",
          "new_api": null,
          "old_text": "it->second.element(index).IsUniqueOnAllDevices()",
          "new_text": null,
          "old_line_content": "  if (it->second.element(index).IsUniqueOnAllDevices()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 478,
          "old_api": "replica_ids",
          "new_api": null,
          "old_text": "replica_group.replica_ids()",
          "new_text": null,
          "old_line_content": "            replica_group.replica_ids())) {",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": "Run",
          "new_api": null,
          "old_text": "Run(module, cross_partition_spmd, &empty)",
          "new_text": null,
          "old_line_content": "  return Run(module, cross_partition_spmd, &empty);",
          "new_line_content": "/* static */ absl::StatusOr<std::unique_ptr<HloReplicationAnalysis>>",
          "content_same": false
        },
        {
          "line": 496,
          "old_api": "absl::WrapUnique(new HloReplicationAnalysis(\n      module, cross_partition_spmd, loops_known_with_same_iterations,\n      /*support_partial_replication=*/false))",
          "new_api": null,
          "old_text": "absl::WrapUnique(new HloReplicationAnalysis(\n      module, cross_partition_spmd, loops_known_with_same_iterations,\n      /*support_partial_replication=*/false))",
          "new_text": null,
          "old_line_content": "  auto analysis = absl::WrapUnique(new HloReplicationAnalysis(",
          "new_line_content": "/* static */ absl::StatusOr<std::unique_ptr<HloReplicationAnalysis>>",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": "ComputeHloReplication",
          "new_api": null,
          "old_text": "analysis->ComputeHloReplication()",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(analysis->ComputeHloReplication());",
          "new_line_content": "                                loops_known_with_same_iterations) {",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": "absl::WrapUnique(\n      new HloReplicationAnalysis(module, cross_partition_spmd, &empty,\n                                 /*support_partial_replication=*/true))",
          "new_api": null,
          "old_text": "absl::WrapUnique(\n      new HloReplicationAnalysis(module, cross_partition_spmd, &empty,\n                                 /*support_partial_replication=*/true))",
          "new_text": null,
          "old_line_content": "  auto analysis = absl::WrapUnique(",
          "new_line_content": "/* static */ absl::StatusOr<std::unique_ptr<HloReplicationAnalysis>>",
          "content_same": false
        },
        {
          "line": 510,
          "old_api": "ComputeHloReplication",
          "new_api": null,
          "old_text": "analysis->ComputeHloReplication()",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(analysis->ComputeHloReplication());",
          "new_line_content": "  const absl::flat_hash_set<const HloInstruction*> empty;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 86,
      "total_additions": 119,
      "total_deletions": 115,
      "total_api_changes": 320
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 7,
        "api_related_lines": 320,
        "non_api_lines": 1,
        "non_api_line_numbers": [
          102
        ]
      }
    },
    "api_calls_before": 324,
    "api_calls_after": 332,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 2,
      "total_diff_lines": 21
    }
  }
}