{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/6fa63f3079cc7becd444b09535533cd35a55c76d",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/6fa63f3079cc7becd444b09535533cd35a55c76d/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/6fa63f3079cc7becd444b09535533cd35a55c76d/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/6fa63f3079cc7becd444b09535533cd35a55c76d/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [],
      "additions": [],
      "deletions": [
        {
          "line": 4097,
          "api": "ShapeUtil::Compatible(*operand_shape, shape_with_layout)",
          "text": "ShapeUtil::Compatible(*operand_shape, shape_with_layout)",
          "line_content": "    if (!ShapeUtil::Compatible(*operand_shape, shape_with_layout)) {"
        },
        {
          "line": 4098,
          "api": "InvalidArgument",
          "text": "InvalidArgument(\n          \"SendToHost shape %s must be compatible with operand shape %s\",\n          ShapeUtil::HumanStringWithLayout(shape_with_layout),\n          ShapeUtil::HumanStringWithLayout(*operand_shape))",
          "line_content": "      return InvalidArgument("
        },
        {
          "line": 4100,
          "api": "ShapeUtil::HumanStringWithLayout(shape_with_layout)",
          "text": "ShapeUtil::HumanStringWithLayout(shape_with_layout)",
          "line_content": "          ShapeUtil::HumanStringWithLayout(shape_with_layout),"
        },
        {
          "line": 4101,
          "api": "ShapeUtil::HumanStringWithLayout(*operand_shape)",
          "text": "ShapeUtil::HumanStringWithLayout(*operand_shape)",
          "line_content": "          ShapeUtil::HumanStringWithLayout(*operand_shape));"
        },
        {
          "line": 4104,
          "api": "IsArray",
          "text": "operand_shape->IsArray()",
          "line_content": "    if (!operand_shape->IsArray()) {"
        },
        {
          "line": 4105,
          "api": "InvalidArgument",
          "text": "InvalidArgument(\"SendToHost only supports array shapes, shape: %s\",\n                             ShapeUtil::HumanString(*operand_shape))",
          "line_content": "      return InvalidArgument(\"SendToHost only supports array shapes, shape: %s\","
        },
        {
          "line": 4106,
          "api": "ShapeUtil::HumanString(*operand_shape)",
          "text": "ShapeUtil::HumanString(*operand_shape)",
          "line_content": "                             ShapeUtil::HumanString(*operand_shape));"
        },
        {
          "line": 4109,
          "api": "type",
          "text": "handle.type()",
          "line_content": "    if (handle.type() != ChannelHandle::DEVICE_TO_HOST) {"
        },
        {
          "line": 4110,
          "api": "InvalidArgument",
          "text": "InvalidArgument(\"SendToHost must use a device-to-host channel\")",
          "line_content": "      return InvalidArgument(\"SendToHost must use a device-to-host channel\");"
        },
        {
          "line": 4116,
          "api": "mutable_shape",
          "text": "send_instr.mutable_shape()",
          "line_content": "    *send_instr.mutable_shape() ="
        },
        {
          "line": 4117,
          "api": "ToProto",
          "text": "ShapeUtil::MakeTupleShape({shape_with_layout,\n                                   ShapeUtil::MakeShape(U32, {}),\n                                   ShapeUtil::MakeTokenShape()})\n            .ToProto()",
          "line_content": "        ShapeUtil::MakeTupleShape({shape_with_layout,"
        },
        {
          "line": 4118,
          "api": "ShapeUtil::MakeShape(U32, {})",
          "text": "ShapeUtil::MakeShape(U32, {})",
          "line_content": "                                   ShapeUtil::MakeShape(U32, {}),"
        },
        {
          "line": 4119,
          "api": "ShapeUtil::MakeTokenShape()",
          "text": "ShapeUtil::MakeTokenShape()",
          "line_content": "                                   ShapeUtil::MakeTokenShape()})"
        },
        {
          "line": 4121,
          "api": "handle",
          "text": "handle.handle()",
          "line_content": "    send_instr.set_channel_id(handle.handle());"
        },
        {
          "line": 4122,
          "api": "set_is_host_transfer",
          "text": "send_instr.set_is_host_transfer(true)",
          "line_content": "    send_instr.set_is_host_transfer(true);"
        },
        {
          "line": 4128,
          "api": "ToProto",
          "text": "ShapeUtil::MakeTokenShape().ToProto()",
          "line_content": "    *send_done_instr.mutable_shape() = ShapeUtil::MakeTokenShape().ToProto();"
        },
        {
          "line": 4129,
          "api": "handle",
          "text": "handle.handle()",
          "line_content": "    send_done_instr.set_channel_id(handle.handle());"
        },
        {
          "line": 4130,
          "api": "set_is_host_transfer",
          "text": "send_done_instr.set_is_host_transfer(true)",
          "line_content": "    send_done_instr.set_is_host_transfer(true);"
        },
        {
          "line": 4140,
          "api": "IsArray",
          "text": "ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    if (!LayoutUtil::HasLayout(shape)) {\n      return InvalidArgument(\"Shape passed to RecvFromHost must have a layout\");\n    }\n\n    // TODO(b/111544877): Support tuple shapes.\n    if (!shape.IsArray()) {\n      return InvalidArgument(\n          \"RecvFromHost only supports array shapes, shape: %s\",\n          ShapeUtil::HumanString(shape));\n    }\n\n    if (handle.type() != ChannelHandle::HOST_TO_DEVICE) {\n      return InvalidArgument(\"RecvFromHost must use a host-to-device channel\");\n    }\n\n    // Recv instruction produces a tuple of {receive buffer, U32 context,\n    // token}.\n    HloInstructionProto recv_instr;\n    *recv_instr.mutable_shape() =\n        ShapeUtil::MakeTupleShape(\n            {shape, ShapeUtil::MakeShape(U32, {}), ShapeUtil::MakeTokenShape()})\n            .ToProto();\n    recv_instr.set_channel_id(handle.handle());\n    recv_instr.set_is_host_transfer(true);\n    TF_ASSIGN_OR_RETURN(XlaOp recv, AddInstruction(std::move(recv_instr),\n                                                   HloOpcode::kRecv, {token}));\n\n    HloInstructionProto recv_done_instr;\n    *recv_done_instr.mutable_shape() =\n        ShapeUtil::MakeTupleShape({shape, ShapeUtil::MakeTokenShape()})\n            .ToProto();\n    recv_done_instr.set_channel_id(handle.handle());\n    recv_done_instr.set_is_host_transfer(true);\n    return AddInstruction(std::move(recv_done_instr), HloOpcode::kRecvDone,\n                          {recv});\n  })",
          "line_content": "  return ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 4141,
          "api": "LayoutUtil::HasLayout(shape)",
          "text": "LayoutUtil::HasLayout(shape)",
          "line_content": "    if (!LayoutUtil::HasLayout(shape)) {"
        },
        {
          "line": 4142,
          "api": "InvalidArgument",
          "text": "InvalidArgument(\"Shape passed to RecvFromHost must have a layout\")",
          "line_content": "      return InvalidArgument(\"Shape passed to RecvFromHost must have a layout\");"
        },
        {
          "line": 4146,
          "api": "IsArray",
          "text": "shape.IsArray()",
          "line_content": "    if (!shape.IsArray()) {"
        },
        {
          "line": 4147,
          "api": "InvalidArgument",
          "text": "InvalidArgument(\n          \"RecvFromHost only supports array shapes, shape: %s\",\n          ShapeUtil::HumanString(shape))",
          "line_content": "      return InvalidArgument("
        },
        {
          "line": 4149,
          "api": "ShapeUtil::HumanString(shape)",
          "text": "ShapeUtil::HumanString(shape)",
          "line_content": "          ShapeUtil::HumanString(shape));"
        },
        {
          "line": 4152,
          "api": "type",
          "text": "handle.type()",
          "line_content": "    if (handle.type() != ChannelHandle::HOST_TO_DEVICE) {"
        },
        {
          "line": 4153,
          "api": "InvalidArgument",
          "text": "InvalidArgument(\"RecvFromHost must use a host-to-device channel\")",
          "line_content": "      return InvalidArgument(\"RecvFromHost must use a host-to-device channel\");"
        },
        {
          "line": 4159,
          "api": "mutable_shape",
          "text": "recv_instr.mutable_shape()",
          "line_content": "    *recv_instr.mutable_shape() ="
        },
        {
          "line": 4160,
          "api": "ToProto",
          "text": "ShapeUtil::MakeTupleShape(\n            {shape, ShapeUtil::MakeShape(U32, {}), ShapeUtil::MakeTokenShape()})\n            .ToProto()",
          "line_content": "        ShapeUtil::MakeTupleShape("
        },
        {
          "line": 4161,
          "api": "ShapeUtil::MakeTokenShape()",
          "text": "ShapeUtil::MakeTokenShape()",
          "line_content": "            {shape, ShapeUtil::MakeShape(U32, {}), ShapeUtil::MakeTokenShape()})"
        },
        {
          "line": 4163,
          "api": "handle",
          "text": "handle.handle()",
          "line_content": "    recv_instr.set_channel_id(handle.handle());"
        },
        {
          "line": 4164,
          "api": "set_is_host_transfer",
          "text": "recv_instr.set_is_host_transfer(true)",
          "line_content": "    recv_instr.set_is_host_transfer(true);"
        },
        {
          "line": 4169,
          "api": "mutable_shape",
          "text": "recv_done_instr.mutable_shape()",
          "line_content": "    *recv_done_instr.mutable_shape() ="
        },
        {
          "line": 4170,
          "api": "ShapeUtil::MakeTokenShape()",
          "text": "ShapeUtil::MakeTokenShape()",
          "line_content": "        ShapeUtil::MakeTupleShape({shape, ShapeUtil::MakeTokenShape()})"
        },
        {
          "line": 4172,
          "api": "handle",
          "text": "handle.handle()",
          "line_content": "    recv_done_instr.set_channel_id(handle.handle());"
        },
        {
          "line": 4173,
          "api": "set_is_host_transfer",
          "text": "recv_done_instr.set_is_host_transfer(true)",
          "line_content": "    recv_done_instr.set_is_host_transfer(true);"
        },
        {
          "line": 4174,
          "api": "std::move(recv_done_instr)",
          "text": "std::move(recv_done_instr)",
          "line_content": "    return AddInstruction(std::move(recv_done_instr), HloOpcode::kRecvDone,"
        },
        {
          "line": 4180,
          "api": "mutable_shape",
          "text": "ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto instr;\n    TF_ASSIGN_OR_RETURN(const Shape* operand_shape, GetShapePtr(operand));\n    TF_ASSIGN_OR_RETURN(Shape shape, ShapeInference::InferGetDimensionSizeShape(\n                                         *operand_shape, dimension));\n    // Calling GetDimensionSize on a static dimension returns a constant\n    // instruction.\n    if (operand_shape->is_static_dimension(dimension)) {\n      return ConstantR0<int32_t>(this, operand_shape->dimensions(dimension));\n    }\n    *instr.mutable_shape() = shape.ToProto();\n    instr.add_dimensions(dimension);\n    return AddInstruction(std::move(instr), HloOpcode::kGetDimensionSize,\n                          {operand});\n  })",
          "line_content": "  return ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 85,
          "api": "rfind",
          "text": "name.rfind(separator)",
          "line_content": "  auto pos = name.rfind(separator);"
        },
        {
          "line": 86,
          "api": "CHECK_NE",
          "text": "CHECK_NE(pos, std::string::npos)",
          "line_content": "  CHECK_NE(pos, std::string::npos) << name;"
        },
        {
          "line": 87,
          "api": "substr",
          "text": "name.substr(0, pos)",
          "line_content": "  return name.substr(0, pos);"
        },
        {
          "line": 4187,
          "api": "is_static_dimension",
          "text": "operand_shape->is_static_dimension(dimension)",
          "line_content": "    if (operand_shape->is_static_dimension(dimension)) {"
        },
        {
          "line": 4188,
          "api": "dimensions",
          "text": "operand_shape->dimensions(dimension)",
          "line_content": "      return ConstantR0<int32_t>(this, operand_shape->dimensions(dimension));"
        },
        {
          "line": 94,
          "api": "StrCat",
          "text": "StrCat(base_name, separator_str, id)",
          "line_content": "  return StrCat(base_name, separator_str, id);"
        },
        {
          "line": 4190,
          "api": "ToProto",
          "text": "shape.ToProto()",
          "line_content": "    *instr.mutable_shape() = shape.ToProto();"
        },
        {
          "line": 4191,
          "api": "add_dimensions",
          "text": "instr.add_dimensions(dimension)",
          "line_content": "    instr.add_dimensions(dimension);"
        },
        {
          "line": 4192,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "    return AddInstruction(std::move(instr), HloOpcode::kGetDimensionSize,"
        },
        {
          "line": 102,
          "api": "set_id",
          "text": "entry->set_id(id)",
          "line_content": "  entry->set_id(id);"
        },
        {
          "line": 103,
          "api": "GetFullName",
          "text": "GetFullName(base_name, separator, id)",
          "line_content": "  entry->set_name(GetFullName(base_name, separator, id));"
        },
        {
          "line": 4198,
          "api": "set_dynamic_dimension",
          "text": "ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    TF_ASSIGN_OR_RETURN(const Shape* operand_shape, GetShapePtr(operand));\n\n    Shape shape = *operand_shape;\n    shape.set_dynamic_dimension(dimension, false);\n    // Setting an op's dynamic dimension to its static size removes the dynamic\n    // dimension.\n    XlaOp static_size =\n        ConstantR0<int32_t>(this, operand_shape->dimensions(dimension));\n    return SetDimensionSizeInternal(shape, operand, static_size, dimension);\n  })",
          "line_content": "  return ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 4202,
          "api": "set_dynamic_dimension",
          "text": "shape.set_dynamic_dimension(dimension, false)",
          "line_content": "    shape.set_dynamic_dimension(dimension, false);"
        },
        {
          "line": 107,
          "api": "opcode",
          "text": "instr_proto->opcode()",
          "line_content": "  HloOpcode opcode = StringToHloOpcode(instr_proto->opcode()).value();"
        },
        {
          "line": 109,
          "api": "custom_call_target",
          "text": "instr_proto->custom_call_target()",
          "line_content": "      instr_proto->custom_call_target() == \"SetBound\") {"
        },
        {
          "line": 4206,
          "api": "dimensions",
          "text": "operand_shape->dimensions(dimension)",
          "line_content": "        ConstantR0<int32_t>(this, operand_shape->dimensions(dimension));"
        },
        {
          "line": 4207,
          "api": "SetDimensionSizeInternal",
          "text": "SetDimensionSizeInternal(shape, operand, static_size, dimension)",
          "line_content": "    return SetDimensionSizeInternal(shape, operand, static_size, dimension);"
        },
        {
          "line": 4213,
          "api": "ReportErrorOrReturn",
          "text": "ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    TF_ASSIGN_OR_RETURN(const Shape* operand_shape, GetShapePtr(operand));\n    TF_ASSIGN_OR_RETURN(const Shape* val_shape, GetShapePtr(val));\n\n    TF_ASSIGN_OR_RETURN(Shape shape,\n                        ShapeInference::InferSetDimensionSizeShape(\n                            *operand_shape, *val_shape, dimension));\n    return SetDimensionSizeInternal(shape, operand, val, dimension);\n  })",
          "line_content": "  return ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 121,
          "api": "mutable_shape",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto instr;\n    *instr.mutable_shape() = shape.ToProto();\n    return builder->AddInstruction(std::move(instr), HloOpcode::kAddDependency,\n                                   {operand, token});\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 123,
          "api": "ToProto",
          "text": "shape.ToProto()",
          "line_content": "    *instr.mutable_shape() = shape.ToProto();"
        },
        {
          "line": 124,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "    return builder->AddInstruction(std::move(instr), HloOpcode::kAddDependency,"
        },
        {
          "line": 4220,
          "api": "SetDimensionSizeInternal",
          "text": "SetDimensionSizeInternal(shape, operand, val, dimension)",
          "line_content": "    return SetDimensionSizeInternal(shape, operand, val, dimension);"
        },
        {
          "line": 134,
          "api": "set_fusion_kind",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto instr;\n    instr.set_fusion_kind(std::string(fusion_kind));\n    if (!output_operand_aliasing.empty()) {\n      for (const auto& pair : output_operand_aliasing) {\n        auto aliasing = instr.add_output_operand_aliasing();\n        aliasing->set_operand_index(pair.second.first);\n        for (int64_t index : pair.second.second) {\n          aliasing->add_operand_shape_index(index);\n        }\n        for (int64_t index : pair.first) {\n          aliasing->add_output_shape_index(index);\n        }\n      }\n    }\n    std::vector<const Shape*> operand_shape_ptrs;\n    TF_ASSIGN_OR_RETURN(auto program_shape,\n                        fused_computation.GetProgramShape());\n    *instr.mutable_shape() = program_shape.result().ToProto();\n    builder->AddCalledComputation(fused_computation, &instr);\n    return builder->AddInstruction(std::move(instr), HloOpcode::kFusion,\n                                   operands);\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 136,
          "api": "std::string(fusion_kind)",
          "text": "std::string(fusion_kind)",
          "line_content": "    instr.set_fusion_kind(std::string(fusion_kind));"
        },
        {
          "line": 137,
          "api": "empty",
          "text": "output_operand_aliasing.empty()",
          "line_content": "    if (!output_operand_aliasing.empty()) {"
        },
        {
          "line": 139,
          "api": "add_output_operand_aliasing",
          "text": "instr.add_output_operand_aliasing()",
          "line_content": "        auto aliasing = instr.add_output_operand_aliasing();"
        },
        {
          "line": 140,
          "api": "set_operand_index",
          "text": "aliasing->set_operand_index(pair.second.first)",
          "line_content": "        aliasing->set_operand_index(pair.second.first);"
        },
        {
          "line": 4237,
          "api": "ToProto",
          "text": "shape.ToProto()",
          "line_content": "  *instr.mutable_shape() = shape.ToProto();"
        },
        {
          "line": 142,
          "api": "add_operand_shape_index",
          "text": "aliasing->add_operand_shape_index(index)",
          "line_content": "          aliasing->add_operand_shape_index(index);"
        },
        {
          "line": 4238,
          "api": "add_dimensions",
          "text": "instr.add_dimensions(dimension)",
          "line_content": "  instr.add_dimensions(dimension);"
        },
        {
          "line": 4239,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "  return AddInstruction(std::move(instr), HloOpcode::kSetDimensionSize,"
        },
        {
          "line": 145,
          "api": "add_output_shape_index",
          "text": "aliasing->add_output_shape_index(index)",
          "line_content": "          aliasing->add_output_shape_index(index);"
        },
        {
          "line": 4244,
          "api": "TF_RETURN_IF_ERROR",
          "text": "TF_RETURN_IF_ERROR(first_error_)",
          "line_content": "  TF_RETURN_IF_ERROR(first_error_);"
        },
        {
          "line": 4247,
          "api": "status",
          "text": "LookUpInstruction(operand).status()",
          "line_content": "  TF_RETURN_IF_ERROR(LookUpInstruction(operand).status());"
        },
        {
          "line": 152,
          "api": "result",
          "text": "program_shape.result().ToProto()",
          "line_content": "    *instr.mutable_shape() = program_shape.result().ToProto();"
        },
        {
          "line": 153,
          "api": "AddCalledComputation",
          "text": "builder->AddCalledComputation(fused_computation, &instr)",
          "line_content": "    builder->AddCalledComputation(fused_computation, &instr);"
        },
        {
          "line": 154,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "    return builder->AddInstruction(std::move(instr), HloOpcode::kFusion,"
        },
        {
          "line": 4251,
          "api": "handle",
          "text": "operand.handle()",
          "line_content": "  IsConstantVisitor(operand.handle(), /*depth=*/0, &visited, &is_constant);"
        },
        {
          "line": 4259,
          "api": "LookUpInstruction",
          "text": "LookUpInstruction(root_op)",
          "line_content": "    auto op_status = LookUpInstruction(root_op);"
        },
        {
          "line": 164,
          "api": "mutable_shape",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto instr;\n    *instr.mutable_shape() = shape.ToProto();\n    instr.set_async_execution_thread(execution_thread);\n    builder->AddCalledComputation(called_computation, &instr);\n    called_computation_id = instr.called_computation_ids()[0];\n    return builder->AddInstruction(std::move(instr), HloOpcode::kAsyncStart,\n                                   operands);\n  })",
          "line_content": "  auto start_op = builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 4261,
          "api": "value",
          "text": "op_status.value()->name()",
          "line_content": "        op_status.ok() ? op_status.value()->name() : \"<unknown operation>\";"
        },
        {
          "line": 166,
          "api": "ToProto",
          "text": "shape.ToProto()",
          "line_content": "    *instr.mutable_shape() = shape.ToProto();"
        },
        {
          "line": 167,
          "api": "set_async_execution_thread",
          "text": "instr.set_async_execution_thread(execution_thread)",
          "line_content": "    instr.set_async_execution_thread(execution_thread);"
        },
        {
          "line": 168,
          "api": "AddCalledComputation",
          "text": "builder->AddCalledComputation(called_computation, &instr)",
          "line_content": "    builder->AddCalledComputation(called_computation, &instr);"
        },
        {
          "line": 169,
          "api": "called_computation_ids",
          "text": "instr.called_computation_ids()",
          "line_content": "    called_computation_id = instr.called_computation_ids()[0];"
        },
        {
          "line": 170,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "    return builder->AddInstruction(std::move(instr), HloOpcode::kAsyncStart,"
        },
        {
          "line": 4262,
          "api": "InvalidArgument",
          "text": "InvalidArgument(\n        \"Operand to BuildConstantSubGraph depends on a parameter.\\n\\n\"\n        \"  op requested for constant subgraph: %s\\n\\n\"\n        \"This is an internal error that typically happens when the XLA user \"\n        \"(e.g. TensorFlow) is attempting to determine a value that must be a \"\n        \"compile-time constant (e.g. an array dimension) but it is not capable \"\n        \"of being evaluated at XLA compile time.\\n\\n\"\n        \"Please file a usability bug with the framework being used (e.g. \"\n        \"TensorFlow).\",\n        op_string)",
          "line_content": "    return InvalidArgument("
        },
        {
          "line": 4276,
          "api": "VLOG_IS_ON",
          "text": "VLOG_IS_ON(4)",
          "line_content": "  if (VLOG_IS_ON(4)) {"
        },
        {
          "line": 181,
          "api": "mutable_shape",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto instr;\n    *instr.mutable_shape() = shape.ToProto();\n    instr.set_async_execution_thread(execution_thread);\n    instr.add_called_computation_ids(called_computation);\n    return builder->AddInstruction(std::move(instr), HloOpcode::kAsyncUpdate,\n                                   {operand});\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 4277,
          "api": "OpToString",
          "text": "OpToString(root_op)",
          "line_content": "    VLOG(4) << \"Build constant subgraph for:\\n\" << OpToString(root_op);"
        },
        {
          "line": 183,
          "api": "ToProto",
          "text": "shape.ToProto()",
          "line_content": "    *instr.mutable_shape() = shape.ToProto();"
        },
        {
          "line": 184,
          "api": "set_async_execution_thread",
          "text": "instr.set_async_execution_thread(execution_thread)",
          "line_content": "    instr.set_async_execution_thread(execution_thread);"
        },
        {
          "line": 185,
          "api": "add_called_computation_ids",
          "text": "instr.add_called_computation_ids(called_computation)",
          "line_content": "    instr.add_called_computation_ids(called_computation);"
        },
        {
          "line": 186,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "    return builder->AddInstruction(std::move(instr), HloOpcode::kAsyncUpdate,"
        },
        {
          "line": 4281,
          "api": "StrCat",
          "text": "StrCat(name_, \"_compute_constant\")",
          "line_content": "  SetProtoIdAndName(&entry, StrCat(name_, \"_compute_constant\"), kNameSeparator,"
        },
        {
          "line": 4282,
          "api": "GetNextId",
          "text": "GetNextId()",
          "line_content": "                    GetNextId());"
        },
        {
          "line": 4283,
          "api": "mutable_program_shape",
          "text": "entry.mutable_program_shape()",
          "line_content": "  ProgramShapeProto* program_shape = entry.mutable_program_shape();"
        },
        {
          "line": 4284,
          "api": "shape",
          "text": "root->shape()",
          "line_content": "  *program_shape->mutable_result() = root->shape();"
        },
        {
          "line": 195,
          "api": "mutable_shape",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto instr;\n    *instr.mutable_shape() = shape.ToProto();\n    instr.set_async_execution_thread(execution_thread);\n    instr.add_called_computation_ids(called_computation);\n    return builder->AddInstruction(std::move(instr), HloOpcode::kAsyncDone,\n                                   {operand});\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 197,
          "api": "ToProto",
          "text": "shape.ToProto()",
          "line_content": "    *instr.mutable_shape() = shape.ToProto();"
        },
        {
          "line": 198,
          "api": "set_async_execution_thread",
          "text": "instr.set_async_execution_thread(execution_thread)",
          "line_content": "    instr.set_async_execution_thread(execution_thread);"
        },
        {
          "line": 199,
          "api": "add_called_computation_ids",
          "text": "instr.add_called_computation_ids(called_computation)",
          "line_content": "    instr.add_called_computation_ids(called_computation);"
        },
        {
          "line": 200,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "    return builder->AddInstruction(std::move(instr), HloOpcode::kAsyncDone,"
        },
        {
          "line": 4293,
          "api": "id",
          "text": "root->id()",
          "line_content": "  worklist.push(root->id());"
        },
        {
          "line": 4294,
          "api": "id",
          "text": "root->id()",
          "line_content": "  related_ops.insert(root->id());"
        },
        {
          "line": 4296,
          "api": "empty",
          "text": "worklist.empty()",
          "line_content": "  while (!worklist.empty()) {"
        },
        {
          "line": 4297,
          "api": "front",
          "text": "worklist.front()",
          "line_content": "    int64_t handle = worklist.front();"
        },
        {
          "line": 4298,
          "api": "pop",
          "text": "worklist.pop()",
          "line_content": "    worklist.pop();"
        },
        {
          "line": 4304,
          "api": "operand_ids",
          "text": "instr_proto->operand_ids()",
          "line_content": "      for (int64_t id : instr_proto->operand_ids()) {"
        },
        {
          "line": 4305,
          "api": "insert",
          "text": "related_ops.insert(id)",
          "line_content": "        if (related_ops.insert(id).second) {"
        },
        {
          "line": 4306,
          "api": "push",
          "text": "worklist.push(id)",
          "line_content": "          worklist.push(id);"
        },
        {
          "line": 211,
          "api": "AllGatherImpl",
          "text": "builder->AllGatherImpl(operand, all_gather_dimension, shard_count,\n                                replica_groups, channel_id, layout,\n                                use_global_device_ids, /*async=*/true)",
          "line_content": "  return builder->AllGatherImpl(operand, all_gather_dimension, shard_count,"
        },
        {
          "line": 4309,
          "api": "called_computation_ids",
          "text": "instr_proto->called_computation_ids()",
          "line_content": "      for (int64_t called_id : instr_proto->called_computation_ids()) {"
        },
        {
          "line": 4310,
          "api": "insert",
          "text": "related_calls.insert(called_id)",
          "line_content": "        related_calls.insert(called_id);"
        },
        {
          "line": 4314,
          "api": "opcode",
          "text": "instr_proto->opcode()",
          "line_content": "    if (instr_proto->opcode() =="
        },
        {
          "line": 219,
          "api": "mutable_shape",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto instr;\n    *instr.mutable_shape() = shape.ToProto();\n    return builder->AddInstruction(std::move(instr), HloOpcode::kAllGatherDone,\n                                   {operand});\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 4315,
          "api": "HloOpcodeString",
          "text": "HloOpcodeString(HloOpcode::kGetDimensionSize)",
          "line_content": "            HloOpcodeString(HloOpcode::kGetDimensionSize) ||"
        },
        {
          "line": 221,
          "api": "ToProto",
          "text": "shape.ToProto()",
          "line_content": "    *instr.mutable_shape() = shape.ToProto();"
        },
        {
          "line": 222,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "    return builder->AddInstruction(std::move(instr), HloOpcode::kAllGatherDone,"
        },
        {
          "line": 4316,
          "api": "InstrIsSetBound",
          "text": "InstrIsSetBound(instr_proto)",
          "line_content": "        InstrIsSetBound(instr_proto)) {"
        },
        {
          "line": 4320,
          "api": "opcode",
          "text": "instr_proto->opcode()",
          "line_content": "      if (instr_proto->opcode() =="
        },
        {
          "line": 4321,
          "api": "HloOpcodeString",
          "text": "HloOpcodeString(HloOpcode::kGetDimensionSize)",
          "line_content": "          HloOpcodeString(HloOpcode::kGetDimensionSize)) {"
        },
        {
          "line": 4328,
          "api": "dimensions",
          "text": "instr_proto->dimensions(0)",
          "line_content": "        int64_t dimension = instr_proto->dimensions(0);"
        },
        {
          "line": 233,
          "api": "AllReduceImpl",
          "text": "builder->AllReduceImpl(operand, computation, replica_groups,\n                                channel_id, layout, use_global_device_ids,\n                                /*async=*/true)",
          "line_content": "  return builder->AllReduceImpl(operand, computation, replica_groups,"
        },
        {
          "line": 4329,
          "api": "operand_ids",
          "text": "instr_proto->operand_ids(0)",
          "line_content": "        int64_t operand_handle = instr_proto->operand_ids(0);"
        },
        {
          "line": 4333,
          "api": "is_dynamic_dimension",
          "text": "operand_proto->shape().is_dynamic_dimension(dimension)",
          "line_content": "        if (!(operand_proto->shape().is_dynamic_dimension(dimension) &&"
        },
        {
          "line": 4335,
          "api": "dimensions",
          "text": "static_cast<int32_t>(\n              operand_proto->shape().dimensions(dimension))",
          "line_content": "          constant_value = static_cast<int32_t>("
        },
        {
          "line": 4336,
          "api": "dimensions",
          "text": "operand_proto->shape().dimensions(dimension)",
          "line_content": "              operand_proto->shape().dimensions(dimension));"
        },
        {
          "line": 241,
          "api": "mutable_shape",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto instr;\n    *instr.mutable_shape() = shape.ToProto();\n    return builder->AddInstruction(std::move(instr), HloOpcode::kAllReduceDone,\n                                   {operand});\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 4338,
          "api": "LiteralUtil::CreateR0(constant_value)",
          "text": "LiteralUtil::CreateR0(constant_value)",
          "line_content": "        Literal literal = LiteralUtil::CreateR0(constant_value);"
        },
        {
          "line": 243,
          "api": "ToProto",
          "text": "shape.ToProto()",
          "line_content": "    *instr.mutable_shape() = shape.ToProto();"
        },
        {
          "line": 244,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "    return builder->AddInstruction(std::move(instr), HloOpcode::kAllReduceDone,"
        },
        {
          "line": 4339,
          "api": "ToProto",
          "text": "literal.ToProto()",
          "line_content": "        *const_instr.mutable_literal() = literal.ToProto();"
        },
        {
          "line": 4340,
          "api": "shape",
          "text": "literal.shape().ToProto()",
          "line_content": "        *const_instr.mutable_shape() = literal.shape().ToProto();"
        },
        {
          "line": 4342,
          "api": "shape",
          "text": "instr_proto->literal().shape().element_type()",
          "line_content": "        if (instr_proto->literal().shape().element_type() == TUPLE) {"
        },
        {
          "line": 4343,
          "api": "mutable_literal",
          "text": "const_instr.mutable_literal()",
          "line_content": "          *const_instr.mutable_literal() ="
        },
        {
          "line": 4346,
          "api": "tuple_literals",
          "text": "instr_proto->literal().tuple_literals(0)",
          "line_content": "              instr_proto->literal().tuple_literals(0);"
        },
        {
          "line": 252,
          "api": "set_cross_program_prefetch_index",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto instr;\n    if (cross_program_prefetch_index) {\n      instr.set_cross_program_prefetch_index(*cross_program_prefetch_index);\n    }\n\n    TF_ASSIGN_OR_RETURN(const Shape* operand_shape,\n                        builder->GetShapePtr(operand));\n    Shape u32 = ShapeUtil::MakeScalarShape(PrimitiveType::U32);\n    Shape shape =\n        ShapeUtil::MakeTupleShapeWithPtrs({operand_shape, operand_shape, &u32});\n    *instr.mutable_shape() = shape.ToProto();\n\n    return builder->AddInstruction(std::move(instr), HloOpcode::kCopyStart,\n                                   {operand});\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 4348,
          "api": "literal",
          "text": "instr_proto->literal()",
          "line_content": "          *const_instr.mutable_literal() = instr_proto->literal();"
        },
        {
          "line": 255,
          "api": "set_cross_program_prefetch_index",
          "text": "instr.set_cross_program_prefetch_index(*cross_program_prefetch_index)",
          "line_content": "      instr.set_cross_program_prefetch_index(*cross_program_prefetch_index);"
        },
        {
          "line": 4351,
          "api": "shape",
          "text": "instr_proto->shape()",
          "line_content": "        *const_instr.mutable_shape() = instr_proto->shape();"
        },
        {
          "line": 4353,
          "api": "mutable_opcode",
          "text": "const_instr.mutable_opcode()",
          "line_content": "      *const_instr.mutable_opcode() ="
        },
        {
          "line": 4354,
          "api": "HloOpcodeString",
          "text": "HloOpcodeString(HloOpcode::kConstant)",
          "line_content": "          std::string(HloOpcodeString(HloOpcode::kConstant));"
        },
        {
          "line": 4355,
          "api": "set_id",
          "text": "const_instr.set_id(handle)",
          "line_content": "      const_instr.set_id(handle);"
        },
        {
          "line": 260,
          "api": "ShapeUtil::MakeScalarShape(PrimitiveType::U32)",
          "text": "ShapeUtil::MakeScalarShape(PrimitiveType::U32)",
          "line_content": "    Shape u32 = ShapeUtil::MakeScalarShape(PrimitiveType::U32);"
        },
        {
          "line": 4356,
          "api": "mutable_name",
          "text": "const_instr.mutable_name()",
          "line_content": "      *const_instr.mutable_name() ="
        },
        {
          "line": 262,
          "api": "ShapeUtil::MakeTupleShapeWithPtrs({operand_shape, operand_shape, &u32})",
          "text": "ShapeUtil::MakeTupleShapeWithPtrs({operand_shape, operand_shape, &u32})",
          "line_content": "        ShapeUtil::MakeTupleShapeWithPtrs({operand_shape, operand_shape, &u32});"
        },
        {
          "line": 263,
          "api": "ToProto",
          "text": "shape.ToProto()",
          "line_content": "    *instr.mutable_shape() = shape.ToProto();"
        },
        {
          "line": 4357,
          "api": "id",
          "text": "const_instr.id()",
          "line_content": "          GetFullName(const_instr.opcode(), kNameSeparator, const_instr.id());"
        },
        {
          "line": 265,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "    return builder->AddInstruction(std::move(instr), HloOpcode::kCopyStart,"
        },
        {
          "line": 4358,
          "api": "add_instructions",
          "text": "entry.add_instructions()",
          "line_content": "      *entry.add_instructions() ="
        },
        {
          "line": 4361,
          "api": "opcode",
          "text": "instr_proto->opcode()",
          "line_content": "    } else if (instr_proto->opcode() =="
        },
        {
          "line": 4362,
          "api": "HloOpcodeString",
          "text": "HloOpcodeString(HloOpcode::kGetTupleElement)",
          "line_content": "               HloOpcodeString(HloOpcode::kGetTupleElement)) {"
        },
        {
          "line": 272,
          "api": "mutable_shape",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto instr;\n    *instr.mutable_shape() = shape.ToProto();\n    return builder->AddInstruction(std::move(instr), HloOpcode::kCopyDone,\n                                   {operand});\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 4368,
          "api": "HloOpcodeString",
          "text": "HloOpcodeString(HloOpcode::kTuple)",
          "line_content": "      if (maybe_tuple_instr->opcode() == HloOpcodeString(HloOpcode::kTuple)) {"
        },
        {
          "line": 274,
          "api": "ToProto",
          "text": "shape.ToProto()",
          "line_content": "    *instr.mutable_shape() = shape.ToProto();"
        },
        {
          "line": 275,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "    return builder->AddInstruction(std::move(instr), HloOpcode::kCopyDone,"
        },
        {
          "line": 4369,
          "api": "tuple_index",
          "text": "instr_proto->tuple_index()",
          "line_content": "        int64_t id = maybe_tuple_instr->operand_ids(instr_proto->tuple_index());"
        },
        {
          "line": 4371,
          "api": "insert",
          "text": "related_ops.insert(id)",
          "line_content": "        if (related_ops.insert(id).second) {"
        },
        {
          "line": 4372,
          "api": "push",
          "text": "worklist.push(id)",
          "line_content": "          worklist.push(id);"
        },
        {
          "line": 4377,
          "api": "default_behavior",
          "text": "default_behavior()",
          "line_content": "        default_behavior();"
        },
        {
          "line": 284,
          "api": "CollectivePermuteImpl",
          "text": "builder->CollectivePermuteImpl(operand, source_target_pairs,\n                                        channel_id, /*async=*/true)",
          "line_content": "  return builder->CollectivePermuteImpl(operand, source_target_pairs,"
        },
        {
          "line": 4381,
          "api": "default_behavior",
          "text": "default_behavior()",
          "line_content": "      default_behavior();"
        },
        {
          "line": 4386,
          "api": "id",
          "text": "root->id()",
          "line_content": "  int64_t root_id = root->id();"
        },
        {
          "line": 291,
          "api": "mutable_shape",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto instr;\n    *instr.mutable_shape() = shape.ToProto();\n    return builder->AddInstruction(\n        std::move(instr), HloOpcode::kCollectivePermuteDone, {operand});\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 4387,
          "api": "find",
          "text": "substitutions.find(root_id)",
          "line_content": "  auto it = substitutions.find(root_id);"
        },
        {
          "line": 293,
          "api": "ToProto",
          "text": "shape.ToProto()",
          "line_content": "    *instr.mutable_shape() = shape.ToProto();"
        },
        {
          "line": 294,
          "api": "AddInstruction",
          "text": "builder->AddInstruction(\n        std::move(instr), HloOpcode::kCollectivePermuteDone, {operand})",
          "line_content": "    return builder->AddInstruction("
        },
        {
          "line": 295,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "        std::move(instr), HloOpcode::kCollectivePermuteDone, {operand});"
        },
        {
          "line": 4388,
          "api": "end",
          "text": "substitutions.end()",
          "line_content": "  while (it != substitutions.end()) {"
        },
        {
          "line": 4390,
          "api": "find",
          "text": "substitutions.find(root_id)",
          "line_content": "    it = substitutions.find(root_id);"
        },
        {
          "line": 4392,
          "api": "set_root_id",
          "text": "entry.set_root_id(root_id)",
          "line_content": "  entry.set_root_id(root_id);"
        },
        {
          "line": 4396,
          "api": "end",
          "text": "substitutions.end()",
          "line_content": "    if (substitutions.find(id) != substitutions.end()) {"
        },
        {
          "line": 301,
          "api": "mutable_shape",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto instr;\n    *instr.mutable_shape() = shape.ToProto();\n    return builder->AddInstruction(std::move(instr), HloOpcode::kBitcast,\n                                   {operand});\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 303,
          "api": "ToProto",
          "text": "shape.ToProto()",
          "line_content": "    *instr.mutable_shape() = shape.ToProto();"
        },
        {
          "line": 304,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "    return builder->AddInstruction(std::move(instr), HloOpcode::kBitcast,"
        },
        {
          "line": 4404,
          "api": "HloOpcodeString",
          "text": "HloOpcodeString(HloOpcode::kGetDimensionSize)",
          "line_content": "    if (instr_src->opcode() == HloOpcodeString(HloOpcode::kGetDimensionSize) ||"
        },
        {
          "line": 4405,
          "api": "InstrIsSetBound",
          "text": "InstrIsSetBound(instr_src)",
          "line_content": "        InstrIsSetBound(instr_src)) {"
        },
        {
          "line": 312,
          "api": "mutable_domain_entry_sharding",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto instr;\n    *instr.mutable_domain_entry_sharding() = entry;\n    *instr.mutable_domain_exit_sharding() = exit;\n    *instr.mutable_shape() = shape.ToProto();\n    return builder->AddInstruction(std::move(instr), HloOpcode::kDomain,\n                                   {operand});\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 4408,
          "api": "add_instructions",
          "text": "entry.add_instructions()",
          "line_content": "    HloInstructionProto* instr = entry.add_instructions();"
        },
        {
          "line": 314,
          "api": "mutable_domain_entry_sharding",
          "text": "instr.mutable_domain_entry_sharding()",
          "line_content": "    *instr.mutable_domain_entry_sharding() = entry;"
        },
        {
          "line": 315,
          "api": "mutable_domain_exit_sharding",
          "text": "instr.mutable_domain_exit_sharding()",
          "line_content": "    *instr.mutable_domain_exit_sharding() = exit;"
        },
        {
          "line": 316,
          "api": "ToProto",
          "text": "shape.ToProto()",
          "line_content": "    *instr.mutable_shape() = shape.ToProto();"
        },
        {
          "line": 317,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "    return builder->AddInstruction(std::move(instr), HloOpcode::kDomain,"
        },
        {
          "line": 4411,
          "api": "clear_operand_ids",
          "text": "instr->clear_operand_ids()",
          "line_content": "    instr->clear_operand_ids();"
        },
        {
          "line": 4412,
          "api": "operand_ids",
          "text": "instr_src->operand_ids()",
          "line_content": "    for (int64_t operand_id : instr_src->operand_ids()) {"
        },
        {
          "line": 4413,
          "api": "find",
          "text": "substitutions.find(operand_id)",
          "line_content": "      auto it = substitutions.find(operand_id);"
        },
        {
          "line": 4414,
          "api": "end",
          "text": "substitutions.end()",
          "line_content": "      while (it != substitutions.end()) {"
        },
        {
          "line": 4416,
          "api": "find",
          "text": "substitutions.find(operand_id)",
          "line_content": "        it = substitutions.find(operand_id);"
        },
        {
          "line": 4418,
          "api": "add_operand_ids",
          "text": "instr->add_operand_ids(operand_id)",
          "line_content": "      instr->add_operand_ids(operand_id);"
        },
        {
          "line": 324,
          "api": "mutable_shape",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto instr;\n    *instr.mutable_shape() = shape.ToProto();\n    return builder->AddInstruction(std::move(instr), HloOpcode::kPartitionId);\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 326,
          "api": "ToProto",
          "text": "shape.ToProto()",
          "line_content": "    *instr.mutable_shape() = shape.ToProto();"
        },
        {
          "line": 327,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "    return builder->AddInstruction(std::move(instr), HloOpcode::kPartitionId);"
        },
        {
          "line": 4422,
          "api": "id",
          "text": "instr->id()",
          "line_content": "        StrCat(instr->name(), \".\", entry.id(), \".\", instr->id());"
        },
        {
          "line": 4423,
          "api": "set_name",
          "text": "instr->set_name(new_name)",
          "line_content": "    instr->set_name(new_name);"
        },
        {
          "line": 4426,
          "api": "id",
          "text": "entry.id()",
          "line_content": "  XlaComputation computation(entry.id());"
        },
        {
          "line": 4427,
          "api": "mutable_proto",
          "text": "computation.mutable_proto()",
          "line_content": "  HloModuleProto* module = computation.mutable_proto();"
        },
        {
          "line": 4428,
          "api": "name",
          "text": "entry.name()",
          "line_content": "  module->set_name(entry.name());"
        },
        {
          "line": 4429,
          "api": "id",
          "text": "entry.id()",
          "line_content": "  module->set_id(entry.id());"
        },
        {
          "line": 334,
          "api": "mutable_shape",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto send_instr;\n    TF_ASSIGN_OR_RETURN(const Shape* shape, builder->GetShapePtr(operand));\n    // Send instruction produces a tuple of {aliased operand, U32 context,\n    // token}.\n    *send_instr.mutable_shape() =\n        ShapeUtil::MakeTupleShape({*shape, ShapeUtil::MakeShape(U32, {}),\n                                   ShapeUtil::MakeTokenShape()})\n            .ToProto();\n    send_instr.set_channel_id(handle.handle());\n    send_instr.set_is_host_transfer(is_host_transfer);\n    return builder->AddInstruction(std::move(send_instr), HloOpcode::kSend,\n                                   {operand, token});\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 4430,
          "api": "name",
          "text": "entry.name()",
          "line_content": "  module->set_entry_computation_name(entry.name());"
        },
        {
          "line": 4431,
          "api": "id",
          "text": "entry.id()",
          "line_content": "  module->set_entry_computation_id(entry.id());"
        },
        {
          "line": 4432,
          "api": "mutable_host_program_shape",
          "text": "module->mutable_host_program_shape()",
          "line_content": "  *module->mutable_host_program_shape() = *program_shape;"
        },
        {
          "line": 4434,
          "api": "end",
          "text": "related_calls.end()",
          "line_content": "    if (related_calls.find(e.second.id()) != related_calls.end()) {"
        },
        {
          "line": 339,
          "api": "mutable_shape",
          "text": "send_instr.mutable_shape()",
          "line_content": "    *send_instr.mutable_shape() ="
        },
        {
          "line": 340,
          "api": "ShapeUtil::MakeShape(U32, {})",
          "text": "ShapeUtil::MakeShape(U32, {})",
          "line_content": "        ShapeUtil::MakeTupleShape({*shape, ShapeUtil::MakeShape(U32, {}),"
        },
        {
          "line": 341,
          "api": "ShapeUtil::MakeTokenShape()",
          "text": "ShapeUtil::MakeTokenShape()",
          "line_content": "                                   ShapeUtil::MakeTokenShape()})"
        },
        {
          "line": 4435,
          "api": "add_computations",
          "text": "module->add_computations()",
          "line_content": "      *module->add_computations() = e.second;"
        },
        {
          "line": 343,
          "api": "handle",
          "text": "handle.handle()",
          "line_content": "    send_instr.set_channel_id(handle.handle());"
        },
        {
          "line": 344,
          "api": "set_is_host_transfer",
          "text": "send_instr.set_is_host_transfer(is_host_transfer)",
          "line_content": "    send_instr.set_is_host_transfer(is_host_transfer);"
        },
        {
          "line": 345,
          "api": "std::move(send_instr)",
          "text": "std::move(send_instr)",
          "line_content": "    return builder->AddInstruction(std::move(send_instr), HloOpcode::kSend,"
        },
        {
          "line": 4438,
          "api": "std::move(entry)",
          "text": "std::move(entry)",
          "line_content": "  *module->add_computations() = std::move(entry);"
        },
        {
          "line": 4439,
          "api": "VLOG_IS_ON",
          "text": "VLOG_IS_ON(4)",
          "line_content": "  if (VLOG_IS_ON(4)) {"
        },
        {
          "line": 4440,
          "api": "DebugString",
          "text": "module->DebugString()",
          "line_content": "    VLOG(4) << \"Constant computation:\\n\" << module->DebugString();"
        },
        {
          "line": 4442,
          "api": "std::move(computation)",
          "text": "std::move(computation)",
          "line_content": "  return std::move(computation);"
        },
        {
          "line": 4447,
          "api": "std::make_unique<XlaBuilder>(computation_name)",
          "text": "std::make_unique<XlaBuilder>(computation_name)",
          "line_content": "  auto sub_builder = std::make_unique<XlaBuilder>(computation_name);"
        },
        {
          "line": 353,
          "api": "mutable_shape",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto send_done_instr;\n    *send_done_instr.mutable_shape() = ShapeUtil::MakeTokenShape().ToProto();\n    send_done_instr.set_channel_id(handle.handle());\n    send_done_instr.set_is_host_transfer(is_host_transfer);\n    return builder->AddInstruction(std::move(send_done_instr),\n                                   HloOpcode::kSendDone, {operand});\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 355,
          "api": "ToProto",
          "text": "ShapeUtil::MakeTokenShape().ToProto()",
          "line_content": "    *send_done_instr.mutable_shape() = ShapeUtil::MakeTokenShape().ToProto();"
        },
        {
          "line": 356,
          "api": "handle",
          "text": "handle.handle()",
          "line_content": "    send_done_instr.set_channel_id(handle.handle());"
        },
        {
          "line": 357,
          "api": "set_is_host_transfer",
          "text": "send_done_instr.set_is_host_transfer(is_host_transfer)",
          "line_content": "    send_done_instr.set_is_host_transfer(is_host_transfer);"
        },
        {
          "line": 358,
          "api": "std::move(send_done_instr)",
          "text": "std::move(send_done_instr)",
          "line_content": "    return builder->AddInstruction(std::move(send_done_instr),"
        },
        {
          "line": 4456,
          "api": "set_input_batch_dimension",
          "text": "dimension_numbers.set_input_batch_dimension(kConvBatchDimension)",
          "line_content": "  dimension_numbers.set_input_batch_dimension(kConvBatchDimension);"
        },
        {
          "line": 4457,
          "api": "set_input_feature_dimension",
          "text": "dimension_numbers.set_input_feature_dimension(kConvFeatureDimension)",
          "line_content": "  dimension_numbers.set_input_feature_dimension(kConvFeatureDimension);"
        },
        {
          "line": 4458,
          "api": "set_output_batch_dimension",
          "text": "dimension_numbers.set_output_batch_dimension(kConvBatchDimension)",
          "line_content": "  dimension_numbers.set_output_batch_dimension(kConvBatchDimension);"
        },
        {
          "line": 4459,
          "api": "set_output_feature_dimension",
          "text": "dimension_numbers.set_output_feature_dimension(kConvFeatureDimension)",
          "line_content": "  dimension_numbers.set_output_feature_dimension(kConvFeatureDimension);"
        },
        {
          "line": 4460,
          "api": "set_kernel_output_feature_dimension",
          "text": "dimension_numbers.set_kernel_output_feature_dimension(\n      kConvKernelOutputDimension)",
          "line_content": "  dimension_numbers.set_kernel_output_feature_dimension("
        },
        {
          "line": 4462,
          "api": "set_kernel_input_feature_dimension",
          "text": "dimension_numbers.set_kernel_input_feature_dimension(\n      kConvKernelInputDimension)",
          "line_content": "  dimension_numbers.set_kernel_input_feature_dimension("
        },
        {
          "line": 367,
          "api": "mutable_shape",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    // Recv instruction produces a tuple of {receive buffer, U32 context,\n    // token}.\n    HloInstructionProto recv_instr;\n    *recv_instr.mutable_shape() =\n        ShapeUtil::MakeTupleShape(\n            {shape, ShapeUtil::MakeShape(U32, {}), ShapeUtil::MakeTokenShape()})\n            .ToProto();\n    recv_instr.set_channel_id(handle.handle());\n    recv_instr.set_is_host_transfer(is_host_transfer);\n    return builder->AddInstruction(std::move(recv_instr), HloOpcode::kRecv,\n                                   {token});\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 4465,
          "api": "add_input_spatial_dimensions",
          "text": "dimension_numbers.add_input_spatial_dimensions(i + 2)",
          "line_content": "    dimension_numbers.add_input_spatial_dimensions(i + 2);"
        },
        {
          "line": 4466,
          "api": "add_kernel_spatial_dimensions",
          "text": "dimension_numbers.add_kernel_spatial_dimensions(i + 2)",
          "line_content": "    dimension_numbers.add_kernel_spatial_dimensions(i + 2);"
        },
        {
          "line": 371,
          "api": "mutable_shape",
          "text": "recv_instr.mutable_shape()",
          "line_content": "    *recv_instr.mutable_shape() ="
        },
        {
          "line": 372,
          "api": "ToProto",
          "text": "ShapeUtil::MakeTupleShape(\n            {shape, ShapeUtil::MakeShape(U32, {}), ShapeUtil::MakeTokenShape()})\n            .ToProto()",
          "line_content": "        ShapeUtil::MakeTupleShape("
        },
        {
          "line": 373,
          "api": "ShapeUtil::MakeTokenShape()",
          "text": "ShapeUtil::MakeTokenShape()",
          "line_content": "            {shape, ShapeUtil::MakeShape(U32, {}), ShapeUtil::MakeTokenShape()})"
        },
        {
          "line": 4467,
          "api": "add_output_spatial_dimensions",
          "text": "dimension_numbers.add_output_spatial_dimensions(i + 2)",
          "line_content": "    dimension_numbers.add_output_spatial_dimensions(i + 2);"
        },
        {
          "line": 375,
          "api": "handle",
          "text": "handle.handle()",
          "line_content": "    recv_instr.set_channel_id(handle.handle());"
        },
        {
          "line": 376,
          "api": "set_is_host_transfer",
          "text": "recv_instr.set_is_host_transfer(is_host_transfer)",
          "line_content": "    recv_instr.set_is_host_transfer(is_host_transfer);"
        },
        {
          "line": 377,
          "api": "std::move(recv_instr)",
          "text": "std::move(recv_instr)",
          "line_content": "    return builder->AddInstruction(std::move(recv_instr), HloOpcode::kRecv,"
        },
        {
          "line": 4474,
          "api": "input_spatial_dimensions_size",
          "text": "dnum.input_spatial_dimensions_size()",
          "line_content": "  if (dnum.input_spatial_dimensions_size() < 2) {"
        },
        {
          "line": 4475,
          "api": "input_spatial_dimensions_size",
          "text": "FailedPrecondition(\"input spacial dimension < 2: %d\",\n                              dnum.input_spatial_dimensions_size())",
          "line_content": "    return FailedPrecondition(\"input spacial dimension < 2: %d\","
        },
        {
          "line": 4476,
          "api": "input_spatial_dimensions_size",
          "text": "dnum.input_spatial_dimensions_size()",
          "line_content": "                              dnum.input_spatial_dimensions_size());"
        },
        {
          "line": 4478,
          "api": "kernel_spatial_dimensions_size",
          "text": "dnum.kernel_spatial_dimensions_size()",
          "line_content": "  if (dnum.kernel_spatial_dimensions_size() < 2) {"
        },
        {
          "line": 4479,
          "api": "kernel_spatial_dimensions_size",
          "text": "FailedPrecondition(\"kernel spacial dimension < 2: %d\",\n                              dnum.kernel_spatial_dimensions_size())",
          "line_content": "    return FailedPrecondition(\"kernel spacial dimension < 2: %d\","
        },
        {
          "line": 4480,
          "api": "kernel_spatial_dimensions_size",
          "text": "dnum.kernel_spatial_dimensions_size()",
          "line_content": "                              dnum.kernel_spatial_dimensions_size());"
        },
        {
          "line": 386,
          "api": "mutable_shape",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto recv_done_instr;\n    *recv_done_instr.mutable_shape() =\n        ShapeUtil::MakeTupleShape({shape, ShapeUtil::MakeTokenShape()})\n            .ToProto();\n    recv_done_instr.set_channel_id(handle.handle());\n    recv_done_instr.set_is_host_transfer(is_host_transfer);\n    return builder->AddInstruction(std::move(recv_done_instr),\n                                   HloOpcode::kRecvDone, {token});\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 4482,
          "api": "output_spatial_dimensions_size",
          "text": "dnum.output_spatial_dimensions_size()",
          "line_content": "  if (dnum.output_spatial_dimensions_size() < 2) {"
        },
        {
          "line": 388,
          "api": "mutable_shape",
          "text": "recv_done_instr.mutable_shape()",
          "line_content": "    *recv_done_instr.mutable_shape() ="
        },
        {
          "line": 389,
          "api": "ShapeUtil::MakeTokenShape()",
          "text": "ShapeUtil::MakeTokenShape()",
          "line_content": "        ShapeUtil::MakeTupleShape({shape, ShapeUtil::MakeTokenShape()})"
        },
        {
          "line": 4483,
          "api": "output_spatial_dimensions_size",
          "text": "FailedPrecondition(\"output spacial dimension < 2: %d\",\n                              dnum.output_spatial_dimensions_size())",
          "line_content": "    return FailedPrecondition(\"output spacial dimension < 2: %d\","
        },
        {
          "line": 391,
          "api": "handle",
          "text": "handle.handle()",
          "line_content": "    recv_done_instr.set_channel_id(handle.handle());"
        },
        {
          "line": 392,
          "api": "set_is_host_transfer",
          "text": "recv_done_instr.set_is_host_transfer(is_host_transfer)",
          "line_content": "    recv_done_instr.set_is_host_transfer(is_host_transfer);"
        },
        {
          "line": 393,
          "api": "std::move(recv_done_instr)",
          "text": "std::move(recv_done_instr)",
          "line_content": "    return builder->AddInstruction(std::move(recv_done_instr),"
        },
        {
          "line": 4484,
          "api": "output_spatial_dimensions_size",
          "text": "dnum.output_spatial_dimensions_size()",
          "line_content": "                              dnum.output_spatial_dimensions_size());"
        },
        {
          "line": 4487,
          "api": "input_batch_dimension",
          "text": "std::set<int64_t>(\n          {dnum.input_batch_dimension(), dnum.input_feature_dimension(),\n           dnum.input_spatial_dimensions(0), dnum.input_spatial_dimensions(1)})\n          .size()",
          "line_content": "  if (std::set<int64_t>("
        },
        {
          "line": 4488,
          "api": "input_feature_dimension",
          "text": "dnum.input_feature_dimension()",
          "line_content": "          {dnum.input_batch_dimension(), dnum.input_feature_dimension(),"
        },
        {
          "line": 4489,
          "api": "input_spatial_dimensions",
          "text": "dnum.input_spatial_dimensions(1)",
          "line_content": "           dnum.input_spatial_dimensions(0), dnum.input_spatial_dimensions(1)})"
        },
        {
          "line": 4491,
          "api": "input_batch_dimension",
          "text": "FailedPrecondition(\n        \"dimension numbers for the input are not unique: (%d, %d, %d, \"\n        \"%d)\",\n        dnum.input_batch_dimension(), dnum.input_feature_dimension(),\n        dnum.input_spatial_dimensions(0), dnum.input_spatial_dimensions(1))",
          "line_content": "    return FailedPrecondition("
        },
        {
          "line": 4494,
          "api": "input_feature_dimension",
          "text": "dnum.input_feature_dimension()",
          "line_content": "        dnum.input_batch_dimension(), dnum.input_feature_dimension(),"
        },
        {
          "line": 4495,
          "api": "input_spatial_dimensions",
          "text": "dnum.input_spatial_dimensions(1)",
          "line_content": "        dnum.input_spatial_dimensions(0), dnum.input_spatial_dimensions(1));"
        },
        {
          "line": 4497,
          "api": "kernel_output_feature_dimension",
          "text": "dnum.kernel_output_feature_dimension()",
          "line_content": "  if (std::set<int64_t>({dnum.kernel_output_feature_dimension(),"
        },
        {
          "line": 402,
          "api": "set_delta",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto instr;\n    instr.set_delta(delta);\n    *instr.mutable_shape() = shape.ToProto();\n    return builder->AddInstruction(std::move(instr),\n                                   HloOpcode::kRngGetAndUpdateState);\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 4498,
          "api": "kernel_input_feature_dimension",
          "text": "dnum.kernel_input_feature_dimension()",
          "line_content": "                         dnum.kernel_input_feature_dimension(),"
        },
        {
          "line": 404,
          "api": "set_delta",
          "text": "instr.set_delta(delta)",
          "line_content": "    instr.set_delta(delta);"
        },
        {
          "line": 405,
          "api": "ToProto",
          "text": "shape.ToProto()",
          "line_content": "    *instr.mutable_shape() = shape.ToProto();"
        },
        {
          "line": 406,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "    return builder->AddInstruction(std::move(instr),"
        },
        {
          "line": 4499,
          "api": "kernel_spatial_dimensions",
          "text": "dnum.kernel_spatial_dimensions(0)",
          "line_content": "                         dnum.kernel_spatial_dimensions(0),"
        },
        {
          "line": 4500,
          "api": "kernel_spatial_dimensions",
          "text": "dnum.kernel_spatial_dimensions(1)",
          "line_content": "                         dnum.kernel_spatial_dimensions(1)})"
        },
        {
          "line": 4502,
          "api": "kernel_output_feature_dimension",
          "text": "FailedPrecondition(\n        \"dimension numbers for the weight are not unique: (%d, %d, %d, \"\n        \"%d)\",\n        dnum.kernel_output_feature_dimension(),\n        dnum.kernel_input_feature_dimension(),\n        dnum.kernel_spatial_dimensions(0), dnum.kernel_spatial_dimensions(1))",
          "line_content": "    return FailedPrecondition("
        },
        {
          "line": 4505,
          "api": "kernel_output_feature_dimension",
          "text": "dnum.kernel_output_feature_dimension()",
          "line_content": "        dnum.kernel_output_feature_dimension(),"
        },
        {
          "line": 4506,
          "api": "kernel_input_feature_dimension",
          "text": "dnum.kernel_input_feature_dimension()",
          "line_content": "        dnum.kernel_input_feature_dimension(),"
        },
        {
          "line": 412,
          "api": "builder",
          "text": "op.builder()",
          "line_content": "  return &op.builder()"
        },
        {
          "line": 413,
          "api": "builder",
          "text": "op.builder()",
          "line_content": "              ->instructions_[op.builder()->handle_to_index_[op.handle_]];"
        },
        {
          "line": 4507,
          "api": "kernel_spatial_dimensions",
          "text": "dnum.kernel_spatial_dimensions(1)",
          "line_content": "        dnum.kernel_spatial_dimensions(0), dnum.kernel_spatial_dimensions(1));"
        },
        {
          "line": 4509,
          "api": "output_batch_dimension",
          "text": "dnum.output_batch_dimension()",
          "line_content": "  if (std::set<int64_t>({dnum.output_batch_dimension(),"
        },
        {
          "line": 4510,
          "api": "output_feature_dimension",
          "text": "dnum.output_feature_dimension()",
          "line_content": "                         dnum.output_feature_dimension(),"
        },
        {
          "line": 4511,
          "api": "output_spatial_dimensions",
          "text": "dnum.output_spatial_dimensions(0)",
          "line_content": "                         dnum.output_spatial_dimensions(0),"
        },
        {
          "line": 4512,
          "api": "output_spatial_dimensions",
          "text": "dnum.output_spatial_dimensions(1)",
          "line_content": "                         dnum.output_spatial_dimensions(1)})"
        },
        {
          "line": 4514,
          "api": "output_batch_dimension",
          "text": "FailedPrecondition(\n        \"dimension numbers for the output are not unique: (%d, %d, %d, \"\n        \"%d)\",\n        dnum.output_batch_dimension(), dnum.output_feature_dimension(),\n        dnum.output_spatial_dimensions(0), dnum.output_spatial_dimensions(1))",
          "line_content": "    return FailedPrecondition("
        },
        {
          "line": 4517,
          "api": "output_feature_dimension",
          "text": "dnum.output_feature_dimension()",
          "line_content": "        dnum.output_batch_dimension(), dnum.output_feature_dimension(),"
        },
        {
          "line": 4518,
          "api": "output_spatial_dimensions",
          "text": "dnum.output_spatial_dimensions(1)",
          "line_content": "        dnum.output_spatial_dimensions(0), dnum.output_spatial_dimensions(1));"
        },
        {
          "line": 423,
          "api": "Neg",
          "text": "Neg(x)",
          "line_content": "XlaOp operator-(XlaOp x) { return Neg(x); }"
        },
        {
          "line": 424,
          "api": "Add",
          "text": "Add(x, y)",
          "line_content": "XlaOp operator+(XlaOp x, XlaOp y) { return Add(x, y); }"
        },
        {
          "line": 425,
          "api": "Sub",
          "text": "Sub(x, y)",
          "line_content": "XlaOp operator-(XlaOp x, XlaOp y) { return Sub(x, y); }"
        },
        {
          "line": 426,
          "api": "Mul",
          "text": "Mul(x, y)",
          "line_content": "XlaOp operator*(XlaOp x, XlaOp y) { return Mul(x, y); }"
        },
        {
          "line": 427,
          "api": "Div",
          "text": "Div(x, y)",
          "line_content": "XlaOp operator/(XlaOp x, XlaOp y) { return Div(x, y); }"
        },
        {
          "line": 428,
          "api": "Rem",
          "text": "Rem(x, y)",
          "line_content": "XlaOp operator%(XlaOp x, XlaOp y) { return Rem(x, y); }"
        },
        {
          "line": 4520,
          "api": "OkStatus",
          "text": "OkStatus()",
          "line_content": "  return OkStatus();"
        },
        {
          "line": 430,
          "api": "Not",
          "text": "Not(x)",
          "line_content": "XlaOp operator~(XlaOp x) { return Not(x); }"
        },
        {
          "line": 431,
          "api": "And",
          "text": "And(x, y)",
          "line_content": "XlaOp operator&(XlaOp x, XlaOp y) { return And(x, y); }"
        },
        {
          "line": 432,
          "api": "Or",
          "text": "Or(x, y)",
          "line_content": "XlaOp operator|(XlaOp x, XlaOp y) { return Or(x, y); }"
        },
        {
          "line": 433,
          "api": "Xor",
          "text": "Xor(x, y)",
          "line_content": "XlaOp operator^(XlaOp x, XlaOp y) { return Xor(x, y); }"
        },
        {
          "line": 434,
          "api": "ShiftLeft",
          "text": "ShiftLeft(x, y)",
          "line_content": "XlaOp operator<<(XlaOp x, XlaOp y) { return ShiftLeft(x, y); }"
        },
        {
          "line": 4526,
          "api": "TF_RETURN_IF_ERROR",
          "text": "TF_RETURN_IF_ERROR(first_error_)",
          "line_content": "  TF_RETURN_IF_ERROR(first_error_);"
        },
        {
          "line": 4528,
          "api": "GetNextId",
          "text": "GetNextId()",
          "line_content": "  const int64_t handle = GetNextId();"
        },
        {
          "line": 437,
          "api": "builder",
          "text": "x.builder()",
          "line_content": "  XlaBuilder* builder = x.builder();"
        },
        {
          "line": 438,
          "api": "ReportErrorOrReturn",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    TF_ASSIGN_OR_RETURN(const Shape* shape, builder->GetShapePtr(x));\n    if (!ShapeUtil::ElementIsIntegral(*shape)) {\n      return InvalidArgument(\n          \"Argument to >> operator does not have an integral type (%s).\",\n          ShapeUtil::HumanString(*shape));\n    }\n    if (ShapeUtil::ElementIsSigned(*shape)) {\n      return ShiftRightArithmetic(x, y);\n    } else {\n      return ShiftRightLogical(x, y);\n    }\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 4529,
          "api": "set_id",
          "text": "instr.set_id(handle)",
          "line_content": "  instr.set_id(handle);"
        },
        {
          "line": 440,
          "api": "ShapeUtil::ElementIsIntegral(*shape)",
          "text": "ShapeUtil::ElementIsIntegral(*shape)",
          "line_content": "    if (!ShapeUtil::ElementIsIntegral(*shape)) {"
        },
        {
          "line": 441,
          "api": "InvalidArgument",
          "text": "InvalidArgument(\n          \"Argument to >> operator does not have an integral type (%s).\",\n          ShapeUtil::HumanString(*shape))",
          "line_content": "      return InvalidArgument("
        },
        {
          "line": 4530,
          "api": "HloOpcodeString",
          "text": "HloOpcodeString(opcode)",
          "line_content": "  *instr.mutable_opcode() = std::string(HloOpcodeString(opcode));"
        },
        {
          "line": 443,
          "api": "ShapeUtil::HumanString(*shape)",
          "text": "ShapeUtil::HumanString(*shape)",
          "line_content": "          ShapeUtil::HumanString(*shape));"
        },
        {
          "line": 4531,
          "api": "name",
          "text": "instr.name().empty()",
          "line_content": "  if (instr.name().empty()) {"
        },
        {
          "line": 445,
          "api": "ShapeUtil::ElementIsSigned(*shape)",
          "text": "ShapeUtil::ElementIsSigned(*shape)",
          "line_content": "    if (ShapeUtil::ElementIsSigned(*shape)) {"
        },
        {
          "line": 446,
          "api": "ShiftRightArithmetic",
          "text": "ShiftRightArithmetic(x, y)",
          "line_content": "      return ShiftRightArithmetic(x, y);"
        },
        {
          "line": 4536,
          "api": "handle",
          "text": "operand.handle()",
          "line_content": "      return InvalidArgument(\"invalid XlaOp with handle %d\", operand.handle());"
        },
        {
          "line": 448,
          "api": "ShiftRightLogical",
          "text": "ShiftRightLogical(x, y)",
          "line_content": "      return ShiftRightLogical(x, y);"
        },
        {
          "line": 4539,
          "api": "name",
          "text": "InvalidArgument(\"Do not add XlaOp from builder %s to builder %s\",\n                             operand.builder_->name(), this->name())",
          "line_content": "      return InvalidArgument(\"Do not add XlaOp from builder %s to builder %s\","
        },
        {
          "line": 4540,
          "api": "name",
          "text": "this->name()",
          "line_content": "                             operand.builder_->name(), this->name());"
        },
        {
          "line": 4542,
          "api": "handle",
          "text": "operand.handle()",
          "line_content": "    instr.add_operand_ids(operand.handle());"
        },
        {
          "line": 4545,
          "api": "has_value",
          "text": "one_shot_metadata_.has_value()",
          "line_content": "  if (one_shot_metadata_.has_value()) {"
        },
        {
          "line": 4546,
          "api": "value",
          "text": "one_shot_metadata_.value()",
          "line_content": "    *instr.mutable_metadata() = one_shot_metadata_.value();"
        },
        {
          "line": 454,
          "api": "TF_RETURN_IF_ERROR",
          "text": "TF_RETURN_IF_ERROR(first_error_)",
          "line_content": "  TF_RETURN_IF_ERROR(first_error_);"
        },
        {
          "line": 455,
          "api": "CheckOpBuilder",
          "text": "CheckOpBuilder(op)",
          "line_content": "  TF_RETURN_IF_ERROR(CheckOpBuilder(op));"
        },
        {
          "line": 456,
          "api": "handle",
          "text": "op.handle()",
          "line_content": "  auto it = handle_to_index_.find(op.handle());"
        },
        {
          "line": 457,
          "api": "end",
          "text": "handle_to_index_.end()",
          "line_content": "  if (it == handle_to_index_.end()) {"
        },
        {
          "line": 458,
          "api": "handle",
          "text": "op.handle()",
          "line_content": "    return InvalidArgument(\"No XlaOp with handle %d\", op.handle());"
        },
        {
          "line": 4547,
          "api": "reset",
          "text": "one_shot_metadata_.reset()",
          "line_content": "    one_shot_metadata_.reset();"
        },
        {
          "line": 460,
          "api": "at",
          "text": "instruction_shapes_.at(it->second).get()",
          "line_content": "  return instruction_shapes_.at(it->second).get();"
        },
        {
          "line": 4549,
          "api": "mutable_metadata",
          "text": "instr.mutable_metadata()",
          "line_content": "    *instr.mutable_metadata() = metadata_;"
        },
        {
          "line": 4553,
          "api": "shape",
          "text": "instr.shape()",
          "line_content": "    Shape shape(instr.shape());"
        },
        {
          "line": 4556,
          "api": "NormalizeTupleSharding",
          "text": "sharding.NormalizeTupleSharding(shape)",
          "line_content": "    sharding = sharding.NormalizeTupleSharding(shape);"
        },
        {
          "line": 4557,
          "api": "Validate",
          "text": "sharding.Validate(shape)",
          "line_content": "    TF_RETURN_IF_ERROR(sharding.Validate(shape));"
        },
        {
          "line": 4558,
          "api": "ToProto",
          "text": "sharding.ToProto()",
          "line_content": "    *instr.mutable_sharding() = sharding.ToProto();"
        },
        {
          "line": 4560,
          "api": "mutable_frontend_attributes",
          "text": "instr.mutable_frontend_attributes()",
          "line_content": "  *instr.mutable_frontend_attributes() = frontend_attributes_;"
        },
        {
          "line": 4562,
          "api": "size",
          "text": "instructions_.size()",
          "line_content": "  handle_to_index_[handle] = instructions_.size();"
        },
        {
          "line": 4563,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "  instructions_.push_back(std::move(instr));"
        },
        {
          "line": 4564,
          "api": "push_back",
          "text": "instruction_shapes_.push_back(\n      std::make_unique<Shape>(instructions_.back().shape()))",
          "line_content": "  instruction_shapes_.push_back("
        },
        {
          "line": 4565,
          "api": "back",
          "text": "instructions_.back().shape()",
          "line_content": "      std::make_unique<Shape>(instructions_.back().shape()));"
        },
        {
          "line": 471,
          "api": "size",
          "text": "operands.size()",
          "line_content": "  operand_shapes.reserve(operands.size());"
        },
        {
          "line": 474,
          "api": "push_back",
          "text": "operand_shapes.push_back(*shape)",
          "line_content": "    operand_shapes.push_back(*shape);"
        },
        {
          "line": 4574,
          "api": "ToProto",
          "text": "shape.ToProto()",
          "line_content": "  *instr.mutable_shape() = shape.ToProto();"
        },
        {
          "line": 4575,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "  return AddInstruction(std::move(instr), opcode, operands);"
        },
        {
          "line": 481,
          "api": "handle",
          "text": "op.handle()",
          "line_content": "  ToStringHelper(&s, /*ident=*/0, op.handle());"
        },
        {
          "line": 486,
          "api": "tuple_shapes_size",
          "text": "shape.tuple_shapes_size()",
          "line_content": "  if (shape.tuple_shapes_size() > 1) {"
        },
        {
          "line": 487,
          "api": "tuple_shapes",
          "text": "absl::StrCat(\n        \"(\",\n        absl::StrJoin(shape.tuple_shapes(), \", \",\n                      [&](std::string* s, const ShapeProto& subshape) {\n                        absl::StrAppend(s, ShapeToString(subshape));\n                      }),\n        \")\")",
          "line_content": "    return absl::StrCat("
        },
        {
          "line": 4582,
          "api": "proto",
          "text": "computation.proto().computations_size()",
          "line_content": "  imported_computations.reserve(computation.proto().computations_size());"
        },
        {
          "line": 489,
          "api": "tuple_shapes",
          "text": "shape.tuple_shapes()",
          "line_content": "        absl::StrJoin(shape.tuple_shapes(), \", \","
        },
        {
          "line": 4585,
          "api": "proto",
          "text": "computation.proto().computations()",
          "line_content": "  for (const HloComputationProto& e : computation.proto().computations()) {"
        },
        {
          "line": 491,
          "api": "ShapeToString",
          "text": "ShapeToString(subshape)",
          "line_content": "                        absl::StrAppend(s, ShapeToString(subshape));"
        },
        {
          "line": 4587,
          "api": "GetNextId",
          "text": "GetNextId()",
          "line_content": "    int64_t computation_id = GetNextId();"
        },
        {
          "line": 4588,
          "api": "id",
          "text": "new_computation.id()",
          "line_content": "    remapped_ids[new_computation.id()] = computation_id;"
        },
        {
          "line": 4589,
          "api": "name",
          "text": "SetProtoIdAndName(&new_computation,\n                      GetBaseName(new_computation.name(), kNameSeparator),\n                      kNameSeparator, computation_id)",
          "line_content": "    SetProtoIdAndName(&new_computation,"
        },
        {
          "line": 495,
          "api": "dimensions",
          "text": "shape.dimensions()",
          "line_content": "  return absl::StrCat(\"[\", absl::StrJoin(shape.dimensions(), \", \"), \"]\");"
        },
        {
          "line": 4590,
          "api": "name",
          "text": "new_computation.name()",
          "line_content": "                      GetBaseName(new_computation.name(), kNameSeparator),"
        },
        {
          "line": 4592,
          "api": "mutable_instructions",
          "text": "new_computation.mutable_instructions()",
          "line_content": "    for (auto& instruction : *new_computation.mutable_instructions()) {"
        },
        {
          "line": 4593,
          "api": "GetNextId",
          "text": "GetNextId()",
          "line_content": "      int64_t instruction_id = GetNextId();"
        },
        {
          "line": 4594,
          "api": "id",
          "text": "instruction.id()",
          "line_content": "      remapped_ids[instruction.id()] = instruction_id;"
        },
        {
          "line": 4595,
          "api": "name",
          "text": "SetProtoIdAndName(&instruction,\n                        GetBaseName(instruction.name(), kNameSeparator),\n                        kNameSeparator, instruction_id)",
          "line_content": "      SetProtoIdAndName(&instruction,"
        },
        {
          "line": 501,
          "api": "value",
          "text": "LookUpInstructionByHandle(op_handle).value()",
          "line_content": "      *(LookUpInstructionByHandle(op_handle).value());"
        },
        {
          "line": 502,
          "api": "opcode",
          "text": "instr.opcode()",
          "line_content": "  absl::StrAppend(out, std::string(ident, ' '), instr.opcode(),"
        },
        {
          "line": 503,
          "api": "shape",
          "text": "instr.shape()",
          "line_content": "                  \", shape=\", ShapeToString(instr.shape()));"
        },
        {
          "line": 504,
          "api": "has_metadata",
          "text": "instr.has_metadata()",
          "line_content": "  if (instr.has_metadata()) {"
        },
        {
          "line": 505,
          "api": "metadata",
          "text": "instr.metadata().source_file()",
          "line_content": "    absl::StrAppend(out, \", metadata={\", instr.metadata().source_file(), \":\","
        },
        {
          "line": 506,
          "api": "metadata",
          "text": "instr.metadata().source_line()",
          "line_content": "                    instr.metadata().source_line(), \"}\");"
        },
        {
          "line": 4596,
          "api": "name",
          "text": "instruction.name()",
          "line_content": "                        GetBaseName(instruction.name(), kNameSeparator),"
        },
        {
          "line": 508,
          "api": "operand_ids_size",
          "text": "instr.operand_ids_size()",
          "line_content": "  if (instr.operand_ids_size()) {"
        },
        {
          "line": 509,
          "api": "absl::StrAppend(out, \"\\n\")",
          "text": "absl::StrAppend(out, \"\\n\")",
          "line_content": "    absl::StrAppend(out, \"\\n\");"
        },
        {
          "line": 4599,
          "api": "root_id",
          "text": "new_computation.root_id()",
          "line_content": "    new_computation.set_root_id(remapped_ids.at(new_computation.root_id()));"
        },
        {
          "line": 511,
          "api": "operand_ids",
          "text": "instr.operand_ids()",
          "line_content": "  absl::StrAppend(out, absl::StrJoin(instr.operand_ids(), \"\\n\","
        },
        {
          "line": 4601,
          "api": "std::move(new_computation)",
          "text": "std::move(new_computation)",
          "line_content": "    imported_computations.push_back(std::move(new_computation));"
        },
        {
          "line": 513,
          "api": "ToStringHelper",
          "text": "ToStringHelper(s, ident + 2, subop)",
          "line_content": "                                       ToStringHelper(s, ident + 2, subop);"
        },
        {
          "line": 4605,
          "api": "at",
          "text": "instr->add_called_computation_ids(\n      remapped_ids.at(computation.proto().entry_computation_id()))",
          "line_content": "  instr->add_called_computation_ids("
        },
        {
          "line": 4606,
          "api": "proto",
          "text": "computation.proto().entry_computation_id()",
          "line_content": "      remapped_ids.at(computation.proto().entry_computation_id()));"
        },
        {
          "line": 4608,
          "api": "mutable_instructions",
          "text": "imported_computation.mutable_instructions()",
          "line_content": "    for (auto& instruction : *imported_computation.mutable_instructions()) {"
        },
        {
          "line": 4609,
          "api": "mutable_operand_ids",
          "text": "instruction.mutable_operand_ids()",
          "line_content": "      for (auto& operand_id : *instruction.mutable_operand_ids()) {"
        },
        {
          "line": 4610,
          "api": "at",
          "text": "remapped_ids.at(operand_id)",
          "line_content": "        operand_id = remapped_ids.at(operand_id);"
        },
        {
          "line": 4613,
          "api": "mutable_control_predecessor_ids",
          "text": "instruction.mutable_control_predecessor_ids()",
          "line_content": "           *instruction.mutable_control_predecessor_ids()) {"
        },
        {
          "line": 4614,
          "api": "at",
          "text": "remapped_ids.at(control_predecessor_id)",
          "line_content": "        control_predecessor_id = remapped_ids.at(control_predecessor_id);"
        },
        {
          "line": 4617,
          "api": "mutable_called_computation_ids",
          "text": "instruction.mutable_called_computation_ids()",
          "line_content": "           *instruction.mutable_called_computation_ids()) {"
        },
        {
          "line": 4618,
          "api": "at",
          "text": "remapped_ids.at(called_computation_id)",
          "line_content": "        called_computation_id = remapped_ids.at(called_computation_id);"
        },
        {
          "line": 523,
          "api": "ok",
          "text": "error.ok()",
          "line_content": "  CHECK(!error.ok());"
        },
        {
          "line": 525,
          "api": "LOG",
          "text": "LOG(FATAL)",
          "line_content": "    LOG(FATAL) << \"error building computation: \" << error;"
        },
        {
          "line": 4622,
          "api": "id",
          "text": "imported_computation.id()",
          "line_content": "    int64_t computation_id = imported_computation.id();"
        },
        {
          "line": 4623,
          "api": "instructions_size",
          "text": "imported_computation.instructions_size()",
          "line_content": "    for (int64_t i = 0; i < imported_computation.instructions_size(); ++i) {"
        },
        {
          "line": 528,
          "api": "ok",
          "text": "first_error_.ok()",
          "line_content": "  if (first_error_.ok()) {"
        },
        {
          "line": 530,
          "api": "CreateCurrent",
          "text": "first_error_backtrace_.CreateCurrent(/*skip_count=*/1)",
          "line_content": "    first_error_backtrace_.CreateCurrent(/*skip_count=*/1);"
        },
        {
          "line": 4627,
          "api": "insert",
          "text": "handle_to_imported_index_.insert(\n          {imported_computation.instructions(i).id(), imported_instruction})",
          "line_content": "      handle_to_imported_index_.insert("
        },
        {
          "line": 532,
          "api": "XlaOp",
          "text": "XlaOp(this)",
          "line_content": "  return XlaOp(this);"
        },
        {
          "line": 4628,
          "api": "instructions",
          "text": "imported_computation.instructions(i).id()",
          "line_content": "          {imported_computation.instructions(i).id(), imported_instruction});"
        },
        {
          "line": 4630,
          "api": "std::move(imported_computation)",
          "text": "std::move(imported_computation)",
          "line_content": "    embedded_.insert({computation_id, std::move(imported_computation)});"
        },
        {
          "line": 536,
          "api": "ok",
          "text": "first_error_.ok()",
          "line_content": "  if (!first_error_.ok()) {"
        },
        {
          "line": 537,
          "api": "XlaOp",
          "text": "XlaOp(this)",
          "line_content": "    return XlaOp(this);"
        },
        {
          "line": 539,
          "api": "ok",
          "text": "op.ok()",
          "line_content": "  if (!op.ok()) {"
        },
        {
          "line": 540,
          "api": "status",
          "text": "op.status()",
          "line_content": "    return ReportError(op.status());"
        },
        {
          "line": 4636,
          "api": "TF_RETURN_IF_ERROR",
          "text": "TF_RETURN_IF_ERROR(first_error_)",
          "line_content": "  TF_RETURN_IF_ERROR(first_error_);"
        },
        {
          "line": 542,
          "api": "value",
          "text": "op.value()",
          "line_content": "  return op.value();"
        },
        {
          "line": 4637,
          "api": "LookUpInstructionInternal<const HloInstructionProto*>(op)",
          "text": "LookUpInstructionInternal<const HloInstructionProto*>(op)",
          "line_content": "  return LookUpInstructionInternal<const HloInstructionProto*>(op);"
        },
        {
          "line": 4642,
          "api": "LookUpInstructionByHandleInternal<const HloInstructionProto*>(handle)",
          "text": "LookUpInstructionByHandleInternal<const HloInstructionProto*>(handle)",
          "line_content": "  return LookUpInstructionByHandleInternal<const HloInstructionProto*>(handle);"
        },
        {
          "line": 547,
          "api": "op_creator",
          "text": "op_creator()",
          "line_content": "  return ReportErrorOrReturn(op_creator());"
        },
        {
          "line": 551,
          "api": "TF_RETURN_IF_ERROR",
          "text": "TF_RETURN_IF_ERROR(first_error_)",
          "line_content": "  TF_RETURN_IF_ERROR(first_error_);"
        },
        {
          "line": 4647,
          "api": "TF_RETURN_IF_ERROR",
          "text": "TF_RETURN_IF_ERROR(first_error_)",
          "line_content": "  TF_RETURN_IF_ERROR(first_error_);"
        },
        {
          "line": 4648,
          "api": "LookUpInstructionInternal<HloInstructionProto*>(op)",
          "text": "LookUpInstructionInternal<HloInstructionProto*>(op)",
          "line_content": "  return LookUpInstructionInternal<HloInstructionProto*>(op);"
        },
        {
          "line": 557,
          "api": "shape",
          "text": "root_proto->shape()",
          "line_content": "  *program_shape.mutable_result() = Shape(root_proto->shape());"
        },
        {
          "line": 4653,
          "api": "LookUpInstructionByHandleInternal<HloInstructionProto*>(handle)",
          "text": "LookUpInstructionByHandleInternal<HloInstructionProto*>(handle)",
          "line_content": "  return LookUpInstructionByHandleInternal<HloInstructionProto*>(handle);"
        },
        {
          "line": 561,
          "api": "size",
          "text": "parameter_numbers_.size()",
          "line_content": "  const int64_t param_count = parameter_numbers_.size();"
        },
        {
          "line": 563,
          "api": "add_parameters",
          "text": "program_shape.add_parameters()",
          "line_content": "    program_shape.add_parameters();"
        },
        {
          "line": 564,
          "api": "add_parameter_names",
          "text": "program_shape.add_parameter_names()",
          "line_content": "    program_shape.add_parameter_names();"
        },
        {
          "line": 4661,
          "api": "Parameter",
          "text": "Parameter(builder, parameter_number, shape, name, empty_bools)",
          "line_content": "  return Parameter(builder, parameter_number, shape, name, empty_bools);"
        },
        {
          "line": 570,
          "api": "HloOpcodeString",
          "text": "HloOpcodeString(HloOpcode::kParameter)",
          "line_content": "    if (instr.opcode() == HloOpcodeString(HloOpcode::kParameter)) {"
        },
        {
          "line": 571,
          "api": "parameter_number",
          "text": "instr.parameter_number()",
          "line_content": "      const int64_t index = instr.parameter_number();"
        },
        {
          "line": 572,
          "api": "TF_RET_CHECK",
          "text": "TF_RET_CHECK(index >= 0 && index < param_count)",
          "line_content": "      TF_RET_CHECK(index >= 0 && index < param_count)"
        },
        {
          "line": 4667,
          "api": "Parameter",
          "text": "builder->Parameter(parameter_number, shape, name,\n                            replicated_at_leaf_buffers)",
          "line_content": "  return builder->Parameter(parameter_number, shape, name,"
        },
        {
          "line": 574,
          "api": "shape",
          "text": "instr.shape()",
          "line_content": "      *program_shape.mutable_parameters(index) = Shape(instr.shape());"
        },
        {
          "line": 575,
          "api": "name",
          "text": "instr.name()",
          "line_content": "      *program_shape.mutable_parameter_names(index) = instr.name();"
        },
        {
          "line": 4674,
          "api": "ConstantLiteral",
          "text": "builder->ConstantLiteral(literal)",
          "line_content": "  return builder->ConstantLiteral(literal);"
        },
        {
          "line": 582,
          "api": "empty",
          "text": "instructions_.empty()",
          "line_content": "  TF_RET_CHECK(!instructions_.empty());"
        },
        {
          "line": 583,
          "api": "back",
          "text": "instructions_.back().id()",
          "line_content": "  return GetProgramShape(instructions_.back().id());"
        },
        {
          "line": 4679,
          "api": "builder",
          "text": "operand.builder()->Broadcast(operand, broadcast_sizes)",
          "line_content": "  return operand.builder()->Broadcast(operand, broadcast_sizes);"
        },
        {
          "line": 588,
          "api": "InvalidArgument",
          "text": "InvalidArgument(\"Given root operation is not in this computation.\")",
          "line_content": "    return InvalidArgument(\"Given root operation is not in this computation.\");"
        },
        {
          "line": 4685,
          "api": "builder",
          "text": "operand.builder()->BroadcastInDim(operand, out_dim_size,\n                                           broadcast_dimensions)",
          "line_content": "  return operand.builder()->BroadcastInDim(operand, out_dim_size,"
        },
        {
          "line": 590,
          "api": "handle",
          "text": "root.handle()",
          "line_content": "  return GetProgramShape(root.handle());"
        },
        {
          "line": 596,
          "api": "contains",
          "text": "visited->contains(op_handle)",
          "line_content": "  if (visited->contains(op_handle) || !*is_constant) {"
        },
        {
          "line": 4692,
          "api": "builder",
          "text": "operand.builder()->DynamicBroadcastInDim(\n      operand, output_dimensions, broadcast_dimensions, output_shape)",
          "line_content": "  return operand.builder()->DynamicBroadcastInDim("
        },
        {
          "line": 601,
          "api": "value",
          "text": "LookUpInstructionByHandle(op_handle).value()",
          "line_content": "      *(LookUpInstructionByHandle(op_handle).value());"
        },
        {
          "line": 4697,
          "api": "builder",
          "text": "operand.builder()->UnaryOp(HloOpcode::kCopy, operand)",
          "line_content": "  return operand.builder()->UnaryOp(HloOpcode::kCopy, operand);"
        },
        {
          "line": 603,
          "api": "clear_shape",
          "text": "to_print.clear_shape()",
          "line_content": "  to_print.clear_shape();"
        },
        {
          "line": 604,
          "api": "opcode",
          "text": "instr.opcode()",
          "line_content": "  const HloOpcode opcode = StringToHloOpcode(instr.opcode()).value();"
        },
        {
          "line": 606,
          "api": "std::vector<absl::string_view>(depth, \"  \")",
          "text": "std::vector<absl::string_view>(depth, \"  \")",
          "line_content": "      absl::StrJoin(std::vector<absl::string_view>(depth, \"  \"), \"\");"
        },
        {
          "line": 607,
          "api": "VLOG_IS_ON",
          "text": "VLOG_IS_ON(2)",
          "line_content": "  if (VLOG_IS_ON(2)) {"
        },
        {
          "line": 608,
          "api": "VLOG",
          "text": "VLOG(2)",
          "line_content": "    VLOG(2) << indent << \"Visiting:\";"
        },
        {
          "line": 609,
          "api": "DebugString",
          "text": "to_print.DebugString()",
          "line_content": "    for (const auto& l : absl::StrSplit(to_print.DebugString(), '\\n')) {"
        },
        {
          "line": 610,
          "api": "VLOG",
          "text": "VLOG(2)",
          "line_content": "      VLOG(2) << indent << l;"
        },
        {
          "line": 4702,
          "api": "builder",
          "text": "operand.builder()->Pad(operand, padding_value, padding_config)",
          "line_content": "  return operand.builder()->Pad(operand, padding_value, padding_config);"
        },
        {
          "line": 4707,
          "api": "builder",
          "text": "operand.builder()->PadInDim(operand, padding_value, dimno, pad_lo,\n                                     pad_hi)",
          "line_content": "  return operand.builder()->PadInDim(operand, padding_value, dimno, pad_lo,"
        },
        {
          "line": 615,
          "api": "operand_ids",
          "text": "instr.operand_ids()",
          "line_content": "      for (const int64_t operand_id : instr.operand_ids()) {"
        },
        {
          "line": 616,
          "api": "IsConstantVisitor",
          "text": "IsConstantVisitor(operand_id, depth + 1, visited, is_constant)",
          "line_content": "        IsConstantVisitor(operand_id, depth + 1, visited, is_constant);"
        },
        {
          "line": 4713,
          "api": "builder",
          "text": "operand.builder()->Reshape(operand, dimensions, new_sizes)",
          "line_content": "  return operand.builder()->Reshape(operand, dimensions, new_sizes);"
        },
        {
          "line": 4717,
          "api": "builder",
          "text": "operand.builder()->Reshape(operand, new_sizes)",
          "line_content": "  return operand.builder()->Reshape(operand, new_sizes);"
        },
        {
          "line": 4721,
          "api": "builder",
          "text": "operand.builder()->Reshape(shape, operand)",
          "line_content": "  return operand.builder()->Reshape(shape, operand);"
        },
        {
          "line": 4727,
          "api": "builder",
          "text": "operand.builder()->DynamicReshape(operand, dim_sizes, new_size_bounds,\n                                           dims_are_dynamic)",
          "line_content": "  return operand.builder()->DynamicReshape(operand, dim_sizes, new_size_bounds,"
        },
        {
          "line": 638,
          "api": "custom_call_target",
          "text": "instr.custom_call_target()",
          "line_content": "      if (instr.custom_call_target() == \"SetBound\") {"
        },
        {
          "line": 4734,
          "api": "builder",
          "text": "operand.builder()->Reshape(operand, new_sizes, inferred_dimension)",
          "line_content": "  return operand.builder()->Reshape(operand, new_sizes, inferred_dimension);"
        },
        {
          "line": 4738,
          "api": "builder",
          "text": "operand.builder()->Collapse(operand, dimensions)",
          "line_content": "  return operand.builder()->Collapse(operand, dimensions);"
        },
        {
          "line": 4744,
          "api": "builder",
          "text": "operand.builder()->Slice(operand, start_indices, limit_indices,\n                                  strides)",
          "line_content": "  return operand.builder()->Slice(operand, start_indices, limit_indices,"
        },
        {
          "line": 4750,
          "api": "builder",
          "text": "operand.builder()->SliceInDim(operand, start_index, limit_index,\n                                       stride, dimno)",
          "line_content": "  return operand.builder()->SliceInDim(operand, start_index, limit_index,"
        },
        {
          "line": 656,
          "api": "operand_ids",
          "text": "instr.operand_ids(0)",
          "line_content": "          *(LookUpInstructionByHandle(instr.operand_ids(0)).value());"
        },
        {
          "line": 657,
          "api": "opcode",
          "text": "operand_instr.opcode()",
          "line_content": "      if (HloOpcodeString(HloOpcode::kTuple) == operand_instr.opcode()) {"
        },
        {
          "line": 658,
          "api": "tuple_index",
          "text": "instr.tuple_index()",
          "line_content": "        IsConstantVisitor(operand_instr.operand_ids(instr.tuple_index()),"
        },
        {
          "line": 4756,
          "api": "builder",
          "text": "operand.builder()->DynamicSlice(operand, start_indices, slice_sizes)",
          "line_content": "  return operand.builder()->DynamicSlice(operand, start_indices, slice_sizes);"
        },
        {
          "line": 661,
          "api": "operand_ids",
          "text": "instr.operand_ids()",
          "line_content": "        for (const int64_t operand_id : instr.operand_ids()) {"
        },
        {
          "line": 662,
          "api": "IsConstantVisitor",
          "text": "IsConstantVisitor(operand_id, depth + 1, visited, is_constant)",
          "line_content": "          IsConstantVisitor(operand_id, depth + 1, visited, is_constant);"
        },
        {
          "line": 4761,
          "api": "builder",
          "text": "operand.builder()->DynamicUpdateSlice(operand, update, start_indices)",
          "line_content": "  return operand.builder()->DynamicUpdateSlice(operand, update, start_indices);"
        },
        {
          "line": 667,
          "api": "VLOG_IS_ON",
          "text": "VLOG_IS_ON(1)",
          "line_content": "  if (VLOG_IS_ON(1) && !*is_constant) {"
        },
        {
          "line": 668,
          "api": "VLOG",
          "text": "VLOG(1)",
          "line_content": "    VLOG(1) << indent << \"Non-constant: \";"
        },
        {
          "line": 669,
          "api": "DebugString",
          "text": "to_print.DebugString()",
          "line_content": "    for (const auto& l : absl::StrSplit(to_print.DebugString(), '\\n')) {"
        },
        {
          "line": 670,
          "api": "VLOG",
          "text": "VLOG(1)",
          "line_content": "      VLOG(1) << indent << l;"
        },
        {
          "line": 4766,
          "api": "ConcatInDim",
          "text": "builder->ConcatInDim(operands, dimension)",
          "line_content": "  return builder->ConcatInDim(operands, dimension);"
        },
        {
          "line": 673,
          "api": "insert",
          "text": "visited->insert(op_handle)",
          "line_content": "  visited->insert(op_handle);"
        },
        {
          "line": 4770,
          "api": "builder",
          "text": "pred.builder()->Select(pred, on_true, on_false)",
          "line_content": "  return pred.builder()->Select(pred, on_true, on_false);"
        },
        {
          "line": 4774,
          "api": "Tuple",
          "text": "builder->Tuple(elements)",
          "line_content": "  return builder->Tuple(elements);"
        },
        {
          "line": 680,
          "api": "mutable_frontend_attributes",
          "text": "instr_proto->mutable_frontend_attributes()",
          "line_content": "  auto* frontend_attributes = instr_proto->mutable_frontend_attributes();"
        },
        {
          "line": 681,
          "api": "std::move(value)",
          "text": "std::move(value)",
          "line_content": "  (*frontend_attributes->mutable_map())[attribute] = std::move(value);"
        },
        {
          "line": 682,
          "api": "OkStatus",
          "text": "OkStatus()",
          "line_content": "  return OkStatus();"
        },
        {
          "line": 4778,
          "api": "builder",
          "text": "tuple_data.builder()->GetTupleElement(tuple_data, index)",
          "line_content": "  return tuple_data.builder()->GetTupleElement(tuple_data, index);"
        },
        {
          "line": 686,
          "api": "DCHECK",
          "text": "DCHECK(parent_builder_ != nullptr)",
          "line_content": "  DCHECK(parent_builder_ != nullptr);"
        },
        {
          "line": 687,
          "api": "Build",
          "text": "Build()",
          "line_content": "  auto build_status = Build();"
        },
        {
          "line": 688,
          "api": "ok",
          "text": "build_status.ok()",
          "line_content": "  if (!build_status.ok()) {"
        },
        {
          "line": 689,
          "api": "status",
          "text": "parent_builder_->ReportError(\n        AddStatus(build_status.status(), absl::StrCat(\"error from: \", name_)))",
          "line_content": "    parent_builder_->ReportError("
        },
        {
          "line": 690,
          "api": "absl::StrCat(\"error from: \", name_)",
          "text": "absl::StrCat(\"error from: \", name_)",
          "line_content": "        AddStatus(build_status.status(), absl::StrCat(\"error from: \", name_)));"
        },
        {
          "line": 4783,
          "api": "Compare",
          "text": "Compare(lhs, rhs, broadcast_dimensions, ComparisonDirection::kEq)",
          "line_content": "  return Compare(lhs, rhs, broadcast_dimensions, ComparisonDirection::kEq);"
        },
        {
          "line": 693,
          "api": "value",
          "text": "std::move(build_status).value()",
          "line_content": "  return std::move(build_status).value();"
        },
        {
          "line": 4789,
          "api": "builder",
          "text": "lhs.builder()",
          "line_content": "  auto b = lhs.builder();"
        },
        {
          "line": 4790,
          "api": "element_type",
          "text": "b->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    TF_ASSIGN_OR_RETURN(auto operand_shape, b->GetShape(lhs));\n    auto operand_element_type = operand_shape.element_type();\n    auto compare_type =\n        primitive_util::IsFloatingPointType(operand_element_type)\n            ? Comparison::Type::kFloatTotalOrder\n            : Comparison::DefaultComparisonType(operand_element_type);\n    return Compare(lhs, rhs, broadcast_dimensions, comparison_direction,\n                   compare_type);\n  })",
          "line_content": "  return b->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 4792,
          "api": "element_type",
          "text": "operand_shape.element_type()",
          "line_content": "    auto operand_element_type = operand_shape.element_type();"
        },
        {
          "line": 697,
          "api": "ok",
          "text": "first_error_.ok()",
          "line_content": "  if (!first_error_.ok()) {"
        },
        {
          "line": 4794,
          "api": "primitive_util::IsFloatingPointType(operand_element_type)",
          "text": "primitive_util::IsFloatingPointType(operand_element_type)",
          "line_content": "        primitive_util::IsFloatingPointType(operand_element_type)"
        },
        {
          "line": 699,
          "api": "Dump",
          "text": "first_error_backtrace_.Dump(tsl::DebugWriteToString, &backtrace)",
          "line_content": "    first_error_backtrace_.Dump(tsl::DebugWriteToString, &backtrace);"
        },
        {
          "line": 700,
          "api": "AppendStatus",
          "text": "AppendStatus(first_error_, backtrace)",
          "line_content": "    return AppendStatus(first_error_, backtrace);"
        },
        {
          "line": 4796,
          "api": "Comparison::DefaultComparisonType(operand_element_type)",
          "text": "Comparison::DefaultComparisonType(operand_element_type)",
          "line_content": "            : Comparison::DefaultComparisonType(operand_element_type);"
        },
        {
          "line": 702,
          "api": "OkStatus",
          "text": "OkStatus()",
          "line_content": "  return OkStatus();"
        },
        {
          "line": 4797,
          "api": "Compare",
          "text": "Compare(lhs, rhs, broadcast_dimensions, comparison_direction,\n                   compare_type)",
          "line_content": "    return Compare(lhs, rhs, broadcast_dimensions, comparison_direction,"
        },
        {
          "line": 706,
          "api": "GetCurrentStatus",
          "text": "GetCurrentStatus()",
          "line_content": "  TF_RETURN_IF_ERROR(GetCurrentStatus());"
        },
        {
          "line": 707,
          "api": "back",
          "text": "instructions_.back().id()",
          "line_content": "  return Build(instructions_.back().id(), remove_dynamic_dimensions);"
        },
        {
          "line": 4804,
          "api": "CompareTotalOrder",
          "text": "CompareTotalOrder(lhs, rhs, broadcast_dimensions,\n                           ComparisonDirection::kEq)",
          "line_content": "  return CompareTotalOrder(lhs, rhs, broadcast_dimensions,"
        },
        {
          "line": 713,
          "api": "InvalidArgument",
          "text": "InvalidArgument(\"Given root operation is not in this computation.\")",
          "line_content": "    return InvalidArgument(\"Given root operation is not in this computation.\");"
        },
        {
          "line": 4810,
          "api": "Compare",
          "text": "Compare(lhs, rhs, broadcast_dimensions, ComparisonDirection::kNe)",
          "line_content": "  return Compare(lhs, rhs, broadcast_dimensions, ComparisonDirection::kNe);"
        },
        {
          "line": 715,
          "api": "handle",
          "text": "root.handle()",
          "line_content": "  return Build(root.handle(), remove_dynamic_dimensions);"
        },
        {
          "line": 4815,
          "api": "CompareTotalOrder",
          "text": "CompareTotalOrder(lhs, rhs, broadcast_dimensions,\n                           ComparisonDirection::kNe)",
          "line_content": "  return CompareTotalOrder(lhs, rhs, broadcast_dimensions,"
        },
        {
          "line": 720,
          "api": "GetCurrentStatus",
          "text": "GetCurrentStatus()",
          "line_content": "  TF_RETURN_IF_ERROR(GetCurrentStatus());"
        },
        {
          "line": 4821,
          "api": "Compare",
          "text": "Compare(lhs, rhs, broadcast_dimensions, ComparisonDirection::kGe)",
          "line_content": "  return Compare(lhs, rhs, broadcast_dimensions, ComparisonDirection::kGe);"
        },
        {
          "line": 727,
          "api": "tuple_shapes_size",
          "text": "shape->tuple_shapes_size()",
          "line_content": "      if (shape->tuple_shapes_size() != 0) {"
        },
        {
          "line": 728,
          "api": "tuple_shapes_size",
          "text": "shape->tuple_shapes_size()",
          "line_content": "        for (int i = 0; i < shape->tuple_shapes_size(); ++i) {"
        },
        {
          "line": 729,
          "api": "mutable_tuple_shapes",
          "text": "shape->mutable_tuple_shapes(i)",
          "line_content": "          remove_dynamic_dimension(shape->mutable_tuple_shapes(i));"
        },
        {
          "line": 4826,
          "api": "CompareTotalOrder",
          "text": "CompareTotalOrder(lhs, rhs, broadcast_dimensions,\n                           ComparisonDirection::kGe)",
          "line_content": "  return CompareTotalOrder(lhs, rhs, broadcast_dimensions,"
        },
        {
          "line": 732,
          "api": "dimensions_size",
          "text": "shape->dimensions_size()",
          "line_content": "      for (int64_t i = 0; i < shape->dimensions_size(); ++i) {"
        },
        {
          "line": 733,
          "api": "set_dynamic_dimension",
          "text": "shape->set_dynamic_dimension(i, false)",
          "line_content": "        shape->set_dynamic_dimension(i, false);"
        },
        {
          "line": 736,
          "api": "size",
          "text": "instructions_.size()",
          "line_content": "    for (size_t index = 0; index < instructions_.size(); ++index) {"
        },
        {
          "line": 737,
          "api": "get",
          "text": "instruction_shapes_[index].get()",
          "line_content": "      remove_dynamic_dimension(instruction_shapes_[index].get());"
        },
        {
          "line": 738,
          "api": "mutable_shape",
          "text": "instructions_[index].mutable_shape()",
          "line_content": "      *instructions_[index].mutable_shape() ="
        },
        {
          "line": 739,
          "api": "ToProto",
          "text": "instruction_shapes_[index]->ToProto()",
          "line_content": "          instruction_shapes_[index]->ToProto();"
        },
        {
          "line": 4832,
          "api": "Compare",
          "text": "Compare(lhs, rhs, broadcast_dimensions, ComparisonDirection::kGt)",
          "line_content": "  return Compare(lhs, rhs, broadcast_dimensions, ComparisonDirection::kGt);"
        },
        {
          "line": 4837,
          "api": "CompareTotalOrder",
          "text": "CompareTotalOrder(lhs, rhs, broadcast_dimensions,\n                           ComparisonDirection::kGt)",
          "line_content": "  return CompareTotalOrder(lhs, rhs, broadcast_dimensions,"
        },
        {
          "line": 744,
          "api": "GetNextId",
          "text": "GetNextId()",
          "line_content": "  SetProtoIdAndName(&entry, name_, kNameSeparator, GetNextId());"
        },
        {
          "line": 746,
          "api": "ToProto",
          "text": "program_shape.ToProto()",
          "line_content": "  *entry.mutable_program_shape() = program_shape.ToProto();"
        },
        {
          "line": 747,
          "api": "set_root_id",
          "text": "entry.set_root_id(root_id)",
          "line_content": "  entry.set_root_id(root_id);"
        },
        {
          "line": 4843,
          "api": "Compare",
          "text": "Compare(lhs, rhs, broadcast_dimensions, ComparisonDirection::kLe)",
          "line_content": "  return Compare(lhs, rhs, broadcast_dimensions, ComparisonDirection::kLe);"
        },
        {
          "line": 751,
          "api": "set_name",
          "text": "instruction.set_name(\n        GetFullName(instruction.name(), kNameSeparator, instruction.id()))",
          "line_content": "    instruction.set_name("
        },
        {
          "line": 752,
          "api": "id",
          "text": "instruction.id()",
          "line_content": "        GetFullName(instruction.name(), kNameSeparator, instruction.id()));"
        },
        {
          "line": 753,
          "api": "add_instructions",
          "text": "entry.add_instructions()->Swap(&instruction)",
          "line_content": "    entry.add_instructions()->Swap(&instruction);"
        },
        {
          "line": 4848,
          "api": "CompareTotalOrder",
          "text": "CompareTotalOrder(lhs, rhs, broadcast_dimensions,\n                           ComparisonDirection::kLe)",
          "line_content": "  return CompareTotalOrder(lhs, rhs, broadcast_dimensions,"
        },
        {
          "line": 756,
          "api": "id",
          "text": "entry.id()",
          "line_content": "  XlaComputation computation(entry.id());"
        },
        {
          "line": 757,
          "api": "mutable_proto",
          "text": "computation.mutable_proto()",
          "line_content": "  HloModuleProto* module = computation.mutable_proto();"
        },
        {
          "line": 758,
          "api": "name",
          "text": "entry.name()",
          "line_content": "  module->set_name(entry.name());"
        },
        {
          "line": 759,
          "api": "id",
          "text": "entry.id()",
          "line_content": "  module->set_id(entry.id());"
        },
        {
          "line": 760,
          "api": "name",
          "text": "entry.name()",
          "line_content": "  module->set_entry_computation_name(entry.name());"
        },
        {
          "line": 761,
          "api": "id",
          "text": "entry.id()",
          "line_content": "  module->set_entry_computation_id(entry.id());"
        },
        {
          "line": 762,
          "api": "program_shape",
          "text": "entry.program_shape()",
          "line_content": "  *module->mutable_host_program_shape() = entry.program_shape();"
        },
        {
          "line": 4854,
          "api": "Compare",
          "text": "Compare(lhs, rhs, broadcast_dimensions, ComparisonDirection::kLt)",
          "line_content": "  return Compare(lhs, rhs, broadcast_dimensions, ComparisonDirection::kLt);"
        },
        {
          "line": 764,
          "api": "add_computations",
          "text": "module->add_computations()->Swap(&e.second)",
          "line_content": "    module->add_computations()->Swap(&e.second);"
        },
        {
          "line": 4859,
          "api": "CompareTotalOrder",
          "text": "CompareTotalOrder(lhs, rhs, broadcast_dimensions,\n                           ComparisonDirection::kLt)",
          "line_content": "  return CompareTotalOrder(lhs, rhs, broadcast_dimensions,"
        },
        {
          "line": 766,
          "api": "add_computations",
          "text": "module->add_computations()->Swap(&entry)",
          "line_content": "  module->add_computations()->Swap(&entry);"
        },
        {
          "line": 767,
          "api": "empty",
          "text": "buffer_donors_.empty()",
          "line_content": "  if (!input_output_aliases_.empty() || !buffer_donors_.empty()) {"
        },
        {
          "line": 768,
          "api": "PopulateInputOutputAliasAndBufferDonor",
          "text": "PopulateInputOutputAliasAndBufferDonor(\n        module, program_shape, input_output_aliases_, buffer_donors_)",
          "line_content": "    TF_RETURN_IF_ERROR(PopulateInputOutputAliasAndBufferDonor("
        },
        {
          "line": 4866,
          "api": "builder",
          "text": "lhs.builder()->BinaryOp(HloOpcode::kCompare, lhs, rhs,\n                                 broadcast_dimensions, direction)",
          "line_content": "  return lhs.builder()->BinaryOp(HloOpcode::kCompare, lhs, rhs,"
        },
        {
          "line": 773,
          "api": "clear",
          "text": "this->instructions_.clear()",
          "line_content": "  this->instructions_.clear();"
        },
        {
          "line": 774,
          "api": "clear",
          "text": "this->instruction_shapes_.clear()",
          "line_content": "  this->instruction_shapes_.clear();"
        },
        {
          "line": 775,
          "api": "clear",
          "text": "this->handle_to_index_.clear()",
          "line_content": "  this->handle_to_index_.clear();"
        },
        {
          "line": 776,
          "api": "clear",
          "text": "this->embedded_.clear()",
          "line_content": "  this->embedded_.clear();"
        },
        {
          "line": 777,
          "api": "clear",
          "text": "this->parameter_numbers_.clear()",
          "line_content": "  this->parameter_numbers_.clear();"
        },
        {
          "line": 4873,
          "api": "builder",
          "text": "lhs.builder()->BinaryOp(HloOpcode::kCompare, lhs, rhs,\n                                 broadcast_dimensions, direction, compare_type)",
          "line_content": "  return lhs.builder()->BinaryOp(HloOpcode::kCompare, lhs, rhs,"
        },
        {
          "line": 779,
          "api": "std::move(computation)",
          "text": "std::move(computation)",
          "line_content": "  return std::move(computation);"
        },
        {
          "line": 4878,
          "api": "Compare",
          "text": "Compare(lhs, rhs, {}, direction)",
          "line_content": "  return Compare(lhs, rhs, {}, direction);"
        },
        {
          "line": 788,
          "api": "result",
          "text": "program_shape.result()",
          "line_content": "  HloInputOutputAliasConfig io_alias_config(program_shape.result());"
        },
        {
          "line": 4884,
          "api": "builder",
          "text": "lhs.builder()->Dot(lhs, rhs, precision_config, preferred_element_type)",
          "line_content": "  return lhs.builder()->Dot(lhs, rhs, precision_config, preferred_element_type);"
        },
        {
          "line": 795,
          "api": "parameters_size",
          "text": "program_shape.parameters_size()",
          "line_content": "    if (alias.param_number >= program_shape.parameters_size()) {"
        },
        {
          "line": 796,
          "api": "parameters_size",
          "text": "InvalidArgument(\"Invalid parameter number %ld (total %ld)\",\n                             alias.param_number,\n                             program_shape.parameters_size())",
          "line_content": "      return InvalidArgument(\"Invalid parameter number %ld (total %ld)\","
        },
        {
          "line": 4891,
          "api": "builder",
          "text": "lhs.builder()->DotGeneral(lhs, rhs, dimension_numbers,\n                                   precision_config, preferred_element_type)",
          "line_content": "  return lhs.builder()->DotGeneral(lhs, rhs, dimension_numbers,"
        },
        {
          "line": 798,
          "api": "parameters_size",
          "text": "program_shape.parameters_size()",
          "line_content": "                             program_shape.parameters_size());"
        },
        {
          "line": 800,
          "api": "parameters",
          "text": "program_shape.parameters(alias.param_number)",
          "line_content": "    const Shape& parameter_shape = program_shape.parameters(alias.param_number);"
        },
        {
          "line": 801,
          "api": "ShapeUtil::IndexIsValid(parameter_shape, alias.param_index)",
          "text": "ShapeUtil::IndexIsValid(parameter_shape, alias.param_index)",
          "line_content": "    if (!ShapeUtil::IndexIsValid(parameter_shape, alias.param_index)) {"
        },
        {
          "line": 802,
          "api": "ToString",
          "text": "InvalidArgument(\"Invalid parameter %ld index: %s\",\n                             alias.param_number,\n                             alias.param_index.ToString().c_str())",
          "line_content": "      return InvalidArgument(\"Invalid parameter %ld index: %s\","
        },
        {
          "line": 804,
          "api": "ToString",
          "text": "alias.param_index.ToString().c_str()",
          "line_content": "                             alias.param_index.ToString().c_str());"
        },
        {
          "line": 4901,
          "api": "builder",
          "text": "lhs.builder()->SparseDot(lhs, rhs, sparse_meta, sparsity,\n                                  dimension_numbers, precision_config,\n                                  preferred_element_type)",
          "line_content": "  return lhs.builder()->SparseDot(lhs, rhs, sparse_meta, sparsity,"
        },
        {
          "line": 806,
          "api": "SetUpAlias",
          "text": "io_alias_config.SetUpAlias(\n        alias.output_index, alias.param_number, alias.param_index, alias.kind)",
          "line_content": "    TF_RETURN_IF_ERROR(io_alias_config.SetUpAlias("
        },
        {
          "line": 809,
          "api": "ToProto",
          "text": "io_alias_config.ToProto()",
          "line_content": "  *module->mutable_input_output_alias() = io_alias_config.ToProto();"
        },
        {
          "line": 814,
          "api": "parameters_size",
          "text": "program_shape.parameters_size()",
          "line_content": "    if (donor.param_number >= program_shape.parameters_size()) {"
        },
        {
          "line": 815,
          "api": "parameters_size",
          "text": "InvalidArgument(\"Invalid parameter number %ld (total %ld)\",\n                             donor.param_number,\n                             program_shape.parameters_size())",
          "line_content": "      return InvalidArgument(\"Invalid parameter number %ld (total %ld)\","
        },
        {
          "line": 4911,
          "api": "builder",
          "text": "lhs.builder()->Conv(lhs, rhs, window_strides, padding,\n                             feature_group_count, batch_group_count,\n                             precision_config, preferred_element_type)",
          "line_content": "  return lhs.builder()->Conv(lhs, rhs, window_strides, padding,"
        },
        {
          "line": 817,
          "api": "parameters_size",
          "text": "program_shape.parameters_size()",
          "line_content": "                             program_shape.parameters_size());"
        },
        {
          "line": 819,
          "api": "parameters",
          "text": "program_shape.parameters(donor.param_number)",
          "line_content": "    const Shape& parameter_shape = program_shape.parameters(donor.param_number);"
        },
        {
          "line": 820,
          "api": "ShapeUtil::IndexIsValid(parameter_shape, donor.param_index)",
          "text": "ShapeUtil::IndexIsValid(parameter_shape, donor.param_index)",
          "line_content": "    if (!ShapeUtil::IndexIsValid(parameter_shape, donor.param_index)) {"
        },
        {
          "line": 821,
          "api": "ToString",
          "text": "InvalidArgument(\"Invalid parameter %ld index: %s\",\n                             donor.param_number,\n                             donor.param_index.ToString().c_str())",
          "line_content": "      return InvalidArgument(\"Invalid parameter %ld index: %s\","
        },
        {
          "line": 823,
          "api": "ToString",
          "text": "donor.param_index.ToString().c_str()",
          "line_content": "                             donor.param_index.ToString().c_str());"
        },
        {
          "line": 825,
          "api": "ParameterHasAlias",
          "text": "io_alias_config.ParameterHasAlias(donor.param_number,\n                                          donor.param_index)",
          "line_content": "    if (io_alias_config.ParameterHasAlias(donor.param_number,"
        },
        {
          "line": 4922,
          "api": "builder",
          "text": "lhs.builder()->ConvWithGeneralPadding(\n      lhs, rhs, window_strides, padding, feature_group_count, batch_group_count,\n      precision_config, preferred_element_type)",
          "line_content": "  return lhs.builder()->ConvWithGeneralPadding("
        },
        {
          "line": 827,
          "api": "ToString",
          "text": "InvalidArgument(\n          \"Parameter %ld index %s is already aliased with one output, thus it \"\n          \"cannot be added as a buffer donor for any output.\",\n          donor.param_number, donor.param_index.ToString().c_str())",
          "line_content": "      return InvalidArgument("
        },
        {
          "line": 830,
          "api": "ToString",
          "text": "donor.param_index.ToString().c_str()",
          "line_content": "          donor.param_number, donor.param_index.ToString().c_str());"
        },
        {
          "line": 832,
          "api": "AddBufferDonor",
          "text": "buffer_donor_config.AddBufferDonor(donor.param_number,\n                                                          donor.param_index)",
          "line_content": "    TF_RETURN_IF_ERROR(buffer_donor_config.AddBufferDonor(donor.param_number,"
        },
        {
          "line": 835,
          "api": "ToProto",
          "text": "buffer_donor_config.ToProto()",
          "line_content": "  *module->mutable_buffer_donor() = buffer_donor_config.ToProto();"
        },
        {
          "line": 837,
          "api": "OkStatus",
          "text": "OkStatus()",
          "line_content": "  return OkStatus();"
        },
        {
          "line": 4933,
          "api": "builder",
          "text": "lhs.builder()->ConvWithGeneralDimensions(\n      lhs, rhs, window_strides, padding, dimension_numbers, feature_group_count,\n      batch_group_count, precision_config, preferred_element_type)",
          "line_content": "  return lhs.builder()->ConvWithGeneralDimensions("
        },
        {
          "line": 843,
          "api": "rank",
          "text": "ReportErrorOrReturn([&]() -> absl::StatusOr<XlaOp> {\n    TF_ASSIGN_OR_RETURN(const Shape* operand_shape, GetShapePtr(operand));\n    TF_ASSIGN_OR_RETURN(const Shape* output_dimensions_shape,\n                        GetShapePtr(output_dimensions));\n\n    if (!output_dimensions_shape->IsInteger()) {\n      return InvalidArgument(\"output_dimensions must be an integer type %s\",\n                             output_dimensions_shape->ToString());\n    }\n\n    if (output_dimensions_shape->rank() != 1) {\n      return InvalidArgument(\"output_dimensions must be rank 1 but got rank %d\",\n                             output_dimensions_shape->rank());\n    }\n\n    int64_t operand_rank = operand_shape->rank();\n    int64_t result_rank = output_shape.rank();\n    int64_t broadcast_dimensions_size = broadcast_dimensions.size();\n    if (broadcast_dimensions_size != operand_rank) {\n      return InvalidArgument(\n          \"broadcast_dimensions size (%d) does not match operand rank (%d)\",\n          broadcast_dimensions_size, operand_rank);\n    }\n\n    if (result_rank < operand_rank) {\n      return InvalidArgument(\"result rank (%d) is less than operand rank (%d)\",\n                             result_rank, operand_rank);\n    }\n\n    for (int64_t i = 0; i != broadcast_dimensions_size; ++i) {\n      int64_t dim_index = broadcast_dimensions[i];\n      if (dim_index < 0 || dim_index >= result_rank) {\n        return InvalidArgument(\n            \"broadcast_dimensions contains invalid value %d for result with \"\n            \"rank %d\",\n            dim_index, result_rank);\n      }\n\n      int64_t dim_size = operand_shape->dimensions(i);\n      int64_t result_dim_size = output_shape.dimensions(dim_index);\n\n      if (dim_size != 1 && dim_size != result_dim_size &&\n          dim_size != Shape::kUnboundedSize) {\n        return InvalidArgument(\n            \"size of operand dimension %d (%d) is not compatible with size of \"\n            \"result dimension %d (%d)\",\n            i, dim_size, dim_index, result_dim_size);\n      }\n    }\n\n    return xla::CustomCall(\n        operand.builder(), \"mhlo.dynamic_broadcast_in_dim\",\n        /*operands=*/{operand, output_dimensions},\n        /*shape=*/output_shape,\n        /*opaque=*/\n        absl::StrCat(\"{broadcast_dimensions=[\",\n                     absl::StrJoin(broadcast_dimensions, \",\"), \"]}\"));\n  })",
          "line_content": "  return ReportErrorOrReturn([&]() -> absl::StatusOr<XlaOp> {"
        },
        {
          "line": 848,
          "api": "IsInteger",
          "text": "output_dimensions_shape->IsInteger()",
          "line_content": "    if (!output_dimensions_shape->IsInteger()) {"
        },
        {
          "line": 849,
          "api": "ToString",
          "text": "InvalidArgument(\"output_dimensions must be an integer type %s\",\n                             output_dimensions_shape->ToString())",
          "line_content": "      return InvalidArgument(\"output_dimensions must be an integer type %s\","
        },
        {
          "line": 850,
          "api": "ToString",
          "text": "output_dimensions_shape->ToString()",
          "line_content": "                             output_dimensions_shape->ToString());"
        },
        {
          "line": 4945,
          "api": "builder",
          "text": "lhs.builder()->ConvGeneral(\n      lhs, rhs, window_strides, padding, dimension_numbers, feature_group_count,\n      batch_group_count, precision_config, preferred_element_type)",
          "line_content": "  return lhs.builder()->ConvGeneral("
        },
        {
          "line": 853,
          "api": "rank",
          "text": "output_dimensions_shape->rank()",
          "line_content": "    if (output_dimensions_shape->rank() != 1) {"
        },
        {
          "line": 854,
          "api": "rank",
          "text": "InvalidArgument(\"output_dimensions must be rank 1 but got rank %d\",\n                             output_dimensions_shape->rank())",
          "line_content": "      return InvalidArgument(\"output_dimensions must be rank 1 but got rank %d\","
        },
        {
          "line": 855,
          "api": "rank",
          "text": "output_dimensions_shape->rank()",
          "line_content": "                             output_dimensions_shape->rank());"
        },
        {
          "line": 858,
          "api": "rank",
          "text": "operand_shape->rank()",
          "line_content": "    int64_t operand_rank = operand_shape->rank();"
        },
        {
          "line": 859,
          "api": "rank",
          "text": "output_shape.rank()",
          "line_content": "    int64_t result_rank = output_shape.rank();"
        },
        {
          "line": 860,
          "api": "size",
          "text": "broadcast_dimensions.size()",
          "line_content": "    int64_t broadcast_dimensions_size = broadcast_dimensions.size();"
        },
        {
          "line": 862,
          "api": "InvalidArgument",
          "text": "InvalidArgument(\n          \"broadcast_dimensions size (%d) does not match operand rank (%d)\",\n          broadcast_dimensions_size, operand_rank)",
          "line_content": "      return InvalidArgument("
        },
        {
          "line": 4960,
          "api": "builder",
          "text": "lhs.builder()->ConvGeneralDilated(\n      lhs, rhs, window_strides, padding, lhs_dilation, rhs_dilation,\n      dimension_numbers, feature_group_count, batch_group_count,\n      precision_config, preferred_element_type, window_reversal)",
          "line_content": "  return lhs.builder()->ConvGeneralDilated("
        },
        {
          "line": 868,
          "api": "InvalidArgument",
          "text": "InvalidArgument(\"result rank (%d) is less than operand rank (%d)\",\n                             result_rank, operand_rank)",
          "line_content": "      return InvalidArgument(\"result rank (%d) is less than operand rank (%d)\","
        },
        {
          "line": 875,
          "api": "InvalidArgument",
          "text": "InvalidArgument(\n            \"broadcast_dimensions contains invalid value %d for result with \"\n            \"rank %d\",\n            dim_index, result_rank)",
          "line_content": "        return InvalidArgument("
        },
        {
          "line": 4976,
          "api": "builder",
          "text": "lhs.builder()->DynamicConvInputGrad(\n      input_sizes, lhs, rhs, window_strides, padding, lhs_dilation,\n      rhs_dilation, dimension_numbers, feature_group_count, batch_group_count,\n      precision_config, padding_type, preferred_element_type)",
          "line_content": "  return lhs.builder()->DynamicConvInputGrad("
        },
        {
          "line": 881,
          "api": "dimensions",
          "text": "operand_shape->dimensions(i)",
          "line_content": "      int64_t dim_size = operand_shape->dimensions(i);"
        },
        {
          "line": 882,
          "api": "dimensions",
          "text": "output_shape.dimensions(dim_index)",
          "line_content": "      int64_t result_dim_size = output_shape.dimensions(dim_index);"
        },
        {
          "line": 886,
          "api": "InvalidArgument",
          "text": "InvalidArgument(\n            \"size of operand dimension %d (%d) is not compatible with size of \"\n            \"result dimension %d (%d)\",\n            i, dim_size, dim_index, result_dim_size)",
          "line_content": "        return InvalidArgument("
        },
        {
          "line": 893,
          "api": "builder",
          "text": "xla::CustomCall(\n        operand.builder(), \"mhlo.dynamic_broadcast_in_dim\",\n        /*operands=*/{operand, output_dimensions},\n        /*shape=*/output_shape,\n        /*opaque=*/\n        absl::StrCat(\"{broadcast_dimensions=[\",\n                     absl::StrJoin(broadcast_dimensions, \",\"), \"]}\"))",
          "line_content": "    return xla::CustomCall("
        },
        {
          "line": 894,
          "api": "builder",
          "text": "operand.builder()",
          "line_content": "        operand.builder(), \"mhlo.dynamic_broadcast_in_dim\","
        },
        {
          "line": 4992,
          "api": "builder",
          "text": "activations.builder()->DynamicConvKernelGrad(\n      activations, gradients, window_strides, padding, lhs_dilation,\n      rhs_dilation, dimension_numbers, feature_group_count, batch_group_count,\n      precision_config, padding_type, preferred_element_type)",
          "line_content": "  return activations.builder()->DynamicConvKernelGrad("
        },
        {
          "line": 898,
          "api": "absl::StrCat(\"{broadcast_dimensions=[\",\n                     absl::StrJoin(broadcast_dimensions, \",\"), \"]}\")",
          "text": "absl::StrCat(\"{broadcast_dimensions=[\",\n                     absl::StrJoin(broadcast_dimensions, \",\"), \"]}\")",
          "line_content": "        absl::StrCat(\"{broadcast_dimensions=[\","
        },
        {
          "line": 899,
          "api": "absl::StrJoin(broadcast_dimensions, \",\")",
          "text": "absl::StrJoin(broadcast_dimensions, \",\")",
          "line_content": "                     absl::StrJoin(broadcast_dimensions, \",\"), \"]}\"));"
        },
        {
          "line": 906,
          "api": "TF_RETURN_IF_ERROR",
          "text": "TF_RETURN_IF_ERROR(first_error_)",
          "line_content": "  TF_RETURN_IF_ERROR(first_error_);"
        },
        {
          "line": 909,
          "api": "ToProto",
          "text": "shape.ToProto()",
          "line_content": "  *instr.mutable_shape() = shape.ToProto();"
        },
        {
          "line": 911,
          "api": "add_dimensions",
          "text": "instr.add_dimensions(dim)",
          "line_content": "    instr.add_dimensions(dim);"
        },
        {
          "line": 5008,
          "api": "builder",
          "text": "lhs.builder()->DynamicConvForward(\n      lhs, rhs, window_strides, padding, lhs_dilation, rhs_dilation,\n      dimension_numbers, feature_group_count, batch_group_count,\n      precision_config, padding_type, preferred_element_type)",
          "line_content": "  return lhs.builder()->DynamicConvForward("
        },
        {
          "line": 915,
          "api": "is_unbounded_dynamic",
          "text": "shape.is_unbounded_dynamic()",
          "line_content": "  TF_RET_CHECK(!shape.is_unbounded_dynamic())"
        },
        {
          "line": 917,
          "api": "rank",
          "text": "shape.rank()",
          "line_content": "  for (int64_t i = 0; i < shape.rank(); i++) {"
        },
        {
          "line": 918,
          "api": "absl::c_find(broadcast_dimensions, i)",
          "text": "absl::c_find(broadcast_dimensions, i)",
          "line_content": "    if (auto it = absl::c_find(broadcast_dimensions, i);"
        },
        {
          "line": 919,
          "api": "end",
          "text": "broadcast_dimensions.end()",
          "line_content": "        it != broadcast_dimensions.end()) {"
        },
        {
          "line": 5016,
          "api": "builder",
          "text": "operand.builder()->Fft(operand, fft_type, fft_length)",
          "line_content": "  return operand.builder()->Fft(operand, fft_type, fft_length);"
        },
        {
          "line": 922,
          "api": "begin",
          "text": "operand_shape->is_bounded_dynamic_dimension(\n                       it - broadcast_dimensions.begin())",
          "line_content": "      TF_RET_CHECK(operand_shape->is_bounded_dynamic_dimension("
        },
        {
          "line": 923,
          "api": "begin",
          "text": "broadcast_dimensions.begin()",
          "line_content": "                       it - broadcast_dimensions.begin()) =="
        },
        {
          "line": 924,
          "api": "is_bounded_dynamic_dimension",
          "text": "shape.is_bounded_dynamic_dimension(i)",
          "line_content": "                   shape.is_bounded_dynamic_dimension(i))"
        },
        {
          "line": 925,
          "api": "ToString",
          "text": "shape.ToString()",
          "line_content": "          << \" i: \" << i << \", shape: \" << shape.ToString()"
        },
        {
          "line": 926,
          "api": "ToString",
          "text": "operand_shape->ToString()",
          "line_content": "          << \", operand_shape: \" << operand_shape->ToString();"
        },
        {
          "line": 5022,
          "api": "builder",
          "text": "a.builder()",
          "line_content": "  XlaBuilder* builder = a.builder();"
        },
        {
          "line": 5023,
          "api": "set_left_side",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    TF_ASSIGN_OR_RETURN(const Shape* a_shape, builder->GetShapePtr(a));\n    TF_ASSIGN_OR_RETURN(const Shape* b_shape, builder->GetShapePtr(b));\n    TriangularSolveOptions options;\n    options.set_left_side(left_side);\n    options.set_lower(lower);\n    options.set_unit_diagonal(unit_diagonal);\n    options.set_transpose_a(transpose_a);\n    TF_ASSIGN_OR_RETURN(Shape shape, ShapeInference::InferTriangularSolveShape(\n                                         *a_shape, *b_shape, options));\n    return builder->TriangularSolveInternal(shape, a, b, std::move(options));\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 929,
          "api": "is_static_dimension",
          "text": "shape.is_static_dimension(i)",
          "line_content": "      TF_RET_CHECK(shape.is_static_dimension(i));"
        },
        {
          "line": 5027,
          "api": "set_left_side",
          "text": "options.set_left_side(left_side)",
          "line_content": "    options.set_left_side(left_side);"
        },
        {
          "line": 932,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "  return AddInstruction(std::move(instr), HloOpcode::kBroadcast, {operand});"
        },
        {
          "line": 5028,
          "api": "set_lower",
          "text": "options.set_lower(lower)",
          "line_content": "    options.set_lower(lower);"
        },
        {
          "line": 5029,
          "api": "set_unit_diagonal",
          "text": "options.set_unit_diagonal(unit_diagonal)",
          "line_content": "    options.set_unit_diagonal(unit_diagonal);"
        },
        {
          "line": 5030,
          "api": "set_transpose_a",
          "text": "options.set_transpose_a(transpose_a)",
          "line_content": "    options.set_transpose_a(transpose_a);"
        },
        {
          "line": 937,
          "api": "TF_RETURN_IF_ERROR",
          "text": "TF_RETURN_IF_ERROR(first_error_)",
          "line_content": "  TF_RETURN_IF_ERROR(first_error_);"
        },
        {
          "line": 5033,
          "api": "std::move(options)",
          "text": "std::move(options)",
          "line_content": "    return builder->TriangularSolveInternal(shape, a, b, std::move(options));"
        },
        {
          "line": 941,
          "api": "ShapeUtil::IsScalar(*operand_shape)",
          "text": "ShapeUtil::IsScalar(*operand_shape)",
          "line_content": "  CHECK(ShapeUtil::IsScalar(*operand_shape) ||"
        },
        {
          "line": 942,
          "api": "rank",
          "text": "output_shape.rank()",
          "line_content": "        operand_shape->rank() == output_shape.rank());"
        },
        {
          "line": 5038,
          "api": "builder",
          "text": "a.builder()",
          "line_content": "  XlaBuilder* builder = a.builder();"
        },
        {
          "line": 944,
          "api": "element_type",
          "text": "operand_shape->element_type()",
          "line_content": "      ShapeUtil::ChangeElementType(output_shape, operand_shape->element_type());"
        },
        {
          "line": 5039,
          "api": "ReportErrorOrReturn",
          "text": "builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    TF_ASSIGN_OR_RETURN(const Shape* a_shape, builder->GetShapePtr(a));\n    TF_ASSIGN_OR_RETURN(Shape shape,\n                        ShapeInference::InferCholeskyShape(*a_shape));\n    return builder->CholeskyInternal(shape, a, lower);\n  })",
          "line_content": "  return builder->ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 947,
          "api": "ShapeUtil::IsScalar(*operand_shape)",
          "text": "ShapeUtil::IsScalar(*operand_shape)",
          "line_content": "  if (ShapeUtil::IsScalar(*operand_shape)) {"
        },
        {
          "line": 948,
          "api": "ShapeUtil::MakeStaticShape(broadcast_shape)",
          "text": "ShapeUtil::MakeStaticShape(broadcast_shape)",
          "line_content": "    return InDimBroadcast(ShapeUtil::MakeStaticShape(broadcast_shape), operand,"
        },
        {
          "line": 5043,
          "api": "CholeskyInternal",
          "text": "builder->CholeskyInternal(shape, a, lower)",
          "line_content": "    return builder->CholeskyInternal(shape, a, lower);"
        },
        {
          "line": 5049,
          "api": "Infeed",
          "text": "builder->Infeed(shape, config)",
          "line_content": "  return builder->Infeed(shape, config);"
        },
        {
          "line": 956,
          "api": "rank",
          "text": "operand_shape->rank()",
          "line_content": "  for (int i = 0; i < operand_shape->rank(); i++) {"
        },
        {
          "line": 957,
          "api": "dimensions",
          "text": "output_shape.dimensions(i)",
          "line_content": "    if (operand_shape->dimensions(i) == output_shape.dimensions(i)) {"
        },
        {
          "line": 958,
          "api": "push_back",
          "text": "broadcast_dimensions.push_back(i)",
          "line_content": "      broadcast_dimensions.push_back(i);"
        },
        {
          "line": 959,
          "api": "dimensions",
          "text": "operand_shape->dimensions(i)",
          "line_content": "      reshaped_dimensions.push_back(operand_shape->dimensions(i));"
        },
        {
          "line": 960,
          "api": "push_back",
          "text": "reshaped_dynamic_dimensions.push_back(\n          operand_shape->is_dynamic_dimension(i))",
          "line_content": "      reshaped_dynamic_dimensions.push_back("
        },
        {
          "line": 961,
          "api": "is_dynamic_dimension",
          "text": "operand_shape->is_dynamic_dimension(i)",
          "line_content": "          operand_shape->is_dynamic_dimension(i));"
        },
        {
          "line": 5054,
          "api": "builder",
          "text": "operand.builder()->Outfeed(operand, shape_with_layout, outfeed_config)",
          "line_content": "  return operand.builder()->Outfeed(operand, shape_with_layout, outfeed_config);"
        },
        {
          "line": 963,
          "api": "dimensions",
          "text": "operand_shape->dimensions(i)",
          "line_content": "      TF_RET_CHECK(operand_shape->dimensions(i) == 1 &&"
        },
        {
          "line": 964,
          "api": "is_static_dimension",
          "text": "operand_shape->is_static_dimension(i)",
          "line_content": "                   operand_shape->is_static_dimension(i))"
        },
        {
          "line": 5059,
          "api": "Call",
          "text": "builder->Call(computation, operands)",
          "line_content": "  return builder->Call(computation, operands);"
        },
        {
          "line": 969,
          "api": "set_dynamic_dimension",
          "text": "broadcast_shape.set_dynamic_dimension(\n        i, operand_shape->is_dynamic_dimension(i))",
          "line_content": "    broadcast_shape.set_dynamic_dimension("
        },
        {
          "line": 970,
          "api": "is_dynamic_dimension",
          "text": "operand_shape->is_dynamic_dimension(i)",
          "line_content": "        i, operand_shape->is_dynamic_dimension(i));"
        },
        {
          "line": 974,
          "api": "element_type",
          "text": "operand_shape->element_type()",
          "line_content": "      ShapeUtil::MakeShape(operand_shape->element_type(), reshaped_dimensions,"
        },
        {
          "line": 5070,
          "api": "CustomCall",
          "text": "builder->CustomCall(call_target_name, operands, shape, opaque,\n                             /*operand_shapes_with_layout=*/std::nullopt,\n                             has_side_effect, output_operand_aliasing, literal,\n                             /*window=*/std::nullopt, /*dnums=*/std::nullopt,\n                             schedule, api_version)",
          "line_content": "  return builder->CustomCall(call_target_name, operands, shape, opaque,"
        },
        {
          "line": 983,
          "api": "TF_ASSIGN_OR_RETURN",
          "text": "TF_ASSIGN_OR_RETURN(\n        reshaped_operand,\n        ReshapeInternal(reshaped_shape, operand, /*inferred_dimension=*/-1))",
          "line_content": "    TF_ASSIGN_OR_RETURN("
        },
        {
          "line": 985,
          "api": "ReshapeInternal",
          "text": "ReshapeInternal(reshaped_shape, operand, /*inferred_dimension=*/-1)",
          "line_content": "        ReshapeInternal(reshaped_shape, operand, /*inferred_dimension=*/-1));"
        },
        {
          "line": 988,
          "api": "InDimBroadcast",
          "text": "InDimBroadcast(broadcast_shape, reshaped_operand,\n                        broadcast_dimensions)",
          "line_content": "  return InDimBroadcast(broadcast_shape, reshaped_operand,"
        },
        {
          "line": 5085,
          "api": "CustomCall",
          "text": "builder->CustomCall(\n      call_target_name, operands, computation, shape, opaque,\n      /*operand_shapes_with_layout=*/std::nullopt, has_side_effect,\n      output_operand_aliasing, literal, schedule, api_version)",
          "line_content": "  return builder->CustomCall("
        },
        {
          "line": 993,
          "api": "ReportErrorOrReturn",
          "text": "ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    TF_ASSIGN_OR_RETURN(const Shape* operand_shape, GetShapePtr(operand));\n    TF_ASSIGN_OR_RETURN(\n        Shape shape, ShapeInference::InferUnaryOpShape(unop, *operand_shape));\n    return AddOpWithShape(unop, shape, {operand});\n  })",
          "line_content": "  return ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 997,
          "api": "AddOpWithShape",
          "text": "AddOpWithShape(unop, shape, {operand})",
          "line_content": "    return AddOpWithShape(unop, shape, {operand});"
        },
        {
          "line": 5100,
          "api": "CustomCall",
          "text": "builder->CustomCall(\n      call_target_name, operands, shape, opaque, operand_shapes_with_layout,\n      has_side_effect, output_operand_aliasing, literal,\n      /*window=*/std::nullopt, /*dnums=*/std::nullopt, schedule, api_version)",
          "line_content": "  return builder->CustomCall("
        },
        {
          "line": 1009,
          "api": "ShapeUtil::IsScalar(origin_shape)",
          "text": "ShapeUtil::IsScalar(origin_shape)",
          "line_content": "  if (ShapeUtil::IsScalar(origin_shape)) {"
        },
        {
          "line": 1013,
          "api": "rank",
          "text": "origin_shape.rank()",
          "line_content": "  const int64_t origin_rank = origin_shape.rank();"
        },
        {
          "line": 1014,
          "api": "rank",
          "text": "target_shape.rank()",
          "line_content": "  const int64_t target_rank = target_shape.rank();"
        },
        {
          "line": 5116,
          "api": "empty",
          "text": "operand_shapes_with_layout.empty()",
          "line_content": "  if (!operand_shapes_with_layout.empty()) {"
        },
        {
          "line": 1022,
          "api": "dimensions",
          "text": "target_shape.dimensions()",
          "line_content": "  absl::Span<const int64_t> target_dimensions = target_shape.dimensions();"
        },
        {
          "line": 1023,
          "api": "begin",
          "text": "target_dimensions.begin()",
          "line_content": "  std::vector<int64_t> target_size{target_dimensions.begin(),"
        },
        {
          "line": 1024,
          "api": "end",
          "text": "target_dimensions.end()",
          "line_content": "                                   target_dimensions.end()};"
        },
        {
          "line": 5119,
          "api": "CustomCall",
          "text": "builder->CustomCall(call_target_name, operands, shape, opaque,\n                             maybe_operand_shapes, has_side_effect,\n                             output_operand_aliasing, literal, window, dnums,\n                             schedule, api_version)",
          "line_content": "  return builder->CustomCall(call_target_name, operands, shape, opaque,"
        },
        {
          "line": 1027,
          "api": "dimensions",
          "text": "origin_shape.dimensions(origin_dim)",
          "line_content": "    target_size[target_dim] = origin_shape.dimensions(origin_dim);"
        },
        {
          "line": 1029,
          "api": "xla::BroadcastInDim(origin, target_size, broadcast_dimensions)",
          "text": "xla::BroadcastInDim(origin, target_size, broadcast_dimensions)",
          "line_content": "  return xla::BroadcastInDim(origin, target_size, broadcast_dimensions);"
        },
        {
          "line": 5126,
          "api": "builder",
          "text": "operand.builder()->OptimizationBarrier(operand)",
          "line_content": "  return operand.builder()->OptimizationBarrier(operand);"
        },
        {
          "line": 5131,
          "api": "builder",
          "text": "real.builder()->BinaryOp(HloOpcode::kComplex, real, imag,\n                                  broadcast_dimensions)",
          "line_content": "  return real.builder()->BinaryOp(HloOpcode::kComplex, real, imag,"
        },
        {
          "line": 1040,
          "api": "absl::Span<const int32_t>({1})",
          "text": "absl::Span<const int32_t>({1})",
          "line_content": "      pad_count, xla::ConstantR1(builder, absl::Span<const int32_t>({1})));"
        },
        {
          "line": 5136,
          "api": "Imag",
          "text": "Imag(operand)",
          "line_content": "  return Complex(Real(operand), Neg(Imag(operand)));"
        },
        {
          "line": 1042,
          "api": "push_back",
          "text": "op_dims.push_back(\n        op_shape->is_static_dimension(i)\n            ? ConstantR1(builder,\n                         absl::Span<const int32_t>(\n                             {static_cast<int32_t>(op_shape->dimensions(i))}))\n            : xla::Reshape(xla::GetDimensionSize(op, i), {1}))",
          "line_content": "    op_dims.push_back("
        },
        {
          "line": 1043,
          "api": "is_static_dimension",
          "text": "op_shape->is_static_dimension(i)",
          "line_content": "        op_shape->is_static_dimension(i)"
        },
        {
          "line": 1044,
          "api": "dimensions",
          "text": "ConstantR1(builder,\n                         absl::Span<const int32_t>(\n                             {static_cast<int32_t>(op_shape->dimensions(i))}))",
          "line_content": "            ? ConstantR1(builder,"
        },
        {
          "line": 1045,
          "api": "dimensions",
          "text": "absl::Span<const int32_t>(\n                             {static_cast<int32_t>(op_shape->dimensions(i))})",
          "line_content": "                         absl::Span<const int32_t>("
        },
        {
          "line": 1046,
          "api": "dimensions",
          "text": "op_shape->dimensions(i)",
          "line_content": "                             {static_cast<int32_t>(op_shape->dimensions(i))}))"
        },
        {
          "line": 1047,
          "api": "xla::GetDimensionSize(op, i)",
          "text": "xla::GetDimensionSize(op, i)",
          "line_content": "            : xla::Reshape(xla::GetDimensionSize(op, i), {1}));"
        },
        {
          "line": 5141,
          "api": "builder",
          "text": "lhs.builder()->BinaryOp(HloOpcode::kAdd, lhs, rhs,\n                                 broadcast_dimensions)",
          "line_content": "  return lhs.builder()->BinaryOp(HloOpcode::kAdd, lhs, rhs,"
        },
        {
          "line": 5147,
          "api": "builder",
          "text": "lhs.builder()->BinaryOp(HloOpcode::kSubtract, lhs, rhs,\n                                 broadcast_dimensions)",
          "line_content": "  return lhs.builder()->BinaryOp(HloOpcode::kSubtract, lhs, rhs,"
        },
        {
          "line": 5153,
          "api": "builder",
          "text": "lhs.builder()->BinaryOp(HloOpcode::kMultiply, lhs, rhs,\n                                 broadcast_dimensions)",
          "line_content": "  return lhs.builder()->BinaryOp(HloOpcode::kMultiply, lhs, rhs,"
        },
        {
          "line": 1060,
          "api": "ShapeUtil::IsScalar(*scalar_shape)",
          "text": "ShapeUtil::IsScalar(*scalar_shape)",
          "line_content": "  CHECK(ShapeUtil::IsScalar(*scalar_shape));"
        },
        {
          "line": 1062,
          "api": "rank",
          "text": "output_shape.rank()",
          "line_content": "  std::vector<XlaOp> output_sizes(output_shape.rank());"
        },
        {
          "line": 1063,
          "api": "rank",
          "text": "output_shape.rank()",
          "line_content": "  for (size_t i = 0; i < output_shape.rank(); i++) {"
        },
        {
          "line": 5159,
          "api": "builder",
          "text": "lhs.builder()->BinaryOp(HloOpcode::kDivide, lhs, rhs,\n                                 broadcast_dimensions)",
          "line_content": "  return lhs.builder()->BinaryOp(HloOpcode::kDivide, lhs, rhs,"
        },
        {
          "line": 1065,
          "api": "is_static_dimension",
          "text": "output_shape.is_static_dimension(i)",
          "line_content": "        output_shape.is_static_dimension(i)"
        },
        {
          "line": 1066,
          "api": "dimensions",
          "text": "ConstantR1(builder,\n                         absl::Span<const int32_t>({static_cast<int32_t>(\n                             output_shape.dimensions(i))}))",
          "line_content": "            ? ConstantR1(builder,"
        },
        {
          "line": 1067,
          "api": "dimensions",
          "text": "static_cast<int32_t>(\n                             output_shape.dimensions(i))",
          "line_content": "                         absl::Span<const int32_t>({static_cast<int32_t>("
        },
        {
          "line": 1068,
          "api": "dimensions",
          "text": "output_shape.dimensions(i)",
          "line_content": "                             output_shape.dimensions(i))}))"
        },
        {
          "line": 1069,
          "api": "xla::GetDimensionSize(output, i)",
          "text": "xla::GetDimensionSize(output, i)",
          "line_content": "            : xla::Reshape(xla::GetDimensionSize(output, i), {1});"
        },
        {
          "line": 5165,
          "api": "builder",
          "text": "lhs.builder()->BinaryOp(HloOpcode::kRemainder, lhs, rhs,\n                                 broadcast_dimensions)",
          "line_content": "  return lhs.builder()->BinaryOp(HloOpcode::kRemainder, lhs, rhs,"
        },
        {
          "line": 1071,
          "api": "xla::DynamicBroadcastInDim(\n      scalar, /*output_dimensions=*/ConcatInDim(builder, output_sizes, 0), {},\n      output_shape)",
          "text": "xla::DynamicBroadcastInDim(\n      scalar, /*output_dimensions=*/ConcatInDim(builder, output_sizes, 0), {},\n      output_shape)",
          "line_content": "  return xla::DynamicBroadcastInDim("
        },
        {
          "line": 1072,
          "api": "ConcatInDim",
          "text": "ConcatInDim(builder, output_sizes, 0)",
          "line_content": "      scalar, /*output_dimensions=*/ConcatInDim(builder, output_sizes, 0), {},"
        },
        {
          "line": 5171,
          "api": "builder",
          "text": "lhs.builder()->BinaryOp(HloOpcode::kMaximum, lhs, rhs,\n                                 broadcast_dimensions)",
          "line_content": "  return lhs.builder()->BinaryOp(HloOpcode::kMaximum, lhs, rhs,"
        },
        {
          "line": 5177,
          "api": "builder",
          "text": "lhs.builder()->BinaryOp(HloOpcode::kMinimum, lhs, rhs,\n                                 broadcast_dimensions)",
          "line_content": "  return lhs.builder()->BinaryOp(HloOpcode::kMinimum, lhs, rhs,"
        },
        {
          "line": 1084,
          "api": "rank",
          "text": "operand_shape->rank()",
          "line_content": "  std::vector<int64_t> broadcast_dimensions(operand_shape->rank());"
        },
        {
          "line": 1085,
          "api": "end",
          "text": "broadcast_dimensions.end()",
          "line_content": "  std::iota(broadcast_dimensions.begin(), broadcast_dimensions.end(),"
        },
        {
          "line": 1086,
          "api": "rank",
          "text": "operand_shape->rank()",
          "line_content": "            output_shape.rank() - operand_shape->rank());"
        },
        {
          "line": 5183,
          "api": "builder",
          "text": "lhs.builder()->BinaryOp(HloOpcode::kAnd, lhs, rhs,\n                                 broadcast_dimensions)",
          "line_content": "  return lhs.builder()->BinaryOp(HloOpcode::kAnd, lhs, rhs,"
        },
        {
          "line": 1088,
          "api": "xla::DynamicBroadcastInDim(operand, output_dimensions,\n                                    broadcast_dimensions, output_shape)",
          "text": "xla::DynamicBroadcastInDim(operand, output_dimensions,\n                                    broadcast_dimensions, output_shape)",
          "line_content": "  return xla::DynamicBroadcastInDim(operand, output_dimensions,"
        },
        {
          "line": 5189,
          "api": "builder",
          "text": "lhs.builder()->BinaryOp(HloOpcode::kOr, lhs, rhs,\n                                 broadcast_dimensions)",
          "line_content": "  return lhs.builder()->BinaryOp(HloOpcode::kOr, lhs, rhs,"
        },
        {
          "line": 5195,
          "api": "builder",
          "text": "lhs.builder()->BinaryOp(HloOpcode::kXor, lhs, rhs,\n                                 broadcast_dimensions)",
          "line_content": "  return lhs.builder()->BinaryOp(HloOpcode::kXor, lhs, rhs,"
        },
        {
          "line": 1104,
          "api": "rank",
          "text": "lhs_shape.rank()",
          "line_content": "  const int64_t lhs_rank = lhs_shape.rank();"
        },
        {
          "line": 1105,
          "api": "rank",
          "text": "rhs_shape.rank()",
          "line_content": "  const int64_t rhs_rank = rhs_shape.rank();"
        },
        {
          "line": 1106,
          "api": "rank",
          "text": "output_shape.rank()",
          "line_content": "  const int64_t output_rank = output_shape.rank();"
        },
        {
          "line": 5200,
          "api": "builder",
          "text": "operand.builder()->UnaryOp(HloOpcode::kNot, operand)",
          "line_content": "  return operand.builder()->UnaryOp(HloOpcode::kNot, operand);"
        },
        {
          "line": 5204,
          "api": "builder",
          "text": "operand.builder()->UnaryOp(HloOpcode::kPopulationCount, operand)",
          "line_content": "  return operand.builder()->UnaryOp(HloOpcode::kPopulationCount, operand);"
        },
        {
          "line": 1110,
          "api": "TF_ASSIGN_OR_RETURN",
          "text": "TF_ASSIGN_OR_RETURN(std::vector<XlaOp> lhs_dims,\n                      ExtractDimensionSizesAndPadOnesToLeft(\n                          builder, lhs, lhs_rank, output_rank - lhs_rank))",
          "line_content": "  TF_ASSIGN_OR_RETURN(std::vector<XlaOp> lhs_dims,"
        },
        {
          "line": 1111,
          "api": "ExtractDimensionSizesAndPadOnesToLeft",
          "text": "ExtractDimensionSizesAndPadOnesToLeft(\n                          builder, lhs, lhs_rank, output_rank - lhs_rank)",
          "line_content": "                      ExtractDimensionSizesAndPadOnesToLeft("
        },
        {
          "line": 1113,
          "api": "TF_ASSIGN_OR_RETURN",
          "text": "TF_ASSIGN_OR_RETURN(std::vector<XlaOp> rhs_dims,\n                      ExtractDimensionSizesAndPadOnesToLeft(\n                          builder, rhs, rhs_rank, output_rank - rhs_rank))",
          "line_content": "  TF_ASSIGN_OR_RETURN(std::vector<XlaOp> rhs_dims,"
        },
        {
          "line": 1114,
          "api": "ExtractDimensionSizesAndPadOnesToLeft",
          "text": "ExtractDimensionSizesAndPadOnesToLeft(\n                          builder, rhs, rhs_rank, output_rank - rhs_rank)",
          "line_content": "                      ExtractDimensionSizesAndPadOnesToLeft("
        },
        {
          "line": 5209,
          "api": "builder",
          "text": "lhs.builder()->BinaryOp(HloOpcode::kShiftLeft, lhs, rhs,\n                                 broadcast_dimensions)",
          "line_content": "  return lhs.builder()->BinaryOp(HloOpcode::kShiftLeft, lhs, rhs,"
        },
        {
          "line": 5215,
          "api": "builder",
          "text": "lhs.builder()->BinaryOp(HloOpcode::kShiftRightArithmetic, lhs, rhs,\n                                 broadcast_dimensions)",
          "line_content": "  return lhs.builder()->BinaryOp(HloOpcode::kShiftRightArithmetic, lhs, rhs,"
        },
        {
          "line": 1121,
          "api": "ConcatInDim",
          "text": "ConcatInDim(builder, rhs_dims, 0)",
          "line_content": "      Max(ConcatInDim(builder, lhs_dims, 0), ConcatInDim(builder, rhs_dims, 0));"
        },
        {
          "line": 5221,
          "api": "builder",
          "text": "lhs.builder()->BinaryOp(HloOpcode::kShiftRightLogical, lhs, rhs,\n                                 broadcast_dimensions)",
          "line_content": "  return lhs.builder()->BinaryOp(HloOpcode::kShiftRightLogical, lhs, rhs,"
        },
        {
          "line": 5228,
          "api": "builder",
          "text": "operand.builder()->Reduce(operand, init_value, computation,\n                                   dimensions_to_reduce)",
          "line_content": "  return operand.builder()->Reduce(operand, init_value, computation,"
        },
        {
          "line": 1139,
          "api": "rank",
          "text": "ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    TF_ASSIGN_OR_RETURN(const Shape* lhs_shape, GetShapePtr(lhs));\n    TF_ASSIGN_OR_RETURN(const Shape* rhs_shape, GetShapePtr(rhs));\n    TF_ASSIGN_OR_RETURN(\n        Shape shape, ShapeInference::InferBinaryOpShape(\n                         binop, *lhs_shape, *rhs_shape, broadcast_dimensions));\n\n    XlaOp updated_lhs = lhs;\n    XlaOp updated_rhs = rhs;\n    if (!lhs_shape->is_unbounded_dynamic() &&\n        !rhs_shape->is_unbounded_dynamic()) {\n      if (lhs_shape->rank() < shape.rank()) {\n        TF_ASSIGN_OR_RETURN(updated_lhs,\n                            BroadcastToTargetRank(lhs, *lhs_shape, shape,\n                                                  broadcast_dimensions));\n      }\n      if (rhs_shape->rank() < shape.rank()) {\n        TF_ASSIGN_OR_RETURN(updated_rhs,\n                            BroadcastToTargetRank(rhs, *rhs_shape, shape,\n                                                  broadcast_dimensions));\n      }\n      TF_ASSIGN_OR_RETURN(const Shape* updated_lhs_shape,\n                          GetShapePtr(updated_lhs));\n      TF_ASSIGN_OR_RETURN(const Shape* updated_rhs_shape,\n                          GetShapePtr(updated_rhs));\n      if (!ShapeUtil::SameDimensions(shape, *updated_lhs_shape)) {\n        TF_ASSIGN_OR_RETURN(updated_lhs,\n                            AddBroadcastSequence(shape, updated_lhs));\n      }\n      if (!ShapeUtil::SameDimensions(shape, *updated_rhs_shape)) {\n        TF_ASSIGN_OR_RETURN(updated_rhs,\n                            AddBroadcastSequence(shape, updated_rhs));\n      }\n    } else {\n      if (ShapeUtil::IsScalar(*lhs_shape) || ShapeUtil::IsScalar(*rhs_shape)) {\n        if (ShapeUtil::IsScalar(*lhs_shape)) {\n          TF_ASSIGN_OR_RETURN(updated_lhs,\n                              BroadcastScalarToOutputShapeWithUnbounded(\n                                  this, lhs, rhs, *rhs_shape));\n        }\n        if (ShapeUtil::IsScalar(*rhs_shape)) {\n          TF_ASSIGN_OR_RETURN(updated_rhs,\n                              BroadcastScalarToOutputShapeWithUnbounded(\n                                  this, rhs, lhs, *lhs_shape));\n        }\n      } else {\n        Shape output_shape = shape;\n        output_shape.set_element_type(lhs_shape->element_type());\n        TF_ASSIGN_OR_RETURN(UnboundedBroadcastResult broadcast_result,\n                            BroadcastToOutputShapeWithUnbounded(\n                                this, lhs, *lhs_shape, rhs, *rhs_shape,\n                                output_shape, broadcast_dimensions));\n        updated_lhs = broadcast_result.lhs;\n        updated_rhs = broadcast_result.rhs;\n      }\n    }\n\n    if (binop == HloOpcode::kCompare) {\n      if (!direction.has_value()) {\n        return InvalidArgument(\n            \"kCompare expects a ComparisonDirection, but none provided.\");\n      }\n      if (type == std::nullopt) {\n        return Compare(shape, updated_lhs, updated_rhs, *direction);\n      } else {\n        return Compare(shape, updated_lhs, updated_rhs, *direction, *type);\n      }\n    }\n\n    if (direction.has_value()) {\n      return InvalidArgument(\n          \"A comparison direction is provided for a non-compare opcode: %s.\",\n          HloOpcodeString(binop));\n    }\n    return BinaryOpNoBroadcast(binop, shape, updated_lhs, updated_rhs);\n  })",
          "line_content": "  return ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 5238,
          "api": "Reduce",
          "text": "builder->Reduce(operands, init_values, computation,\n                         dimensions_to_reduce)",
          "line_content": "  return builder->Reduce(operands, init_values, computation,"
        },
        {
          "line": 1148,
          "api": "is_unbounded_dynamic",
          "text": "lhs_shape->is_unbounded_dynamic()",
          "line_content": "    if (!lhs_shape->is_unbounded_dynamic() &&"
        },
        {
          "line": 1149,
          "api": "is_unbounded_dynamic",
          "text": "rhs_shape->is_unbounded_dynamic()",
          "line_content": "        !rhs_shape->is_unbounded_dynamic()) {"
        },
        {
          "line": 1150,
          "api": "rank",
          "text": "shape.rank()",
          "line_content": "      if (lhs_shape->rank() < shape.rank()) {"
        },
        {
          "line": 1151,
          "api": "TF_ASSIGN_OR_RETURN",
          "text": "TF_ASSIGN_OR_RETURN(updated_lhs,\n                            BroadcastToTargetRank(lhs, *lhs_shape, shape,\n                                                  broadcast_dimensions))",
          "line_content": "        TF_ASSIGN_OR_RETURN(updated_lhs,"
        },
        {
          "line": 1152,
          "api": "BroadcastToTargetRank",
          "text": "BroadcastToTargetRank(lhs, *lhs_shape, shape,\n                                                  broadcast_dimensions)",
          "line_content": "                            BroadcastToTargetRank(lhs, *lhs_shape, shape,"
        },
        {
          "line": 5244,
          "api": "builder",
          "text": "operand.builder()->ReduceAll(operand, init_value, computation)",
          "line_content": "  return operand.builder()->ReduceAll(operand, init_value, computation);"
        },
        {
          "line": 1155,
          "api": "rank",
          "text": "shape.rank()",
          "line_content": "      if (rhs_shape->rank() < shape.rank()) {"
        },
        {
          "line": 1156,
          "api": "TF_ASSIGN_OR_RETURN",
          "text": "TF_ASSIGN_OR_RETURN(updated_rhs,\n                            BroadcastToTargetRank(rhs, *rhs_shape, shape,\n                                                  broadcast_dimensions))",
          "line_content": "        TF_ASSIGN_OR_RETURN(updated_rhs,"
        },
        {
          "line": 1157,
          "api": "BroadcastToTargetRank",
          "text": "BroadcastToTargetRank(rhs, *rhs_shape, shape,\n                                                  broadcast_dimensions)",
          "line_content": "                            BroadcastToTargetRank(rhs, *rhs_shape, shape,"
        },
        {
          "line": 5251,
          "api": "builder",
          "text": "operand.builder()->ReduceWindow(operand, init_value, computation,\n                                         window_dimensions, window_strides,\n                                         padding)",
          "line_content": "  return operand.builder()->ReduceWindow(operand, init_value, computation,"
        },
        {
          "line": 1164,
          "api": "ShapeUtil::SameDimensions(shape, *updated_lhs_shape)",
          "text": "ShapeUtil::SameDimensions(shape, *updated_lhs_shape)",
          "line_content": "      if (!ShapeUtil::SameDimensions(shape, *updated_lhs_shape)) {"
        },
        {
          "line": 1165,
          "api": "TF_ASSIGN_OR_RETURN",
          "text": "TF_ASSIGN_OR_RETURN(updated_lhs,\n                            AddBroadcastSequence(shape, updated_lhs))",
          "line_content": "        TF_ASSIGN_OR_RETURN(updated_lhs,"
        },
        {
          "line": 1166,
          "api": "AddBroadcastSequence",
          "text": "AddBroadcastSequence(shape, updated_lhs)",
          "line_content": "                            AddBroadcastSequence(shape, updated_lhs));"
        },
        {
          "line": 5261,
          "api": "empty",
          "text": "operands.empty()",
          "line_content": "  CHECK(!operands.empty());"
        },
        {
          "line": 1168,
          "api": "ShapeUtil::SameDimensions(shape, *updated_rhs_shape)",
          "text": "ShapeUtil::SameDimensions(shape, *updated_rhs_shape)",
          "line_content": "      if (!ShapeUtil::SameDimensions(shape, *updated_rhs_shape)) {"
        },
        {
          "line": 1169,
          "api": "TF_ASSIGN_OR_RETURN",
          "text": "TF_ASSIGN_OR_RETURN(updated_rhs,\n                            AddBroadcastSequence(shape, updated_rhs))",
          "line_content": "        TF_ASSIGN_OR_RETURN(updated_rhs,"
        },
        {
          "line": 1170,
          "api": "AddBroadcastSequence",
          "text": "AddBroadcastSequence(shape, updated_rhs)",
          "line_content": "                            AddBroadcastSequence(shape, updated_rhs));"
        },
        {
          "line": 5262,
          "api": "builder",
          "text": "operands[0].builder()->ReduceWindow(operands, init_values, computation,\n                                             window_dimensions, window_strides,\n                                             padding)",
          "line_content": "  return operands[0].builder()->ReduceWindow(operands, init_values, computation,"
        },
        {
          "line": 1173,
          "api": "ShapeUtil::IsScalar(*rhs_shape)",
          "text": "ShapeUtil::IsScalar(*rhs_shape)",
          "line_content": "      if (ShapeUtil::IsScalar(*lhs_shape) || ShapeUtil::IsScalar(*rhs_shape)) {"
        },
        {
          "line": 1174,
          "api": "ShapeUtil::IsScalar(*lhs_shape)",
          "text": "ShapeUtil::IsScalar(*lhs_shape)",
          "line_content": "        if (ShapeUtil::IsScalar(*lhs_shape)) {"
        },
        {
          "line": 1175,
          "api": "TF_ASSIGN_OR_RETURN",
          "text": "TF_ASSIGN_OR_RETURN(updated_lhs,\n                              BroadcastScalarToOutputShapeWithUnbounded(\n                                  this, lhs, rhs, *rhs_shape))",
          "line_content": "          TF_ASSIGN_OR_RETURN(updated_lhs,"
        },
        {
          "line": 1176,
          "api": "BroadcastScalarToOutputShapeWithUnbounded",
          "text": "BroadcastScalarToOutputShapeWithUnbounded(\n                                  this, lhs, rhs, *rhs_shape)",
          "line_content": "                              BroadcastScalarToOutputShapeWithUnbounded("
        },
        {
          "line": 1179,
          "api": "ShapeUtil::IsScalar(*rhs_shape)",
          "text": "ShapeUtil::IsScalar(*rhs_shape)",
          "line_content": "        if (ShapeUtil::IsScalar(*rhs_shape)) {"
        },
        {
          "line": 1180,
          "api": "TF_ASSIGN_OR_RETURN",
          "text": "TF_ASSIGN_OR_RETURN(updated_rhs,\n                              BroadcastScalarToOutputShapeWithUnbounded(\n                                  this, rhs, lhs, *lhs_shape))",
          "line_content": "          TF_ASSIGN_OR_RETURN(updated_rhs,"
        },
        {
          "line": 1181,
          "api": "BroadcastScalarToOutputShapeWithUnbounded",
          "text": "BroadcastScalarToOutputShapeWithUnbounded(\n                                  this, rhs, lhs, *lhs_shape)",
          "line_content": "                              BroadcastScalarToOutputShapeWithUnbounded("
        },
        {
          "line": 5275,
          "api": "builder",
          "text": "operand.builder()->ReduceWindowWithGeneralPadding(\n      absl::MakeSpan(&operand, 1), absl::MakeSpan(&init_value, 1), computation,\n      window_dimensions, window_strides, base_dilations, window_dilations,\n      padding)",
          "line_content": "  return operand.builder()->ReduceWindowWithGeneralPadding("
        },
        {
          "line": 5276,
          "api": "absl::MakeSpan(&init_value, 1)",
          "text": "absl::MakeSpan(&init_value, 1)",
          "line_content": "      absl::MakeSpan(&operand, 1), absl::MakeSpan(&init_value, 1), computation,"
        },
        {
          "line": 1186,
          "api": "element_type",
          "text": "lhs_shape->element_type()",
          "line_content": "        output_shape.set_element_type(lhs_shape->element_type());"
        },
        {
          "line": 5289,
          "api": "empty",
          "text": "operands.empty()",
          "line_content": "  CHECK(!operands.empty());"
        },
        {
          "line": 5290,
          "api": "builder",
          "text": "operands[0].builder()->ReduceWindowWithGeneralPadding(\n      operands, init_values, computation, window_dimensions, window_strides,\n      base_dilations, window_dilations, padding)",
          "line_content": "  return operands[0].builder()->ReduceWindowWithGeneralPadding("
        },
        {
          "line": 1197,
          "api": "has_value",
          "text": "direction.has_value()",
          "line_content": "      if (!direction.has_value()) {"
        },
        {
          "line": 1198,
          "api": "InvalidArgument",
          "text": "InvalidArgument(\n            \"kCompare expects a ComparisonDirection, but none provided.\")",
          "line_content": "        return InvalidArgument("
        },
        {
          "line": 1202,
          "api": "Compare",
          "text": "Compare(shape, updated_lhs, updated_rhs, *direction)",
          "line_content": "        return Compare(shape, updated_lhs, updated_rhs, *direction);"
        },
        {
          "line": 1204,
          "api": "Compare",
          "text": "Compare(shape, updated_lhs, updated_rhs, *direction, *type)",
          "line_content": "        return Compare(shape, updated_lhs, updated_rhs, *direction, *type);"
        },
        {
          "line": 5301,
          "api": "builder",
          "text": "operand.builder()->AllGather(operand, all_gather_dimension,\n                                      shard_count, replica_groups, channel_id,\n                                      layout, use_global_device_ids)",
          "line_content": "  return operand.builder()->AllGather(operand, all_gather_dimension,"
        },
        {
          "line": 1208,
          "api": "has_value",
          "text": "direction.has_value()",
          "line_content": "    if (direction.has_value()) {"
        },
        {
          "line": 1209,
          "api": "InvalidArgument",
          "text": "InvalidArgument(\n          \"A comparison direction is provided for a non-compare opcode: %s.\",\n          HloOpcodeString(binop))",
          "line_content": "      return InvalidArgument("
        },
        {
          "line": 1211,
          "api": "HloOpcodeString",
          "text": "HloOpcodeString(binop)",
          "line_content": "          HloOpcodeString(binop));"
        },
        {
          "line": 1213,
          "api": "BinaryOpNoBroadcast",
          "text": "BinaryOpNoBroadcast(binop, shape, updated_lhs, updated_rhs)",
          "line_content": "    return BinaryOpNoBroadcast(binop, shape, updated_lhs, updated_rhs);"
        },
        {
          "line": 5312,
          "api": "empty",
          "text": "operands.empty()",
          "line_content": "  CHECK(!operands.empty());"
        },
        {
          "line": 5313,
          "api": "builder",
          "text": "operands[0].builder()->AllGather(\n      operands[0].builder()->Tuple(operands), all_gather_dimension, shard_count,\n      replica_groups, channel_id, layout, use_global_device_ids)",
          "line_content": "  return operands[0].builder()->AllGather("
        },
        {
          "line": 5314,
          "api": "builder",
          "text": "operands[0].builder()->Tuple(operands)",
          "line_content": "      operands[0].builder()->Tuple(operands), all_gather_dimension, shard_count,"
        },
        {
          "line": 1219,
          "api": "mutable_shape",
          "text": "ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {\n    HloInstructionProto instr;\n    *instr.mutable_shape() = shape.ToProto();\n    return AddInstruction(std::move(instr), binop, {lhs, rhs});\n  })",
          "line_content": "  return ReportErrorOrReturn([&]() -> StatusOr<XlaOp> {"
        },
        {
          "line": 1221,
          "api": "ToProto",
          "text": "shape.ToProto()",
          "line_content": "    *instr.mutable_shape() = shape.ToProto();"
        },
        {
          "line": 1222,
          "api": "std::move(instr)",
          "text": "std::move(instr)",
          "line_content": "    return AddInstruction(std::move(instr), binop, {lhs, rhs});"
        },
        {
          "line": 5320,
          "api": "builder",
          "text": "operand.builder()->CrossReplicaSum(operand, replica_groups)",
          "line_content": "  return operand.builder()->CrossReplicaSum(operand, replica_groups);"
        },
        {
          "line": 1229,
          "api": "element_type"