{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/ab1f5ff898302ec149408c4d030241991544faf6",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/ab1f5ff898302ec149408c4d030241991544faf6/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/ab1f5ff898302ec149408c4d030241991544faf6/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/ab1f5ff898302ec149408c4d030241991544faf6/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 419,
          "old_api": "get",
          "new_api": "std::make_unique<mlir::MLIRContext>(\n      registry, mlir::MLIRContext::Threading::DISABLED)",
          "old_text": "mlir_context.get()",
          "new_text": "std::make_unique<mlir::MLIRContext>(\n      registry, mlir::MLIRContext::Threading::DISABLED)",
          "old_line_content": "      mlir::ModuleOp::create(mlir::Builder(mlir_context.get()).getUnknownLoc());",
          "new_line_content": "  auto mlir_context = std::make_unique<mlir::MLIRContext>(",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": "HloToLhloModule",
          "new_api": "registerHandler",
          "old_text": "HloToLhloModule(*results->buffer_assignment, *hlo_module, *mlir_module)",
          "new_text": "mlir_context->getDiagEngine().registerHandler(DiagnosticHandler)",
          "old_line_content": "      HloToLhloModule(*results->buffer_assignment, *hlo_module, *mlir_module));",
          "new_line_content": "  mlir_context->getDiagEngine().registerHandler(DiagnosticHandler);",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": "DumpingEnabledForHloModule",
          "new_api": "HloToLhloModule",
          "old_text": "DumpingEnabledForHloModule(*hlo_module)",
          "new_text": "HloToLhloModule(*results->buffer_assignment, *hlo_module, *mlir_module)",
          "old_line_content": "  if (DumpingEnabledForHloModule(*hlo_module)) {",
          "new_line_content": "      HloToLhloModule(*results->buffer_assignment, *hlo_module, *mlir_module));",
          "content_same": false
        },
        {
          "line": 432,
          "old_api": "entry_computation",
          "new_api": "DumpingEnabledForHloModule",
          "old_text": "hlo_module->entry_computation()->name()",
          "new_text": "DumpingEnabledForHloModule(*hlo_module)",
          "old_line_content": "      mlir_module->lookupSymbol(hlo_module->entry_computation()->name()));",
          "new_line_content": "  if (DumpingEnabledForHloModule(*hlo_module)) {",
          "content_same": false
        },
        {
          "line": 445,
          "old_api": "IrEmitterUnnested::Create(&ir_emitter_context)",
          "new_api": "get",
          "old_text": "IrEmitterUnnested::Create(&ir_emitter_context)",
          "new_text": "mlir_context.get()",
          "old_line_content": "  auto ir_emitter = IrEmitterUnnested::Create(&ir_emitter_context);",
          "new_line_content": "      cuda_compute_capability, rocm_compute_capability, mlir_context.get(),",
          "content_same": false
        },
        {
          "line": 448,
          "old_api": "name",
          "new_api": "set_allocations",
          "old_text": "absl::StrCat(\n        \"GpuCompiler::RunBackend - IR emission for \", hlo_module->name())",
          "new_text": "ir_emitter_context.set_allocations(results->allocations)",
          "old_line_content": "    XLA_SCOPED_LOGGING_TIMER(absl::StrCat(",
          "new_line_content": "  ir_emitter_context.set_allocations(results->allocations);",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": "debug_options",
          "new_api": "getBody",
          "old_text": "hlo_module->config().debug_options().xla_gpu_enable_shared_constants()",
          "new_text": "entry_function.getBody()",
          "old_line_content": "        hlo_module->config().debug_options().xla_gpu_enable_shared_constants();",
          "new_line_content": "    TF_RETURN_IF_ERROR(ir_emitter->EmitLmhloRegion(&entry_function.getBody()));",
          "content_same": false
        },
        {
          "line": 461,
          "old_api": "constants",
          "new_api": "debug_options",
          "old_text": "ir_emitter_context.constants()",
          "new_text": "hlo_module->config().debug_options().xla_gpu_enable_shared_constants()",
          "old_line_content": "                                          ir_emitter_context.constants());",
          "new_line_content": "        hlo_module->config().debug_options().xla_gpu_enable_shared_constants();",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": "NowMicros",
          "new_api": "llvm_module",
          "old_text": "tsl::Env::Default()->NowMicros()",
          "new_text": "ir_emitter_context.llvm_module()",
          "old_line_content": "    uint64_t end_usecs = tsl::Env::Default()->NowMicros();",
          "new_line_content": "      RemoveUnusedAndUninitializedGlobals(ir_emitter_context.llvm_module(),",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": "RecordHloToLlvmDuration",
          "new_api": "constants",
          "old_text": "RecordHloToLlvmDuration(end_usecs - start_usecs)",
          "new_text": "ir_emitter_context.constants()",
          "old_line_content": "    RecordHloToLlvmDuration(end_usecs - start_usecs);",
          "new_line_content": "    results->constants = std::move(ir_emitter_context.constants());",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": "size",
          "new_api": "RecordHloToLlvmDuration",
          "old_text": "llvm::transform(\n      results->allocations, std::back_inserter(buffer_sizes),\n      [](const BufferAllocation& allocation) { return allocation.size(); })",
          "new_text": "RecordHloToLlvmDuration(end_usecs - start_usecs)",
          "old_line_content": "  llvm::transform(",
          "new_line_content": "    RecordHloToLlvmDuration(end_usecs - start_usecs);",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": "config",
          "new_api": "std::back_inserter(buffer_sizes)",
          "old_text": "hlo_module->config()",
          "new_text": "std::back_inserter(buffer_sizes)",
          "old_line_content": "  if (IsXlaRuntimeExecutableEnabled(hlo_module->config()) &&",
          "new_line_content": "      results->allocations, std::back_inserter(buffer_sizes),",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": "HasFp8",
          "new_api": "size",
          "old_text": "HasFp8(*hlo_module)",
          "new_text": "allocation.size()",
          "old_line_content": "      !HasFp8(*hlo_module)) {",
          "new_line_content": "      [](const BufferAllocation& allocation) { return allocation.size(); });",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": "ConsumeThunkSequence",
          "new_api": "config",
          "old_text": "ir_emitter->ConsumeThunkSequence()",
          "new_text": "hlo_module->config()",
          "old_line_content": "                     hlo_module->config(), ir_emitter->ConsumeThunkSequence(),",
          "new_line_content": "  if (IsXlaRuntimeExecutableEnabled(hlo_module->config()) &&",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": "OkStatus",
          "new_api": "getName",
          "old_text": "OkStatus()",
          "new_text": "TF_ASSIGN_OR_RETURN(\n        results->executable,\n        LowerToJitRt(*mlir_module, entry_function.getName(), buffer_sizes,\n                     hlo_module->config(), ir_emitter->ConsumeThunkSequence(),\n                     /*hlo_module_for_dump=*/hlo_module))",
          "old_line_content": "    return OkStatus();",
          "new_line_content": "    TF_ASSIGN_OR_RETURN(",
          "content_same": false
        },
        {
          "line": 490,
          "old_api": "config",
          "new_api": "ConsumeThunkSequence",
          "old_text": "hlo_module->config()",
          "new_text": "ir_emitter->ConsumeThunkSequence()",
          "old_line_content": "  if (IsOpenXlaRuntimeEnabled(hlo_module->config())) {",
          "new_line_content": "                     hlo_module->config(), ir_emitter->ConsumeThunkSequence(),",
          "content_same": false
        },
        {
          "line": 495,
          "old_api": "ConsumeThunkSequence",
          "new_api": "config",
          "old_text": "ir_emitter->ConsumeThunkSequence()",
          "new_text": "hlo_module->config()",
          "old_line_content": "                       hlo_module->config(), ir_emitter->ConsumeThunkSequence(),",
          "new_line_content": "  if (IsOpenXlaRuntimeEnabled(hlo_module->config())) {",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": "get",
          "new_api": "OkStatus",
          "old_text": "thunk_sequence.get()",
          "new_text": "OkStatus()",
          "old_line_content": "               thunk_sequence.get());",
          "new_line_content": "    return OkStatus();",
          "content_same": false
        },
        {
          "line": 520,
          "old_api": "eraseFromParent",
          "new_api": "empty",
          "old_text": "global->eraseFromParent()",
          "new_text": "info.content.empty()",
          "old_line_content": "        global->eraseFromParent();",
          "new_line_content": "    if (!info.content.empty()) {",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 522,
          "old_api": null,
          "new_api": "getGlobalVariable",
          "old_text": null,
          "new_text": "llvm_module->getGlobalVariable(info.symbol_name)",
          "old_line_content": "    }",
          "new_line_content": "          llvm_module->getGlobalVariable(info.symbol_name);",
          "content_same": false
        },
        {
          "line": 523,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(global != nullptr)",
          "old_line_content": "  }",
          "new_line_content": "      CHECK(global != nullptr);",
          "content_same": false
        },
        {
          "line": 524,
          "old_api": null,
          "new_api": "use_empty",
          "old_text": null,
          "new_text": "global->use_empty()",
          "old_line_content": "}",
          "new_line_content": "      if (global->use_empty()) {",
          "content_same": false
        },
        {
          "line": 525,
          "old_api": null,
          "new_api": "eraseFromParent",
          "old_text": null,
          "new_text": "global->eraseFromParent()",
          "old_line_content": "",
          "new_line_content": "        global->eraseFromParent();",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "mlir_context.get()",
          "old_line_content": "  results->module_name =",
          "new_line_content": "      mlir::ModuleOp::create(mlir::Builder(mlir_context.get()).getUnknownLoc());",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": null,
          "new_api": "TF_RETURN_IF_ERROR",
          "old_text": null,
          "new_text": "TF_RETURN_IF_ERROR(\n      HloToLhloModule(*results->buffer_assignment, *hlo_module, *mlir_module))",
          "old_line_content": "",
          "new_line_content": "  TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": null,
          "new_api": "getLoc",
          "old_text": null,
          "new_text": "mlir_module->getLoc()",
          "old_line_content": "",
          "new_line_content": "      mlir::mhlo::GetDebugNameFromLocation(mlir_module->getLoc());",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "mlir_module.get()",
          "old_line_content": "",
          "new_line_content": "    DumpToFileInDirOrStdout(*hlo_module, \"lmhlo\", mlir_module.get());",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": null,
          "new_api": "lookupSymbol",
          "old_text": null,
          "new_text": "mlir::cast<mlir::func::FuncOp>(\n      mlir_module->lookupSymbol(hlo_module->entry_computation()->name()))",
          "old_line_content": "      &results->output_shape, &results->entry_func_attrs));",
          "new_line_content": "  auto entry_function = mlir::cast<mlir::func::FuncOp>(",
          "content_same": false
        },
        {
          "line": 437,
          "old_api": null,
          "new_api": "entry_computation",
          "old_text": null,
          "new_text": "hlo_module->entry_computation()->name()",
          "old_line_content": "",
          "new_line_content": "      mlir_module->lookupSymbol(hlo_module->entry_computation()->name()));",
          "content_same": false
        },
        {
          "line": 439,
          "old_api": null,
          "new_api": "GetMlirAllocationInfo",
          "old_text": null,
          "new_text": "GetMlirAllocationInfo(\n      entry_function, &results->allocations, &results->output_info,\n      &results->output_shape, &results->entry_func_attrs)",
          "old_line_content": "      hlo_module, /*buffer_assignment=*/nullptr, platform_name, gpu_device_info,",
          "new_line_content": "  TF_RETURN_IF_ERROR(GetMlirAllocationInfo(",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "results->llvm_module.get()",
          "old_line_content": "",
          "new_line_content": "      results->llvm_module.get());",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": null,
          "new_api": "IrEmitterUnnested::Create(&ir_emitter_context)",
          "old_text": null,
          "new_text": "IrEmitterUnnested::Create(&ir_emitter_context)",
          "old_line_content": "",
          "new_line_content": "  auto ir_emitter = IrEmitterUnnested::Create(&ir_emitter_context);",
          "content_same": false
        },
        {
          "line": 453,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "absl::StrCat(\n        \"GpuCompiler::RunBackend - IR emission for \", hlo_module->name())",
          "old_line_content": "    bool supports_runtime_managed_constants =",
          "new_line_content": "    XLA_SCOPED_LOGGING_TIMER(absl::StrCat(",
          "content_same": false
        },
        {
          "line": 454,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "hlo_module->name()",
          "old_line_content": "        // TODO(b/218907125): Implement this feature for ROCm as well.",
          "new_line_content": "        \"GpuCompiler::RunBackend - IR emission for \", hlo_module->name()));",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": null,
          "new_api": "constants",
          "old_text": null,
          "new_text": "ir_emitter_context.constants()",
          "old_line_content": "",
          "new_line_content": "                                          ir_emitter_context.constants());",
          "content_same": false
        },
        {
          "line": 470,
          "old_api": null,
          "new_api": "NowMicros",
          "old_text": null,
          "new_text": "tsl::Env::Default()->NowMicros()",
          "old_line_content": "  }",
          "new_line_content": "    uint64_t end_usecs = tsl::Env::Default()->NowMicros();",
          "content_same": false
        },
        {
          "line": 479,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "llvm::transform(\n      results->allocations, std::back_inserter(buffer_sizes),\n      [](const BufferAllocation& allocation) { return allocation.size(); })",
          "old_line_content": "  // is submitted. Currently we can't emit LLVM IR with fp8 types.",
          "new_line_content": "  llvm::transform(",
          "content_same": false
        },
        {
          "line": 486,
          "old_api": null,
          "new_api": "HasFp8",
          "old_text": null,
          "new_text": "HasFp8(*hlo_module)",
          "old_line_content": "                     /*hlo_module_for_dump=*/hlo_module));",
          "new_line_content": "      !HasFp8(*hlo_module)) {",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "entry_function.getName()",
          "old_line_content": "",
          "new_line_content": "        LowerToJitRt(*mlir_module, entry_function.getName(), buffer_sizes,",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": null,
          "new_api": "OkStatus",
          "old_text": null,
          "new_text": "OkStatus()",
          "old_line_content": "        results->executable,",
          "new_line_content": "    return OkStatus();",
          "content_same": false
        },
        {
          "line": 496,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "TF_ASSIGN_OR_RETURN(\n        results->executable,\n        LowerToOpenXla(std::move(mlir_context), std::move(mlir_module),\n                       entry_function.getName(), buffer_sizes,\n                       hlo_module->config(), ir_emitter->ConsumeThunkSequence(),\n                       /*hlo_module_for_dump=*/hlo_module))",
          "old_line_content": "                       /*hlo_module_for_dump=*/hlo_module));",
          "new_line_content": "    TF_ASSIGN_OR_RETURN(",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": null,
          "new_api": "std::move(mlir_module)",
          "old_text": null,
          "new_text": "std::move(mlir_module)",
          "old_line_content": "  }",
          "new_line_content": "        LowerToOpenXla(std::move(mlir_context), std::move(mlir_module),",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": null,
          "new_api": "getName",
          "old_text": null,
          "new_text": "entry_function.getName()",
          "old_line_content": "",
          "new_line_content": "                       entry_function.getName(), buffer_sizes,",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": null,
          "new_api": "ConsumeThunkSequence",
          "old_text": null,
          "new_text": "ir_emitter->ConsumeThunkSequence()",
          "old_line_content": "}",
          "new_line_content": "  auto thunk_sequence = ir_emitter->ConsumeThunkSequence();",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": null,
          "new_api": "ClearCompileTimeInfo",
          "old_text": null,
          "new_text": "thunk->ClearCompileTimeInfo()",
          "old_line_content": "",
          "new_line_content": "  ForAllThunks([](Thunk* thunk) { thunk->ClearCompileTimeInfo(); },",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "thunk_sequence.get()",
          "old_line_content": "// Removes all globals from the given module that are both uninitialized and",
          "new_line_content": "               thunk_sequence.get());",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": null,
          "new_api": "std::move(thunk_sequence)",
          "old_text": null,
          "new_text": "std::move(thunk_sequence)",
          "old_line_content": "// have no uses within that module.",
          "new_line_content": "  results->executable = std::move(thunk_sequence);",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": null,
          "new_api": "OkStatus",
          "old_text": null,
          "new_text": "OkStatus()",
          "old_line_content": "void RemoveUnusedAndUninitializedGlobals(",
          "new_line_content": "  return OkStatus();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 515,
          "old_api": "empty",
          "new_api": null,
          "old_text": "info.content.empty()",
          "new_text": null,
          "old_line_content": "    if (!info.content.empty()) {",
          "new_line_content": "    llvm::Module* llvm_module,",
          "content_same": false
        },
        {
          "line": 517,
          "old_api": "getGlobalVariable",
          "new_api": null,
          "old_text": "llvm_module->getGlobalVariable(info.symbol_name)",
          "new_text": null,
          "old_line_content": "          llvm_module->getGlobalVariable(info.symbol_name);",
          "new_line_content": "  for (const auto& info : constants) {",
          "content_same": false
        },
        {
          "line": 518,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(global != nullptr)",
          "new_text": null,
          "old_line_content": "      CHECK(global != nullptr);",
          "new_line_content": "    // Empty content means the constant is initialized in the LLVM IR, so we",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": "use_empty",
          "new_api": null,
          "old_text": "global->use_empty()",
          "new_text": null,
          "old_line_content": "      if (global->use_empty()) {",
          "new_line_content": "    // must not remove it.",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": "std::make_unique<mlir::MLIRContext>(registry)",
          "new_api": null,
          "old_text": "std::make_unique<mlir::MLIRContext>(registry)",
          "new_text": null,
          "old_line_content": "  auto mlir_context = std::make_unique<mlir::MLIRContext>(registry);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": "registerHandler",
          "new_api": null,
          "old_text": "mlir_context->getDiagEngine().registerHandler(DiagnosticHandler)",
          "new_text": null,
          "old_line_content": "  mlir_context->getDiagEngine().registerHandler(DiagnosticHandler);",
          "new_line_content": "  // Disable MLIR multi-threading to prevent creating too many threads when",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": "TF_RETURN_IF_ERROR",
          "new_api": null,
          "old_text": "TF_RETURN_IF_ERROR(\n      HloToLhloModule(*results->buffer_assignment, *hlo_module, *mlir_module))",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": "getLoc",
          "new_api": null,
          "old_text": "mlir_module->getLoc()",
          "new_text": null,
          "old_line_content": "      mlir::mhlo::GetDebugNameFromLocation(mlir_module->getLoc());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": "get",
          "new_api": null,
          "old_text": "mlir_module.get()",
          "new_text": null,
          "old_line_content": "    DumpToFileInDirOrStdout(*hlo_module, \"lmhlo\", mlir_module.get());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 431,
          "old_api": "lookupSymbol",
          "new_api": null,
          "old_text": "mlir::cast<mlir::func::FuncOp>(\n      mlir_module->lookupSymbol(hlo_module->entry_computation()->name()))",
          "new_text": null,
          "old_line_content": "  auto entry_function = mlir::cast<mlir::func::FuncOp>(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": "GetMlirAllocationInfo",
          "new_api": null,
          "old_text": "GetMlirAllocationInfo(\n      entry_function, &results->allocations, &results->output_info,\n      &results->output_shape, &results->entry_func_attrs)",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(GetMlirAllocationInfo(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": "get",
          "new_api": null,
          "old_text": "mlir_context.get()",
          "new_text": null,
          "old_line_content": "      cuda_compute_capability, rocm_compute_capability, mlir_context.get(),",
          "new_line_content": "      entry_function, &results->allocations, &results->output_info,",
          "content_same": false
        },
        {
          "line": 441,
          "old_api": "get",
          "new_api": null,
          "old_text": "results->llvm_module.get()",
          "new_text": null,
          "old_line_content": "      results->llvm_module.get());",
          "new_line_content": "      &results->output_shape, &results->entry_func_attrs));",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": "set_allocations",
          "new_api": null,
          "old_text": "ir_emitter_context.set_allocations(results->allocations)",
          "new_text": null,
          "old_line_content": "  ir_emitter_context.set_allocations(results->allocations);",
          "new_line_content": "  IrEmitterContext ir_emitter_context(",
          "content_same": false
        },
        {
          "line": 449,
          "old_api": "name",
          "new_api": null,
          "old_text": "hlo_module->name()",
          "new_text": null,
          "old_line_content": "        \"GpuCompiler::RunBackend - IR emission for \", hlo_module->name()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": "getBody",
          "new_api": null,
          "old_text": "entry_function.getBody()",
          "new_text": null,
          "old_line_content": "    TF_RETURN_IF_ERROR(ir_emitter->EmitLmhloRegion(&entry_function.getBody()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": "llvm_module",
          "new_api": null,
          "old_text": "ir_emitter_context.llvm_module()",
          "new_text": null,
          "old_line_content": "      RemoveUnusedAndUninitializedGlobals(ir_emitter_context.llvm_module(),",
          "new_line_content": "        platform_id != se::rocm::kROCmPlatformId &&",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": "constants",
          "new_api": null,
          "old_text": "ir_emitter_context.constants()",
          "new_text": null,
          "old_line_content": "    results->constants = std::move(ir_emitter_context.constants());",
          "new_line_content": "      // responsible for allocating and initializing them.",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": "std::back_inserter(buffer_sizes)",
          "new_api": null,
          "old_text": "std::back_inserter(buffer_sizes)",
          "new_text": null,
          "old_line_content": "      results->allocations, std::back_inserter(buffer_sizes),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": "size",
          "new_api": null,
          "old_text": "allocation.size()",
          "new_text": null,
          "old_line_content": "      [](const BufferAllocation& allocation) { return allocation.size(); });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": "getName",
          "new_api": null,
          "old_text": "TF_ASSIGN_OR_RETURN(\n        results->executable,\n        LowerToJitRt(*mlir_module, entry_function.getName(), buffer_sizes,\n                     hlo_module->config(), ir_emitter->ConsumeThunkSequence(),\n                     /*hlo_module_for_dump=*/hlo_module))",
          "new_text": null,
          "old_line_content": "    TF_ASSIGN_OR_RETURN(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": "getName",
          "new_api": null,
          "old_text": "entry_function.getName()",
          "new_text": null,
          "old_line_content": "        LowerToJitRt(*mlir_module, entry_function.getName(), buffer_sizes,",
          "new_line_content": "  // is submitted. Currently we can't emit LLVM IR with fp8 types.",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": "getName",
          "new_api": null,
          "old_text": "TF_ASSIGN_OR_RETURN(\n        results->executable,\n        LowerToOpenXla(std::move(mlir_context), std::move(mlir_module),\n                       entry_function.getName(), buffer_sizes,\n                       hlo_module->config(), ir_emitter->ConsumeThunkSequence(),\n                       /*hlo_module_for_dump=*/hlo_module))",
          "new_text": null,
          "old_line_content": "    TF_ASSIGN_OR_RETURN(",
          "new_line_content": "                     /*hlo_module_for_dump=*/hlo_module));",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": "std::move(mlir_module)",
          "new_api": null,
          "old_text": "std::move(mlir_module)",
          "new_text": null,
          "old_line_content": "        LowerToOpenXla(std::move(mlir_context), std::move(mlir_module),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": "getName",
          "new_api": null,
          "old_text": "entry_function.getName()",
          "new_text": null,
          "old_line_content": "                       entry_function.getName(), buffer_sizes,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": "OkStatus",
          "new_api": null,
          "old_text": "OkStatus()",
          "new_text": null,
          "old_line_content": "    return OkStatus();",
          "new_line_content": "        results->executable,",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": "ClearCompileTimeInfo",
          "new_api": null,
          "old_text": "thunk->ClearCompileTimeInfo()",
          "new_text": null,
          "old_line_content": "  ForAllThunks([](Thunk* thunk) { thunk->ClearCompileTimeInfo(); },",
          "new_line_content": "                       /*hlo_module_for_dump=*/hlo_module));",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": "std::move(thunk_sequence)",
          "new_api": null,
          "old_text": "std::move(thunk_sequence)",
          "new_text": null,
          "old_line_content": "  results->executable = std::move(thunk_sequence);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": "OkStatus",
          "new_api": null,
          "old_text": "OkStatus()",
          "new_text": null,
          "old_line_content": "  return OkStatus();",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 19,
      "total_additions": 29,
      "total_deletions": 29,
      "total_api_changes": 77
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 6,
        "api_related_lines": 77,
        "non_api_lines": 2,
        "non_api_line_numbers": [
          418,
          420
        ]
      }
    },
    "api_calls_before": 255,
    "api_calls_after": 255,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 1,
      "total_diff_lines": 19
    }
  }
}