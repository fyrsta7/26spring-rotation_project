{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/e79ce7712620a972b12b1237b1663b1709023623",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/e79ce7712620a972b12b1237b1663b1709023623/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/e79ce7712620a972b12b1237b1663b1709023623/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/tensorflow/modified_file/e79ce7712620a972b12b1237b1663b1709023623/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 496,
          "old_api": "LLVMInitializeNVPTXTarget",
          "new_api": "FeedLLVMWithFlags",
          "old_text": "LLVMInitializeNVPTXTarget()",
          "new_text": "FeedLLVMWithFlags({\n      \"-slp-vectorize-hor=false\",\n      \"-slp-max-reg-size=32\",\n  })",
          "old_line_content": "  LLVMInitializeNVPTXTarget();",
          "new_line_content": "  FeedLLVMWithFlags({",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": "llvm::PassRegistry::getPassRegistry()",
          "new_api": "debug_options",
          "old_text": "llvm::PassRegistry::getPassRegistry()",
          "new_text": "hlo_module_config.debug_options().xla_backend_extra_options()",
          "old_line_content": "  llvm::PassRegistry* registry = llvm::PassRegistry::getPassRegistry();",
          "new_line_content": "      hlo_module_config.debug_options().xla_backend_extra_options());",
          "content_same": false
        },
        {
          "line": 655,
          "old_api": "back",
          "new_api": "VLOG",
          "old_text": "g_hsacoCache.cache.back()",
          "new_text": "VLOG(1)",
          "old_line_content": "  g_hsacoCache.cache.back().ir = ir;",
          "new_line_content": "    VLOG(1) << \"HSACO cache: \" << g_hsacoCache.request_count << \" requests, \"",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": "tsl::Env::Default()",
          "new_api": "back",
          "old_text": "tsl::Env::Default()",
          "new_text": "g_hsacoCache.cache.back()",
          "old_line_content": "  auto* env = tsl::Env::Default();",
          "new_line_content": "  g_hsacoCache.cache.back().ir = ir;",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": "GetLocalTempDirectories",
          "new_api": "back",
          "old_text": "env->GetLocalTempDirectories(&tempdir_vector)",
          "new_text": "g_hsacoCache.cache.back()",
          "old_line_content": "  env->GetLocalTempDirectories(&tempdir_vector);",
          "new_line_content": "  g_hsacoCache.cache.back().gfx = gfx;",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": "empty",
          "new_api": "back",
          "old_text": "tempdir_vector.empty()",
          "new_text": "g_hsacoCache.cache.back()",
          "old_line_content": "  if (tempdir_vector.empty()) {",
          "new_line_content": "  g_hsacoCache.cache.back().hsaco = hsaco;",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": "getModuleIdentifier",
          "new_api": "VLOG",
          "old_text": "module->getModuleIdentifier()",
          "new_text": "VLOG(1)",
          "old_line_content": "      absl::StrCat(module->getModuleIdentifier(), random_number + \".ll\");",
          "new_line_content": "  VLOG(1) << \"Compile-time artifacts located at: \" << tempdir_name;",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": "getModuleIdentifier",
          "new_api": "tsl::random::New64()",
          "old_text": "module->getModuleIdentifier()",
          "new_text": "tsl::random::New64()",
          "old_line_content": "      absl::StrCat(module->getModuleIdentifier(), random_number + \".o\");",
          "new_line_content": "  std::string random_number = std::to_string(tsl::random::New64());",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": "add",
          "new_api": "flush",
          "old_text": "codegen_passes.add(new llvm::TargetLibraryInfoWrapperPass(\n      llvm::Triple(module->getTargetTriple())))",
          "new_text": "ir_fs->flush()",
          "old_line_content": "  codegen_passes.add(new llvm::TargetLibraryInfoWrapperPass(",
          "new_line_content": "  ir_fs->flush();",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": "addPassesToEmitFile",
          "new_api": "tsl::io::Basename(module_id)",
          "old_text": "target_machine->addPassesToEmitFile(codegen_passes, *isabin_fs, nullptr,\n                                      llvm::CGFT_ObjectFile)",
          "new_text": "tsl::io::Basename(module_id)",
          "old_line_content": "  target_machine->addPassesToEmitFile(codegen_passes, *isabin_fs, nullptr,",
          "new_line_content": "      ReplaceFilenameExtension(tsl::io::Basename(module_id),",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "flush",
          "new_api": "add",
          "old_text": "isabin_fs->flush()",
          "new_text": "codegen_passes.add(new llvm::TargetLibraryInfoWrapperPass(\n      llvm::Triple(module->getTargetTriple())))",
          "old_line_content": "  isabin_fs->flush();",
          "new_line_content": "  codegen_passes.add(new llvm::TargetLibraryInfoWrapperPass(",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": "flush",
          "new_api": "createDataLayout",
          "old_text": "ir_fs->flush()",
          "new_text": "target_machine->createDataLayout()",
          "old_line_content": "    ir_fs->flush();",
          "new_line_content": "  module->setDataLayout(target_machine->createDataLayout());",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": "getError",
          "new_api": "print",
          "old_text": "lld_program.getError().message()",
          "new_text": "module->print(*ir_fs, nullptr)",
          "old_line_content": "                              lld_program.getError().message());",
          "new_line_content": "    module->print(*ir_fs, nullptr);",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": "llvm_ir::AsStringRef(hsaco_path)",
          "new_api": "tsl::io::JoinPath(\"/opt/rocm\", \"llvm/bin\")",
          "old_text": "llvm_ir::AsStringRef(hsaco_path)",
          "new_text": "tsl::io::JoinPath(\"/opt/rocm\", \"llvm/bin\")",
          "old_line_content": "      llvm_ir::AsStringRef(hsaco_path),",
          "new_line_content": "  std::string lld_path = tsl::io::JoinPath(\"/opt/rocm\", \"llvm/bin\");",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": "xla::InternalError(\"ld.lld execute fail: %s, error code %d\",\n                              error_message, lld_result)",
          "new_api": "llvm_ir::AsStringRef(\"-shared\")",
          "old_text": "xla::InternalError(\"ld.lld execute fail: %s, error code %d\",\n                              error_message, lld_result)",
          "new_text": "llvm_ir::AsStringRef(\"-shared\")",
          "old_line_content": "    return xla::InternalError(\"ld.lld execute fail: %s, error code %d\",",
          "new_line_content": "      llvm_ir::AsStringRef(\"gnu\"),       llvm_ir::AsStringRef(\"-shared\"),",
          "content_same": false
        },
        {
          "line": 763,
          "old_api": "reinterpret_cast<char*>(&hsaco[0])",
          "new_api": "xla::InternalError(\"ld.lld execute fail: %s, error code %d\",\n                              error_message, lld_result)",
          "old_text": "reinterpret_cast<char*>(&hsaco[0])",
          "new_text": "xla::InternalError(\"ld.lld execute fail: %s, error code %d\",\n                              error_message, lld_result)",
          "old_line_content": "  hsaco_file.read(reinterpret_cast<char*>(&hsaco[0]), hsaco_file_size);",
          "new_line_content": "    return xla::InternalError(\"ld.lld execute fail: %s, error code %d\",",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": "CouldNeedDeviceBitcode",
          "new_api": "c_str",
          "old_text": "CouldNeedDeviceBitcode(*module)",
          "new_text": "ir_path.c_str()",
          "old_line_content": "  if (!CouldNeedDeviceBitcode(*module)) {",
          "new_line_content": "    remove(ir_path.c_str());",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": "OkStatus",
          "new_api": "c_str",
          "old_text": "OkStatus()",
          "new_text": "isabin_path.c_str()",
          "old_line_content": "    return OkStatus();",
          "new_line_content": "    remove(isabin_path.c_str());",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "std::get_if<se::RocmComputeCapability>(&gpu_version)",
          "new_api": "LinkWithBitcodeVector",
          "old_text": "std::get_if<se::RocmComputeCapability>(&gpu_version)",
          "new_text": "LinkWithBitcodeVector(module,\n                               GetROCDLPaths(gcn_arch_name, rocdl_dir_path))",
          "old_line_content": "      std::get_if<se::RocmComputeCapability>(&gpu_version);",
          "new_line_content": "  return LinkWithBitcodeVector(module,",
          "content_same": false
        },
        {
          "line": 800,
          "old_api": "debug_options",
          "new_api": "std::get_if<se::RocmComputeCapability>(&gpu_version)",
          "old_text": "hlo_module_config.debug_options().xla_gpu_ftz()",
          "new_text": "std::get_if<se::RocmComputeCapability>(&gpu_version)",
          "old_line_content": "  if (hlo_module_config.debug_options().xla_gpu_ftz()) {",
          "new_line_content": "      std::get_if<se::RocmComputeCapability>(&gpu_version);",
          "content_same": false
        },
        {
          "line": 802,
          "old_api": "addFnAttr",
          "new_api": "xla::InternalError(\"Incompatible compute capability was specified.\")",
          "old_text": "fn.addFnAttr(\"denormal-fp-math-f32\", \"preserve-sign\")",
          "new_text": "xla::InternalError(\"Incompatible compute capability was specified.\")",
          "old_line_content": "      fn.addFnAttr(\"denormal-fp-math-f32\", \"preserve-sign\");",
          "new_line_content": "    return xla::InternalError(\"Incompatible compute capability was specified.\");",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": "OkStatus",
          "new_api": "TF_RETURN_IF_ERROR",
          "old_text": "OkStatus()",
          "new_text": "TF_RETURN_IF_ERROR(\n      LinkROCDLIfNecessary(module, gcn_arch_name, device_bitcode_dir_path))",
          "old_line_content": "  return OkStatus();",
          "new_line_content": "  TF_RETURN_IF_ERROR(",
          "content_same": false
        },
        {
          "line": 851,
          "old_api": "absl::StrJoin(mapped_tokens, \",\")",
          "new_api": "size",
          "old_text": "absl::StrJoin(mapped_tokens, \",\")",
          "new_text": "tokens.size()",
          "old_line_content": "  feature_str = absl::StrJoin(mapped_tokens, \",\");",
          "new_line_content": "  if (tokens.size() > 0) gfx = tokens[0];",
          "content_same": false
        },
        {
          "line": 863,
          "old_api": "GetFeatureStrFromGCNArchName",
          "new_api": "std::make_pair(gfx, feature_str)",
          "old_text": "GetFeatureStrFromGCNArchName(gcn_arch_name)",
          "new_text": "std::make_pair(gfx, feature_str)",
          "old_line_content": "  auto arch = GetFeatureStrFromGCNArchName(gcn_arch_name);",
          "new_line_content": "  return std::make_pair(gfx, feature_str);",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": "debug_options",
          "new_api": "std::get_if<se::RocmComputeCapability>(&gpu_version)",
          "old_text": "hlo_module_config.debug_options().xla_backend_extra_options()",
          "new_text": "std::get_if<se::RocmComputeCapability>(&gpu_version)",
          "old_line_content": "      hlo_module_config.debug_options().xla_backend_extra_options());",
          "new_line_content": "      std::get_if<se::RocmComputeCapability>(&gpu_version);",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": "LLVMInitializeAMDGPUAsmPrinter",
          "new_api": "debug_options",
          "old_text": "LLVMInitializeAMDGPUAsmPrinter()",
          "new_text": "llvm_ir::InitializeLLVMCommandLineOptions(\n      hlo_module_config.debug_options().xla_backend_extra_options())",
          "old_line_content": "  LLVMInitializeAMDGPUAsmPrinter();",
          "new_line_content": "  llvm_ir::InitializeLLVMCommandLineOptions(",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": "find",
          "new_api": "absl::call_once(backend_init_flag, AMDGPUBackendInit, hlo_module_config)",
          "old_text": "str.find('\\n')",
          "new_text": "absl::call_once(backend_init_flag, AMDGPUBackendInit, hlo_module_config)",
          "old_line_content": "    auto pos = str.find('\\n');",
          "new_line_content": "  absl::call_once(backend_init_flag, AMDGPUBackendInit, hlo_module_config);",
          "content_same": false
        },
        {
          "line": 915,
          "old_api": "str",
          "new_api": "find",
          "old_text": "module->getName().str()",
          "new_text": "str.find('\\n')",
          "old_line_content": "        [&] { return absl::StrCat(\"Compiling IR\", module->getName().str()); },",
          "new_line_content": "    auto pos = str.find('\\n');",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": "std::get_if<se::RocmComputeCapability>(&gpu_version)",
          "new_api": "substr",
          "old_text": "std::get_if<se::RocmComputeCapability>(&gpu_version)",
          "new_text": "str.substr(pos + 1)",
          "old_line_content": "        std::get_if<se::RocmComputeCapability>(&gpu_version);",
          "new_line_content": "    if (pos != std::string::npos) str = str.substr(pos + 1);",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": "xla::InternalError(\n          \"Incompatible compute capability was specified.\")",
          "new_api": "compilation_cache_key",
          "old_text": "xla::InternalError(\n          \"Incompatible compute capability was specified.\")",
          "new_text": "hlo_module_config.compilation_cache_key()",
          "old_line_content": "      return xla::InternalError(",
          "new_line_content": "  str += hlo_module_config.compilation_cache_key();",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": "VLOG",
          "new_api": "std::get_if<se::RocmComputeCapability>(&gpu_version)",
          "old_text": "VLOG(1)",
          "new_text": "std::get_if<se::RocmComputeCapability>(&gpu_version)",
          "old_line_content": "      VLOG(1) << \"HSACO cache hit\";",
          "new_line_content": "        std::get_if<se::RocmComputeCapability>(&gpu_version);",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": "AMDGPUGetTargetMachine",
          "new_api": "std::to_string(hsaco_count)",
          "old_text": "AMDGPUGetTargetMachine(default_target_triple, gpu_version,\n                               hlo_module_config)",
          "new_text": "std::to_string(hsaco_count)",
          "old_line_content": "        AMDGPUGetTargetMachine(default_target_triple, gpu_version,",
          "new_line_content": "      std::string name = \"/tmp/\" + std::to_string(hsaco_count) + \".ll\";",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": "get",
          "new_api": "close",
          "old_text": "LinkAndOptimizeModule(\n        module, gpu_version, hlo_module_config, rocdl_dir_path,\n        AMDGPUTargetModuleLinker, default_target_triple, target_machine.get(),\n        kAMDGPUInlineThreshold)",
          "new_text": "ofs.close()",
          "old_line_content": "    TF_RETURN_IF_ERROR(LinkAndOptimizeModule(",
          "new_line_content": "      ofs.close();",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": "get",
          "new_api": "AMDGPUGetTargetMachine",
          "old_text": "target_machine.get()",
          "new_text": "AMDGPUGetTargetMachine(default_target_triple, gpu_version,\n                               hlo_module_config)",
          "old_line_content": "    TF_ASSIGN_OR_RETURN(hsaco, EmitModuleToHsaco(module, target_machine.get()));",
          "new_line_content": "        AMDGPUGetTargetMachine(default_target_triple, gpu_version,",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 512,
          "old_api": null,
          "new_api": "llvm::PassRegistry::getPassRegistry()",
          "old_text": null,
          "new_text": "llvm::PassRegistry::getPassRegistry()",
          "old_line_content": "    const HloModuleConfig& hlo_module_config,",
          "new_line_content": "  llvm::PassRegistry* registry = llvm::PassRegistry::getPassRegistry();",
          "content_same": false
        },
        {
          "line": 513,
          "old_api": null,
          "new_api": "InitializePasses",
          "old_text": null,
          "new_text": "InitializePasses(registry)",
          "old_line_content": "    const std::string& libdevice_dir_path,",
          "new_line_content": "  InitializePasses(registry);",
          "content_same": false
        },
        {
          "line": 526,
          "old_api": null,
          "new_api": "absl::call_once(backend_init_flag, NVPTXBackendInit, hlo_module_config)",
          "old_text": null,
          "new_text": "absl::call_once(backend_init_flag, NVPTXBackendInit, hlo_module_config)",
          "old_line_content": "    // If the module has no functions or globals, there's nothing to compile.",
          "new_line_content": "  absl::call_once(backend_init_flag, NVPTXBackendInit, hlo_module_config);",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": null,
          "new_api": "str",
          "old_text": null,
          "new_text": "module->getName().str()",
          "old_line_content": "    }",
          "new_line_content": "        [&] { return absl::StrCat(\"Compiling IR:\", module->getName().str()); },",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": null,
          "new_api": "str",
          "old_text": null,
          "new_text": "module->getName().str()",
          "old_line_content": "    auto compute_capability =",
          "new_line_content": "    XLA_SCOPED_LOGGING_TIMER(\"Compile module \" + module->getName().str());",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": null,
          "new_api": "global_empty",
          "old_text": null,
          "new_text": "module->global_empty()",
          "old_line_content": "          \"Incompatible compute capability was specified.\");",
          "new_line_content": "    if (module->empty() && module->global_empty()) {",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": null,
          "new_api": "str",
          "old_text": null,
          "new_text": "module->getName().str()",
          "old_line_content": "    }",
          "new_line_content": "      VLOG(2) << \"Module '\" << module->getName().str()",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": null,
          "new_api": "std::string()",
          "old_text": null,
          "new_text": "std::string()",
          "old_line_content": "    llvm::Triple default_target_triple(\"nvptx64-unknown-unknown\");",
          "new_line_content": "      return std::string();",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": null,
          "new_api": "std::get_if<se::CudaComputeCapability>(&gpu_version)",
          "old_text": null,
          "new_text": "std::get_if<se::CudaComputeCapability>(&gpu_version)",
          "old_line_content": "",
          "new_line_content": "        std::get_if<se::CudaComputeCapability>(&gpu_version);",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": null,
          "new_api": "xla::InternalError(\n          \"Incompatible compute capability was specified.\")",
          "old_text": null,
          "new_text": "xla::InternalError(\n          \"Incompatible compute capability was specified.\")",
          "old_line_content": "    if (configure_target) {",
          "new_line_content": "      return xla::InternalError(",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": null,
          "new_api": "NVPTXGetTargetMachine",
          "old_text": null,
          "new_text": "NVPTXGetTargetMachine(\n        default_target_triple, *compute_capability, hlo_module_config)",
          "old_line_content": "    // Link with libdevice, and optimize the LLVM module.",
          "new_line_content": "    std::unique_ptr<llvm::TargetMachine> target_machine = NVPTXGetTargetMachine(",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "target_machine.get()",
          "old_line_content": "",
          "new_line_content": "      configure_target(target_machine.get());",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": null,
          "new_api": "NowMicros",
          "old_text": null,
          "new_text": "tsl::Env::Default()->NowMicros()",
          "old_line_content": "",
          "new_line_content": "    uint64_t start_usecs = tsl::Env::Default()->NowMicros();",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "LinkAndOptimizeModule(\n        module, gpu_version, hlo_module_config, libdevice_dir_path,\n        NVPTXTargetModuleLinker, default_target_triple, target_machine.get(),\n        kDefaultInlineThreshold)",
          "old_line_content": "    // Lower optimized LLVM module to PTX.",
          "new_line_content": "    TF_RETURN_IF_ERROR(LinkAndOptimizeModule(",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "target_machine.get()",
          "old_line_content": "",
          "new_line_content": "        NVPTXTargetModuleLinker, default_target_triple, target_machine.get(),",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": null,
          "new_api": "NowMicros",
          "old_text": null,
          "new_text": "tsl::Env::Default()->NowMicros()",
          "old_line_content": "  }",
          "new_line_content": "    uint64_t end_usecs = tsl::Env::Default()->NowMicros();",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": null,
          "new_api": "RecordLlvmPassesDuration",
          "old_text": null,
          "new_text": "RecordLlvmPassesDuration(end_usecs - start_usecs)",
          "old_line_content": "  return ptx;",
          "new_line_content": "    RecordLlvmPassesDuration(end_usecs - start_usecs);",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": null,
          "new_api": "NowMicros",
          "old_text": null,
          "new_text": "tsl::Env::Default()->NowMicros()",
          "old_line_content": "",
          "new_line_content": "    start_usecs = tsl::Env::Default()->NowMicros();",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "target_machine.get()",
          "old_line_content": "namespace {",
          "new_line_content": "    ptx = EmitModuleToPTX(module, target_machine.get());",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": null,
          "new_api": "NowMicros",
          "old_text": null,
          "new_text": "tsl::Env::Default()->NowMicros()",
          "old_line_content": "// Gets the ROCm-Device-Libs filenames for a particular AMDGPU version.",
          "new_line_content": "    end_usecs = tsl::Env::Default()->NowMicros();",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": null,
          "new_api": "RecordLlvmToPtxDuration",
          "old_text": null,
          "new_text": "RecordLlvmToPtxDuration(end_usecs - start_usecs)",
          "old_line_content": "std::vector<std::string> GetROCDLPaths(std::string gcn_arch_name,",
          "new_line_content": "    RecordLlvmToPtxDuration(end_usecs - start_usecs);",
          "content_same": false
        },
        {
          "line": 599,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "rocdl_filenames->size()",
          "old_line_content": "  }",
          "new_line_content": "  result.reserve(rocdl_filenames->size() + 1);",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": null,
          "new_api": "tsl::io::JoinPath(rocdl_dir_path, filename)",
          "old_text": null,
          "new_text": "tsl::io::JoinPath(rocdl_dir_path, filename)",
          "old_line_content": "      rocdl_dir_path,",
          "new_line_content": "    result.push_back(tsl::io::JoinPath(rocdl_dir_path, filename));",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": null,
          "new_api": "absl::StrSplit(gcn_arch_name, ':')",
          "old_text": null,
          "new_text": "absl::StrSplit(gcn_arch_name, ':')",
          "old_line_content": "",
          "new_line_content": "  std::vector<std::string> tokens = absl::StrSplit(gcn_arch_name, ':');",
          "content_same": false
        },
        {
          "line": 607,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "tokens[0].size()",
          "old_line_content": "  uint64_t hash;",
          "new_line_content": "  if (!tokens.empty() && tokens[0].size() >= 3) {",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": null,
          "new_api": "substr",
          "old_text": null,
          "new_text": "tokens[0].substr(3)",
          "old_line_content": "  std::string ir;",
          "new_line_content": "    amdgpu_version = tokens[0].substr(3);",
          "content_same": false
        },
        {
          "line": 610,
          "old_api": null,
          "new_api": "tsl::io::JoinPath(\n      rocdl_dir_path,\n      absl::StrCat(\"oclc_isa_version_\", amdgpu_version, \".bc\"))",
          "old_text": null,
          "new_text": "tsl::io::JoinPath(\n      rocdl_dir_path,\n      absl::StrCat(\"oclc_isa_version_\", amdgpu_version, \".bc\"))",
          "old_line_content": "  std::vector<uint8_t> hsaco;",
          "new_line_content": "  result.push_back(tsl::io::JoinPath(",
          "content_same": false
        },
        {
          "line": 612,
          "old_api": null,
          "new_api": "absl::StrCat(\"oclc_isa_version_\", amdgpu_version, \".bc\")",
          "old_text": null,
          "new_text": "absl::StrCat(\"oclc_isa_version_\", amdgpu_version, \".bc\")",
          "old_line_content": "",
          "new_line_content": "      absl::StrCat(\"oclc_isa_version_\", amdgpu_version, \".bc\")));",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": null,
          "new_api": "std::hash<std::string>{}(ir)",
          "old_text": null,
          "new_text": "std::hash<std::string>{}(ir)",
          "old_line_content": "  g_hsacoCache.request_count++;",
          "new_line_content": "  hash = std::hash<std::string>{}(ir);",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "g_hsacoCache.cache.size()",
          "old_line_content": "    llvm::Module* module, llvm::TargetMachine* target_machine) {",
          "new_line_content": "  g_hsacoCache.cache.resize(g_hsacoCache.cache.size() + 1);",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "g_hsacoCache.cache.back()",
          "old_line_content": "  std::vector<std::string> tempdir_vector;",
          "new_line_content": "  g_hsacoCache.cache.back().hash = hash;",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": null,
          "new_api": "tsl::Env::Default()",
          "old_text": null,
          "new_text": "tsl::Env::Default()",
          "old_line_content": "  bool keep_tempfiles = false;",
          "new_line_content": "  auto* env = tsl::Env::Default();",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": null,
          "new_api": "GetLocalTempDirectories",
          "old_text": null,
          "new_text": "env->GetLocalTempDirectories(&tempdir_vector)",
          "old_line_content": "                                             /*default_val=*/false,",
          "new_line_content": "  env->GetLocalTempDirectories(&tempdir_vector);",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "tempdir_vector.empty()",
          "old_line_content": "                                             &keep_tempfiles));",
          "new_line_content": "  if (tempdir_vector.empty()) {",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": null,
          "new_api": "xla::InternalError(\n        \"Unable to locate a temporary directory for compile-time artifacts.\")",
          "old_text": null,
          "new_text": "xla::InternalError(\n        \"Unable to locate a temporary directory for compile-time artifacts.\")",
          "old_line_content": "  // Prepare filenames for all stages of compilation:",
          "new_line_content": "    return xla::InternalError(",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "tempdir_vector.front()",
          "old_line_content": "  std::string ir_filename =",
          "new_line_content": "  std::string tempdir_name = tempdir_vector.front();",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": null,
          "new_api": "tensorflow::ReadBoolFromEnvVar(\"TF_ROCM_KEEP_XLA_TEMPFILES\",\n                                             /*default_val=*/false,\n                                             &keep_tempfiles)",
          "old_text": null,
          "new_text": "tensorflow::ReadBoolFromEnvVar(\"TF_ROCM_KEEP_XLA_TEMPFILES\",\n                                             /*default_val=*/false,\n                                             &keep_tempfiles)",
          "old_line_content": "  std::string ir_opt_filename =",
          "new_line_content": "  TF_CHECK_OK(tensorflow::ReadBoolFromEnvVar(\"TF_ROCM_KEEP_XLA_TEMPFILES\",",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": null,
          "new_api": "getModuleIdentifier",
          "old_text": null,
          "new_text": "module->getModuleIdentifier()",
          "old_line_content": "",
          "new_line_content": "      absl::StrCat(module->getModuleIdentifier(), random_number + \".ll\");",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": null,
          "new_api": "tsl::io::JoinPath(tempdir_name, ir_filename)",
          "old_text": null,
          "new_text": "tsl::io::JoinPath(tempdir_name, ir_filename)",
          "old_line_content": "  std::string hsaco_filename =",
          "new_line_content": "  std::string ir_path = tsl::io::JoinPath(tempdir_name, ir_filename);",
          "content_same": false
        },
        {
          "line": 697,
          "old_api": null,
          "new_api": "getModuleIdentifier",
          "old_text": null,
          "new_text": "module->getModuleIdentifier()",
          "old_line_content": "",
          "new_line_content": "      absl::StrCat(module->getModuleIdentifier(), random_number + \"_opt.ll\");",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": null,
          "new_api": "tsl::io::JoinPath(tempdir_name, ir_opt_filename)",
          "old_text": null,
          "new_text": "tsl::io::JoinPath(tempdir_name, ir_opt_filename)",
          "old_line_content": "  std::error_code ec;",
          "new_line_content": "  std::string ir_opt_path = tsl::io::JoinPath(tempdir_name, ir_opt_filename);",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": null,
          "new_api": "getModuleIdentifier",
          "old_text": null,
          "new_text": "module->getModuleIdentifier()",
          "old_line_content": "  std::unique_ptr<llvm::raw_fd_ostream> ir_fs(",
          "new_line_content": "      absl::StrCat(module->getModuleIdentifier(), random_number + \".o\");",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": null,
          "new_api": "tsl::io::JoinPath(tempdir_name, isabin_filename)",
          "old_text": null,
          "new_text": "tsl::io::JoinPath(tempdir_name, isabin_filename)",
          "old_line_content": "      new llvm::raw_fd_ostream(ir_path, ec, llvm::sys::fs::OF_None));",
          "new_line_content": "  std::string isabin_path = tsl::io::JoinPath(tempdir_name, isabin_filename);",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": null,
          "new_api": "getModuleIdentifier",
          "old_text": null,
          "new_text": "module->getModuleIdentifier()",
          "old_line_content": "",
          "new_line_content": "      absl::StrCat(module->getModuleIdentifier(), random_number + \".hsaco\");",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": null,
          "new_api": "tsl::io::JoinPath(tempdir_name, hsaco_filename)",
          "old_text": null,
          "new_text": "tsl::io::JoinPath(tempdir_name, hsaco_filename)",
          "old_line_content": "  // Emit GCN ISA binary.",
          "new_line_content": "  std::string hsaco_path = tsl::io::JoinPath(tempdir_name, hsaco_filename);",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": null,
          "new_api": "print",
          "old_text": null,
          "new_text": "module->print(*ir_fs, nullptr)",
          "old_line_content": "      \"\", false);",
          "new_line_content": "  module->print(*ir_fs, nullptr);",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": null,
          "new_api": "getModuleIdentifier",
          "old_text": null,
          "new_text": "module->getModuleIdentifier()",
          "old_line_content": "      new llvm::raw_fd_ostream(isabin_path, ec, llvm::sys::fs::OF_Text));",
          "new_line_content": "  std::string module_id = module->getModuleIdentifier();",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": null,
          "new_api": "getTargetTriple",
          "old_text": null,
          "new_text": "module->getTargetTriple()",
          "old_line_content": "",
          "new_line_content": "      llvm::Triple(module->getTargetTriple())));",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": null,
          "new_api": "addPassesToEmitFile",
          "old_text": null,
          "new_text": "target_machine->addPassesToEmitFile(codegen_passes, *isabin_fs, nullptr,\n                                      llvm::CGFT_ObjectFile)",
          "old_line_content": "  }",
          "new_line_content": "  target_machine->addPassesToEmitFile(codegen_passes, *isabin_fs, nullptr,",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": null,
          "new_api": "run",
          "old_text": null,
          "new_text": "codegen_passes.run(*module)",
          "old_line_content": "  // TODO(whchung@gmail.com): change to tensorflow::ROCmRoot() after",
          "new_line_content": "  codegen_passes.run(*module);",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": null,
          "new_api": "flush",
          "old_text": null,
          "new_text": "isabin_fs->flush()",
          "old_line_content": "  // ROCm-Device-Libs PR.",
          "new_line_content": "  isabin_fs->flush();",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": null,
          "new_api": "flush",
          "old_text": null,
          "new_text": "ir_fs->flush()",
          "old_line_content": "  }",
          "new_line_content": "    ir_fs->flush();",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": null,
          "new_api": "llvm::sys::findProgramByName(\"ld.lld\", {lld_path})",
          "old_text": null,
          "new_text": "llvm::sys::findProgramByName(\"ld.lld\", {lld_path})",
          "old_line_content": "  };",
          "new_line_content": "  auto lld_program = llvm::sys::findProgramByName(\"ld.lld\", {lld_path});",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": null,
          "new_api": "getError",
          "old_text": null,
          "new_text": "xla::InternalError(\"unable to find ld.lld in PATH: %s\",\n                              lld_program.getError().message())",
          "old_line_content": "  std::string error_message;",
          "new_line_content": "    return xla::InternalError(\"unable to find ld.lld in PATH: %s\",",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": null,
          "new_api": "getError",
          "old_text": null,
          "new_text": "lld_program.getError().message()",
          "old_line_content": "  int lld_result =",
          "new_line_content": "                              lld_program.getError().message());",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": null,
          "new_api": "llvm_ir::AsStringRef(\"-flavor\")",
          "old_text": null,
          "new_text": "llvm_ir::AsStringRef(\"-flavor\")",
          "old_line_content": "  if (lld_result) {",
          "new_line_content": "      llvm_ir::AsStringRef(\"ld.lld\"),    llvm_ir::AsStringRef(\"-flavor\"),",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": null,
          "new_api": "llvm_ir::AsStringRef(\"-o\")",
          "old_text": null,
          "new_text": "llvm_ir::AsStringRef(\"-o\")",
          "old_line_content": "                              error_message, lld_result);",
          "new_line_content": "      llvm_ir::AsStringRef(isabin_path), llvm_ir::AsStringRef(\"-o\"),",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": null,
          "new_api": "llvm_ir::AsStringRef(hsaco_path)",
          "old_text": null,
          "new_text": "llvm_ir::AsStringRef(hsaco_path)",
          "old_line_content": "  }",
          "new_line_content": "      llvm_ir::AsStringRef(hsaco_path),",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": null,
          "new_api": "llvm_ir::AsArrayRef(lld_args)",
          "old_text": null,
          "new_text": "llvm_ir::AsArrayRef(lld_args)",
          "old_line_content": "",
          "new_line_content": "      llvm::sys::ExecuteAndWait(*lld_program, llvm_ir::AsArrayRef(lld_args),",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": null,
          "new_api": "tellg",
          "old_text": null,
          "new_text": "hsaco_file.tellg()",
          "old_line_content": "  }",
          "new_line_content": "  std::ifstream::pos_type hsaco_file_size = hsaco_file.tellg();",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": null,
          "new_api": "seekg",
          "old_text": null,
          "new_text": "hsaco_file.seekg(0, std::ios::beg)",
          "old_line_content": "",
          "new_line_content": "  hsaco_file.seekg(0, std::ios::beg);",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": null,
          "new_api": "reinterpret_cast<char*>(&hsaco[0])",
          "old_text": null,
          "new_text": "reinterpret_cast<char*>(&hsaco[0])",
          "old_line_content": "// Links ROCm-Device-Libs into the given module if the module needs it.",
          "new_line_content": "  hsaco_file.read(reinterpret_cast<char*>(&hsaco[0]), hsaco_file_size);",
          "content_same": false
        },
        {
          "line": 774,
          "old_api": null,
          "new_api": "close",
          "old_text": null,
          "new_text": "hsaco_file.close()",
          "old_line_content": "Status LinkROCDLIfNecessary(llvm::Module* module, std::string gcn_arch_name,",
          "new_line_content": "  hsaco_file.close();",
          "content_same": false
        },
        {
          "line": 778,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "hsaco_path.c_str()",
          "old_line_content": "  }",
          "new_line_content": "    remove(hsaco_path.c_str());",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": null,
          "new_api": "CouldNeedDeviceBitcode",
          "old_text": null,
          "new_text": "CouldNeedDeviceBitcode(*module)",
          "old_line_content": "                                const std::string& device_bitcode_dir_path) {",
          "new_line_content": "  if (!CouldNeedDeviceBitcode(*module)) {",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": null,
          "new_api": "OkStatus",
          "old_text": null,
          "new_text": "OkStatus()",
          "old_line_content": "  // Link the input module with ROCDL.",
          "new_line_content": "    return OkStatus();",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": null,
          "new_api": "GetROCDLPaths",
          "old_text": null,
          "new_text": "GetROCDLPaths(gcn_arch_name, rocdl_dir_path)",
          "old_line_content": "  if (!compute_capability) {",
          "new_line_content": "                               GetROCDLPaths(gcn_arch_name, rocdl_dir_path));",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": null,
          "new_api": "gcn_arch_name",
          "old_text": null,
          "new_text": "compute_capability->gcn_arch_name()",
          "old_line_content": "",
          "new_line_content": "  std::string gcn_arch_name = compute_capability->gcn_arch_name();",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": null,
          "new_api": "LinkROCDLIfNecessary",
          "old_text": null,
          "new_text": "LinkROCDLIfNecessary(module, gcn_arch_name, device_bitcode_dir_path)",
          "old_line_content": "}",
          "new_line_content": "      LinkROCDLIfNecessary(module, gcn_arch_name, device_bitcode_dir_path));",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": null,
          "new_api": "debug_options",
          "old_text": null,
          "new_text": "hlo_module_config.debug_options().xla_gpu_ftz()",
          "old_line_content": "// hipDeviceProp_t::gcnArchName string, and maps it to a valid feature_str",
          "new_line_content": "  if (hlo_module_config.debug_options().xla_gpu_ftz()) {",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": null,
          "new_api": "addFnAttr",
          "old_text": null,
          "new_text": "fn.addFnAttr(\"denormal-fp-math-f32\", \"preserve-sign\")",
          "old_line_content": "// This mapping is currently in a state of flux because TF XLA uses its",
          "new_line_content": "      fn.addFnAttr(\"denormal-fp-math-f32\", \"preserve-sign\");",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": null,
          "new_api": "OkStatus",
          "old_text": null,
          "new_text": "OkStatus()",
          "old_line_content": "// related changes which have not yet been upstreamed (to the LLVM repo)",
          "new_line_content": "  return OkStatus();",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": null,
          "new_api": "absl::StrSplit(gcn_arch_name, ':')",
          "old_text": null,
          "new_text": "absl::StrSplit(gcn_arch_name, ':')",
          "old_line_content": "    }",
          "new_line_content": "  std::vector<std::string> tokens = absl::StrSplit(gcn_arch_name, ':');",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "tokens.end()",
          "old_line_content": "",
          "new_line_content": "  for (auto it = tokens.begin(); it != tokens.end(); it++) {",
          "content_same": false
        },
        {
          "line": 855,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "tokens.begin()",
          "old_line_content": "",
          "new_line_content": "    if (it != tokens.begin()) {",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": null,
          "new_api": "MapGCNArchNameTokenToFeatureStr",
          "old_text": null,
          "new_text": "MapGCNArchNameTokenToFeatureStr(token)",
          "old_line_content": "    llvm::Triple target_triple, GpuVersion gpu_version,",
          "new_line_content": "      std::string mapped_token = MapGCNArchNameTokenToFeatureStr(token);",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "mapped_tokens.push_back(mapped_token)",
          "old_line_content": "    const HloModuleConfig& hlo_module_config) {",
          "new_line_content": "      mapped_tokens.push_back(mapped_token);",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": null,
          "new_api": "absl::StrJoin(mapped_tokens, \",\")",
          "old_text": null,
          "new_text": "absl::StrJoin(mapped_tokens, \",\")",
          "old_line_content": "",
          "new_line_content": "  feature_str = absl::StrJoin(mapped_tokens, \",\");",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": null,
          "new_api": "gcn_arch_name",
          "old_text": null,
          "new_text": "compute_capability->gcn_arch_name()",
          "old_line_content": "  // Initialize the AMDGPU target; it's the only target we link with, so call",
          "new_line_content": "  std::string gcn_arch_name = compute_capability->gcn_arch_name();",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": null,
          "new_api": "GetFeatureStrFromGCNArchName",
          "old_text": null,
          "new_text": "GetFeatureStrFromGCNArchName(gcn_arch_name)",
          "old_line_content": "  // its specific initialization functions instead of the catch-all",
          "new_line_content": "  auto arch = GetFeatureStrFromGCNArchName(gcn_arch_name);",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": null,
          "new_api": "std::move(target_triple)",
          "old_text": null,
          "new_text": "std::move(target_triple)",
          "old_line_content": "  // InitializeAll*.",
          "new_line_content": "  return GetTargetMachine(std::move(target_triple), arch.first,",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": null,
          "new_api": "debug_options",
          "old_text": null,
          "new_text": "hlo_module_config.debug_options().xla_backend_extra_options()",
          "old_line_content": "",
          "new_line_content": "      hlo_module_config.debug_options().xla_backend_extra_options());",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": null,
          "new_api": "LLVMInitializeAMDGPUTarget",
          "old_text": null,
          "new_text": "LLVMInitializeAMDGPUTarget()",
          "old_line_content": "",
          "new_line_content": "  LLVMInitializeAMDGPUTarget();",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": null,
          "new_api": "LLVMInitializeAMDGPUTargetInfo",
          "old_text": null,
          "new_text": "LLVMInitializeAMDGPUTargetInfo()",
          "old_line_content": "}  // namespace",
          "new_line_content": "  LLVMInitializeAMDGPUTargetInfo();",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": null,
          "new_api": "LLVMInitializeAMDGPUTargetMC",
          "old_text": null,
          "new_text": "LLVMInitializeAMDGPUTargetMC()",
          "old_line_content": "",
          "new_line_content": "  LLVMInitializeAMDGPUTargetMC();",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": null,
          "new_api": "LLVMInitializeAMDGPUAsmPrinter",
          "old_text": null,
          "new_text": "LLVMInitializeAMDGPUAsmPrinter()",
          "old_line_content": "namespace amdgpu {",
          "new_line_content": "  LLVMInitializeAMDGPUAsmPrinter();",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": null,
          "new_api": "llvm::PassRegistry::getPassRegistry()",
          "old_text": null,
          "new_text": "llvm::PassRegistry::getPassRegistry()",
          "old_line_content": "    const std::string& rocdl_dir_path) {",
          "new_line_content": "  llvm::PassRegistry* registry = llvm::PassRegistry::getPassRegistry();",
          "content_same": false
        },
        {
          "line": 894,
          "old_api": null,
          "new_api": "InitializePasses",
          "old_text": null,
          "new_text": "InitializePasses(registry)",
          "old_line_content": "  static absl::once_flag backend_init_flag;",
          "new_line_content": "  InitializePasses(registry);",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": null,
          "new_api": "substr",
          "old_text": null,
          "new_text": "str.substr(0, 13)",
          "old_line_content": "    tensorflow::profiler::TraceMe activity(",
          "new_line_content": "  if (str.size() >= 13 && str.substr(0, 13) == \"; ModuleID = \") {",
          "content_same": false
        },
        {
          "line": 916,
          "old_api": null,
          "new_api": "substr",
          "old_text": null,
          "new_text": "str.substr(pos + 1)",
          "old_line_content": "        tensorflow::profiler::TraceMeLevel::kInfo);",
          "new_line_content": "    if (pos != std::string::npos) str = str.substr(pos + 1);",
          "content_same": false
        },
        {
          "line": 918,
          "old_api": null,
          "new_api": "substr",
          "old_text": null,
          "new_text": "str.substr(0, 18)",
          "old_line_content": "",
          "new_line_content": "  if (str.size() >= 18 && str.substr(0, 18) == \"source_filename = \") {",
          "content_same": false
        },
        {
          "line": 919,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "str.find('\\n')",
          "old_line_content": "    auto compute_capability =",
          "new_line_content": "    auto pos = str.find('\\n');",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": null,
          "new_api": "str",
          "old_text": null,
          "new_text": "module->getName().str()",
          "old_line_content": "",
          "new_line_content": "        [&] { return absl::StrCat(\"Compiling IR\", module->getName().str()); },",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": null,
          "new_api": "str",
          "old_text": null,
          "new_text": "module->getName().str()",
          "old_line_content": "",
          "new_line_content": "    XLA_SCOPED_LOGGING_TIMER(\"Compile module \" + module->getName().str());",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": null,
          "new_api": "xla::InternalError(\n          \"Incompatible compute capability was specified.\")",
          "old_text": null,
          "new_text": "xla::InternalError(\n          \"Incompatible compute capability was specified.\")",
          "old_line_content": "    }",
          "new_line_content": "      return xla::InternalError(",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": null,
          "new_api": "gcn_arch_name",
          "old_text": null,
          "new_text": "compute_capability->gcn_arch_name()",
          "old_line_content": "      static int hsaco_count = 0;",
          "new_line_content": "    std::string gcn_arch_name = compute_capability->gcn_arch_name();",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": null,
          "new_api": "HsacoCache::Find(str, hash, gcn_arch_name, hsaco)",
          "old_text": null,
          "new_text": "HsacoCache::Find(str, hash, gcn_arch_name, hsaco)",
          "old_line_content": "      std::ofstream ofs(name);",
          "new_line_content": "    if (HsacoCache::Find(str, hash, gcn_arch_name, hsaco)) {",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "      ofs << str;",
          "new_line_content": "      VLOG(1) << \"HSACO cache hit\";",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(1)",
          "old_line_content": "",
          "new_line_content": "    VLOG(1) << \"HSACO cache miss\";",
          "content_same": false
        },
        {
          "line": 961,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "LinkAndOptimizeModule(\n        module, gpu_version, hlo_module_config, rocdl_dir_path,\n        AMDGPUTargetModuleLinker, default_target_triple, target_machine.get(),\n        kAMDGPUInlineThreshold)",
          "old_line_content": "}",
          "new_line_content": "    TF_RETURN_IF_ERROR(LinkAndOptimizeModule(",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "target_machine.get()",
          "old_line_content": "}  // namespace amdgpu",
          "new_line_content": "        AMDGPUTargetModuleLinker, default_target_triple, target_machine.get(),",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "target_machine.get()",
          "old_line_content": "",
          "new_line_content": "    TF_ASSIGN_OR_RETURN(hsaco, EmitModuleToHsaco(module, target_machine.get()));",
          "content_same": false
        },
        {
          "line": 968,
          "old_api": null,
          "new_api": "HsacoCache::Add(str, hash, gcn_arch_name, hsaco)",
          "old_text": null,
          "new_text": "HsacoCache::Add(str, hash, gcn_arch_name, hsaco)",
          "old_line_content": "",
          "new_line_content": "    HsacoCache::Add(str, hash, gcn_arch_name, hsaco);",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": null,
          "new_api": "debug_options",
          "old_text": null,
          "new_text": "llvm_ir::InitializeLLVMCommandLineOptions(\n      hlo_module_config.debug_options().xla_backend_extra_options())",
          "old_line_content": "  // Initialize the LLVM optimization passes.",
          "new_line_content": "  llvm_ir::InitializeLLVMCommandLineOptions(",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": null,
          "new_api": "LLVMInitializeNVPTXTarget",
          "old_text": null,
          "new_text": "LLVMInitializeNVPTXTarget()",
          "old_line_content": "}  // namespace",
          "new_line_content": "  LLVMInitializeNVPTXTarget();",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": null,
          "new_api": "LLVMInitializeNVPTXTargetInfo",
          "old_text": null,
          "new_text": "LLVMInitializeNVPTXTargetInfo()",
          "old_line_content": "",
          "new_line_content": "  LLVMInitializeNVPTXTargetInfo();",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": null,
          "new_api": "LLVMInitializeNVPTXTargetMC",
          "old_text": null,
          "new_text": "LLVMInitializeNVPTXTargetMC()",
          "old_line_content": "namespace nvptx {",
          "new_line_content": "  LLVMInitializeNVPTXTargetMC();",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": null,
          "new_api": "LLVMInitializeNVPTXAsmPrinter",
          "old_text": null,
          "new_text": "LLVMInitializeNVPTXAsmPrinter()",
          "old_line_content": "",
          "new_line_content": "  LLVMInitializeNVPTXAsmPrinter();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 516,
          "old_api": "absl::call_once(backend_init_flag, NVPTXBackendInit, hlo_module_config)",
          "new_api": null,
          "old_text": "absl::call_once(backend_init_flag, NVPTXBackendInit, hlo_module_config)",
          "new_text": null,
          "old_line_content": "  absl::call_once(backend_init_flag, NVPTXBackendInit, hlo_module_config);",
          "new_line_content": "}  // namespace",
          "content_same": false
        },
        {
          "line": 522,
          "old_api": "str",
          "new_api": null,
          "old_text": "module->getName().str()",
          "new_text": null,
          "old_line_content": "        [&] { return absl::StrCat(\"Compiling IR:\", module->getName().str()); },",
          "new_line_content": "    const HloModuleConfig& hlo_module_config,",
          "content_same": false
        },
        {
          "line": 524,
          "old_api": "str",
          "new_api": null,
          "old_text": "module->getName().str()",
          "new_text": null,
          "old_line_content": "    XLA_SCOPED_LOGGING_TIMER(\"Compile module \" + module->getName().str());",
          "new_line_content": "    std::function<void(llvm::TargetMachine*)> configure_target) {",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": "global_empty",
          "new_api": null,
          "old_text": "module->global_empty()",
          "new_text": null,
          "old_line_content": "    if (module->empty() && module->global_empty()) {",
          "new_line_content": "  std::string ptx;",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": "str",
          "new_api": null,
          "old_text": "module->getName().str()",
          "new_text": null,
          "old_line_content": "      VLOG(2) << \"Module '\" << module->getName().str()",
          "new_line_content": "  std::unique_ptr<llvm::TargetMachine> target_machine;",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": "std::string()",
          "new_api": null,
          "old_text": "std::string()",
          "new_text": null,
          "old_line_content": "      return std::string();",
          "new_line_content": "    tensorflow::profiler::TraceMe activity(",
          "content_same": false
        },
        {
          "line": 535,
          "old_api": "std::get_if<se::CudaComputeCapability>(&gpu_version)",
          "new_api": null,
          "old_text": "std::get_if<se::CudaComputeCapability>(&gpu_version)",
          "new_text": null,
          "old_line_content": "        std::get_if<se::CudaComputeCapability>(&gpu_version);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": "xla::InternalError(\n          \"Incompatible compute capability was specified.\")",
          "new_api": null,
          "old_text": "xla::InternalError(\n          \"Incompatible compute capability was specified.\")",
          "new_text": null,
          "old_line_content": "      return xla::InternalError(",
          "new_line_content": "    // Just return an empty string.",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": "NVPTXGetTargetMachine",
          "new_api": null,
          "old_text": "NVPTXGetTargetMachine(\n        default_target_triple, *compute_capability, hlo_module_config)",
          "new_text": null,
          "old_line_content": "    std::unique_ptr<llvm::TargetMachine> target_machine = NVPTXGetTargetMachine(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 548,
          "old_api": "get",
          "new_api": null,
          "old_text": "target_machine.get()",
          "new_text": null,
          "old_line_content": "      configure_target(target_machine.get());",
          "new_line_content": "          \"Incompatible compute capability was specified.\");",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": "NowMicros",
          "new_api": null,
          "old_text": "tsl::Env::Default()->NowMicros()",
          "new_text": null,
          "old_line_content": "    uint64_t start_usecs = tsl::Env::Default()->NowMicros();",
          "new_line_content": "    llvm::Triple default_target_triple(\"nvptx64-unknown-unknown\");",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": "get",
          "new_api": null,
          "old_text": "LinkAndOptimizeModule(\n        module, gpu_version, hlo_module_config, libdevice_dir_path,\n        NVPTXTargetModuleLinker, default_target_triple, target_machine.get(),\n        kDefaultInlineThreshold)",
          "new_text": null,
          "old_line_content": "    TF_RETURN_IF_ERROR(LinkAndOptimizeModule(",
          "new_line_content": "        default_target_triple, *compute_capability, hlo_module_config);",
          "content_same": false
        },
        {
          "line": 556,
          "old_api": "get",
          "new_api": null,
          "old_text": "target_machine.get()",
          "new_text": null,
          "old_line_content": "        NVPTXTargetModuleLinker, default_target_triple, target_machine.get(),",
          "new_line_content": "    // Apply target machine configuration from call-back if available.",
          "content_same": false
        },
        {
          "line": 559,
          "old_api": "NowMicros",
          "new_api": null,
          "old_text": "tsl::Env::Default()->NowMicros()",
          "new_text": null,
          "old_line_content": "    uint64_t end_usecs = tsl::Env::Default()->NowMicros();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": "RecordLlvmPassesDuration",
          "new_api": null,
          "old_text": "RecordLlvmPassesDuration(end_usecs - start_usecs)",
          "new_text": null,
          "old_line_content": "    RecordLlvmPassesDuration(end_usecs - start_usecs);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": "NowMicros",
          "new_api": null,
          "old_text": "tsl::Env::Default()->NowMicros()",
          "new_text": null,
          "old_line_content": "    start_usecs = tsl::Env::Default()->NowMicros();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": "get",
          "new_api": null,
          "old_text": "target_machine.get()",
          "new_text": null,
          "old_line_content": "    ptx = EmitModuleToPTX(module, target_machine.get());",
          "new_line_content": "        module, gpu_version, hlo_module_config, libdevice_dir_path,",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": "NowMicros",
          "new_api": null,
          "old_text": "tsl::Env::Default()->NowMicros()",
          "new_text": null,
          "old_line_content": "    end_usecs = tsl::Env::Default()->NowMicros();",
          "new_line_content": "        kDefaultInlineThreshold));",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": "RecordLlvmToPtxDuration",
          "new_api": null,
          "old_text": "RecordLlvmToPtxDuration(end_usecs - start_usecs)",
          "new_text": null,
          "old_line_content": "    RecordLlvmToPtxDuration(end_usecs - start_usecs);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": "size",
          "new_api": null,
          "old_text": "rocdl_filenames->size()",
          "new_text": null,
          "old_line_content": "  result.reserve(rocdl_filenames->size() + 1);",
          "new_line_content": "                                       const std::string& rocdl_dir_path) {",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": "tsl::io::JoinPath(rocdl_dir_path, filename)",
          "new_api": null,
          "old_text": "tsl::io::JoinPath(rocdl_dir_path, filename)",
          "new_text": null,
          "old_line_content": "    result.push_back(tsl::io::JoinPath(rocdl_dir_path, filename));",
          "new_line_content": "  static std::vector<std::string>* rocdl_filenames =",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "absl::StrSplit(gcn_arch_name, ':')",
          "new_api": null,
          "old_text": "absl::StrSplit(gcn_arch_name, ':')",
          "new_text": null,
          "old_line_content": "  std::vector<std::string> tokens = absl::StrSplit(gcn_arch_name, ':');",
          "new_line_content": "           \"oclc_unsafe_math_off.bc\", \"oclc_wavefrontsize64_on.bc\"});",
          "content_same": false
        },
        {
          "line": 597,
          "old_api": "size",
          "new_api": null,
          "old_text": "tokens[0].size()",
          "new_text": null,
          "old_line_content": "  if (!tokens.empty() && tokens[0].size() >= 3) {",
          "new_line_content": "  // Construct full path to ROCDL bitcode libraries.",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": "substr",
          "new_api": null,
          "old_text": "tokens[0].substr(3)",
          "new_text": null,
          "old_line_content": "    amdgpu_version = tokens[0].substr(3);",
          "new_line_content": "  std::vector<std::string> result;",
          "content_same": false
        },
        {
          "line": 600,
          "old_api": "tsl::io::JoinPath(\n      rocdl_dir_path,\n      absl::StrCat(\"oclc_isa_version_\", amdgpu_version, \".bc\"))",
          "new_api": null,
          "old_text": "tsl::io::JoinPath(\n      rocdl_dir_path,\n      absl::StrCat(\"oclc_isa_version_\", amdgpu_version, \".bc\"))",
          "new_text": null,
          "old_line_content": "  result.push_back(tsl::io::JoinPath(",
          "new_line_content": "  for (auto& filename : *rocdl_filenames) {",
          "content_same": false
        },
        {
          "line": 602,
          "old_api": "absl::StrCat(\"oclc_isa_version_\", amdgpu_version, \".bc\")",
          "new_api": null,
          "old_text": "absl::StrCat(\"oclc_isa_version_\", amdgpu_version, \".bc\")",
          "new_text": null,
          "old_line_content": "      absl::StrCat(\"oclc_isa_version_\", amdgpu_version, \".bc\")));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 632,
          "old_api": "std::hash<std::string>{}(ir)",
          "new_api": null,
          "old_text": "std::hash<std::string>{}(ir)",
          "new_text": null,
          "old_line_content": "  hash = std::hash<std::string>{}(ir);",
          "new_line_content": "                   const std::string& gfx, std::vector<uint8_t>& hsaco);",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(1)",
          "new_text": null,
          "old_line_content": "    VLOG(1) << \"HSACO cache: \" << g_hsacoCache.request_count << \" requests, \"",
          "new_line_content": "    if (x.hash != hash) continue;",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": "size",
          "new_api": null,
          "old_text": "g_hsacoCache.cache.size()",
          "new_text": null,
          "old_line_content": "  g_hsacoCache.cache.resize(g_hsacoCache.cache.size() + 1);",
          "new_line_content": "  if (!(g_hsacoCache.request_count % 50))",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": "back",
          "new_api": null,
          "old_text": "g_hsacoCache.cache.back()",
          "new_text": null,
          "old_line_content": "  g_hsacoCache.cache.back().hash = hash;",
          "new_line_content": "            << g_hsacoCache.hit_count << \" hits\";",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": "back",
          "new_api": null,
          "old_text": "g_hsacoCache.cache.back()",
          "new_text": null,
          "old_line_content": "  g_hsacoCache.cache.back().gfx = gfx;",
          "new_line_content": "  return hit;",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": "back",
          "new_api": null,
          "old_text": "g_hsacoCache.cache.back()",
          "new_text": null,
          "old_line_content": "  g_hsacoCache.cache.back().hsaco = hsaco;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": "xla::InternalError(\n        \"Unable to locate a temporary directory for compile-time artifacts.\")",
          "new_api": null,
          "old_text": "xla::InternalError(\n        \"Unable to locate a temporary directory for compile-time artifacts.\")",
          "new_text": null,
          "old_line_content": "    return xla::InternalError(",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": "front",
          "new_api": null,
          "old_text": "tempdir_vector.front()",
          "new_text": null,
          "old_line_content": "  std::string tempdir_name = tempdir_vector.front();",
          "new_line_content": "// TargetMachine for the AMDGPU target.",
          "content_same": false
        },
        {
          "line": 673,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(1)",
          "new_text": null,
          "old_line_content": "  VLOG(1) << \"Compile-time artifacts located at: \" << tempdir_name;",
          "new_line_content": "StatusOr<std::vector<uint8_t>> EmitModuleToHsaco(",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": "tensorflow::ReadBoolFromEnvVar(\"TF_ROCM_KEEP_XLA_TEMPFILES\",\n                                             /*default_val=*/false,\n                                             &keep_tempfiles)",
          "new_api": null,
          "old_text": "tensorflow::ReadBoolFromEnvVar(\"TF_ROCM_KEEP_XLA_TEMPFILES\",\n                                             /*default_val=*/false,\n                                             &keep_tempfiles)",
          "new_text": null,
          "old_line_content": "  TF_CHECK_OK(tensorflow::ReadBoolFromEnvVar(\"TF_ROCM_KEEP_XLA_TEMPFILES\",",
          "new_line_content": "  std::vector<std::string> tempdir_vector;",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": "tsl::random::New64()",
          "new_api": null,
          "old_text": "tsl::random::New64()",
          "new_text": null,
          "old_line_content": "  std::string random_number = std::to_string(tsl::random::New64());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": "tsl::io::JoinPath(tempdir_name, ir_filename)",
          "new_api": null,
          "old_text": "tsl::io::JoinPath(tempdir_name, ir_filename)",
          "new_text": null,
          "old_line_content": "  std::string ir_path = tsl::io::JoinPath(tempdir_name, ir_filename);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "getModuleIdentifier",
          "new_api": null,
          "old_text": "module->getModuleIdentifier()",
          "new_text": null,
          "old_line_content": "      absl::StrCat(module->getModuleIdentifier(), random_number + \"_opt.ll\");",
          "new_line_content": "                                             /*default_val=*/false,",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": "tsl::io::JoinPath(tempdir_name, ir_opt_filename)",
          "new_api": null,
          "old_text": "tsl::io::JoinPath(tempdir_name, ir_opt_filename)",
          "new_text": null,
          "old_line_content": "  std::string ir_opt_path = tsl::io::JoinPath(tempdir_name, ir_opt_filename);",
          "new_line_content": "                                             &keep_tempfiles));",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": "tsl::io::JoinPath(tempdir_name, isabin_filename)",
          "new_api": null,
          "old_text": "tsl::io::JoinPath(tempdir_name, isabin_filename)",
          "new_text": null,
          "old_line_content": "  std::string isabin_path = tsl::io::JoinPath(tempdir_name, isabin_filename);",
          "new_line_content": "  std::string ir_filename =",
          "content_same": false
        },
        {
          "line": 695,
          "old_api": "getModuleIdentifier",
          "new_api": null,
          "old_text": "module->getModuleIdentifier()",
          "new_text": null,
          "old_line_content": "      absl::StrCat(module->getModuleIdentifier(), random_number + \".hsaco\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 696,
          "old_api": "tsl::io::JoinPath(tempdir_name, hsaco_filename)",
          "new_api": null,
          "old_text": "tsl::io::JoinPath(tempdir_name, hsaco_filename)",
          "new_text": null,
          "old_line_content": "  std::string hsaco_path = tsl::io::JoinPath(tempdir_name, hsaco_filename);",
          "new_line_content": "  std::string ir_opt_filename =",
          "content_same": false
        },
        {
          "line": 703,
          "old_api": "print",
          "new_api": null,
          "old_text": "module->print(*ir_fs, nullptr)",
          "new_text": null,
          "old_line_content": "  module->print(*ir_fs, nullptr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 704,
          "old_api": "flush",
          "new_api": null,
          "old_text": "ir_fs->flush()",
          "new_text": null,
          "old_line_content": "  ir_fs->flush();",
          "new_line_content": "  std::string hsaco_filename =",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": "getModuleIdentifier",
          "new_api": null,
          "old_text": "module->getModuleIdentifier()",
          "new_text": null,
          "old_line_content": "  std::string module_id = module->getModuleIdentifier();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": "tsl::io::Basename(module_id)",
          "new_api": null,
          "old_text": "tsl::io::Basename(module_id)",
          "new_text": null,
          "old_line_content": "      ReplaceFilenameExtension(tsl::io::Basename(module_id),",
          "new_line_content": "  std::unique_ptr<llvm::raw_fd_ostream> ir_fs(",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": "getTargetTriple",
          "new_api": null,
          "old_text": "module->getTargetTriple()",
          "new_text": null,
          "old_line_content": "      llvm::Triple(module->getTargetTriple())));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": "createDataLayout",
          "new_api": null,
          "old_text": "target_machine->createDataLayout()",
          "new_text": null,
          "old_line_content": "  module->setDataLayout(target_machine->createDataLayout());",
          "new_line_content": "  IrDumpingPassManager codegen_passes(",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": "run",
          "new_api": null,
          "old_text": "codegen_passes.run(*module)",
          "new_text": null,
          "old_line_content": "  codegen_passes.run(*module);",
          "new_line_content": "      \"\", false);",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": "print",
          "new_api": null,
          "old_text": "module->print(*ir_fs, nullptr)",
          "new_text": null,
          "old_line_content": "    module->print(*ir_fs, nullptr);",
          "new_line_content": "      new llvm::raw_fd_ostream(isabin_path, ec, llvm::sys::fs::OF_Text));",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": "tsl::io::JoinPath(\"/opt/rocm\", \"llvm/bin\")",
          "new_api": null,
          "old_text": "tsl::io::JoinPath(\"/opt/rocm\", \"llvm/bin\")",
          "new_text": null,
          "old_line_content": "  std::string lld_path = tsl::io::JoinPath(\"/opt/rocm\", \"llvm/bin\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": "llvm::sys::findProgramByName(\"ld.lld\", {lld_path})",
          "new_api": null,
          "old_text": "llvm::sys::findProgramByName(\"ld.lld\", {lld_path})",
          "new_text": null,
          "old_line_content": "  auto lld_program = llvm::sys::findProgramByName(\"ld.lld\", {lld_path});",
          "new_line_content": "  if (keep_tempfiles) {",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": "getError",
          "new_api": null,
          "old_text": "xla::InternalError(\"unable to find ld.lld in PATH: %s\",\n                              lld_program.getError().message())",
          "new_text": null,
          "old_line_content": "    return xla::InternalError(\"unable to find ld.lld in PATH: %s\",",
          "new_line_content": "        new llvm::raw_fd_ostream(ir_opt_path, ec, llvm::sys::fs::OF_None));",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": "llvm_ir::AsStringRef(\"-flavor\")",
          "new_api": null,
          "old_text": "llvm_ir::AsStringRef(\"-flavor\")",
          "new_text": null,
          "old_line_content": "      llvm_ir::AsStringRef(\"ld.lld\"),    llvm_ir::AsStringRef(\"-flavor\"),",
          "new_line_content": "  // Locate lld.",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "llvm_ir::AsStringRef(\"-shared\")",
          "new_api": null,
          "old_text": "llvm_ir::AsStringRef(\"-shared\")",
          "new_text": null,
          "old_line_content": "      llvm_ir::AsStringRef(\"gnu\"),       llvm_ir::AsStringRef(\"-shared\"),",
          "new_line_content": "  // TODO(whchung@gmail.com): change to tensorflow::ROCmRoot() after",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": "llvm_ir::AsStringRef(\"-o\")",
          "new_api": null,
          "old_text": "llvm_ir::AsStringRef(\"-o\")",
          "new_text": null,
          "old_line_content": "      llvm_ir::AsStringRef(isabin_path), llvm_ir::AsStringRef(\"-o\"),",
          "new_line_content": "  // ROCm-Device-Libs PR.",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": "llvm_ir::AsArrayRef(lld_args)",
          "new_api": null,
          "old_text": "llvm_ir::AsArrayRef(lld_args)",
          "new_text": null,
          "old_line_content": "      llvm::sys::ExecuteAndWait(*lld_program, llvm_ir::AsArrayRef(lld_args),",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": "tellg",
          "new_api": null,
          "old_text": "hsaco_file.tellg()",
          "new_text": null,
          "old_line_content": "  std::ifstream::pos_type hsaco_file_size = hsaco_file.tellg();",
          "new_line_content": "  int lld_result =",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": "seekg",
          "new_api": null,
          "old_text": "hsaco_file.seekg(0, std::ios::beg)",
          "new_text": null,
          "old_line_content": "  hsaco_file.seekg(0, std::ios::beg);",
          "new_line_content": "  if (lld_result) {",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": "close",
          "new_api": null,
          "old_text": "hsaco_file.close()",
          "new_text": null,
          "old_line_content": "  hsaco_file.close();",
          "new_line_content": "                              error_message, lld_result);",
          "content_same": false
        },
        {
          "line": 766,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "ir_path.c_str()",
          "new_text": null,
          "old_line_content": "    remove(ir_path.c_str());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "isabin_path.c_str()",
          "new_text": null,
          "old_line_content": "    remove(isabin_path.c_str());",
          "new_line_content": "  // Read HSACO.",
          "content_same": false
        },
        {
          "line": 768,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "hsaco_path.c_str()",
          "new_text": null,
          "old_line_content": "    remove(hsaco_path.c_str());",
          "new_line_content": "  std::ifstream hsaco_file(hsaco_path, std::ios::binary | std::ios::ate);",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": "LinkWithBitcodeVector",
          "new_api": null,
          "old_text": "LinkWithBitcodeVector(module,\n                               GetROCDLPaths(gcn_arch_name, rocdl_dir_path))",
          "new_text": null,
          "old_line_content": "  return LinkWithBitcodeVector(module,",
          "new_line_content": "  return hsaco;",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": "GetROCDLPaths",
          "new_api": null,
          "old_text": "GetROCDLPaths(gcn_arch_name, rocdl_dir_path)",
          "new_text": null,
          "old_line_content": "                               GetROCDLPaths(gcn_arch_name, rocdl_dir_path));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": "xla::InternalError(\"Incompatible compute capability was specified.\")",
          "new_api": null,
          "old_text": "xla::InternalError(\"Incompatible compute capability was specified.\")",
          "new_text": null,
          "old_line_content": "    return xla::InternalError(\"Incompatible compute capability was specified.\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": "gcn_arch_name",
          "new_api": null,
          "old_text": "compute_capability->gcn_arch_name()",
          "new_text": null,
          "old_line_content": "  std::string gcn_arch_name = compute_capability->gcn_arch_name();",
          "new_line_content": "                                const HloModuleConfig& hlo_module_config,",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": "TF_RETURN_IF_ERROR",
          "new_api": null,
          "old_text": "TF_RETURN_IF_ERROR(\n      LinkROCDLIfNecessary(module, gcn_arch_name, device_bitcode_dir_path))",
          "new_text": null,
          "old_line_content": "  TF_RETURN_IF_ERROR(",
          "new_line_content": "                                const std::string& device_bitcode_dir_path) {",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": "LinkROCDLIfNecessary",
          "new_api": null,
          "old_text": "LinkROCDLIfNecessary(module, gcn_arch_name, device_bitcode_dir_path)",
          "new_text": null,
          "old_line_content": "      LinkROCDLIfNecessary(module, gcn_arch_name, device_bitcode_dir_path));",
          "new_line_content": "  // Link the input module with ROCDL.",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": "absl::StrSplit(gcn_arch_name, ':')",
          "new_api": null,
          "old_text": "absl::StrSplit(gcn_arch_name, ':')",
          "new_text": null,
          "old_line_content": "  std::vector<std::string> tokens = absl::StrSplit(gcn_arch_name, ':');",
          "new_line_content": "  return \"\";",
          "content_same": false
        },
        {
          "line": 841,
          "old_api": "size",
          "new_api": null,
          "old_text": "tokens.size()",
          "new_text": null,
          "old_line_content": "  if (tokens.size() > 0) gfx = tokens[0];",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": "end",
          "new_api": null,
          "old_text": "tokens.end()",
          "new_text": null,
          "old_line_content": "  for (auto it = tokens.begin(); it != tokens.end(); it++) {",
          "new_line_content": "std::pair<std::string, std::string> GetFeatureStrFromGCNArchName(",
          "content_same": false
        },
        {
          "line": 845,
          "old_api": "begin",
          "new_api": null,
          "old_text": "tokens.begin()",
          "new_text": null,
          "old_line_content": "    if (it != tokens.begin()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": "MapGCNArchNameTokenToFeatureStr",
          "new_api": null,
          "old_text": "MapGCNArchNameTokenToFeatureStr(token)",
          "new_text": null,
          "old_line_content": "      std::string mapped_token = MapGCNArchNameTokenToFeatureStr(token);",
          "new_line_content": "  // For ROCm versions 4.0 and greater, we need to specify the correct",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "mapped_tokens.push_back(mapped_token)",
          "new_text": null,
          "old_line_content": "      mapped_tokens.push_back(mapped_token);",
          "new_line_content": "  // feature str, based on the underlying GPU HW to get max performance.",
          "content_same": false
        },
        {
          "line": 853,
          "old_api": "std::make_pair(gfx, feature_str)",
          "new_api": null,
          "old_text": "std::make_pair(gfx, feature_str)",
          "new_text": null,
          "old_line_content": "  return std::make_pair(gfx, feature_str);",
          "new_line_content": "    // Skip the first token, that is the gfxNNN str",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": "std::get_if<se::RocmComputeCapability>(&gpu_version)",
          "new_api": null,
          "old_text": "std::get_if<se::RocmComputeCapability>(&gpu_version)",
          "new_text": null,
          "old_line_content": "      std::get_if<se::RocmComputeCapability>(&gpu_version);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": "gcn_arch_name",
          "new_api": null,
          "old_text": "compute_capability->gcn_arch_name()",
          "new_text": null,
          "old_line_content": "  std::string gcn_arch_name = compute_capability->gcn_arch_name();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 864,
          "old_api": "std::move(target_triple)",
          "new_api": null,
          "old_text": "std::move(target_triple)",
          "new_text": null,
          "old_line_content": "  return GetTargetMachine(std::move(target_triple), arch.first,",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": "debug_options",
          "new_api": null,
          "old_text": "llvm_ir::InitializeLLVMCommandLineOptions(\n      hlo_module_config.debug_options().xla_backend_extra_options())",
          "new_text": null,
          "old_line_content": "  llvm_ir::InitializeLLVMCommandLineOptions(",
          "new_line_content": "  auto compute_capability =",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": "LLVMInitializeAMDGPUTarget",
          "new_api": null,
          "old_text": "LLVMInitializeAMDGPUTarget()",
          "new_text": null,
          "old_line_content": "  LLVMInitializeAMDGPUTarget();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": "LLVMInitializeAMDGPUTargetInfo",
          "new_api": null,
          "old_text": "LLVMInitializeAMDGPUTargetInfo()",
          "new_text": null,
          "old_line_content": "  LLVMInitializeAMDGPUTargetInfo();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": "LLVMInitializeAMDGPUTargetMC",
          "new_api": null,
          "old_text": "LLVMInitializeAMDGPUTargetMC()",
          "new_text": null,
          "old_line_content": "  LLVMInitializeAMDGPUTargetMC();",
          "new_line_content": "void AMDGPUBackendInit(const HloModuleConfig& hlo_module_config) {",
          "content_same": false
        },
        {
          "line": 883,
          "old_api": "llvm::PassRegistry::getPassRegistry()",
          "new_api": null,
          "old_text": "llvm::PassRegistry::getPassRegistry()",
          "new_text": null,
          "old_line_content": "  llvm::PassRegistry* registry = llvm::PassRegistry::getPassRegistry();",
          "new_line_content": "  // its specific initialization functions instead of the catch-all",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": "InitializePasses",
          "new_api": null,
          "old_text": "InitializePasses(registry)",
          "new_text": null,
          "old_line_content": "  InitializePasses(registry);",
          "new_line_content": "  // InitializeAll*.",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": "absl::call_once(backend_init_flag, AMDGPUBackendInit, hlo_module_config)",
          "new_api": null,
          "old_text": "absl::call_once(backend_init_flag, AMDGPUBackendInit, hlo_module_config)",
          "new_text": null,
          "old_line_content": "  absl::call_once(backend_init_flag, AMDGPUBackendInit, hlo_module_config);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": "substr",
          "new_api": null,
          "old_text": "str.substr(0, 13)",
          "new_text": null,
          "old_line_content": "  if (str.size() >= 13 && str.substr(0, 13) == \"; ModuleID = \") {",
          "new_line_content": "  static absl::once_flag backend_init_flag;",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": "substr",
          "new_api": null,
          "old_text": "str.substr(pos + 1)",
          "new_text": null,
          "old_line_content": "    if (pos != std::string::npos) str = str.substr(pos + 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": "substr",
          "new_api": null,
          "old_text": "str.substr(0, 18)",
          "new_text": null,
          "old_line_content": "  if (str.size() >= 18 && str.substr(0, 18) == \"source_filename = \") {",
          "new_line_content": "  std::unique_ptr<llvm::TargetMachine> target_machine;",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": "find",
          "new_api": null,
          "old_text": "str.find('\\n')",
          "new_text": null,
          "old_line_content": "    auto pos = str.find('\\n');",
          "new_line_content": "  std::string str;",
          "content_same": false
        },
        {
          "line": 910,
          "old_api": "substr",
          "new_api": null,
          "old_text": "str.substr(pos + 1)",
          "new_text": null,
          "old_line_content": "    if (pos != std::string::npos) str = str.substr(pos + 1);",
          "new_line_content": "  llvm::raw_string_ostream stream(str);",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": "compilation_cache_key",
          "new_api": null,
          "old_text": "hlo_module_config.compilation_cache_key()",
          "new_text": null,
          "old_line_content": "  str += hlo_module_config.compilation_cache_key();",
          "new_line_content": "  // Delete the first two lines, since they usually vary even when the rest of",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": "str",
          "new_api": null,
          "old_text": "module->getName().str()",
          "new_text": null,
          "old_line_content": "    XLA_SCOPED_LOGGING_TIMER(\"Compile module \" + module->getName().str());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": "gcn_arch_name",
          "new_api": null,
          "old_text": "compute_capability->gcn_arch_name()",
          "new_text": null,
          "old_line_content": "    std::string gcn_arch_name = compute_capability->gcn_arch_name();",
          "new_line_content": "        tensorflow::profiler::TraceMeLevel::kInfo);",
          "content_same": false
        },
        {
          "line": 929,
          "old_api": "HsacoCache::Find(str, hash, gcn_arch_name, hsaco)",
          "new_api": null,
          "old_text": "HsacoCache::Find(str, hash, gcn_arch_name, hsaco)",
          "new_text": null,
          "old_line_content": "    if (HsacoCache::Find(str, hash, gcn_arch_name, hsaco)) {",
          "new_line_content": "    auto compute_capability =",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(1)",
          "new_text": null,
          "old_line_content": "    VLOG(1) << \"HSACO cache miss\";",
          "new_line_content": "          \"Incompatible compute capability was specified.\");",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": "std::to_string(hsaco_count)",
          "new_api": null,
          "old_text": "std::to_string(hsaco_count)",
          "new_text": null,
          "old_line_content": "      std::string name = \"/tmp/\" + std::to_string(hsaco_count) + \".ll\";",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": "close",
          "new_api": null,
          "old_text": "ofs.close()",
          "new_text": null,
          "old_line_content": "      ofs.close();",
          "new_line_content": "      return hsaco;",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "get",
          "new_api": null,
          "old_text": "target_machine.get()",
          "new_text": null,
          "old_line_content": "        AMDGPUTargetModuleLinker, default_target_triple, target_machine.get(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": "HsacoCache::Add(str, hash, gcn_arch_name, hsaco)",
          "new_api": null,
          "old_text": "HsacoCache::Add(str, hash, gcn_arch_name, hsaco)",
          "new_text": null,
          "old_line_content": "    HsacoCache::Add(str, hash, gcn_arch_name, hsaco);",
          "new_line_content": "                               hlo_module_config);",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": "debug_options",
          "new_api": null,
          "old_text": "llvm_ir::InitializeLLVMCommandLineOptions(\n      hlo_module_config.debug_options().xla_backend_extra_options())",
          "new_text": null,
          "old_line_content": "  llvm_ir::InitializeLLVMCommandLineOptions(",
          "new_line_content": "  // SLPVectorizer is useful (vectorizes f16x2 ops) but slow.  Most of the",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": "debug_options",
          "new_api": null,
          "old_text": "hlo_module_config.debug_options().xla_backend_extra_options()",
          "new_text": null,
          "old_line_content": "      hlo_module_config.debug_options().xla_backend_extra_options());",
          "new_line_content": "  // slowness appears to be in trying to form horizontal reductions, which don't",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": "LLVMInitializeNVPTXTargetInfo",
          "new_api": null,
          "old_text": "LLVMInitializeNVPTXTargetInfo()",
          "new_text": null,
          "old_line_content": "  LLVMInitializeNVPTXTargetInfo();",
          "new_line_content": "      \"-slp-vectorize-hor=false\",",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": "LLVMInitializeNVPTXTargetMC",
          "new_api": null,
          "old_text": "LLVMInitializeNVPTXTargetMC()",
          "new_text": null,
          "old_line_content": "  LLVMInitializeNVPTXTargetMC();",
          "new_line_content": "      \"-slp-max-reg-size=32\",",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": "LLVMInitializeNVPTXAsmPrinter",
          "new_api": null,
          "old_text": "LLVMInitializeNVPTXAsmPrinter()",
          "new_text": null,
          "old_line_content": "  LLVMInitializeNVPTXAsmPrinter();",
          "new_line_content": "  });",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": "InitializePasses",
          "new_api": null,
          "old_text": "InitializePasses(registry)",
          "new_text": null,
          "old_line_content": "  InitializePasses(registry);",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 34,
      "total_additions": 108,
      "total_deletions": 107,
      "total_api_changes": 249
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 10,
        "api_related_lines": 249,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          500,
          493,
          494,
          495
        ]
      }
    },
    "api_calls_before": 335,
    "api_calls_after": 336,
    "diff_info": {
      "added_lines": 10,
      "removed_lines": 0,
      "total_diff_lines": 22
    }
  }
}