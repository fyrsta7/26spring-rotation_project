{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/solidity/modified_file/df4b405f9c1cd3ebfd2787b5f1f6925cabf789d3",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/solidity/modified_file/df4b405f9c1cd3ebfd2787b5f1f6925cabf789d3/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/solidity/modified_file/df4b405f9c1cd3ebfd2787b5f1f6925cabf789d3/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/solidity/modified_file/df4b405f9c1cd3ebfd2787b5f1f6925cabf789d3/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 298,
          "old_api": "plus<u256>()",
          "new_api": "push_back",
          "old_text": "plus<u256>()",
          "new_text": "m_rules.push_back({\n\t\t{Instruction::ISZERO, {{Instruction::XOR, {X, Y}}}},\n\t\t[=]() -> Pattern { return { Instruction::EQ, {X, Y} }; }\n\t})",
          "old_line_content": "\t\t{Instruction::ADD, plus<u256>()},",
          "new_line_content": "\tm_rules.push_back({",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": "resetMatchGroups",
          "new_api": "SemanticInformation::isDeterministic(*_expr.item)",
          "old_text": "rules.resetMatchGroups()",
          "new_text": "SemanticInformation::isDeterministic(*_expr.item)",
          "old_line_content": "\t\trules.resetMatchGroups();",
          "new_line_content": "\t\t!SemanticInformation::isDeterministic(*_expr.item)",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": "size",
          "new_api": "count",
          "old_text": "m_arguments.size()",
          "new_text": "m_matchGroups->count(m_matchGroup)",
          "old_line_content": "\tfor (size_t i = 0; i < m_arguments.size(); ++i)",
          "new_line_content": "\t\tif (!m_matchGroups->count(m_matchGroup))",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 386,
          "old_api": null,
          "new_api": "SemanticInformation::isCommutativeOperation(*_expr.item)",
          "old_text": null,
          "new_text": "SemanticInformation::isCommutativeOperation(*_expr.item)",
          "old_line_content": "",
          "new_line_content": "\tif (!_secondRun && _expr.arguments.size() == 2 && SemanticInformation::isCommutativeOperation(*_expr.item))",
          "content_same": false
        },
        {
          "line": 261,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(0)",
          "old_line_content": "\t\t{{Instruction::EQ, {X, 0}}, [=]() -> Pattern { return {Instruction::ISZERO, {X}}; } },",
          "new_line_content": "\t\t{{Instruction::OR, {X, ~u256(0)}}, [=]{ return ~u256(0); }},",
          "content_same": false
        },
        {
          "line": 389,
          "old_api": null,
          "new_api": "swap",
          "old_text": null,
          "new_text": "swap(expr.arguments[0], expr.arguments[1])",
          "old_line_content": "",
          "new_line_content": "\t\tswap(expr.arguments[0], expr.arguments[1]);",
          "content_same": false
        },
        {
          "line": 390,
          "old_api": null,
          "new_api": "tryToSimplify",
          "old_text": null,
          "new_text": "tryToSimplify(expr, true)",
          "old_line_content": "ExpressionClasses::Id ExpressionClasses::rebuildExpression(ExpressionTemplate const& _template)",
          "new_line_content": "\t\treturn tryToSimplify(expr, true);",
          "content_same": false
        },
        {
          "line": 521,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "arg.toString()",
          "old_line_content": "",
          "new_line_content": "\t\ts << arg.toString();",
          "content_same": false
        },
        {
          "line": 523,
          "old_api": null,
          "new_api": "str",
          "old_text": null,
          "new_text": "s.str()",
          "old_line_content": "",
          "new_line_content": "\treturn s.str();",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(0)",
          "old_line_content": "",
          "new_line_content": "\t\t{{Instruction::MOD, {X, X}}, [=]{ return u256(0); }},",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": null,
          "new_api": "rebuildExpression",
          "old_text": null,
          "new_text": "rebuildExpression(t)",
          "old_line_content": "\tm_type(Operation),",
          "new_line_content": "\t\targuments.push_back(rebuildExpression(t));",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "find(_template.item, arguments)",
          "old_line_content": "\tm_requireDataMatch(true),",
          "new_line_content": "\treturn find(_template.item, arguments);",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(0)",
          "old_line_content": "\t\tInstruction::LT,",
          "new_line_content": "\t\t{{Instruction::AND, {{{X}, {Instruction::NOT, {X}}}}}, [=]{ return u256(0); }},",
          "content_same": false
        },
        {
          "line": 280,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(0)",
          "old_line_content": "\t\tInstruction::SLT,",
          "new_line_content": "\t\t{{Instruction::OR, {{{X}, {Instruction::NOT, {X}}}}}, [=]{ return ~u256(0); }},",
          "content_same": false
        },
        {
          "line": 290,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "m_rules.push_back({\n\t\t\t{Instruction::ISZERO, {{Instruction::ISZERO, {{op, {X, Y}}}}}},\n\t\t\t[=]() -> Pattern { return {op, {X, Y}}; }\n\t\t})",
          "old_line_content": "\t\t[=]() -> Pattern { return {Instruction::ISZERO, {X}}; }",
          "new_line_content": "\t\tm_rules.push_back({",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "m_rules.push_back({\n\t\t{Instruction::ISZERO, {{Instruction::ISZERO, {{Instruction::ISZERO, {X}}}}}},\n\t\t[=]() -> Pattern { return {Instruction::ISZERO, {X}}; }\n\t})",
          "old_line_content": "\t\t[=]() -> Pattern { return { Instruction::EQ, {X, Y} }; }",
          "new_line_content": "\tm_rules.push_back({",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": null,
          "new_api": "matchesBaseItem",
          "old_text": null,
          "new_text": "matchesBaseItem(_expr.item)",
          "old_line_content": "\t\telse if ((*m_matchGroups)[m_matchGroup]->id != _expr.id)",
          "new_line_content": "\tif (!matchesBaseItem(_expr.item))",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": null,
          "new_api": "plus<u256>()",
          "old_text": null,
          "new_text": "plus<u256>()",
          "old_line_content": "\t{",
          "new_line_content": "\t\t{Instruction::ADD, plus<u256>()},",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": null,
          "new_api": "multiplies<u256>()",
          "old_text": null,
          "new_text": "multiplies<u256>()",
          "old_line_content": "\t\tauto op = opFun.first;",
          "new_line_content": "\t\t{Instruction::MUL, multiplies<u256>()},",
          "content_same": false
        },
        {
          "line": 306,
          "old_api": null,
          "new_api": "bit_and<u256>()",
          "old_text": null,
          "new_text": "bit_and<u256>()",
          "old_line_content": "\t\tauto fun = opFun.second;",
          "new_line_content": "\t\t{Instruction::AND, bit_and<u256>()},",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": null,
          "new_api": "bit_or<u256>()",
          "old_text": null,
          "new_text": "bit_or<u256>()",
          "old_line_content": "\t\t// Moving constants to the outside, order matters here!",
          "new_line_content": "\t\t{Instruction::OR, bit_or<u256>()},",
          "content_same": false
        },
        {
          "line": 308,
          "old_api": null,
          "new_api": "bit_xor<u256>()",
          "old_text": null,
          "new_text": "bit_xor<u256>()",
          "old_line_content": "\t\t// we need actions that return expressions (or patterns?) here, and we need also reversed rules",
          "new_line_content": "\t\t{Instruction::XOR, bit_xor<u256>()}",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "m_arguments.size()",
          "old_line_content": "",
          "new_line_content": "\tassertThrow(m_arguments.size() == 0 || _expr.arguments.size() == m_arguments.size(), OptimizerException, \"\");",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "m_arguments.size()",
          "old_line_content": "AssemblyItem Pattern::toAssemblyItem(SourceLocation const& _location) const",
          "new_line_content": "\tfor (size_t i = 0; i < m_arguments.size(); ++i)",
          "content_same": false
        },
        {
          "line": 435,
          "old_api": null,
          "new_api": "representative",
          "old_text": null,
          "new_text": "_classes.representative(_expr.arguments[i])",
          "old_line_content": "{",
          "new_line_content": "\t\tif (!m_arguments[i].matches(_classes.representative(_expr.arguments[i]), _classes))",
          "content_same": false
        },
        {
          "line": 442,
          "old_api": null,
          "new_api": "AssemblyItem",
          "old_text": null,
          "new_text": "AssemblyItem(m_type, m_data, _location)",
          "old_line_content": "\tswitch (m_type)",
          "new_line_content": "\treturn AssemblyItem(m_type, m_data, _location);",
          "content_same": false
        },
        {
          "line": 318,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "\t\t// For now, we still need explicit commutativity for the inner pattern",
          "new_line_content": "\t\t\t[=]() -> Pattern { return {op, {X, fun(A.d(), B.d())}}; }",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": null,
          "new_api": "unsigned",
          "old_text": null,
          "new_text": "unsigned(m_data)",
          "old_line_content": "\t\ts << \"ANY\";",
          "new_line_content": "\t\ts << instructionInfo(Instruction(unsigned(m_data))).name;",
          "content_same": false
        },
        {
          "line": 326,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "\t// move constants across subtractions",
          "new_line_content": "\t\t\t[=]() -> Pattern { return {op, {X, fun(A.d(), B.d())}}; }",
          "content_same": false
        },
        {
          "line": 337,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "A.d()",
          "old_line_content": "\t\t\t// (A + X) - Y -> (X - Y) + A",
          "new_line_content": "\t\t\t[=]() -> Pattern { return {Instruction::ADD, {X, 0 - A.d()}}; }",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "p.toString()",
          "old_line_content": "{",
          "new_line_content": "\t\ts << p.toString() << \", \";",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": null,
          "new_api": "str",
          "old_text": null,
          "new_text": "s.str()",
          "old_line_content": "\t\treturn true;",
          "new_line_content": "\treturn s.str();",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "A.d()",
          "old_line_content": "\t};",
          "new_line_content": "\t\t\t[=]() -> Pattern { return {Instruction::ADD, {{Instruction::SUB, {X, Y}}, 0 - A.d()}}; }",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "_item->type()",
          "old_line_content": "",
          "new_line_content": "\tif (m_type != _item->type())",
          "content_same": false
        },
        {
          "line": 353,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "A.d()",
          "old_line_content": "{",
          "new_line_content": "\t\t\t[=]() -> Pattern { return {Instruction::ADD, {{Instruction::SUB, {X, Y}}, 0 - A.d()}}; }",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "_item->data()",
          "old_line_content": "{",
          "new_line_content": "\tif (m_requireDataMatch && m_data != _item->data())",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": null,
          "new_api": "assertThrow",
          "old_text": null,
          "new_text": "assertThrow(m_matchGroup > 0, OptimizerException, \"\")",
          "old_line_content": "",
          "new_line_content": "\tassertThrow(m_matchGroup > 0, OptimizerException, \"\");",
          "content_same": false
        },
        {
          "line": 490,
          "old_api": null,
          "new_api": "assertThrow",
          "old_text": null,
          "new_text": "assertThrow(!!m_matchGroups, OptimizerException, \"\")",
          "old_line_content": "ExpressionTemplate::ExpressionTemplate(Pattern const& _pattern, SourceLocation const& _location)",
          "new_line_content": "\tassertThrow(!!m_matchGroups, OptimizerException, \"\");",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": null,
          "new_api": "assertThrow",
          "old_text": null,
          "new_text": "assertThrow((*m_matchGroups)[m_matchGroup], OptimizerException, \"\")",
          "old_line_content": "{",
          "new_line_content": "\tassertThrow((*m_matchGroups)[m_matchGroup], OptimizerException, \"\");",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "_expr.item->type()",
          "old_line_content": "\t{",
          "new_line_content": "\t\t_expr.item->type() != Operation ||",
          "content_same": false
        },
        {
          "line": 369,
          "old_api": null,
          "new_api": "rules",
          "old_text": null,
          "new_text": "rules.rules()",
          "old_line_content": "\t\t\t//cout << \"Simplifying \" << *_expr.item << \"(\";",
          "new_line_content": "\tfor (auto const& rule: rules.rules())",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": null,
          "new_api": "matchGroup",
          "old_text": null,
          "new_text": "_pattern.matchGroup()",
          "old_line_content": "\t{",
          "new_line_content": "\tif (_pattern.matchGroup())",
          "content_same": false
        },
        {
          "line": 371,
          "old_api": null,
          "new_api": "resetMatchGroups",
          "old_text": null,
          "new_text": "rules.resetMatchGroups()",
          "old_line_content": "\t\t\t//\tcout << fullDAGToString(arg) << \", \";",
          "new_line_content": "\t\trules.resetMatchGroups();",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": null,
          "new_api": "matches",
          "old_text": null,
          "new_text": "rule.first.matches(_expr, *this)",
          "old_line_content": "\t\t\t//cout << \")\" << endl;",
          "new_line_content": "\t\tif (rule.first.matches(_expr, *this))",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": null,
          "new_api": "id",
          "old_text": null,
          "new_text": "_pattern.id()",
          "old_line_content": "\t}",
          "new_line_content": "\t\tid = _pattern.id();",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": null,
          "new_api": "toAssemblyItem",
          "old_text": null,
          "new_text": "_pattern.toAssemblyItem(_location)",
          "old_line_content": "string ExpressionTemplate::toString() const",
          "new_line_content": "\t\titem = _pattern.toAssemblyItem(_location);",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "_pattern.arguments()",
          "old_line_content": "\tstringstream s;",
          "new_line_content": "\tfor (auto const& arg: _pattern.arguments())",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": null,
          "new_api": "ExpressionTemplate",
          "old_text": null,
          "new_text": "ExpressionTemplate(arg, _location)",
          "old_line_content": "\tif (hasId)",
          "new_line_content": "\t\targuments.push_back(ExpressionTemplate(arg, _location));",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": null,
          "new_api": "location",
          "old_text": null,
          "new_text": "_expr.item->location()",
          "old_line_content": "\t\tExpression expr = _expr;",
          "new_line_content": "\t\t\treturn rebuildExpression(ExpressionTemplate(rule.second(), _expr.item->location()));",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 384,
          "old_api": "tryToSimplify",
          "new_api": null,
          "old_text": "tryToSimplify(expr, true)",
          "new_text": null,
          "old_line_content": "\t\treturn tryToSimplify(expr, true);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 515,
          "old_api": "toString",
          "new_api": null,
          "old_text": "arg.toString()",
          "new_text": null,
          "old_line_content": "\t\ts << arg.toString();",
          "new_line_content": "\tif (hasId)",
          "content_same": false
        },
        {
          "line": 517,
          "old_api": "str",
          "new_api": null,
          "old_text": "s.str()",
          "new_text": null,
          "old_line_content": "\treturn s.str();",
          "new_line_content": "\telse",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(0)",
          "new_text": null,
          "old_line_content": "\t\t{{Instruction::XOR, {X, X}}, [=]{ return u256(0); }},",
          "new_line_content": "\t\t{{Instruction::OR, {X, X}}, [=]{ return X; }},",
          "content_same": false
        },
        {
          "line": 397,
          "old_api": "rebuildExpression",
          "new_api": null,
          "old_text": "rebuildExpression(t)",
          "new_text": null,
          "old_line_content": "\t\targuments.push_back(rebuildExpression(t));",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 398,
          "old_api": "find",
          "new_api": null,
          "old_text": "find(_template.item, arguments)",
          "new_text": null,
          "old_line_content": "\treturn find(_template.item, arguments);",
          "new_line_content": "\tif (_template.hasId)",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "m_rules.push_back({\n\t\t\t{Instruction::ISZERO, {{Instruction::ISZERO, {{op, {X, Y}}}}}},\n\t\t\t[=]() -> Pattern { return {op, {X, Y}}; }\n\t\t})",
          "new_text": null,
          "old_line_content": "\t\tm_rules.push_back({",
          "new_line_content": "\t\tInstruction::EQ,",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "m_rules.push_back({\n\t\t{Instruction::ISZERO, {{Instruction::ISZERO, {{Instruction::ISZERO, {X}}}}}},\n\t\t[=]() -> Pattern { return {Instruction::ISZERO, {X}}; }\n\t})",
          "new_text": null,
          "old_line_content": "\tm_rules.push_back({",
          "new_line_content": "\t\tInstruction::SGT",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": "matchesBaseItem",
          "new_api": null,
          "old_text": "matchesBaseItem(_expr.item)",
          "new_text": null,
          "old_line_content": "\tif (!matchesBaseItem(_expr.item))",
          "new_line_content": "\tm_matchGroup = _group;",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "m_rules.push_back({\n\t\t{Instruction::ISZERO, {{Instruction::XOR, {X, Y}}}},\n\t\t[=]() -> Pattern { return { Instruction::EQ, {X, Y} }; }\n\t})",
          "new_text": null,
          "old_line_content": "\tm_rules.push_back({",
          "new_line_content": "\t\t\t[=]() -> Pattern { return {op, {X, Y}}; }",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": "count",
          "new_api": null,
          "old_text": "m_matchGroups->count(m_matchGroup)",
          "new_text": null,
          "old_line_content": "\t\tif (!m_matchGroups->count(m_matchGroup))",
          "new_line_content": "bool Pattern::matches(Expression const& _expr, ExpressionClasses const& _classes) const",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": "multiplies<u256>()",
          "new_api": null,
          "old_text": "multiplies<u256>()",
          "new_text": null,
          "old_line_content": "\t\t{Instruction::MUL, multiplies<u256>()},",
          "new_line_content": "\t\t{Instruction::ISZERO, {{Instruction::XOR, {X, Y}}}},",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": "bit_and<u256>()",
          "new_api": null,
          "old_text": "bit_and<u256>()",
          "new_text": null,
          "old_line_content": "\t\t{Instruction::AND, bit_and<u256>()},",
          "new_line_content": "\t\t[=]() -> Pattern { return { Instruction::EQ, {X, Y} }; }",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": "bit_or<u256>()",
          "new_api": null,
          "old_text": "bit_or<u256>()",
          "new_text": null,
          "old_line_content": "\t\t{Instruction::OR, bit_or<u256>()},",
          "new_line_content": "\t});",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": "bit_xor<u256>()",
          "new_api": null,
          "old_text": "bit_xor<u256>()",
          "new_text": null,
          "old_line_content": "\t\t{Instruction::XOR, bit_xor<u256>()}",
          "new_line_content": "\t// Associative operations",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": "size",
          "new_api": null,
          "old_text": "m_arguments.size()",
          "new_text": null,
          "old_line_content": "\tassertThrow(m_arguments.size() == 0 || _expr.arguments.size() == m_arguments.size(), OptimizerException, \"\");",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": "representative",
          "new_api": null,
          "old_text": "_classes.representative(_expr.arguments[i])",
          "new_text": null,
          "old_line_content": "\t\tif (!m_arguments[i].matches(_classes.representative(_expr.arguments[i]), _classes))",
          "new_line_content": "\t\t\t(*m_matchGroups)[m_matchGroup] = &_expr;",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": "AssemblyItem",
          "new_api": null,
          "old_text": "AssemblyItem(m_type, m_data, _location)",
          "new_text": null,
          "old_line_content": "\treturn AssemblyItem(m_type, m_data, _location);",
          "new_line_content": "\t\t\treturn false;",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": "d",
          "new_api": null,
          "old_text": "B.d()",
          "new_text": null,
          "old_line_content": "\t\t\t[=]() -> Pattern { return {op, {X, fun(A.d(), B.d())}}; }",
          "new_line_content": "\t\tauto fun = opFun.second;",
          "content_same": false
        },
        {
          "line": 445,
          "old_api": "unsigned",
          "new_api": null,
          "old_text": "unsigned(m_data)",
          "new_text": null,
          "old_line_content": "\t\ts << instructionInfo(Instruction(unsigned(m_data))).name;",
          "new_line_content": "string Pattern::toString() const",
          "content_same": false
        },
        {
          "line": 320,
          "old_api": "d",
          "new_api": null,
          "old_text": "B.d()",
          "new_text": null,
          "old_line_content": "\t\t\t[=]() -> Pattern { return {op, {X, fun(A.d(), B.d())}}; }",
          "new_line_content": "\t\t// X+(Y+A) -> (X+Y)+A",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": "d",
          "new_api": null,
          "old_text": "A.d()",
          "new_text": null,
          "old_line_content": "\t\t\t[=]() -> Pattern { return {Instruction::ADD, {X, 0 - A.d()}}; }",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 463,
          "old_api": "toString",
          "new_api": null,
          "old_text": "p.toString()",
          "new_text": null,
          "old_line_content": "\t\ts << p.toString() << \", \";",
          "new_line_content": "\tif (!m_requireDataMatch)",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": "str",
          "new_api": null,
          "old_text": "s.str()",
          "new_text": null,
          "old_line_content": "\treturn s.str();",
          "new_line_content": "\tif (m_matchGroup)",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": "d",
          "new_api": null,
          "old_text": "A.d()",
          "new_text": null,
          "old_line_content": "\t\t\t[=]() -> Pattern { return {Instruction::ADD, {{Instruction::SUB, {X, Y}}, 0 - A.d()}}; }",
          "new_line_content": "\t\t\t// (A + X) - Y -> (X - Y) + A",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": "type",
          "new_api": null,
          "old_text": "_item->type()",
          "new_text": null,
          "old_line_content": "\tif (m_type != _item->type())",
          "new_line_content": "bool Pattern::matchesBaseItem(AssemblyItem const* _item) const",
          "content_same": false
        },
        {
          "line": 347,
          "old_api": "d",
          "new_api": null,
          "old_text": "A.d()",
          "new_text": null,
          "old_line_content": "\t\t\t[=]() -> Pattern { return {Instruction::ADD, {{Instruction::SUB, {X, Y}}, 0 - A.d()}}; }",
          "new_line_content": "\t\t\t// X - (Y + A) -> (X - Y) + (-A)",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": "data",
          "new_api": null,
          "old_text": "_item->data()",
          "new_text": null,
          "old_line_content": "\tif (m_requireDataMatch && m_data != _item->data())",
          "new_line_content": "\tif (m_type == UndefinedItem)",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": "assertThrow",
          "new_api": null,
          "old_text": "assertThrow(m_matchGroup > 0, OptimizerException, \"\")",
          "new_text": null,
          "old_line_content": "\tassertThrow(m_matchGroup > 0, OptimizerException, \"\");",
          "new_line_content": "\t\treturn false;",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": "assertThrow",
          "new_api": null,
          "old_text": "assertThrow(!!m_matchGroups, OptimizerException, \"\")",
          "new_text": null,
          "old_line_content": "\tassertThrow(!!m_matchGroups, OptimizerException, \"\");",
          "new_line_content": "\treturn true;",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": "assertThrow",
          "new_api": null,
          "old_text": "assertThrow((*m_matchGroups)[m_matchGroup], OptimizerException, \"\")",
          "new_text": null,
          "old_line_content": "\tassertThrow((*m_matchGroups)[m_matchGroup], OptimizerException, \"\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 358,
          "old_api": "type",
          "new_api": null,
          "old_text": "_expr.item->type()",
          "new_text": null,
          "old_line_content": "\t\t_expr.item->type() != Operation ||",
          "new_line_content": "ExpressionClasses::Id ExpressionClasses::tryToSimplify(Expression const& _expr, bool _secondRun)",
          "content_same": false
        },
        {
          "line": 359,
          "old_api": "SemanticInformation::isDeterministic(*_expr.item)",
          "new_api": null,
          "old_text": "SemanticInformation::isDeterministic(*_expr.item)",
          "new_text": null,
          "old_line_content": "\t\t!SemanticInformation::isDeterministic(*_expr.item)",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 363,
          "old_api": "rules",
          "new_api": null,
          "old_text": "rules.rules()",
          "new_text": null,
          "old_line_content": "\tfor (auto const& rule: rules.rules())",
          "new_line_content": "\t\t!_expr.item ||",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": "matchGroup",
          "new_api": null,
          "old_text": "_pattern.matchGroup()",
          "new_text": null,
          "old_line_content": "\tif (_pattern.matchGroup())",
          "new_line_content": "\treturn *(*m_matchGroups)[m_matchGroup];",
          "content_same": false
        },
        {
          "line": 366,
          "old_api": "matches",
          "new_api": null,
          "old_text": "rule.first.matches(_expr, *this)",
          "new_text": null,
          "old_line_content": "\t\tif (rule.first.matches(_expr, *this))",
          "new_line_content": "\t)",
          "content_same": false
        },
        {
          "line": 495,
          "old_api": "id",
          "new_api": null,
          "old_text": "_pattern.id()",
          "new_text": null,
          "old_line_content": "\t\tid = _pattern.id();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "toAssemblyItem",
          "new_api": null,
          "old_text": "_pattern.toAssemblyItem(_location)",
          "new_text": null,
          "old_line_content": "\t\titem = _pattern.toAssemblyItem(_location);",
          "new_line_content": "\t\thasId = true;",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "_pattern.arguments()",
          "new_text": null,
          "old_line_content": "\tfor (auto const& arg: _pattern.arguments())",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": "ExpressionTemplate",
          "new_api": null,
          "old_text": "ExpressionTemplate(arg, _location)",
          "new_text": null,
          "old_line_content": "\t\targuments.push_back(ExpressionTemplate(arg, _location));",
          "new_line_content": "\telse",
          "content_same": false
        },
        {
          "line": 376,
          "old_api": "location",
          "new_api": null,
          "old_text": "_expr.item->location()",
          "new_text": null,
          "old_line_content": "\t\t\treturn rebuildExpression(ExpressionTemplate(rule.second(), _expr.item->location()));",
          "new_line_content": "\t\t\t//for (Id arg: _expr.arguments)",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": "SemanticInformation::isCommutativeOperation(*_expr.item)",
          "new_api": null,
          "old_text": "SemanticInformation::isCommutativeOperation(*_expr.item)",
          "new_text": null,
          "old_line_content": "\tif (!_secondRun && _expr.arguments.size() == 2 && SemanticInformation::isCommutativeOperation(*_expr.item))",
          "new_line_content": "\t\t\t//ExpressionTemplate t(rule.second());",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": "swap",
          "new_api": null,
          "old_text": "swap(expr.arguments[0], expr.arguments[1])",
          "new_text": null,
          "old_line_content": "\t\tswap(expr.arguments[0], expr.arguments[1]);",
          "new_line_content": "\t\t}",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 3,
      "total_additions": 46,
      "total_deletions": 43,
      "total_api_changes": 92
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 6,
        "api_related_lines": 92,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          258,
          276,
          277,
          278
        ]
      }
    },
    "api_calls_before": 236,
    "api_calls_after": 239,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 0,
      "total_diff_lines": 25
    }
  }
}