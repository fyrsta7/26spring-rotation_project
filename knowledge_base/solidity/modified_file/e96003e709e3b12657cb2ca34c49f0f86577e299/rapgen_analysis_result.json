{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/solidity/modified_file/e96003e709e3b12657cb2ca34c49f0f86577e299",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/solidity/modified_file/e96003e709e3b12657cb2ca34c49f0f86577e299/before.h",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/solidity/modified_file/e96003e709e3b12657cb2ca34c49f0f86577e299/after.h",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/solidity/modified_file/e96003e709e3b12657cb2ca34c49f0f86577e299/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": true,
    "api_changes": {
      "replacements": [
        {
          "line": 96,
          "old_api": "d",
          "new_api": "u256",
          "old_text": "A.d()",
          "new_text": "u256(1)",
          "old_line_content": "\t\t\tunsigned testBit = unsigned(A.d()) * 8 + 7;",
          "new_line_content": "\t\t\tu256 mask = (u256(1) << testBit) - 1;",
          "content_same": false
        },
        {
          "line": 97,
          "old_api": "u256",
          "new_api": "d",
          "old_text": "u256(1)",
          "new_text": "B.d()",
          "old_line_content": "\t\t\tu256 mask = (u256(1) << testBit) - 1;",
          "new_line_content": "\t\t\treturn boost::multiprecision::bit_test(B.d(), testBit) ? B.d() | ~mask : B.d() & mask;",
          "content_same": false
        },
        {
          "line": 101,
          "old_api": "d",
          "new_api": "u256",
          "old_text": "A.d()",
          "new_text": "u256(0)",
          "old_line_content": "\t\t\tif (A.d() > 255)",
          "new_line_content": "\t\t\t\treturn u256(0);",
          "content_same": false
        },
        {
          "line": 102,
          "old_api": "u256",
          "new_api": "d",
          "old_text": "u256(0)",
          "new_text": "A.d()",
          "old_line_content": "\t\t\t\treturn u256(0);",
          "new_line_content": "\t\t\treturn shlWorkaround(B.d(), unsigned(A.d()));",
          "content_same": false
        },
        {
          "line": 106,
          "old_api": "d",
          "new_api": "u256",
          "old_text": "A.d()",
          "new_text": "u256(0)",
          "old_line_content": "\t\t\tif (A.d() > 255)",
          "new_line_content": "\t\t\t\treturn u256(0);",
          "content_same": false
        },
        {
          "line": 107,
          "old_api": "u256",
          "new_api": "d",
          "old_text": "u256(0)",
          "new_text": "A.d()",
          "old_line_content": "\t\t\t\treturn u256(0);",
          "new_line_content": "\t\t\treturn B.d() >> unsigned(A.d());",
          "content_same": false
        },
        {
          "line": 238,
          "old_api": "u256",
          "new_api": "push_back",
          "old_text": "u256(1)",
          "new_text": "rules.push_back({\n\t\t\t{Instruction::MOD, {X, value}},\n\t\t\t[=]() -> Pattern { return {Instruction::AND, {X, value - 1}}; },\n\t\t\tfalse\n\t\t})",
          "old_line_content": "\t\tu256 value = u256(1) << i;",
          "new_line_content": "\t\trules.push_back({",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": "u256",
          "new_api": "push_back",
          "old_text": "u256(1)",
          "new_text": "rules.push_back({\n\t\t\t{Instruction::AND, {{op, mask}}},\n\t\t\t[=]() -> Pattern { return op; },\n\t\t\tfalse\n\t\t})",
          "old_line_content": "\t\tu256 const mask = (u256(1) << 160) - 1;",
          "new_line_content": "\t\trules.push_back({",
          "content_same": false
        },
        {
          "line": 337,
          "old_api": "std::plus<u256>()",
          "new_api": "std::multiplies<u256>()",
          "old_text": "std::plus<u256>()",
          "new_text": "std::multiplies<u256>()",
          "old_line_content": "\t\t{Instruction::ADD, std::plus<u256>()},",
          "new_line_content": "\t\t{Instruction::MUL, std::multiplies<u256>()},",
          "content_same": false
        },
        {
          "line": 338,
          "old_api": "std::multiplies<u256>()",
          "new_api": "std::bit_and<u256>()",
          "old_text": "std::multiplies<u256>()",
          "new_text": "std::bit_and<u256>()",
          "old_line_content": "\t\t{Instruction::MUL, std::multiplies<u256>()},",
          "new_line_content": "\t\t{Instruction::AND, std::bit_and<u256>()},",
          "content_same": false
        },
        {
          "line": 339,
          "old_api": "std::bit_and<u256>()",
          "new_api": "std::bit_or<u256>()",
          "old_text": "std::bit_and<u256>()",
          "new_text": "std::bit_or<u256>()",
          "old_line_content": "\t\t{Instruction::AND, std::bit_and<u256>()},",
          "new_line_content": "\t\t{Instruction::OR, std::bit_or<u256>()},",
          "content_same": false
        },
        {
          "line": 340,
          "old_api": "std::bit_or<u256>()",
          "new_api": "std::bit_xor<u256>()",
          "old_text": "std::bit_or<u256>()",
          "new_text": "std::bit_xor<u256>()",
          "old_line_content": "\t\t{Instruction::OR, std::bit_or<u256>()},",
          "new_line_content": "\t\t{Instruction::XOR, std::bit_xor<u256>()}",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": "d",
          "new_api": "std::move(mask)",
          "old_text": "B.d()",
          "new_text": "std::move(mask)",
          "old_line_content": "\t\t\t\tA.d() >> unsigned(B.d());",
          "new_line_content": "\t\t\treturn {Instruction::AND, {{shiftOp, {B.d(), X}}, std::move(mask)}};",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": "d",
          "new_api": "u256",
          "old_text": "B.d()",
          "new_text": "u256(-1)",
          "old_line_content": "\t\tunsigned bAsUint = static_cast<unsigned>(B.d());",
          "new_line_content": "\t\treturn (A.d() & (u256(-1) >> bAsUint)) == (u256(-1) >> bAsUint);",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": "simplificationRuleListPart1",
          "new_api": "simplificationRuleListPart2",
          "old_text": "simplificationRuleListPart1(A, B, C, X, Y)",
          "new_text": "simplificationRuleListPart2(A, B, C, X, Y)",
          "old_line_content": "\trules += simplificationRuleListPart1(A, B, C, X, Y);",
          "new_line_content": "\trules += simplificationRuleListPart2(A, B, C, X, Y);",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": "simplificationRuleListPart2",
          "new_api": "simplificationRuleListPart3",
          "old_text": "simplificationRuleListPart2(A, B, C, X, Y)",
          "new_text": "simplificationRuleListPart3(A, B, C, X, Y)",
          "old_line_content": "\trules += simplificationRuleListPart2(A, B, C, X, Y);",
          "new_line_content": "\trules += simplificationRuleListPart3(A, B, C, X, Y);",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": "simplificationRuleListPart3",
          "new_api": "simplificationRuleListPart4",
          "old_text": "simplificationRuleListPart3(A, B, C, X, Y)",
          "new_text": "simplificationRuleListPart4(A, B, C, X, Y)",
          "old_line_content": "\trules += simplificationRuleListPart3(A, B, C, X, Y);",
          "new_line_content": "\trules += simplificationRuleListPart4(A, B, C, X, Y);",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": "simplificationRuleListPart4",
          "new_api": "simplificationRuleListPart5",
          "old_text": "simplificationRuleListPart4(A, B, C, X, Y)",
          "new_text": "simplificationRuleListPart5(A, B, C, X, Y)",
          "old_line_content": "\trules += simplificationRuleListPart4(A, B, C, X, Y);",
          "new_line_content": "\trules += simplificationRuleListPart5(A, B, C, X, Y);",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": "simplificationRuleListPart5",
          "new_api": "simplificationRuleListPart6",
          "old_text": "simplificationRuleListPart5(A, B, C, X, Y)",
          "new_text": "simplificationRuleListPart6(A, B, C, X, Y)",
          "old_line_content": "\trules += simplificationRuleListPart5(A, B, C, X, Y);",
          "new_line_content": "\trules += simplificationRuleListPart6(A, B, C, X, Y);",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": "simplificationRuleListPart6",
          "new_api": "simplificationRuleListPart7",
          "old_text": "simplificationRuleListPart6(A, B, C, X, Y)",
          "new_text": "simplificationRuleListPart7(A, B, C, X, Y)",
          "old_line_content": "\trules += simplificationRuleListPart6(A, B, C, X, Y);",
          "new_line_content": "\trules += simplificationRuleListPart7(A, B, C, X, Y);",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": "simplificationRuleListPart7",
          "new_api": "simplificationRuleListPart8",
          "old_text": "simplificationRuleListPart7(A, B, C, X, Y)",
          "new_text": "simplificationRuleListPart8(A, B, C, X, Y)",
          "old_line_content": "\trules += simplificationRuleListPart7(A, B, C, X, Y);",
          "new_line_content": "\trules += simplificationRuleListPart8(A, B, C, X, Y);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 256,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(0)",
          "old_line_content": "\t\t{Instruction::SHR, {A, X}},",
          "new_line_content": "\t\t[=]() -> Pattern { return u256(0); },",
          "content_same": false
        },
        {
          "line": 130,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(-1)",
          "old_line_content": "\t\t{{Instruction::MUL, {1, X}}, [=]{ return X; }, false},",
          "new_line_content": "\t\t{{Instruction::MUL, {X, u256(-1)}}, [=]() -> Pattern { return {Instruction::SUB, {0, X}}; }, false},",
          "content_same": false
        },
        {
          "line": 258,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "A.d()",
          "old_line_content": "\t\ttrue,",
          "new_line_content": "\t\t[=]() { return A.d() >= 256; }",
          "content_same": false
        },
        {
          "line": 389,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "rules.push_back({\n\t\t// SHR(B, SHR(A, X)) -> SHR(min(A+B, 256), X)\n\t\t{Instruction::SHR, {{B}, {Instruction::SHR, {{A}, {X}}}}},\n\t\t[=]() -> Pattern {\n\t\t\tbigint sum = bigint(A.d()) + B.d();\n\t\t\tif (sum >= 256)\n\t\t\t\treturn {Instruction::AND, {X, u256(0)}};\n\t\t\telse\n\t\t\t\treturn {Instruction::SHR, {u256(sum), X}};\n\t\t},\n\t\tfalse\n\t})",
          "old_line_content": "\t// Combine two SHR by constant",
          "new_line_content": "\trules.push_back({",
          "content_same": false
        },
        {
          "line": 135,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(0)",
          "old_line_content": "\t\t{{Instruction::DIV, {X, 1}}, [=]{ return X; }, false},",
          "new_line_content": "\t\t{{Instruction::SDIV, {X, 0}}, [=]{ return u256(0); }, true},",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "\t\t[=]() -> Pattern {",
          "new_line_content": "\t\t\tbigint sum = bigint(A.d()) + B.d();",
          "content_same": false
        },
        {
          "line": 138,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(0)",
          "old_line_content": "\t\t{{Instruction::SDIV, {X, 1}}, [=]{ return X; }, false},",
          "new_line_content": "\t\t{{Instruction::AND, {X, ~u256(0)}}, [=]{ return X; }, false},",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(0)",
          "old_line_content": "\t\t\tif (sum >= 256)",
          "new_line_content": "\t\t\t\treturn {Instruction::AND, {X, u256(0)}};",
          "content_same": false
        },
        {
          "line": 397,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(sum)",
          "old_line_content": "\t\t\telse",
          "new_line_content": "\t\t\t\treturn {Instruction::SHR, {u256(sum), X}};",
          "content_same": false
        },
        {
          "line": 270,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(1)",
          "old_line_content": "\t{",
          "new_line_content": "\t\tu256 const mask = (u256(1) << 160) - 1;",
          "content_same": false
        },
        {
          "line": 144,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(0)",
          "old_line_content": "\t\t{{Instruction::OR, {0, X}}, [=]{ return X; }, false},",
          "new_line_content": "\t\t{{Instruction::OR, {X, ~u256(0)}}, [=]{ return ~u256(0); }, true},",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "rules.push_back({\n\t\t// SHR(B, SHL(A, X)) -> AND(SH[L/R]([B - A / A - B], X), Mask)\n\t\t{Instruction::SHR, {{B}, {Instruction::SHL, {{A}, {X}}}}},\n\t\t[=]() -> Pattern {\n\t\t\tu256 mask = shlWorkaround(u256(-1), unsigned(A.d())) >> unsigned(B.d());\n\n\t\t\tif (A.d() > B.d())\n\t\t\t\treturn {Instruction::AND, {{Instruction::SHL, {A.d() - B.d(), X}}, mask}};\n\t\t\telse if (B.d() > A.d())\n\t\t\t\treturn {Instruction::AND, {{Instruction::SHR, {B.d() - A.d(), X}}, mask}};\n\t\t\telse\n\t\t\t\treturn {Instruction::AND, {X, mask}};\n\t\t},\n\t\tfalse,\n\t\t[=] { return A.d() < 256 && B.d() < 256; }\n\t})",
          "old_line_content": "\t// Combine SHL-SHR by constant",
          "new_line_content": "\trules.push_back({",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "A.d()",
          "old_line_content": "\t\t\t{Instruction::SUB, {X, A}},",
          "new_line_content": "\t\t\t[=]() -> Pattern { return {Instruction::ADD, {X, 0 - A.d()}}; },",
          "content_same": false
        },
        {
          "line": 148,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(0)",
          "old_line_content": "\t\t{{Instruction::XOR, {0, X}}, [=]{ return X; }, false},",
          "new_line_content": "\t\t{{Instruction::MOD, {X, 0}}, [=]{ return u256(0); }, true},",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "rules.push_back({\n\t\t\t{Instruction::AND, {{mask, op}}},\n\t\t\t[=]() -> Pattern { return op; },\n\t\t\tfalse\n\t\t})",
          "old_line_content": "\t\t});",
          "new_line_content": "\t\trules.push_back({",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "\t\t[=]() -> Pattern {",
          "new_line_content": "\t\t\tu256 mask = shlWorkaround(u256(-1), unsigned(A.d())) >> unsigned(B.d());",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "",
          "new_line_content": "\t\t\tif (A.d() > B.d())",
          "content_same": false
        },
        {
          "line": 154,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(0)",
          "old_line_content": "\t\t{{Instruction::SHR, {0, X}}, [=]{ return X; }, false},",
          "new_line_content": "\t\t{{Instruction::SHL, {X, 0}}, [=]{ return u256(0); }, true},",
          "content_same": false
        },
        {
          "line": 158,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(0)",
          "old_line_content": "\t\t{{Instruction::LT, {0, X}}, [=]() -> Pattern { return {Instruction::ISZERO, {{Instruction::ISZERO, {X}}}}; }, false},",
          "new_line_content": "\t\t{{Instruction::GT, {X, ~u256(0)}}, [=]{ return u256(0); }, true},",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "\t\tfalse,",
          "new_line_content": "\t\t[=] { return A.d() < 256 && B.d() < 256; }",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "A.d()",
          "old_line_content": "\t\t\t{Instruction::SUB, {X, {Instruction::ADD, {Y, A}}}},",
          "new_line_content": "\t\t\t[=]() -> Pattern { return {Instruction::ADD, {{Instruction::SUB, {X, Y}}, 0 - A.d()}}; },",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "rules.push_back({\n\t\t// SHL(B, SHR(A, X)) -> AND(SH[L/R]([B - A / A - B], X), Mask)\n\t\t{Instruction::SHL, {{B}, {Instruction::SHR, {{A}, {X}}}}},\n\t\t[=]() -> Pattern {\n\t\t\tu256 mask = shlWorkaround(u256(-1) >> unsigned(A.d()), unsigned(B.d()));\n\n\t\t\tif (A.d() > B.d())\n\t\t\t\treturn {Instruction::AND, {{Instruction::SHR, {A.d() - B.d(), X}}, mask}};\n\t\t\telse if (B.d() > A.d())\n\t\t\t\treturn {Instruction::AND, {{Instruction::SHL, {B.d() - A.d(), X}}, mask}};\n\t\t\telse\n\t\t\t\treturn {Instruction::AND, {X, mask}};\n\t\t},\n\t\tfalse,\n\t\t[=] { return A.d() < 256 && B.d() < 256; }\n\t})",
          "old_line_content": "\t// Combine SHR-SHL by constant",
          "new_line_content": "\trules.push_back({",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "A.d()",
          "old_line_content": "\t\t\t{Instruction::SUB, {X, {Instruction::ADD, {A, Y}}}},",
          "new_line_content": "\t\t\t[=]() -> Pattern { return {Instruction::ADD, {{Instruction::SUB, {X, Y}}, 0 - A.d()}}; },",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "\t\t[=]() -> Pattern {",
          "new_line_content": "\t\t\tu256 mask = shlWorkaround(u256(-1) >> unsigned(A.d()), unsigned(B.d()));",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "",
          "new_line_content": "\t\t\tif (A.d() > B.d())",
          "content_same": false
        },
        {
          "line": 303,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "rules.push_back({\n\t\t\t{Instruction::ISZERO, {{Instruction::ISZERO, {{op, {X, Y}}}}}},\n\t\t\t[=]() -> Pattern { return {op, {X, Y}}; },\n\t\t\tfalse\n\t\t})",
          "old_line_content": "\t})",
          "new_line_content": "\t\trules.push_back({",
          "content_same": false
        },
        {
          "line": 435,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "\t\tfalse,",
          "new_line_content": "\t\t[=] { return A.d() < 256 && B.d() < 256; }",
          "content_same": false
        },
        {
          "line": 180,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(0)",
          "old_line_content": "\t\t{{Instruction::OR, {X, X}}, [=]{ return X; }, true},",
          "new_line_content": "\t\t{{Instruction::XOR, {X, X}}, [=]{ return u256(0); }, true},",
          "content_same": false
        },
        {
          "line": 309,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "rules.push_back({\n\t\t{Instruction::ISZERO, {{Instruction::ISZERO, {{Instruction::ISZERO, {X}}}}}},\n\t\t[=]() -> Pattern { return {Instruction::ISZERO, {X}}; },\n\t\tfalse\n\t})",
          "old_line_content": "",
          "new_line_content": "\trules.push_back({",
          "content_same": false
        },
        {
          "line": 315,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "rules.push_back({\n\t\t{Instruction::ISZERO, {{Instruction::XOR, {X, Y}}}},\n\t\t[=]() -> Pattern { return { Instruction::EQ, {X, Y} }; },\n\t\tfalse\n\t})",
          "old_line_content": "",
          "new_line_content": "\trules.push_back({",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "\t\t\t\tshiftOp == Instruction::SHL ?",
          "new_line_content": "\t\t\t\tshlWorkaround(A.d(), unsigned(B.d())) :",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": null,
          "new_api": "simplificationRuleListPart1",
          "old_text": null,
          "new_text": "simplificationRuleListPart1(A, B, C, X, Y)",
          "old_line_content": "\tstd::vector<SimplificationRule<Pattern>> rules;",
          "new_line_content": "\trules += simplificationRuleListPart1(A, B, C, X, Y);",
          "content_same": false
        },
        {
          "line": 448,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "rules.push_back({\n\t\t\t// SH[L/R](B, AND(X, A)) -> AND(SH[L/R](B, X), [ A << B / A >> B ])\n\t\t\t{shiftOp, {{B}, {Instruction::AND, {{X}, {A}}}}},\n\t\t\treplacement,\n\t\t\tfalse,\n\t\t\t[=] { return B.d() < 256; }\n\t\t})",
          "old_line_content": "\t\t};",
          "new_line_content": "\t\trules.push_back({",
          "content_same": false
        },
        {
          "line": 453,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "\t\t\tfalse,",
          "new_line_content": "\t\t\t[=] { return B.d() < 256; }",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "rules.push_back({\n\t\t\t// SH[L/R](B, AND(A, X)) -> AND(SH[L/R](B, X), [ A << B / A >> B ])\n\t\t\t{shiftOp, {{B}, {Instruction::AND, {{A}, {X}}}}},\n\t\t\treplacement,\n\t\t\tfalse,\n\t\t\t[=] { return B.d() < 256; }\n\t\t})",
          "old_line_content": "\t\t});",
          "new_line_content": "\t\trules.push_back({",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "\t\t\tfalse,",
          "new_line_content": "\t\t\t[=] { return B.d() < 256; }",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": null,
          "new_api": "std::plus<u256>()",
          "old_text": null,
          "new_text": "std::plus<u256>()",
          "old_line_content": "\tfor (auto const& opFun: std::vector<std::pair<Instruction,std::function<u256(u256 const&,u256 const&)>>>{",
          "new_line_content": "\t\t{Instruction::ADD, std::plus<u256>()},",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "rules.push_back({\n\t\t// MUL(X, SHL(Y, 1)) -> SHL(Y, X)\n\t\t{Instruction::MUL, {X, {Instruction::SHL, {Y, u256(1)}}}},\n\t\t[=]() -> Pattern {\n\t\t\treturn {Instruction::SHL, {Y, X}};\n\t\t},\n\t\tfalse\n\t})",
          "old_line_content": "",
          "new_line_content": "\trules.push_back({",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(1)",
          "old_line_content": "\t\t// MUL(X, SHL(Y, 1)) -> SHL(Y, X)",
          "new_line_content": "\t\t{Instruction::MUL, {X, {Instruction::SHL, {Y, u256(1)}}}},",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(0)",
          "old_line_content": "\t\t{{Instruction::AND, {{Instruction::OR, {Y, X}}, X}}, [=]{ return X; }, true},",
          "new_line_content": "\t\t{{Instruction::AND, {X, {Instruction::NOT, {X}}}}, [=]{ return u256(0); }, true},",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "rules.push_back({\n\t\t// MUL(SHL(X, 1), Y) -> SHL(X, Y)\n\t\t{Instruction::MUL, {{Instruction::SHL, {X, u256(1)}}, Y}},\n\t\t[=]() -> Pattern {\n\t\t\treturn {Instruction::SHL, {X, Y}};\n\t\t},\n\t\tfalse\n\t})",
          "old_line_content": "\t});",
          "new_line_content": "\trules.push_back({",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(1)",
          "old_line_content": "\t\t// MUL(SHL(X, 1), Y) -> SHL(X, Y)",
          "new_line_content": "\t\t{Instruction::MUL, {{Instruction::SHL, {X, u256(1)}}, Y}},",
          "content_same": false
        },
        {
          "line": 93,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "A.d()",
          "old_line_content": "\t\t{{Instruction::SIGNEXTEND, {A, B}}, [=]() -> u256 {",
          "new_line_content": "\t\t\tif (A.d() >= 31)",
          "content_same": false
        },
        {
          "line": 375,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "rules.push_back({\n\t\t// SHL(B, SHL(A, X)) -> SHL(min(A+B, 256), X)\n\t\t{Instruction::SHL, {{B}, {Instruction::SHL, {{A}, {X}}}}},\n\t\t[=]() -> Pattern {\n\t\t\tbigint sum = bigint(A.d()) + B.d();\n\t\t\tif (sum >= 256)\n\t\t\t\treturn {Instruction::AND, {X, u256(0)}};\n\t\t\telse\n\t\t\t\treturn {Instruction::SHL, {u256(sum), X}};\n\t\t},\n\t\tfalse\n\t})",
          "old_line_content": "\t// Combine two SHL by constant",
          "new_line_content": "\trules.push_back({",
          "content_same": false
        },
        {
          "line": 353,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "\t\t\t\t{op, {{op, xa}, B}},",
          "new_line_content": "\t\t\t\t[=]() -> Pattern { return {op, {X, fun(A.d(), B.d())}}; },",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "rules.push_back({\n\t\t// DIV(X, SHL(Y, 1)) -> SHR(Y, X)\n\t\t{Instruction::DIV, {X, {Instruction::SHL, {Y, u256(1)}}}},\n\t\t[=]() -> Pattern {\n\t\t\treturn {Instruction::SHR, {Y, X}};\n\t\t},\n\t\tfalse\n\t})",
          "old_line_content": "",
          "new_line_content": "\trules.push_back({",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(1)",
          "old_line_content": "\t\t// DIV(X, SHL(Y, 1)) -> SHR(Y, X)",
          "new_line_content": "\t\t{Instruction::DIV, {X, {Instruction::SHL, {Y, u256(1)}}}},",
          "content_same": false
        },
        {
          "line": 100,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "A.d()",
          "old_line_content": "\t\t{{Instruction::SHL, {A, B}}, [=]{",
          "new_line_content": "\t\t\tif (A.d() > 255)",
          "content_same": false
        },
        {
          "line": 105,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "A.d()",
          "old_line_content": "\t\t{{Instruction::SHR, {A, B}}, [=]{",
          "new_line_content": "\t\t\tif (A.d() > 255)",
          "content_same": false
        },
        {
          "line": 363,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "\t\t\t\t{op, {B, {op, xa}}},",
          "new_line_content": "\t\t\t\t[=]() -> Pattern { return {op, {X, fun(A.d(), B.d())}}; },",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "\tstd::function<bool()> feasibilityFunction = [=]() {",
          "new_line_content": "\t\tif (B.d() > 256)",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(1)",
          "old_line_content": "\t{",
          "new_line_content": "\t\tu256 value = u256(1) << i;",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "\t\t\treturn false;",
          "new_line_content": "\t\tunsigned bAsUint = static_cast<unsigned>(B.d());",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "rules.push_back({\n\t\t// AND(A, SHR(B, X)) -> A & ((2^256-1) >> B) == ((2^256-1) >> B)\n\t\t{Instruction::AND, {A, {Instruction::SHR, {B, X}}}},\n\t\t[=]() -> Pattern { return {Instruction::SHR, {B, X}}; },\n\t\tfalse,\n\t\tfeasibilityFunction\n\t})",
          "old_line_content": "",
          "new_line_content": "\trules.push_back({",
          "content_same": false
        },
        {
          "line": 246,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "rules.push_back({\n\t\t{Instruction::SHL, {A, X}},\n\t\t[=]() -> Pattern { return u256(0); },\n\t\ttrue,\n\t\t[=]() { return A.d() >= 256; }\n\t})",
          "old_line_content": "\t// Replace SHL >=256, X with 0",
          "new_line_content": "\trules.push_back({",
          "content_same": false
        },
        {
          "line": 254,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "rules.push_back({\n\t\t{Instruction::SHR, {A, X}},\n\t\t[=]() -> Pattern { return u256(0); },\n\t\ttrue,\n\t\t[=]() { return A.d() >= 256; }\n\t})",
          "old_line_content": "\t// Replace SHR >=256, X with 0",
          "new_line_content": "\trules.push_back({",
          "content_same": false
        },
        {
          "line": 248,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(0)",
          "old_line_content": "\t\t{Instruction::SHL, {A, X}},",
          "new_line_content": "\t\t[=]() -> Pattern { return u256(0); },",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "rules.push_back({\n\t\t// AND(SHR(B, X), A) -> ((2^256-1) >> B) & A == ((2^256-1) >> B)\n\t\t{Instruction::AND, {{Instruction::SHR, {B, X}}, A}},\n\t\t[=]() -> Pattern { return {Instruction::SHR, {B, X}}; },\n\t\tfalse,\n\t\tfeasibilityFunction\n\t})",
          "old_line_content": "",
          "new_line_content": "\trules.push_back({",
          "content_same": false
        },
        {
          "line": 250,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "A.d()",
          "old_line_content": "\t\ttrue,",
          "new_line_content": "\t\t[=]() { return A.d() >= 256; }",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "\t\t[=]() -> Pattern {",
          "new_line_content": "\t\t\tbigint sum = bigint(A.d()) + B.d();",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(0)",
          "old_line_content": "\t\t\tif (sum >= 256)",
          "new_line_content": "\t\t\t\treturn {Instruction::AND, {X, u256(0)}};",
          "content_same": false
        },
        {
          "line": 126,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(0)",
          "old_line_content": "\t\t{{Instruction::SUB, {X, 0}}, [=]{ return X; }, false},",
          "new_line_content": "\t\t{{Instruction::MUL, {X, 0}}, [=]{ return u256(0); }, true},",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(sum)",
          "old_line_content": "\t\t\telse",
          "new_line_content": "\t\t\t\treturn {Instruction::SHL, {u256(sum), X}};",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 128,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(0)",
          "new_text": null,
          "old_line_content": "\t\t{{Instruction::MUL, {0, X}}, [=]{ return u256(0); }, true},",
          "new_line_content": "\t\t{{Instruction::MUL, {X, 1}}, [=]{ return X; }, false},",
          "content_same": false
        },
        {
          "line": 257,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(0)",
          "new_text": null,
          "old_line_content": "\t\t[=]() -> Pattern { return u256(0); },",
          "new_line_content": "\t\ttrue,",
          "content_same": false
        },
        {
          "line": 384,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(sum)",
          "new_text": null,
          "old_line_content": "\t\t\t\treturn {Instruction::SHL, {u256(sum), X}};",
          "new_line_content": "\t\t},",
          "content_same": false
        },
        {
          "line": 259,
          "old_api": "d",
          "new_api": null,
          "old_text": "A.d()",
          "new_text": null,
          "old_line_content": "\t\t[=]() { return A.d() >= 256; }",
          "new_line_content": "\t});",
          "content_same": false
        },
        {
          "line": 134,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(0)",
          "new_text": null,
          "old_line_content": "\t\t{{Instruction::DIV, {0, X}}, [=]{ return u256(0); }, true},",
          "new_line_content": "\t\t{{Instruction::DIV, {X, 1}}, [=]{ return X; }, false},",
          "content_same": false
        },
        {
          "line": 390,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t// SHR(B, SHR(A, X)) -> SHR(min(A+B, 256), X)\n\t\t{Instruction::SHR, {{B}, {Instruction::SHR, {{A}, {X}}}}},\n\t\t[=]() -> Pattern {\n\t\t\tbigint sum = bigint(A.d()) + B.d();\n\t\t\tif (sum >= 256)\n\t\t\t\treturn {Instruction::AND, {X, u256(0)}};\n\t\t\telse\n\t\t\t\treturn {Instruction::SHR, {u256(sum), X}};\n\t\t},\n\t\tfalse\n\t})",
          "new_text": null,
          "old_line_content": "\trules.push_back({",
          "new_line_content": "\t\t// SHR(B, SHR(A, X)) -> SHR(min(A+B, 256), X)",
          "content_same": false
        },
        {
          "line": 137,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(0)",
          "new_text": null,
          "old_line_content": "\t\t{{Instruction::SDIV, {0, X}}, [=]{ return u256(0); }, true},",
          "new_line_content": "\t\t{{Instruction::SDIV, {X, 1}}, [=]{ return X; }, false},",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": "d",
          "new_api": null,
          "old_text": "B.d()",
          "new_text": null,
          "old_line_content": "\t\t\tbigint sum = bigint(A.d()) + B.d();",
          "new_line_content": "\t\t\tif (sum >= 256)",
          "content_same": false
        },
        {
          "line": 396,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(0)",
          "new_text": null,
          "old_line_content": "\t\t\t\treturn {Instruction::AND, {X, u256(0)}};",
          "new_line_content": "\t\t\telse",
          "content_same": false
        },
        {
          "line": 142,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(0)",
          "new_text": null,
          "old_line_content": "\t\t{{Instruction::AND, {0, X}}, [=]{ return u256(0); }, true},",
          "new_line_content": "\t\t{{Instruction::OR, {X, 0}}, [=]{ return X; }, false},",
          "content_same": false
        },
        {
          "line": 398,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(sum)",
          "new_text": null,
          "old_line_content": "\t\t\t\treturn {Instruction::SHR, {u256(sum), X}};",
          "new_line_content": "\t\t},",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t\t{Instruction::AND, {{op, mask}}},\n\t\t\t[=]() -> Pattern { return op; },\n\t\t\tfalse\n\t\t})",
          "new_text": null,
          "old_line_content": "\t\trules.push_back({",
          "new_line_content": "\t\t\t{Instruction::AND, {{op, mask}}},",
          "content_same": false
        },
        {
          "line": 146,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(0)",
          "new_text": null,
          "old_line_content": "\t\t{{Instruction::OR, {~u256(0), X}}, [=]{ return ~u256(0); }, true},",
          "new_line_content": "\t\t{{Instruction::XOR, {X, 0}}, [=]{ return X; }, false},",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t// SHR(B, SHL(A, X)) -> AND(SH[L/R]([B - A / A - B], X), Mask)\n\t\t{Instruction::SHR, {{B}, {Instruction::SHL, {{A}, {X}}}}},\n\t\t[=]() -> Pattern {\n\t\t\tu256 mask = shlWorkaround(u256(-1), unsigned(A.d())) >> unsigned(B.d());\n\n\t\t\tif (A.d() > B.d())\n\t\t\t\treturn {Instruction::AND, {{Instruction::SHL, {A.d() - B.d(), X}}, mask}};\n\t\t\telse if (B.d() > A.d())\n\t\t\t\treturn {Instruction::AND, {{Instruction::SHR, {B.d() - A.d(), X}}, mask}};\n\t\t\telse\n\t\t\t\treturn {Instruction::AND, {X, mask}};\n\t\t},\n\t\tfalse,\n\t\t[=] { return A.d() < 256 && B.d() < 256; }\n\t})",
          "new_text": null,
          "old_line_content": "\trules.push_back({",
          "new_line_content": "\t\t// SHR(B, SHL(A, X)) -> AND(SH[L/R]([B - A / A - B], X), Mask)",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": "d",
          "new_api": null,
          "old_text": "A.d()",
          "new_text": null,
          "old_line_content": "\t\t\t[=]() -> Pattern { return {Instruction::ADD, {X, 0 - A.d()}}; },",
          "new_line_content": "\t\t\tfalse",
          "content_same": false
        },
        {
          "line": 150,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(0)",
          "new_text": null,
          "old_line_content": "\t\t{{Instruction::MOD, {0, X}}, [=]{ return u256(0); }, true},",
          "new_line_content": "\t\t{{Instruction::EQ, {X, 0}}, [=]() -> Pattern { return {Instruction::ISZERO, {X}}; }, false },",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t\t{Instruction::AND, {{mask, op}}},\n\t\t\t[=]() -> Pattern { return op; },\n\t\t\tfalse\n\t\t})",
          "new_text": null,
          "old_line_content": "\t\trules.push_back({",
          "new_line_content": "\t\t\t{Instruction::AND, {{mask, op}}},",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": "d",
          "new_api": null,
          "old_text": "B.d()",
          "new_text": null,
          "old_line_content": "\t\t\tu256 mask = shlWorkaround(u256(-1), unsigned(A.d())) >> unsigned(B.d());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 156,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(0)",
          "new_text": null,
          "old_line_content": "\t\t{{Instruction::SHR, {X, 0}}, [=]{ return u256(0); }, true},",
          "new_line_content": "\t\t{{Instruction::GT, {X, 0}}, [=]() -> Pattern { return {Instruction::ISZERO, {{Instruction::ISZERO, {X}}}}; }, false},",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": "d",
          "new_api": null,
          "old_text": "A.d()",
          "new_text": null,
          "old_line_content": "\t\t\t\treturn {Instruction::AND, {{Instruction::SHR, {B.d() - A.d(), X}}, mask}};",
          "new_line_content": "\t\t\telse",
          "content_same": false
        },
        {
          "line": 418,
          "old_api": "d",
          "new_api": null,
          "old_text": "B.d()",
          "new_text": null,
          "old_line_content": "\t\t[=] { return A.d() < 256 && B.d() < 256; }",
          "new_line_content": "\t});",
          "content_same": false
        },
        {
          "line": 548,
          "old_api": "d",
          "new_api": null,
          "old_text": "A.d()",
          "new_text": null,
          "old_line_content": "\t\t\t[=]() -> Pattern { return {Instruction::ADD, {{Instruction::SUB, {X, Y}}, 0 - A.d()}}; },",
          "new_line_content": "\t\t\tfalse",
          "content_same": false
        },
        {
          "line": 164,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(0xff)",
          "new_text": null,
          "old_line_content": "\t\t{{Instruction::BYTE, {31, X}}, [=]() -> Pattern { return {Instruction::AND, {X, u256(0xff)}}; }, false}",
          "new_line_content": "\t};",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t// SHL(B, SHR(A, X)) -> AND(SH[L/R]([B - A / A - B], X), Mask)\n\t\t{Instruction::SHL, {{B}, {Instruction::SHR, {{A}, {X}}}}},\n\t\t[=]() -> Pattern {\n\t\t\tu256 mask = shlWorkaround(u256(-1) >> unsigned(A.d()), unsigned(B.d()));\n\n\t\t\tif (A.d() > B.d())\n\t\t\t\treturn {Instruction::AND, {{Instruction::SHR, {A.d() - B.d(), X}}, mask}};\n\t\t\telse if (B.d() > A.d())\n\t\t\t\treturn {Instruction::AND, {{Instruction::SHL, {B.d() - A.d(), X}}, mask}};\n\t\t\telse\n\t\t\t\treturn {Instruction::AND, {X, mask}};\n\t\t},\n\t\tfalse,\n\t\t[=] { return A.d() < 256 && B.d() < 256; }\n\t})",
          "new_text": null,
          "old_line_content": "\trules.push_back({",
          "new_line_content": "\t\t// SHL(B, SHR(A, X)) -> AND(SH[L/R]([B - A / A - B], X), Mask)",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": "d",
          "new_api": null,
          "old_text": "A.d()",
          "new_text": null,
          "old_line_content": "\t\t\t[=]() -> Pattern { return {Instruction::ADD, {{Instruction::SUB, {X, Y}}, 0 - A.d()}}; },",
          "new_line_content": "\t\t\tfalse",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": "d",
          "new_api": null,
          "old_text": "B.d()",
          "new_text": null,
          "old_line_content": "\t\t\tu256 mask = shlWorkaround(u256(-1) >> unsigned(A.d()), unsigned(B.d()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 431,
          "old_api": "d",
          "new_api": null,
          "old_text": "A.d()",
          "new_text": null,
          "old_line_content": "\t\t\t\treturn {Instruction::AND, {{Instruction::SHL, {B.d() - A.d(), X}}, mask}};",
          "new_line_content": "\t\t\telse",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t\t{Instruction::ISZERO, {{Instruction::ISZERO, {{op, {X, Y}}}}}},\n\t\t\t[=]() -> Pattern { return {op, {X, Y}}; },\n\t\t\tfalse\n\t\t})",
          "new_text": null,
          "old_line_content": "\t\trules.push_back({",
          "new_line_content": "\t\t\t{Instruction::ISZERO, {{Instruction::ISZERO, {{op, {X, Y}}}}}},",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": "d",
          "new_api": null,
          "old_text": "B.d()",
          "new_text": null,
          "old_line_content": "\t\t[=] { return A.d() < 256 && B.d() < 256; }",
          "new_line_content": "\t});",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t{Instruction::ISZERO, {{Instruction::ISZERO, {{Instruction::ISZERO, {X}}}}}},\n\t\t[=]() -> Pattern { return {Instruction::ISZERO, {X}}; },\n\t\tfalse\n\t})",
          "new_text": null,
          "old_line_content": "\trules.push_back({",
          "new_line_content": "\t\t{Instruction::ISZERO, {{Instruction::ISZERO, {{Instruction::ISZERO, {X}}}}}},",
          "content_same": false
        },
        {
          "line": 188,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(0)",
          "new_text": null,
          "old_line_content": "\t\t{{Instruction::MOD, {X, X}}, [=]{ return u256(0); }, true}",
          "new_line_content": "\t};",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t{Instruction::ISZERO, {{Instruction::XOR, {X, Y}}}},\n\t\t[=]() -> Pattern { return { Instruction::EQ, {X, Y} }; },\n\t\tfalse\n\t})",
          "new_text": null,
          "old_line_content": "\trules.push_back({",
          "new_line_content": "\t\t{Instruction::ISZERO, {{Instruction::XOR, {X, Y}}}},",
          "content_same": false
        },
        {
          "line": 447,
          "old_api": "std::move(mask)",
          "new_api": null,
          "old_text": "std::move(mask)",
          "new_text": null,
          "old_line_content": "\t\t\treturn {Instruction::AND, {{shiftOp, {B.d(), X}}, std::move(mask)}};",
          "new_line_content": "\t\t};",
          "content_same": false
        },
        {
          "line": 449,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t\t// SH[L/R](B, AND(X, A)) -> AND(SH[L/R](B, X), [ A << B / A >> B ])\n\t\t\t{shiftOp, {{B}, {Instruction::AND, {{X}, {A}}}}},\n\t\t\treplacement,\n\t\t\tfalse,\n\t\t\t[=] { return B.d() < 256; }\n\t\t})",
          "new_text": null,
          "old_line_content": "\t\trules.push_back({",
          "new_line_content": "\t\t\t// SH[L/R](B, AND(X, A)) -> AND(SH[L/R](B, X), [ A << B / A >> B ])",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": "simplificationRuleListPart8",
          "new_api": null,
          "old_text": "simplificationRuleListPart8(A, B, C, X, Y)",
          "new_text": null,
          "old_line_content": "\trules += simplificationRuleListPart8(A, B, C, X, Y);",
          "new_line_content": "\treturn rules;",
          "content_same": false
        },
        {
          "line": 454,
          "old_api": "d",
          "new_api": null,
          "old_text": "B.d()",
          "new_text": null,
          "old_line_content": "\t\t\t[=] { return B.d() < 256; }",
          "new_line_content": "\t\t});",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t\t// SH[L/R](B, AND(A, X)) -> AND(SH[L/R](B, X), [ A << B / A >> B ])\n\t\t\t{shiftOp, {{B}, {Instruction::AND, {{A}, {X}}}}},\n\t\t\treplacement,\n\t\t\tfalse,\n\t\t\t[=] { return B.d() < 256; }\n\t\t})",
          "new_text": null,
          "old_line_content": "\t\trules.push_back({",
          "new_line_content": "\t\t\t// SH[L/R](B, AND(A, X)) -> AND(SH[L/R](B, X), [ A << B / A >> B ])",
          "content_same": false
        },
        {
          "line": 461,
          "old_api": "d",
          "new_api": null,
          "old_text": "B.d()",
          "new_text": null,
          "old_line_content": "\t\t\t[=] { return B.d() < 256; }",
          "new_line_content": "\t\t});",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t// MUL(X, SHL(Y, 1)) -> SHL(Y, X)\n\t\t{Instruction::MUL, {X, {Instruction::SHL, {Y, u256(1)}}}},\n\t\t[=]() -> Pattern {\n\t\t\treturn {Instruction::SHL, {Y, X}};\n\t\t},\n\t\tfalse\n\t})",
          "new_text": null,
          "old_line_content": "\trules.push_back({",
          "new_line_content": "\t\t// MUL(X, SHL(Y, 1)) -> SHL(Y, X)",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(1)",
          "new_text": null,
          "old_line_content": "\t\t{Instruction::MUL, {X, {Instruction::SHL, {Y, u256(1)}}}},",
          "new_line_content": "\t\t[=]() -> Pattern {",
          "content_same": false
        },
        {
          "line": 341,
          "old_api": "std::bit_xor<u256>()",
          "new_api": null,
          "old_text": "std::bit_xor<u256>()",
          "new_text": null,
          "old_line_content": "\t\t{Instruction::XOR, std::bit_xor<u256>()}",
          "new_line_content": "\t})",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t// MUL(SHL(X, 1), Y) -> SHL(X, Y)\n\t\t{Instruction::MUL, {{Instruction::SHL, {X, u256(1)}}, Y}},\n\t\t[=]() -> Pattern {\n\t\t\treturn {Instruction::SHL, {X, Y}};\n\t\t},\n\t\tfalse\n\t})",
          "new_text": null,
          "old_line_content": "\trules.push_back({",
          "new_line_content": "\t\t// MUL(SHL(X, 1), Y) -> SHL(X, Y)",
          "content_same": false
        },
        {
          "line": 219,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(0)",
          "new_text": null,
          "old_line_content": "\t\t{{Instruction::OR, {{Instruction::NOT, {X}}, X}}, [=]{ return ~u256(0); }, true},",
          "new_line_content": "\t};",
          "content_same": false
        },
        {
          "line": 92,
          "old_api": "d",
          "new_api": null,
          "old_text": "B.d()",
          "new_text": null,
          "old_line_content": "\t\t{{Instruction::MULMOD, {A, B, C}}, [=]{ return A.d() * B.d(); }, false},",
          "new_line_content": "\t\t{{Instruction::SIGNEXTEND, {A, B}}, [=]() -> u256 {",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(1)",
          "new_text": null,
          "old_line_content": "\t\t{Instruction::MUL, {{Instruction::SHL, {X, u256(1)}}, Y}},",
          "new_line_content": "\t\t[=]() -> Pattern {",
          "content_same": false
        },
        {
          "line": 98,
          "old_api": "d",
          "new_api": null,
          "old_text": "B.d()",
          "new_text": null,
          "old_line_content": "\t\t\treturn boost::multiprecision::bit_test(B.d(), testBit) ? B.d() | ~mask : B.d() & mask;",
          "new_line_content": "\t\t}, false},",
          "content_same": false
        },
        {
          "line": 354,
          "old_api": "d",
          "new_api": null,
          "old_text": "B.d()",
          "new_text": null,
          "old_line_content": "\t\t\t\t[=]() -> Pattern { return {op, {X, fun(A.d(), B.d())}}; },",
          "new_line_content": "\t\t\t\tfalse",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t// DIV(X, SHL(Y, 1)) -> SHR(Y, X)\n\t\t{Instruction::DIV, {X, {Instruction::SHL, {Y, u256(1)}}}},\n\t\t[=]() -> Pattern {\n\t\t\treturn {Instruction::SHR, {Y, X}};\n\t\t},\n\t\tfalse\n\t})",
          "new_text": null,
          "old_line_content": "\trules.push_back({",
          "new_line_content": "\t\t// DIV(X, SHL(Y, 1)) -> SHR(Y, X)",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(1)",
          "new_text": null,
          "old_line_content": "\t\t{Instruction::DIV, {X, {Instruction::SHL, {Y, u256(1)}}}},",
          "new_line_content": "\t\t[=]() -> Pattern {",
          "content_same": false
        },
        {
          "line": 103,
          "old_api": "d",
          "new_api": null,
          "old_text": "A.d()",
          "new_text": null,
          "old_line_content": "\t\t\treturn shlWorkaround(B.d(), unsigned(A.d()));",
          "new_line_content": "\t\t}, false},",
          "content_same": false
        },
        {
          "line": 108,
          "old_api": "d",
          "new_api": null,
          "old_text": "A.d()",
          "new_text": null,
          "old_line_content": "\t\t\treturn B.d() >> unsigned(A.d());",
          "new_line_content": "\t\t}, false}",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": "d",
          "new_api": null,
          "old_text": "B.d()",
          "new_text": null,
          "old_line_content": "\t\t\t\t[=]() -> Pattern { return {op, {X, fun(A.d(), B.d())}}; },",
          "new_line_content": "\t\t\t\tfalse",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": "d",
          "new_api": null,
          "old_text": "B.d()",
          "new_text": null,
          "old_line_content": "\t\tif (B.d() > 256)",
          "new_line_content": "\t\t\treturn false;",
          "content_same": false
        },
        {
          "line": 239,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t\t{Instruction::MOD, {X, value}},\n\t\t\t[=]() -> Pattern { return {Instruction::AND, {X, value - 1}}; },\n\t\t\tfalse\n\t\t})",
          "new_text": null,
          "old_line_content": "\t\trules.push_back({",
          "new_line_content": "\t\t\t{Instruction::MOD, {X, value}},",
          "content_same": false
        },
        {
          "line": 495,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(-1)",
          "new_text": null,
          "old_line_content": "\t\treturn (A.d() & (u256(-1) >> bAsUint)) == (u256(-1) >> bAsUint);",
          "new_line_content": "\t};",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t// AND(A, SHR(B, X)) -> A & ((2^256-1) >> B) == ((2^256-1) >> B)\n\t\t{Instruction::AND, {A, {Instruction::SHR, {B, X}}}},\n\t\t[=]() -> Pattern { return {Instruction::SHR, {B, X}}; },\n\t\tfalse,\n\t\tfeasibilityFunction\n\t})",
          "new_text": null,
          "old_line_content": "\trules.push_back({",
          "new_line_content": "\t\t// AND(A, SHR(B, X)) -> A & ((2^256-1) >> B) == ((2^256-1) >> B)",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t{Instruction::SHL, {A, X}},\n\t\t[=]() -> Pattern { return u256(0); },\n\t\ttrue,\n\t\t[=]() { return A.d() >= 256; }\n\t})",
          "new_text": null,
          "old_line_content": "\trules.push_back({",
          "new_line_content": "\t\t{Instruction::SHL, {A, X}},",
          "content_same": false
        },
        {
          "line": 376,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t// SHL(B, SHL(A, X)) -> SHL(min(A+B, 256), X)\n\t\t{Instruction::SHL, {{B}, {Instruction::SHL, {{A}, {X}}}}},\n\t\t[=]() -> Pattern {\n\t\t\tbigint sum = bigint(A.d()) + B.d();\n\t\t\tif (sum >= 256)\n\t\t\t\treturn {Instruction::AND, {X, u256(0)}};\n\t\t\telse\n\t\t\t\treturn {Instruction::SHL, {u256(sum), X}};\n\t\t},\n\t\tfalse\n\t})",
          "new_text": null,
          "old_line_content": "\trules.push_back({",
          "new_line_content": "\t\t// SHL(B, SHL(A, X)) -> SHL(min(A+B, 256), X)",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(0)",
          "new_text": null,
          "old_line_content": "\t\t[=]() -> Pattern { return u256(0); },",
          "new_line_content": "\t\ttrue,",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t// AND(SHR(B, X), A) -> ((2^256-1) >> B) & A == ((2^256-1) >> B)\n\t\t{Instruction::AND, {{Instruction::SHR, {B, X}}, A}},\n\t\t[=]() -> Pattern { return {Instruction::SHR, {B, X}}; },\n\t\tfalse,\n\t\tfeasibilityFunction\n\t})",
          "new_text": null,
          "old_line_content": "\trules.push_back({",
          "new_line_content": "\t\t// AND(SHR(B, X), A) -> ((2^256-1) >> B) & A == ((2^256-1) >> B)",
          "content_same": false
        },
        {
          "line": 251,
          "old_api": "d",
          "new_api": null,
          "old_text": "A.d()",
          "new_text": null,
          "old_line_content": "\t\t[=]() { return A.d() >= 256; }",
          "new_line_content": "\t});",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": "d",
          "new_api": null,
          "old_text": "B.d()",
          "new_text": null,
          "old_line_content": "\t\t\tbigint sum = bigint(A.d()) + B.d();",
          "new_line_content": "\t\t\tif (sum >= 256)",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": "u256",
          "new_api": null,
          "old_text": "u256(0)",
          "new_text": null,
          "old_line_content": "\t\t\t\treturn {Instruction::AND, {X, u256(0)}};",
          "new_line_content": "\t\t\telse",
          "content_same": false
        },
        {
          "line": 255,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "rules.push_back({\n\t\t{Instruction::SHR, {A, X}},\n\t\t[=]() -> Pattern { return u256(0); },\n\t\ttrue,\n\t\t[=]() { return A.d() >= 256; }\n\t})",
          "new_text": null,
          "old_line_content": "\trules.push_back({",
          "new_line_content": "\t\t{Instruction::SHR, {A, X}},",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 21,
      "total_additions": 63,
      "total_deletions": 64,
      "total_api_changes": 148
    },
    "non_api_changes": {
      "has_non_api_changes": false,
      "evidence": {
        "total_diff_lines": 1,
        "api_related_lines": 148,
        "non_api_lines": 0,
        "non_api_line_numbers": []
      }
    },
    "api_calls_before": 255,
    "api_calls_after": 253,
    "diff_info": {
      "added_lines": 0,
      "removed_lines": 1,
      "total_diff_lines": 13
    }
  }
}