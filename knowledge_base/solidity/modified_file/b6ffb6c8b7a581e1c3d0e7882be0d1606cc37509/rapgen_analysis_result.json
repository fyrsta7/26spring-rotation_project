{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/solidity/modified_file/b6ffb6c8b7a581e1c3d0e7882be0d1606cc37509",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/solidity/modified_file/b6ffb6c8b7a581e1c3d0e7882be0d1606cc37509/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/solidity/modified_file/b6ffb6c8b7a581e1c3d0e7882be0d1606cc37509/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/solidity/modified_file/b6ffb6c8b7a581e1c3d0e7882be0d1606cc37509/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 71,
          "old_api": "instructionInfo",
          "new_api": "SemanticInformation::invalidatesMemory(i0)",
          "old_text": "instructionInfo(i0)",
          "new_text": "SemanticInformation::invalidatesMemory(i0)",
          "old_line_content": "\t\t\t\tinstructionInfo(i0).args == 2 &&",
          "new_line_content": "\t\t\t\t!SemanticInformation::invalidatesMemory(i0) &&",
          "content_same": false
        },
        {
          "line": 72,
          "old_api": "SemanticInformation::invalidatesMemory(i0)",
          "new_api": "SemanticInformation::invalidatesStorage(i0)",
          "old_text": "SemanticInformation::invalidatesMemory(i0)",
          "new_text": "SemanticInformation::invalidatesStorage(i0)",
          "old_line_content": "\t\t\t\t!SemanticInformation::invalidatesMemory(i0) &&",
          "new_line_content": "\t\t\t\t!SemanticInformation::invalidatesStorage(i0) &&",
          "content_same": false
        },
        {
          "line": 73,
          "old_api": "SemanticInformation::invalidatesStorage(i0)",
          "new_api": "SemanticInformation::altersControlFlow(i0)",
          "old_text": "SemanticInformation::invalidatesStorage(i0)",
          "new_text": "SemanticInformation::altersControlFlow(i0)",
          "old_line_content": "\t\t\t\t!SemanticInformation::invalidatesStorage(i0)",
          "new_line_content": "\t\t\t\t!SemanticInformation::altersControlFlow(i0) &&",
          "content_same": false
        },
        {
          "line": 106,
          "old_api": "data",
          "new_api": "type",
          "old_text": "_in[2].data()",
          "new_text": "_in[2].type()",
          "old_line_content": "\t\t\t_in[0].data() == _in[2].data()",
          "new_line_content": "\t\t\t_in[2].type() == Tag &&",
          "content_same": false
        },
        {
          "line": 128,
          "old_api": "u256",
          "new_api": "type",
          "old_text": "u256(0xFFFFFFFF)",
          "new_text": "_in[1].type()",
          "old_line_content": "\t\t\t(_in[1].data() & u256(0xFFFFFFFF)) == u256(0xFFFFFFFF)",
          "new_line_content": "\t\t\t_in[1].type() == Push &&",
          "content_same": false
        },
        {
          "line": 155,
          "old_api": "Method::windowSize()",
          "new_api": "begin",
          "old_text": "Method::windowSize()",
          "new_text": "_state.items.begin()",
          "old_line_content": "\t\t_state.i += Method::windowSize();",
          "new_line_content": "\tif (_state.i + Method::windowSize() <= _state.items.size() && Method::apply(_state.items.begin() + _state.i, _state.out))",
          "content_same": false
        },
        {
          "line": 163,
          "old_api": "size",
          "new_api": "std::back_inserter(m_optimisedItems)",
          "old_text": "m_items.size()",
          "new_text": "std::back_inserter(m_optimisedItems)",
          "old_line_content": "\twhile (state.i < m_items.size())",
          "new_line_content": "\tOptimiserState state {m_items, 0, std::back_inserter(m_optimisedItems)};",
          "content_same": false
        },
        {
          "line": 164,
          "old_api": "Identity",
          "new_api": "size",
          "old_text": "Identity()",
          "new_text": "m_items.size()",
          "old_line_content": "\t\tapplyMethods(state, PushPop(), AddPop(), DoubleSwap(), JumpToNext(), TagConjunctions(), Identity());",
          "new_line_content": "\twhile (state.i < m_items.size())",
          "content_same": false
        },
        {
          "line": 165,
          "old_api": "size",
          "new_api": "Identity",
          "old_text": "m_items.size()",
          "new_text": "Identity()",
          "old_line_content": "\tif (m_optimisedItems.size() < m_items.size())",
          "new_line_content": "\t\tapplyMethods(state, PushPop(), AddPop(), DoubleSwap(), JumpToNext(), TagConjunctions(), Identity());",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 129,
          "old_api": null,
          "new_api": "u256",
          "old_text": null,
          "new_text": "u256(0xFFFFFFFF)",
          "old_line_content": "\t\t)",
          "new_line_content": "\t\t\t(_in[1].data() & u256(0xFFFFFFFF)) == u256(0xFFFFFFFF)",
          "content_same": false
        },
        {
          "line": 166,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "m_items.size()",
          "old_line_content": "\t{",
          "new_line_content": "\tif (m_optimisedItems.size() < m_items.size())",
          "content_same": false
        },
        {
          "line": 168,
          "old_api": null,
          "new_api": "std::move(m_optimisedItems)",
          "old_text": null,
          "new_text": "std::move(m_optimisedItems)",
          "old_line_content": "\t\treturn true;",
          "new_line_content": "\t\tm_items = std::move(m_optimisedItems);",
          "content_same": false
        },
        {
          "line": 104,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "_in[0].type()",
          "old_line_content": "\t\t\t(_in[1] == Instruction::JUMP || _in[1] == Instruction::JUMPI) &&",
          "new_line_content": "\t\t\t_in[0].type() == PushTag &&",
          "content_same": false
        },
        {
          "line": 74,
          "old_api": null,
          "new_api": "instructionInfo",
          "old_text": null,
          "new_text": "instructionInfo(i0)",
          "old_line_content": "\t\t\t)",
          "new_line_content": "\t\t\t\t!instructionInfo(i0).sideEffects",
          "content_same": false
        },
        {
          "line": 107,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "_in[2].data()",
          "old_line_content": "\t\t)",
          "new_line_content": "\t\t\t_in[0].data() == _in[2].data()",
          "content_same": false
        },
        {
          "line": 77,
          "old_api": null,
          "new_api": "instructionInfo",
          "old_text": null,
          "new_text": "instructionInfo(i0)",
          "old_line_content": "\t\t\t\t*_out = Instruction::POP;",
          "new_line_content": "\t\t\t\tfor (int j = 0; j < instructionInfo(i0).args; j++)",
          "content_same": false
        },
        {
          "line": 111,
          "old_api": null,
          "new_api": "location",
          "old_text": null,
          "new_text": "_in[1].location()",
          "old_line_content": "\t\t\t*_out = _in[2];",
          "new_line_content": "\t\t\t\t*_out = AssemblyItem(Instruction::POP, _in[1].location());",
          "content_same": false
        },
        {
          "line": 149,
          "old_api": null,
          "new_api": "assertThrow",
          "old_text": null,
          "new_text": "assertThrow(false, OptimizerException, \"Peephole optimizer failed to apply identity.\")",
          "old_line_content": "}",
          "new_line_content": "\tassertThrow(false, OptimizerException, \"Peephole optimizer failed to apply identity.\");",
          "content_same": false
        },
        {
          "line": 126,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "_in[0].type()",
          "old_line_content": "\t\t\t_in[2] == Instruction::AND &&",
          "new_line_content": "\t\t\t_in[0].type() == PushTag &&",
          "content_same": false
        },
        {
          "line": 91,
          "old_api": null,
          "new_api": "SemanticInformation::isSwapInstruction(_in[0])",
          "old_text": null,
          "new_text": "SemanticInformation::isSwapInstruction(_in[0])",
          "old_line_content": "\t\t\treturn true;",
          "new_line_content": "\t\tif (_in[0] == _in[1] && SemanticInformation::isSwapInstruction(_in[0]))",
          "content_same": false
        },
        {
          "line": 156,
          "old_api": null,
          "new_api": "Method::windowSize()",
          "old_text": null,
          "new_text": "Method::windowSize()",
          "old_line_content": "\telse",
          "new_line_content": "\t\t_state.i += Method::windowSize();",
          "content_same": false
        },
        {
          "line": 158,
          "old_api": null,
          "new_api": "applyMethods",
          "old_text": null,
          "new_text": "applyMethods(_state, _other...)",
          "old_line_content": "}",
          "new_line_content": "\t\tapplyMethods(_state, _other...);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 162,
          "old_api": "std::back_inserter(m_optimisedItems)",
          "new_api": null,
          "old_text": "std::back_inserter(m_optimisedItems)",
          "new_text": null,
          "old_line_content": "\tOptimiserState state {m_items, 0, std::back_inserter(m_optimisedItems)};",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 90,
          "old_api": "SemanticInformation::isSwapInstruction(_in[0])",
          "new_api": null,
          "old_text": "SemanticInformation::isSwapInstruction(_in[0])",
          "new_text": null,
          "old_line_content": "\t\tif (_in[0] == _in[1] && SemanticInformation::isSwapInstruction(_in[0]))",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 167,
          "old_api": "std::move(m_optimisedItems)",
          "new_api": null,
          "old_text": "std::move(m_optimisedItems)",
          "new_text": null,
          "old_line_content": "\t\tm_items = std::move(m_optimisedItems);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 103,
          "old_api": "type",
          "new_api": null,
          "old_text": "_in[0].type()",
          "new_text": null,
          "old_line_content": "\t\t\t_in[0].type() == PushTag &&",
          "new_line_content": "\t\tif (",
          "content_same": false
        },
        {
          "line": 105,
          "old_api": "type",
          "new_api": null,
          "old_text": "_in[2].type()",
          "new_text": null,
          "old_line_content": "\t\t\t_in[2].type() == Tag &&",
          "new_line_content": "\t\t\t(_in[1] == Instruction::JUMP || _in[1] == Instruction::JUMPI) &&",
          "content_same": false
        },
        {
          "line": 110,
          "old_api": "location",
          "new_api": null,
          "old_text": "_in[1].location()",
          "new_text": null,
          "old_line_content": "\t\t\t\t*_out = AssemblyItem(Instruction::POP, _in[1].location());",
          "new_line_content": "\t\t\tif (_in[1] == Instruction::JUMPI)",
          "content_same": false
        },
        {
          "line": 148,
          "old_api": "assertThrow",
          "new_api": null,
          "old_text": "assertThrow(false, OptimizerException, \"Peephole optimizer failed to apply identity.\")",
          "new_text": null,
          "old_line_content": "\tassertThrow(false, OptimizerException, \"Peephole optimizer failed to apply identity.\");",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 125,
          "old_api": "type",
          "new_api": null,
          "old_text": "_in[0].type()",
          "new_text": null,
          "old_line_content": "\t\t\t_in[0].type() == PushTag &&",
          "new_line_content": "\t\tif (",
          "content_same": false
        },
        {
          "line": 154,
          "old_api": "begin",
          "new_api": null,
          "old_text": "_state.items.begin()",
          "new_text": null,
          "old_line_content": "\tif (_state.i + Method::windowSize() <= _state.items.size() && Method::apply(_state.items.begin() + _state.i, _state.out))",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 157,
          "old_api": "applyMethods",
          "new_api": null,
          "old_text": "applyMethods(_state, _other...)",
          "new_text": null,
          "old_line_content": "\t\tapplyMethods(_state, _other...);",
          "new_line_content": "\telse",
          "content_same": false
        },
        {
          "line": 127,
          "old_api": "type",
          "new_api": null,
          "old_text": "_in[1].type()",
          "new_text": null,
          "old_line_content": "\t\t\t_in[1].type() == Push &&",
          "new_line_content": "\t\t\t_in[2] == Instruction::AND &&",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 9,
      "total_additions": 13,
      "total_deletions": 11,
      "total_api_changes": 33
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 8,
        "api_related_lines": 33,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          76,
          78,
          79
        ]
      }
    },
    "api_calls_before": 39,
    "api_calls_after": 41,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 5,
      "total_diff_lines": 26
    }
  }
}