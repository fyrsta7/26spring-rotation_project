{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/solidity/modified_file/7bdd1b1d4ae46920ae54aaa61c40b411a75f15b9",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/solidity/modified_file/7bdd1b1d4ae46920ae54aaa61c40b411a75f15b9/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/solidity/modified_file/7bdd1b1d4ae46920ae54aaa61c40b411a75f15b9/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/solidity/modified_file/7bdd1b1d4ae46920ae54aaa61c40b411a75f15b9/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 326,
          "old_api": "SemanticInformation::isDeterministic(*_expr.item)",
          "new_api": "d",
          "old_text": "SemanticInformation::isDeterministic(*_expr.item)",
          "new_text": "A.d()",
          "old_line_content": "\t\t!SemanticInformation::isDeterministic(*_expr.item)",
          "new_line_content": "\t\t\t[=]() -> Pattern { return {Instruction::ADD, {{Instruction::SUB, {X, Y}}, 0 - A.d()}}; }",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": "rules",
          "new_api": "d",
          "old_text": "rules.rules()",
          "new_text": "A.d()",
          "old_line_content": "\tfor (auto const& rule: rules.rules())",
          "new_line_content": "\t\t\t[=]() -> Pattern { return {Instruction::ADD, {{Instruction::SUB, {X, Y}}, 0 - A.d()}}; }",
          "content_same": false
        },
        {
          "line": 412,
          "old_api": "unsigned",
          "new_api": "representative",
          "old_text": "unsigned(m_data)",
          "new_text": "_classes.representative(_expr.arguments[i])",
          "old_line_content": "\t\ts << instructionInfo(Instruction(unsigned(m_data))).name;",
          "new_line_content": "\t\tif (!m_arguments[i].matches(_classes.representative(_expr.arguments[i]), _classes))",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": "matchGroup",
          "new_api": "data",
          "old_text": "_pattern.matchGroup()",
          "new_text": "_item->data()",
          "old_line_content": "\tif (_pattern.matchGroup())",
          "new_line_content": "\tif (m_requireDataMatch && m_data != _item->data())",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": "toAssemblyItem",
          "new_api": "assertThrow",
          "old_text": "_pattern.toAssemblyItem(_location)",
          "new_text": "assertThrow(!!m_matchGroups, OptimizerException, \"\")",
          "old_line_content": "\t\titem = _pattern.toAssemblyItem(_location);",
          "new_line_content": "\tassertThrow(!!m_matchGroups, OptimizerException, \"\");",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 271,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "m_rules.push_back({\n\t\t\t{Instruction::ISZERO, {{Instruction::ISZERO, {{op, {X, Y}}}}}},\n\t\t\t[=]() -> Pattern { return {op, {X, Y}}; }\n\t\t})",
          "old_line_content": "\t{",
          "new_line_content": "\t\tm_rules.push_back({",
          "content_same": false
        },
        {
          "line": 401,
          "old_api": null,
          "new_api": "matchesBaseItem",
          "old_text": null,
          "new_text": "matchesBaseItem(_expr.item)",
          "old_line_content": "AssemblyItem Pattern::toAssemblyItem(SourceLocation const& _location) const",
          "new_line_content": "\tif (!matchesBaseItem(_expr.item))",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "m_rules.push_back({\n\t\t{Instruction::ISZERO, {{Instruction::ISZERO, {{Instruction::ISZERO, {X}}}}}},\n\t\t[=]() -> Pattern { return {Instruction::ISZERO, {X}}; }\n\t})",
          "old_line_content": "\t\t// we need actions that return expressions (or patterns?) here, and we need also reversed rules",
          "new_line_content": "\tm_rules.push_back({",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "m_matchGroups->count(m_matchGroup)",
          "old_line_content": "",
          "new_line_content": "\t\tif (!m_matchGroups->count(m_matchGroup))",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": null,
          "new_api": "plus<u256>()",
          "old_text": null,
          "new_text": "plus<u256>()",
          "old_line_content": "\t\t// X+(Y+A) -> (X+Y)+A",
          "new_line_content": "\t\t{Instruction::ADD, plus<u256>()},",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": null,
          "new_api": "multiplies<u256>()",
          "old_text": null,
          "new_text": "multiplies<u256>()",
          "old_line_content": "\t\t\t{op, {{op, {X, A}}, Y}},",
          "new_line_content": "\t\t{Instruction::MUL, multiplies<u256>()},",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": null,
          "new_api": "bit_and<u256>()",
          "old_text": null,
          "new_text": "bit_and<u256>()",
          "old_line_content": "\t\t\t[=]() -> Pattern { return {op, {{op, {X, Y}}, A}}; }",
          "new_line_content": "\t\t{Instruction::AND, bit_and<u256>()},",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": null,
          "new_api": "bit_or<u256>()",
          "old_text": null,
          "new_text": "bit_or<u256>()",
          "old_line_content": "\t\t}, {",
          "new_line_content": "\t\t{Instruction::OR, bit_or<u256>()},",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": null,
          "new_api": "bit_xor<u256>()",
          "old_text": null,
          "new_text": "bit_xor<u256>()",
          "old_line_content": "\t\t// For now, we still need explicit commutativity for the inner pattern",
          "new_line_content": "\t\t{Instruction::XOR, bit_xor<u256>()}",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "m_arguments.size()",
          "old_line_content": "\t{",
          "new_line_content": "\tassertThrow(m_arguments.size() == 0 || _expr.arguments.size() == m_arguments.size(), OptimizerException, \"\");",
          "content_same": false
        },
        {
          "line": 411,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "m_arguments.size()",
          "old_line_content": "\tcase Operation:",
          "new_line_content": "\tfor (size_t i = 0; i < m_arguments.size(); ++i)",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": null,
          "new_api": "AssemblyItem",
          "old_text": null,
          "new_text": "AssemblyItem(m_type, m_data, _location)",
          "old_line_content": "\t\tbreak;",
          "new_line_content": "\treturn AssemblyItem(m_type, m_data, _location);",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\t[=]() -> Pattern { return {op, {X, fun(A.d(), B.d())}}; }",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": null,
          "new_api": "unsigned",
          "old_text": null,
          "new_text": "unsigned(m_data)",
          "old_line_content": "\ts << \"(\";",
          "new_line_content": "\t\ts << instructionInfo(Instruction(unsigned(m_data))).name;",
          "content_same": false
        },
        {
          "line": 303,
          "old_api": null,
          "new_api": "d",
          "old_text": null,
          "new_text": "B.d()",
          "old_line_content": "\t\t}, {",
          "new_line_content": "\t\t\t[=]() -> Pattern { return {op, {X, fun(A.d(), B.d())}}; }",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "p.toString()",
          "old_line_content": "}",
          "new_line_content": "\t\ts << p.toString() << \", \";",
          "content_same": false
        },
        {
          "line": 448,
          "old_api": null,
          "new_api": "str",
          "old_text": null,
          "new_text": "s.str()",
          "old_line_content": "Pattern::Expression const& Pattern::matchGroupValue() const",
          "new_line_content": "\treturn s.str();",
          "content_same": false
        },
        {
          "line": 457,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "_item->type()",
          "old_line_content": "ExpressionTemplate::ExpressionTemplate(Pattern const& _pattern, SourceLocation const& _location)",
          "new_line_content": "\tif (m_type != _item->type())",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": null,
          "new_api": "assertThrow",
          "old_text": null,
          "new_text": "assertThrow(m_matchGroup > 0, OptimizerException, \"\")",
          "old_line_content": "\t\thasId = false;",
          "new_line_content": "\tassertThrow(m_matchGroup > 0, OptimizerException, \"\");",
          "content_same": false
        },
        {
          "line": 468,
          "old_api": null,
          "new_api": "assertThrow",
          "old_text": null,
          "new_text": "assertThrow((*m_matchGroups)[m_matchGroup], OptimizerException, \"\")",
          "old_line_content": "\t}",
          "new_line_content": "\tassertThrow((*m_matchGroups)[m_matchGroup], OptimizerException, \"\");",
          "content_same": false
        },
        {
          "line": 341,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "_expr.item->type()",
          "old_line_content": "\t\t\t//ExpressionTemplate t(rule.second());",
          "new_line_content": "\t\t_expr.item->type() != Operation ||",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": null,
          "new_api": "SemanticInformation::isDeterministic(*_expr.item)",
          "old_text": null,
          "new_text": "SemanticInformation::isDeterministic(*_expr.item)",
          "old_line_content": "\t\t\t//cout << \"to \" << rule.second().toString() << endl;",
          "new_line_content": "\t\t!SemanticInformation::isDeterministic(*_expr.item)",
          "content_same": false
        },
        {
          "line": 346,
          "old_api": null,
          "new_api": "rules",
          "old_text": null,
          "new_text": "rules.rules()",
          "old_line_content": "",
          "new_line_content": "\tfor (auto const& rule: rules.rules())",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": null,
          "new_api": "matchGroup",
          "old_text": null,
          "new_text": "_pattern.matchGroup()",
          "old_line_content": "\tstringstream s;",
          "new_line_content": "\tif (_pattern.matchGroup())",
          "content_same": false
        },
        {
          "line": 348,
          "old_api": null,
          "new_api": "resetMatchGroups",
          "old_text": null,
          "new_text": "rules.resetMatchGroups()",
          "old_line_content": "\t{",
          "new_line_content": "\t\trules.resetMatchGroups();",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": null,
          "new_api": "matches",
          "old_text": null,
          "new_text": "rule.first.matches(_expr, *this)",
          "old_line_content": "\t\tExpression expr = _expr;",
          "new_line_content": "\t\tif (rule.first.matches(_expr, *this))",
          "content_same": false
        },
        {
          "line": 478,
          "old_api": null,
          "new_api": "id",
          "old_text": null,
          "new_text": "_pattern.id()",
          "old_line_content": "\telse",
          "new_line_content": "\t\tid = _pattern.id();",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": null,
          "new_api": "toAssemblyItem",
          "old_text": null,
          "new_text": "_pattern.toAssemblyItem(_location)",
          "old_line_content": "\ts << \")\";",
          "new_line_content": "\t\titem = _pattern.toAssemblyItem(_location);",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": null,
          "new_api": "arguments",
          "old_text": null,
          "new_text": "_pattern.arguments()",
          "old_line_content": "}",
          "new_line_content": "\tfor (auto const& arg: _pattern.arguments())",
          "content_same": false
        },
        {
          "line": 486,
          "old_api": null,
          "new_api": "ExpressionTemplate",
          "old_text": null,
          "new_text": "ExpressionTemplate(arg, _location)",
          "old_line_content": "",
          "new_line_content": "\t\targuments.push_back(ExpressionTemplate(arg, _location));",
          "content_same": false
        },
        {
          "line": 359,
          "old_api": null,
          "new_api": "getLocation",
          "old_text": null,
          "new_text": "_expr.item->getLocation()",
          "old_line_content": "\tif (_template.hasId)",
          "new_line_content": "\t\t\treturn rebuildExpression(ExpressionTemplate(rule.second(), _expr.item->getLocation()));",
          "content_same": false
        },
        {
          "line": 363,
          "old_api": null,
          "new_api": "SemanticInformation::isCommutativeOperation(*_expr.item)",
          "old_text": null,
          "new_text": "SemanticInformation::isCommutativeOperation(*_expr.item)",
          "old_line_content": "\tfor (ExpressionTemplate const& t: _template.arguments)",
          "new_line_content": "\tif (!_secondRun && _expr.arguments.size() == 2 && SemanticInformation::isCommutativeOperation(*_expr.item))",
          "content_same": false
        },
        {
          "line": 366,
          "old_api": null,
          "new_api": "swap",
          "old_text": null,
          "new_text": "swap(expr.arguments[0], expr.arguments[1])",
          "old_line_content": "}",
          "new_line_content": "\t\tswap(expr.arguments[0], expr.arguments[1]);",
          "content_same": false
        },
        {
          "line": 367,
          "old_api": null,
          "new_api": "tryToSimplify",
          "old_text": null,
          "new_text": "tryToSimplify(expr, true)",
          "old_line_content": "",
          "new_line_content": "\t\treturn tryToSimplify(expr, true);",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": null,
          "new_api": "toString",
          "old_text": null,
          "new_text": "arg.toString()",
          "old_line_content": "",
          "new_line_content": "\t\ts << arg.toString();",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": null,
          "new_api": "str",
          "old_text": null,
          "new_text": "s.str()",
          "old_line_content": "",
          "new_line_content": "\treturn s.str();",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": null,
          "new_api": "rebuildExpression",
          "old_text": null,
          "new_text": "rebuildExpression(t)",
          "old_line_content": "\tm_matchGroups = &_matchGroups;",
          "new_line_content": "\t\targuments.push_back(rebuildExpression(t));",
          "content_same": false
        },
        {
          "line": 381,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "find(_template.item, arguments)",
          "old_line_content": "}",
          "new_line_content": "\treturn find(_template.item, arguments);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 385,
          "old_api": "matchesBaseItem",
          "new_api": null,
          "old_text": "matchesBaseItem(_expr.item)",
          "new_text": null,
          "old_line_content": "\tif (!matchesBaseItem(_expr.item))",
          "new_line_content": "Pattern::Pattern(Instruction _instruction, std::vector<Pattern> const& _arguments):",
          "content_same": false
        },
        {
          "line": 389,
          "old_api": "count",
          "new_api": null,
          "old_text": "m_matchGroups->count(m_matchGroup)",
          "new_text": null,
          "old_line_content": "\t\tif (!m_matchGroups->count(m_matchGroup))",
          "new_line_content": "\tm_arguments(_arguments)",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": "plus<u256>()",
          "new_api": null,
          "old_text": "plus<u256>()",
          "new_text": null,
          "old_line_content": "\t\t{Instruction::ADD, plus<u256>()},",
          "new_line_content": "\t\tInstruction::EQ,",
          "content_same": false
        },
        {
          "line": 266,
          "old_api": "multiplies<u256>()",
          "new_api": null,
          "old_text": "multiplies<u256>()",
          "new_text": null,
          "old_line_content": "\t\t{Instruction::MUL, multiplies<u256>()},",
          "new_line_content": "\t\tInstruction::LT,",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": "bit_and<u256>()",
          "new_api": null,
          "old_text": "bit_and<u256>()",
          "new_text": null,
          "old_line_content": "\t\t{Instruction::AND, bit_and<u256>()},",
          "new_line_content": "\t\tInstruction::SLT,",
          "content_same": false
        },
        {
          "line": 268,
          "old_api": "bit_or<u256>()",
          "new_api": null,
          "old_text": "bit_or<u256>()",
          "new_text": null,
          "old_line_content": "\t\t{Instruction::OR, bit_or<u256>()},",
          "new_line_content": "\t\tInstruction::GT,",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": "bit_xor<u256>()",
          "new_api": null,
          "old_text": "bit_xor<u256>()",
          "new_text": null,
          "old_line_content": "\t\t{Instruction::XOR, bit_xor<u256>()}",
          "new_line_content": "\t\tInstruction::SGT",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": "size",
          "new_api": null,
          "old_text": "m_arguments.size()",
          "new_text": null,
          "old_line_content": "\tassertThrow(m_arguments.size() == 0 || _expr.arguments.size() == m_arguments.size(), OptimizerException, \"\");",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": "size",
          "new_api": null,
          "old_text": "m_arguments.size()",
          "new_text": null,
          "old_line_content": "\tfor (size_t i = 0; i < m_arguments.size(); ++i)",
          "new_line_content": "\tm_matchGroup = _group;",
          "content_same": false
        },
        {
          "line": 396,
          "old_api": "representative",
          "new_api": null,
          "old_text": "_classes.representative(_expr.arguments[i])",
          "new_text": null,
          "old_line_content": "\t\tif (!m_arguments[i].matches(_classes.representative(_expr.arguments[i]), _classes))",
          "new_line_content": "\tm_matchGroups = &_matchGroups;",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": "AssemblyItem",
          "new_api": null,
          "old_text": "AssemblyItem(m_type, m_data, _location)",
          "new_text": null,
          "old_line_content": "\treturn AssemblyItem(m_type, m_data, _location);",
          "new_line_content": "\tif (m_matchGroup)",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": "d",
          "new_api": null,
          "old_text": "B.d()",
          "new_text": null,
          "old_line_content": "\t\t\t[=]() -> Pattern { return {op, {X, fun(A.d(), B.d())}}; }",
          "new_line_content": "\t// Associative operations",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": "d",
          "new_api": null,
          "old_text": "B.d()",
          "new_text": null,
          "old_line_content": "\t\t\t[=]() -> Pattern { return {op, {X, fun(A.d(), B.d())}}; }",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": "d",
          "new_api": null,
          "old_text": "A.d()",
          "new_text": null,
          "old_line_content": "\t\t\t[=]() -> Pattern { return {Instruction::ADD, {X, 0 - A.d()}}; }",
          "new_line_content": "\t\t\t{op, {{op, {X, A}}, Y}},",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": "toString",
          "new_api": null,
          "old_text": "p.toString()",
          "new_text": null,
          "old_line_content": "\t\ts << p.toString() << \", \";",
          "new_line_content": "\tcase Push:",
          "content_same": false
        },
        {
          "line": 432,
          "old_api": "str",
          "new_api": null,
          "old_text": "s.str()",
          "new_text": null,
          "old_line_content": "\treturn s.str();",
          "new_line_content": "\t\tbreak;",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": "d",
          "new_api": null,
          "old_text": "A.d()",
          "new_text": null,
          "old_line_content": "\t\t\t[=]() -> Pattern { return {Instruction::ADD, {{Instruction::SUB, {X, Y}}, 0 - A.d()}}; }",
          "new_line_content": "\tm_rules += vector<pair<Pattern, function<Pattern()>>>{",
          "content_same": false
        },
        {
          "line": 441,
          "old_api": "type",
          "new_api": null,
          "old_text": "_item->type()",
          "new_text": null,
          "old_line_content": "\tif (m_type != _item->type())",
          "new_line_content": "\t\ts << \" ~\";",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": "data",
          "new_api": null,
          "old_text": "_item->data()",
          "new_text": null,
          "old_line_content": "\tif (m_requireDataMatch && m_data != _item->data())",
          "new_line_content": "\t\ts << \"[\" << dec << m_matchGroup << \"]\";",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": "assertThrow",
          "new_api": null,
          "old_text": "assertThrow(m_matchGroup > 0, OptimizerException, \"\")",
          "new_text": null,
          "old_line_content": "\tassertThrow(m_matchGroup > 0, OptimizerException, \"\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": "assertThrow",
          "new_api": null,
          "old_text": "assertThrow(!!m_matchGroups, OptimizerException, \"\")",
          "new_text": null,
          "old_line_content": "\tassertThrow(!!m_matchGroups, OptimizerException, \"\");",
          "new_line_content": "bool Pattern::matchesBaseItem(AssemblyItem const* _item) const",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": "assertThrow",
          "new_api": null,
          "old_text": "assertThrow((*m_matchGroups)[m_matchGroup], OptimizerException, \"\")",
          "new_text": null,
          "old_line_content": "\tassertThrow((*m_matchGroups)[m_matchGroup], OptimizerException, \"\");",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 325,
          "old_api": "type",
          "new_api": null,
          "old_text": "_expr.item->type()",
          "new_text": null,
          "old_line_content": "\t\t_expr.item->type() != Operation ||",
          "new_line_content": "\t\t\t{Instruction::SUB, {X, {Instruction::ADD, {Y, A}}}},",
          "content_same": false
        },
        {
          "line": 332,
          "old_api": "resetMatchGroups",
          "new_api": null,
          "old_text": "rules.resetMatchGroups()",
          "new_text": null,
          "old_line_content": "\t\trules.resetMatchGroups();",
          "new_line_content": "\t};",
          "content_same": false
        },
        {
          "line": 333,
          "old_api": "matches",
          "new_api": null,
          "old_text": "rule.first.matches(_expr, *this)",
          "new_text": null,
          "old_line_content": "\t\tif (rule.first.matches(_expr, *this))",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": "id",
          "new_api": null,
          "old_text": "_pattern.id()",
          "new_text": null,
          "old_line_content": "\t\tid = _pattern.id();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": "arguments",
          "new_api": null,
          "old_text": "_pattern.arguments()",
          "new_text": null,
          "old_line_content": "\tfor (auto const& arg: _pattern.arguments())",
          "new_line_content": "\treturn *(*m_matchGroups)[m_matchGroup];",
          "content_same": false
        },
        {
          "line": 470,
          "old_api": "ExpressionTemplate",
          "new_api": null,
          "old_text": "ExpressionTemplate(arg, _location)",
          "new_text": null,
          "old_line_content": "\t\targuments.push_back(ExpressionTemplate(arg, _location));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": "getLocation",
          "new_api": null,
          "old_text": "_expr.item->getLocation()",
          "new_text": null,
          "old_line_content": "\t\t\treturn rebuildExpression(ExpressionTemplate(rule.second(), _expr.item->getLocation()));",
          "new_line_content": "\t)",
          "content_same": false
        },
        {
          "line": 347,
          "old_api": "SemanticInformation::isCommutativeOperation(*_expr.item)",
          "new_api": null,
          "old_text": "SemanticInformation::isCommutativeOperation(*_expr.item)",
          "new_text": null,
          "old_line_content": "\tif (!_secondRun && _expr.arguments.size() == 2 && SemanticInformation::isCommutativeOperation(*_expr.item))",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 350,
          "old_api": "swap",
          "new_api": null,
          "old_text": "swap(expr.arguments[0], expr.arguments[1])",
          "new_text": null,
          "old_line_content": "\t\tswap(expr.arguments[0], expr.arguments[1]);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": "tryToSimplify",
          "new_api": null,
          "old_text": "tryToSimplify(expr, true)",
          "new_text": null,
          "old_line_content": "\t\treturn tryToSimplify(expr, true);",
          "new_line_content": "\t\t\t// Debug info",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": "toString",
          "new_api": null,
          "old_text": "arg.toString()",
          "new_text": null,
          "old_line_content": "\t\ts << arg.toString();",
          "new_line_content": "\t\thasId = false;",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": "str",
          "new_api": null,
          "old_text": "s.str()",
          "new_text": null,
          "old_line_content": "\treturn s.str();",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": "rebuildExpression",
          "new_api": null,
          "old_text": "rebuildExpression(t)",
          "new_text": null,
          "old_line_content": "\t\targuments.push_back(rebuildExpression(t));",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": "find",
          "new_api": null,
          "old_text": "find(_template.item, arguments)",
          "new_text": null,
          "old_line_content": "\treturn find(_template.item, arguments);",
          "new_line_content": "\t\tExpression expr = _expr;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 5,
      "total_additions": 38,
      "total_deletions": 36,
      "total_api_changes": 79
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 16,
        "api_related_lines": 79,
        "non_api_lines": 9,
        "non_api_line_numbers": [
          263,
          264,
          270,
          272,
          273,
          274,
          276,
          277,
          278
        ]
      }
    },
    "api_calls_before": 222,
    "api_calls_after": 224,
    "diff_info": {
      "added_lines": 16,
      "removed_lines": 0,
      "total_diff_lines": 28
    }
  }
}