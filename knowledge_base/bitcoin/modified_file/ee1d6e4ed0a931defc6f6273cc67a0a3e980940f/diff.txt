diff --git a/modified_file.cpp b/modified_file.cpp
index 0000000..1111111 100644
--- a/modified_file.cpp
+++ b/modified_file.cpp
--- a/modified_file.cpp
+++ b/modified_file.cpp
@@ -810,6 +810,9 @@
                                  CBlockIndex* pindexBlock, int64& nFees, bool fBlock, bool fMiner, int64 nMinFee)

 {

     // Take over previous transactions' spent pointers

+    // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain

+    // fMiner is true when called from the internal bitcoin miner

+    // ... both are false when called from CTransaction::AcceptToMemoryPool

     if (!IsCoinBase())

     {

         int64 nValueIn = 0;

@@ -863,9 +866,13 @@
                     if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)

                         return DoS(10, error("ConnectInputs() : tried to spend coinbase at depth %d", pindexBlock->nHeight - pindex->nHeight));

 

-            // Verify signature

-            if (!VerifySignature(txPrev, *this, i))

-                return DoS(100,error("ConnectInputs() : %s VerifySignature failed", GetHash().ToString().substr(0,10).c_str()));

+            // Skip ECDSA signature verification when connecting blocks (fBlock=true) during initial download

+            // (before the last blockchain checkpoint). This is safe because block merkle hashes are

+            // still computed and checked, and any change will be caught at the next checkpoint.

+            if (!(fBlock && IsInitialBlockDownload()))

+                // Verify signature

+                if (!VerifySignature(txPrev, *this, i))

+                    return DoS(100,error("ConnectInputs() : %s VerifySignature failed", GetHash().ToString().substr(0,10).c_str()));

 

             // Check for conflicts (double-spend)

             // This doesn't trigger the DoS code on purpose; if it did, it would make it easier
