{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/03d49d0f25ab5660524d5ddd171de677a808b984",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/03d49d0f25ab5660524d5ddd171de677a808b984/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/03d49d0f25ab5660524d5ddd171de677a808b984/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/03d49d0f25ab5660524d5ddd171de677a808b984/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": true,
    "api_changes": {
      "replacements": [
        {
          "line": 402,
          "old_api": "strprintf",
          "new_api": "empty",
          "old_text": "strprintf(\"httpworker.%i\", worker_num)",
          "new_text": "boundSockets.empty()",
          "old_line_content": "    util::ThreadRename(strprintf(\"httpworker.%i\", worker_num));",
          "new_line_content": "    return !boundSockets.empty();",
          "content_same": false
        },
        {
          "line": 435,
          "old_api": "WillLogCategory",
          "new_api": "InitHTTPAllowList",
          "old_text": "LogInstance().WillLogCategory(BCLog::LIBEVENT)",
          "new_text": "InitHTTPAllowList()",
          "old_line_content": "    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));",
          "new_line_content": "    if (!InitHTTPAllowList())",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": "get",
          "new_api": "evthread_use_pthreads",
          "old_text": "base_ctr.get()",
          "new_text": "evthread_use_pthreads()",
          "old_line_content": "    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());",
          "new_line_content": "    evthread_use_pthreads();",
          "content_same": false
        },
        {
          "line": 449,
          "old_api": "LogPrintf",
          "new_api": "obtain_event_base",
          "old_text": "LogPrintf(\"couldn't create evhttp. Exiting.\\n\")",
          "new_text": "obtain_event_base()",
          "old_line_content": "        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");",
          "new_line_content": "    raii_event_base base_ctr = obtain_event_base();",
          "content_same": false
        },
        {
          "line": 453,
          "old_api": "GetIntArg",
          "new_api": "get",
          "old_text": "gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT)",
          "new_text": "http_ctr.get()",
          "old_line_content": "    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));",
          "new_line_content": "    struct evhttp* http = http_ctr.get();",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": "evhttp_set_max_body_size",
          "new_api": "LogPrintf",
          "old_text": "evhttp_set_max_body_size(http, MAX_SIZE)",
          "new_text": "LogPrintf(\"couldn't create evhttp. Exiting.\\n\")",
          "old_line_content": "    evhttp_set_max_body_size(http, MAX_SIZE);",
          "new_line_content": "        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": "LogPrintf",
          "new_api": "GetIntArg",
          "old_text": "LogPrintf(\"Unable to bind any endpoint for RPC server\\n\")",
          "new_text": "gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT)",
          "old_line_content": "        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");",
          "new_line_content": "    evhttp_set_timeout(http, gArgs.GetIntArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": "GetIntArg",
          "new_api": "HTTPBindAddresses",
          "old_text": "gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE)",
          "new_text": "HTTPBindAddresses(http)",
          "old_line_content": "    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);",
          "new_line_content": "    if (!HTTPBindAddresses(http)) {",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": "LogDebug",
          "new_api": "LogPrintf",
          "old_text": "LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth)",
          "new_text": "LogPrintf(\"Unable to bind any endpoint for RPC server\\n\")",
          "old_line_content": "    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);",
          "new_line_content": "        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": "release",
          "new_api": "LogPrint",
          "old_text": "base_ctr.release()",
          "new_text": "LogPrint(BCLog::HTTP, \"Initialized HTTP server\\n\")",
          "old_line_content": "    eventBase = base_ctr.release();",
          "new_line_content": "    LogPrint(BCLog::HTTP, \"Initialized HTTP server\\n\");",
          "content_same": false
        },
        {
          "line": 470,
          "old_api": "release",
          "new_api": "GetIntArg",
          "old_text": "http_ctr.release()",
          "new_text": "gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE)",
          "old_line_content": "    eventHTTP = http_ctr.release();",
          "new_line_content": "    int workQueueDepth = std::max((long)gArgs.GetIntArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": "event_enable_debug_logging",
          "new_api": "release",
          "old_text": "event_enable_debug_logging(EVENT_DBG_ALL)",
          "new_text": "http_ctr.release()",
          "old_line_content": "        event_enable_debug_logging(EVENT_DBG_ALL);",
          "new_line_content": "    eventHTTP = http_ctr.release();",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": "LogPrint",
          "new_api": "get",
          "old_text": "LogPrint(BCLog::HTTP, \"Interrupting HTTP server\\n\")",
          "new_text": "g_work_queue.get()",
          "old_line_content": "    LogPrint(BCLog::HTTP, \"Interrupting HTTP server\\n\");",
          "new_line_content": "        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": "Interrupt",
          "new_api": "LogPrint",
          "old_text": "g_work_queue->Interrupt()",
          "new_text": "LogPrint(BCLog::HTTP, \"Interrupting HTTP server\\n\")",
          "old_line_content": "        g_work_queue->Interrupt();",
          "new_line_content": "    LogPrint(BCLog::HTTP, \"Interrupting HTTP server\\n\");",
          "content_same": false
        },
        {
          "line": 510,
          "old_api": "LogPrint",
          "new_api": "Interrupt",
          "old_text": "LogPrint(BCLog::HTTP, \"Stopping HTTP server\\n\")",
          "new_text": "g_work_queue->Interrupt()",
          "old_line_content": "    LogPrint(BCLog::HTTP, \"Stopping HTTP server\\n\");",
          "new_line_content": "        g_work_queue->Interrupt();",
          "content_same": false
        },
        {
          "line": 516,
          "old_api": "clear",
          "new_api": "LogPrint",
          "old_text": "g_thread_http_workers.clear()",
          "new_text": "LogPrint(BCLog::HTTP, \"Stopping HTTP server\\n\")",
          "old_line_content": "        g_thread_http_workers.clear();",
          "new_line_content": "    LogPrint(BCLog::HTTP, \"Stopping HTTP server\\n\");",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": "event_base_once",
          "new_api": "WaitUntilEmpty",
          "old_text": "event_base_once(eventBase, -1, EV_TIMEOUT, [](evutil_socket_t, short, void*) {\n            evhttp_free(eventHTTP);\n            eventHTTP = nullptr;\n        }, nullptr, nullptr)",
          "new_text": "g_requests.WaitUntilEmpty()",
          "old_line_content": "        event_base_once(eventBase, -1, EV_TIMEOUT, [](evutil_socket_t, short, void*) {",
          "new_line_content": "        g_requests.WaitUntilEmpty();",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": "LogPrint",
          "new_api": "event_base_once",
          "old_text": "LogPrint(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\")",
          "new_text": "event_base_once(eventBase, -1, EV_TIMEOUT, [](evutil_socket_t, short, void*) {\n            evhttp_free(eventHTTP);\n            eventHTTP = nullptr;\n        }, nullptr, nullptr)",
          "old_line_content": "        LogPrint(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\");",
          "new_line_content": "        event_base_once(eventBase, -1, EV_TIMEOUT, [](evutil_socket_t, short, void*) {",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": "join",
          "new_api": "evhttp_free",
          "old_text": "g_thread_http.join()",
          "new_text": "evhttp_free(eventHTTP)",
          "old_line_content": "        if (g_thread_http.joinable()) g_thread_http.join();",
          "new_line_content": "            evhttp_free(eventHTTP);",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": "std::make_pair(false, \"\")",
          "new_api": "evhttp_request_get_input_headers",
          "old_text": "std::make_pair(false, \"\")",
          "new_text": "evhttp_request_get_input_headers(req)",
          "old_line_content": "        return std::make_pair(false, \"\");",
          "new_line_content": "    const struct evkeyvalq* headers = evhttp_request_get_input_headers(req);",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": "evhttp_request_get_output_headers",
          "new_api": "evbuffer_drain",
          "old_text": "evhttp_request_get_output_headers(req)",
          "new_text": "evbuffer_drain(buf, size)",
          "old_line_content": "    struct evkeyvalq* headers = evhttp_request_get_output_headers(req);",
          "new_line_content": "    evbuffer_drain(buf, size);",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": "event_get_version_number",
          "new_api": "size",
          "old_text": "event_get_version_number()",
          "new_text": "reply.size()",
          "old_line_content": "        if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02010900) {",
          "new_line_content": "    evbuffer_add(evb, reply.data(), reply.size());",
          "content_same": false
        },
        {
          "line": 656,
          "old_api": "evhttp_connection_get_bufferevent",
          "new_api": "evhttp_send_reply",
          "old_text": "evhttp_connection_get_bufferevent(conn)",
          "new_text": "evhttp_send_reply(req_copy, nStatus, nullptr, nullptr)",
          "old_line_content": "                bufferevent* bev = evhttp_connection_get_bufferevent(conn);",
          "new_line_content": "        evhttp_send_reply(req_copy, nStatus, nullptr, nullptr);",
          "content_same": false
        },
        {
          "line": 728,
          "old_api": "evhttp_parse_query_str",
          "new_api": "evhttp_uri_get_query",
          "old_text": "evhttp_parse_query_str(query, &params_q)",
          "new_text": "evhttp_uri_get_query(uri_parsed)",
          "old_line_content": "        evhttp_parse_query_str(query, &params_q);",
          "new_line_content": "    const char* query{evhttp_uri_get_query(uri_parsed)};",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": "begin",
          "new_api": "emplace_back",
          "old_text": "pathHandlers.begin()",
          "new_text": "pathHandlers.emplace_back(prefix, exactMatch, handler)",
          "old_line_content": "    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();",
          "new_line_content": "    pathHandlers.emplace_back(prefix, exactMatch, handler);",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": "LogPrint",
          "new_api": "end",
          "old_text": "LogPrint(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch)",
          "new_text": "pathHandlers.end()",
          "old_line_content": "        LogPrint(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);",
          "new_line_content": "    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 518,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\")",
          "old_line_content": "    // Unlisten sockets, these are what make the event loop running, which means",
          "new_line_content": "        LogPrint(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");",
          "content_same": false
        },
        {
          "line": 520,
          "old_api": null,
          "new_api": "join",
          "old_text": null,
          "new_text": "thread.join()",
          "old_line_content": "    for (evhttp_bound_socket *socket : boundSockets) {",
          "new_line_content": "            thread.join();",
          "content_same": false
        },
        {
          "line": 522,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "g_thread_http_workers.clear()",
          "old_line_content": "    }",
          "new_line_content": "        g_thread_http_workers.clear();",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": null,
          "new_api": "evhttp_del_accept_socket",
          "old_text": null,
          "new_text": "evhttp_del_accept_socket(eventHTTP, socket)",
          "old_line_content": "        }",
          "new_line_content": "        evhttp_del_accept_socket(eventHTTP, socket);",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "boundSockets.clear()",
          "old_line_content": "    }",
          "new_line_content": "    boundSockets.clear();",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": null,
          "new_api": "CountActiveConnections",
          "old_text": null,
          "new_text": "g_requests.CountActiveConnections()",
          "old_line_content": "        // Schedule a callback to call evhttp_free in the event base thread, so",
          "new_line_content": "        if (const auto n_connections{g_requests.CountActiveConnections()}; n_connections != 0) {",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::HTTP, \"Waiting for %d connections to stop HTTP server\\n\", n_connections)",
          "old_line_content": "        // that evhttp_free does not need to be called again after the handling",
          "new_line_content": "            LogPrint(BCLog::HTTP, \"Waiting for %d connections to stop HTTP server\\n\", n_connections);",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": null,
          "new_api": "join",
          "old_text": null,
          "new_text": "g_thread_http.join()",
          "old_line_content": "}",
          "new_line_content": "        if (g_thread_http.joinable()) g_thread_http.join();",
          "content_same": false
        },
        {
          "line": 548,
          "old_api": null,
          "new_api": "event_base_free",
          "old_text": null,
          "new_text": "event_base_free(eventBase)",
          "old_line_content": "",
          "new_line_content": "        event_base_free(eventBase);",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "g_work_queue.reset()",
          "old_line_content": "    return eventBase;",
          "new_line_content": "    g_work_queue.reset();",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::HTTP, \"Stopped HTTP server\\n\")",
          "old_line_content": "}",
          "new_line_content": "    LogPrint(BCLog::HTTP, \"Stopped HTTP server\\n\");",
          "content_same": false
        },
        {
          "line": 563,
          "old_api": null,
          "new_api": "static_cast<HTTPEvent*>(data)",
          "old_text": null,
          "new_text": "static_cast<HTTPEvent*>(data)",
          "old_line_content": "HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):",
          "new_line_content": "    HTTPEvent *self = static_cast<HTTPEvent*>(data);",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": null,
          "new_api": "handler",
          "old_text": null,
          "new_text": "self->handler()",
          "old_line_content": "    deleteWhenTriggered(_deleteWhenTriggered), handler(_handler)",
          "new_line_content": "    self->handler();",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": null,
          "new_api": "event_new",
          "old_text": null,
          "new_text": "event_new(base, -1, 0, httpevent_callback_fn, this)",
          "old_line_content": "}",
          "new_line_content": "    ev = event_new(base, -1, 0, httpevent_callback_fn, this);",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(ev)",
          "old_line_content": "void HTTPEvent::trigger(struct timeval* tv)",
          "new_line_content": "    assert(ev);",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": null,
          "new_api": "event_free",
          "old_text": null,
          "new_text": "event_free(ev)",
          "old_line_content": "    else",
          "new_line_content": "    event_free(ev);",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": null,
          "new_api": "event_active",
          "old_text": null,
          "new_text": "event_active(ev, 0, 0)",
          "old_line_content": "{",
          "new_line_content": "        event_active(ev, 0, 0); // immediately trigger event in main thread",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": null,
          "new_api": "evtimer_add",
          "old_text": null,
          "new_text": "evtimer_add(ev, tv)",
          "old_line_content": "",
          "new_line_content": "        evtimer_add(ev, tv); // trigger after timeval passed",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"%s: Unhandled request\\n\", __func__)",
          "old_line_content": "std::pair<bool, std::string> HTTPRequest::GetHeader(const std::string& hdr) const",
          "new_line_content": "        LogPrintf(\"%s: Unhandled request\\n\", __func__);",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": null,
          "new_api": "WriteReply",
          "old_text": null,
          "new_text": "WriteReply(HTTP_INTERNAL_SERVER_ERROR, \"Unhandled request\")",
          "old_line_content": "{",
          "new_line_content": "        WriteReply(HTTP_INTERNAL_SERVER_ERROR, \"Unhandled request\");",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(headers)",
          "old_line_content": "}",
          "new_line_content": "    assert(headers);",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "hdr.c_str()",
          "old_line_content": "",
          "new_line_content": "    const char* val = evhttp_find_header(headers, hdr.c_str());",
          "content_same": false
        },
        {
          "line": 607,
          "old_api": null,
          "new_api": "std::make_pair(true, val)",
          "old_text": null,
          "new_text": "std::make_pair(true, val)",
          "old_line_content": "{",
          "new_line_content": "        return std::make_pair(true, val);",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": null,
          "new_api": "std::make_pair(false, \"\")",
          "old_text": null,
          "new_text": "std::make_pair(false, \"\")",
          "old_line_content": "    if (!buf)",
          "new_line_content": "        return std::make_pair(false, \"\");",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": null,
          "new_api": "evhttp_request_get_input_buffer",
          "old_text": null,
          "new_text": "evhttp_request_get_input_buffer(req)",
          "old_line_content": "     * evbuffer_peek and an awkward loop. Though in that case, it'd be even",
          "new_line_content": "    struct evbuffer* buf = evhttp_request_get_input_buffer(req);",
          "content_same": false
        },
        {
          "line": 617,
          "old_api": null,
          "new_api": "evbuffer_get_length",
          "old_text": null,
          "new_text": "evbuffer_get_length(buf)",
          "old_line_content": "     */",
          "new_line_content": "    size_t size = evbuffer_get_length(buf);",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": null,
          "new_api": "evbuffer_pullup",
          "old_text": null,
          "new_text": "evbuffer_pullup(buf, size)",
          "old_line_content": "}",
          "new_line_content": "    const char* data = (const char*)evbuffer_pullup(buf, size);",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": null,
          "new_api": "evhttp_request_get_output_headers",
          "old_text": null,
          "new_text": "evhttp_request_get_output_headers(req)",
          "old_line_content": " * a HTTP request.",
          "new_line_content": "    struct evkeyvalq* headers = evhttp_request_get_output_headers(req);",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(headers)",
          "old_line_content": " * Replies must be sent in the main loop in the main http thread,",
          "new_line_content": "    assert(headers);",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "value.c_str()",
          "old_line_content": " * this cannot be done from worker threads.",
          "new_line_content": "    evhttp_add_header(headers, hdr.c_str(), value.c_str());",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": null,
          "new_api": "WriteHeader",
          "old_text": null,
          "new_text": "WriteHeader(\"Connection\", \"close\")",
          "old_line_content": "    auto req_copy = req;",
          "new_line_content": "        WriteHeader(\"Connection\", \"close\");",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": null,
          "new_api": "evhttp_request_get_output_buffer",
          "old_text": null,
          "new_text": "evhttp_request_get_output_buffer(req)",
          "old_line_content": "        // Re-enable reading from the socket. This is the second part of the libevent",
          "new_line_content": "    struct evbuffer* evb = evhttp_request_get_output_buffer(req);",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(evb)",
          "old_line_content": "        // workaround above.",
          "new_line_content": "    assert(evb);",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": null,
          "new_api": "event_get_version_number",
          "old_text": null,
          "new_text": "event_get_version_number()",
          "old_line_content": "                }",
          "new_line_content": "        if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02010900) {",
          "content_same": false
        },
        {
          "line": 660,
          "old_api": null,
          "new_api": "evhttp_request_get_connection",
          "old_text": null,
          "new_text": "evhttp_request_get_connection(req_copy)",
          "old_line_content": "            }",
          "new_line_content": "            evhttp_connection* conn = evhttp_request_get_connection(req_copy);",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": null,
          "new_api": "evhttp_connection_get_bufferevent",
          "old_text": null,
          "new_text": "evhttp_connection_get_bufferevent(conn)",
          "old_line_content": "    });",
          "new_line_content": "                bufferevent* bev = evhttp_connection_get_bufferevent(conn);",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "bufferevent_enable",
          "old_text": null,
          "new_text": "bufferevent_enable(bev, EV_READ | EV_WRITE)",
          "old_line_content": "    replySent = true;",
          "new_line_content": "                    bufferevent_enable(bev, EV_READ | EV_WRITE);",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": null,
          "new_api": "trigger",
          "old_text": null,
          "new_text": "ev->trigger(nullptr)",
          "old_line_content": "{",
          "new_line_content": "    ev->trigger(nullptr);",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": null,
          "new_api": "evhttp_request_get_connection",
          "old_text": null,
          "new_text": "evhttp_request_get_connection(req)",
          "old_line_content": "",
          "new_line_content": "    evhttp_connection* con = evhttp_request_get_connection(req);",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": null,
          "new_api": "evhttp_connection_get_peer",
          "old_text": null,
          "new_text": "evhttp_connection_get_peer(con, &address, &port)",
          "old_line_content": "    }",
          "new_line_content": "        evhttp_connection_get_peer(con, &address, &port);",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": null,
          "new_api": "evhttp_connection_get_peer",
          "old_text": null,
          "new_text": "evhttp_connection_get_peer(con, (char**)&address, &port)",
          "old_line_content": "}",
          "new_line_content": "        evhttp_connection_get_peer(con, (char**)&address, &port);",
          "content_same": false
        },
        {
          "line": 689,
          "old_api": null,
          "new_api": "LookupNumeric",
          "old_text": null,
          "new_text": "LookupNumeric(address, port)",
          "old_line_content": "{",
          "new_line_content": "        peer = MaybeFlipIPv6toCJDNS(LookupNumeric(address, port));",
          "content_same": false
        },
        {
          "line": 696,
          "old_api": null,
          "new_api": "evhttp_request_get_uri",
          "old_text": null,
          "new_text": "evhttp_request_get_uri(req)",
          "old_line_content": "    case EVHTTP_REQ_GET:",
          "new_line_content": "    return evhttp_request_get_uri(req);",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": null,
          "new_api": "evhttp_request_get_command",
          "old_text": null,
          "new_text": "evhttp_request_get_command(req)",
          "old_line_content": "        return HEAD;",
          "new_line_content": "    switch (evhttp_request_get_command(req)) {",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": null,
          "new_api": "evhttp_request_get_uri",
          "old_text": null,
          "new_text": "evhttp_request_get_uri(req)",
          "old_line_content": "{",
          "new_line_content": "    const char* uri{evhttp_request_get_uri(req)};",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": null,
          "new_api": "GetQueryParameterFromUri",
          "old_text": null,
          "new_text": "GetQueryParameterFromUri(uri, key)",
          "old_line_content": "    if (!uri_parsed) {",
          "new_line_content": "    return GetQueryParameterFromUri(uri, key);",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": null,
          "new_api": "evhttp_uri_parse",
          "old_text": null,
          "new_text": "evhttp_uri_parse(uri)",
          "old_line_content": "",
          "new_line_content": "    evhttp_uri* uri_parsed{evhttp_uri_parse(uri)};",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": null,
          "new_api": "std::runtime_error(\"URI parsing failed, it likely contained RFC 3986 invalid characters\")",
          "old_text": null,
          "new_text": "std::runtime_error(\"URI parsing failed, it likely contained RFC 3986 invalid characters\")",
          "old_line_content": "        // Parse the query string into a key-value queue and iterate over it",
          "new_line_content": "        throw std::runtime_error(\"URI parsing failed, it likely contained RFC 3986 invalid characters\");",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": null,
          "new_api": "evhttp_parse_query_str",
          "old_text": null,
          "new_text": "evhttp_parse_query_str(query, &params_q)",
          "old_line_content": "            }",
          "new_line_content": "        evhttp_parse_query_str(query, &params_q);",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": null,
          "new_api": "evhttp_clear_headers",
          "old_text": null,
          "new_text": "evhttp_clear_headers(&params_q)",
          "old_line_content": "",
          "new_line_content": "        evhttp_clear_headers(&params_q);",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": null,
          "new_api": "evhttp_uri_free",
          "old_text": null,
          "new_text": "evhttp_uri_free(uri_parsed)",
          "old_line_content": "{",
          "new_line_content": "    evhttp_uri_free(uri_parsed);",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch)",
          "old_line_content": "{",
          "new_line_content": "    LogPrint(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);",
          "content_same": false
        },
        {
          "line": 758,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(g_httppathhandlers_mutex)",
          "old_line_content": "    if (i != iend)",
          "new_line_content": "    LOCK(g_httppathhandlers_mutex);",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "pathHandlers.begin()",
          "old_line_content": "    {",
          "new_line_content": "    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();",
          "content_same": false
        },
        {
          "line": 766,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch)",
          "old_line_content": "",
          "new_line_content": "        LogPrint(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "pathHandlers.erase(i)",
          "old_line_content": "",
          "new_line_content": "        pathHandlers.erase(i);",
          "content_same": false
        },
        {
          "line": 392,
          "old_api": null,
          "new_api": "evhttp_bound_socket_get_fd",
          "old_text": null,
          "new_text": "evhttp_bound_socket_get_fd(bind_handle)",
          "old_line_content": "        } else {",
          "new_line_content": "            evutil_socket_t fd = evhttp_bound_socket_get_fd(bind_handle);",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": null,
          "new_api": "setsockopt",
          "old_text": null,
          "new_text": "setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (sockopt_arg_type)&one, sizeof(one))",
          "old_line_content": "        }",
          "new_line_content": "            if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (sockopt_arg_type)&one, sizeof(one)) == SOCKET_ERROR) {",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": null,
          "new_api": "LogInfo",
          "old_text": null,
          "new_text": "LogInfo(\"WARNING: Unable to set TCP_NODELAY on RPC server socket, continuing anyway\\n\")",
          "old_line_content": "    }",
          "new_line_content": "                LogInfo(\"WARNING: Unable to set TCP_NODELAY on RPC server socket, continuing anyway\\n\");",
          "content_same": false
        },
        {
          "line": 397,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "boundSockets.push_back(bind_handle)",
          "old_line_content": "}",
          "new_line_content": "            boundSockets.push_back(bind_handle);",
          "content_same": false
        },
        {
          "line": 399,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"Binding RPC on address %s port %i failed.\\n\", i->first, i->second)",
          "old_line_content": "/** Simple wrapper to set thread name and run work queue */",
          "new_line_content": "            LogPrintf(\"Binding RPC on address %s port %i failed.\\n\", i->first, i->second);",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": null,
          "new_api": "strprintf",
          "old_text": null,
          "new_text": "strprintf(\"httpworker.%i\", worker_num)",
          "old_line_content": "{",
          "new_line_content": "    util::ThreadRename(strprintf(\"httpworker.%i\", worker_num));",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": null,
          "new_api": "Run",
          "old_text": null,
          "new_text": "queue->Run()",
          "old_line_content": "    BCLog::Level level;",
          "new_line_content": "    queue->Run();",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": null,
          "new_api": "LogPrintLevel",
          "old_text": null,
          "new_text": "LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg)",
          "old_line_content": "        return false;",
          "new_line_content": "    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);",
          "content_same": false
        },
        {
          "line": 439,
          "old_api": null,
          "new_api": "event_set_log_callback",
          "old_text": null,
          "new_text": "event_set_log_callback(&libevent_log_cb)",
          "old_line_content": "#else",
          "new_line_content": "    event_set_log_callback(&libevent_log_cb);",
          "content_same": false
        },
        {
          "line": 441,
          "old_api": null,
          "new_api": "WillLogCategory",
          "old_text": null,
          "new_text": "LogInstance().WillLogCategory(BCLog::LIBEVENT)",
          "old_line_content": "#endif",
          "new_line_content": "    UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT));",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": null,
          "new_api": "evthread_use_windows_threads",
          "old_text": null,
          "new_text": "evthread_use_windows_threads()",
          "old_line_content": "",
          "new_line_content": "    evthread_use_windows_threads();",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "base_ctr.get()",
          "old_line_content": "",
          "new_line_content": "    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());",
          "content_same": false
        },
        {
          "line": 460,
          "old_api": null,
          "new_api": "evhttp_set_max_headers_size",
          "old_text": null,
          "new_text": "evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE)",
          "old_line_content": "        return false;",
          "new_line_content": "    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);",
          "content_same": false
        },
        {
          "line": 461,
          "old_api": null,
          "new_api": "evhttp_set_max_body_size",
          "old_text": null,
          "new_text": "evhttp_set_max_body_size(http, MAX_SIZE)",
          "old_line_content": "    }",
          "new_line_content": "    evhttp_set_max_body_size(http, MAX_SIZE);",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": null,
          "new_api": "evhttp_set_gencb",
          "old_text": null,
          "new_text": "evhttp_set_gencb(http, http_request_cb, (void*)&interrupt)",
          "old_line_content": "",
          "new_line_content": "    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": null,
          "new_api": "LogDebug",
          "old_text": null,
          "new_text": "LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth)",
          "old_line_content": "    return true;",
          "new_line_content": "    LogDebug(BCLog::HTTP, \"creating work queue of depth %d\\n\", workQueueDepth);",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": null,
          "new_api": "std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth)",
          "old_text": null,
          "new_text": "std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth)",
          "old_line_content": "",
          "new_line_content": "    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": null,
          "new_api": "release",
          "old_text": null,
          "new_text": "base_ctr.release()",
          "old_line_content": "    if (enable) {",
          "new_line_content": "    eventBase = base_ctr.release();",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": null,
          "new_api": "event_enable_debug_logging",
          "old_text": null,
          "new_text": "event_enable_debug_logging(EVENT_DBG_ALL)",
          "old_line_content": "static std::thread g_thread_http;",
          "new_line_content": "        event_enable_debug_logging(EVENT_DBG_ALL);",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": null,
          "new_api": "event_enable_debug_logging",
          "old_text": null,
          "new_text": "event_enable_debug_logging(EVENT_DBG_NONE)",
          "old_line_content": "",
          "new_line_content": "        event_enable_debug_logging(EVENT_DBG_NONE);",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": null,
          "new_api": "GetIntArg",
          "old_text": null,
          "new_text": "gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS)",
          "old_line_content": "    }",
          "new_line_content": "    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": null,
          "new_api": "LogInfo",
          "old_text": null,
          "new_text": "LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads)",
          "old_line_content": "}",
          "new_line_content": "    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);",
          "content_same": false
        },
        {
          "line": 495,
          "old_api": null,
          "new_api": "std::thread(ThreadHTTP, eventBase)",
          "old_text": null,
          "new_text": "std::thread(ThreadHTTP, eventBase)",
          "old_line_content": "",
          "new_line_content": "    g_thread_http = std::thread(ThreadHTTP, eventBase);",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": null,
          "new_api": "evhttp_set_gencb",
          "old_text": null,
          "new_text": "evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr)",
          "old_line_content": "",
          "new_line_content": "        evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 512,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\")",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 514,
          "old_api": "join",
          "new_api": null,
          "old_text": "thread.join()",
          "new_text": null,
          "old_line_content": "            thread.join();",
          "new_line_content": "void StopHTTPServer()",
          "content_same": false
        },
        {
          "line": 521,
          "old_api": "evhttp_del_accept_socket",
          "new_api": null,
          "old_text": "evhttp_del_accept_socket(eventHTTP, socket)",
          "new_text": null,
          "old_line_content": "        evhttp_del_accept_socket(eventHTTP, socket);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 523,
          "old_api": "clear",
          "new_api": null,
          "old_text": "boundSockets.clear()",
          "new_text": null,
          "old_line_content": "    boundSockets.clear();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 525,
          "old_api": "CountActiveConnections",
          "new_api": null,
          "old_text": "g_requests.CountActiveConnections()",
          "new_text": null,
          "old_line_content": "        if (const auto n_connections{g_requests.CountActiveConnections()}; n_connections != 0) {",
          "new_line_content": "    // that after this and all connections are closed the event loop will quit.",
          "content_same": false
        },
        {
          "line": 526,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::HTTP, \"Waiting for %d connections to stop HTTP server\\n\", n_connections)",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::HTTP, \"Waiting for %d connections to stop HTTP server\\n\", n_connections);",
          "new_line_content": "    for (evhttp_bound_socket *socket : boundSockets) {",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": "WaitUntilEmpty",
          "new_api": null,
          "old_text": "g_requests.WaitUntilEmpty()",
          "new_text": null,
          "old_line_content": "        g_requests.WaitUntilEmpty();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 535,
          "old_api": "evhttp_free",
          "new_api": null,
          "old_text": "evhttp_free(eventHTTP)",
          "new_text": null,
          "old_line_content": "            evhttp_free(eventHTTP);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 542,
          "old_api": "event_base_free",
          "new_api": null,
          "old_text": "event_base_free(eventBase)",
          "new_text": null,
          "old_line_content": "        event_base_free(eventBase);",
          "new_line_content": "            eventHTTP = nullptr;",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": "reset",
          "new_api": null,
          "old_text": "g_work_queue.reset()",
          "new_text": null,
          "old_line_content": "    g_work_queue.reset();",
          "new_line_content": "    if (eventBase) {",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": "static_cast<HTTPEvent*>(data)",
          "new_api": null,
          "old_text": "static_cast<HTTPEvent*>(data)",
          "new_text": null,
          "old_line_content": "    HTTPEvent *self = static_cast<HTTPEvent*>(data);",
          "new_line_content": "    return eventBase;",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": "handler",
          "new_api": null,
          "old_text": "self->handler()",
          "new_text": null,
          "old_line_content": "    self->handler();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": "event_new",
          "new_api": null,
          "old_text": "event_new(base, -1, 0, httpevent_callback_fn, this)",
          "new_text": null,
          "old_line_content": "    ev = event_new(base, -1, 0, httpevent_callback_fn, this);",
          "new_line_content": "        delete self;",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(ev)",
          "new_text": null,
          "old_line_content": "    assert(ev);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": "event_free",
          "new_api": null,
          "old_text": "event_free(ev)",
          "new_text": null,
          "old_line_content": "    event_free(ev);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": "event_active",
          "new_api": null,
          "old_text": "event_active(ev, 0, 0)",
          "new_text": null,
          "old_line_content": "        event_active(ev, 0, 0); // immediately trigger event in main thread",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": "evtimer_add",
          "new_api": null,
          "old_text": "evtimer_add(ev, tv)",
          "new_text": null,
          "old_line_content": "        evtimer_add(ev, tv); // trigger after timeval passed",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"%s: Unhandled request\\n\", __func__)",
          "new_text": null,
          "old_line_content": "        LogPrintf(\"%s: Unhandled request\\n\", __func__);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": "WriteReply",
          "new_api": null,
          "old_text": "WriteReply(HTTP_INTERNAL_SERVER_ERROR, \"Unhandled request\")",
          "new_text": null,
          "old_line_content": "        WriteReply(HTTP_INTERNAL_SERVER_ERROR, \"Unhandled request\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 597,
          "old_api": "evhttp_request_get_input_headers",
          "new_api": null,
          "old_text": "evhttp_request_get_input_headers(req)",
          "new_text": null,
          "old_line_content": "    const struct evkeyvalq* headers = evhttp_request_get_input_headers(req);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(headers)",
          "new_text": null,
          "old_line_content": "    assert(headers);",
          "new_line_content": "    // evhttpd cleans up the request, as long as a reply was sent.",
          "content_same": false
        },
        {
          "line": 599,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "hdr.c_str()",
          "new_text": null,
          "old_line_content": "    const char* val = evhttp_find_header(headers, hdr.c_str());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": "std::make_pair(true, val)",
          "new_api": null,
          "old_text": "std::make_pair(true, val)",
          "new_text": null,
          "old_line_content": "        return std::make_pair(true, val);",
          "new_line_content": "std::pair<bool, std::string> HTTPRequest::GetHeader(const std::string& hdr) const",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": "evhttp_request_get_input_buffer",
          "new_api": null,
          "old_text": "evhttp_request_get_input_buffer(req)",
          "new_text": null,
          "old_line_content": "    struct evbuffer* buf = evhttp_request_get_input_buffer(req);",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": "evbuffer_get_length",
          "new_api": null,
          "old_text": "evbuffer_get_length(buf)",
          "new_text": null,
          "old_line_content": "    size_t size = evbuffer_get_length(buf);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": "evbuffer_pullup",
          "new_api": null,
          "old_text": "evbuffer_pullup(buf, size)",
          "new_text": null,
          "old_line_content": "    const char* data = (const char*)evbuffer_pullup(buf, size);",
          "new_line_content": "    /** Trivial implementation: if this is ever a performance bottleneck,",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": "evbuffer_drain",
          "new_api": null,
          "old_text": "evbuffer_drain(buf, size)",
          "new_text": null,
          "old_line_content": "    evbuffer_drain(buf, size);",
          "new_line_content": "     * abstraction to consume the evbuffer on the fly in the parsing algorithm.",
          "content_same": false
        },
        {
          "line": 629,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(headers)",
          "new_text": null,
          "old_line_content": "    assert(headers);",
          "new_line_content": "    return rv;",
          "content_same": false
        },
        {
          "line": 630,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "value.c_str()",
          "new_text": null,
          "old_line_content": "    evhttp_add_header(headers, hdr.c_str(), value.c_str());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 640,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(!replySent && req)",
          "new_text": null,
          "old_line_content": "    assert(!replySent && req);",
          "new_line_content": " * a HTTP request.",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": "WriteHeader",
          "new_api": null,
          "old_text": "WriteHeader(\"Connection\", \"close\")",
          "new_text": null,
          "old_line_content": "        WriteHeader(\"Connection\", \"close\");",
          "new_line_content": " * this cannot be done from worker threads.",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": "evhttp_request_get_output_buffer",
          "new_api": null,
          "old_text": "evhttp_request_get_output_buffer(req)",
          "new_text": null,
          "old_line_content": "    struct evbuffer* evb = evhttp_request_get_output_buffer(req);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": "size",
          "new_api": null,
          "old_text": "reply.size()",
          "new_text": null,
          "old_line_content": "    evbuffer_add(evb, reply.data(), reply.size());",
          "new_line_content": "    if (m_interrupt) {",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": "evhttp_send_reply",
          "new_api": null,
          "old_text": "evhttp_send_reply(req_copy, nStatus, nullptr, nullptr)",
          "new_text": null,
          "old_line_content": "        evhttp_send_reply(req_copy, nStatus, nullptr, nullptr);",
          "new_line_content": "    // Send event to main http thread to send reply message",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": "evhttp_request_get_connection",
          "new_api": null,
          "old_text": "evhttp_request_get_connection(req_copy)",
          "new_text": null,
          "old_line_content": "            evhttp_connection* conn = evhttp_request_get_connection(req_copy);",
          "new_line_content": "    auto req_copy = req;",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": "bufferevent_enable",
          "new_api": null,
          "old_text": "bufferevent_enable(bev, EV_READ | EV_WRITE)",
          "new_text": null,
          "old_line_content": "                    bufferevent_enable(bev, EV_READ | EV_WRITE);",
          "new_line_content": "        // workaround above.",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": "trigger",
          "new_api": null,
          "old_text": "ev->trigger(nullptr)",
          "new_text": null,
          "old_line_content": "    ev->trigger(nullptr);",
          "new_line_content": "                if (bev) {",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": "evhttp_request_get_connection",
          "new_api": null,
          "old_text": "evhttp_request_get_connection(req)",
          "new_text": null,
          "old_line_content": "    evhttp_connection* con = evhttp_request_get_connection(req);",
          "new_line_content": "    replySent = true;",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": "evhttp_connection_get_peer",
          "new_api": null,
          "old_text": "evhttp_connection_get_peer(con, &address, &port)",
          "new_text": null,
          "old_line_content": "        evhttp_connection_get_peer(con, &address, &port);",
          "new_line_content": "    if (con) {",
          "content_same": false
        },
        {
          "line": 680,
          "old_api": "evhttp_connection_get_peer",
          "new_api": null,
          "old_text": "evhttp_connection_get_peer(con, (char**)&address, &port)",
          "new_text": null,
          "old_line_content": "        evhttp_connection_get_peer(con, (char**)&address, &port);",
          "new_line_content": "        const char* address = \"\";",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": "LookupNumeric",
          "new_api": null,
          "old_text": "LookupNumeric(address, port)",
          "new_text": null,
          "old_line_content": "        peer = MaybeFlipIPv6toCJDNS(LookupNumeric(address, port));",
          "new_line_content": "#ifdef HAVE_EVHTTP_CONNECTION_GET_PEER_CONST_CHAR",
          "content_same": false
        },
        {
          "line": 690,
          "old_api": "evhttp_request_get_uri",
          "new_api": null,
          "old_text": "evhttp_request_get_uri(req)",
          "new_text": null,
          "old_line_content": "    return evhttp_request_get_uri(req);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 695,
          "old_api": "evhttp_request_get_command",
          "new_api": null,
          "old_text": "evhttp_request_get_command(req)",
          "new_text": null,
          "old_line_content": "    switch (evhttp_request_get_command(req)) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": "evhttp_request_get_uri",
          "new_api": null,
          "old_text": "evhttp_request_get_uri(req)",
          "new_text": null,
          "old_line_content": "    const char* uri{evhttp_request_get_uri(req)};",
          "new_line_content": "        return UNKNOWN;",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": "GetQueryParameterFromUri",
          "new_api": null,
          "old_text": "GetQueryParameterFromUri(uri, key)",
          "new_text": null,
          "old_line_content": "    return GetQueryParameterFromUri(uri, key);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": "evhttp_uri_parse",
          "new_api": null,
          "old_text": "evhttp_uri_parse(uri)",
          "new_text": null,
          "old_line_content": "    evhttp_uri* uri_parsed{evhttp_uri_parse(uri)};",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": "std::runtime_error(\"URI parsing failed, it likely contained RFC 3986 invalid characters\")",
          "new_api": null,
          "old_text": "std::runtime_error(\"URI parsing failed, it likely contained RFC 3986 invalid characters\")",
          "new_text": null,
          "old_line_content": "        throw std::runtime_error(\"URI parsing failed, it likely contained RFC 3986 invalid characters\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": "evhttp_uri_get_query",
          "new_api": null,
          "old_text": "evhttp_uri_get_query(uri_parsed)",
          "new_text": null,
          "old_line_content": "    const char* query{evhttp_uri_get_query(uri_parsed)};",
          "new_line_content": "std::optional<std::string> GetQueryParameterFromUri(const char* uri, const std::string& key)",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": "evhttp_clear_headers",
          "new_api": null,
          "old_text": "evhttp_clear_headers(&params_q)",
          "new_text": null,
          "old_line_content": "        evhttp_clear_headers(&params_q);",
          "new_line_content": "        for (struct evkeyval* param{params_q.tqh_first}; param != nullptr; param = param->next.tqe_next) {",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": "evhttp_uri_free",
          "new_api": null,
          "old_text": "evhttp_uri_free(uri_parsed)",
          "new_text": null,
          "old_line_content": "    evhttp_uri_free(uri_parsed);",
          "new_line_content": "                result = param->value;",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch)",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(g_httppathhandlers_mutex)",
          "new_text": null,
          "old_line_content": "    LOCK(g_httppathhandlers_mutex);",
          "new_line_content": "    return result;",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "pathHandlers.emplace_back(prefix, exactMatch, handler)",
          "new_text": null,
          "old_line_content": "    pathHandlers.emplace_back(prefix, exactMatch, handler);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": "end",
          "new_api": null,
          "old_text": "pathHandlers.end()",
          "new_text": null,
          "old_line_content": "    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": "erase",
          "new_api": null,
          "old_text": "pathHandlers.erase(i)",
          "new_text": null,
          "old_line_content": "        pathHandlers.erase(i);",
          "new_line_content": "    for (; i != iend; ++i)",
          "content_same": false
        },
        {
          "line": 391,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "boundSockets.push_back(bind_handle)",
          "new_text": null,
          "old_line_content": "            boundSockets.push_back(bind_handle);",
          "new_line_content": "            // Set the no-delay option (disable Nagle's algorithm) on the TCP socket.",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"Binding RPC on address %s port %i failed.\\n\", i->first, i->second)",
          "new_text": null,
          "old_line_content": "            LogPrintf(\"Binding RPC on address %s port %i failed.\\n\", i->first, i->second);",
          "new_line_content": "            int one = 1;",
          "content_same": false
        },
        {
          "line": 396,
          "old_api": "empty",
          "new_api": null,
          "old_text": "boundSockets.empty()",
          "new_text": null,
          "old_line_content": "    return !boundSockets.empty();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": "Run",
          "new_api": null,
          "old_text": "queue->Run()",
          "new_text": null,
          "old_line_content": "    queue->Run();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": "LogPrintLevel",
          "new_api": null,
          "old_text": "LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg)",
          "new_text": null,
          "old_line_content": "    LogPrintLevel(BCLog::LIBEVENT, level, \"%s\\n\", msg);",
          "new_line_content": "        level = BCLog::Level::Warning;",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": "InitHTTPAllowList",
          "new_api": null,
          "old_text": "InitHTTPAllowList()",
          "new_text": null,
          "old_line_content": "    if (!InitHTTPAllowList())",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": "event_set_log_callback",
          "new_api": null,
          "old_text": "event_set_log_callback(&libevent_log_cb)",
          "new_text": null,
          "old_line_content": "    event_set_log_callback(&libevent_log_cb);",
          "new_line_content": "bool InitHTTPServer(const util::SignalInterrupt& interrupt)",
          "content_same": false
        },
        {
          "line": 438,
          "old_api": "evthread_use_windows_threads",
          "new_api": null,
          "old_text": "evthread_use_windows_threads()",
          "new_text": null,
          "old_line_content": "    evthread_use_windows_threads();",
          "new_line_content": "    // Redirect libevent's logging to our own log",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": "evthread_use_pthreads",
          "new_api": null,
          "old_text": "evthread_use_pthreads()",
          "new_text": null,
          "old_line_content": "    evthread_use_pthreads();",
          "new_line_content": "    // Update libevent's log handling.",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": "obtain_event_base",
          "new_api": null,
          "old_text": "obtain_event_base()",
          "new_text": null,
          "old_line_content": "    raii_event_base base_ctr = obtain_event_base();",
          "new_line_content": "#ifdef WIN32",
          "content_same": false
        },
        {
          "line": 447,
          "old_api": "get",
          "new_api": null,
          "old_text": "http_ctr.get()",
          "new_text": null,
          "old_line_content": "    struct evhttp* http = http_ctr.get();",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 454,
          "old_api": "evhttp_set_max_headers_size",
          "new_api": null,
          "old_text": "evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE)",
          "new_text": null,
          "old_line_content": "    evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);",
          "new_line_content": "    if (!http) {",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": "evhttp_set_gencb",
          "new_api": null,
          "old_text": "evhttp_set_gencb(http, http_request_cb, (void*)&interrupt)",
          "new_text": null,
          "old_line_content": "    evhttp_set_gencb(http, http_request_cb, (void*)&interrupt);",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": "HTTPBindAddresses",
          "new_api": null,
          "old_text": "HTTPBindAddresses(http)",
          "new_text": null,
          "old_line_content": "    if (!HTTPBindAddresses(http)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 463,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::HTTP, \"Initialized HTTP server\\n\")",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::HTTP, \"Initialized HTTP server\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": "std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth)",
          "new_api": null,
          "old_text": "std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth)",
          "new_text": null,
          "old_line_content": "    g_work_queue = std::make_unique<WorkQueue<HTTPClosure>>(workQueueDepth);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 478,
          "old_api": "event_enable_debug_logging",
          "new_api": null,
          "old_text": "event_enable_debug_logging(EVENT_DBG_NONE)",
          "new_text": null,
          "old_line_content": "        event_enable_debug_logging(EVENT_DBG_NONE);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": "GetIntArg",
          "new_api": null,
          "old_text": "gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS)",
          "new_text": null,
          "old_line_content": "    int rpcThreads = std::max((long)gArgs.GetIntArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": "LogInfo",
          "new_api": null,
          "old_text": "LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads)",
          "new_text": null,
          "old_line_content": "    LogInfo(\"Starting HTTP server with %d worker threads\\n\", rpcThreads);",
          "new_line_content": "static std::thread g_thread_http;",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": "std::thread(ThreadHTTP, eventBase)",
          "new_api": null,
          "old_text": "std::thread(ThreadHTTP, eventBase)",
          "new_text": null,
          "old_line_content": "    g_thread_http = std::thread(ThreadHTTP, eventBase);",
          "new_line_content": "static std::vector<std::thread> g_thread_http_workers;",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": "get",
          "new_api": null,
          "old_text": "g_work_queue.get()",
          "new_text": null,
          "old_line_content": "        g_thread_http_workers.emplace_back(HTTPWorkQueueRun, g_work_queue.get(), i);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": "evhttp_set_gencb",
          "new_api": null,
          "old_text": "evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr)",
          "new_text": null,
          "old_line_content": "        evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 26,
      "total_additions": 80,
      "total_deletions": 77,
      "total_api_changes": 183
    },
    "non_api_changes": {
      "has_non_api_changes": false,
      "evidence": {
        "total_diff_lines": 6,
        "api_related_lines": 183,
        "non_api_lines": 0,
        "non_api_line_numbers": []
      }
    },
    "api_calls_before": 264,
    "api_calls_after": 267,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 0,
      "total_diff_lines": 18
    }
  }
}