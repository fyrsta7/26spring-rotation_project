{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/e66630cc87c017f40ec29f6c1edf2ed5a286e49d",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/e66630cc87c017f40ec29f6c1edf2ed5a286e49d/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/e66630cc87c017f40ec29f6c1edf2ed5a286e49d/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/e66630cc87c017f40ec29f6c1edf2ed5a286e49d/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 121,
          "old_api": "pop_back",
          "new_api": "back",
          "old_text": "urr_selection.pop_back();",
          "new_text": "urr_selection.back();",
          "old_line_content": "                curr_selection.pop_back();",
          "new_line_content": "            for (--utxo_pool_index; utxo_pool_index > curr_selection.back(); --utxo_pool_index) {",
          "content_same": false
        },
        {
          "line": 122,
          "old_api": "size",
          "new_api": "at",
          "old_text": "urr_selection.size())",
          "new_text": "txo_pool.at(utxo_pool_index).GetSelectionAmount();",
          "old_line_content": "                curr_available_value += utxo_pool.at(curr_selection.size()).GetSelectionAmount();",
          "new_line_content": "                curr_available_value += utxo_pool.at(utxo_pool_index).GetSelectionAmount();",
          "content_same": false
        },
        {
          "line": 130,
          "old_api": "back",
          "new_api": "pop_back",
          "old_text": "urr_selection.back() ",
          "new_text": "urr_selection.pop_back();",
          "old_line_content": "            curr_selection.back() = false;",
          "new_line_content": "            curr_selection.pop_back();",
          "content_same": false
        },
        {
          "line": 132,
          "old_api": "GetSelectionAmount",
          "new_api": "at",
          "old_text": "txo.GetSelectionAmount();",
          "new_text": "txo_pool.at(utxo_pool_index);",
          "old_line_content": "            curr_value -= utxo.GetSelectionAmount();",
          "new_line_content": "            OutputGroup& utxo = utxo_pool.at(utxo_pool_index);",
          "content_same": false
        },
        {
          "line": 135,
          "old_api": "size",
          "new_api": "GetSelectionAmount",
          "old_text": "urr_selection.size())",
          "new_text": "txo.GetSelectionAmount();",
          "old_line_content": "            OutputGroup& utxo = utxo_pool.at(curr_selection.size());",
          "new_line_content": "            curr_available_value -= utxo.GetSelectionAmount();",
          "content_same": false
        },
        {
          "line": 142,
          "old_api": "back",
          "new_api": "at",
          "old_text": "urr_selection.back() ",
          "new_text": "txo_pool.at(utxo_pool_index - 1).GetSelectionAmount() ",
          "old_line_content": "            if (!curr_selection.empty() && !curr_selection.back() &&",
          "new_line_content": "                utxo.GetSelectionAmount() != utxo_pool.at(utxo_pool_index - 1).GetSelectionAmount() ||",
          "content_same": false
        },
        {
          "line": 143,
          "old_api": "size",
          "new_api": "at",
          "old_text": "urr_selection.size() ",
          "new_text": "txo_pool.at(utxo_pool_index - 1).",
          "old_line_content": "                utxo.GetSelectionAmount() == utxo_pool.at(curr_selection.size() - 1).GetSelectionAmount() &&",
          "new_line_content": "                utxo.fee != utxo_pool.at(utxo_pool_index - 1).fee)",
          "content_same": false
        },
        {
          "line": 162,
          "old_api": "at",
          "new_api": "ComputeAndSetWaste",
          "old_text": "est_selection.at(i))",
          "new_text": "esult.ComputeAndSetWaste(CAmount{0});",
          "old_line_content": "        if (best_selection.at(i)) {",
          "new_line_content": "    result.ComputeAndSetWaste(CAmount{0});",
          "content_same": false
        },
        {
          "line": 163,
          "old_api": "at",
          "new_api": "GetWaste",
          "old_text": "txo_pool.at(i))",
          "new_text": "esult.GetWaste())",
          "old_line_content": "            result.AddInput(utxo_pool.at(i));",
          "new_line_content": "    assert(best_waste == result.GetWaste());",
          "content_same": false
        },
        {
          "line": 179,
          "old_api": "astRandomContext",
          "new_api": "at",
          "old_text": "astRandomContext())",
          "new_text": "txo_pool.at(i);",
          "old_line_content": "    Shuffle(indexes.begin(), indexes.end(), FastRandomContext());",
          "new_line_content": "        const OutputGroup& group = utxo_pool.at(i);",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": "astRandomContext",
          "new_api": "AddInput",
          "old_text": "astRandomContext())",
          "new_text": "esult.AddInput(group);",
          "old_line_content": "    Shuffle(groups.begin(), groups.end(), FastRandomContext());",
          "new_line_content": "            result.AddInput(group);",
          "content_same": false
        },
        {
          "line": 252,
          "old_api": "GetSelectionAmount",
          "new_api": "push_back",
          "old_text": "roup.GetSelectionAmount() ",
          "new_text": "pplicable_groups.push_back(group);",
          "old_line_content": "        if (group.GetSelectionAmount() == nTargetValue) {",
          "new_line_content": "            applicable_groups.push_back(group);",
          "content_same": false
        },
        {
          "line": 253,
          "old_api": "AddInput",
          "new_api": "GetSelectionAmount",
          "old_text": "esult.AddInput(group);",
          "new_text": "roup.GetSelectionAmount();",
          "old_line_content": "            result.AddInput(group);",
          "new_line_content": "            nTotalLower += group.GetSelectionAmount();",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": "end",
          "new_api": "pproximateBestSubset",
          "old_text": "pplicable_groups.end(),",
          "new_text": "pproximateBestSubset(applicable_groups, nTotalLower, nTargetValue, vfBest, nBest);",
          "old_line_content": "    std::sort(applicable_groups.begin(), applicable_groups.end(), descending);",
          "new_line_content": "    ApproximateBestSubset(applicable_groups, nTotalLower, nTargetValue, vfBest, nBest);",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": "AddInput",
          "new_api": "ogAcceptCategory",
          "old_text": "esult.AddInput(applicable_groups[i]);",
          "new_text": "ogAcceptCategory(BCLog::SELECTCOINS))",
          "old_line_content": "                result.AddInput(applicable_groups[i]);",
          "new_line_content": "        if (LogAcceptCategory(BCLog::SELECTCOINS)) {",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": "ogAcceptCategory",
          "new_api": "ormatMoney",
          "old_text": "ogAcceptCategory(BCLog::SELECTCOINS))",
          "new_text": "ormatMoney(applicable_groups[i].m_value))",
          "old_line_content": "        if (LogAcceptCategory(BCLog::SELECTCOINS)) {",
          "new_line_content": "                    log_message += strprintf(\"%s \", FormatMoney(applicable_groups[i].m_value));",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 128,
          "old_api": null,
          "new_api": "GetSelectionAmount",
          "old_text": null,
          "new_text": "txo.GetSelectionAmount();",
          "old_line_content": "",
          "new_line_content": "            curr_value -= utxo.GetSelectionAmount();",
          "content_same": false
        },
        {
          "line": 387,
          "old_api": null,
          "new_api": "etSelectionWaste",
          "old_text": null,
          "new_text": "etSelectionWaste(m_selected_inputs, change_cost, m_target, m_use_effective);",
          "old_line_content": "}",
          "new_line_content": "    m_waste = GetSelectionWaste(m_selected_inputs, change_cost, m_target, m_use_effective);",
          "content_same": false
        },
        {
          "line": 261,
          "old_api": null,
          "new_api": "AddInput",
          "old_text": null,
          "new_text": "esult.AddInput(group);",
          "old_line_content": "    }",
          "new_line_content": "            result.AddInput(group);",
          "content_same": false
        },
        {
          "line": 392,
          "old_api": null,
          "new_api": "ssert",
          "old_text": null,
          "new_text": "ssert(m_waste);",
          "old_line_content": "}",
          "new_line_content": "    return *Assert(m_waste);",
          "content_same": false
        },
        {
          "line": 137,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "urr_selection.empty() ",
          "old_line_content": "            // Remove this utxo from the curr_available_value utxo amount",
          "new_line_content": "            if (curr_selection.empty() ||",
          "content_same": false
        },
        {
          "line": 139,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "urr_selection.back() ",
          "old_line_content": "",
          "new_line_content": "                (utxo_pool_index - 1) == curr_selection.back() ||",
          "content_same": false
        },
        {
          "line": 268,
          "old_api": null,
          "new_api": "AddInput",
          "old_text": null,
          "new_text": "esult.AddInput(*lowest_larger);",
          "old_line_content": "    }",
          "new_line_content": "        result.AddInput(*lowest_larger);",
          "content_same": false
        },
        {
          "line": 397,
          "old_api": null,
          "new_api": "cend",
          "old_text": null,
          "new_text": "_selected_inputs.cend(),",
          "old_line_content": "}",
          "new_line_content": "    return std::accumulate(m_selected_inputs.cbegin(), m_selected_inputs.cend(), CAmount{0}, [](CAmount sum, const auto& coin) { return sum + coin.txout.nValue; });",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "pplicable_groups.end(),",
          "old_line_content": "        return result;",
          "new_line_content": "    std::sort(applicable_groups.begin(), applicable_groups.end(), descending);",
          "content_same": false
        },
        {
          "line": 146,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "urr_selection.push_back(utxo_pool_index);",
          "old_line_content": "            } else {",
          "new_line_content": "                curr_selection.push_back(utxo_pool_index);",
          "content_same": false
        },
        {
          "line": 147,
          "old_api": null,
          "new_api": "GetSelectionAmount",
          "old_text": null,
          "new_text": "txo.GetSelectionAmount();",
          "old_line_content": "                // Inclusion branch first (Largest First Exploration)",
          "new_line_content": "                curr_value += utxo.GetSelectionAmount();",
          "content_same": false
        },
        {
          "line": 402,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "_selected_inputs.clear();",
          "old_line_content": "}",
          "new_line_content": "    m_selected_inputs.clear();",
          "content_same": false
        },
        {
          "line": 403,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "_waste.reset();",
          "old_line_content": "",
          "new_line_content": "    m_waste.reset();",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": null,
          "new_api": "pproximateBestSubset",
          "old_text": null,
          "new_text": "pproximateBestSubset(applicable_groups, nTotalLower, nTargetValue + MIN_CHANGE, vfBest, nBest);",
          "old_line_content": "    CAmount nBest;",
          "new_line_content": "        ApproximateBestSubset(applicable_groups, nTotalLower, nTargetValue + MIN_CHANGE, vfBest, nBest);",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": null,
          "new_api": "til::insert(m_selected_inputs, group.m_outputs);",
          "old_text": null,
          "new_text": "til::insert(m_selected_inputs, group.m_outputs);",
          "old_line_content": "}",
          "new_line_content": "    util::insert(m_selected_inputs, group.m_outputs);",
          "content_same": false
        },
        {
          "line": 154,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "est_selection.empty())",
          "old_line_content": "",
          "new_line_content": "    if (best_selection.empty()) {",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": null,
          "new_api": "GetSelectionAmount",
          "old_text": null,
          "new_text": "owest_larger->GetSelectionAmount() ",
          "old_line_content": "",
          "new_line_content": "        ((nBest != nTargetValue && nBest < nTargetValue + MIN_CHANGE) || lowest_larger->GetSelectionAmount() <= nBest)) {",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": null,
          "new_api": "AddInput",
          "old_text": null,
          "new_text": "esult.AddInput(*lowest_larger);",
          "old_line_content": "    // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,",
          "new_line_content": "        result.AddInput(*lowest_larger);",
          "content_same": false
        },
        {
          "line": 160,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "txo_pool.at(i))",
          "old_line_content": "    // Set output set",
          "new_line_content": "        result.AddInput(utxo_pool.at(i));",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "pplicable_groups.size();",
          "old_line_content": "    if (lowest_larger &&",
          "new_line_content": "        for (unsigned int i = 0; i < applicable_groups.size(); i++) {",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "_selected_inputs.end())",
          "old_line_content": "}",
          "new_line_content": "    std::vector<CInputCoin> coins(m_selected_inputs.begin(), m_selected_inputs.end());",
          "content_same": false
        },
        {
          "line": 420,
          "old_api": null,
          "new_api": "astRandomContext",
          "old_text": null,
          "new_text": "astRandomContext())",
          "old_line_content": "",
          "new_line_content": "    Shuffle(coins.begin(), coins.end(), FastRandomContext());",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "pplicable_groups.size();",
          "old_line_content": "        }",
          "new_line_content": "            for (unsigned int i = 0; i < applicable_groups.size(); i++) {",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "_waste.has_value())",
          "old_line_content": "}",
          "new_line_content": "    Assert(m_waste.has_value());",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "ther.m_waste.has_value())",
          "old_line_content": "",
          "new_line_content": "    Assert(other.m_waste.has_value());",
          "content_same": false
        },
        {
          "line": 173,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "txo_pool.size())",
          "old_line_content": "{",
          "new_line_content": "    indexes.resize(utxo_pool.size());",
          "content_same": false
        },
        {
          "line": 174,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "ndexes.end(),",
          "old_line_content": "    SelectionResult result(target_value);",
          "new_line_content": "    std::iota(indexes.begin(), indexes.end(), 0);",
          "content_same": false
        },
        {
          "line": 175,
          "old_api": null,
          "new_api": "astRandomContext",
          "old_text": null,
          "new_text": "astRandomContext())",
          "old_line_content": "",
          "new_line_content": "    Shuffle(indexes.begin(), indexes.end(), FastRandomContext());",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": null,
          "new_api": "ormatMoney",
          "old_text": null,
          "new_text": "ormatMoney(nBest))",
          "old_line_content": "                if (vfBest[i]) {",
          "new_line_content": "            LogPrint(BCLog::SELECTCOINS, \"%stotal %s\\n\", log_message, FormatMoney(nBest));",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "ther.m_selected_inputs.size())",
          "old_line_content": "{",
          "new_line_content": "    return *m_waste < *other.m_waste || (*m_waste == *other.m_waste && m_selected_inputs.size() > other.m_selected_inputs.size());",
          "content_same": false
        },
        {
          "line": 180,
          "old_api": null,
          "new_api": "GetSelectionAmount",
          "old_text": null,
          "new_text": "roup.GetSelectionAmount() ",
          "old_line_content": "",
          "new_line_content": "        Assume(group.GetSelectionAmount() > 0);",
          "content_same": false
        },
        {
          "line": 181,
          "old_api": null,
          "new_api": "GetSelectionAmount",
          "old_text": null,
          "new_text": "roup.GetSelectionAmount();",
          "old_line_content": "    CAmount selected_eff_value = 0;",
          "new_line_content": "        selected_eff_value += group.GetSelectionAmount();",
          "content_same": false
        },
        {
          "line": 182,
          "old_api": null,
          "new_api": "AddInput",
          "old_text": null,
          "new_text": "esult.AddInput(group);",
          "old_line_content": "    for (const size_t i : indexes) {",
          "new_line_content": "        result.AddInput(group);",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": null,
          "new_api": "GetFee",
          "old_text": null,
          "new_text": "_effective_feerate.GetFee(output.m_input_bytes);",
          "old_line_content": " ******************************************************************************/",
          "new_line_content": "    const CAmount coin_fee = output.m_input_bytes < 0 ? 0 : m_effective_feerate.GetFee(output.m_input_bytes);",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "_outputs.push_back(output);",
          "old_line_content": "",
          "new_line_content": "    m_outputs.push_back(output);",
          "content_same": false
        },
        {
          "line": 195,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "roups.size(),",
          "old_line_content": "                                  std::vector<char>& vfBest, CAmount& nBest, int iterations = 1000)",
          "new_line_content": "    vfBest.assign(groups.size(), true);",
          "content_same": false
        },
        {
          "line": 323,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "_outputs.back();",
          "old_line_content": "    // Filter for positive only here before adding the coin",
          "new_line_content": "    CInputCoin& coin = m_outputs.back();",
          "content_same": false
        },
        {
          "line": 328,
          "old_api": null,
          "new_api": "GetFee",
          "old_text": null,
          "new_text": "_long_term_feerate.GetFee(coin.m_input_bytes);",
          "old_line_content": "",
          "new_line_content": "    coin.m_long_term_fee = coin.m_input_bytes < 0 ? 0 : m_long_term_feerate.GetFee(coin.m_input_bytes);",
          "content_same": false
        },
        {
          "line": 202,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "roups.size(),",
          "old_line_content": "    FastRandomContext insecure_rand;",
          "new_line_content": "        vfIncluded.assign(groups.size(), false);",
          "content_same": false
        },
        {
          "line": 76,
          "old_api": null,
          "new_api": "GetSelectionAmount",
          "old_text": null,
          "new_text": "txo.GetSelectionAmount() ",
          "old_line_content": "        // Assert that this utxo is not negative. It should never be negative, effective value calculation should have removed it",
          "new_line_content": "        assert(utxo.GetSelectionAmount() > 0);",
          "content_same": false
        },
        {
          "line": 207,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "roups.size();",
          "old_line_content": "        CAmount nTotal = 0;",
          "new_line_content": "            for (unsigned int i = 0; i < groups.size(); i++)",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": null,
          "new_api": "td::min(m_depth, depth);",
          "old_text": null,
          "new_text": "td::min(m_depth, depth);",
          "old_line_content": "    effective_value += coin.effective_value;",
          "new_line_content": "    m_depth = std::min(m_depth, depth);",
          "content_same": false
        },
        {
          "line": 84,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "txo_pool.end(),",
          "old_line_content": "    // Sort the utxo_pool",
          "new_line_content": "    std::sort(utxo_pool.begin(), utxo_pool.end(), descending);",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": null,
          "new_api": "randbool",
          "old_text": null,
          "new_text": "nsecure_rand.randbool() ",
          "old_line_content": "                //needed to prevent degenerate behavior and it is important",
          "new_line_content": "                if (nPass == 0 ? insecure_rand.randbool() : !vfIncluded[i])",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": null,
          "new_api": "td::max(m_descendants, descendants);",
          "old_text": null,
          "new_text": "td::max(m_descendants, descendants);",
          "old_line_content": "    // have common ancestors",
          "new_line_content": "    m_descendants = std::max(m_descendants, descendants);",
          "content_same": false
        },
        {
          "line": 217,
          "old_api": null,
          "new_api": "GetSelectionAmount",
          "old_text": null,
          "new_text": "roups[i].GetSelectionAmount();",
          "old_line_content": "                //because there may be some privacy improvement by making",
          "new_line_content": "                    nTotal += groups[i].GetSelectionAmount();",
          "content_same": false
        },
        {
          "line": 96,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "txo_pool.at(0).",
          "old_line_content": "            curr_value > selection_target + cost_of_change ||    // Selected value is out of range, go back and try other branch",
          "new_line_content": "            (curr_waste > best_waste && (utxo_pool.at(0).fee - utxo_pool.at(0).long_term_fee) > 0)) { // Don't select things which we know will be more wasteful if the waste is increasing",
          "content_same": false
        },
        {
          "line": 227,
          "old_api": null,
          "new_api": "GetSelectionAmount",
          "old_text": null,
          "new_text": "roups[i].GetSelectionAmount();",
          "old_line_content": "                        {",
          "new_line_content": "                        nTotal -= groups[i].GetSelectionAmount();",
          "content_same": false
        },
        {
          "line": 361,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "nputs.empty())",
          "old_line_content": "",
          "new_line_content": "    assert(!inputs.empty());",
          "content_same": false
        },
        {
          "line": 116,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "urr_selection.empty())",
          "old_line_content": "",
          "new_line_content": "            if (curr_selection.empty()) { // We have walked back to the first utxo and no branch is untraversed. All solutions searched",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": null,
          "new_api": "astRandomContext",
          "old_text": null,
          "new_text": "astRandomContext())",
          "old_line_content": "    std::optional<OutputGroup> lowest_larger;",
          "new_line_content": "    Shuffle(groups.begin(), groups.end(), FastRandomContext());",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": null,
          "new_api": "ssert",
          "old_text": null,
          "new_text": "ssert(change_cost > 0);",
          "old_line_content": "",
          "new_line_content": "        assert(change_cost > 0);",
          "content_same": false
        },
        {
          "line": 254,
          "old_api": null,
          "new_api": "GetSelectionAmount",
          "old_text": null,
          "new_text": "owest_larger->GetSelectionAmount())",
          "old_line_content": "            return result;",
          "new_line_content": "        } else if (!lowest_larger || group.GetSelectionAmount() < lowest_larger->GetSelectionAmount()) {",
          "content_same": false
        },
        {
          "line": 248,
          "old_api": null,
          "new_api": "GetSelectionAmount",
          "old_text": null,
          "new_text": "roup.GetSelectionAmount() ",
          "old_line_content": "",
          "new_line_content": "        if (group.GetSelectionAmount() == nTargetValue) {",
          "content_same": false
        },
        {
          "line": 251,
          "old_api": null,
          "new_api": "GetSelectionAmount",
          "old_text": null,
          "new_text": "roup.GetSelectionAmount() ",
          "old_line_content": "    for (const OutputGroup& group : groups) {",
          "new_line_content": "        } else if (group.GetSelectionAmount() < nTargetValue + MIN_CHANGE) {",
          "content_same": false
        },
        {
          "line": 126,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "urr_selection.back())",
          "old_line_content": "                break;",
          "new_line_content": "            assert(utxo_pool_index == curr_selection.back());",
          "content_same": false
        },
        {
          "line": 127,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "txo_pool.at(utxo_pool_index);",
          "old_line_content": "            }",
          "new_line_content": "            OutputGroup& utxo = utxo_pool.at(utxo_pool_index);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 256,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "pplicable_groups.push_back(group);",
          "new_text": null,
          "old_line_content": "            applicable_groups.push_back(group);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 257,
          "old_api": "GetSelectionAmount",
          "new_api": null,
          "old_text": "roup.GetSelectionAmount();",
          "new_text": null,
          "old_line_content": "            nTotalLower += group.GetSelectionAmount();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 258,
          "old_api": "GetSelectionAmount",
          "new_api": null,
          "old_text": "owest_larger->GetSelectionAmount())",
          "new_text": null,
          "old_line_content": "        } else if (!lowest_larger || group.GetSelectionAmount() < lowest_larger->GetSelectionAmount()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 131,
          "old_api": "size",
          "new_api": null,
          "old_text": "urr_selection.size() ",
          "new_text": null,
          "old_line_content": "            OutputGroup& utxo = utxo_pool.at(curr_selection.size() - 1);",
          "new_line_content": "        } else { // Moving forwards, continuing down this branch",
          "content_same": false
        },
        {
          "line": 391,
          "old_api": "etSelectionWaste",
          "new_api": null,
          "old_text": "etSelectionWaste(m_selected_inputs, change_cost, m_target, m_use_effective);",
          "new_text": null,
          "old_line_content": "    m_waste = GetSelectionWaste(m_selected_inputs, change_cost, m_target, m_use_effective);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": "AddInput",
          "new_api": null,
          "old_text": "esult.AddInput(group);",
          "new_text": null,
          "old_line_content": "            result.AddInput(group);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 138,
          "old_api": "GetSelectionAmount",
          "new_api": null,
          "old_text": "txo.GetSelectionAmount();",
          "new_text": null,
          "old_line_content": "            curr_available_value -= utxo.GetSelectionAmount();",
          "new_line_content": "                // The previous index is included and therefore not relevant for exclusion shortcut",
          "content_same": false
        },
        {
          "line": 396,
          "old_api": "ssert",
          "new_api": null,
          "old_text": "ssert(m_waste);",
          "new_text": null,
          "old_line_content": "    return *Assert(m_waste);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 144,
          "old_api": "size",
          "new_api": null,
          "old_text": "urr_selection.size() ",
          "new_text": null,
          "old_line_content": "                utxo.fee == utxo_pool.at(curr_selection.size() - 1).fee) {",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 145,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "urr_selection.push_back(false);",
          "new_text": null,
          "old_line_content": "                curr_selection.push_back(false);",
          "new_line_content": "                // Inclusion branch first (Largest First Exploration)",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": "AddInput",
          "new_api": null,
          "old_text": "esult.AddInput(*lowest_larger);",
          "new_text": null,
          "old_line_content": "        result.AddInput(*lowest_larger);",
          "new_line_content": "    // Solve subset sum by stochastic approximation",
          "content_same": false
        },
        {
          "line": 401,
          "old_api": "cend",
          "new_api": null,
          "old_text": "_selected_inputs.cend(),",
          "new_text": null,
          "old_line_content": "    return std::accumulate(m_selected_inputs.cbegin(), m_selected_inputs.cend(), CAmount{0}, [](CAmount sum, const auto& coin) { return sum + coin.txout.nValue; });",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 148,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "urr_selection.push_back(true);",
          "new_text": null,
          "old_line_content": "                curr_selection.push_back(true);",
          "new_line_content": "                curr_waste += utxo.fee - utxo.long_term_fee;",
          "content_same": false
        },
        {
          "line": 149,
          "old_api": "GetSelectionAmount",
          "new_api": null,
          "old_text": "txo.GetSelectionAmount();",
          "new_text": null,
          "old_line_content": "                curr_value += utxo.GetSelectionAmount();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 406,
          "old_api": "clear",
          "new_api": null,
          "old_text": "_selected_inputs.clear();",
          "new_text": null,
          "old_line_content": "    m_selected_inputs.clear();",
          "new_line_content": "void SelectionResult::AddInput(const OutputGroup& group)",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": "reset",
          "new_api": null,
          "old_text": "_waste.reset();",
          "new_text": null,
          "old_line_content": "    m_waste.reset();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": "pproximateBestSubset",
          "new_api": null,
          "old_text": "pproximateBestSubset(applicable_groups, nTotalLower, nTargetValue, vfBest, nBest);",
          "new_text": null,
          "old_line_content": "    ApproximateBestSubset(applicable_groups, nTotalLower, nTargetValue, vfBest, nBest);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": "pproximateBestSubset",
          "new_api": null,
          "old_text": "pproximateBestSubset(applicable_groups, nTotalLower, nTargetValue + MIN_CHANGE, vfBest, nBest);",
          "new_text": null,
          "old_line_content": "        ApproximateBestSubset(applicable_groups, nTotalLower, nTargetValue + MIN_CHANGE, vfBest, nBest);",
          "new_line_content": "    //                                   or the next bigger coin is closer), return the bigger coin",
          "content_same": false
        },
        {
          "line": 156,
          "old_api": "empty",
          "new_api": null,
          "old_text": "est_selection.empty())",
          "new_text": null,
          "old_line_content": "    if (best_selection.empty()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 412,
          "old_api": "til::insert(m_selected_inputs, group.m_outputs);",
          "new_api": null,
          "old_text": "til::insert(m_selected_inputs, group.m_outputs);",
          "new_text": null,
          "old_line_content": "    util::insert(m_selected_inputs, group.m_outputs);",
          "new_line_content": "const std::set<CInputCoin>& SelectionResult::GetInputSet() const",
          "content_same": false
        },
        {
          "line": 161,
          "old_api": "size",
          "new_api": null,
          "old_text": "est_selection.size();",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i < best_selection.size(); ++i) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": "GetSelectionAmount",
          "new_api": null,
          "old_text": "owest_larger->GetSelectionAmount() ",
          "new_text": null,
          "old_line_content": "        ((nBest != nTargetValue && nBest < nTargetValue + MIN_CHANGE) || lowest_larger->GetSelectionAmount() <= nBest)) {",
          "new_line_content": "            if (vfBest[i]) {",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": "size",
          "new_api": null,
          "old_text": "pplicable_groups.size();",
          "new_text": null,
          "old_line_content": "        for (unsigned int i = 0; i < applicable_groups.size(); i++) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 166,
          "old_api": "ComputeAndSetWaste",
          "new_api": null,
          "old_text": "esult.ComputeAndSetWaste(CAmount{0});",
          "new_text": null,
          "old_line_content": "    result.ComputeAndSetWaste(CAmount{0});",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 167,
          "old_api": "GetWaste",
          "new_api": null,
          "old_text": "esult.GetWaste())",
          "new_text": null,
          "old_line_content": "    assert(best_waste == result.GetWaste());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": "end",
          "new_api": null,
          "old_text": "_selected_inputs.end())",
          "new_text": null,
          "old_line_content": "    std::vector<CInputCoin> coins(m_selected_inputs.begin(), m_selected_inputs.end());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": "astRandomContext",
          "new_api": null,
          "old_text": "astRandomContext())",
          "new_text": null,
          "old_line_content": "    Shuffle(coins.begin(), coins.end(), FastRandomContext());",
          "new_line_content": "bool SelectionResult::operator<(SelectionResult other) const",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": "size",
          "new_api": null,
          "old_text": "pplicable_groups.size();",
          "new_text": null,
          "old_line_content": "            for (unsigned int i = 0; i < applicable_groups.size(); i++) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 302,
          "old_api": "ormatMoney",
          "new_api": null,
          "old_text": "ormatMoney(applicable_groups[i].m_value))",
          "new_text": null,
          "old_line_content": "                    log_message += strprintf(\"%s \", FormatMoney(applicable_groups[i].m_value));",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "_waste.has_value())",
          "new_text": null,
          "old_line_content": "    Assert(m_waste.has_value());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 431,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "ther.m_waste.has_value())",
          "new_text": null,
          "old_line_content": "    Assert(other.m_waste.has_value());",
          "new_line_content": "} // namespace wallet",
          "content_same": false
        },
        {
          "line": 177,
          "old_api": "size",
          "new_api": null,
          "old_text": "txo_pool.size())",
          "new_text": null,
          "old_line_content": "    indexes.resize(utxo_pool.size());",
          "new_line_content": "    CAmount selected_eff_value = 0;",
          "content_same": false
        },
        {
          "line": 178,
          "old_api": "end",
          "new_api": null,
          "old_text": "ndexes.end(),",
          "new_text": null,
          "old_line_content": "    std::iota(indexes.begin(), indexes.end(), 0);",
          "new_line_content": "    for (const size_t i : indexes) {",
          "content_same": false
        },
        {
          "line": 305,
          "old_api": "ormatMoney",
          "new_api": null,
          "old_text": "ormatMoney(nBest))",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::SELECTCOINS, \"%stotal %s\\n\", log_message, FormatMoney(nBest));",
          "new_line_content": "    return result;",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": "size",
          "new_api": null,
          "old_text": "ther.m_selected_inputs.size())",
          "new_text": null,
          "old_line_content": "    return *m_waste < *other.m_waste || (*m_waste == *other.m_waste && m_selected_inputs.size() > other.m_selected_inputs.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 183,
          "old_api": "at",
          "new_api": null,
          "old_text": "txo_pool.at(i);",
          "new_text": null,
          "old_line_content": "        const OutputGroup& group = utxo_pool.at(i);",
          "new_line_content": "        if (selected_eff_value >= target_value) {",
          "content_same": false
        },
        {
          "line": 184,
          "old_api": "GetSelectionAmount",
          "new_api": null,
          "old_text": "roup.GetSelectionAmount() ",
          "new_text": null,
          "old_line_content": "        Assume(group.GetSelectionAmount() > 0);",
          "new_line_content": "            return result;",
          "content_same": false
        },
        {
          "line": 185,
          "old_api": "GetSelectionAmount",
          "new_api": null,
          "old_text": "roup.GetSelectionAmount();",
          "new_text": null,
          "old_line_content": "        selected_eff_value += group.GetSelectionAmount();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 186,
          "old_api": "AddInput",
          "new_api": null,
          "old_text": "esult.AddInput(group);",
          "new_text": null,
          "old_line_content": "        result.AddInput(group);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 320,
          "old_api": "GetFee",
          "new_api": null,
          "old_text": "_effective_feerate.GetFee(output.m_input_bytes);",
          "new_text": null,
          "old_line_content": "    const CAmount coin_fee = output.m_input_bytes < 0 ? 0 : m_effective_feerate.GetFee(output.m_input_bytes);",
          "new_line_content": "    if (positive_only && ev <= 0) return;",
          "content_same": false
        },
        {
          "line": 326,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "_outputs.push_back(output);",
          "new_text": null,
          "old_line_content": "    m_outputs.push_back(output);",
          "new_line_content": "    fee += coin.m_fee;",
          "content_same": false
        },
        {
          "line": 71,
          "old_api": "size",
          "new_api": null,
          "old_text": "txo_pool.size())",
          "new_text": null,
          "old_line_content": "    curr_selection.reserve(utxo_pool.size());",
          "new_line_content": "    // Calculate curr_available_value",
          "content_same": false
        },
        {
          "line": 199,
          "old_api": "size",
          "new_api": null,
          "old_text": "roups.size(),",
          "new_text": null,
          "old_line_content": "    vfBest.assign(groups.size(), true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 327,
          "old_api": "back",
          "new_api": null,
          "old_text": "_outputs.back();",
          "new_text": null,
          "old_line_content": "    CInputCoin& coin = m_outputs.back();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 332,
          "old_api": "GetFee",
          "new_api": null,
          "old_text": "_long_term_feerate.GetFee(coin.m_input_bytes);",
          "new_text": null,
          "old_line_content": "    coin.m_long_term_fee = coin.m_input_bytes < 0 ? 0 : m_long_term_feerate.GetFee(coin.m_input_bytes);",
          "new_line_content": "    effective_value += coin.effective_value;",
          "content_same": false
        },
        {
          "line": 78,
          "old_api": "GetSelectionAmount",
          "new_api": null,
          "old_text": "txo.GetSelectionAmount();",
          "new_text": null,
          "old_line_content": "        curr_available_value += utxo.GetSelectionAmount();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 206,
          "old_api": "size",
          "new_api": null,
          "old_text": "roups.size(),",
          "new_text": null,
          "old_line_content": "        vfIncluded.assign(groups.size(), false);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 211,
          "old_api": "size",
          "new_api": null,
          "old_text": "roups.size();",
          "new_text": null,
          "old_line_content": "            for (unsigned int i = 0; i < groups.size(); i++)",
          "new_line_content": "                //needed to prevent degenerate behavior and it is important",
          "content_same": false
        },
        {
          "line": 340,
          "old_api": "td::min(m_depth, depth);",
          "new_api": null,
          "old_text": "td::min(m_depth, depth);",
          "new_text": null,
          "old_line_content": "    m_depth = std::min(m_depth, depth);",
          "new_line_content": "    m_ancestors += ancestors;",
          "content_same": false
        },
        {
          "line": 85,
          "old_api": "end",
          "new_api": null,
          "old_text": "txo_pool.end(),",
          "new_text": null,
          "old_line_content": "    std::sort(utxo_pool.begin(), utxo_pool.end(), descending);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 219,
          "old_api": "randbool",
          "new_api": null,
          "old_text": "nsecure_rand.randbool() ",
          "new_text": null,
          "old_line_content": "                if (nPass == 0 ? insecure_rand.randbool() : !vfIncluded[i])",
          "new_line_content": "                    if (nTotal >= nTargetValue)",
          "content_same": false
        },
        {
          "line": 347,
          "old_api": "td::max(m_descendants, descendants);",
          "new_api": null,
          "old_text": "td::max(m_descendants, descendants);",
          "new_text": null,
          "old_line_content": "    m_descendants = std::max(m_descendants, descendants);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 221,
          "old_api": "GetSelectionAmount",
          "new_api": null,
          "old_text": "roups[i].GetSelectionAmount();",
          "new_text": null,
          "old_line_content": "                    nTotal += groups[i].GetSelectionAmount();",
          "new_line_content": "                        fReachedTarget = true;",
          "content_same": false
        },
        {
          "line": 97,
          "old_api": "at",
          "new_api": null,
          "old_text": "txo_pool.at(0).",
          "new_text": null,
          "old_line_content": "            (curr_waste > best_waste && (utxo_pool.at(0).fee - utxo_pool.at(0).long_term_fee) > 0)) { // Don't select things which we know will be more wasteful if the waste is increasing",
          "new_line_content": "            backtrack = true;",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": "GetSelectionAmount",
          "new_api": null,
          "old_text": "roups[i].GetSelectionAmount();",
          "new_text": null,
          "old_line_content": "                        nTotal -= groups[i].GetSelectionAmount();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 107,
          "old_api": "size",
          "new_api": null,
          "old_text": "txo_pool.size())",
          "new_text": null,
          "old_line_content": "                best_selection.resize(utxo_pool.size());",
          "new_line_content": "                if (best_waste == 0) {",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": "empty",
          "new_api": null,
          "old_text": "nputs.empty())",
          "new_text": null,
          "old_line_content": "    assert(!inputs.empty());",
          "new_line_content": "    CAmount selected_effective_value = 0;",
          "content_same": false
        },
        {
          "line": 120,
          "old_api": "back",
          "new_api": null,
          "old_text": "urr_selection.back())",
          "new_text": null,
          "old_line_content": "            while (!curr_selection.empty() && !curr_selection.back()) {",
          "new_line_content": "            // Add omitted UTXOs back to lookahead before traversing the omission branch of last included UTXO.",
          "content_same": false
        },
        {
          "line": 125,
          "old_api": "empty",
          "new_api": null,
          "old_text": "urr_selection.empty())",
          "new_text": null,
          "old_line_content": "            if (curr_selection.empty()) { // We have walked back to the first utxo and no branch is untraversed. All solutions searched",
          "new_line_content": "            // Output was included on previous iterations, try excluding now.",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": "ssert",
          "new_api": null,
          "old_text": "ssert(selected_effective_value >= target);",
          "new_text": null,
          "old_line_content": "        assert(selected_effective_value >= target);",
          "new_line_content": "    return waste;",
          "content_same": false
        },
        {
          "line": 255,
          "old_api": "GetSelectionAmount",
          "new_api": null,
          "old_text": "roup.GetSelectionAmount() ",
          "new_text": null,
          "old_line_content": "        } else if (group.GetSelectionAmount() < nTargetValue + MIN_CHANGE) {",
          "new_line_content": "            lowest_larger = group;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 16,
      "total_additions": 57,
      "total_deletions": 61,
      "total_api_changes": 134
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 4,
        "api_related_lines": 134,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          8,
          5,
          6,
          7
        ]
      }
    },
    "api_calls_before": 127,
    "api_calls_after": 115,
    "diff_info": {
      "added_lines": 2,
      "removed_lines": 4,
      "total_diff_lines": 21
    }
  }
}