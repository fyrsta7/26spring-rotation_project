{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/273d02580aa736b7ccea8fce51d90541665fdbd1",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/273d02580aa736b7ccea8fce51d90541665fdbd1/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/273d02580aa736b7ccea8fce51d90541665fdbd1/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/273d02580aa736b7ccea8fce51d90541665fdbd1/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": true,
    "api_changes": {
      "replacements": [
        {
          "line": 786,
          "old_api": "lower_bound",
          "new_api": "rand256",
          "old_text": "mapOrphanTransactions.lower_bound(randomhash)",
          "new_text": "rng.rand256()",
          "old_line_content": "        std::map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.lower_bound(randomhash);",
          "new_line_content": "        uint256 randomhash = rng.rand256();",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": "end",
          "new_api": "lower_bound",
          "old_text": "mapOrphanTransactions.end()",
          "new_text": "mapOrphanTransactions.lower_bound(randomhash)",
          "old_line_content": "        if (it == mapOrphanTransactions.end())",
          "new_line_content": "        std::map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.lower_bound(randomhash);",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": "begin",
          "new_api": "end",
          "old_text": "mapOrphanTransactions.begin()",
          "new_text": "mapOrphanTransactions.end()",
          "old_line_content": "            it = mapOrphanTransactions.begin();",
          "new_line_content": "        if (it == mapOrphanTransactions.end())",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": "EraseOrphanTx",
          "new_api": "begin",
          "old_text": "EraseOrphanTx(it->first)",
          "new_text": "mapOrphanTransactions.begin()",
          "old_line_content": "        EraseOrphanTx(it->first);",
          "new_line_content": "            it = mapOrphanTransactions.begin();",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": "empty",
          "new_api": "GetArg",
          "old_text": "message.empty()",
          "new_text": "gArgs.GetArg(\"-banscore\", DEFAULT_BANSCORE_THRESHOLD)",
          "old_line_content": "    std::string message_prefixed = message.empty() ? \"\" : (\": \" + message);",
          "new_line_content": "    int banscore = gArgs.GetArg(\"-banscore\", DEFAULT_BANSCORE_THRESHOLD);",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": "Contains",
          "new_api": "AssertLockHeld",
          "old_text": "chainActive.Contains(pindex)",
          "new_text": "AssertLockHeld(cs_main)",
          "old_line_content": "    if (chainActive.Contains(pindex)) return true;",
          "new_line_content": "    AssertLockHeld(cs_main);",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": "IsValid",
          "new_api": "Contains",
          "old_text": "pindex->IsValid(BLOCK_VALID_SCRIPTS)",
          "new_text": "chainActive.Contains(pindex)",
          "old_line_content": "    return pindex->IsValid(BLOCK_VALID_SCRIPTS) && (pindexBestHeader != nullptr) &&",
          "new_line_content": "    if (chainActive.Contains(pindex)) return true;",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": "GetBlockTime",
          "new_api": "IsValid",
          "old_text": "pindex->GetBlockTime()",
          "new_text": "pindex->IsValid(BLOCK_VALID_SCRIPTS)",
          "old_line_content": "        (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() < STALE_RELAY_AGE_LIMIT) &&",
          "new_line_content": "    return pindex->IsValid(BLOCK_VALID_SCRIPTS) && (pindexBestHeader != nullptr) &&",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": "GetBlockProofEquivalentTime",
          "new_api": "GetBlockTime",
          "old_text": "GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, consensusParams)",
          "new_text": "pindex->GetBlockTime()",
          "old_line_content": "        (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, consensusParams) < STALE_RELAY_AGE_LIMIT);",
          "new_line_content": "        (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() < STALE_RELAY_AGE_LIMIT) &&",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": "end",
          "new_api": "find",
          "old_text": "mapOrphanTransactionsByPrev.end()",
          "new_text": "mapOrphanTransactionsByPrev.find(txin.prevout)",
          "old_line_content": "            if (itByPrev == mapOrphanTransactionsByPrev.end()) continue;",
          "new_line_content": "            auto itByPrev = mapOrphanTransactionsByPrev.find(txin.prevout);",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": "push_back",
          "new_api": "GetHash",
          "old_text": "vOrphanErase.push_back(orphanHash)",
          "new_text": "orphanTx.GetHash()",
          "old_line_content": "                vOrphanErase.push_back(orphanHash);",
          "new_line_content": "                const uint256& orphanHash = orphanTx.GetHash();",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": "GetHash",
          "new_api": "GetConsensus",
          "old_text": "pblock->GetHash()",
          "new_text": "Params().GetConsensus()",
          "old_line_content": "    uint256 hashBlock(pblock->GetHash());",
          "new_line_content": "    bool fWitnessEnabled = IsWitnessEnabled(pindex->pprev, Params().GetConsensus());",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": "AssertLockHeld",
          "new_api": "ToString",
          "old_text": "AssertLockHeld(cs_main)",
          "new_text": "connman->ForEachNode([this, &pcmpctblock, pindex, &msgMaker, fWitnessEnabled, &hashBlock](CNode* pnode) {\n        AssertLockHeld(cs_main);\n\n        // TODO: Avoid the repeated-serialization here\n        if (pnode->nVersion < INVALID_CB_NO_BAN_VERSION || pnode->fDisconnect)\n            return;\n        ProcessBlockAvailability(pnode->GetId());\n        CNodeState &state = *State(pnode->GetId());\n        // If the peer has, or we announced to them the previous block already,\n        // but we don't think they have this one, go ahead and announce it\n        if (state.fPreferHeaderAndIDs && (!fWitnessEnabled || state.fWantsCmpctWitness) &&\n                !PeerHasHeader(&state, pindex) && PeerHasHeader(&state, pindex->pprev)) {\n\n            LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", \"PeerLogicValidation::NewPoWValidBlock\",\n                    hashBlock.ToString(), pnode->GetId());\n            connman->PushMessage(pnode, msgMaker.Make(NetMsgType::CMPCTBLOCK, *pcmpctblock));\n            state.pindexBestHeaderSent = pindex;\n        }\n    })",
          "old_line_content": "        AssertLockHeld(cs_main);",
          "new_line_content": "    connman->ForEachNode([this, &pcmpctblock, pindex, &msgMaker, fWitnessEnabled, &hashBlock](CNode* pnode) {",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": "GetId",
          "new_api": "ToString",
          "old_text": "pnode->GetId()",
          "new_text": "LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", \"PeerLogicValidation::NewPoWValidBlock\",\n                    hashBlock.ToString(), pnode->GetId())",
          "old_line_content": "                    hashBlock.ToString(), pnode->GetId());",
          "new_line_content": "            LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", \"PeerLogicValidation::NewPoWValidBlock\",",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": "Make",
          "new_api": "GetId",
          "old_text": "msgMaker.Make(NetMsgType::CMPCTBLOCK, *pcmpctblock)",
          "new_text": "pnode->GetId()",
          "old_line_content": "            connman->PushMessage(pnode, msgMaker.Make(NetMsgType::CMPCTBLOCK, *pcmpctblock));",
          "new_line_content": "                    hashBlock.ToString(), pnode->GetId());",
          "content_same": false
        },
        {
          "line": 974,
          "old_api": "PushBlockHash",
          "new_api": "reverse_iterate",
          "old_text": "pnode->PushBlockHash(hash)",
          "new_text": "reverse_iterate(vHashes)",
          "old_line_content": "                    pnode->PushBlockHash(hash);",
          "new_line_content": "                for (const uint256& hash : reverse_iterate(vHashes)) {",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": "find",
          "new_api": "GetHash",
          "old_text": "mapBlockSource.find(hash)",
          "new_text": "block.GetHash()",
          "old_line_content": "    std::map<uint256, std::pair<NodeId, bool>>::iterator it = mapBlockSource.find(hash);",
          "new_line_content": "    const uint256 hash(block.GetHash());",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": "GetRejectReason",
          "new_api": "GetRejectCode",
          "old_text": "state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH)",
          "new_text": "state.GetRejectCode()",
          "old_line_content": "            CBlockReject reject = {(unsigned char)state.GetRejectCode(), state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), hash};",
          "new_line_content": "        if (it != mapBlockSource.end() && State(it->second.first) && state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) {",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "push_back",
          "new_api": "GetRejectReason",
          "old_text": "State(it->second.first)->rejects.push_back(reject)",
          "new_text": "state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH)",
          "old_line_content": "            State(it->second.first)->rejects.push_back(reject);",
          "new_line_content": "            CBlockReject reject = {(unsigned char)state.GetRejectCode(), state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), hash};",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": "IsInitialBlockDownload",
          "new_api": "IsValid",
          "old_text": "IsInitialBlockDownload()",
          "new_text": "state.IsValid()",
          "old_line_content": "             !IsInitialBlockDownload() &&",
          "new_line_content": "    else if (state.IsValid() &&",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": "size",
          "new_api": "IsInitialBlockDownload",
          "old_text": "mapBlocksInFlight.size()",
          "new_text": "IsInitialBlockDownload()",
          "old_line_content": "             mapBlocksInFlight.count(hash) == mapBlocksInFlight.size()) {",
          "new_line_content": "             !IsInitialBlockDownload() &&",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": "end",
          "new_api": "size",
          "old_text": "mapBlockSource.end()",
          "new_text": "mapBlocksInFlight.size()",
          "old_line_content": "        if (it != mapBlockSource.end()) {",
          "new_line_content": "             mapBlocksInFlight.count(hash) == mapBlocksInFlight.size()) {",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": "MaybeSetPeerAsAnnouncingHeaderAndIDs",
          "new_api": "end",
          "old_text": "MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first, connman)",
          "new_text": "mapBlockSource.end()",
          "old_line_content": "            MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first, connman);",
          "new_line_content": "        if (it != mapBlockSource.end()) {",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": "erase",
          "new_api": "end",
          "old_text": "mapBlockSource.erase(it)",
          "new_text": "mapBlockSource.end()",
          "old_line_content": "        mapBlockSource.erase(it);",
          "new_line_content": "    if (it != mapBlockSource.end())",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": "Tip",
          "new_api": "assert",
          "old_text": "chainActive.Tip()->GetBlockHash()",
          "new_text": "assert(recentRejects)",
          "old_line_content": "            if (chainActive.Tip()->GetBlockHash() != hashRecentRejectsChainTip)",
          "new_line_content": "            assert(recentRejects);",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": "reset",
          "new_api": "Tip",
          "old_text": "recentRejects->reset()",
          "new_text": "chainActive.Tip()->GetBlockHash()",
          "old_line_content": "                recentRejects->reset();",
          "new_line_content": "                hashRecentRejectsChainTip = chainActive.Tip()->GetBlockHash();",
          "content_same": false
        },
        {
          "line": 1047,
          "old_api": "count",
          "new_api": "LOCK",
          "old_text": "mapOrphanTransactions.count(inv.hash)",
          "new_text": "LOCK(g_cs_orphans)",
          "old_line_content": "                if (mapOrphanTransactions.count(inv.hash)) return true;",
          "new_line_content": "                LOCK(g_cs_orphans);",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": "exists",
          "new_api": "contains",
          "old_text": "mempool.exists(inv.hash)",
          "new_text": "recentRejects->contains(inv.hash)",
          "old_line_content": "                   mempool.exists(inv.hash) ||",
          "new_line_content": "            return recentRejects->contains(inv.hash) ||",
          "content_same": false
        },
        {
          "line": 1052,
          "old_api": "COutPoint",
          "new_api": "exists",
          "old_text": "COutPoint(inv.hash, 0)",
          "new_text": "mempool.exists(inv.hash)",
          "old_line_content": "                   pcoinsTip->HaveCoinInCache(COutPoint(inv.hash, 0)) || // Best effort: only try output 0 and 1",
          "new_line_content": "                   mempool.exists(inv.hash) ||",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": "ForEachNode",
          "new_api": "GetHash",
          "old_text": "connman->ForEachNode([&inv](CNode* pnode)\n    {\n        pnode->PushInventory(inv);\n    })",
          "new_text": "tx.GetHash()",
          "old_line_content": "    connman->ForEachNode([&inv](CNode* pnode)",
          "new_line_content": "    CInv inv(MSG_TX, tx.GetHash());",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": "GetTime",
          "new_api": "GetHash",
          "old_text": "GetTime()",
          "new_text": "addr.GetHash()",
          "old_line_content": "    const CSipHasher hasher = connman->GetDeterministicRandomizer(RANDOMIZER_ID_ADDRESS_RELAY).Write(hashAddr << 32).Write((GetTime() + hashAddr) / (24*60*60));",
          "new_line_content": "    uint64_t hashAddr = addr.GetHash();",
          "content_same": false
        },
        {
          "line": 1092,
          "old_api": "std::make_pair(hashKey, pnode)",
          "new_api": "begin",
          "old_text": "std::make_pair(hashKey, pnode)",
          "new_text": "best.begin()",
          "old_line_content": "                     best[i] = std::make_pair(hashKey, pnode);",
          "new_line_content": "                     std::copy(best.begin() + i, best.begin() + nRelayNodes - 1, best.begin() + i + 1);",
          "content_same": false
        },
        {
          "line": 1125,
          "old_api": "LookupBlockIndex",
          "new_api": "LOCK",
          "old_text": "LookupBlockIndex(inv.hash)",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "        const CBlockIndex* pindex = LookupBlockIndex(inv.hash);",
          "new_line_content": "        LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": "FormatStateMessage",
          "new_api": "Params",
          "old_text": "FormatStateMessage(state)",
          "new_text": "Params()",
          "old_line_content": "            LogPrint(BCLog::NET, \"failed to activate chain (%s)\\n\", FormatStateMessage(state));",
          "new_line_content": "        if (!ActivateBestChain(state, Params(), a_recent_block)) {",
          "content_same": false
        },
        {
          "line": 1146,
          "old_api": "LookupBlockIndex",
          "new_api": "LOCK",
          "old_text": "LookupBlockIndex(inv.hash)",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "    const CBlockIndex* pindex = LookupBlockIndex(inv.hash);",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1186,
          "old_api": "assert",
          "new_api": "MessageStart",
          "old_text": "assert(!\"cannot load block from disk\")",
          "new_text": "chainparams.MessageStart()",
          "old_line_content": "                assert(!\"cannot load block from disk\");",
          "new_line_content": "            if (!ReadRawBlockFromDisk(block_data, pindex, chainparams.MessageStart())) {",
          "content_same": false
        },
        {
          "line": 1193,
          "old_api": "ReadBlockFromDisk",
          "new_api": "std::make_shared<CBlock>()",
          "old_text": "ReadBlockFromDisk(*pblockRead, pindex, consensusParams)",
          "new_text": "std::make_shared<CBlock>()",
          "old_line_content": "            if (!ReadBlockFromDisk(*pblockRead, pindex, consensusParams))",
          "new_line_content": "            std::shared_ptr<CBlock> pblockRead = std::make_shared<CBlock>();",
          "content_same": false
        },
        {
          "line": 1194,
          "old_api": "assert",
          "new_api": "ReadBlockFromDisk",
          "old_text": "assert(!\"cannot load block from disk\")",
          "new_text": "ReadBlockFromDisk(*pblockRead, pindex, consensusParams)",
          "old_line_content": "                assert(!\"cannot load block from disk\");",
          "new_line_content": "            if (!ReadBlockFromDisk(*pblockRead, pindex, consensusParams))",
          "content_same": false
        },
        {
          "line": 1237,
          "old_api": "GetBlockHash",
          "new_api": "Height",
          "old_text": "pindex->GetBlockHash()",
          "new_text": "chainActive.Height()",
          "old_line_content": "                    if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == pindex->GetBlockHash()) {",
          "new_line_content": "                if (CanDirectFetch(consensusParams) && pindex->nHeight >= chainActive.Height() - MAX_CMPCTBLOCK_DEPTH) {",
          "content_same": false
        },
        {
          "line": 1238,
          "old_api": "Make",
          "new_api": "GetBlockHash",
          "old_text": "msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block)",
          "new_text": "pindex->GetBlockHash()",
          "old_line_content": "                        connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));",
          "new_line_content": "                    if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == pindex->GetBlockHash()) {",
          "content_same": false
        },
        {
          "line": 1257,
          "old_api": "Make",
          "new_api": "Tip",
          "old_text": "msgMaker.Make(NetMsgType::INV, vInv)",
          "new_text": "chainActive.Tip()->GetBlockHash()",
          "old_line_content": "            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::INV, vInv));",
          "new_line_content": "            vInv.push_back(CInv(MSG_BLOCK, chainActive.Tip()->GetBlockHash()));",
          "content_same": false
        },
        {
          "line": 1258,
          "old_api": "SetNull",
          "new_api": "Make",
          "old_text": "pfrom->hashContinue.SetNull()",
          "new_text": "msgMaker.Make(NetMsgType::INV, vInv)",
          "old_line_content": "            pfrom->hashContinue.SetNull();",
          "new_line_content": "            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::INV, vInv));",
          "content_same": false
        },
        {
          "line": 1288,
          "old_api": "Make",
          "new_api": "end",
          "old_text": "msgMaker.Make(nSendFlags, NetMsgType::TX, *mi->second)",
          "new_text": "mapRelay.end()",
          "old_line_content": "                connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *mi->second));",
          "new_line_content": "            if (mi != mapRelay.end()) {",
          "content_same": false
        },
        {
          "line": 1339,
          "old_api": "LOCK",
          "new_api": "size",
          "old_text": "LOCK(cs_main)",
          "new_text": "block.vtx.size()",
          "old_line_content": "            LOCK(cs_main);",
          "new_line_content": "        if (req.indexes[i] >= block.vtx.size()) {",
          "content_same": false
        },
        {
          "line": 1340,
          "old_api": "GetId",
          "new_api": "LOCK",
          "old_text": "pfrom->GetId()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "            Misbehaving(pfrom->GetId(), 100, strprintf(\"Peer %d sent us a getblocktxn with out-of-bounds tx indices\", pfrom->GetId()));",
          "new_line_content": "            LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1346,
          "old_api": "GetSendVersion",
          "new_api": "LOCK",
          "old_text": "pfrom->GetSendVersion()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1347,
          "old_api": "GetId",
          "new_api": "GetSendVersion",
          "old_text": "pfrom->GetId()",
          "new_text": "pfrom->GetSendVersion()",
          "old_line_content": "    int nSendFlags = State(pfrom->GetId())->fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;",
          "new_line_content": "    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());",
          "content_same": false
        },
        {
          "line": 1348,
          "old_api": "Make",
          "new_api": "GetId",
          "old_text": "msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp)",
          "new_text": "pfrom->GetId()",
          "old_line_content": "    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));",
          "new_line_content": "    int nSendFlags = State(pfrom->GetId())->fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;",
          "content_same": false
        },
        {
          "line": 1354,
          "old_api": "size",
          "new_api": "GetSendVersion",
          "old_text": "headers.size()",
          "new_text": "pfrom->GetSendVersion()",
          "old_line_content": "    size_t nCount = headers.size();",
          "new_line_content": "    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());",
          "content_same": false
        },
        {
          "line": 1365,
          "old_api": "GetId",
          "new_api": "LOCK",
          "old_text": "pfrom->GetId()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "        CNodeState *nodestate = State(pfrom->GetId());",
          "new_line_content": "        LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1378,
          "old_api": "GetHash",
          "new_api": "uint256",
          "old_text": "LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n                    headers[0].GetHash().ToString(),\n                    headers[0].hashPrevBlock.ToString(),\n                    pindexBestHeader->nHeight,\n                    pfrom->GetId(), nodestate->nUnconnectingHeaders)",
          "new_text": "uint256()",
          "old_line_content": "            LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",",
          "new_line_content": "            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": "ToString",
          "new_api": "GetHash",
          "old_text": "headers[0].hashPrevBlock.ToString()",
          "new_text": "headers[0].GetHash().ToString()",
          "old_line_content": "                    headers[0].hashPrevBlock.ToString(),",
          "new_line_content": "                    headers[0].GetHash().ToString(),",
          "content_same": false
        },
        {
          "line": 1397,
          "old_api": "GetId",
          "new_api": "IsNull",
          "old_text": "pfrom->GetId()",
          "new_text": "hashLastBlock.IsNull()",
          "old_line_content": "                Misbehaving(pfrom->GetId(), 20, \"non-continuous headers sequence\");",
          "new_line_content": "            if (!hashLastBlock.IsNull() && header.hashPrevBlock != hashLastBlock) {",
          "content_same": false
        },
        {
          "line": 1415,
          "old_api": "LOCK",
          "new_api": "IsInvalid",
          "old_text": "LOCK(cs_main)",
          "new_text": "state.IsInvalid(nDoS)",
          "old_line_content": "            LOCK(cs_main);",
          "new_line_content": "        if (state.IsInvalid(nDoS)) {",
          "content_same": false
        },
        {
          "line": 1461,
          "old_api": "GetId",
          "new_api": "LOCK",
          "old_text": "pfrom->GetId()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "        CNodeState *nodestate = State(pfrom->GetId());",
          "new_line_content": "        LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1468,
          "old_api": "GetBlockHash",
          "new_api": "assert",
          "old_text": "pindexLast->GetBlockHash()",
          "new_text": "assert(pindexLast)",
          "old_line_content": "        UpdateBlockAvailability(pfrom->GetId(), pindexLast->GetBlockHash());",
          "new_line_content": "        assert(pindexLast);",
          "content_same": false
        },
        {
          "line": 1475,
          "old_api": "GetTime",
          "new_api": "Tip",
          "old_text": "GetTime()",
          "new_text": "chainActive.Tip()",
          "old_line_content": "            nodestate->m_last_block_announcement = GetTime();",
          "new_line_content": "        if (received_new_header && pindexLast->nChainWork > chainActive.Tip()->nChainWork) {",
          "content_same": false
        },
        {
          "line": 1483,
          "old_api": "uint256",
          "new_api": "GetId",
          "old_text": "uint256()",
          "new_text": "pfrom->GetId()",
          "old_line_content": "            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256()));",
          "new_line_content": "            LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->GetId(), pfrom->nStartingHeight);",
          "content_same": false
        },
        {
          "line": 1496,
          "old_api": "GetId",
          "new_api": "GetBlockHash",
          "old_text": "pfrom->GetId()",
          "new_text": "pindexWalk->GetBlockHash()",
          "old_line_content": "                        (!IsWitnessEnabled(pindexWalk->pprev, chainparams.GetConsensus()) || State(pfrom->GetId())->fHaveWitness)) {",
          "new_line_content": "                        !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&",
          "content_same": false
        },
        {
          "line": 1507,
          "old_api": "ToString",
          "new_api": "Contains",
          "old_text": "LogPrint(BCLog::NET, \"Large reorg, won't direct fetch to %s (%d)\\n\",\n                        pindexLast->GetBlockHash().ToString(),\n                        pindexLast->nHeight)",
          "new_text": "chainActive.Contains(pindexWalk)",
          "old_line_content": "                LogPrint(BCLog::NET, \"Large reorg, won't direct fetch to %s (%d)\\n\",",
          "new_line_content": "            if (!chainActive.Contains(pindexWalk)) {",
          "content_same": false
        },
        {
          "line": 1519,
          "old_api": "GetBlockHash",
          "new_api": "GetFetchFlags",
          "old_text": "pindex->GetBlockHash()",
          "new_text": "GetFetchFlags(pfrom)",
          "old_line_content": "                    vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));",
          "new_line_content": "                    uint32_t nFetchFlags = GetFetchFlags(pfrom);",
          "content_same": false
        },
        {
          "line": 1521,
          "old_api": "ToString",
          "new_api": "GetBlockHash",
          "old_text": "LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\n                            pindex->GetBlockHash().ToString(), pfrom->GetId())",
          "new_text": "pindex->GetBlockHash()",
          "old_line_content": "                    LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",",
          "new_line_content": "                    MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex);",
          "content_same": false
        },
        {
          "line": 1522,
          "old_api": "GetId",
          "new_api": "ToString",
          "old_text": "pfrom->GetId()",
          "new_text": "LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\n                            pindex->GetBlockHash().ToString(), pfrom->GetId())",
          "old_line_content": "                            pindex->GetBlockHash().ToString(), pfrom->GetId());",
          "new_line_content": "                    LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",",
          "content_same": false
        },
        {
          "line": 1525,
          "old_api": "ToString",
          "new_api": "size",
          "old_text": "LogPrint(BCLog::NET, \"Downloading blocks toward %s (%d) via headers direct fetch\\n\",\n                            pindexLast->GetBlockHash().ToString(), pindexLast->nHeight)",
          "new_text": "vGetData.size()",
          "old_line_content": "                    LogPrint(BCLog::NET, \"Downloading blocks toward %s (%d) via headers direct fetch\\n\",",
          "new_line_content": "                if (vGetData.size() > 1) {",
          "content_same": false
        },
        {
          "line": 1529,
          "old_api": "IsValid",
          "new_api": "size",
          "old_text": "pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)",
          "new_text": "vGetData.size()",
          "old_line_content": "                    if (nodestate->fSupportsDesiredCmpctVersion && vGetData.size() == 1 && mapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {",
          "new_line_content": "                if (vGetData.size() > 0) {",
          "content_same": false
        },
        {
          "line": 1552,
          "old_api": "GetId",
          "new_api": "IsOutboundDisconnectionCandidate",
          "old_text": "pfrom->GetId()",
          "new_text": "IsOutboundDisconnectionCandidate(pfrom)",
          "old_line_content": "                    LogPrintf(\"Disconnecting outbound peer %d -- headers chain has insufficient work\\n\", pfrom->GetId());",
          "new_line_content": "                if (IsOutboundDisconnectionCandidate(pfrom)) {",
          "content_same": false
        },
        {
          "line": 1562,
          "old_api": "GetId",
          "new_api": "Tip",
          "old_text": "pfrom->GetId()",
          "new_text": "chainActive.Tip()",
          "old_line_content": "                LogPrint(BCLog::NET, \"Protecting outbound peer=%d from eviction\\n\", pfrom->GetId());",
          "new_line_content": "            if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= chainActive.Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {",
          "content_same": false
        },
        {
          "line": 1575,
          "old_api": "GetArg",
          "new_api": "GetId",
          "old_text": "gArgs.GetArg(\"-dropmessagestest\", 0)",
          "new_text": "pfrom->GetId()",
          "old_line_content": "    if (gArgs.IsArgSet(\"-dropmessagestest\") && GetRand(gArgs.GetArg(\"-dropmessagestest\", 0)) == 0)",
          "new_line_content": "    LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 1588,
          "old_api": "GetId",
          "new_api": "LOCK",
          "old_text": "pfrom->GetId()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "            Misbehaving(pfrom->GetId(), 100);",
          "new_line_content": "            LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1629,
          "old_api": "GetId",
          "new_api": "LOCK",
          "old_text": "pfrom->GetId()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "            Misbehaving(pfrom->GetId(), 1);",
          "new_line_content": "            LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1648,
          "old_api": "ServiceFlags",
          "new_api": "std::min(nVersion, PROTOCOL_VERSION)",
          "old_text": "ServiceFlags(nServiceInt)",
          "new_text": "std::min(nVersion, PROTOCOL_VERSION)",
          "old_line_content": "        nServices = ServiceFlags(nServiceInt);",
          "new_line_content": "        nSendVersion = std::min(nVersion, PROTOCOL_VERSION);",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": "GetDesirableServiceFlags",
          "new_api": "Make",
          "old_text": "GetDesirableServiceFlags(nServices)",
          "new_text": "CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,\n                                   strprintf(\"Expected to offer services %08x\", GetDesirableServiceFlags(nServices)))",
          "old_line_content": "                                   strprintf(\"Expected to offer services %08x\", GetDesirableServiceFlags(nServices))));",
          "new_line_content": "                connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,",
          "content_same": false
        },
        {
          "line": 1669,
          "old_api": "strprintf",
          "new_api": "Make",
          "old_text": "strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION)",
          "new_text": "CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n                                   strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION))",
          "old_line_content": "                                   strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION)));",
          "new_line_content": "                connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,",
          "content_same": false
        },
        {
          "line": 1678,
          "old_api": "LIMITED_STRING",
          "new_api": "empty",
          "old_text": "LIMITED_STRING(strSubVer, MAX_SUBVERSION_LENGTH)",
          "new_text": "vRecv.empty()",
          "old_line_content": "            vRecv >> LIMITED_STRING(strSubVer, MAX_SUBVERSION_LENGTH);",
          "new_line_content": "        if (!vRecv.empty()) {",
          "content_same": false
        },
        {
          "line": 1679,
          "old_api": "SanitizeString",
          "new_api": "LIMITED_STRING",
          "old_text": "SanitizeString(strSubVer)",
          "new_text": "LIMITED_STRING(strSubVer, MAX_SUBVERSION_LENGTH)",
          "old_line_content": "            cleanSubVer = SanitizeString(strSubVer);",
          "new_line_content": "            vRecv >> LIMITED_STRING(strSubVer, MAX_SUBVERSION_LENGTH);",
          "content_same": false
        },
        {
          "line": 1732,
          "old_api": "GetId",
          "new_api": "LOCK",
          "old_text": "pfrom->GetId()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "            State(pfrom->GetId())->fHaveWitness = true;",
          "new_line_content": "            LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1738,
          "old_api": "GetId",
          "new_api": "LOCK",
          "old_text": "pfrom->GetId()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "        UpdatePreferredDownload(pfrom, State(pfrom->GetId()));",
          "new_line_content": "        LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1751,
          "old_api": "PushAddress",
          "new_api": "ToString",
          "old_text": "pfrom->PushAddress(addr, insecure_rand)",
          "new_text": "addr.ToString()",
          "old_line_content": "                    pfrom->PushAddress(addr, insecure_rand);",
          "new_line_content": "                    LogPrint(BCLog::NET, \"ProcessMessages: advertising address %s\\n\", addr.ToString());",
          "content_same": false
        },
        {
          "line": 1752,
          "old_api": "IsPeerAddrLocalGood",
          "new_api": "PushAddress",
          "old_text": "IsPeerAddrLocalGood(pfrom)",
          "new_text": "pfrom->PushAddress(addr, insecure_rand)",
          "old_line_content": "                } else if (IsPeerAddrLocalGood(pfrom)) {",
          "new_line_content": "                    pfrom->PushAddress(addr, insecure_rand);",
          "content_same": false
        },
        {
          "line": 1753,
          "old_api": "SetIP",
          "new_api": "IsPeerAddrLocalGood",
          "old_text": "addr.SetIP(addrMe)",
          "new_text": "IsPeerAddrLocalGood(pfrom)",
          "old_line_content": "                    addr.SetIP(addrMe);",
          "new_line_content": "                } else if (IsPeerAddrLocalGood(pfrom)) {",
          "content_same": false
        },
        {
          "line": 1754,
          "old_api": "ToString",
          "new_api": "SetIP",
          "old_text": "addr.ToString()",
          "new_text": "addr.SetIP(addrMe)",
          "old_line_content": "                    LogPrint(BCLog::NET, \"ProcessMessages: advertising address %s\\n\", addr.ToString());",
          "new_line_content": "                    addr.SetIP(addrMe);",
          "content_same": false
        },
        {
          "line": 1755,
          "old_api": "PushAddress",
          "new_api": "ToString",
          "old_text": "pfrom->PushAddress(addr, insecure_rand)",
          "new_text": "addr.ToString()",
          "old_line_content": "                    pfrom->PushAddress(addr, insecure_rand);",
          "new_line_content": "                    LogPrint(BCLog::NET, \"ProcessMessages: advertising address %s\\n\", addr.ToString());",
          "content_same": false
        },
        {
          "line": 1784,
          "old_api": "Make",
          "new_api": "ParseHex",
          "old_text": "CNetMsgMaker(nSendVersion).Make(\"alert\", finalAlert)",
          "new_text": "ParseHex(\"60010000000000000000000000ffffff7f00000000ffffff7ffeffff7f01ffffff7f00000000ffffff7f00ffffff7f002f555247454e543a20416c657274206b657920636f6d70726f6d697365642c2075706772616465207265717569726564004630440220653febd6410f470f6bae11cad19c48413becb1ac2c17f908fd0fd53bdc3abd5202206d0e9c96fe88d4a0f01ed9dedae2b6f9e00da94cad0fecaae66ecf689bf71b50\")",
          "old_line_content": "            connman->PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(\"alert\", finalAlert));",
          "new_line_content": "            CDataStream finalAlert(ParseHex(\"60010000000000000000000000ffffff7f00000000ffffff7ffeffff7f01ffffff7f00000000ffffff7f00ffffff7f002f555247454e543a20416c657274206b657920636f6d70726f6d697365642c2075706772616465207265717569726564004630440220653febd6410f470f6bae11cad19c48413becb1ac2c17f908fd0fd53bdc3abd5202206d0e9c96fe88d4a0f01ed9dedae2b6f9e00da94cad0fecaae66ecf689bf71b50\"), SER_NETWORK, PROTOCOL_VERSION);",
          "content_same": false
        },
        {
          "line": 1798,
          "old_api": "GetId",
          "new_api": "LOCK",
          "old_text": "pfrom->GetId()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "        Misbehaving(pfrom->GetId(), 1);",
          "new_line_content": "        LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1812,
          "old_api": "GetId",
          "new_api": "LOCK",
          "old_text": "pfrom->GetId()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "            State(pfrom->GetId())->fCurrentlyConnected = true;",
          "new_line_content": "            LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1813,
          "old_api": "load",
          "new_api": "GetId",
          "old_text": "LogPrintf(\"New outbound peer connected: version: %d, blocks=%d, peer=%d%s\\n\",\n                      pfrom->nVersion.load(), pfrom->nStartingHeight, pfrom->GetId(),\n                      (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom->addr.ToString()) : \"\"))",
          "new_text": "pfrom->GetId()",
          "old_line_content": "            LogPrintf(\"New outbound peer connected: version: %d, blocks=%d, peer=%d%s\\n\",",
          "new_line_content": "            State(pfrom->GetId())->fCurrentlyConnected = true;",
          "content_same": false
        },
        {
          "line": 1814,
          "old_api": "GetId",
          "new_api": "load",
          "old_text": "pfrom->GetId()",
          "new_text": "LogPrintf(\"New outbound peer connected: version: %d, blocks=%d, peer=%d%s\\n\",\n                      pfrom->nVersion.load(), pfrom->nStartingHeight, pfrom->GetId(),\n                      (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom->addr.ToString()) : \"\"))",
          "old_line_content": "                      pfrom->nVersion.load(), pfrom->nStartingHeight, pfrom->GetId(),",
          "new_line_content": "            LogPrintf(\"New outbound peer connected: version: %d, blocks=%d, peer=%d%s\\n\",",
          "content_same": false
        },
        {
          "line": 1815,
          "old_api": "ToString",
          "new_api": "GetId",
          "old_text": "pfrom->addr.ToString()",
          "new_text": "pfrom->GetId()",
          "old_line_content": "                      (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom->addr.ToString()) : \"\"));",
          "new_line_content": "                      pfrom->nVersion.load(), pfrom->nStartingHeight, pfrom->GetId(),",
          "content_same": false
        },
        {
          "line": 1834,
          "old_api": "Make",
          "new_api": "GetLocalServices",
          "old_text": "msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion)",
          "new_text": "pfrom->GetLocalServices()",
          "old_line_content": "                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));",
          "new_line_content": "            if (pfrom->GetLocalServices() & NODE_WITNESS)",
          "content_same": false
        },
        {
          "line": 1845,
          "old_api": "GetId",
          "new_api": "LOCK",
          "old_text": "pfrom->GetId()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "        Misbehaving(pfrom->GetId(), 1);",
          "new_line_content": "        LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1859,
          "old_api": "size",
          "new_api": "LOCK",
          "old_text": "vAddr.size()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "            Misbehaving(pfrom->GetId(), 20, strprintf(\"message addr size() = %u\", vAddr.size()));",
          "new_line_content": "            LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1881,
          "old_api": "IsReachable",
          "new_api": "AddAddressKnown",
          "old_text": "IsReachable(addr)",
          "new_text": "pfrom->AddAddressKnown(addr)",
          "old_line_content": "            bool fReachable = IsReachable(addr);",
          "new_line_content": "            pfrom->AddAddressKnown(addr);",
          "content_same": false
        },
        {
          "line": 1882,
          "old_api": "IsRoutable",
          "new_api": "IsReachable",
          "old_text": "addr.IsRoutable()",
          "new_text": "IsReachable(addr)",
          "old_line_content": "            if (addr.nTime > nSince && !pfrom->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())",
          "new_line_content": "            bool fReachable = IsReachable(addr);",
          "content_same": false
        },
        {
          "line": 1892,
          "old_api": "size",
          "new_api": "AddNewAddresses",
          "old_text": "vAddr.size()",
          "new_text": "connman->AddNewAddresses(vAddrOk, pfrom->addr, 2 * 60 * 60)",
          "old_line_content": "        if (vAddr.size() < 1000)",
          "new_line_content": "        connman->AddNewAddresses(vAddrOk, pfrom->addr, 2 * 60 * 60);",
          "content_same": false
        },
        {
          "line": 1901,
          "old_api": "GetId",
          "new_api": "LOCK",
          "old_text": "pfrom->GetId()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "        State(pfrom->GetId())->fPreferHeaders = true;",
          "new_line_content": "        LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1910,
          "old_api": "LOCK",
          "new_api": "GetLocalServices",
          "old_text": "LOCK(cs_main)",
          "new_text": "pfrom->GetLocalServices()",
          "old_line_content": "            LOCK(cs_main);",
          "new_line_content": "        if (nCMPCTBLOCKVersion == 1 || ((pfrom->GetLocalServices() & NODE_WITNESS) && nCMPCTBLOCKVersion == 2)) {",
          "content_same": false
        },
        {
          "line": 1919,
          "old_api": "GetLocalServices",
          "new_api": "GetId",
          "old_text": "pfrom->GetLocalServices()",
          "new_text": "pfrom->GetId()",
          "old_line_content": "                if (pfrom->GetLocalServices() & NODE_WITNESS)",
          "new_line_content": "            if (!State(pfrom->GetId())->fSupportsDesiredCmpctVersion) {",
          "content_same": false
        },
        {
          "line": 1920,
          "old_api": "GetId",
          "new_api": "GetLocalServices",
          "old_text": "pfrom->GetId()",
          "new_text": "pfrom->GetLocalServices()",
          "old_line_content": "                    State(pfrom->GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2);",
          "new_line_content": "                if (pfrom->GetLocalServices() & NODE_WITNESS)",
          "content_same": false
        },
        {
          "line": 1934,
          "old_api": "size",
          "new_api": "LOCK",
          "old_text": "vInv.size()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "            Misbehaving(pfrom->GetId(), 20, strprintf(\"message inv size() = %u\", vInv.size()));",
          "new_line_content": "            LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1954,
          "old_api": "GetId",
          "new_api": "AlreadyHave",
          "old_text": "pfrom->GetId()",
          "new_text": "AlreadyHave(inv)",
          "old_line_content": "            LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->GetId());",
          "new_line_content": "            bool fAlreadyHave = AlreadyHave(inv);",
          "content_same": false
        },
        {
          "line": 1962,
          "old_api": "count",
          "new_api": "GetId",
          "old_text": "mapBlocksInFlight.count(inv.hash)",
          "new_text": "pfrom->GetId()",
          "old_line_content": "                if (!fAlreadyHave && !fImporting && !fReindex && !mapBlocksInFlight.count(inv.hash)) {",
          "new_line_content": "                UpdateBlockAvailability(pfrom->GetId(), inv.hash);",
          "content_same": false
        },
        {
          "line": 1969,
          "old_api": "GetId",
          "new_api": "GetLocator",
          "old_text": "pfrom->GetId()",
          "new_text": "chainActive.GetLocator(pindexBestHeader)",
          "old_line_content": "                    LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->GetId());",
          "new_line_content": "                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash));",
          "content_same": false
        },
        {
          "line": 1977,
          "old_api": "IsInitialBlockDownload",
          "new_api": "GetId",
          "old_text": "IsInitialBlockDownload()",
          "new_text": "pfrom->GetId()",
          "old_line_content": "                } else if (!fAlreadyHave && !fImporting && !fReindex && !IsInitialBlockDownload()) {",
          "new_line_content": "                    LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol peer=%d\\n\", inv.hash.ToString(), pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 1978,
          "old_api": "AskFor",
          "new_api": "IsInitialBlockDownload",
          "old_text": "pfrom->AskFor(inv)",
          "new_text": "IsInitialBlockDownload()",
          "old_line_content": "                    pfrom->AskFor(inv);",
          "new_line_content": "                } else if (!fAlreadyHave && !fImporting && !fReindex && !IsInitialBlockDownload()) {",
          "content_same": false
        },
        {
          "line": 1991,
          "old_api": "size",
          "new_api": "LOCK",
          "old_text": "vInv.size()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "            Misbehaving(pfrom->GetId(), 20, strprintf(\"message getdata size() = %u\", vInv.size()));",
          "new_line_content": "            LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1998,
          "old_api": "GetId",
          "new_api": "size",
          "old_text": "pfrom->GetId()",
          "new_text": "vInv.size()",
          "old_line_content": "            LogPrint(BCLog::NET, \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom->GetId());",
          "new_line_content": "        if (vInv.size() > 0) {",
          "content_same": false
        },
        {
          "line": 2002,
          "old_api": "ProcessGetData",
          "new_api": "end",
          "old_text": "ProcessGetData(pfrom, chainparams, connman, interruptMsgProc)",
          "new_text": "vInv.end()",
          "old_line_content": "        ProcessGetData(pfrom, chainparams, connman, interruptMsgProc);",
          "new_line_content": "        pfrom->vRecvGetData.insert(pfrom->vRecvGetData.end(), vInv.begin(), vInv.end());",
          "content_same": false
        },
        {
          "line": 2012,
          "old_api": "GetId",
          "new_api": "size",
          "old_text": "pfrom->GetId()",
          "new_text": "locator.vHave.size()",
          "old_line_content": "            LogPrint(BCLog::NET, \"getblocks locator size %lld > %d, disconnect peer=%d\\n\", locator.vHave.size(), MAX_LOCATOR_SZ, pfrom->GetId());",
          "new_line_content": "        if (locator.vHave.size() > MAX_LOCATOR_SZ) {",
          "content_same": false
        },
        {
          "line": 2032,
          "old_api": "FormatStateMessage",
          "new_api": "Params",
          "old_text": "FormatStateMessage(state)",
          "new_text": "Params()",
          "old_line_content": "                LogPrint(BCLog::NET, \"failed to activate chain (%s)\\n\", FormatStateMessage(state));",
          "new_line_content": "            if (!ActivateBestChain(state, Params(), a_recent_block)) {",
          "content_same": false
        },
        {
          "line": 2046,
          "old_api": "Next",
          "new_api": "GetId",
          "old_text": "chainActive.Next(pindex)",
          "new_text": "pfrom->GetId()",
          "old_line_content": "        for (; pindex; pindex = chainActive.Next(pindex))",
          "new_line_content": "        LogPrint(BCLog::NET, \"getblocks %d to %s limit %d from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), nLimit, pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2056,
          "old_api": "Tip",
          "new_api": "GetConsensus",
          "old_text": "chainActive.Tip()",
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "            if (fPruneMode && (!(pindex->nStatus & BLOCK_HAVE_DATA) || pindex->nHeight <= chainActive.Tip()->nHeight - nPrunedBlocksLikelyToHave))",
          "new_line_content": "            const int nPrunedBlocksLikelyToHave = MIN_BLOCKS_TO_KEEP - 3600 / chainparams.GetConsensus().nPowTargetSpacing;",
          "content_same": false
        },
        {
          "line": 2067,
          "old_api": "GetBlockHash",
          "new_api": "ToString",
          "old_text": "pindex->GetBlockHash()",
          "new_text": "pindex->GetBlockHash().ToString()",
          "old_line_content": "                pfrom->hashContinue = pindex->GetBlockHash();",
          "new_line_content": "                LogPrint(BCLog::NET, \"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());",
          "content_same": false
        },
        {
          "line": 2117,
          "old_api": "assert",
          "new_api": "GetConsensus",
          "old_text": "assert(ret)",
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "        assert(ret);",
          "new_line_content": "        bool ret = ReadBlockFromDisk(block, pindex, chainparams.GetConsensus());",
          "content_same": false
        },
        {
          "line": 2129,
          "old_api": "GetId",
          "new_api": "size",
          "old_text": "pfrom->GetId()",
          "new_text": "locator.vHave.size()",
          "old_line_content": "            LogPrint(BCLog::NET, \"getheaders locator size %lld > %d, disconnect peer=%d\\n\", locator.vHave.size(), MAX_LOCATOR_SZ, pfrom->GetId());",
          "new_line_content": "        if (locator.vHave.size() > MAX_LOCATOR_SZ) {",
          "content_same": false
        },
        {
          "line": 2135,
          "old_api": "IsInitialBlockDownload",
          "new_api": "LOCK",
          "old_text": "IsInitialBlockDownload()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "        if (IsInitialBlockDownload() && !pfrom->fWhitelisted) {",
          "new_line_content": "        LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2136,
          "old_api": "GetId",
          "new_api": "IsInitialBlockDownload",
          "old_text": "pfrom->GetId()",
          "new_text": "IsInitialBlockDownload()",
          "old_line_content": "            LogPrint(BCLog::NET, \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom->GetId());",
          "new_line_content": "        if (IsInitialBlockDownload() && !pfrom->fWhitelisted) {",
          "content_same": false
        },
        {
          "line": 2151,
          "old_api": "GetId",
          "new_api": "GetConsensus",
          "old_text": "pfrom->GetId()",
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "                LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block header that isn't in the main chain\\n\", __func__, pfrom->GetId());",
          "new_line_content": "            if (!BlockRequestAllowed(pindex, chainparams.GetConsensus())) {",
          "content_same": false
        },
        {
          "line": 2167,
          "old_api": "Next",
          "new_api": "GetId",
          "old_text": "chainActive.Next(pindex)",
          "new_text": "pfrom->GetId()",
          "old_line_content": "        for (; pindex; pindex = chainActive.Next(pindex))",
          "new_line_content": "        LogPrint(BCLog::NET, \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2170,
          "old_api": "GetBlockHash",
          "new_api": "GetBlockHeader",
          "old_text": "pindex->GetBlockHash()",
          "new_text": "pindex->GetBlockHeader()",
          "old_line_content": "            if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)",
          "new_line_content": "            vHeaders.push_back(pindex->GetBlockHeader());",
          "content_same": false
        },
        {
          "line": 2186,
          "old_api": "Make",
          "new_api": "Tip",
          "old_text": "msgMaker.Make(NetMsgType::HEADERS, vHeaders)",
          "new_text": "chainActive.Tip()",
          "old_line_content": "        connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));",
          "new_line_content": "        nodestate->pindexBestHeaderSent = pindex ? pindex : chainActive.Tip();",
          "content_same": false
        },
        {
          "line": 2206,
          "old_api": "AddInventoryKnown",
          "new_api": "GetHash",
          "old_text": "pfrom->AddInventoryKnown(inv)",
          "new_text": "tx.GetHash()",
          "old_line_content": "        pfrom->AddInventoryKnown(inv);",
          "new_line_content": "        CInv inv(MSG_TX, tx.GetHash());",
          "content_same": false
        },
        {
          "line": 2219,
          "old_api": "AcceptToMemoryPool",
          "new_api": "AlreadyHave",
          "old_text": "AcceptToMemoryPool(mempool, state, ptx, &fMissingInputs, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)",
          "new_text": "AlreadyHave(inv)",
          "old_line_content": "            AcceptToMemoryPool(mempool, state, ptx, &fMissingInputs, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {",
          "new_line_content": "        if (!AlreadyHave(inv) &&",
          "content_same": false
        },
        {
          "line": 2220,
          "old_api": "get",
          "new_api": "AcceptToMemoryPool",
          "old_text": "pcoinsTip.get()",
          "new_text": "AcceptToMemoryPool(mempool, state, ptx, &fMissingInputs, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)",
          "old_line_content": "            mempool.check(pcoinsTip.get());",
          "new_line_content": "            AcceptToMemoryPool(mempool, state, ptx, &fMissingInputs, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {",
          "content_same": false
        },
        {
          "line": 2221,
          "old_api": "RelayTransaction",
          "new_api": "get",
          "old_text": "RelayTransaction(tx, connman)",
          "new_text": "pcoinsTip.get()",
          "old_line_content": "            RelayTransaction(tx, connman);",
          "new_line_content": "            mempool.check(pcoinsTip.get());",
          "content_same": false
        },
        {
          "line": 2222,
          "old_api": "size",
          "new_api": "RelayTransaction",
          "old_text": "tx.vout.size()",
          "new_text": "RelayTransaction(tx, connman)",
          "old_line_content": "            for (unsigned int i = 0; i < tx.vout.size(); i++) {",
          "new_line_content": "            RelayTransaction(tx, connman);",
          "content_same": false
        },
        {
          "line": 2223,
          "old_api": "emplace_back",
          "new_api": "size",
          "old_text": "vWorkQueue.emplace_back(inv.hash, i)",
          "new_text": "tx.vout.size()",
          "old_line_content": "                vWorkQueue.emplace_back(inv.hash, i);",
          "new_line_content": "            for (unsigned int i = 0; i < tx.vout.size(); i++) {",
          "content_same": false
        },
        {
          "line": 2229,
          "old_api": "GetId",
          "new_api": "GetHash",
          "old_text": "pfrom->GetId()",
          "new_text": "LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n                pfrom->GetId(),\n                tx.GetHash().ToString(),\n                mempool.size(), mempool.DynamicMemoryUsage() / 1000)",
          "old_line_content": "                pfrom->GetId(),",
          "new_line_content": "            LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",",
          "content_same": false
        },
        {
          "line": 2230,
          "old_api": "GetHash",
          "new_api": "GetId",
          "old_text": "tx.GetHash().ToString()",
          "new_text": "pfrom->GetId()",
          "old_line_content": "                tx.GetHash().ToString(),",
          "new_line_content": "                pfrom->GetId(),",
          "content_same": false
        },
        {
          "line": 2231,
          "old_api": "DynamicMemoryUsage",
          "new_api": "GetHash",
          "old_text": "mempool.DynamicMemoryUsage()",
          "new_text": "tx.GetHash().ToString()",
          "old_line_content": "                mempool.size(), mempool.DynamicMemoryUsage() / 1000);",
          "new_line_content": "                tx.GetHash().ToString(),",
          "content_same": false
        },
        {
          "line": 2236,
          "old_api": "front",
          "new_api": "empty",
          "old_text": "vWorkQueue.front()",
          "new_text": "vWorkQueue.empty()",
          "old_line_content": "                auto itByPrev = mapOrphanTransactionsByPrev.find(vWorkQueue.front());",
          "new_line_content": "            while (!vWorkQueue.empty()) {",
          "content_same": false
        },
        {
          "line": 2237,
          "old_api": "pop_front",
          "new_api": "front",
          "old_text": "vWorkQueue.pop_front()",
          "new_text": "vWorkQueue.front()",
          "old_line_content": "                vWorkQueue.pop_front();",
          "new_line_content": "                auto itByPrev = mapOrphanTransactionsByPrev.find(vWorkQueue.front());",
          "content_same": false
        },
        {
          "line": 2238,
          "old_api": "end",
          "new_api": "pop_front",
          "old_text": "mapOrphanTransactionsByPrev.end()",
          "new_text": "vWorkQueue.pop_front()",
          "old_line_content": "                if (itByPrev == mapOrphanTransactionsByPrev.end())",
          "new_line_content": "                vWorkQueue.pop_front();",
          "content_same": false
        },
        {
          "line": 2241,
          "old_api": "end",
          "new_api": "begin",
          "old_text": "itByPrev->second.end()",
          "new_text": "itByPrev->second.begin()",
          "old_line_content": "                     mi != itByPrev->second.end();",
          "new_line_content": "                for (auto mi = itByPrev->second.begin();",
          "content_same": false
        },
        {
          "line": 2258,
          "old_api": "ToString",
          "new_api": "AcceptToMemoryPool",
          "old_text": "orphanHash.ToString()",
          "new_text": "AcceptToMemoryPool(mempool, stateDummy, porphanTx, &fMissingInputs2, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)",
          "old_line_content": "                        LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());",
          "new_line_content": "                    if (AcceptToMemoryPool(mempool, stateDummy, porphanTx, &fMissingInputs2, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {",
          "content_same": false
        },
        {
          "line": 2259,
          "old_api": "RelayTransaction",
          "new_api": "ToString",
          "old_text": "RelayTransaction(orphanTx, connman)",
          "new_text": "orphanHash.ToString()",
          "old_line_content": "                        RelayTransaction(orphanTx, connman);",
          "new_line_content": "                        LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());",
          "content_same": false
        },
        {
          "line": 2260,
          "old_api": "size",
          "new_api": "RelayTransaction",
          "old_text": "orphanTx.vout.size()",
          "new_text": "RelayTransaction(orphanTx, connman)",
          "old_line_content": "                        for (unsigned int i = 0; i < orphanTx.vout.size(); i++) {",
          "new_line_content": "                        RelayTransaction(orphanTx, connman);",
          "content_same": false
        },
        {
          "line": 2261,
          "old_api": "emplace_back",
          "new_api": "size",
          "old_text": "vWorkQueue.emplace_back(orphanHash, i)",
          "new_text": "orphanTx.vout.size()",
          "old_line_content": "                            vWorkQueue.emplace_back(orphanHash, i);",
          "new_line_content": "                        for (unsigned int i = 0; i < orphanTx.vout.size(); i++) {",
          "content_same": false
        },
        {
          "line": 2272,
          "old_api": "insert",
          "new_api": "Misbehaving",
          "old_text": "setMisbehaving.insert(fromPeer)",
          "new_text": "Misbehaving(fromPeer, nDos)",
          "old_line_content": "                            setMisbehaving.insert(fromPeer);",
          "new_line_content": "                            Misbehaving(fromPeer, nDos);",
          "content_same": false
        },
        {
          "line": 2273,
          "old_api": "ToString",
          "new_api": "insert",
          "old_text": "orphanHash.ToString()",
          "new_text": "setMisbehaving.insert(fromPeer)",
          "old_line_content": "                            LogPrint(BCLog::MEMPOOL, \"   invalid orphan tx %s\\n\", orphanHash.ToString());",
          "new_line_content": "                            setMisbehaving.insert(fromPeer);",
          "content_same": false
        },
        {
          "line": 2278,
          "old_api": "push_back",
          "new_api": "ToString",
          "old_text": "vEraseQueue.push_back(orphanHash)",
          "new_text": "orphanHash.ToString()",
          "old_line_content": "                        vEraseQueue.push_back(orphanHash);",
          "new_line_content": "                        LogPrint(BCLog::MEMPOOL, \"   removed orphan tx %s\\n\", orphanHash.ToString());",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": "CorruptionPossible",
          "new_api": "push_back",
          "old_text": "stateDummy.CorruptionPossible()",
          "new_text": "vEraseQueue.push_back(orphanHash)",
          "old_line_content": "                        if (!orphanTx.HasWitness() && !stateDummy.CorruptionPossible()) {",
          "new_line_content": "                        vEraseQueue.push_back(orphanHash);",
          "content_same": false
        },
        {
          "line": 2284,
          "old_api": "insert",
          "new_api": "assert",
          "old_text": "recentRejects->insert(orphanHash)",
          "new_text": "assert(recentRejects)",
          "old_line_content": "                            recentRejects->insert(orphanHash);",
          "new_line_content": "                            assert(recentRejects);",
          "content_same": false
        },
        {
          "line": 2308,
          "old_api": "AskFor",
          "new_api": "AddInventoryKnown",
          "old_text": "pfrom->AskFor(_inv)",
          "new_text": "pfrom->AddInventoryKnown(_inv)",
          "old_line_content": "                    if (!AlreadyHave(_inv)) pfrom->AskFor(_inv);",
          "new_line_content": "                    pfrom->AddInventoryKnown(_inv);",
          "content_same": false
        },
        {
          "line": 2314,
          "old_api": "LimitOrphanTxSize",
          "new_api": "GetArg",
          "old_text": "LimitOrphanTxSize(nMaxOrphanTx)",
          "new_text": "gArgs.GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS)",
          "old_line_content": "                unsigned int nEvicted = LimitOrphanTxSize(nMaxOrphanTx);",
          "new_line_content": "                unsigned int nMaxOrphanTx = (unsigned int)std::max((int64_t)0, gArgs.GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS));",
          "content_same": false
        },
        {
          "line": 2330,
          "old_api": "GetHash",
          "new_api": "assert",
          "old_text": "tx.GetHash()",
          "new_text": "assert(recentRejects)",
          "old_line_content": "                recentRejects->insert(tx.GetHash());",
          "new_line_content": "                assert(recentRejects);",
          "content_same": false
        },
        {
          "line": 2331,
          "old_api": "RecursiveDynamicUsage",
          "new_api": "GetHash",
          "old_text": "RecursiveDynamicUsage(*ptx)",
          "new_text": "tx.GetHash()",
          "old_line_content": "                if (RecursiveDynamicUsage(*ptx) < 100000) {",
          "new_line_content": "                recentRejects->insert(tx.GetHash());",
          "content_same": false
        },
        {
          "line": 2332,
          "old_api": "AddToCompactExtraTransactions",
          "new_api": "RecursiveDynamicUsage",
          "old_text": "AddToCompactExtraTransactions(ptx)",
          "new_text": "RecursiveDynamicUsage(*ptx)",
          "old_line_content": "                    AddToCompactExtraTransactions(ptx);",
          "new_line_content": "                if (RecursiveDynamicUsage(*ptx) < 100000) {",
          "content_same": false
        },
        {
          "line": 2335,
          "old_api": "AddToCompactExtraTransactions",
          "new_api": "RecursiveDynamicUsage",
          "old_text": "AddToCompactExtraTransactions(ptx)",
          "new_text": "RecursiveDynamicUsage(*ptx)",
          "old_line_content": "                AddToCompactExtraTransactions(ptx);",
          "new_line_content": "            } else if (tx.HasWitness() && RecursiveDynamicUsage(*ptx) < 100000) {",
          "content_same": false
        },
        {
          "line": 2349,
          "old_api": "GetId",
          "new_api": "IsInvalid",
          "old_text": "pfrom->GetId()",
          "new_text": "state.IsInvalid(nDoS)",
          "old_line_content": "                    LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());",
          "new_line_content": "                if (!state.IsInvalid(nDoS) || nDoS == 0) {",
          "content_same": false
        },
        {
          "line": 2350,
          "old_api": "RelayTransaction",
          "new_api": "GetId",
          "old_text": "RelayTransaction(tx, connman)",
          "new_text": "pfrom->GetId()",
          "old_line_content": "                    RelayTransaction(tx, connman);",
          "new_line_content": "                    LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2381,
          "old_api": "GetId",
          "new_api": "GetHash",
          "old_text": "pfrom->GetId()",
          "new_text": "tx.GetHash().ToString()",
          "old_line_content": "                pfrom->GetId(),",
          "new_line_content": "            LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),",
          "content_same": false
        },
        {
          "line": 2382,
          "old_api": "FormatStateMessage",
          "new_api": "GetId",
          "old_text": "FormatStateMessage(state)",
          "new_text": "pfrom->GetId()",
          "old_line_content": "                FormatStateMessage(state));",
          "new_line_content": "                pfrom->GetId(),",
          "content_same": false
        },
        {
          "line": 2383,
          "old_api": "GetRejectCode",
          "new_api": "FormatStateMessage",
          "old_text": "state.GetRejectCode()",
          "new_text": "FormatStateMessage(state)",
          "old_line_content": "            if (enable_bip61 && state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) { // Never send AcceptToMemoryPool's internal codes over P2P",
          "new_line_content": "                FormatStateMessage(state));",
          "content_same": false
        },
        {
          "line": 2385,
          "old_api": "GetRejectReason",
          "new_api": "GetRejectCode",
          "old_text": "state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH)",
          "new_text": "state.GetRejectCode()",
          "old_line_content": "                                   state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash));",
          "new_line_content": "                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),",
          "content_same": false
        },
        {
          "line": 2407,
          "old_api": "uint256",
          "new_api": "IsInitialBlockDownload",
          "old_text": "uint256()",
          "new_text": "IsInitialBlockDownload()",
          "old_line_content": "                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));",
          "new_line_content": "            if (!IsInitialBlockDownload())",
          "content_same": false
        },
        {
          "line": 2423,
          "old_api": "GetId",
          "new_api": "LOCK",
          "old_text": "pfrom->GetId()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "                    Misbehaving(pfrom->GetId(), nDoS, strprintf(\"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->GetId()));",
          "new_line_content": "                    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2451,
          "old_api": "GetBlockHash",
          "new_api": "assert",
          "old_text": "pindex->GetBlockHash()",
          "new_text": "assert(pindex)",
          "old_line_content": "        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());",
          "new_line_content": "        assert(pindex);",
          "content_same": false
        },
        {
          "line": 2458,
          "old_api": "GetTime",
          "new_api": "Tip",
          "old_text": "GetTime()",
          "new_text": "chainActive.Tip()",
          "old_line_content": "            nodestate->m_last_block_announcement = GetTime();",
          "new_line_content": "        if (received_new_header && pindex->nChainWork > chainActive.Tip()->nChainWork) {",
          "content_same": false
        },
        {
          "line": 2462,
          "old_api": "end",
          "new_api": "GetBlockHash",
          "old_text": "mapBlocksInFlight.end()",
          "new_text": "pindex->GetBlockHash()",
          "old_line_content": "        bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();",
          "new_line_content": "        std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());",
          "content_same": false
        },
        {
          "line": 2474,
          "old_api": "Make",
          "new_api": "GetHash",
          "old_text": "msgMaker.Make(NetMsgType::GETDATA, vInv)",
          "new_text": "cmpctblock.header.GetHash()",
          "old_line_content": "                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));",
          "new_line_content": "                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());",
          "content_same": false
        },
        {
          "line": 2509,
          "old_api": "GetId",
          "new_api": "GetBlockHash",
          "old_text": "pfrom->GetId()",
          "new_text": "pindex->GetBlockHash()",
          "old_line_content": "                    Misbehaving(pfrom->GetId(), 100, strprintf(\"Peer %d sent us invalid compact block\\n\", pfrom->GetId()));",
          "new_line_content": "                    MarkBlockAsReceived(pindex->GetBlockHash()); // Reset in-flight state in case of whitelist",
          "content_same": false
        },
        {
          "line": 2515,
          "old_api": "Make",
          "new_api": "GetHash",
          "old_text": "msgMaker.Make(NetMsgType::GETDATA, vInv)",
          "new_text": "cmpctblock.header.GetHash()",
          "old_line_content": "                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));",
          "new_line_content": "                    vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());",
          "content_same": false
        },
        {
          "line": 2521,
          "old_api": "IsTxAvailable",
          "new_api": "BlockTxCount",
          "old_text": "partialBlock.IsTxAvailable(i)",
          "new_text": "cmpctblock.BlockTxCount()",
          "old_line_content": "                    if (!partialBlock.IsTxAvailable(i))",
          "new_line_content": "                for (size_t i = 0; i < cmpctblock.BlockTxCount(); i++) {",
          "content_same": false
        },
        {
          "line": 2522,
          "old_api": "push_back",
          "new_api": "IsTxAvailable",
          "old_text": "req.indexes.push_back(i)",
          "new_text": "partialBlock.IsTxAvailable(i)",
          "old_line_content": "                        req.indexes.push_back(i);",
          "new_line_content": "                    if (!partialBlock.IsTxAvailable(i))",
          "content_same": false
        },
        {
          "line": 2532,
          "old_api": "Make",
          "new_api": "GetBlockHash",
          "old_text": "msgMaker.Make(NetMsgType::GETBLOCKTXN, req)",
          "new_text": "pindex->GetBlockHash()",
          "old_line_content": "                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETBLOCKTXN, req));",
          "new_line_content": "                    req.blockhash = pindex->GetBlockHash();",
          "content_same": false
        },
        {
          "line": 2558,
          "old_api": "Make",
          "new_api": "GetHash",
          "old_text": "msgMaker.Make(NetMsgType::GETDATA, vInv)",
          "new_text": "cmpctblock.header.GetHash()",
          "old_line_content": "                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));",
          "new_line_content": "                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());",
          "content_same": false
        },
        {
          "line": 2584,
          "old_api": "GetId",
          "new_api": "LOCK",
          "old_text": "pfrom->GetId()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "                mapBlockSource.emplace(pblock->GetHash(), std::make_pair(pfrom->GetId(), false));",
          "new_line_content": "                LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2601,
          "old_api": "GetHash",
          "new_api": "LOCK",
          "old_text": "pblock->GetHash()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "                mapBlockSource.erase(pblock->GetHash());",
          "new_line_content": "                LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2604,
          "old_api": "IsValid",
          "new_api": "LOCK",
          "old_text": "pindex->IsValid(BLOCK_VALID_TRANSACTIONS)",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "            if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS)) {",
          "new_line_content": "            LOCK(cs_main); // hold cs_main for CBlockIndex::IsValid()",
          "content_same": false
        },
        {
          "line": 2626,
          "old_api": "end",
          "new_api": "find",
          "old_text": "mapBlocksInFlight.end()",
          "new_text": "mapBlocksInFlight.find(resp.blockhash)",
          "old_line_content": "            if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||",
          "new_line_content": "            std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);",
          "content_same": false
        },
        {
          "line": 2627,
          "old_api": "GetId",
          "new_api": "end",
          "old_text": "pfrom->GetId()",
          "new_text": "mapBlocksInFlight.end()",
          "old_line_content": "                    it->second.first != pfrom->GetId()) {",
          "new_line_content": "            if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||",
          "content_same": false
        },
        {
          "line": 2636,
          "old_api": "GetId",
          "new_api": "MarkBlockAsReceived",
          "old_text": "pfrom->GetId()",
          "new_text": "MarkBlockAsReceived(resp.blockhash)",
          "old_line_content": "                Misbehaving(pfrom->GetId(), 100, strprintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->GetId()));",
          "new_line_content": "                MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case of whitelist",
          "content_same": false
        },
        {
          "line": 2642,
          "old_api": "Make",
          "new_api": "GetFetchFlags",
          "old_text": "msgMaker.Make(NetMsgType::GETDATA, invs)",
          "new_text": "GetFetchFlags(pfrom)",
          "old_line_content": "                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));",
          "new_line_content": "                invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom), resp.blockhash));",
          "content_same": false
        },
        {
          "line": 2684,
          "old_api": "GetHash",
          "new_api": "LOCK",
          "old_text": "pblock->GetHash()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "                mapBlockSource.erase(pblock->GetHash());",
          "new_line_content": "                LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2698,
          "old_api": "strprintf",
          "new_api": "LOCK",
          "old_text": "strprintf(\"headers message size = %u\", nCount)",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "            Misbehaving(pfrom->GetId(), 20, strprintf(\"headers message size = %u\", nCount));",
          "new_line_content": "            LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2739,
          "old_api": "GetHash",
          "new_api": "LOCK",
          "old_text": "pblock->GetHash()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "            mapBlockSource.erase(pblock->GetHash());",
          "new_line_content": "            LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2764,
          "old_api": "GetAddresses",
          "new_api": "clear",
          "old_text": "connman->GetAddresses()",
          "new_text": "pfrom->vAddrToSend.clear()",
          "old_line_content": "        std::vector<CAddress> vAddr = connman->GetAddresses();",
          "new_line_content": "        pfrom->vAddrToSend.clear();",
          "content_same": false
        },
        {
          "line": 2855,
          "old_api": "GetId",
          "new_api": "empty",
          "old_text": "LogPrint(BCLog::NET, \"pong peer=%d: %s, %x expected, %x received, %u bytes\\n\",\n                pfrom->GetId(),\n                sProblem,\n                pfrom->nPingNonceSent,\n                nonce,\n                nAvail)",
          "new_text": "sProblem.empty()",
          "old_line_content": "            LogPrint(BCLog::NET, \"pong peer=%d: %s, %x expected, %x received, %u bytes\\n\",",
          "new_line_content": "        if (!(sProblem.empty())) {",
          "content_same": false
        },
        {
          "line": 2876,
          "old_api": "GetId",
          "new_api": "LOCK",
          "old_text": "pfrom->GetId()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "            Misbehaving(pfrom->GetId(), 100);",
          "new_line_content": "            LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2881,
          "old_api": "reset",
          "new_api": "LOCK",
          "old_text": "pfrom->pfilter.reset(new CBloomFilter(filter))",
          "new_text": "LOCK(pfrom->cs_filter)",
          "old_line_content": "            pfrom->pfilter.reset(new CBloomFilter(filter));",
          "new_line_content": "            LOCK(pfrom->cs_filter);",
          "content_same": false
        },
        {
          "line": 2882,
          "old_api": "UpdateEmptyFull",
          "new_api": "reset",
          "old_text": "pfrom->pfilter->UpdateEmptyFull()",
          "new_text": "pfrom->pfilter.reset(new CBloomFilter(filter))",
          "old_line_content": "            pfrom->pfilter->UpdateEmptyFull();",
          "new_line_content": "            pfrom->pfilter.reset(new CBloomFilter(filter));",
          "content_same": false
        },
        {
          "line": 2907,
          "old_api": "GetId",
          "new_api": "LOCK",
          "old_text": "pfrom->GetId()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "            Misbehaving(pfrom->GetId(), 100);",
          "new_line_content": "            LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2914,
          "old_api": "GetLocalServices",
          "new_api": "LOCK",
          "old_text": "pfrom->GetLocalServices()",
          "new_text": "LOCK(pfrom->cs_filter)",
          "old_line_content": "        if (pfrom->GetLocalServices() & NODE_BLOOM) {",
          "new_line_content": "        LOCK(pfrom->cs_filter);",
          "content_same": false
        },
        {
          "line": 2915,
          "old_api": "reset",
          "new_api": "GetLocalServices",
          "old_text": "pfrom->pfilter.reset(new CBloomFilter())",
          "new_text": "pfrom->GetLocalServices()",
          "old_line_content": "            pfrom->pfilter.reset(new CBloomFilter());",
          "new_line_content": "        if (pfrom->GetLocalServices() & NODE_BLOOM) {",
          "content_same": false
        },
        {
          "line": 2948,
          "old_api": "GetId",
          "new_api": "AssertLockHeld",
          "old_text": "pnode->GetId()",
          "new_text": "AssertLockHeld(cs_main)",
          "old_line_content": "    CNodeState &state = *State(pnode->GetId());",
          "new_line_content": "    AssertLockHeld(cs_main);",
          "content_same": false
        },
        {
          "line": 2966,
          "old_api": "ToString",
          "new_api": "IsLocal",
          "old_text": "pnode->addr.ToString()",
          "new_text": "pnode->addr.IsLocal()",
          "old_line_content": "                LogPrintf(\"Warning: not banning local peer %s!\\n\", pnode->addr.ToString());",
          "new_line_content": "            if (pnode->addr.IsLocal())",
          "content_same": false
        },
        {
          "line": 2991,
          "old_api": "ProcessGetData",
          "new_api": "empty",
          "old_text": "ProcessGetData(pfrom, chainparams, connman, interruptMsgProc)",
          "new_text": "pfrom->vRecvGetData.empty()",
          "old_line_content": "        ProcessGetData(pfrom, chainparams, connman, interruptMsgProc);",
          "new_line_content": "    if (!pfrom->vRecvGetData.empty())",
          "content_same": false
        },
        {
          "line": 3006,
          "old_api": "empty",
          "new_api": "LOCK",
          "old_text": "pfrom->vProcessMsg.empty()",
          "new_text": "LOCK(pfrom->cs_vProcessMsg)",
          "old_line_content": "        if (pfrom->vProcessMsg.empty())",
          "new_line_content": "        LOCK(pfrom->cs_vProcessMsg);",
          "content_same": false
        },
        {
          "line": 3010,
          "old_api": "front",
          "new_api": "begin",
          "old_text": "msgs.front().vRecv.size()",
          "new_text": "pfrom->vProcessMsg.begin()",
          "old_line_content": "        pfrom->nProcessQueueSize -= msgs.front().vRecv.size() + CMessageHeader::HEADER_SIZE;",
          "new_line_content": "        msgs.splice(msgs.begin(), pfrom->vProcessMsg, pfrom->vProcessMsg.begin());",
          "content_same": false
        },
        {
          "line": 3011,
          "old_api": "GetReceiveFloodSize",
          "new_api": "front",
          "old_text": "connman->GetReceiveFloodSize()",
          "new_text": "msgs.front().vRecv.size()",
          "old_line_content": "        pfrom->fPauseRecv = pfrom->nProcessQueueSize > connman->GetReceiveFloodSize();",
          "new_line_content": "        pfrom->nProcessQueueSize -= msgs.front().vRecv.size() + CMessageHeader::HEADER_SIZE;",
          "content_same": false
        },
        {
          "line": 3012,
          "old_api": "empty",
          "new_api": "GetReceiveFloodSize",
          "old_text": "pfrom->vProcessMsg.empty()",
          "new_text": "connman->GetReceiveFloodSize()",
          "old_line_content": "        fMoreWork = !pfrom->vProcessMsg.empty();",
          "new_line_content": "        pfrom->fPauseRecv = pfrom->nProcessQueueSize > connman->GetReceiveFloodSize();",
          "content_same": false
        },
        {
          "line": 3019,
          "old_api": "GetId",
          "new_api": "MessageStart",
          "old_text": "pfrom->GetId()",
          "new_text": "chainparams.MessageStart()",
          "old_line_content": "        LogPrint(BCLog::NET, \"PROCESSMESSAGE: INVALID MESSAGESTART %s peer=%d\\n\", SanitizeString(msg.hdr.GetCommand()), pfrom->GetId());",
          "new_line_content": "    if (memcmp(msg.hdr.pchMessageStart, chainparams.MessageStart(), CMessageHeader::MESSAGE_START_SIZE) != 0) {",
          "content_same": false
        },
        {
          "line": 3039,
          "old_api": "begin",
          "new_api": "GetMessageHash",
          "old_text": "hash.begin()",
          "new_text": "msg.GetMessageHash()",
          "old_line_content": "    if (memcmp(hash.begin(), hdr.pchChecksum, CMessageHeader::CHECKSUM_SIZE) != 0)",
          "new_line_content": "    const uint256& hash = msg.GetMessageHash();",
          "content_same": false
        },
        {
          "line": 3042,
          "old_api": "SanitizeString",
          "new_api": "begin",
          "old_text": "SanitizeString(strCommand)",
          "new_text": "LogPrint(BCLog::NET, \"%s(%s, %u bytes): CHECKSUM ERROR expected %s was %s\\n\", __func__,\n           SanitizeString(strCommand), nMessageSize,\n           HexStr(hash.begin(), hash.begin()+CMessageHeader::CHECKSUM_SIZE),\n           HexStr(hdr.pchChecksum, hdr.pchChecksum+CMessageHeader::CHECKSUM_SIZE))",
          "old_line_content": "           SanitizeString(strCommand), nMessageSize,",
          "new_line_content": "        LogPrint(BCLog::NET, \"%s(%s, %u bytes): CHECKSUM ERROR expected %s was %s\\n\", __func__,",
          "content_same": false
        },
        {
          "line": 3043,
          "old_api": "begin",
          "new_api": "SanitizeString",
          "old_text": "hash.begin()",
          "new_text": "SanitizeString(strCommand)",
          "old_line_content": "           HexStr(hash.begin(), hash.begin()+CMessageHeader::CHECKSUM_SIZE),",
          "new_line_content": "           SanitizeString(strCommand), nMessageSize,",
          "content_same": false
        },
        {
          "line": 3044,
          "old_api": "HexStr",
          "new_api": "begin",
          "old_text": "HexStr(hdr.pchChecksum, hdr.pchChecksum+CMessageHeader::CHECKSUM_SIZE)",
          "new_text": "hash.begin()",
          "old_line_content": "           HexStr(hdr.pchChecksum, hdr.pchChecksum+CMessageHeader::CHECKSUM_SIZE));",
          "new_line_content": "           HexStr(hash.begin(), hash.begin()+CMessageHeader::CHECKSUM_SIZE),",
          "content_same": false
        },
        {
          "line": 3094,
          "old_api": "SendRejectsAndCheckIfBanned",
          "new_api": "LOCK",
          "old_text": "SendRejectsAndCheckIfBanned(pfrom, connman, m_enable_bip61)",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "    SendRejectsAndCheckIfBanned(pfrom, connman, m_enable_bip61);",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 3104,
          "old_api": "GetSendVersion",
          "new_api": "GetId",
          "old_text": "pto->GetSendVersion()",
          "new_text": "pto->GetId()",
          "old_line_content": "    const CNetMsgMaker msgMaker(pto->GetSendVersion());",
          "new_line_content": "    CNodeState &state = *State(pto->GetId());",
          "content_same": false
        },
        {
          "line": 3137,
          "old_api": "ToString",
          "new_api": "assert",
          "old_text": "state.m_chain_sync.m_work_header->GetBlockHash().ToString()",
          "new_text": "assert(state.m_chain_sync.m_work_header)",
          "old_line_content": "                LogPrint(BCLog::NET, \"sending getheaders to outbound peer=%d to verify chain work (current best known block:%s, benchmark blockhash: %s)\\n\", pto->GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\", state.m_chain_sync.m_work_header->GetBlockHash().ToString());",
          "new_line_content": "                assert(state.m_chain_sync.m_work_header);",
          "content_same": false
        },
        {
          "line": 3138,
          "old_api": "uint256",
          "new_api": "ToString",
          "old_text": "uint256()",
          "new_text": "state.m_chain_sync.m_work_header->GetBlockHash().ToString()",
          "old_line_content": "                connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(state.m_chain_sync.m_work_header->pprev), uint256()));",
          "new_line_content": "                LogPrint(BCLog::NET, \"sending getheaders to outbound peer=%d to verify chain work (current best known block:%s, benchmark blockhash: %s)\\n\", pto->GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\", state.m_chain_sync.m_work_header->GetBlockHash().ToString());",
          "content_same": false
        },
        {
          "line": 3165,
          "old_api": "AssertLockHeld",
          "new_api": "ForEachNode",
          "old_text": "AssertLockHeld(cs_main)",
          "new_text": "connman->ForEachNode([&](CNode* pnode) {\n            AssertLockHeld(cs_main);\n\n            // Ignore non-outbound peers, or nodes marked for disconnect already\n            if (!IsOutboundDisconnectionCandidate(pnode) || pnode->fDisconnect) return;\n            CNodeState *state = State(pnode->GetId());\n            if (state == nullptr) return; // shouldn't be possible, but just in case\n            // Don't evict our protected peers\n            if (state->m_chain_sync.m_protect) return;\n            if (state->m_last_block_announcement < oldest_block_announcement || (state->m_last_block_announcement == oldest_block_announcement && pnode->GetId() > worst_peer)) {\n                worst_peer = pnode->GetId();\n                oldest_block_announcement = state->m_last_block_announcement;\n            }\n        })",
          "old_line_content": "            AssertLockHeld(cs_main);",
          "new_line_content": "        connman->ForEachNode([&](CNode* pnode) {",
          "content_same": false
        },
        {
          "line": 3169,
          "old_api": "GetId",
          "new_api": "IsOutboundDisconnectionCandidate",
          "old_text": "pnode->GetId()",
          "new_text": "IsOutboundDisconnectionCandidate(pnode)",
          "old_line_content": "            CNodeState *state = State(pnode->GetId());",
          "new_line_content": "            if (!IsOutboundDisconnectionCandidate(pnode) || pnode->fDisconnect) return;",
          "content_same": false
        },
        {
          "line": 3180,
          "old_api": "AssertLockHeld",
          "new_api": "ForNode",
          "old_text": "AssertLockHeld(cs_main)",
          "new_text": "connman->ForNode(worst_peer, [&](CNode *pnode) {\n                AssertLockHeld(cs_main);\n\n                // Only disconnect a peer that has been connected to us for\n                // some reasonable fraction of our check-frequency, to give\n                // it time for new information to have arrived.\n                // Also don't disconnect any peer we're trying to download a\n                // block from.\n                CNodeState &state = *State(pnode->GetId());\n                if (time_in_seconds - pnode->nTimeConnected > MINIMUM_CONNECT_TIME && state.nBlocksInFlight == 0) {\n                    LogPrint(BCLog::NET, \"disconnecting extra outbound peer=%d (last block announcement received at time %d)\\n\", pnode->GetId(), oldest_block_announcement);\n                    pnode->fDisconnect = true;\n                    return true;\n                } else {\n                    LogPrint(BCLog::NET, \"keeping outbound peer=%d chosen for eviction (connect time: %d, blocks_in_flight: %d)\\n\", pnode->GetId(), pnode->nTimeConnected, state.nBlocksInFlight);\n                    return false;\n                }\n            })",
          "old_line_content": "                AssertLockHeld(cs_main);",
          "new_line_content": "            bool disconnected = connman->ForNode(worst_peer, [&](CNode *pnode) {",
          "content_same": false
        },
        {
          "line": 3223,
          "old_api": "LogPrintf",
          "new_api": "TipMayBeStale",
          "old_text": "LogPrintf(\"Potential stale tip detected, will try using extra outbound peer (last tip update: %d seconds ago)\\n\", time_in_seconds - g_last_tip_update)",
          "new_text": "TipMayBeStale(consensusParams)",
          "old_line_content": "            LogPrintf(\"Potential stale tip detected, will try using extra outbound peer (last tip update: %d seconds ago)\\n\", time_in_seconds - g_last_tip_update);",
          "new_line_content": "        if (!fImporting && !fReindex && connman->GetNetworkActive() && connman->GetUseAddrmanOutgoing() && TipMayBeStale(consensusParams)) {",
          "content_same": false
        },
        {
          "line": 3224,
          "old_api": "SetTryNewOutboundPeer",
          "new_api": "LogPrintf",
          "old_text": "connman->SetTryNewOutboundPeer(true)",
          "new_text": "LogPrintf(\"Potential stale tip detected, will try using extra outbound peer (last tip update: %d seconds ago)\\n\", time_in_seconds - g_last_tip_update)",
          "old_line_content": "            connman->SetTryNewOutboundPeer(true);",
          "new_line_content": "            LogPrintf(\"Potential stale tip detected, will try using extra outbound peer (last tip update: %d seconds ago)\\n\", time_in_seconds - g_last_tip_update);",
          "content_same": false
        },
        {
          "line": 3225,
          "old_api": "GetTryNewOutboundPeer",
          "new_api": "SetTryNewOutboundPeer",
          "old_text": "connman->GetTryNewOutboundPeer()",
          "new_text": "connman->SetTryNewOutboundPeer(true)",
          "old_line_content": "        } else if (connman->GetTryNewOutboundPeer()) {",
          "new_line_content": "            connman->SetTryNewOutboundPeer(true);",
          "content_same": false
        },
        {
          "line": 3226,
          "old_api": "SetTryNewOutboundPeer",
          "new_api": "GetTryNewOutboundPeer",
          "old_text": "connman->SetTryNewOutboundPeer(false)",
          "new_text": "connman->GetTryNewOutboundPeer()",
          "old_line_content": "            connman->SetTryNewOutboundPeer(false);",
          "new_line_content": "        } else if (connman->GetTryNewOutboundPeer()) {",
          "content_same": false
        },
        {
          "line": 3301,
          "old_api": "IsInitialBlockDownload",
          "new_api": "GetTimeMicros",
          "old_text": "IsInitialBlockDownload()",
          "new_text": "GetTimeMicros()",
          "old_line_content": "        if (!IsInitialBlockDownload() && pto->nNextLocalAddrSend < nNow) {",
          "new_line_content": "        int64_t nNow = GetTimeMicros();",
          "content_same": false
        },
        {
          "line": 3302,
          "old_api": "AdvertiseLocal",
          "new_api": "IsInitialBlockDownload",
          "old_text": "AdvertiseLocal(pto)",
          "new_text": "IsInitialBlockDownload()",
          "old_line_content": "            AdvertiseLocal(pto);",
          "new_line_content": "        if (!IsInitialBlockDownload() && pto->nNextLocalAddrSend < nNow) {",
          "content_same": false
        },
        {
          "line": 3303,
          "old_api": "PoissonNextSend",
          "new_api": "AdvertiseLocal",
          "old_text": "PoissonNextSend(nNow, AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL)",
          "new_text": "AdvertiseLocal(pto)",
          "old_line_content": "            pto->nNextLocalAddrSend = PoissonNextSend(nNow, AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL);",
          "new_line_content": "            AdvertiseLocal(pto);",
          "content_same": false
        },
        {
          "line": 3318,
          "old_api": "push_back",
          "new_api": "GetKey",
          "old_text": "vAddr.push_back(addr)",
          "new_text": "addr.GetKey()",
          "old_line_content": "                    vAddr.push_back(addr);",
          "new_line_content": "                    pto->addrKnown.insert(addr.GetKey());",
          "content_same": false
        },
        {
          "line": 3323,
          "old_api": "clear",
          "new_api": "Make",
          "old_text": "vAddr.clear()",
          "new_text": "msgMaker.Make(NetMsgType::ADDR, vAddr)",
          "old_line_content": "                        vAddr.clear();",
          "new_line_content": "                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));",
          "content_same": false
        },
        {
          "line": 3328,
          "old_api": "empty",
          "new_api": "clear",
          "old_text": "vAddr.empty()",
          "new_text": "pto->vAddrToSend.clear()",
          "old_line_content": "            if (!vAddr.empty())",
          "new_line_content": "            pto->vAddrToSend.clear();",
          "content_same": false
        },
        {
          "line": 3329,
          "old_api": "Make",
          "new_api": "empty",
          "old_text": "msgMaker.Make(NetMsgType::ADDR, vAddr)",
          "new_text": "vAddr.empty()",
          "old_line_content": "                connman->PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));",
          "new_line_content": "            if (!vAddr.empty())",
          "content_same": false
        },
        {
          "line": 3332,
          "old_api": "shrink_to_fit",
          "new_api": "capacity",
          "old_text": "pto->vAddrToSend.shrink_to_fit()",
          "new_text": "pto->vAddrToSend.capacity()",
          "old_line_content": "                pto->vAddrToSend.shrink_to_fit();",
          "new_line_content": "            if (pto->vAddrToSend.capacity() > 40)",
          "content_same": false
        },
        {
          "line": 3356,
          "old_api": "uint256",
          "new_api": "GetId",
          "old_text": "uint256()",
          "new_text": "pto->GetId()",
          "old_line_content": "                connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256()));",
          "new_line_content": "                LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->GetId(), pto->nStartingHeight);",
          "content_same": false
        },
        {
          "line": 3394,
          "old_api": "assert",
          "new_api": "LookupBlockIndex",
          "old_text": "assert(pindex)",
          "new_text": "LookupBlockIndex(hash)",
          "old_line_content": "                    assert(pindex);",
          "new_line_content": "                    const CBlockIndex* pindex = LookupBlockIndex(hash);",
          "content_same": false
        },
        {
          "line": 3419,
          "old_api": "PeerHasHeader",
          "new_api": "GetBlockHeader",
          "old_text": "PeerHasHeader(&state, pindex)",
          "new_text": "pindex->GetBlockHeader()",
          "old_line_content": "                    } else if (PeerHasHeader(&state, pindex)) {",
          "new_line_content": "                        vHeaders.push_back(pindex->GetBlockHeader());",
          "content_same": false
        },
        {
          "line": 3435,
          "old_api": "size",
          "new_api": "empty",
          "old_text": "vHeaders.size()",
          "new_text": "vHeaders.empty()",
          "old_line_content": "                if (vHeaders.size() == 1 && state.fPreferHeaderAndIDs) {",
          "new_line_content": "            if (!fRevertToInv && !vHeaders.empty()) {",
          "content_same": false
        },
        {
          "line": 3439,
          "old_api": "GetId",
          "new_api": "front",
          "old_text": "pto->GetId()",
          "new_text": "LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", __func__,\n                            vHeaders.front().GetHash().ToString(), pto->GetId())",
          "old_line_content": "                            vHeaders.front().GetHash().ToString(), pto->GetId());",
          "new_line_content": "                    LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", __func__,",
          "content_same": false
        },
        {
          "line": 3446,
          "old_api": "GetBlockHash",
          "new_api": "LOCK",
          "old_text": "pBestIndex->GetBlockHash()",
          "new_text": "LOCK(cs_most_recent_block)",
          "old_line_content": "                        if (most_recent_block_hash == pBestIndex->GetBlockHash()) {",
          "new_line_content": "                        LOCK(cs_most_recent_block);",
          "content_same": false
        },
        {
          "line": 3459,
          "old_api": "assert",
          "new_api": "ReadBlockFromDisk",
          "old_text": "assert(ret)",
          "new_text": "ReadBlockFromDisk(block, pBestIndex, consensusParams)",
          "old_line_content": "                        assert(ret);",
          "new_line_content": "                        bool ret = ReadBlockFromDisk(block, pBestIndex, consensusParams);",
          "content_same": false
        },
        {
          "line": 3468,
          "old_api": "front",
          "new_api": "size",
          "old_text": "vHeaders.front().GetHash().ToString()",
          "new_text": "vHeaders.size()",
          "old_line_content": "                                vHeaders.front().GetHash().ToString(),",
          "new_line_content": "                                vHeaders.size(),",
          "content_same": false
        },
        {
          "line": 3469,
          "old_api": "GetId",
          "new_api": "front",
          "old_text": "pto->GetId()",
          "new_text": "vHeaders.front().GetHash().ToString()",
          "old_line_content": "                                vHeaders.back().GetHash().ToString(), pto->GetId());",
          "new_line_content": "                                vHeaders.front().GetHash().ToString(),",
          "content_same": false
        },
        {
          "line": 3472,
          "old_api": "GetId",
          "new_api": "front",
          "old_text": "pto->GetId()",
          "new_text": "LogPrint(BCLog::NET, \"%s: sending header %s to peer=%d\\n\", __func__,\n                                vHeaders.front().GetHash().ToString(), pto->GetId())",
          "old_line_content": "                                vHeaders.front().GetHash().ToString(), pto->GetId());",
          "new_line_content": "                        LogPrint(BCLog::NET, \"%s: sending header %s to peer=%d\\n\", __func__,",
          "content_same": false
        },
        {
          "line": 3484,
          "old_api": "back",
          "new_api": "empty",
          "old_text": "pto->vBlockHashesToAnnounce.back()",
          "new_text": "pto->vBlockHashesToAnnounce.empty()",
          "old_line_content": "                    const uint256 &hashToAnnounce = pto->vBlockHashesToAnnounce.back();",
          "new_line_content": "                if (!pto->vBlockHashesToAnnounce.empty()) {",
          "content_same": false
        },
        {
          "line": 3485,
          "old_api": "LookupBlockIndex",
          "new_api": "back",
          "old_text": "LookupBlockIndex(hashToAnnounce)",
          "new_text": "pto->vBlockHashesToAnnounce.back()",
          "old_line_content": "                    const CBlockIndex* pindex = LookupBlockIndex(hashToAnnounce);",
          "new_line_content": "                    const uint256 &hashToAnnounce = pto->vBlockHashesToAnnounce.back();",
          "content_same": false
        },
        {
          "line": 3486,
          "old_api": "assert",
          "new_api": "LookupBlockIndex",
          "old_text": "assert(pindex)",
          "new_text": "LookupBlockIndex(hashToAnnounce)",
          "old_line_content": "                    assert(pindex);",
          "new_line_content": "                    const CBlockIndex* pindex = LookupBlockIndex(hashToAnnounce);",
          "content_same": false
        },
        {
          "line": 3493,
          "old_api": "Tip",
          "new_api": "ToString",
          "old_text": "chainActive.Tip()->GetBlockHash().ToString()",
          "new_text": "LogPrint(BCLog::NET, \"Announcing block %s not on main chain (tip=%s)\\n\",\n                            hashToAnnounce.ToString(), chainActive.Tip()->GetBlockHash().ToString())",
          "old_line_content": "                            hashToAnnounce.ToString(), chainActive.Tip()->GetBlockHash().ToString());",
          "new_line_content": "                        LogPrint(BCLog::NET, \"Announcing block %s not on main chain (tip=%s)\\n\",",
          "content_same": false
        },
        {
          "line": 3498,
          "old_api": "CInv",
          "new_api": "PeerHasHeader",
          "old_text": "CInv(MSG_BLOCK, hashToAnnounce)",
          "new_text": "PeerHasHeader(&state, pindex)",
          "old_line_content": "                        pto->PushInventory(CInv(MSG_BLOCK, hashToAnnounce));",
          "new_line_content": "                    if (!PeerHasHeader(&state, pindex)) {",
          "content_same": false
        },
        {
          "line": 3499,
          "old_api": "ToString",
          "new_api": "CInv",
          "old_text": "LogPrint(BCLog::NET, \"%s: sending inv peer=%d hash=%s\\n\", __func__,\n                            pto->GetId(), hashToAnnounce.ToString())",
          "new_text": "CInv(MSG_BLOCK, hashToAnnounce)",
          "old_line_content": "                        LogPrint(BCLog::NET, \"%s: sending inv peer=%d hash=%s\\n\", __func__,",
          "new_line_content": "                        pto->PushInventory(CInv(MSG_BLOCK, hashToAnnounce));",
          "content_same": false
        },
        {
          "line": 3513,
          "old_api": "size",
          "new_api": "LOCK",
          "old_text": "pto->vInventoryBlockToSend.size()",
          "new_text": "LOCK(pto->cs_inventory)",
          "old_line_content": "            vInv.reserve(std::max<size_t>(pto->vInventoryBlockToSend.size(), INVENTORY_BROADCAST_MAX));",
          "new_line_content": "            LOCK(pto->cs_inventory);",
          "content_same": false
        },
        {
          "line": 3518,
          "old_api": "size",
          "new_api": "CInv",
          "old_text": "vInv.size()",
          "new_text": "CInv(MSG_BLOCK, hash)",
          "old_line_content": "                if (vInv.size() == MAX_INV_SZ) {",
          "new_line_content": "                vInv.push_back(CInv(MSG_BLOCK, hash));",
          "content_same": false
        },
        {
          "line": 3519,
          "old_api": "Make",
          "new_api": "size",
          "old_text": "msgMaker.Make(NetMsgType::INV, vInv)",
          "new_text": "vInv.size()",
          "old_line_content": "                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));",
          "new_line_content": "                if (vInv.size() == MAX_INV_SZ) {",
          "content_same": false
        },
        {
          "line": 3520,
          "old_api": "clear",
          "new_api": "Make",
          "old_text": "vInv.clear()",
          "new_text": "msgMaker.Make(NetMsgType::INV, vInv)",
          "old_line_content": "                    vInv.clear();",
          "new_line_content": "                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));",
          "content_same": false
        },
        {
          "line": 3540,
          "old_api": "clear",
          "new_api": "LOCK",
          "old_text": "pto->setInventoryTxToSend.clear()",
          "new_text": "LOCK(pto->cs_filter)",
          "old_line_content": "                if (!pto->fRelayTxes) pto->setInventoryTxToSend.clear();",
          "new_line_content": "                LOCK(pto->cs_filter);",
          "content_same": false
        },
        {
          "line": 3567,
          "old_api": "push_back",
          "new_api": "insert",
          "old_text": "vInv.push_back(inv)",
          "new_text": "pto->filterInventoryKnown.insert(hash)",
          "old_line_content": "                    vInv.push_back(inv);",
          "new_line_content": "                    pto->filterInventoryKnown.insert(hash);",
          "content_same": false
        },
        {
          "line": 3568,
          "old_api": "size",
          "new_api": "push_back",
          "old_text": "vInv.size()",
          "new_text": "vInv.push_back(inv)",
          "old_line_content": "                    if (vInv.size() == MAX_INV_SZ) {",
          "new_line_content": "                    vInv.push_back(inv);",
          "content_same": false
        },
        {
          "line": 3569,
          "old_api": "Make",
          "new_api": "size",
          "old_text": "msgMaker.Make(NetMsgType::INV, vInv)",
          "new_text": "vInv.size()",
          "old_line_content": "                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));",
          "new_line_content": "                    if (vInv.size() == MAX_INV_SZ) {",
          "content_same": false
        },
        {
          "line": 3570,
          "old_api": "clear",
          "new_api": "Make",
          "old_text": "vInv.clear()",
          "new_text": "msgMaker.Make(NetMsgType::INV, vInv)",
          "old_line_content": "                        vInv.clear();",
          "new_line_content": "                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));",
          "content_same": false
        },
        {
          "line": 3581,
          "old_api": "end",
          "new_api": "size",
          "old_text": "pto->setInventoryTxToSend.end()",
          "new_text": "pto->setInventoryTxToSend.size()",
          "old_line_content": "                for (std::set<uint256>::iterator it = pto->setInventoryTxToSend.begin(); it != pto->setInventoryTxToSend.end(); it++) {",
          "new_line_content": "                vInvTx.reserve(pto->setInventoryTxToSend.size());",
          "content_same": false
        },
        {
          "line": 3582,
          "old_api": "push_back",
          "new_api": "end",
          "old_text": "vInvTx.push_back(it)",
          "new_text": "pto->setInventoryTxToSend.end()",
          "old_line_content": "                    vInvTx.push_back(it);",
          "new_line_content": "                for (std::set<uint256>::iterator it = pto->setInventoryTxToSend.begin(); it != pto->setInventoryTxToSend.end(); it++) {",
          "content_same": false
        },
        {
          "line": 3597,
          "old_api": "empty",
          "new_api": "LOCK",
          "old_text": "vInvTx.empty()",
          "new_text": "LOCK(pto->cs_filter)",
          "old_line_content": "                while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {",
          "new_line_content": "                LOCK(pto->cs_filter);",
          "content_same": false
        },
        {
          "line": 3600,
          "old_api": "back",
          "new_api": "end",
          "old_text": "vInvTx.back()",
          "new_text": "vInvTx.end()",
          "old_line_content": "                    std::set<uint256>::iterator it = vInvTx.back();",
          "new_line_content": "                    std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);",
          "content_same": false
        },
        {
          "line": 3601,
          "old_api": "pop_back",
          "new_api": "back",
          "old_text": "vInvTx.pop_back()",
          "new_text": "vInvTx.back()",
          "old_line_content": "                    vInvTx.pop_back();",
          "new_line_content": "                    std::set<uint256>::iterator it = vInvTx.back();",
          "content_same": false
        },
        {
          "line": 3626,
          "old_api": "pop_front",
          "new_api": "front",
          "old_text": "vRelayExpiration.pop_front()",
          "new_text": "vRelayExpiration.front()",
          "old_line_content": "                            vRelayExpiration.pop_front();",
          "new_line_content": "                            mapRelay.erase(vRelayExpiration.front().second);",
          "content_same": false
        },
        {
          "line": 3635,
          "old_api": "Make",
          "new_api": "size",
          "old_text": "msgMaker.Make(NetMsgType::INV, vInv)",
          "new_text": "vInv.size()",
          "old_line_content": "                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));",
          "new_line_content": "                    if (vInv.size() == MAX_INV_SZ) {",
          "content_same": false
        },
        {
          "line": 3636,
          "old_api": "clear",
          "new_api": "Make",
          "old_text": "vInv.clear()",
          "new_text": "msgMaker.Make(NetMsgType::INV, vInv)",
          "old_line_content": "                        vInv.clear();",
          "new_line_content": "                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));",
          "content_same": false
        },
        {
          "line": 3643,
          "old_api": "Make",
          "new_api": "empty",
          "old_text": "msgMaker.Make(NetMsgType::INV, vInv)",
          "new_text": "vInv.empty()",
          "old_line_content": "            connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));",
          "new_line_content": "        if (!vInv.empty())",
          "content_same": false
        },
        {
          "line": 3661,
          "old_api": "front",
          "new_api": "size",
          "old_text": "state.vBlocksInFlight.front()",
          "new_text": "state.vBlocksInFlight.size()",
          "old_line_content": "            QueuedBlock &queuedBlock = state.vBlocksInFlight.front();",
          "new_line_content": "        if (state.vBlocksInFlight.size() > 0) {",
          "content_same": false
        },
        {
          "line": 3716,
          "old_api": "GetBlockHash",
          "new_api": "GetFetchFlags",
          "old_text": "pindex->GetBlockHash()",
          "new_text": "GetFetchFlags(pto)",
          "old_line_content": "                vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));",
          "new_line_content": "                uint32_t nFetchFlags = GetFetchFlags(pto);",
          "content_same": false
        },
        {
          "line": 3718,
          "old_api": "ToString",
          "new_api": "GetBlockHash",
          "old_text": "pindex->GetBlockHash().ToString()",
          "new_text": "pindex->GetBlockHash()",
          "old_line_content": "                LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),",
          "new_line_content": "                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);",
          "content_same": false
        },
        {
          "line": 3719,
          "old_api": "GetId",
          "new_api": "ToString",
          "old_text": "pto->GetId()",
          "new_text": "pindex->GetBlockHash().ToString()",
          "old_line_content": "                    pindex->nHeight, pto->GetId());",
          "new_line_content": "                LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),",
          "content_same": false
        },
        {
          "line": 3724,
          "old_api": "LogPrint",
          "new_api": "State",
          "old_text": "LogPrint(BCLog::NET, \"Stall started peer=%d\\n\", staller)",
          "new_text": "State(staller)",
          "old_line_content": "                    LogPrint(BCLog::NET, \"Stall started peer=%d\\n\", staller);",
          "new_line_content": "                    State(staller)->nStallingSince = nNow;",
          "content_same": false
        },
        {
          "line": 3735,
          "old_api": "AlreadyHave",
          "new_api": "begin",
          "old_text": "AlreadyHave(inv)",
          "new_text": "pto->mapAskFor.begin()",
          "old_line_content": "            if (!AlreadyHave(inv))",
          "new_line_content": "            const CInv& inv = (*pto->mapAskFor.begin()).second;",
          "content_same": false
        },
        {
          "line": 3738,
          "old_api": "push_back",
          "new_api": "GetId",
          "old_text": "vGetData.push_back(inv)",
          "new_text": "pto->GetId()",
          "old_line_content": "                vGetData.push_back(inv);",
          "new_line_content": "                LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());",
          "content_same": false
        },
        {
          "line": 3739,
          "old_api": "size",
          "new_api": "push_back",
          "old_text": "vGetData.size()",
          "new_text": "vGetData.push_back(inv)",
          "old_line_content": "                if (vGetData.size() >= 1000)",
          "new_line_content": "                vGetData.push_back(inv);",
          "content_same": false
        },
        {
          "line": 3742,
          "old_api": "clear",
          "new_api": "Make",
          "old_text": "vGetData.clear()",
          "new_text": "msgMaker.Make(NetMsgType::GETDATA, vGetData)",
          "old_line_content": "                    vGetData.clear();",
          "new_line_content": "                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));",
          "content_same": false
        },
        {
          "line": 3751,
          "old_api": "Make",
          "new_api": "empty",
          "old_text": "msgMaker.Make(NetMsgType::GETDATA, vGetData)",
          "new_text": "vGetData.empty()",
          "old_line_content": "            connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));",
          "new_line_content": "        if (!vGetData.empty())",
          "content_same": false
        },
        {
          "line": 3759,
          "old_api": "GetArg",
          "new_api": "GetBoolArg",
          "old_text": "gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE)",
          "new_text": "gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)",
          "old_line_content": "            CAmount currentFilter = mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();",
          "new_line_content": "            !(pto->fWhitelisted && gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY))) {",
          "content_same": false
        },
        {
          "line": 3760,
          "old_api": "GetTimeMicros",
          "new_api": "GetArg",
          "old_text": "GetTimeMicros()",
          "new_text": "gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE)",
          "old_line_content": "            int64_t timeNow = GetTimeMicros();",
          "new_line_content": "            CAmount currentFilter = mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2049,
          "old_api": null,
          "new_api": "GetBlockHash",
          "old_text": null,
          "new_text": "pindex->GetBlockHash()",
          "old_line_content": "            {",
          "new_line_content": "            if (pindex->GetBlockHash() == hashStop)",
          "content_same": false
        },
        {
          "line": 2051,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pindex->GetBlockHash().ToString()",
          "old_line_content": "                break;",
          "new_line_content": "                LogPrint(BCLog::NET, \"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());",
          "content_same": false
        },
        {
          "line": 2057,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "            {",
          "new_line_content": "            if (fPruneMode && (!(pindex->nStatus & BLOCK_HAVE_DATA) || pindex->nHeight <= chainActive.Tip()->nHeight - nPrunedBlocksLikelyToHave))",
          "content_same": false
        },
        {
          "line": 2059,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pindex->GetBlockHash().ToString()",
          "old_line_content": "                break;",
          "new_line_content": "                LogPrint(BCLog::NET, \" getblocks stopping, pruned or too old block at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());",
          "content_same": false
        },
        {
          "line": 2062,
          "old_api": null,
          "new_api": "GetBlockHash",
          "old_text": null,
          "new_text": "pindex->GetBlockHash()",
          "old_line_content": "            if (--nLimit <= 0)",
          "new_line_content": "            pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));",
          "content_same": false
        },
        {
          "line": 2068,
          "old_api": null,
          "new_api": "GetBlockHash",
          "old_text": null,
          "new_text": "pindex->GetBlockHash()",
          "old_line_content": "                break;",
          "new_line_content": "                pfrom->hashContinue = pindex->GetBlockHash();",
          "content_same": false
        },
        {
          "line": 2081,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_most_recent_block)",
          "old_line_content": "            if (most_recent_block_hash == req.blockhash)",
          "new_line_content": "            LOCK(cs_most_recent_block);",
          "content_same": false
        },
        {
          "line": 2087,
          "old_api": null,
          "new_api": "SendBlockTransactions",
          "old_text": null,
          "new_text": "SendBlockTransactions(*recent_block, req, pfrom, connman)",
          "old_line_content": "            return true;",
          "new_line_content": "            SendBlockTransactions(*recent_block, req, pfrom, connman);",
          "content_same": false
        },
        {
          "line": 2091,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "",
          "new_line_content": "        LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2093,
          "old_api": null,
          "new_api": "LookupBlockIndex",
          "old_text": null,
          "new_text": "LookupBlockIndex(req.blockhash)",
          "old_line_content": "        if (!pindex || !(pindex->nStatus & BLOCK_HAVE_DATA)) {",
          "new_line_content": "        const CBlockIndex* pindex = LookupBlockIndex(req.blockhash);",
          "content_same": false
        },
        {
          "line": 2095,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            return true;",
          "new_line_content": "            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block we don't have\\n\", pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2099,
          "old_api": null,
          "new_api": "Height",
          "old_text": null,
          "new_text": "chainActive.Height()",
          "old_line_content": "            // If an older block is requested (should never happen in practice,",
          "new_line_content": "        if (pindex->nHeight < chainActive.Height() - MAX_BLOCKTXN_DEPTH) {",
          "content_same": false
        },
        {
          "line": 2107,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            CInv inv;",
          "new_line_content": "            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block > %i deep\\n\", pfrom->GetId(), MAX_BLOCKTXN_DEPTH);",
          "content_same": false
        },
        {
          "line": 2109,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            inv.hash = req.blockhash;",
          "new_line_content": "            inv.type = State(pfrom->GetId())->fWantsCmpctWitness ? MSG_WITNESS_BLOCK : MSG_BLOCK;",
          "content_same": false
        },
        {
          "line": 2111,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "pfrom->vRecvGetData.push_back(inv)",
          "old_line_content": "            // The message processing loop will go around again (without pausing) and we'll respond then (without cs_main)",
          "new_line_content": "            pfrom->vRecvGetData.push_back(inv);",
          "content_same": false
        },
        {
          "line": 2118,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(ret)",
          "old_line_content": "",
          "new_line_content": "        assert(ret);",
          "content_same": false
        },
        {
          "line": 2120,
          "old_api": null,
          "new_api": "SendBlockTransactions",
          "old_text": null,
          "new_text": "SendBlockTransactions(block, req, pfrom, connman)",
          "old_line_content": "        return true;",
          "new_line_content": "        SendBlockTransactions(block, req, pfrom, connman);",
          "content_same": false
        },
        {
          "line": 2130,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            pfrom->fDisconnect = true;",
          "new_line_content": "            LogPrint(BCLog::NET, \"getheaders locator size %lld > %d, disconnect peer=%d\\n\", locator.vHave.size(), MAX_LOCATOR_SZ, pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2137,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            return true;",
          "new_line_content": "            LogPrint(BCLog::NET, \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2141,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "        const CBlockIndex* pindex = nullptr;",
          "new_line_content": "        CNodeState *nodestate = State(pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2143,
          "old_api": null,
          "new_api": "IsNull",
          "old_text": null,
          "new_text": "locator.IsNull()",
          "old_line_content": "        {",
          "new_line_content": "        if (locator.IsNull())",
          "content_same": false
        },
        {
          "line": 2146,
          "old_api": null,
          "new_api": "LookupBlockIndex",
          "old_text": null,
          "new_text": "LookupBlockIndex(hashStop)",
          "old_line_content": "            if (!pindex) {",
          "new_line_content": "            pindex = LookupBlockIndex(hashStop);",
          "content_same": false
        },
        {
          "line": 2152,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "                return true;",
          "new_line_content": "                LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block header that isn't in the main chain\\n\", __func__, pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2159,
          "old_api": null,
          "new_api": "FindForkInGlobalIndex",
          "old_text": null,
          "new_text": "FindForkInGlobalIndex(chainActive, locator)",
          "old_line_content": "            if (pindex)",
          "new_line_content": "            pindex = FindForkInGlobalIndex(chainActive, locator);",
          "content_same": false
        },
        {
          "line": 2161,
          "old_api": null,
          "new_api": "Next",
          "old_text": null,
          "new_text": "chainActive.Next(pindex)",
          "old_line_content": "        }",
          "new_line_content": "                pindex = chainActive.Next(pindex);",
          "content_same": false
        },
        {
          "line": 2168,
          "old_api": null,
          "new_api": "Next",
          "old_text": null,
          "new_text": "chainActive.Next(pindex)",
          "old_line_content": "        {",
          "new_line_content": "        for (; pindex; pindex = chainActive.Next(pindex))",
          "content_same": false
        },
        {
          "line": 2171,
          "old_api": null,
          "new_api": "GetBlockHash",
          "old_text": null,
          "new_text": "pindex->GetBlockHash()",
          "old_line_content": "                break;",
          "new_line_content": "            if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)",
          "content_same": false
        },
        {
          "line": 2187,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::HEADERS, vHeaders)",
          "old_line_content": "        return true;",
          "new_line_content": "        connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));",
          "content_same": false
        },
        {
          "line": 2194,
          "old_api": null,
          "new_api": "GetBoolArg",
          "old_text": null,
          "new_text": "gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)",
          "old_line_content": "        {",
          "new_line_content": "        if (!fRelayTxes && (!pfrom->fWhitelisted || !gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)))",
          "content_same": false
        },
        {
          "line": 2196,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            return true;",
          "new_line_content": "            LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2207,
          "old_api": null,
          "new_api": "AddInventoryKnown",
          "old_text": null,
          "new_text": "pfrom->AddInventoryKnown(inv)",
          "old_line_content": "",
          "new_line_content": "        pfrom->AddInventoryKnown(inv);",
          "content_same": false
        },
        {
          "line": 2209,
          "old_api": null,
          "new_api": "LOCK2",
          "old_text": null,
          "new_text": "LOCK2(cs_main, g_cs_orphans)",
          "old_line_content": "",
          "new_line_content": "        LOCK2(cs_main, g_cs_orphans);",
          "content_same": false
        },
        {
          "line": 2215,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "mapAlreadyAskedFor.erase(inv.hash)",
          "old_line_content": "",
          "new_line_content": "        mapAlreadyAskedFor.erase(inv.hash);",
          "content_same": false
        },
        {
          "line": 2224,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "vWorkQueue.emplace_back(inv.hash, i)",
          "old_line_content": "            }",
          "new_line_content": "                vWorkQueue.emplace_back(inv.hash, i);",
          "content_same": false
        },
        {
          "line": 2227,
          "old_api": null,
          "new_api": "GetTime",
          "old_text": null,
          "new_text": "GetTime()",
          "old_line_content": "",
          "new_line_content": "            pfrom->nLastTXTime = GetTime();",
          "content_same": false
        },
        {
          "line": 2232,
          "old_api": null,
          "new_api": "DynamicMemoryUsage",
          "old_text": null,
          "new_text": "mempool.DynamicMemoryUsage()",
          "old_line_content": "",
          "new_line_content": "                mempool.size(), mempool.DynamicMemoryUsage() / 1000);",
          "content_same": false
        },
        {
          "line": 2239,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapOrphanTransactionsByPrev.end()",
          "old_line_content": "                    continue;",
          "new_line_content": "                if (itByPrev == mapOrphanTransactionsByPrev.end())",
          "content_same": false
        },
        {
          "line": 2242,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "itByPrev->second.end()",
          "old_line_content": "                     ++mi)",
          "new_line_content": "                     mi != itByPrev->second.end();",
          "content_same": false
        },
        {
          "line": 2247,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "orphanTx.GetHash()",
          "old_line_content": "                    NodeId fromPeer = (*mi)->second.fromPeer;",
          "new_line_content": "                    const uint256& orphanHash = orphanTx.GetHash();",
          "content_same": false
        },
        {
          "line": 2256,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "setMisbehaving.count(fromPeer)",
          "old_line_content": "                        continue;",
          "new_line_content": "                    if (setMisbehaving.count(fromPeer))",
          "content_same": false
        },
        {
          "line": 2262,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "vWorkQueue.emplace_back(orphanHash, i)",
          "old_line_content": "                        }",
          "new_line_content": "                            vWorkQueue.emplace_back(orphanHash, i);",
          "content_same": false
        },
        {
          "line": 2264,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "vEraseQueue.push_back(orphanHash)",
          "old_line_content": "                    }",
          "new_line_content": "                        vEraseQueue.push_back(orphanHash);",
          "content_same": false
        },
        {
          "line": 2269,
          "old_api": null,
          "new_api": "IsInvalid",
          "old_text": null,
          "new_text": "stateDummy.IsInvalid(nDos)",
          "old_line_content": "                        {",
          "new_line_content": "                        if (stateDummy.IsInvalid(nDos) && nDos > 0)",
          "content_same": false
        },
        {
          "line": 2274,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "orphanHash.ToString()",
          "old_line_content": "                        }",
          "new_line_content": "                            LogPrint(BCLog::MEMPOOL, \"   invalid orphan tx %s\\n\", orphanHash.ToString());",
          "content_same": false
        },
        {
          "line": 2280,
          "old_api": null,
          "new_api": "CorruptionPossible",
          "old_text": null,
          "new_text": "stateDummy.CorruptionPossible()",
          "old_line_content": "                            // Do not use rejection cache for witness transactions or",
          "new_line_content": "                        if (!orphanTx.HasWitness() && !stateDummy.CorruptionPossible()) {",
          "content_same": false
        },
        {
          "line": 2285,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "recentRejects->insert(orphanHash)",
          "old_line_content": "                        }",
          "new_line_content": "                            recentRejects->insert(orphanHash);",
          "content_same": false
        },
        {
          "line": 2288,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "pcoinsTip.get()",
          "old_line_content": "                }",
          "new_line_content": "                    mempool.check(pcoinsTip.get());",
          "content_same": false
        },
        {
          "line": 2293,
          "old_api": null,
          "new_api": "EraseOrphanTx",
          "old_text": null,
          "new_text": "EraseOrphanTx(hash)",
          "old_line_content": "        }",
          "new_line_content": "                EraseOrphanTx(hash);",
          "content_same": false
        },
        {
          "line": 2299,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "recentRejects->contains(txin.prevout.hash)",
          "old_line_content": "                    fRejectedParents = true;",
          "new_line_content": "                if (recentRejects->contains(txin.prevout.hash)) {",
          "content_same": false
        },
        {
          "line": 2305,
          "old_api": null,
          "new_api": "GetFetchFlags",
          "old_text": null,
          "new_text": "GetFetchFlags(pfrom)",
          "old_line_content": "                for (const CTxIn& txin : tx.vin) {",
          "new_line_content": "                uint32_t nFetchFlags = GetFetchFlags(pfrom);",
          "content_same": false
        },
        {
          "line": 2309,
          "old_api": null,
          "new_api": "AskFor",
          "old_text": null,
          "new_text": "pfrom->AskFor(_inv)",
          "old_line_content": "                }",
          "new_line_content": "                    if (!AlreadyHave(_inv)) pfrom->AskFor(_inv);",
          "content_same": false
        },
        {
          "line": 2311,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "",
          "new_line_content": "                AddOrphanTx(ptx, pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2315,
          "old_api": null,
          "new_api": "LimitOrphanTxSize",
          "old_text": null,
          "new_text": "LimitOrphanTxSize(nMaxOrphanTx)",
          "old_line_content": "                if (nEvicted > 0) {",
          "new_line_content": "                unsigned int nEvicted = LimitOrphanTxSize(nMaxOrphanTx);",
          "content_same": false
        },
        {
          "line": 2317,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::MEMPOOL, \"mapOrphan overflow, removed %u tx\\n\", nEvicted)",
          "old_line_content": "                }",
          "new_line_content": "                    LogPrint(BCLog::MEMPOOL, \"mapOrphan overflow, removed %u tx\\n\", nEvicted);",
          "content_same": false
        },
        {
          "line": 2320,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "tx.GetHash().ToString()",
          "old_line_content": "                // We will continue to reject this tx since it has rejected",
          "new_line_content": "                LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s\\n\",tx.GetHash().ToString());",
          "content_same": false
        },
        {
          "line": 2323,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "tx.GetHash()",
          "old_line_content": "            }",
          "new_line_content": "                recentRejects->insert(tx.GetHash());",
          "content_same": false
        },
        {
          "line": 2326,
          "old_api": null,
          "new_api": "CorruptionPossible",
          "old_text": null,
          "new_text": "state.CorruptionPossible()",
          "old_line_content": "                // Do not use rejection cache for witness transactions or",
          "new_line_content": "            if (!tx.HasWitness() && !state.CorruptionPossible()) {",
          "content_same": false
        },
        {
          "line": 2333,
          "old_api": null,
          "new_api": "AddToCompactExtraTransactions",
          "old_text": null,
          "new_text": "AddToCompactExtraTransactions(ptx)",
          "old_line_content": "                }",
          "new_line_content": "                    AddToCompactExtraTransactions(ptx);",
          "content_same": false
        },
        {
          "line": 2336,
          "old_api": null,
          "new_api": "AddToCompactExtraTransactions",
          "old_text": null,
          "new_text": "AddToCompactExtraTransactions(ptx)",
          "old_line_content": "            }",
          "new_line_content": "                AddToCompactExtraTransactions(ptx);",
          "content_same": false
        },
        {
          "line": 2339,
          "old_api": null,
          "new_api": "GetBoolArg",
          "old_text": null,
          "new_text": "gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)",
          "old_line_content": "                // Always relay transactions received from whitelisted peers, even",
          "new_line_content": "            if (pfrom->fWhitelisted && gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) {",
          "content_same": false
        },
        {
          "line": 2351,
          "old_api": null,
          "new_api": "RelayTransaction",
          "old_text": null,
          "new_text": "RelayTransaction(tx, connman)",
          "old_line_content": "                } else {",
          "new_line_content": "                    RelayTransaction(tx, connman);",
          "content_same": false
        },
        {
          "line": 2353,
          "old_api": null,
          "new_api": "FormatStateMessage",
          "old_text": null,
          "new_text": "FormatStateMessage(state)",
          "old_line_content": "                }",
          "new_line_content": "                    LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->GetId(), FormatStateMessage(state));",
          "content_same": false
        },
        {
          "line": 2359,
          "old_api": null,
          "new_api": "AddToCompactExtraTransactions",
          "old_text": null,
          "new_text": "AddToCompactExtraTransactions(removedTx)",
          "old_line_content": "",
          "new_line_content": "            AddToCompactExtraTransactions(removedTx);",
          "content_same": false
        },
        {
          "line": 2379,
          "old_api": null,
          "new_api": "IsInvalid",
          "old_text": null,
          "new_text": "state.IsInvalid(nDoS)",
          "old_line_content": "        {",
          "new_line_content": "        if (state.IsInvalid(nDoS))",
          "content_same": false
        },
        {
          "line": 2386,
          "old_api": null,
          "new_api": "GetRejectReason",
          "old_text": null,
          "new_text": "state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH)",
          "old_line_content": "            }",
          "new_line_content": "                                   state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash));",
          "content_same": false
        },
        {
          "line": 2389,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            }",
          "new_line_content": "                Misbehaving(pfrom->GetId(), nDoS);",
          "content_same": false
        },
        {
          "line": 2403,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "",
          "new_line_content": "        LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2405,
          "old_api": null,
          "new_api": "LookupBlockIndex",
          "old_text": null,
          "new_text": "LookupBlockIndex(cmpctblock.header.hashPrevBlock)",
          "old_line_content": "            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers",
          "new_line_content": "        if (!LookupBlockIndex(cmpctblock.header.hashPrevBlock)) {",
          "content_same": false
        },
        {
          "line": 2408,
          "old_api": null,
          "new_api": "uint256",
          "old_text": null,
          "new_text": "uint256()",
          "old_line_content": "            return true;",
          "new_line_content": "                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));",
          "content_same": false
        },
        {
          "line": 2412,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "cmpctblock.header.GetHash()",
          "old_line_content": "            received_new_header = true;",
          "new_line_content": "        if (!LookupBlockIndex(cmpctblock.header.GetHash())) {",
          "content_same": false
        },
        {
          "line": 2419,
          "old_api": null,
          "new_api": "ProcessNewBlockHeaders",
          "old_text": null,
          "new_text": "ProcessNewBlockHeaders({cmpctblock.header}, state, chainparams, &pindex)",
          "old_line_content": "            int nDoS;",
          "new_line_content": "        if (!ProcessNewBlockHeaders({cmpctblock.header}, state, chainparams, &pindex)) {",
          "content_same": false
        },
        {
          "line": 2421,
          "old_api": null,
          "new_api": "IsInvalid",
          "old_text": null,
          "new_text": "state.IsInvalid(nDoS)",
          "old_line_content": "                if (nDoS > 0) {",
          "new_line_content": "            if (state.IsInvalid(nDoS)) {",
          "content_same": false
        },
        {
          "line": 2424,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "                } else {",
          "new_line_content": "                    Misbehaving(pfrom->GetId(), nDoS, strprintf(\"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->GetId()));",
          "content_same": false
        },
        {
          "line": 2426,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "                }",
          "new_line_content": "                    LogPrint(BCLog::NET, \"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": null,
          "new_api": "std::make_shared<CBlock>()",
          "old_text": null,
          "new_text": "std::make_shared<CBlock>()",
          "old_line_content": "        bool fBlockReconstructed = false;",
          "new_line_content": "        std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();",
          "content_same": false
        },
        {
          "line": 2449,
          "old_api": null,
          "new_api": "LOCK2",
          "old_text": null,
          "new_text": "LOCK2(cs_main, g_cs_orphans)",
          "old_line_content": "        // If AcceptBlockHeader returned true, it set pindex",
          "new_line_content": "        LOCK2(cs_main, g_cs_orphans);",
          "content_same": false
        },
        {
          "line": 2452,
          "old_api": null,
          "new_api": "GetBlockHash",
          "old_text": null,
          "new_text": "pindex->GetBlockHash()",
          "old_line_content": "",
          "new_line_content": "        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());",
          "content_same": false
        },
        {
          "line": 2454,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "",
          "new_line_content": "        CNodeState *nodestate = State(pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2459,
          "old_api": null,
          "new_api": "GetTime",
          "old_text": null,
          "new_text": "GetTime()",
          "old_line_content": "        }",
          "new_line_content": "            nodestate->m_last_block_announcement = GetTime();",
          "content_same": false
        },
        {
          "line": 2463,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapBlocksInFlight.end()",
          "old_line_content": "",
          "new_line_content": "        bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();",
          "content_same": false
        },
        {
          "line": 2468,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "                pindex->nTx != 0) { // We had this block at some point, but pruned it",
          "new_line_content": "        if (pindex->nChainWork <= chainActive.Tip()->nChainWork || // We know something better",
          "content_same": false
        },
        {
          "line": 2475,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::GETDATA, vInv)",
          "old_line_content": "            }",
          "new_line_content": "                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));",
          "content_same": false
        },
        {
          "line": 2481,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "            return true;",
          "new_line_content": "        if (!fAlreadyInFlight && !CanDirectFetch(chainparams.GetConsensus()))",
          "content_same": false
        },
        {
          "line": 2484,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "            // Don't bother trying to process compact blocks from v1 peers",
          "new_line_content": "        if (IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) && !nodestate->fSupportsDesiredCmpctVersion) {",
          "content_same": false
        },
        {
          "line": 2492,
          "old_api": null,
          "new_api": "Height",
          "old_text": null,
          "new_text": "chainActive.Height()",
          "old_line_content": "            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||",
          "new_line_content": "        if (pindex->nHeight <= chainActive.Height() + 2) {",
          "content_same": false
        },
        {
          "line": 2494,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "                std::list<QueuedBlock>::iterator* queuedBlockIt = nullptr;",
          "new_line_content": "                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {",
          "content_same": false
        },
        {
          "line": 2496,
          "old_api": null,
          "new_api": "GetBlockHash",
          "old_text": null,
          "new_text": "pindex->GetBlockHash()",
          "old_line_content": "                    if (!(*queuedBlockIt)->partialBlock)",
          "new_line_content": "                if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {",
          "content_same": false
        },
        {
          "line": 2498,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool))",
          "old_line_content": "                    else {",
          "new_line_content": "                        (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));",
          "content_same": false
        },
        {
          "line": 2501,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::NET, \"Peer sent us compact block we were already syncing!\\n\")",
          "old_line_content": "                        return true;",
          "new_line_content": "                        LogPrint(BCLog::NET, \"Peer sent us compact block we were already syncing!\\n\");",
          "content_same": false
        },
        {
          "line": 2507,
          "old_api": null,
          "new_api": "InitData",
          "old_text": null,
          "new_text": "partialBlock.InitData(cmpctblock, vExtraTxnForCompact)",
          "old_line_content": "                if (status == READ_STATUS_INVALID) {",
          "new_line_content": "                ReadStatus status = partialBlock.InitData(cmpctblock, vExtraTxnForCompact);",
          "content_same": false
        },
        {
          "line": 2510,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "                    return true;",
          "new_line_content": "                    Misbehaving(pfrom->GetId(), 100, strprintf(\"Peer %d sent us invalid compact block\\n\", pfrom->GetId()));",
          "content_same": false
        },
        {
          "line": 2516,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::GETDATA, vInv)",
          "old_line_content": "                    return true;",
          "new_line_content": "                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));",
          "content_same": false
        },
        {
          "line": 2523,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "req.indexes.push_back(i)",
          "old_line_content": "                }",
          "new_line_content": "                        req.indexes.push_back(i);",
          "content_same": false
        },
        {
          "line": 2525,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "req.indexes.empty()",
          "old_line_content": "                    // Dirty hack to jump to BLOCKTXN code (TODO: move message handling into their own functions)",
          "new_line_content": "                if (req.indexes.empty()) {",
          "content_same": false
        },
        {
          "line": 2528,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "cmpctblock.header.GetHash()",
          "old_line_content": "                    blockTxnMsg << txn;",
          "new_line_content": "                    txn.blockhash = cmpctblock.header.GetHash();",
          "content_same": false
        },
        {
          "line": 2533,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::GETBLOCKTXN, req)",
          "old_line_content": "                }",
          "new_line_content": "                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETBLOCKTXN, req));",
          "content_same": false
        },
        {
          "line": 2542,
          "old_api": null,
          "new_api": "InitData",
          "old_text": null,
          "new_text": "tempBlock.InitData(cmpctblock, vExtraTxnForCompact)",
          "old_line_content": "                if (status != READ_STATUS_OK) {",
          "new_line_content": "                ReadStatus status = tempBlock.InitData(cmpctblock, vExtraTxnForCompact);",
          "content_same": false
        },
        {
          "line": 2548,
          "old_api": null,
          "new_api": "FillBlock",
          "old_text": null,
          "new_text": "tempBlock.FillBlock(*pblock, dummy)",
          "old_line_content": "                if (status == READ_STATUS_OK) {",
          "new_line_content": "                status = tempBlock.FillBlock(*pblock, dummy);",
          "content_same": false
        },
        {
          "line": 2559,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::GETDATA, vInv)",
          "old_line_content": "                return true;",
          "new_line_content": "                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));",
          "content_same": false
        },
        {
          "line": 2569,
          "old_api": null,
          "new_api": "ProcessMessage",
          "old_text": null,
          "new_text": "ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, interruptMsgProc, enable_bip61)",
          "old_line_content": "",
          "new_line_content": "            return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, interruptMsgProc, enable_bip61);",
          "content_same": false
        },
        {
          "line": 2577,
          "old_api": null,
          "new_api": "ProcessHeadersMessage",
          "old_text": null,
          "new_text": "ProcessHeadersMessage(pfrom, connman, {cmpctblock.header}, chainparams, /*punish_duplicate_invalid=*/false)",
          "old_line_content": "        }",
          "new_line_content": "            return ProcessHeadersMessage(pfrom, connman, {cmpctblock.header}, chainparams, /*punish_duplicate_invalid=*/false);",
          "content_same": false
        },
        {
          "line": 2585,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            }",
          "new_line_content": "                mapBlockSource.emplace(pblock->GetHash(), std::make_pair(pfrom->GetId(), false));",
          "content_same": false
        },
        {
          "line": 2597,
          "old_api": null,
          "new_api": "ProcessNewBlock",
          "old_text": null,
          "new_text": "ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock)",
          "old_line_content": "            if (fNewBlock) {",
          "new_line_content": "            ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);",
          "content_same": false
        },
        {
          "line": 2599,
          "old_api": null,
          "new_api": "GetTime",
          "old_text": null,
          "new_text": "GetTime()",
          "old_line_content": "            } else {",
          "new_line_content": "                pfrom->nLastBlockTime = GetTime();",
          "content_same": false
        },
        {
          "line": 2602,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "pblock->GetHash()",
          "old_line_content": "            }",
          "new_line_content": "                mapBlockSource.erase(pblock->GetHash());",
          "content_same": false
        },
        {
          "line": 2605,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "pindex->IsValid(BLOCK_VALID_TRANSACTIONS)",
          "old_line_content": "                // Clear download state for this block, which is in",
          "new_line_content": "            if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS)) {",
          "content_same": false
        },
        {
          "line": 2610,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "pblock->GetHash()",
          "old_line_content": "            }",
          "new_line_content": "                MarkBlockAsReceived(pblock->GetHash());",
          "content_same": false
        },
        {
          "line": 2621,
          "old_api": null,
          "new_api": "std::make_shared<CBlock>()",
          "old_text": null,
          "new_text": "std::make_shared<CBlock>()",
          "old_line_content": "        bool fBlockRead = false;",
          "new_line_content": "        std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();",
          "content_same": false
        },
        {
          "line": 2624,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "",
          "new_line_content": "            LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2629,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "                return true;",
          "new_line_content": "                LogPrint(BCLog::NET, \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2634,
          "old_api": null,
          "new_api": "FillBlock",
          "old_text": null,
          "new_text": "partialBlock.FillBlock(*pblock, resp.txn)",
          "old_line_content": "            if (status == READ_STATUS_INVALID) {",
          "new_line_content": "            ReadStatus status = partialBlock.FillBlock(*pblock, resp.txn);",
          "content_same": false
        },
        {
          "line": 2637,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "                return true;",
          "new_line_content": "                Misbehaving(pfrom->GetId(), 100, strprintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->GetId()));",
          "content_same": false
        },
        {
          "line": 2643,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::GETDATA, invs)",
          "old_line_content": "            } else {",
          "new_line_content": "                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));",
          "content_same": false
        },
        {
          "line": 2662,
          "old_api": null,
          "new_api": "MarkBlockAsReceived",
          "old_text": null,
          "new_text": "MarkBlockAsReceived(resp.blockhash)",
          "old_line_content": "                fBlockRead = true;",
          "new_line_content": "                MarkBlockAsReceived(resp.blockhash); // it is now an empty pointer",
          "content_same": false
        },
        {
          "line": 2669,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            }",
          "new_line_content": "                mapBlockSource.emplace(resp.blockhash, std::make_pair(pfrom->GetId(), false));",
          "content_same": false
        },
        {
          "line": 2680,
          "old_api": null,
          "new_api": "ProcessNewBlock",
          "old_text": null,
          "new_text": "ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock)",
          "old_line_content": "            if (fNewBlock) {",
          "new_line_content": "            ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);",
          "content_same": false
        },
        {
          "line": 2682,
          "old_api": null,
          "new_api": "GetTime",
          "old_text": null,
          "new_text": "GetTime()",
          "old_line_content": "            } else {",
          "new_line_content": "                pfrom->nLastBlockTime = GetTime();",
          "content_same": false
        },
        {
          "line": 2685,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "pblock->GetHash()",
          "old_line_content": "            }",
          "new_line_content": "                mapBlockSource.erase(pblock->GetHash());",
          "content_same": false
        },
        {
          "line": 2696,
          "old_api": null,
          "new_api": "ReadCompactSize",
          "old_text": null,
          "new_text": "ReadCompactSize(vRecv)",
          "old_line_content": "        if (nCount > MAX_HEADERS_RESULTS) {",
          "new_line_content": "        unsigned int nCount = ReadCompactSize(vRecv);",
          "content_same": false
        },
        {
          "line": 2699,
          "old_api": null,
          "new_api": "strprintf",
          "old_text": null,
          "new_text": "strprintf(\"headers message size = %u\", nCount)",
          "old_line_content": "            return false;",
          "new_line_content": "            Misbehaving(pfrom->GetId(), 20, strprintf(\"headers message size = %u\", nCount));",
          "content_same": false
        },
        {
          "line": 2702,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "headers.resize(nCount)",
          "old_line_content": "        for (unsigned int n = 0; n < nCount; n++) {",
          "new_line_content": "        headers.resize(nCount);",
          "content_same": false
        },
        {
          "line": 2705,
          "old_api": null,
          "new_api": "ReadCompactSize",
          "old_text": null,
          "new_text": "ReadCompactSize(vRecv)",
          "old_line_content": "        }",
          "new_line_content": "            ReadCompactSize(vRecv); // ignore tx count; assume it is 0.",
          "content_same": false
        },
        {
          "line": 2713,
          "old_api": null,
          "new_api": "ProcessHeadersMessage",
          "old_text": null,
          "new_text": "ProcessHeadersMessage(pfrom, connman, headers, chainparams, should_punish)",
          "old_line_content": "    }",
          "new_line_content": "        return ProcessHeadersMessage(pfrom, connman, headers, chainparams, should_punish);",
          "content_same": false
        },
        {
          "line": 2718,
          "old_api": null,
          "new_api": "std::make_shared<CBlock>()",
          "old_text": null,
          "new_text": "std::make_shared<CBlock>()",
          "old_line_content": "        vRecv >> *pblock;",
          "new_line_content": "        std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();",
          "content_same": false
        },
        {
          "line": 2721,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "",
          "new_line_content": "        LogPrint(BCLog::NET, \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2724,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "pblock->GetHash()",
          "old_line_content": "        {",
          "new_line_content": "        const uint256 hash(pblock->GetHash());",
          "content_same": false
        },
        {
          "line": 2726,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "            // Also always process if we requested the block explicitly, as we may",
          "new_line_content": "            LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2729,
          "old_api": null,
          "new_api": "MarkBlockAsReceived",
          "old_text": null,
          "new_text": "MarkBlockAsReceived(hash)",
          "old_line_content": "            // mapBlockSource is only used for sending reject messages and DoS scores,",
          "new_line_content": "            forceProcessing |= MarkBlockAsReceived(hash);",
          "content_same": false
        },
        {
          "line": 2732,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "        }",
          "new_line_content": "            mapBlockSource.emplace(hash, std::make_pair(pfrom->GetId(), true));",
          "content_same": false
        },
        {
          "line": 2735,
          "old_api": null,
          "new_api": "ProcessNewBlock",
          "old_text": null,
          "new_text": "ProcessNewBlock(chainparams, pblock, forceProcessing, &fNewBlock)",
          "old_line_content": "        if (fNewBlock) {",
          "new_line_content": "        ProcessNewBlock(chainparams, pblock, forceProcessing, &fNewBlock);",
          "content_same": false
        },
        {
          "line": 2737,
          "old_api": null,
          "new_api": "GetTime",
          "old_text": null,
          "new_text": "GetTime()",
          "old_line_content": "        } else {",
          "new_line_content": "            pfrom->nLastBlockTime = GetTime();",
          "content_same": false
        },
        {
          "line": 2740,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "pblock->GetHash()",
          "old_line_content": "        }",
          "new_line_content": "            mapBlockSource.erase(pblock->GetHash());",
          "content_same": false
        },
        {
          "line": 2752,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            return true;",
          "new_line_content": "            LogPrint(BCLog::NET, \"Ignoring \\\"getaddr\\\" from outbound connection. peer=%d\\n\", pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2759,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            return true;",
          "new_line_content": "            LogPrint(BCLog::NET, \"Ignoring repeated \\\"getaddr\\\". peer=%d\\n\", pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2765,
          "old_api": null,
          "new_api": "GetAddresses",
          "old_text": null,
          "new_text": "connman->GetAddresses()",
          "old_line_content": "        FastRandomContext insecure_rand;",
          "new_line_content": "        std::vector<CAddress> vAddr = connman->GetAddresses();",
          "content_same": false
        },
        {
          "line": 2768,
          "old_api": null,
          "new_api": "PushAddress",
          "old_text": null,
          "new_text": "pfrom->PushAddress(addr, insecure_rand)",
          "old_line_content": "        return true;",
          "new_line_content": "            pfrom->PushAddress(addr, insecure_rand);",
          "content_same": false
        },
        {
          "line": 2773,
          "old_api": null,
          "new_api": "GetLocalServices",
          "old_text": null,
          "new_text": "pfrom->GetLocalServices()",
          "old_line_content": "        {",
          "new_line_content": "        if (!(pfrom->GetLocalServices() & NODE_BLOOM) && !pfrom->fWhitelisted)",
          "content_same": false
        },
        {
          "line": 2775,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            pfrom->fDisconnect = true;",
          "new_line_content": "            LogPrint(BCLog::NET, \"mempool request with bloom filters disabled, disconnect peer=%d\\n\", pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2780,
          "old_api": null,
          "new_api": "OutboundTargetReached",
          "old_text": null,
          "new_text": "connman->OutboundTargetReached(false)",
          "old_line_content": "        {",
          "new_line_content": "        if (connman->OutboundTargetReached(false) && !pfrom->fWhitelisted)",
          "content_same": false
        },
        {
          "line": 2782,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            pfrom->fDisconnect = true;",
          "new_line_content": "            LogPrint(BCLog::NET, \"mempool request with bandwidth limit reached, disconnect peer=%d\\n\", pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2787,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pfrom->cs_inventory)",
          "old_line_content": "        pfrom->fSendMempool = true;",
          "new_line_content": "        LOCK(pfrom->cs_inventory);",
          "content_same": false
        },
        {
          "line": 2808,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::PONG, nonce)",
          "old_line_content": "        }",
          "new_line_content": "            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::PONG, nonce));",
          "content_same": false
        },
        {
          "line": 2816,
          "old_api": null,
          "new_api": "in_avail",
          "old_text": null,
          "new_text": "vRecv.in_avail()",
          "old_line_content": "        bool bPingFinished = false;",
          "new_line_content": "        size_t nAvail = vRecv.in_avail();",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "mapOrphanTransactions.size()",
          "old_line_content": "    {",
          "new_line_content": "    while (mapOrphanTransactions.size() > nMaxOrphans)",
          "content_same": false
        },
        {
          "line": 2832,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "pfrom->nMinPingUsecTime.load()",
          "old_line_content": "                    } else {",
          "new_line_content": "                        pfrom->nMinPingUsecTime = std::min(pfrom->nMinPingUsecTime.load(), pingUsecTime);",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": null,
          "new_api": "EraseOrphanTx",
          "old_text": null,
          "new_text": "EraseOrphanTx(it->first)",
          "old_line_content": "        ++nEvicted;",
          "new_line_content": "        EraseOrphanTx(it->first);",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": null,
          "new_api": "State",
          "old_text": null,
          "new_text": "State(pnode)",
          "old_line_content": "    if (state == nullptr)",
          "new_line_content": "    CNodeState *state = State(pnode);",
          "content_same": false
        },
        {
          "line": 2857,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "                sProblem,",
          "new_line_content": "                pfrom->GetId(),",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "message.empty()",
          "old_line_content": "    if (state->nMisbehavior >= banscore && state->nMisbehavior - howmuch < banscore)",
          "new_line_content": "    std::string message_prefixed = message.empty() ? \"\" : (\": \" + message);",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d) BAN THRESHOLD EXCEEDED%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed)",
          "old_line_content": "        state->fShouldBan = true;",
          "new_line_content": "        LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d) BAN THRESHOLD EXCEEDED%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed)",
          "old_line_content": "}",
          "new_line_content": "        LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);",
          "content_same": false
        },
        {
          "line": 2873,
          "old_api": null,
          "new_api": "IsWithinSizeConstraints",
          "old_text": null,
          "new_text": "filter.IsWithinSizeConstraints()",
          "old_line_content": "        {",
          "new_line_content": "        if (!filter.IsWithinSizeConstraints())",
          "content_same": false
        },
        {
          "line": 2877,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "        }",
          "new_line_content": "            Misbehaving(pfrom->GetId(), 100);",
          "content_same": false
        },
        {
          "line": 2883,
          "old_api": null,
          "new_api": "UpdateEmptyFull",
          "old_text": null,
          "new_text": "pfrom->pfilter->UpdateEmptyFull()",
          "old_line_content": "            pfrom->fRelayTxes = true;",
          "new_line_content": "            pfrom->pfilter->UpdateEmptyFull();",
          "content_same": false
        },
        {
          "line": 841,
          "old_api": null,
          "new_api": "GetBlockProofEquivalentTime",
          "old_text": null,
          "new_text": "GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, consensusParams)",
          "old_line_content": "}",
          "new_line_content": "        (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, consensusParams) < STALE_RELAY_AGE_LIMIT);",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "recentRejects.reset(new CRollingBloomFilter(120000, 0.000001))",
          "old_line_content": "",
          "new_line_content": "    recentRejects.reset(new CRollingBloomFilter(120000, 0.000001));",
          "content_same": false
        },
        {
          "line": 2896,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vData.size()",
          "old_line_content": "            bad = true;",
          "new_line_content": "        if (vData.size() > MAX_SCRIPT_ELEMENT_SIZE) {",
          "content_same": false
        },
        {
          "line": 850,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "Params().GetConsensus()",
          "old_line_content": "    // Stale tip checking and peer eviction are on two different timers, but we",
          "new_line_content": "    const Consensus::Params& consensusParams = Params().GetConsensus();",
          "content_same": false
        },
        {
          "line": 2899,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pfrom->cs_filter)",
          "old_line_content": "            if (pfrom->pfilter) {",
          "new_line_content": "            LOCK(pfrom->cs_filter);",
          "content_same": false
        },
        {
          "line": 2901,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "pfrom->pfilter->insert(vData)",
          "old_line_content": "            } else {",
          "new_line_content": "                pfrom->pfilter->insert(vData);",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": null,
          "new_api": "std::bind(&PeerLogicValidation::CheckForStaleTipAndEvictPeers, this, consensusParams)",
          "old_text": null,
          "new_text": "std::bind(&PeerLogicValidation::CheckForStaleTipAndEvictPeers, this, consensusParams)",
          "old_line_content": "}",
          "new_line_content": "    scheduler.scheduleEvery(std::bind(&PeerLogicValidation::CheckForStaleTipAndEvictPeers, this, consensusParams), EXTRA_PEER_CHECK_INTERVAL * 1000);",
          "content_same": false
        },
        {
          "line": 2908,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "        }",
          "new_line_content": "            Misbehaving(pfrom->GetId(), 100);",
          "content_same": false
        },
        {
          "line": 864,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(g_cs_orphans)",
          "old_line_content": "",
          "new_line_content": "    LOCK(g_cs_orphans);",
          "content_same": false
        },
        {
          "line": 2916,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "pfrom->pfilter.reset(new CBloomFilter())",
          "old_line_content": "        }",
          "new_line_content": "            pfrom->pfilter.reset(new CBloomFilter());",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "itByPrev->second.end()",
          "old_line_content": "                const CTransaction& orphanTx = *(*mi)->second.tx;",
          "new_line_content": "            for (auto mi = itByPrev->second.begin(); mi != itByPrev->second.end(); ++mi) {",
          "content_same": false
        },
        {
          "line": 2925,
          "old_api": null,
          "new_api": "MoneyRange",
          "old_text": null,
          "new_text": "MoneyRange(newFeeFilter)",
          "old_line_content": "            {",
          "new_line_content": "        if (MoneyRange(newFeeFilter)) {",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "vOrphanErase.push_back(orphanHash)",
          "old_line_content": "            }",
          "new_line_content": "                vOrphanErase.push_back(orphanHash);",
          "content_same": false
        },
        {
          "line": 2927,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pfrom->cs_feeFilter)",
          "old_line_content": "                pfrom->minFeeFilter = newFeeFilter;",
          "new_line_content": "                LOCK(pfrom->cs_feeFilter);",
          "content_same": false
        },
        {
          "line": 2930,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "        }",
          "new_line_content": "            LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vOrphanErase.size()",
          "old_line_content": "        int nErased = 0;",
          "new_line_content": "    if (vOrphanErase.size()) {",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": null,
          "new_api": "EraseOrphanTx",
          "old_text": null,
          "new_text": "EraseOrphanTx(orphanHash)",
          "old_line_content": "        }",
          "new_line_content": "            nErased += EraseOrphanTx(orphanHash);",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx included or conflicted by block\\n\", nErased)",
          "old_line_content": "    }",
          "new_line_content": "        LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": null,
          "new_api": "GetTime",
          "old_text": null,
          "new_text": "GetTime()",
          "old_line_content": "}",
          "new_line_content": "    g_last_tip_update = GetTime();",
          "content_same": false
        },
        {
          "line": 2942,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "    return true;",
          "new_line_content": "    LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(strCommand), pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2949,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pnode->GetId()",
          "old_line_content": "",
          "new_line_content": "    CNodeState &state = *State(pnode->GetId());",
          "content_same": false
        },
        {
          "line": 2953,
          "old_api": null,
          "new_api": "std::string(NetMsgType::BLOCK)",
          "old_text": null,
          "new_text": "std::string(NetMsgType::BLOCK)",
          "old_line_content": "        }",
          "new_line_content": "            connman->PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, std::string(NetMsgType::BLOCK), reject.chRejectCode, reject.strRejectReason, reject.hashBlock));",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": null,
          "new_api": "std::make_shared<const CBlockHeaderAndShortTxIDs> (*pblock, true)",
          "old_text": null,
          "new_text": "std::make_shared<const CBlockHeaderAndShortTxIDs> (*pblock, true)",
          "old_line_content": "    const CNetMsgMaker msgMaker(PROTOCOL_VERSION);",
          "new_line_content": "    std::shared_ptr<const CBlockHeaderAndShortTxIDs> pcmpctblock = std::make_shared<const CBlockHeaderAndShortTxIDs> (*pblock, true);",
          "content_same": false
        },
        {
          "line": 2956,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "state.rejects.clear()",
          "old_line_content": "",
          "new_line_content": "    state.rejects.clear();",
          "content_same": false
        },
        {
          "line": 910,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2961,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pnode->addr.ToString()",
          "old_line_content": "        else if (pnode->m_manual_connection)",
          "new_line_content": "            LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pnode->addr.ToString());",
          "content_same": false
        },
        {
          "line": 2963,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pnode->addr.ToString()",
          "old_line_content": "        else {",
          "new_line_content": "            LogPrintf(\"Warning: not punishing manually-connected peer %s!\\n\", pnode->addr.ToString());",
          "content_same": false
        },
        {
          "line": 918,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "pblock->GetHash()",
          "old_line_content": "",
          "new_line_content": "    uint256 hashBlock(pblock->GetHash());",
          "content_same": false
        },
        {
          "line": 2967,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pnode->addr.ToString()",
          "old_line_content": "            else",
          "new_line_content": "                LogPrintf(\"Warning: not banning local peer %s!\\n\", pnode->addr.ToString());",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_most_recent_block)",
          "old_line_content": "        most_recent_block_hash = hashBlock;",
          "new_line_content": "        LOCK(cs_most_recent_block);",
          "content_same": false
        },
        {
          "line": 2970,
          "old_api": null,
          "new_api": "Ban",
          "old_text": null,
          "new_text": "connman->Ban(pnode->addr, BanReasonNodeMisbehaving)",
          "old_line_content": "            }",
          "new_line_content": "                connman->Ban(pnode->addr, BanReasonNodeMisbehaving);",
          "content_same": false
        },
        {
          "line": 929,
          "old_api": null,
          "new_api": "AssertLockHeld",
          "old_text": null,
          "new_text": "AssertLockHeld(cs_main)",
          "old_line_content": "",
          "new_line_content": "        AssertLockHeld(cs_main);",
          "content_same": false
        },
        {
          "line": 2980,
          "old_api": null,
          "new_api": "Params",
          "old_text": null,
          "new_text": "Params()",
          "old_line_content": "    //",
          "new_line_content": "    const CChainParams& chainparams = Params();",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pnode->GetId()",
          "old_line_content": "        // If the peer has, or we announced to them the previous block already,",
          "new_line_content": "        CNodeState &state = *State(pnode->GetId());",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": null,
          "new_api": "PeerHasHeader",
          "old_text": null,
          "new_text": "PeerHasHeader(&state, pindex->pprev)",
          "old_line_content": "",
          "new_line_content": "                !PeerHasHeader(&state, pindex) && PeerHasHeader(&state, pindex->pprev)) {",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::CMPCTBLOCK, *pcmpctblock)",
          "old_line_content": "            state.pindexBestHeaderSent = pindex;",
          "new_line_content": "            connman->PushMessage(pnode, msgMaker.Make(NetMsgType::CMPCTBLOCK, *pcmpctblock));",
          "content_same": false
        },
        {
          "line": 2992,
          "old_api": null,
          "new_api": "ProcessGetData",
          "old_text": null,
          "new_text": "ProcessGetData(pfrom, chainparams, connman, interruptMsgProc)",
          "old_line_content": "",
          "new_line_content": "        ProcessGetData(pfrom, chainparams, connman, interruptMsgProc);",
          "content_same": false
        },
        {
          "line": 2998,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "pfrom->vRecvGetData.empty()",
          "old_line_content": "",
          "new_line_content": "    if (!pfrom->vRecvGetData.empty()) return true;",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": null,
          "new_api": "SetBestHeight",
          "old_text": null,
          "new_text": "connman->SetBestHeight(nNewHeight)",
          "old_line_content": "",
          "new_line_content": "    connman->SetBestHeight(nNewHeight);",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": null,
          "new_api": "SetServiceFlagsIBDCache",
          "old_text": null,
          "new_text": "SetServiceFlagsIBDCache(!fInitialDownload)",
          "old_line_content": "    if (!fInitialDownload) {",
          "new_line_content": "    SetServiceFlagsIBDCache(!fInitialDownload);",
          "content_same": false
        },
        {
          "line": 3007,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "pfrom->vProcessMsg.empty()",
          "old_line_content": "            return false;",
          "new_line_content": "        if (pfrom->vProcessMsg.empty())",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": null,
          "new_api": "GetBlockHash",
          "old_text": null,
          "new_text": "pindexToAnnounce->GetBlockHash()",
          "old_line_content": "            pindexToAnnounce = pindexToAnnounce->pprev;",
          "new_line_content": "            vHashes.push_back(pindexToAnnounce->GetBlockHash());",
          "content_same": false
        },
        {
          "line": 965,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vHashes.size()",
          "old_line_content": "                // Limit announcements in case of a huge reorganization.",
          "new_line_content": "            if (vHashes.size() == MAX_BLOCKS_TO_ANNOUNCE) {",
          "content_same": false
        },
        {
          "line": 3013,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "pfrom->vProcessMsg.empty()",
          "old_line_content": "    }",
          "new_line_content": "        fMoreWork = !pfrom->vProcessMsg.empty();",
          "content_same": false
        },
        {
          "line": 3015,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "msgs.front()",
          "old_line_content": "",
          "new_line_content": "    CNetMessage& msg(msgs.front());",
          "content_same": false
        },
        {
          "line": 3017,
          "old_api": null,
          "new_api": "GetRecvVersion",
          "old_text": null,
          "new_text": "pfrom->GetRecvVersion()",
          "old_line_content": "    // Scan for message start",
          "new_line_content": "    msg.SetVersion(pfrom->GetRecvVersion());",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": null,
          "new_api": "ForEachNode",
          "old_text": null,
          "new_text": "connman->ForEachNode([nNewHeight, &vHashes](CNode* pnode) {\n            if (nNewHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : 0)) {\n                for (const uint256& hash : reverse_iterate(vHashes)) {\n                    pnode->PushBlockHash(hash);\n                }\n            }\n        })",
          "old_line_content": "            if (nNewHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : 0)) {",
          "new_line_content": "        connman->ForEachNode([nNewHeight, &vHashes](CNode* pnode) {",
          "content_same": false
        },
        {
          "line": 3020,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "        pfrom->fDisconnect = true;",
          "new_line_content": "        LogPrint(BCLog::NET, \"PROCESSMESSAGE: INVALID MESSAGESTART %s peer=%d\\n\", SanitizeString(msg.hdr.GetCommand()), pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": null,
          "new_api": "PushBlockHash",
          "old_text": null,
          "new_text": "pnode->PushBlockHash(hash)",
          "old_line_content": "                }",
          "new_line_content": "                    pnode->PushBlockHash(hash);",
          "content_same": false
        },
        {
          "line": 979,
          "old_api": null,
          "new_api": "WakeMessageHandler",
          "old_text": null,
          "new_text": "connman->WakeMessageHandler()",
          "old_line_content": "    }",
          "new_line_content": "        connman->WakeMessageHandler();",
          "content_same": false
        },
        {
          "line": 3027,
          "old_api": null,
          "new_api": "MessageStart",
          "old_text": null,
          "new_text": "chainparams.MessageStart()",
          "old_line_content": "    {",
          "new_line_content": "    if (!hdr.IsValid(chainparams.MessageStart()))",
          "content_same": false
        },
        {
          "line": 3029,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "        return fMoreWork;",
          "new_line_content": "        LogPrint(BCLog::NET, \"PROCESSMESSAGE: ERRORS IN HEADER %s peer=%d\\n\", SanitizeString(hdr.GetCommand()), pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": null,
          "new_api": "GetTime",
          "old_text": null,
          "new_text": "GetTime()",
          "old_line_content": "}",
          "new_line_content": "    nTimeBestReceived = GetTime();",
          "content_same": false
        },
        {
          "line": 3032,
          "old_api": null,
          "new_api": "GetCommand",
          "old_text": null,
          "new_text": "hdr.GetCommand()",
          "old_line_content": "",
          "new_line_content": "    std::string strCommand = hdr.GetCommand();",
          "content_same": false
        },
        {
          "line": 990,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 3040,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "hash.begin()",
          "old_line_content": "    {",
          "new_line_content": "    if (memcmp(hash.begin(), hdr.pchChecksum, CMessageHeader::CHECKSUM_SIZE) != 0)",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "mapBlockSource.find(hash)",
          "old_line_content": "",
          "new_line_content": "    std::map<uint256, std::pair<NodeId, bool>>::iterator it = mapBlockSource.find(hash);",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": null,
          "new_api": "IsInvalid",
          "old_text": null,
          "new_text": "state.IsInvalid(nDoS)",
          "old_line_content": "        // Don't send reject message with code 0 or an internal reject code.",
          "new_line_content": "    if (state.IsInvalid(nDoS)) {",
          "content_same": false
        },
        {
          "line": 3045,
          "old_api": null,
          "new_api": "HexStr",
          "old_text": null,
          "new_text": "HexStr(hdr.pchChecksum, hdr.pchChecksum+CMessageHeader::CHECKSUM_SIZE)",
          "old_line_content": "        return fMoreWork;",
          "new_line_content": "           HexStr(hdr.pchChecksum, hdr.pchChecksum+CMessageHeader::CHECKSUM_SIZE));",
          "content_same": false
        },
        {
          "line": 1000,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "State(it->second.first)->rejects.push_back(reject)",
          "old_line_content": "            if (nDoS > 0 && it->second.second)",
          "new_line_content": "            State(it->second.first)->rejects.push_back(reject);",
          "content_same": false
        },
        {
          "line": 1002,
          "old_api": null,
          "new_api": "Misbehaving",
          "old_text": null,
          "new_text": "Misbehaving(it->second.first, nDoS)",
          "old_line_content": "        }",
          "new_line_content": "                Misbehaving(it->second.first, nDoS);",
          "content_same": false
        },
        {
          "line": 3053,
          "old_api": null,
          "new_api": "ProcessMessage",
          "old_text": null,
          "new_text": "ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc, m_enable_bip61)",
          "old_line_content": "        if (interruptMsgProc)",
          "new_line_content": "        fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc, m_enable_bip61);",
          "content_same": false
        },
        {
          "line": 3056,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "pfrom->vRecvGetData.empty()",
          "old_line_content": "            fMoreWork = true;",
          "new_line_content": "        if (!pfrom->vRecvGetData.empty())",
          "content_same": false
        },
        {
          "line": 3062,
          "old_api": null,
          "new_api": "std::string(\"error parsing message\")",
          "old_text": null,
          "new_text": "std::string(\"error parsing message\")",
          "old_line_content": "        }",
          "new_line_content": "            connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, std::string(\"error parsing message\")));",
          "content_same": false
        },
        {
          "line": 1015,
          "old_api": null,
          "new_api": "MaybeSetPeerAsAnnouncingHeaderAndIDs",
          "old_text": null,
          "new_text": "MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first, connman)",
          "old_line_content": "        }",
          "new_line_content": "            MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first, connman);",
          "content_same": false
        },
        {
          "line": 3064,
          "old_api": null,
          "new_api": "what",
          "old_text": null,
          "new_text": "e.what()",
          "old_line_content": "        {",
          "new_line_content": "        if (strstr(e.what(), \"end of data\"))",
          "content_same": false
        },
        {
          "line": 3067,
          "old_api": null,
          "new_api": "what",
          "old_text": null,
          "new_text": "e.what()",
          "old_line_content": "        }",
          "new_line_content": "            LogPrint(BCLog::NET, \"%s(%s, %u bytes): Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "mapBlockSource.erase(it)",
          "old_line_content": "}",
          "new_line_content": "        mapBlockSource.erase(it);",
          "content_same": false
        },
        {
          "line": 3069,
          "old_api": null,
          "new_api": "what",
          "old_text": null,
          "new_text": "e.what()",
          "old_line_content": "        {",
          "new_line_content": "        else if (strstr(e.what(), \"size too large\"))",
          "content_same": false
        },
        {
          "line": 3072,
          "old_api": null,
          "new_api": "what",
          "old_text": null,
          "new_text": "e.what()",
          "old_line_content": "        }",
          "new_line_content": "            LogPrint(BCLog::NET, \"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());",
          "content_same": false
        },
        {
          "line": 3074,
          "old_api": null,
          "new_api": "what",
          "old_text": null,
          "new_text": "e.what()",
          "old_line_content": "        {",
          "new_line_content": "        else if (strstr(e.what(), \"non-canonical ReadCompactSize()\"))",
          "content_same": false
        },
        {
          "line": 3077,
          "old_api": null,
          "new_api": "what",
          "old_text": null,
          "new_text": "e.what()",
          "old_line_content": "        }",
          "new_line_content": "            LogPrint(BCLog::NET, \"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());",
          "content_same": false
        },
        {
          "line": 3081,
          "old_api": null,
          "new_api": "PrintExceptionContinue",
          "old_text": null,
          "new_text": "PrintExceptionContinue(&e, \"ProcessMessages()\")",
          "old_line_content": "        }",
          "new_line_content": "            PrintExceptionContinue(&e, \"ProcessMessages()\");",
          "content_same": false
        },
        {
          "line": 1036,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()->GetBlockHash()",
          "old_line_content": "            {",
          "new_line_content": "            if (chainActive.Tip()->GetBlockHash() != hashRecentRejectsChainTip)",
          "content_same": false
        },
        {
          "line": 3085,
          "old_api": null,
          "new_api": "PrintExceptionContinue",
          "old_text": null,
          "new_text": "PrintExceptionContinue(&e, \"ProcessMessages()\")",
          "old_line_content": "    } catch (...) {",
          "new_line_content": "        PrintExceptionContinue(&e, \"ProcessMessages()\");",
          "content_same": false
        },
        {
          "line": 3087,
          "old_api": null,
          "new_api": "PrintExceptionContinue",
          "old_text": null,
          "new_text": "PrintExceptionContinue(nullptr, \"ProcessMessages()\")",
          "old_line_content": "    }",
          "new_line_content": "        PrintExceptionContinue(nullptr, \"ProcessMessages()\");",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "recentRejects->reset()",
          "old_line_content": "            }",
          "new_line_content": "                recentRejects->reset();",
          "content_same": false
        },
        {
          "line": 3091,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "    }",
          "new_line_content": "        LogPrint(BCLog::NET, \"%s(%s, %u bytes) FAILED peer=%d\\n\", __func__, SanitizeString(strCommand), nMessageSize, pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 3095,
          "old_api": null,
          "new_api": "SendRejectsAndCheckIfBanned",
          "old_text": null,
          "new_text": "SendRejectsAndCheckIfBanned(pfrom, connman, m_enable_bip61)",
          "old_line_content": "",
          "new_line_content": "    SendRejectsAndCheckIfBanned(pfrom, connman, m_enable_bip61);",
          "content_same": false
        },
        {
          "line": 1048,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "mapOrphanTransactions.count(inv.hash)",
          "old_line_content": "            }",
          "new_line_content": "                if (mapOrphanTransactions.count(inv.hash)) return true;",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": null,
          "new_api": "COutPoint",
          "old_text": null,
          "new_text": "COutPoint(inv.hash, 1)",
          "old_line_content": "        }",
          "new_line_content": "                   pcoinsTip->HaveCoinInCache(COutPoint(inv.hash, 1));",
          "content_same": false
        },
        {
          "line": 3102,
          "old_api": null,
          "new_api": "AssertLockHeld",
          "old_text": null,
          "new_text": "AssertLockHeld(cs_main)",
          "old_line_content": "",
          "new_line_content": "    AssertLockHeld(cs_main);",
          "content_same": false
        },
        {
          "line": 3105,
          "old_api": null,
          "new_api": "GetSendVersion",
          "old_text": null,
          "new_text": "pto->GetSendVersion()",
          "old_line_content": "",
          "new_line_content": "    const CNetMsgMaker msgMaker(pto->GetSendVersion());",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": null,
          "new_api": "LookupBlockIndex",
          "old_text": null,
          "new_text": "LookupBlockIndex(inv.hash)",
          "old_line_content": "    }",
          "new_line_content": "        return LookupBlockIndex(inv.hash) != nullptr;",
          "content_same": false
        },
        {
          "line": 3107,
          "old_api": null,
          "new_api": "IsOutboundDisconnectionCandidate",
          "old_text": null,
          "new_text": "IsOutboundDisconnectionCandidate(pto)",
          "old_line_content": "        // This is an outbound peer subject to disconnection if they don't",
          "new_line_content": "    if (!state.m_chain_sync.m_protect && IsOutboundDisconnectionCandidate(pto) && state.fSyncStarted) {",
          "content_same": false
        },
        {
          "line": 3114,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "            if (state.m_chain_sync.m_timeout != 0) {",
          "new_line_content": "        if (state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= chainActive.Tip()->nChainWork) {",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": null,
          "new_api": "ForEachNode",
          "old_text": null,
          "new_text": "connman->ForEachNode([&inv](CNode* pnode)\n    {\n        pnode->PushInventory(inv);\n    })",
          "old_line_content": "    {",
          "new_line_content": "    connman->ForEachNode([&inv](CNode* pnode)",
          "content_same": false
        },
        {
          "line": 1069,
          "old_api": null,
          "new_api": "PushInventory",
          "old_text": null,
          "new_text": "pnode->PushInventory(inv)",
          "old_line_content": "    });",
          "new_line_content": "        pnode->PushInventory(inv);",
          "content_same": false
        },
        {
          "line": 3126,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "            state.m_chain_sync.m_sent_getheaders = false;",
          "new_line_content": "            state.m_chain_sync.m_work_header = chainActive.Tip();",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": null,
          "new_api": "GetTime",
          "old_text": null,
          "new_text": "GetTime()",
          "old_line_content": "    FastRandomContext insecure_rand;",
          "new_line_content": "    const CSipHasher hasher = connman->GetDeterministicRandomizer(RANDOMIZER_ID_ADDRESS_RELAY).Write(hashAddr << 32).Write((GetTime() + hashAddr) / (24*60*60));",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "best.size()",
          "old_line_content": "",
          "new_line_content": "    assert(nRelayNodes <= best.size());",
          "content_same": false
        },
        {
          "line": 3134,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "state.pindexBestKnownBlock->GetBlockHash().ToString()",
          "old_line_content": "                pto->fDisconnect = true;",
          "new_line_content": "                LogPrintf(\"Disconnecting outbound peer %d for old chain, best known block = %s\\n\", pto->GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\");",
          "content_same": false
        },
        {
          "line": 1089,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pnode->GetId()",
          "old_line_content": "            for (unsigned int i = 0; i < nRelayNodes; i++) {",
          "new_line_content": "            uint64_t hashKey = CSipHasher(hasher).Write(pnode->GetId()).Finalize();",
          "content_same": false
        },
        {
          "line": 3139,
          "old_api": null,
          "new_api": "uint256",
          "old_text": null,
          "new_text": "uint256()",
          "old_line_content": "                state.m_chain_sync.m_sent_getheaders = true;",
          "new_line_content": "                connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(state.m_chain_sync.m_work_header->pprev), uint256()));",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": null,
          "new_api": "std::make_pair(hashKey, pnode)",
          "old_text": null,
          "new_text": "std::make_pair(hashKey, pnode)",
          "old_line_content": "                     break;",
          "new_line_content": "                     best[i] = std::make_pair(hashKey, pnode);",
          "content_same": false
        },
        {
          "line": 3141,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "                // Bump the timeout to allow a response, which could clear the timeout",
          "new_line_content": "                constexpr int64_t HEADERS_RESPONSE_TIME = 120; // 2 minutes",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": null,
          "new_api": "PushAddress",
          "old_text": null,
          "new_text": "best[i].second->PushAddress(addr, insecure_rand)",
          "old_line_content": "        }",
          "new_line_content": "            best[i].second->PushAddress(addr, insecure_rand);",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": null,
          "new_api": "std::move(pushfunc)",
          "old_text": null,
          "new_text": "std::move(pushfunc)",
          "old_line_content": "}",
          "new_line_content": "    connman->ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));",
          "content_same": false
        },
        {
          "line": 3156,
          "old_api": null,
          "new_api": "GetExtraOutboundCount",
          "old_text": null,
          "new_text": "connman->GetExtraOutboundCount()",
          "old_line_content": "    if (extra_peers > 0) {",
          "new_line_content": "    int extra_peers = connman->GetExtraOutboundCount();",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "    {",
          "new_line_content": "    const Consensus::Params& consensusParams = chainparams.GetConsensus();",
          "content_same": false
        },
        {
          "line": 3163,
          "old_api": null,
          "new_api": "std::numeric_limits<int64_t>::max()",
          "old_text": null,
          "new_text": "std::numeric_limits<int64_t>::max()",
          "old_line_content": "",
          "new_line_content": "        int64_t oldest_block_announcement = std::numeric_limits<int64_t>::max();",
          "content_same": false
        },
        {
          "line": 1117,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_most_recent_block)",
          "old_line_content": "        a_recent_block = most_recent_block;",
          "new_line_content": "        LOCK(cs_most_recent_block);",
          "content_same": false
        },
        {
          "line": 3166,
          "old_api": null,
          "new_api": "AssertLockHeld",
          "old_text": null,
          "new_text": "AssertLockHeld(cs_main)",
          "old_line_content": "",
          "new_line_content": "            AssertLockHeld(cs_main);",
          "content_same": false
        },
        {
          "line": 3170,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pnode->GetId()",
          "old_line_content": "            if (state == nullptr) return; // shouldn't be possible, but just in case",
          "new_line_content": "            CNodeState *state = State(pnode->GetId());",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": null,
          "new_api": "LookupBlockIndex",
          "old_text": null,
          "new_text": "LookupBlockIndex(inv.hash)",
          "old_line_content": "        if (pindex) {",
          "new_line_content": "        const CBlockIndex* pindex = LookupBlockIndex(inv.hash);",
          "content_same": false
        },
        {
          "line": 3175,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pnode->GetId()",
          "old_line_content": "                oldest_block_announcement = state->m_last_block_announcement;",
          "new_line_content": "                worst_peer = pnode->GetId();",
          "content_same": false
        },
        {
          "line": 1129,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "pindex->IsValid(BLOCK_VALID_TREE)",
          "old_line_content": "                // If we have the block and all of its parents, but have not yet validated it,",
          "new_line_content": "                    pindex->IsValid(BLOCK_VALID_TREE)) {",
          "content_same": false
        },
        {
          "line": 3181,
          "old_api": null,
          "new_api": "AssertLockHeld",
          "old_text": null,
          "new_text": "AssertLockHeld(cs_main)",
          "old_line_content": "",
          "new_line_content": "                AssertLockHeld(cs_main);",
          "content_same": false
        },
        {
          "line": 3188,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pnode->GetId()",
          "old_line_content": "                if (time_in_seconds - pnode->nTimeConnected > MINIMUM_CONNECT_TIME && state.nBlocksInFlight == 0) {",
          "new_line_content": "                CNodeState &state = *State(pnode->GetId());",
          "content_same": false
        },
        {
          "line": 1142,
          "old_api": null,
          "new_api": "FormatStateMessage",
          "old_text": null,
          "new_text": "FormatStateMessage(state)",
          "old_line_content": "        }",
          "new_line_content": "            LogPrint(BCLog::NET, \"failed to activate chain (%s)\\n\", FormatStateMessage(state));",
          "content_same": false
        },
        {
          "line": 3190,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pnode->GetId()",
          "old_line_content": "                    pnode->fDisconnect = true;",
          "new_line_content": "                    LogPrint(BCLog::NET, \"disconnecting extra outbound peer=%d (last block announcement received at time %d)\\n\", pnode->GetId(), oldest_block_announcement);",
          "content_same": false
        },
        {
          "line": 3194,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pnode->GetId()",
          "old_line_content": "                    return false;",
          "new_line_content": "                    LogPrint(BCLog::NET, \"keeping outbound peer=%d chosen for eviction (connect time: %d, blocks_in_flight: %d)\\n\", pnode->GetId(), pnode->nTimeConnected, state.nBlocksInFlight);",
          "content_same": false
        },
        {
          "line": 1147,
          "old_api": null,
          "new_api": "LookupBlockIndex",
          "old_text": null,
          "new_text": "LookupBlockIndex(inv.hash)",
          "old_line_content": "    if (pindex) {",
          "new_line_content": "    const CBlockIndex* pindex = LookupBlockIndex(inv.hash);",
          "content_same": false
        },
        {
          "line": 1149,
          "old_api": null,
          "new_api": "BlockRequestAllowed",
          "old_text": null,
          "new_text": "BlockRequestAllowed(pindex, consensusParams)",
          "old_line_content": "        if (!send) {",
          "new_line_content": "        send = BlockRequestAllowed(pindex, consensusParams);",
          "content_same": false
        },
        {
          "line": 1151,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "        }",
          "new_line_content": "            LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": null,
          "new_api": "GetSendVersion",
          "old_text": null,
          "new_text": "pfrom->GetSendVersion()",
          "old_line_content": "    // disconnect node in case we have reached the outbound limit for serving historical blocks",
          "new_line_content": "    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());",
          "content_same": false
        },
        {
          "line": 3204,
          "old_api": null,
          "new_api": "SetTryNewOutboundPeer",
          "old_text": null,
          "new_text": "connman->SetTryNewOutboundPeer(false)",
          "old_line_content": "            }",
          "new_line_content": "                connman->SetTryNewOutboundPeer(false);",
          "content_same": false
        },
        {
          "line": 1157,
          "old_api": null,
          "new_api": "GetBlockTime",
          "old_text": null,
          "new_text": "pindex->GetBlockTime()",
          "old_line_content": "    {",
          "new_line_content": "    if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "",
          "new_line_content": "        LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 3212,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "       )) {",
          "new_line_content": "            (((pfrom->GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom->GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (chainActive.Tip()->nHeight - pindex->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )",
          "content_same": false
        },
        {
          "line": 3216,
          "old_api": null,
          "new_api": "GetTime",
          "old_text": null,
          "new_text": "GetTime()",
          "old_line_content": "",
          "new_line_content": "    int64_t time_in_seconds = GetTime();",
          "content_same": false
        },
        {
          "line": 1169,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "",
          "new_line_content": "        LogPrint(BCLog::NET, \"Ignore block request below NODE_NETWORK_LIMITED threshold from peer=%d\\n\", pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 3218,
          "old_api": null,
          "new_api": "EvictExtraOutboundPeers",
          "old_text": null,
          "new_text": "EvictExtraOutboundPeers(time_in_seconds)",
          "old_line_content": "",
          "new_line_content": "    EvictExtraOutboundPeers(time_in_seconds);",
          "content_same": false
        },
        {
          "line": 3227,
          "old_api": null,
          "new_api": "SetTryNewOutboundPeer",
          "old_text": null,
          "new_text": "connman->SetTryNewOutboundPeer(false)",
          "old_line_content": "        }",
          "new_line_content": "            connman->SetTryNewOutboundPeer(false);",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": null,
          "new_api": "GetBlockHash",
          "old_text": null,
          "new_text": "pindex->GetBlockHash()",
          "old_line_content": "            pblock = a_recent_block;",
          "new_line_content": "        if (a_recent_block && a_recent_block->GetHash() == pindex->GetBlockHash()) {",
          "content_same": false
        },
        {
          "line": 1187,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(!\"cannot load block from disk\")",
          "old_line_content": "            }",
          "new_line_content": "                assert(!\"cannot load block from disk\");",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": null,
          "new_api": "MakeSpan",
          "old_text": null,
          "new_text": "MakeSpan(block_data)",
          "old_line_content": "            // Don't set pblock as we've sent the block",
          "new_line_content": "            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, MakeSpan(block_data)));",
          "content_same": false
        },
        {
          "line": 3238,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "    {",
          "new_line_content": "    explicit CompareInvMempoolOrder(CTxMemPool *_mempool)",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(!\"cannot load block from disk\")",
          "old_line_content": "            pblock = pblockRead;",
          "new_line_content": "                assert(!\"cannot load block from disk\");",
          "content_same": false
        },
        {
          "line": 3247,
          "old_api": null,
          "new_api": "CompareDepthAndScore",
          "old_text": null,
          "new_text": "mp->CompareDepthAndScore(*b, *a)",
          "old_line_content": "    }",
          "new_line_content": "        return mp->CompareDepthAndScore(*b, *a);",
          "content_same": false
        },
        {
          "line": 1200,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock)",
          "old_line_content": "            else if (inv.type == MSG_WITNESS_BLOCK)",
          "new_line_content": "                connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));",
          "content_same": false
        },
        {
          "line": 1202,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::BLOCK, *pblock)",
          "old_line_content": "            else if (inv.type == MSG_FILTERED_BLOCK)",
          "new_line_content": "                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));",
          "content_same": false
        },
        {
          "line": 3254,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "Params().GetConsensus()",
          "old_line_content": "    {",
          "new_line_content": "    const Consensus::Params& consensusParams = Params().GetConsensus();",
          "content_same": false
        },
        {
          "line": 1208,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pfrom->cs_filter)",
          "old_line_content": "                    if (pfrom->pfilter) {",
          "new_line_content": "                    LOCK(pfrom->cs_filter);",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": null,
          "new_api": "CMerkleBlock",
          "old_text": null,
          "new_text": "CMerkleBlock(*pblock, *pfrom->pfilter)",
          "old_line_content": "                    }",
          "new_line_content": "                        merkleBlock = CMerkleBlock(*pblock, *pfrom->pfilter);",
          "content_same": false
        },
        {
          "line": 3261,
          "old_api": null,
          "new_api": "GetSendVersion",
          "old_text": null,
          "new_text": "pto->GetSendVersion()",
          "old_line_content": "",
          "new_line_content": "        const CNetMsgMaker msgMaker(pto->GetSendVersion());",
          "content_same": false
        },
        {
          "line": 1215,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock)",
          "old_line_content": "                    // CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see",
          "new_line_content": "                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));",
          "content_same": false
        },
        {
          "line": 3271,
          "old_api": null,
          "new_api": "GetTimeMicros",
          "old_text": null,
          "new_text": "GetTimeMicros()",
          "old_line_content": "            // Ping automatically sent as a latency probe & keepalive.",
          "new_line_content": "        if (pto->nPingNonceSent == 0 && pto->nPingUsecStart + PING_INTERVAL * 1000000 < GetTimeMicros()) {",
          "content_same": false
        },
        {
          "line": 1224,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first])",
          "old_line_content": "                }",
          "new_line_content": "                        connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));",
          "content_same": false
        },
        {
          "line": 3278,
          "old_api": null,
          "new_api": "GetRandBytes",
          "old_text": null,
          "new_text": "GetRandBytes((unsigned char*)&nonce, sizeof(nonce))",
          "old_line_content": "            }",
          "new_line_content": "                GetRandBytes((unsigned char*)&nonce, sizeof(nonce));",
          "content_same": false
        },
        {
          "line": 3281,
          "old_api": null,
          "new_api": "GetTimeMicros",
          "old_text": null,
          "new_text": "GetTimeMicros()",
          "old_line_content": "            if (pto->nVersion > BIP0031_VERSION) {",
          "new_line_content": "            pto->nPingUsecStart = GetTimeMicros();",
          "content_same": false
        },
        {
          "line": 1235,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "                int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;",
          "new_line_content": "                bool fPeerWantsWitness = State(pfrom->GetId())->fWantsCmpctWitness;",
          "content_same": false
        },
        {
          "line": 3284,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::PING, nonce)",
          "old_line_content": "            } else {",
          "new_line_content": "                connman->PushMessage(pto, msgMaker.Make(NetMsgType::PING, nonce));",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block)",
          "old_line_content": "                    } else {",
          "new_line_content": "                        connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));",
          "content_same": false
        },
        {
          "line": 3288,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::PING)",
          "old_line_content": "            }",
          "new_line_content": "                connman->PushMessage(pto, msgMaker.Make(NetMsgType::PING));",
          "content_same": false
        },
        {
          "line": 1242,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock)",
          "old_line_content": "                    }",
          "new_line_content": "                        connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));",
          "content_same": false
        },
        {
          "line": 3292,
          "old_api": null,
          "new_api": "TRY_LOCK",
          "old_text": null,
          "new_text": "TRY_LOCK(cs_main, lockMain)",
          "old_line_content": "        if (!lockMain)",
          "new_line_content": "        TRY_LOCK(cs_main, lockMain); // Acquire cs_main for IsInitialBlockDownload() and CNodeState()",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock)",
          "old_line_content": "                }",
          "new_line_content": "                    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));",
          "content_same": false
        },
        {
          "line": 3296,
          "old_api": null,
          "new_api": "SendRejectsAndCheckIfBanned",
          "old_text": null,
          "new_text": "SendRejectsAndCheckIfBanned(pto, connman, m_enable_bip61)",
          "old_line_content": "            return true;",
          "new_line_content": "        if (SendRejectsAndCheckIfBanned(pto, connman, m_enable_bip61))",
          "content_same": false
        },
        {
          "line": 3298,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pto->GetId()",
          "old_line_content": "",
          "new_line_content": "        CNodeState &state = *State(pto->GetId());",
          "content_same": false
        },
        {
          "line": 3304,
          "old_api": null,
          "new_api": "PoissonNextSend",
          "old_text": null,
          "new_text": "PoissonNextSend(nNow, AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL)",
          "old_line_content": "        }",
          "new_line_content": "            pto->nNextLocalAddrSend = PoissonNextSend(nNow, AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL);",
          "content_same": false
        },
        {
          "line": 1259,
          "old_api": null,
          "new_api": "SetNull",
          "old_text": null,
          "new_text": "pfrom->hashContinue.SetNull()",
          "old_line_content": "        }",
          "new_line_content": "            pfrom->hashContinue.SetNull();",
          "content_same": false
        },
        {
          "line": 3311,
          "old_api": null,
          "new_api": "PoissonNextSend",
          "old_text": null,
          "new_text": "PoissonNextSend(nNow, AVG_ADDRESS_BROADCAST_INTERVAL)",
          "old_line_content": "            std::vector<CAddress> vAddr;",
          "new_line_content": "            pto->nNextAddrSend = PoissonNextSend(nNow, AVG_ADDRESS_BROADCAST_INTERVAL);",
          "content_same": false
        },
        {
          "line": 3313,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "pto->vAddrToSend.size()",
          "old_line_content": "            for (const CAddress& addr : pto->vAddrToSend)",
          "new_line_content": "            vAddr.reserve(pto->vAddrToSend.size());",
          "content_same": false
        },
        {
          "line": 1266,
          "old_api": null,
          "new_api": "AssertLockNotHeld",
          "old_text": null,
          "new_text": "AssertLockNotHeld(cs_main)",
          "old_line_content": "",
          "new_line_content": "    AssertLockNotHeld(cs_main);",
          "content_same": false
        },
        {
          "line": 1268,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "pfrom->vRecvGetData.begin()",
          "old_line_content": "    std::vector<CInv> vNotFound;",
          "new_line_content": "    std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();",
          "content_same": false
        },
        {
          "line": 3316,
          "old_api": null,
          "new_api": "GetKey",
          "old_text": null,
          "new_text": "addr.GetKey()",
          "old_line_content": "                {",
          "new_line_content": "                if (!pto->addrKnown.contains(addr.GetKey()))",
          "content_same": false
        },
        {
          "line": 1270,
          "old_api": null,
          "new_api": "GetSendVersion",
          "old_text": null,
          "new_text": "pfrom->GetSendVersion()",
          "old_line_content": "    {",
          "new_line_content": "    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());",
          "content_same": false
        },
        {
          "line": 3319,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "vAddr.push_back(addr)",
          "old_line_content": "                    // receiver rejects addr messages larger than 1000",
          "new_line_content": "                    vAddr.push_back(addr);",
          "content_same": false
        },
        {
          "line": 1272,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "",
          "new_line_content": "        LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 3321,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vAddr.size()",
          "old_line_content": "                    {",
          "new_line_content": "                    if (vAddr.size() >= 1000)",
          "content_same": false
        },
        {
          "line": 1274,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "pfrom->vRecvGetData.end()",
          "old_line_content": "            if (interruptMsgProc)",
          "new_line_content": "        while (it != pfrom->vRecvGetData.end() && (it->type == MSG_TX || it->type == MSG_WITNESS_TX)) {",
          "content_same": false
        },
        {
          "line": 3324,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "vAddr.clear()",
          "old_line_content": "                    }",
          "new_line_content": "                        vAddr.clear();",
          "content_same": false
        },
        {
          "line": 3330,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::ADDR, vAddr)",
          "old_line_content": "            // we only send the big addr message once",
          "new_line_content": "                connman->PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));",
          "content_same": false
        },
        {
          "line": 3333,
          "old_api": null,
          "new_api": "shrink_to_fit",
          "old_text": null,
          "new_text": "pto->vAddrToSend.shrink_to_fit()",
          "old_line_content": "        }",
          "new_line_content": "                pto->vAddrToSend.shrink_to_fit();",
          "content_same": false
        },
        {
          "line": 1286,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "mapRelay.find(inv.hash)",
          "old_line_content": "            int nSendFlags = (inv.type == MSG_TX ? SERIALIZE_TRANSACTION_NO_WITNESS : 0);",
          "new_line_content": "            auto mi = mapRelay.find(inv.hash);",
          "content_same": false
        },
        {
          "line": 1289,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(nSendFlags, NetMsgType::TX, *mi->second)",
          "old_line_content": "                push = true;",
          "new_line_content": "                connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *mi->second));",
          "content_same": false
        },
        {
          "line": 3338,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "        bool fFetch = state.fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->fOneShot); // Download if this is a nice peer, or we have no nice peers and this one might do.",
          "new_line_content": "            pindexBestHeader = chainActive.Tip();",
          "content_same": false
        },
        {
          "line": 1292,
          "old_api": null,
          "new_api": "info",
          "old_text": null,
          "new_text": "mempool.info(inv.hash)",
          "old_line_content": "                // To protect privacy, do not answer getdata using the mempool when",
          "new_line_content": "                auto txinfo = mempool.info(inv.hash);",
          "content_same": false
        },
        {
          "line": 3342,
          "old_api": null,
          "new_api": "GetAdjustedTime",
          "old_text": null,
          "new_text": "GetAdjustedTime()",
          "old_line_content": "                state.fSyncStarted = true;",
          "new_line_content": "            if ((nSyncStarted == 0 && fFetch) || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {",
          "content_same": false
        },
        {
          "line": 1296,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(nSendFlags, NetMsgType::TX, *txinfo.tx)",
          "old_line_content": "                    push = true;",
          "new_line_content": "                    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *txinfo.tx));",
          "content_same": false
        },
        {
          "line": 3344,
          "old_api": null,
          "new_api": "GetBlockTime",
          "old_text": null,
          "new_text": "pindexBestHeader->GetBlockTime()",
          "old_line_content": "                nSyncStarted++;",
          "new_line_content": "                state.nHeadersSyncTimeout = GetTimeMicros() + HEADERS_DOWNLOAD_TIMEOUT_BASE + HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER * (GetAdjustedTime() - pindexBestHeader->GetBlockTime())/(consensusParams.nPowTargetSpacing);",
          "content_same": false
        },
        {
          "line": 1301,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "vNotFound.push_back(inv)",
          "old_line_content": "            }",
          "new_line_content": "                vNotFound.push_back(inv);",
          "content_same": false
        },
        {
          "line": 1306,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "pfrom->vRecvGetData.end()",
          "old_line_content": "        const CInv &inv = *it;",
          "new_line_content": "    if (it != pfrom->vRecvGetData.end() && !pfrom->fPauseSend) {",
          "content_same": false
        },
        {
          "line": 3357,
          "old_api": null,
          "new_api": "uint256",
          "old_text": null,
          "new_text": "uint256()",
          "old_line_content": "            }",
          "new_line_content": "                connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256()));",
          "content_same": false
        },
        {
          "line": 1310,
          "old_api": null,
          "new_api": "ProcessGetBlockData",
          "old_text": null,
          "new_text": "ProcessGetBlockData(pfrom, chainparams, inv, connman)",
          "old_line_content": "        }",
          "new_line_content": "            ProcessGetBlockData(pfrom, chainparams, inv, connman);",
          "content_same": false
        },
        {
          "line": 1314,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "pfrom->vRecvGetData.begin()",
          "old_line_content": "",
          "new_line_content": "    pfrom->vRecvGetData.erase(pfrom->vRecvGetData.begin(), it);",
          "content_same": false
        },
        {
          "line": 1316,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "vNotFound.empty()",
          "old_line_content": "        // Let the peer know that we didn't find what it asked for, so it doesn't",
          "new_line_content": "    if (!vNotFound.empty()) {",
          "content_same": false
        },
        {
          "line": 3364,
          "old_api": null,
          "new_api": "IsInitialBlockDownload",
          "old_text": null,
          "new_text": "IsInitialBlockDownload()",
          "old_line_content": "        {",
          "new_line_content": "        if (!fReindex && !fImporting && !IsInitialBlockDownload())",
          "content_same": false
        },
        {
          "line": 3366,
          "old_api": null,
          "new_api": "Broadcast",
          "old_text": null,
          "new_text": "GetMainSignals().Broadcast(nTimeBestReceived, connman)",
          "old_line_content": "        }",
          "new_line_content": "            GetMainSignals().Broadcast(nTimeBestReceived, connman);",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::NOTFOUND, vNotFound)",
          "old_line_content": "    }",
          "new_line_content": "        connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::NOTFOUND, vNotFound));",
          "content_same": false
        },
        {
          "line": 1330,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "        nFetchFlags |= MSG_WITNESS_FLAG;",
          "new_line_content": "    if ((pfrom->GetLocalServices() & NODE_WITNESS) && State(pfrom->GetId())->fHaveWitness) {",
          "content_same": false
        },
        {
          "line": 3380,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pto->cs_inventory)",
          "old_line_content": "            std::vector<CBlock> vHeaders;",
          "new_line_content": "            LOCK(pto->cs_inventory);",
          "content_same": false
        },
        {
          "line": 3384,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "pto->vBlockHashesToAnnounce.size()",
          "old_line_content": "            const CBlockIndex *pBestIndex = nullptr; // last header queued for delivery",
          "new_line_content": "                                pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);",
          "content_same": false
        },
        {
          "line": 3386,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pto->GetId()",
          "old_line_content": "",
          "new_line_content": "            ProcessBlockAvailability(pto->GetId()); // ensure pindexBestKnownBlock is up-to-date",
          "content_same": false
        },
        {
          "line": 1341,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            return;",
          "new_line_content": "            Misbehaving(pfrom->GetId(), 100, strprintf(\"Peer %d sent us a getblocktxn with out-of-bounds tx indices\", pfrom->GetId()));",
          "content_same": false
        },
        {
          "line": 3395,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(pindex)",
          "old_line_content": "                    if (chainActive[pindex->nHeight] != pindex) {",
          "new_line_content": "                    assert(pindex);",
          "content_same": false
        },
        {
          "line": 1349,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp)",
          "old_line_content": "}",
          "new_line_content": "    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));",
          "content_same": false
        },
        {
          "line": 1355,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "headers.size()",
          "old_line_content": "",
          "new_line_content": "    size_t nCount = headers.size();",
          "content_same": false
        },
        {
          "line": 1366,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "",
          "new_line_content": "        CNodeState *nodestate = State(pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 3420,
          "old_api": null,
          "new_api": "PeerHasHeader",
          "old_text": null,
          "new_text": "PeerHasHeader(&state, pindex)",
          "old_line_content": "                        continue; // keep looking for the first new block",
          "new_line_content": "                    } else if (PeerHasHeader(&state, pindex)) {",
          "content_same": false
        },
        {
          "line": 3422,
          "old_api": null,
          "new_api": "PeerHasHeader",
          "old_text": null,
          "new_text": "PeerHasHeader(&state, pindex->pprev)",
          "old_line_content": "                        // Peer doesn't have this header but they do have the prior one.",
          "new_line_content": "                    } else if (pindex->pprev == nullptr || PeerHasHeader(&state, pindex->pprev)) {",
          "content_same": false
        },
        {
          "line": 1376,
          "old_api": null,
          "new_api": "LookupBlockIndex",
          "old_text": null,
          "new_text": "LookupBlockIndex(headers[0].hashPrevBlock)",
          "old_line_content": "            nodestate->nUnconnectingHeaders++;",
          "new_line_content": "        if (!LookupBlockIndex(headers[0].hashPrevBlock) && nCount < MAX_BLOCKS_TO_ANNOUNCE) {",
          "content_same": false
        },
        {
          "line": 3426,
          "old_api": null,
          "new_api": "GetBlockHeader",
          "old_text": null,
          "new_text": "pindex->GetBlockHeader()",
          "old_line_content": "                    } else {",
          "new_line_content": "                        vHeaders.push_back(pindex->GetBlockHeader());",
          "content_same": false
        },
        {
          "line": 1381,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "headers[0].hashPrevBlock.ToString()",
          "old_line_content": "                    pindexBestHeader->nHeight,",
          "new_line_content": "                    headers[0].hashPrevBlock.ToString(),",
          "content_same": false
        },
        {
          "line": 1383,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            // Set hashLastUnknownBlock for this peer, so that if we",
          "new_line_content": "                    pfrom->GetId(), nodestate->nUnconnectingHeaders);",
          "content_same": false
        },
        {
          "line": 1387,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "headers.back().GetHash()",
          "old_line_content": "",
          "new_line_content": "            UpdateBlockAvailability(pfrom->GetId(), headers.back().GetHash());",
          "content_same": false
        },
        {
          "line": 3436,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vHeaders.size()",
          "old_line_content": "                    // We only send up to 1 block as header-and-ids, as otherwise",
          "new_line_content": "                if (vHeaders.size() == 1 && state.fPreferHeaderAndIDs) {",
          "content_same": false
        },
        {
          "line": 1390,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            }",
          "new_line_content": "                Misbehaving(pfrom->GetId(), 20);",
          "content_same": false
        },
        {
          "line": 3440,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pto->GetId()",
          "old_line_content": "",
          "new_line_content": "                            vHeaders.front().GetHash().ToString(), pto->GetId());",
          "content_same": false
        },
        {
          "line": 1398,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "                return false;",
          "new_line_content": "                Misbehaving(pfrom->GetId(), 20, \"non-continuous headers sequence\");",
          "content_same": false
        },
        {
          "line": 3447,
          "old_api": null,
          "new_api": "GetBlockHash",
          "old_text": null,
          "new_text": "pBestIndex->GetBlockHash()",
          "old_line_content": "                            if (state.fWantsCmpctWitness || !fWitnessesPresentInMostRecentCompactBlock)",
          "new_line_content": "                        if (most_recent_block_hash == pBestIndex->GetBlockHash()) {",
          "content_same": false
        },
        {
          "line": 1401,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "header.GetHash()",
          "old_line_content": "        }",
          "new_line_content": "            hashLastBlock = header.GetHash();",
          "content_same": false
        },
        {
          "line": 3449,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block)",
          "old_line_content": "                            else {",
          "new_line_content": "                                connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block));",
          "content_same": false
        },
        {
          "line": 3452,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock)",
          "old_line_content": "                            }",
          "new_line_content": "                                connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));",
          "content_same": false
        },
        {
          "line": 1406,
          "old_api": null,
          "new_api": "LookupBlockIndex",
          "old_text": null,
          "new_text": "LookupBlockIndex(hashLastBlock)",
          "old_line_content": "            received_new_header = true;",
          "new_line_content": "        if (!LookupBlockIndex(hashLastBlock)) {",
          "content_same": false
        },
        {
          "line": 3460,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(ret)",
          "old_line_content": "                        CBlockHeaderAndShortTxIDs cmpctblock(block, state.fWantsCmpctWitness);",
          "new_line_content": "                        assert(ret);",
          "content_same": false
        },
        {
          "line": 1413,
          "old_api": null,
          "new_api": "ProcessNewBlockHeaders",
          "old_text": null,
          "new_text": "ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast, &first_invalid_header)",
          "old_line_content": "        int nDoS;",
          "new_line_content": "    if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast, &first_invalid_header)) {",
          "content_same": false
        },
        {
          "line": 3462,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock)",
          "old_line_content": "                    }",
          "new_line_content": "                        connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));",
          "content_same": false
        },
        {
          "line": 1416,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "            if (nDoS > 0) {",
          "new_line_content": "            LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1418,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            } else {",
          "new_line_content": "                Misbehaving(pfrom->GetId(), nDoS, \"invalid header received\");",
          "content_same": false
        },
        {
          "line": 1420,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            }",
          "new_line_content": "                LogPrint(BCLog::NET, \"peer=%d: invalid header received\\n\", pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 1422,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "first_invalid_header.GetHash()",
          "old_line_content": "                // Goal: don't allow outbound peers to use up our outbound",
          "new_line_content": "            if (punish_duplicate_invalid && LookupBlockIndex(first_invalid_header.GetHash())) {",
          "content_same": false
        },
        {
          "line": 3470,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pto->GetId()",
          "old_line_content": "                    } else {",
          "new_line_content": "                                vHeaders.back().GetHash().ToString(), pto->GetId());",
          "content_same": false
        },
        {
          "line": 3473,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pto->GetId()",
          "old_line_content": "                    }",
          "new_line_content": "                                vHeaders.front().GetHash().ToString(), pto->GetId());",
          "content_same": false
        },
        {
          "line": 3475,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::HEADERS, vHeaders)",
          "old_line_content": "                    state.pindexBestHeaderSent = pBestIndex;",
          "new_line_content": "                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));",
          "content_same": false
        },
        {
          "line": 3487,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(pindex)",
          "old_line_content": "",
          "new_line_content": "                    assert(pindex);",
          "content_same": false
        },
        {
          "line": 3494,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()->GetBlockHash().ToString()",
          "old_line_content": "                    }",
          "new_line_content": "                            hashToAnnounce.ToString(), chainActive.Tip()->GetBlockHash().ToString());",
          "content_same": false
        },
        {
          "line": 3501,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "hashToAnnounce.ToString()",
          "old_line_content": "                    }",
          "new_line_content": "                            pto->GetId(), hashToAnnounce.ToString());",
          "content_same": false
        },
        {
          "line": 3505,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "pto->vBlockHashesToAnnounce.clear()",
          "old_line_content": "        }",
          "new_line_content": "            pto->vBlockHashesToAnnounce.clear();",
          "content_same": false
        },
        {
          "line": 1462,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "        if (nodestate->nUnconnectingHeaders > 0) {",
          "new_line_content": "        CNodeState *nodestate = State(pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 1464,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "        }",
          "new_line_content": "            LogPrint(BCLog::NET, \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->GetId(), nodestate->nUnconnectingHeaders);",
          "content_same": false
        },
        {
          "line": 3514,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "pto->vInventoryBlockToSend.size()",
          "old_line_content": "",
          "new_line_content": "            vInv.reserve(std::max<size_t>(pto->vInventoryBlockToSend.size(), INVENTORY_BROADCAST_MAX));",
          "content_same": false
        },
        {
          "line": 1469,
          "old_api": null,
          "new_api": "GetBlockHash",
          "old_text": null,
          "new_text": "pindexLast->GetBlockHash()",
          "old_line_content": "",
          "new_line_content": "        UpdateBlockAvailability(pfrom->GetId(), pindexLast->GetBlockHash());",
          "content_same": false
        },
        {
          "line": 3521,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "vInv.clear()",
          "old_line_content": "                }",
          "new_line_content": "                    vInv.clear();",
          "content_same": false
        },
        {
          "line": 1476,
          "old_api": null,
          "new_api": "GetTime",
          "old_text": null,
          "new_text": "GetTime()",
          "old_line_content": "        }",
          "new_line_content": "            nodestate->m_last_block_announcement = GetTime();",
          "content_same": false
        },
        {
          "line": 3524,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "pto->vInventoryBlockToSend.clear()",
          "old_line_content": "",
          "new_line_content": "            pto->vInventoryBlockToSend.clear();",
          "content_same": false
        },
        {
          "line": 3531,
          "old_api": null,
          "new_api": "PoissonNextSendInbound",
          "old_text": null,
          "new_text": "connman->PoissonNextSendInbound(nNow, INVENTORY_BROADCAST_INTERVAL)",
          "old_line_content": "                } else {",
          "new_line_content": "                    pto->nNextInvSend = connman->PoissonNextSendInbound(nNow, INVENTORY_BROADCAST_INTERVAL);",
          "content_same": false
        },
        {
          "line": 1484,
          "old_api": null,
          "new_api": "uint256",
          "old_text": null,
          "new_text": "uint256()",
          "old_line_content": "        }",
          "new_line_content": "            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256()));",
          "content_same": false
        },
        {
          "line": 3534,
          "old_api": null,
          "new_api": "PoissonNextSend",
          "old_text": null,
          "new_text": "PoissonNextSend(nNow, INVENTORY_BROADCAST_INTERVAL >> 1)",
          "old_line_content": "                }",
          "new_line_content": "                    pto->nNextInvSend = PoissonNextSend(nNow, INVENTORY_BROADCAST_INTERVAL >> 1);",
          "content_same": false
        },
        {
          "line": 1487,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "        // If this set of headers is valid and ends in a block with at least as",
          "new_line_content": "        bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());",
          "content_same": false
        },
        {
          "line": 1490,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "            std::vector<const CBlockIndex*> vToFetch;",
          "new_line_content": "        if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && chainActive.Tip()->nChainWork <= pindexLast->nChainWork) {",
          "content_same": false
        },
        {
          "line": 3541,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "pto->setInventoryTxToSend.clear()",
          "old_line_content": "            }",
          "new_line_content": "                if (!pto->fRelayTxes) pto->setInventoryTxToSend.clear();",
          "content_same": false
        },
        {
          "line": 1494,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vToFetch.size()",
          "old_line_content": "                if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&",
          "new_line_content": "            while (pindexWalk && !chainActive.Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {",
          "content_same": false
        },
        {
          "line": 1497,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "                    // We don't have this block, and it's not yet in flight.",
          "new_line_content": "                        (!IsWitnessEnabled(pindexWalk->pprev, chainparams.GetConsensus()) || State(pfrom->GetId())->fHaveWitness)) {",
          "content_same": false
        },
        {
          "line": 3546,
          "old_api": null,
          "new_api": "infoAll",
          "old_text": null,
          "new_text": "mempool.infoAll()",
          "old_line_content": "                pto->fSendMempool = false;",
          "new_line_content": "                auto vtxinfo = mempool.infoAll();",
          "content_same": false
        },
        {
          "line": 1499,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "vToFetch.push_back(pindexWalk)",
          "old_line_content": "                }",
          "new_line_content": "                    vToFetch.push_back(pindexWalk);",
          "content_same": false
        },
        {
          "line": 3550,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pto->cs_feeFilter)",
          "old_line_content": "                    filterrate = pto->minFeeFilter;",
          "new_line_content": "                    LOCK(pto->cs_feeFilter);",
          "content_same": false
        },
        {
          "line": 3554,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pto->cs_filter)",
          "old_line_content": "",
          "new_line_content": "                LOCK(pto->cs_filter);",
          "content_same": false
        },
        {
          "line": 1509,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pindexLast->GetBlockHash().ToString()",
          "old_line_content": "                        pindexLast->nHeight);",
          "new_line_content": "                        pindexLast->GetBlockHash().ToString(),",
          "content_same": false
        },
        {
          "line": 3557,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "txinfo.tx->GetHash()",
          "old_line_content": "                    CInv inv(MSG_TX, hash);",
          "new_line_content": "                    const uint256& hash = txinfo.tx->GetHash();",
          "content_same": false
        },
        {
          "line": 3559,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "pto->setInventoryTxToSend.erase(hash)",
          "old_line_content": "                    if (filterrate) {",
          "new_line_content": "                    pto->setInventoryTxToSend.erase(hash);",
          "content_same": false
        },
        {
          "line": 3561,
          "old_api": null,
          "new_api": "GetFeePerK",
          "old_text": null,
          "new_text": "txinfo.feeRate.GetFeePerK()",
          "old_line_content": "                            continue;",
          "new_line_content": "                        if (txinfo.feeRate.GetFeePerK() < filterrate)",
          "content_same": false
        },
        {
          "line": 1514,
          "old_api": null,
          "new_api": "reverse_iterate",
          "old_text": null,
          "new_text": "reverse_iterate(vToFetch)",
          "old_line_content": "                    if (nodestate->nBlocksInFlight >= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {",
          "new_line_content": "                for (const CBlockIndex *pindex : reverse_iterate(vToFetch)) {",
          "content_same": false
        },
        {
          "line": 3565,
          "old_api": null,
          "new_api": "IsRelevantAndUpdate",
          "old_text": null,
          "new_text": "pto->pfilter->IsRelevantAndUpdate(*txinfo.tx)",
          "old_line_content": "                    }",
          "new_line_content": "                        if (!pto->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;",
          "content_same": false
        },
        {
          "line": 1523,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "                }",
          "new_line_content": "                            pindex->GetBlockHash().ToString(), pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 3571,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "vInv.clear()",
          "old_line_content": "                    }",
          "new_line_content": "                        vInv.clear();",
          "content_same": false
        },
        {
          "line": 3574,
          "old_api": null,
          "new_api": "GetTime",
          "old_text": null,
          "new_text": "GetTime()",
          "old_line_content": "            }",
          "new_line_content": "                pto->timeLastMempoolReq = GetTime();",
          "content_same": false
        },
        {
          "line": 1527,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pindexLast->GetBlockHash().ToString()",
          "old_line_content": "                }",
          "new_line_content": "                            pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);",
          "content_same": false
        },
        {
          "line": 1530,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)",
          "old_line_content": "                        // In any case, we want to download using a compact block, not a regular one",
          "new_line_content": "                    if (nodestate->fSupportsDesiredCmpctVersion && vGetData.size() == 1 && mapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {",
          "content_same": false
        },
        {
          "line": 1532,
          "old_api": null,
          "new_api": "CInv",
          "old_text": null,
          "new_text": "CInv(MSG_CMPCT_BLOCK, vGetData[0].hash)",
          "old_line_content": "                    }",
          "new_line_content": "                        vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);",
          "content_same": false
        },
        {
          "line": 1534,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::GETDATA, vGetData)",
          "old_line_content": "                }",
          "new_line_content": "                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vGetData));",
          "content_same": false
        },
        {
          "line": 3583,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "vInvTx.push_back(it)",
          "old_line_content": "                }",
          "new_line_content": "                    vInvTx.push_back(it);",
          "content_same": false
        },
        {
          "line": 3587,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pto->cs_feeFilter)",
          "old_line_content": "                    filterrate = pto->minFeeFilter;",
          "new_line_content": "                    LOCK(pto->cs_feeFilter);",
          "content_same": false
        },
        {
          "line": 1540,
          "old_api": null,
          "new_api": "IsInitialBlockDownload",
          "old_text": null,
          "new_text": "IsInitialBlockDownload()",
          "old_line_content": "            // When nCount < MAX_HEADERS_RESULTS, we know we have no more",
          "new_line_content": "        if (IsInitialBlockDownload() && nCount != MAX_HEADERS_RESULTS) {",
          "content_same": false
        },
        {
          "line": 3593,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "vInvTx.end()",
          "old_line_content": "                // No reason to drain out at many times the network's capacity,",
          "new_line_content": "                std::make_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);",
          "content_same": false
        },
        {
          "line": 3598,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "vInvTx.empty()",
          "old_line_content": "                    // Fetch the top element from the heap",
          "new_line_content": "                while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {",
          "content_same": false
        },
        {
          "line": 1553,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "                    pfrom->fDisconnect = true;",
          "new_line_content": "                    LogPrintf(\"Disconnecting outbound peer %d -- headers chain has insufficient work\\n\", pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 3602,
          "old_api": null,
          "new_api": "pop_back",
          "old_text": null,
          "new_text": "vInvTx.pop_back()",
          "old_line_content": "                    uint256 hash = *it;",
          "new_line_content": "                    vInvTx.pop_back();",
          "content_same": false
        },
        {
          "line": 3605,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "pto->setInventoryTxToSend.erase(it)",
          "old_line_content": "                    // Check if not in the filter already",
          "new_line_content": "                    pto->setInventoryTxToSend.erase(it);",
          "content_same": false
        },
        {
          "line": 1559,
          "old_api": null,
          "new_api": "IsOutboundDisconnectionCandidate",
          "old_text": null,
          "new_text": "IsOutboundDisconnectionCandidate(pfrom)",
          "old_line_content": "            // If this is an outbound peer, check to see if we should protect",
          "new_line_content": "        if (!pfrom->fDisconnect && IsOutboundDisconnectionCandidate(pfrom) && nodestate->pindexBestKnownBlock != nullptr) {",
          "content_same": false
        },
        {
          "line": 3607,
          "old_api": null,
          "new_api": "contains",
          "old_text": null,
          "new_text": "pto->filterInventoryKnown.contains(hash)",
          "old_line_content": "                        continue;",
          "new_line_content": "                    if (pto->filterInventoryKnown.contains(hash)) {",
          "content_same": false
        },
        {
          "line": 1563,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "                nodestate->m_chain_sync.m_protect = true;",
          "new_line_content": "                LogPrint(BCLog::NET, \"Protecting outbound peer=%d from eviction\\n\", pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 3611,
          "old_api": null,
          "new_api": "info",
          "old_text": null,
          "new_text": "mempool.info(hash)",
          "old_line_content": "                    if (!txinfo.tx) {",
          "new_line_content": "                    auto txinfo = mempool.info(hash);",
          "content_same": false
        },
        {
          "line": 3615,
          "old_api": null,
          "new_api": "GetFeePerK",
          "old_text": null,
          "new_text": "txinfo.feeRate.GetFeePerK()",
          "old_line_content": "                        continue;",
          "new_line_content": "                    if (filterrate && txinfo.feeRate.GetFeePerK() < filterrate) {",
          "content_same": false
        },
        {
          "line": 3618,
          "old_api": null,
          "new_api": "IsRelevantAndUpdate",
          "old_text": null,
          "new_text": "pto->pfilter->IsRelevantAndUpdate(*txinfo.tx)",
          "old_line_content": "                    // Send",
          "new_line_content": "                    if (pto->pfilter && !pto->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;",
          "content_same": false
        },
        {
          "line": 3620,
          "old_api": null,
          "new_api": "CInv",
          "old_text": null,
          "new_text": "CInv(MSG_TX, hash)",
          "old_line_content": "                    nRelayedTransactions++;",
          "new_line_content": "                    vInv.push_back(CInv(MSG_TX, hash));",
          "content_same": false
        },
        {
          "line": 1576,
          "old_api": null,
          "new_api": "GetArg",
          "old_text": null,
          "new_text": "gArgs.GetArg(\"-dropmessagestest\", 0)",
          "old_line_content": "    {",
          "new_line_content": "    if (gArgs.IsArgSet(\"-dropmessagestest\") && GetRand(gArgs.GetArg(\"-dropmessagestest\", 0)) == 0)",
          "content_same": false
        },
        {
          "line": 3624,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "vRelayExpiration.front()",
          "old_line_content": "                        {",
          "new_line_content": "                        while (!vRelayExpiration.empty() && vRelayExpiration.front().first < nNow)",
          "content_same": false
        },
        {
          "line": 1578,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"dropmessagestest DROPPING RECV MESSAGE\\n\")",
          "old_line_content": "        return true;",
          "new_line_content": "        LogPrintf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");",
          "content_same": false
        },
        {
          "line": 3627,
          "old_api": null,
          "new_api": "pop_front",
          "old_text": null,
          "new_text": "vRelayExpiration.pop_front()",
          "old_line_content": "                        }",
          "new_line_content": "                            vRelayExpiration.pop_front();",
          "content_same": false
        },
        {
          "line": 3630,
          "old_api": null,
          "new_api": "std::move(txinfo.tx)",
          "old_text": null,
          "new_text": "std::move(txinfo.tx)",
          "old_line_content": "                        if (ret.second) {",
          "new_line_content": "                        auto ret = mapRelay.insert(std::make_pair(hash, std::move(txinfo.tx)));",
          "content_same": false
        },
        {
          "line": 1583,
          "old_api": null,
          "new_api": "GetLocalServices",
          "old_text": null,
          "new_text": "pfrom->GetLocalServices()",
          "old_line_content": "              (strCommand == NetMsgType::FILTERLOAD ||",
          "new_line_content": "    if (!(pfrom->GetLocalServices() & NODE_BLOOM) &&",
          "content_same": false
        },
        {
          "line": 3632,
          "old_api": null,
          "new_api": "std::make_pair(nNow + 15 * 60 * 1000000, ret.first)",
          "old_text": null,
          "new_text": "std::make_pair(nNow + 15 * 60 * 1000000, ret.first)",
          "old_line_content": "                        }",
          "new_line_content": "                            vRelayExpiration.push_back(std::make_pair(nNow + 15 * 60 * 1000000, ret.first));",
          "content_same": false
        },
        {
          "line": 1589,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            return false;",
          "new_line_content": "            Misbehaving(pfrom->GetId(), 100);",
          "content_same": false
        },
        {
          "line": 3637,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "vInv.clear()",
          "old_line_content": "                    }",
          "new_line_content": "                        vInv.clear();",
          "content_same": false
        },
        {
          "line": 3639,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "pto->filterInventoryKnown.insert(hash)",
          "old_line_content": "                }",
          "new_line_content": "                    pto->filterInventoryKnown.insert(hash);",
          "content_same": false
        },
        {
          "line": 3644,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::INV, vInv)",
          "old_line_content": "",
          "new_line_content": "            connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": null,
          "new_api": "LogAcceptCategory",
          "old_text": null,
          "new_text": "LogAcceptCategory(BCLog::NET)",
          "old_line_content": "            try {",
          "new_line_content": "        if (LogAcceptCategory(BCLog::NET)) {",
          "content_same": false
        },
        {
          "line": 3647,
          "old_api": null,
          "new_api": "GetTimeMicros",
          "old_text": null,
          "new_text": "GetTimeMicros()",
          "old_line_content": "        if (state.nStallingSince && state.nStallingSince < nNow - 1000000 * BLOCK_STALLING_TIMEOUT) {",
          "new_line_content": "        nNow = GetTimeMicros();",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": null,
          "new_api": "LIMITED_STRING",
          "old_text": null,
          "new_text": "LIMITED_STRING(strReason, MAX_REJECT_MESSAGE_LENGTH)",
          "old_line_content": "",
          "new_line_content": "                vRecv >> LIMITED_STRING(strMsg, CMessageHeader::COMMAND_SIZE) >> ccode >> LIMITED_STRING(strReason, MAX_REJECT_MESSAGE_LENGTH);",
          "content_same": false
        },
        {
          "line": 3652,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pto->GetId()",
          "old_line_content": "            pto->fDisconnect = true;",
          "new_line_content": "            LogPrintf(\"Peer=%d is stalling block download, disconnecting\\n\", pto->GetId());",
          "content_same": false
        },
        {
          "line": 1605,
          "old_api": null,
          "new_api": "itostr",
          "old_text": null,
          "new_text": "itostr(ccode)",
          "old_line_content": "",
          "new_line_content": "                ss << strMsg << \" code \" << itostr(ccode) << \": \" << strReason;",
          "content_same": false
        },
        {
          "line": 1611,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "hash.ToString()",
          "old_line_content": "                }",
          "new_line_content": "                    ss << \": hash \" << hash.ToString();",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": null,
          "new_api": "str",
          "old_text": null,
          "new_text": "ss.str()",
          "old_line_content": "            } catch (const std::ios_base::failure&) {",
          "new_line_content": "                LogPrint(BCLog::NET, \"Reject %s\\n\", SanitizeString(ss.str()));",
          "content_same": false
        },
        {
          "line": 3662,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "state.vBlocksInFlight.front()",
          "old_line_content": "            int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - (state.nBlocksInFlightValidHeaders > 0);",
          "new_line_content": "            QueuedBlock &queuedBlock = state.vBlocksInFlight.front();",
          "content_same": false
        },
        {
          "line": 1616,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::NET, \"Unparseable reject message received\\n\")",
          "old_line_content": "            }",
          "new_line_content": "                LogPrint(BCLog::NET, \"Unparseable reject message received\\n\");",
          "content_same": false
        },
        {
          "line": 3665,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pto->GetId()",
          "old_line_content": "                pto->fDisconnect = true;",
          "new_line_content": "                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->GetId());",
          "content_same": false
        },
        {
          "line": 3671,
          "old_api": null,
          "new_api": "std::numeric_limits<int64_t>::max()",
          "old_text": null,
          "new_text": "std::numeric_limits<int64_t>::max()",
          "old_line_content": "            // Detect whether this is a stalling initial-headers-sync peer",
          "new_line_content": "        if (state.fSyncStarted && state.nHeadersSyncTimeout < std::numeric_limits<int64_t>::max()) {",
          "content_same": false
        },
        {
          "line": 3673,
          "old_api": null,
          "new_api": "GetAdjustedTime",
          "old_text": null,
          "new_text": "GetAdjustedTime()",
          "old_line_content": "                if (nNow > state.nHeadersSyncTimeout && nSyncStarted == 1 && (nPreferredDownload - state.fPreferredDownload >= 1)) {",
          "new_line_content": "            if (pindexBestHeader->GetBlockTime() <= GetAdjustedTime() - 24*60*60) {",
          "content_same": false
        },
        {
          "line": 1627,
          "old_api": null,
          "new_api": "std::string(\"Duplicate version message\")",
          "old_text": null,
          "new_text": "std::string(\"Duplicate version message\")",
          "old_line_content": "            }",
          "new_line_content": "                connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(\"Duplicate version message\")));",
          "content_same": false
        },
        {
          "line": 1630,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            return false;",
          "new_line_content": "            Misbehaving(pfrom->GetId(), 1);",
          "content_same": false
        },
        {
          "line": 3681,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pto->GetId()",
          "old_line_content": "                        pto->fDisconnect = true;",
          "new_line_content": "                        LogPrintf(\"Timeout downloading headers from peer=%d, disconnecting\\n\", pto->GetId());",
          "content_same": false
        },
        {
          "line": 3685,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pto->GetId()",
          "old_line_content": "                        // Reset the headers sync state so that we have a",
          "new_line_content": "                        LogPrintf(\"Timeout downloading headers from whitelisted peer=%d, not disconnecting\\n\", pto->GetId());",
          "content_same": false
        },
        {
          "line": 1649,
          "old_api": null,
          "new_api": "ServiceFlags",
          "old_text": null,
          "new_text": "ServiceFlags(nServiceInt)",
          "old_line_content": "        if (!pfrom->fInbound)",
          "new_line_content": "        nServices = ServiceFlags(nServiceInt);",
          "content_same": false
        },
        {
          "line": 3699,
          "old_api": null,
          "new_api": "std::numeric_limits<int64_t>::max()",
          "old_text": null,
          "new_text": "std::numeric_limits<int64_t>::max()",
          "old_line_content": "            }",
          "new_line_content": "                state.nHeadersSyncTimeout = std::numeric_limits<int64_t>::max();",
          "content_same": false
        },
        {
          "line": 1652,
          "old_api": null,
          "new_api": "SetServices",
          "old_text": null,
          "new_text": "connman->SetServices(pfrom->addr, nServices)",
          "old_line_content": "        }",
          "new_line_content": "            connman->SetServices(pfrom->addr, nServices);",
          "content_same": false
        },
        {
          "line": 1654,
          "old_api": null,
          "new_api": "HasAllDesirableServiceFlags",
          "old_text": null,
          "new_text": "HasAllDesirableServiceFlags(nServices)",
          "old_line_content": "        {",
          "new_line_content": "        if (!pfrom->fInbound && !pfrom->fFeeler && !pfrom->m_manual_connection && !HasAllDesirableServiceFlags(nServices))",
          "content_same": false
        },
        {
          "line": 1656,
          "old_api": null,
          "new_api": "GetDesirableServiceFlags",
          "old_text": null,
          "new_text": "GetDesirableServiceFlags(nServices)",
          "old_line_content": "            if (enable_bip61) {",
          "new_line_content": "            LogPrint(BCLog::NET, \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->GetId(), nServices, GetDesirableServiceFlags(nServices));",
          "content_same": false
        },
        {
          "line": 3705,
          "old_api": null,
          "new_api": "GetTime",
          "old_text": null,
          "new_text": "GetTime()",
          "old_line_content": "",
          "new_line_content": "        ConsiderEviction(pto, GetTime());",
          "content_same": false
        },
        {
          "line": 1659,
          "old_api": null,
          "new_api": "GetDesirableServiceFlags",
          "old_text": null,
          "new_text": "GetDesirableServiceFlags(nServices)",
          "old_line_content": "            }",
          "new_line_content": "                                   strprintf(\"Expected to offer services %08x\", GetDesirableServiceFlags(nServices))));",
          "content_same": false
        },
        {
          "line": 3711,
          "old_api": null,
          "new_api": "IsInitialBlockDownload",
          "old_text": null,
          "new_text": "IsInitialBlockDownload()",
          "old_line_content": "            std::vector<const CBlockIndex*> vToDownload;",
          "new_line_content": "        if (!pto->fClient && ((fFetch && !pto->m_limited_node) || !IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {",
          "content_same": false
        },
        {
          "line": 3714,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pto->GetId()",
          "old_line_content": "            for (const CBlockIndex *pindex : vToDownload) {",
          "new_line_content": "            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);",
          "content_same": false
        },
        {
          "line": 1667,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            if (enable_bip61) {",
          "new_line_content": "            LogPrint(BCLog::NET, \"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->GetId(), nVersion);",
          "content_same": false
        },
        {
          "line": 1670,
          "old_api": null,
          "new_api": "strprintf",
          "old_text": null,
          "new_text": "strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION)",
          "old_line_content": "            }",
          "new_line_content": "                                   strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION)));",
          "content_same": false
        },
        {
          "line": 3720,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pto->GetId()",
          "old_line_content": "            }",
          "new_line_content": "                    pindex->nHeight, pto->GetId());",
          "content_same": false
        },
        {
          "line": 1676,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "vRecv.empty()",
          "old_line_content": "            vRecv >> addrFrom >> nNonce;",
          "new_line_content": "        if (!vRecv.empty())",
          "content_same": false
        },
        {
          "line": 3725,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::NET, \"Stall started peer=%d\\n\", staller)",
          "old_line_content": "                }",
          "new_line_content": "                    LogPrint(BCLog::NET, \"Stall started peer=%d\\n\", staller);",
          "content_same": false
        },
        {
          "line": 1680,
          "old_api": null,
          "new_api": "SanitizeString",
          "old_text": null,
          "new_text": "SanitizeString(strSubVer)",
          "old_line_content": "        }",
          "new_line_content": "            cleanSubVer = SanitizeString(strSubVer);",
          "content_same": false
        },
        {
          "line": 1682,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "vRecv.empty()",
          "old_line_content": "            vRecv >> nStartingHeight;",
          "new_line_content": "        if (!vRecv.empty()) {",
          "content_same": false
        },
        {
          "line": 1685,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "vRecv.empty()",
          "old_line_content": "            vRecv >> fRelay;",
          "new_line_content": "        if (!vRecv.empty())",
          "content_same": false
        },
        {
          "line": 3733,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "pto->mapAskFor.begin()",
          "old_line_content": "        {",
          "new_line_content": "        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)",
          "content_same": false
        },
        {
          "line": 1688,
          "old_api": null,
          "new_api": "CheckIncomingNonce",
          "old_text": null,
          "new_text": "connman->CheckIncomingNonce(nNonce)",
          "old_line_content": "        {",
          "new_line_content": "        if (pfrom->fInbound && !connman->CheckIncomingNonce(nNonce))",
          "content_same": false
        },
        {
          "line": 3736,
          "old_api": null,
          "new_api": "AlreadyHave",
          "old_text": null,
          "new_text": "AlreadyHave(inv)",
          "old_line_content": "            {",
          "new_line_content": "            if (!AlreadyHave(inv))",
          "content_same": false
        },
        {
          "line": 1690,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pfrom->addr.ToString()",
          "old_line_content": "            pfrom->fDisconnect = true;",
          "new_line_content": "            LogPrintf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString());",
          "content_same": false
        },
        {
          "line": 3740,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vGetData.size()",
          "old_line_content": "                {",
          "new_line_content": "                if (vGetData.size() >= 1000)",
          "content_same": false
        },
        {
          "line": 1695,
          "old_api": null,
          "new_api": "IsRoutable",
          "old_text": null,
          "new_text": "addrMe.IsRoutable()",
          "old_line_content": "        {",
          "new_line_content": "        if (pfrom->fInbound && addrMe.IsRoutable())",
          "content_same": false
        },
        {
          "line": 3743,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "vGetData.clear()",
          "old_line_content": "                }",
          "new_line_content": "                    vGetData.clear();",
          "content_same": false
        },
        {
          "line": 1697,
          "old_api": null,
          "new_api": "SeenLocal",
          "old_text": null,
          "new_text": "SeenLocal(addrMe)",
          "old_line_content": "        }",
          "new_line_content": "            SeenLocal(addrMe);",
          "content_same": false
        },
        {
          "line": 3747,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "pto->setAskFor.erase(inv.hash)",
          "old_line_content": "            }",
          "new_line_content": "                pto->setAskFor.erase(inv.hash);",
          "content_same": false
        },
        {
          "line": 3749,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "pto->mapAskFor.begin()",
          "old_line_content": "        }",
          "new_line_content": "            pto->mapAskFor.erase(pto->mapAskFor.begin());",
          "content_same": false
        },
        {
          "line": 1702,
          "old_api": null,
          "new_api": "GetAdjustedTime",
          "old_text": null,
          "new_text": "GetAdjustedTime()",
          "old_line_content": "",
          "new_line_content": "            PushNodeVersion(pfrom, connman, GetAdjustedTime());",
          "content_same": false
        },
        {
          "line": 1704,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK)",
          "old_line_content": "",
          "new_line_content": "        connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK));",
          "content_same": false
        },
        {
          "line": 3752,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::GETDATA, vGetData)",
          "old_line_content": "",
          "new_line_content": "            connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));",
          "content_same": false
        },
        {
          "line": 1707,
          "old_api": null,
          "new_api": "SetAddrLocal",
          "old_text": null,
          "new_text": "pfrom->SetAddrLocal(addrMe)",
          "old_line_content": "        {",
          "new_line_content": "        pfrom->SetAddrLocal(addrMe);",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pfrom->cs_SubVer)",
          "old_line_content": "            pfrom->strSubVer = strSubVer;",
          "new_line_content": "            LOCK(pfrom->cs_SubVer);",
          "content_same": false
        },
        {
          "line": 3761,
          "old_api": null,
          "new_api": "GetTimeMicros",
          "old_text": null,
          "new_text": "GetTimeMicros()",
          "old_line_content": "            if (timeNow > pto->nextSendTimeFeeFilter) {",
          "new_line_content": "            int64_t timeNow = GetTimeMicros();",
          "content_same": false
        },
        {
          "line": 3765,
          "old_api": null,
          "new_api": "round",
          "old_text": null,
          "new_text": "filterRounder.round(currentFilter)",
          "old_line_content": "                // We always have a fee filter of at least minRelayTxFee",
          "new_line_content": "                CAmount filterToSend = filterRounder.round(currentFilter);",
          "content_same": false
        },
        {
          "line": 3767,
          "old_api": null,
          "new_api": "GetFeePerK",
          "old_text": null,
          "new_text": "::minRelayTxFee.GetFeePerK()",
          "old_line_content": "                if (filterToSend != pto->lastSentFeeFilter) {",
          "new_line_content": "                filterToSend = std::max(filterToSend, ::minRelayTxFee.GetFeePerK());",
          "content_same": false
        },
        {
          "line": 3769,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::FEEFILTER, filterToSend)",
          "old_line_content": "                    pto->lastSentFeeFilter = filterToSend;",
          "new_line_content": "                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::FEEFILTER, filterToSend));",
          "content_same": false
        },
        {
          "line": 1722,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pfrom->cs_filter)",
          "old_line_content": "            pfrom->fRelayTxes = fRelay; // set to true after we get the first filter* message",
          "new_line_content": "            LOCK(pfrom->cs_filter);",
          "content_same": false
        },
        {
          "line": 3772,
          "old_api": null,
          "new_api": "PoissonNextSend",
          "old_text": null,
          "new_text": "PoissonNextSend(timeNow, AVG_FEEFILTER_BROADCAST_INTERVAL)",
          "old_line_content": "            }",
          "new_line_content": "                pto->nextSendTimeFeeFilter = PoissonNextSend(timeNow, AVG_FEEFILTER_BROADCAST_INTERVAL);",
          "content_same": false
        },
        {
          "line": 1727,
          "old_api": null,
          "new_api": "SetSendVersion",
          "old_text": null,
          "new_text": "pfrom->SetSendVersion(nSendVersion)",
          "old_line_content": "        pfrom->nVersion = nVersion;",
          "new_line_content": "        pfrom->SetSendVersion(nSendVersion);",
          "content_same": false
        },
        {
          "line": 3778,
          "old_api": null,
          "new_api": "GetRandInt",
          "old_text": null,
          "new_text": "GetRandInt(MAX_FEEFILTER_CHANGE_DELAY)",
          "old_line_content": "            }",
          "new_line_content": "                pto->nextSendTimeFeeFilter = timeNow + GetRandInt(MAX_FEEFILTER_CHANGE_DELAY) * 1000000;",
          "content_same": false
        },
        {
          "line": 1733,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "        }",
          "new_line_content": "            State(pfrom->GetId())->fHaveWitness = true;",
          "content_same": false
        },
        {
          "line": 1739,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "        }",
          "new_line_content": "        UpdatePreferredDownload(pfrom, State(pfrom->GetId()));",
          "content_same": false
        },
        {
          "line": 3792,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "mapOrphanTransactionsByPrev.clear()",
          "old_line_content": "    }",
          "new_line_content": "        mapOrphanTransactionsByPrev.clear();",
          "content_same": false
        },
        {
          "line": 1745,
          "old_api": null,
          "new_api": "IsInitialBlockDownload",
          "old_text": null,
          "new_text": "IsInitialBlockDownload()",
          "old_line_content": "            {",
          "new_line_content": "            if (fListen && !IsInitialBlockDownload())",
          "content_same": false
        },
        {
          "line": 1747,
          "old_api": null,
          "new_api": "GetLocalServices",
          "old_text": null,
          "new_text": "pfrom->GetLocalServices()",
          "old_line_content": "                FastRandomContext insecure_rand;",
          "new_line_content": "                CAddress addr = GetLocalAddress(&pfrom->addr, pfrom->GetLocalServices());",
          "content_same": false
        },
        {
          "line": 1749,
          "old_api": null,
          "new_api": "IsRoutable",
          "old_text": null,
          "new_text": "addr.IsRoutable()",
          "old_line_content": "                {",
          "new_line_content": "                if (addr.IsRoutable())",
          "content_same": false
        },
        {
          "line": 1756,
          "old_api": null,
          "new_api": "PushAddress",
          "old_text": null,
          "new_text": "pfrom->PushAddress(addr, insecure_rand)",
          "old_line_content": "                }",
          "new_line_content": "                    pfrom->PushAddress(addr, insecure_rand);",
          "content_same": false
        },
        {
          "line": 1761,
          "old_api": null,
          "new_api": "GetAddressCount",
          "old_text": null,
          "new_text": "connman->GetAddressCount()",
          "old_line_content": "            {",
          "new_line_content": "            if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || connman->GetAddressCount() < 1000)",
          "content_same": false
        },
        {
          "line": 1763,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR)",
          "old_line_content": "                pfrom->fGetAddr = true;",
          "new_line_content": "                connman->PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR));",
          "content_same": false
        },
        {
          "line": 1766,
          "old_api": null,
          "new_api": "MarkAddressGood",
          "old_text": null,
          "new_text": "connman->MarkAddressGood(pfrom->addr)",
          "old_line_content": "        }",
          "new_line_content": "            connman->MarkAddressGood(pfrom->addr);",
          "content_same": false
        },
        {
          "line": 1771,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pfrom->addr.ToString()",
          "old_line_content": "",
          "new_line_content": "            remoteAddr = \", peeraddr=\" + pfrom->addr.ToString();",
          "content_same": false
        },
        {
          "line": 1773,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "LogPrint(BCLog::NET, \"receive version message: %s: version %d, blocks=%d, us=%s, peer=%d%s\\n\",\n                  cleanSubVer, pfrom->nVersion,\n                  pfrom->nStartingHeight, addrMe.ToString(), pfrom->GetId(),\n                  remoteAddr)",
          "old_line_content": "                  cleanSubVer, pfrom->nVersion,",
          "new_line_content": "        LogPrint(BCLog::NET, \"receive version message: %s: version %d, blocks=%d, us=%s, peer=%d%s\\n\",",
          "content_same": false
        },
        {
          "line": 1775,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "                  remoteAddr);",
          "new_line_content": "                  pfrom->nStartingHeight, addrMe.ToString(), pfrom->GetId(),",
          "content_same": false
        },
        {
          "line": 1778,
          "old_api": null,
          "new_api": "GetTime",
          "old_text": null,
          "new_text": "GetTime()",
          "old_line_content": "        pfrom->nTimeOffset = nTimeOffset;",
          "new_line_content": "        int64_t nTimeOffset = nTime - GetTime();",
          "content_same": false
        },
        {
          "line": 1780,
          "old_api": null,
          "new_api": "AddTimeData",
          "old_text": null,
          "new_text": "AddTimeData(pfrom->addr, nTimeOffset)",
          "old_line_content": "",
          "new_line_content": "        AddTimeData(pfrom->addr, nTimeOffset);",
          "content_same": false
        },
        {
          "line": 1785,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "CNetMsgMaker(nSendVersion).Make(\"alert\", finalAlert)",
          "old_line_content": "        }",
          "new_line_content": "            connman->PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(\"alert\", finalAlert));",
          "content_same": false
        },
        {
          "line": 1790,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(pfrom->fInbound == false)",
          "old_line_content": "            pfrom->fDisconnect = true;",
          "new_line_content": "            assert(pfrom->fInbound == false);",
          "content_same": false
        },
        {
          "line": 1799,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "        return false;",
          "new_line_content": "        Misbehaving(pfrom->GetId(), 1);",
          "content_same": false
        },
        {
          "line": 1804,
          "old_api": null,
          "new_api": "GetSendVersion",
          "old_text": null,
          "new_text": "pfrom->GetSendVersion()",
          "old_line_content": "",
          "new_line_content": "    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());",
          "content_same": false
        },
        {
          "line": 1808,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "pfrom->nVersion.load()",
          "old_line_content": "",
          "new_line_content": "        pfrom->SetRecvVersion(std::min(pfrom->nVersion.load(), PROTOCOL_VERSION));",
          "content_same": false
        },
        {
          "line": 1816,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pfrom->addr.ToString()",
          "old_line_content": "        }",
          "new_line_content": "                      (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom->addr.ToString()) : \"\"));",
          "content_same": false
        },
        {
          "line": 1824,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::SENDHEADERS)",
          "old_line_content": "        }",
          "new_line_content": "            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDHEADERS));",
          "content_same": false
        },
        {
          "line": 1835,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion)",
          "old_line_content": "            nCMPCTBLOCKVersion = 1;",
          "new_line_content": "                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));",
          "content_same": false
        },
        {
          "line": 1837,
          "old_api": null,
          "new_api": "Make",
          "old_text": null,
          "new_text": "msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion)",
          "old_line_content": "        }",
          "new_line_content": "            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));",
          "content_same": false
        },
        {
          "line": 1846,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "        return false;",
          "new_line_content": "        Misbehaving(pfrom->GetId(), 1);",
          "content_same": false
        },
        {
          "line": 1855,
          "old_api": null,
          "new_api": "GetAddressCount",
          "old_text": null,
          "new_text": "connman->GetAddressCount()",
          "old_line_content": "            return true;",
          "new_line_content": "        if (pfrom->nVersion < CADDR_TIME_VERSION && connman->GetAddressCount() > 1000)",
          "content_same": false
        },
        {
          "line": 1857,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vAddr.size()",
          "old_line_content": "        {",
          "new_line_content": "        if (vAddr.size() > 1000)",
          "content_same": false
        },
        {
          "line": 1860,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vAddr.size()",
          "old_line_content": "            return false;",
          "new_line_content": "            Misbehaving(pfrom->GetId(), 20, strprintf(\"message addr size() = %u\", vAddr.size()));",
          "content_same": false
        },
        {
          "line": 1866,
          "old_api": null,
          "new_api": "GetAdjustedTime",
          "old_text": null,
          "new_text": "GetAdjustedTime()",
          "old_line_content": "        int64_t nSince = nNow - 10 * 60;",
          "new_line_content": "        int64_t nNow = GetAdjustedTime();",
          "content_same": false
        },
        {
          "line": 1876,
          "old_api": null,
          "new_api": "HasAllDesirableServiceFlags",
          "old_text": null,
          "new_text": "HasAllDesirableServiceFlags(addr.nServices)",
          "old_line_content": "                continue;",
          "new_line_content": "            if (!MayHaveUsefulAddressDB(addr.nServices) && !HasAllDesirableServiceFlags(addr.nServices))",
          "content_same": false
        },
        {
          "line": 1883,
          "old_api": null,
          "new_api": "IsRoutable",
          "old_text": null,
          "new_text": "addr.IsRoutable()",
          "old_line_content": "            {",
          "new_line_content": "            if (addr.nTime > nSince && !pfrom->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())",
          "content_same": false
        },
        {
          "line": 1886,
          "old_api": null,
          "new_api": "RelayAddress",
          "old_text": null,
          "new_text": "RelayAddress(addr, fReachable, connman)",
          "old_line_content": "            }",
          "new_line_content": "                RelayAddress(addr, fReachable, connman);",
          "content_same": false
        },
        {
          "line": 1890,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "vAddrOk.push_back(addr)",
          "old_line_content": "        }",
          "new_line_content": "                vAddrOk.push_back(addr);",
          "content_same": false
        },
        {
          "line": 1893,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vAddr.size()",
          "old_line_content": "            pfrom->fGetAddr = false;",
          "new_line_content": "        if (vAddr.size() < 1000)",
          "content_same": false
        },
        {
          "line": 1902,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "        return true;",
          "new_line_content": "        State(pfrom->GetId())->fPreferHeaders = true;",
          "content_same": false
        },
        {
          "line": 1911,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "            // fProvidesHeaderAndIDs is used to \"lock in\" version of compact blocks we send (fWantsCmpctWitness)",
          "new_line_content": "            LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1915,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            }",
          "new_line_content": "                State(pfrom->GetId())->fWantsCmpctWitness = nCMPCTBLOCKVersion == 2;",
          "content_same": false
        },
        {
          "line": 1921,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "                else",
          "new_line_content": "                    State(pfrom->GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2);",
          "content_same": false
        },
        {
          "line": 1923,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            }",
          "new_line_content": "                    State(pfrom->GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1);",
          "content_same": false
        },
        {
          "line": 1932,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vInv.size()",
          "old_line_content": "        {",
          "new_line_content": "        if (vInv.size() > MAX_INV_SZ)",
          "content_same": false
        },
        {
          "line": 1935,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vInv.size()",
          "old_line_content": "            return false;",
          "new_line_content": "            Misbehaving(pfrom->GetId(), 20, strprintf(\"message inv size() = %u\", vInv.size()));",
          "content_same": false
        },
        {
          "line": 1942,
          "old_api": null,
          "new_api": "GetBoolArg",
          "old_text": null,
          "new_text": "gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)",
          "old_line_content": "            fBlocksOnly = false;",
          "new_line_content": "        if (pfrom->fWhitelisted && gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY))",
          "content_same": false
        },
        {
          "line": 1945,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "",
          "new_line_content": "        LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1947,
          "old_api": null,
          "new_api": "GetFetchFlags",
          "old_text": null,
          "new_text": "GetFetchFlags(pfrom)",
          "old_line_content": "",
          "new_line_content": "        uint32_t nFetchFlags = GetFetchFlags(pfrom);",
          "content_same": false
        },
        {
          "line": 1955,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "",
          "new_line_content": "            LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 1963,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "mapBlocksInFlight.count(inv.hash)",
          "old_line_content": "                    // We used to request the full block here, but since headers-announcements are now the",
          "new_line_content": "                if (!fAlreadyHave && !fImporting && !fReindex && !mapBlocksInFlight.count(inv.hash)) {",
          "content_same": false
        },
        {
          "line": 1970,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "                }",
          "new_line_content": "                    LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 1975,
          "old_api": null,
          "new_api": "AddInventoryKnown",
          "old_text": null,
          "new_text": "pfrom->AddInventoryKnown(inv)",
          "old_line_content": "                if (fBlocksOnly) {",
          "new_line_content": "                pfrom->AddInventoryKnown(inv);",
          "content_same": false
        },
        {
          "line": 1979,
          "old_api": null,
          "new_api": "AskFor",
          "old_text": null,
          "new_text": "pfrom->AskFor(inv)",
          "old_line_content": "                }",
          "new_line_content": "                    pfrom->AskFor(inv);",
          "content_same": false
        },
        {
          "line": 1989,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vInv.size()",
          "old_line_content": "        {",
          "new_line_content": "        if (vInv.size() > MAX_INV_SZ)",
          "content_same": false
        },
        {
          "line": 1992,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vInv.size()",
          "old_line_content": "            return false;",
          "new_line_content": "            Misbehaving(pfrom->GetId(), 20, strprintf(\"message getdata size() = %u\", vInv.size()));",
          "content_same": false
        },
        {
          "line": 1996,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "",
          "new_line_content": "        LogPrint(BCLog::NET, \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 1999,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "        }",
          "new_line_content": "            LogPrint(BCLog::NET, \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2003,
          "old_api": null,
          "new_api": "ProcessGetData",
          "old_text": null,
          "new_text": "ProcessGetData(pfrom, chainparams, connman, interruptMsgProc)",
          "old_line_content": "        return true;",
          "new_line_content": "        ProcessGetData(pfrom, chainparams, connman, interruptMsgProc);",
          "content_same": false
        },
        {
          "line": 2013,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pfrom->GetId()",
          "old_line_content": "            pfrom->fDisconnect = true;",
          "new_line_content": "            LogPrint(BCLog::NET, \"getblocks locator size %lld > %d, disconnect peer=%d\\n\", locator.vHave.size(), MAX_LOCATOR_SZ, pfrom->GetId());",
          "content_same": false
        },
        {
          "line": 2028,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_most_recent_block)",
          "old_line_content": "                a_recent_block = most_recent_block;",
          "new_line_content": "                LOCK(cs_most_recent_block);",
          "content_same": false
        },
        {
          "line": 2033,
          "old_api": null,
          "new_api": "FormatStateMessage",
          "old_text": null,
          "new_text": "FormatStateMessage(state)",
          "old_line_content": "            }",
          "new_line_content": "                LogPrint(BCLog::NET, \"failed to activate chain (%s)\\n\", FormatStateMessage(state));",
          "content_same": false
        },
        {
          "line": 2037,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "",
          "new_line_content": "        LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2040,
          "old_api": null,
          "new_api": "FindForkInGlobalIndex",
          "old_text": null,
          "new_text": "FindForkInGlobalIndex(chainActive, locator)",
          "old_line_content": "",
          "new_line_content": "        const CBlockIndex* pindex = FindForkInGlobalIndex(chainActive, locator);",
          "content_same": false
        },
        {
          "line": 2044,
          "old_api": null,
          "new_api": "Next",
          "old_text": null,
          "new_text": "chainActive.Next(pindex)",
          "old_line_content": "        int nLimit = 500;",
          "new_line_content": "            pindex = chainActive.Next(pindex);",
          "content_same": false
        },
        {
          "line": 2047,
          "old_api": null,
          "new_api": "Next",
          "old_text": null,
          "new_text": "chainActive.Next(pindex)",
          "old_line_content": "        {",
          "new_line_content": "        for (; pindex; pindex = chainActive.Next(pindex))",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2048,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindex->GetBlockHash()",
          "new_text": null,
          "old_line_content": "            if (pindex->GetBlockHash() == hashStop)",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2050,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "pindex->GetBlockHash().ToString()",
          "new_text": null,
          "old_line_content": "                LogPrint(BCLog::NET, \"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 2055,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "            const int nPrunedBlocksLikelyToHave = MIN_BLOCKS_TO_KEEP - 3600 / chainparams.GetConsensus().nPowTargetSpacing;",
          "new_line_content": "            // for some reasonable time window (1 hour) that block relay might require.",
          "content_same": false
        },
        {
          "line": 2058,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "pindex->GetBlockHash().ToString()",
          "new_text": null,
          "old_line_content": "                LogPrint(BCLog::NET, \" getblocks stopping, pruned or too old block at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 2061,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindex->GetBlockHash()",
          "new_text": null,
          "old_line_content": "            pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2066,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "pindex->GetBlockHash().ToString()",
          "new_text": null,
          "old_line_content": "                LogPrint(BCLog::NET, \"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());",
          "new_line_content": "                // trigger the peer to getblocks the next batch of inventory.",
          "content_same": false
        },
        {
          "line": 2080,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_most_recent_block)",
          "new_text": null,
          "old_line_content": "            LOCK(cs_most_recent_block);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2086,
          "old_api": "SendBlockTransactions",
          "new_api": null,
          "old_text": "SendBlockTransactions(*recent_block, req, pfrom, connman)",
          "new_text": null,
          "old_line_content": "            SendBlockTransactions(*recent_block, req, pfrom, connman);",
          "new_line_content": "        if (recent_block) {",
          "content_same": false
        },
        {
          "line": 2090,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "        LOCK(cs_main);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2092,
          "old_api": "LookupBlockIndex",
          "new_api": null,
          "old_text": "LookupBlockIndex(req.blockhash)",
          "new_text": null,
          "old_line_content": "        const CBlockIndex* pindex = LookupBlockIndex(req.blockhash);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2094,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block we don't have\\n\", pfrom->GetId());",
          "new_line_content": "        if (!pindex || !(pindex->nStatus & BLOCK_HAVE_DATA)) {",
          "content_same": false
        },
        {
          "line": 2098,
          "old_api": "Height",
          "new_api": null,
          "old_text": "chainActive.Height()",
          "new_text": null,
          "old_line_content": "        if (pindex->nHeight < chainActive.Height() - MAX_BLOCKTXN_DEPTH) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2106,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block > %i deep\\n\", pfrom->GetId(), MAX_BLOCKTXN_DEPTH);",
          "new_line_content": "            // actually receive all the data read from disk over the network.",
          "content_same": false
        },
        {
          "line": 2108,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "            inv.type = State(pfrom->GetId())->fWantsCmpctWitness ? MSG_WITNESS_BLOCK : MSG_BLOCK;",
          "new_line_content": "            CInv inv;",
          "content_same": false
        },
        {
          "line": 2110,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "pfrom->vRecvGetData.push_back(inv)",
          "new_text": null,
          "old_line_content": "            pfrom->vRecvGetData.push_back(inv);",
          "new_line_content": "            inv.hash = req.blockhash;",
          "content_same": false
        },
        {
          "line": 2116,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "        bool ret = ReadBlockFromDisk(block, pindex, chainparams.GetConsensus());",
          "new_line_content": "        CBlock block;",
          "content_same": false
        },
        {
          "line": 2119,
          "old_api": "SendBlockTransactions",
          "new_api": null,
          "old_text": "SendBlockTransactions(block, req, pfrom, connman)",
          "new_text": null,
          "old_line_content": "        SendBlockTransactions(block, req, pfrom, connman);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2128,
          "old_api": "size",
          "new_api": null,
          "old_text": "locator.vHave.size()",
          "new_text": null,
          "old_line_content": "        if (locator.vHave.size() > MAX_LOCATOR_SZ) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2134,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "        LOCK(cs_main);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2140,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "        CNodeState *nodestate = State(pfrom->GetId());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2142,
          "old_api": "IsNull",
          "new_api": null,
          "old_text": "locator.IsNull()",
          "new_text": null,
          "old_line_content": "        if (locator.IsNull())",
          "new_line_content": "        const CBlockIndex* pindex = nullptr;",
          "content_same": false
        },
        {
          "line": 2145,
          "old_api": "LookupBlockIndex",
          "new_api": null,
          "old_text": "LookupBlockIndex(hashStop)",
          "new_text": null,
          "old_line_content": "            pindex = LookupBlockIndex(hashStop);",
          "new_line_content": "            // If locator is null, return the hashStop block",
          "content_same": false
        },
        {
          "line": 2150,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "            if (!BlockRequestAllowed(pindex, chainparams.GetConsensus())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2158,
          "old_api": "FindForkInGlobalIndex",
          "new_api": null,
          "old_text": "FindForkInGlobalIndex(chainActive, locator)",
          "new_text": null,
          "old_line_content": "            pindex = FindForkInGlobalIndex(chainActive, locator);",
          "new_line_content": "            // Find the last block the caller has in the main chain",
          "content_same": false
        },
        {
          "line": 2160,
          "old_api": "Next",
          "new_api": null,
          "old_text": "chainActive.Next(pindex)",
          "new_text": null,
          "old_line_content": "                pindex = chainActive.Next(pindex);",
          "new_line_content": "            if (pindex)",
          "content_same": false
        },
        {
          "line": 2166,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom->GetId());",
          "new_line_content": "        int nLimit = MAX_HEADERS_RESULTS;",
          "content_same": false
        },
        {
          "line": 2169,
          "old_api": "GetBlockHeader",
          "new_api": null,
          "old_text": "pindex->GetBlockHeader()",
          "new_text": null,
          "old_line_content": "            vHeaders.push_back(pindex->GetBlockHeader());",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2185,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "        nodestate->pindexBestHeaderSent = pindex ? pindex : chainActive.Tip();",
          "new_line_content": "        // in the SendMessages logic.",
          "content_same": false
        },
        {
          "line": 2193,
          "old_api": "GetBoolArg",
          "new_api": null,
          "old_text": "gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)",
          "new_text": null,
          "old_line_content": "        if (!fRelayTxes && (!pfrom->fWhitelisted || !gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)))",
          "new_line_content": "        // We are in blocks only mode and peer is either not whitelisted or whitelistrelay is off",
          "content_same": false
        },
        {
          "line": 2195,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom->GetId());",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2205,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "tx.GetHash()",
          "new_text": null,
          "old_line_content": "        CInv inv(MSG_TX, tx.GetHash());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2208,
          "old_api": "LOCK2",
          "new_api": null,
          "old_text": "LOCK2(cs_main, g_cs_orphans)",
          "new_text": null,
          "old_line_content": "        LOCK2(cs_main, g_cs_orphans);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2213,
          "old_api": "erase",
          "new_api": null,
          "old_text": "pfrom->setAskFor.erase(inv.hash)",
          "new_text": null,
          "old_line_content": "        pfrom->setAskFor.erase(inv.hash);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2218,
          "old_api": "AlreadyHave",
          "new_api": null,
          "old_text": "AlreadyHave(inv)",
          "new_text": null,
          "old_line_content": "        if (!AlreadyHave(inv) &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2226,
          "old_api": "GetTime",
          "new_api": null,
          "old_text": "GetTime()",
          "new_text": null,
          "old_line_content": "            pfrom->nLastTXTime = GetTime();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2228,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n                pfrom->GetId(),\n                tx.GetHash().ToString(),\n                mempool.size(), mempool.DynamicMemoryUsage() / 1000)",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2235,
          "old_api": "empty",
          "new_api": null,
          "old_text": "vWorkQueue.empty()",
          "new_text": null,
          "old_line_content": "            while (!vWorkQueue.empty()) {",
          "new_line_content": "            std::set<NodeId> setMisbehaving;",
          "content_same": false
        },
        {
          "line": 2240,
          "old_api": "begin",
          "new_api": null,
          "old_text": "itByPrev->second.begin()",
          "new_text": null,
          "old_line_content": "                for (auto mi = itByPrev->second.begin();",
          "new_line_content": "                    continue;",
          "content_same": false
        },
        {
          "line": 2246,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "orphanTx.GetHash()",
          "new_text": null,
          "old_line_content": "                    const uint256& orphanHash = orphanTx.GetHash();",
          "new_line_content": "                    const CTransaction& orphanTx = *porphanTx;",
          "content_same": false
        },
        {
          "line": 2255,
          "old_api": "count",
          "new_api": null,
          "old_text": "setMisbehaving.count(fromPeer)",
          "new_text": null,
          "old_line_content": "                    if (setMisbehaving.count(fromPeer))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2257,
          "old_api": "AcceptToMemoryPool",
          "new_api": null,
          "old_text": "AcceptToMemoryPool(mempool, stateDummy, porphanTx, &fMissingInputs2, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)",
          "new_text": null,
          "old_line_content": "                    if (AcceptToMemoryPool(mempool, stateDummy, porphanTx, &fMissingInputs2, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {",
          "new_line_content": "                        continue;",
          "content_same": false
        },
        {
          "line": 2263,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "vEraseQueue.push_back(orphanHash)",
          "new_text": null,
          "old_line_content": "                        vEraseQueue.push_back(orphanHash);",
          "new_line_content": "                        }",
          "content_same": false
        },
        {
          "line": 2268,
          "old_api": "IsInvalid",
          "new_api": null,
          "old_text": "stateDummy.IsInvalid(nDos)",
          "new_text": null,
          "old_line_content": "                        if (stateDummy.IsInvalid(nDos) && nDos > 0)",
          "new_line_content": "                        int nDos = 0;",
          "content_same": false
        },
        {
          "line": 2271,
          "old_api": "Misbehaving",
          "new_api": null,
          "old_text": "Misbehaving(fromPeer, nDos)",
          "new_text": null,
          "old_line_content": "                            Misbehaving(fromPeer, nDos);",
          "new_line_content": "                            // Punish peer that gave us an invalid orphan tx",
          "content_same": false
        },
        {
          "line": 2277,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "orphanHash.ToString()",
          "new_text": null,
          "old_line_content": "                        LogPrint(BCLog::MEMPOOL, \"   removed orphan tx %s\\n\", orphanHash.ToString());",
          "new_line_content": "                        // Probably non-standard or insufficient fee",
          "content_same": false
        },
        {
          "line": 2283,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(recentRejects)",
          "new_text": null,
          "old_line_content": "                            assert(recentRejects);",
          "new_line_content": "                            // See https://github.com/bitcoin/bitcoin/issues/8279 for details.",
          "content_same": false
        },
        {
          "line": 2287,
          "old_api": "get",
          "new_api": null,
          "old_text": "pcoinsTip.get()",
          "new_text": null,
          "old_line_content": "                    mempool.check(pcoinsTip.get());",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 2292,
          "old_api": "EraseOrphanTx",
          "new_api": null,
          "old_text": "EraseOrphanTx(hash)",
          "new_text": null,
          "old_line_content": "                EraseOrphanTx(hash);",
          "new_line_content": "            for (const uint256& hash : vEraseQueue)",
          "content_same": false
        },
        {
          "line": 2298,
          "old_api": "contains",
          "new_api": null,
          "old_text": "recentRejects->contains(txin.prevout.hash)",
          "new_text": null,
          "old_line_content": "                if (recentRejects->contains(txin.prevout.hash)) {",
          "new_line_content": "            for (const CTxIn& txin : tx.vin) {",
          "content_same": false
        },
        {
          "line": 2304,
          "old_api": "GetFetchFlags",
          "new_api": null,
          "old_text": "GetFetchFlags(pfrom)",
          "new_text": null,
          "old_line_content": "                uint32_t nFetchFlags = GetFetchFlags(pfrom);",
          "new_line_content": "            if (!fRejectedParents) {",
          "content_same": false
        },
        {
          "line": 2307,
          "old_api": "AddInventoryKnown",
          "new_api": null,
          "old_text": "pfrom->AddInventoryKnown(_inv)",
          "new_text": null,
          "old_line_content": "                    pfrom->AddInventoryKnown(_inv);",
          "new_line_content": "                    CInv _inv(MSG_TX | nFetchFlags, txin.prevout.hash);",
          "content_same": false
        },
        {
          "line": 2310,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "                AddOrphanTx(ptx, pfrom->GetId());",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 2313,
          "old_api": "GetArg",
          "new_api": null,
          "old_text": "gArgs.GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS)",
          "new_text": null,
          "old_line_content": "                unsigned int nMaxOrphanTx = (unsigned int)std::max((int64_t)0, gArgs.GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS));",
          "new_line_content": "                // DoS prevention: do not allow mapOrphanTransactions to grow unbounded",
          "content_same": false
        },
        {
          "line": 2316,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::MEMPOOL, \"mapOrphan overflow, removed %u tx\\n\", nEvicted)",
          "new_text": null,
          "old_line_content": "                    LogPrint(BCLog::MEMPOOL, \"mapOrphan overflow, removed %u tx\\n\", nEvicted);",
          "new_line_content": "                if (nEvicted > 0) {",
          "content_same": false
        },
        {
          "line": 2319,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "tx.GetHash().ToString()",
          "new_text": null,
          "old_line_content": "                LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s\\n\",tx.GetHash().ToString());",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 2322,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "tx.GetHash()",
          "new_text": null,
          "old_line_content": "                recentRejects->insert(tx.GetHash());",
          "new_line_content": "                // parents so avoid re-requesting it from other peers.",
          "content_same": false
        },
        {
          "line": 2325,
          "old_api": "CorruptionPossible",
          "new_api": null,
          "old_text": "state.CorruptionPossible()",
          "new_text": null,
          "old_line_content": "            if (!tx.HasWitness() && !state.CorruptionPossible()) {",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 2329,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(recentRejects)",
          "new_text": null,
          "old_line_content": "                assert(recentRejects);",
          "new_line_content": "                // See https://github.com/bitcoin/bitcoin/issues/8279 for details.",
          "content_same": false
        },
        {
          "line": 2334,
          "old_api": "RecursiveDynamicUsage",
          "new_api": null,
          "old_text": "RecursiveDynamicUsage(*ptx)",
          "new_text": null,
          "old_line_content": "            } else if (tx.HasWitness() && RecursiveDynamicUsage(*ptx) < 100000) {",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 2338,
          "old_api": "GetBoolArg",
          "new_api": null,
          "old_text": "gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)",
          "new_text": null,
          "old_line_content": "            if (pfrom->fWhitelisted && gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2348,
          "old_api": "IsInvalid",
          "new_api": null,
          "old_text": "state.IsInvalid(nDoS)",
          "new_text": null,
          "old_line_content": "                if (!state.IsInvalid(nDoS) || nDoS == 0) {",
          "new_line_content": "                int nDoS = 0;",
          "content_same": false
        },
        {
          "line": 2352,
          "old_api": "FormatStateMessage",
          "new_api": null,
          "old_text": "FormatStateMessage(state)",
          "new_text": null,
          "old_line_content": "                    LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->GetId(), FormatStateMessage(state));",
          "new_line_content": "                } else {",
          "content_same": false
        },
        {
          "line": 2358,
          "old_api": "AddToCompactExtraTransactions",
          "new_api": null,
          "old_text": "AddToCompactExtraTransactions(removedTx)",
          "new_text": null,
          "old_line_content": "            AddToCompactExtraTransactions(removedTx);",
          "new_line_content": "        for (const CTransactionRef& removedTx : lRemovedTxn)",
          "content_same": false
        },
        {
          "line": 2378,
          "old_api": "IsInvalid",
          "new_api": null,
          "old_text": "state.IsInvalid(nDoS)",
          "new_text": null,
          "old_line_content": "        if (state.IsInvalid(nDoS))",
          "new_line_content": "        int nDoS = 0;",
          "content_same": false
        },
        {
          "line": 2380,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "tx.GetHash().ToString()",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2388,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "                Misbehaving(pfrom->GetId(), nDoS);",
          "new_line_content": "            if (nDoS > 0) {",
          "content_same": false
        },
        {
          "line": 2402,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "        LOCK(cs_main);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2404,
          "old_api": "LookupBlockIndex",
          "new_api": null,
          "old_text": "LookupBlockIndex(cmpctblock.header.hashPrevBlock)",
          "new_text": null,
          "old_line_content": "        if (!LookupBlockIndex(cmpctblock.header.hashPrevBlock)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2406,
          "old_api": "IsInitialBlockDownload",
          "new_api": null,
          "old_text": "IsInitialBlockDownload()",
          "new_text": null,
          "old_line_content": "            if (!IsInitialBlockDownload())",
          "new_line_content": "            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers",
          "content_same": false
        },
        {
          "line": 2411,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "cmpctblock.header.GetHash()",
          "new_text": null,
          "old_line_content": "        if (!LookupBlockIndex(cmpctblock.header.GetHash())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2418,
          "old_api": "ProcessNewBlockHeaders",
          "new_api": null,
          "old_text": "ProcessNewBlockHeaders({cmpctblock.header}, state, chainparams, &pindex)",
          "new_text": null,
          "old_line_content": "        if (!ProcessNewBlockHeaders({cmpctblock.header}, state, chainparams, &pindex)) {",
          "new_line_content": "        CValidationState state;",
          "content_same": false
        },
        {
          "line": 2420,
          "old_api": "IsInvalid",
          "new_api": null,
          "old_text": "state.IsInvalid(nDoS)",
          "new_text": null,
          "old_line_content": "            if (state.IsInvalid(nDoS)) {",
          "new_line_content": "            int nDoS;",
          "content_same": false
        },
        {
          "line": 2422,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "                    LOCK(cs_main);",
          "new_line_content": "                if (nDoS > 0) {",
          "content_same": false
        },
        {
          "line": 2425,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "                    LogPrint(BCLog::NET, \"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->GetId());",
          "new_line_content": "                } else {",
          "content_same": false
        },
        {
          "line": 2444,
          "old_api": "std::make_shared<CBlock>()",
          "new_api": null,
          "old_text": "std::make_shared<CBlock>()",
          "new_text": null,
          "old_line_content": "        std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();",
          "new_line_content": "        // below)",
          "content_same": false
        },
        {
          "line": 2448,
          "old_api": "LOCK2",
          "new_api": null,
          "old_text": "LOCK2(cs_main, g_cs_orphans)",
          "new_text": null,
          "old_line_content": "        LOCK2(cs_main, g_cs_orphans);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2450,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(pindex)",
          "new_text": null,
          "old_line_content": "        assert(pindex);",
          "new_line_content": "        // If AcceptBlockHeader returned true, it set pindex",
          "content_same": false
        },
        {
          "line": 2453,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "        CNodeState *nodestate = State(pfrom->GetId());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2457,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "        if (received_new_header && pindex->nChainWork > chainActive.Tip()->nChainWork) {",
          "new_line_content": "        // peer's last block announcement time",
          "content_same": false
        },
        {
          "line": 2461,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindex->GetBlockHash()",
          "new_text": null,
          "old_line_content": "        std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2467,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "        if (pindex->nChainWork <= chainActive.Tip()->nChainWork || // We know something better",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2473,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "cmpctblock.header.GetHash()",
          "new_text": null,
          "old_line_content": "                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());",
          "new_line_content": "                std::vector<CInv> vInv(1);",
          "content_same": false
        },
        {
          "line": 2480,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "        if (!fAlreadyInFlight && !CanDirectFetch(chainparams.GetConsensus()))",
          "new_line_content": "        // If we're not close to tip yet, give up and let parallel block fetch work its magic",
          "content_same": false
        },
        {
          "line": 2483,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "        if (IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) && !nodestate->fSupportsDesiredCmpctVersion) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2491,
          "old_api": "Height",
          "new_api": null,
          "old_text": "chainActive.Height()",
          "new_text": null,
          "old_line_content": "        if (pindex->nHeight <= chainActive.Height() + 2) {",
          "new_line_content": "        // possibilities in compact block processing...",
          "content_same": false
        },
        {
          "line": 2493,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {",
          "new_line_content": "            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||",
          "content_same": false
        },
        {
          "line": 2495,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindex->GetBlockHash()",
          "new_text": null,
          "old_line_content": "                if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {",
          "new_line_content": "                std::list<QueuedBlock>::iterator* queuedBlockIt = nullptr;",
          "content_same": false
        },
        {
          "line": 2497,
          "old_api": "reset",
          "new_api": null,
          "old_text": "*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool))",
          "new_text": null,
          "old_line_content": "                        (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));",
          "new_line_content": "                    if (!(*queuedBlockIt)->partialBlock)",
          "content_same": false
        },
        {
          "line": 2500,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::NET, \"Peer sent us compact block we were already syncing!\\n\")",
          "new_text": null,
          "old_line_content": "                        LogPrint(BCLog::NET, \"Peer sent us compact block we were already syncing!\\n\");",
          "new_line_content": "                        // The block was already in flight using compact blocks from the same peer",
          "content_same": false
        },
        {
          "line": 2506,
          "old_api": "InitData",
          "new_api": null,
          "old_text": "partialBlock.InitData(cmpctblock, vExtraTxnForCompact)",
          "new_text": null,
          "old_line_content": "                ReadStatus status = partialBlock.InitData(cmpctblock, vExtraTxnForCompact);",
          "new_line_content": "                PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;",
          "content_same": false
        },
        {
          "line": 2508,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindex->GetBlockHash()",
          "new_text": null,
          "old_line_content": "                    MarkBlockAsReceived(pindex->GetBlockHash()); // Reset in-flight state in case of whitelist",
          "new_line_content": "                if (status == READ_STATUS_INVALID) {",
          "content_same": false
        },
        {
          "line": 2514,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "cmpctblock.header.GetHash()",
          "new_text": null,
          "old_line_content": "                    vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());",
          "new_line_content": "                    std::vector<CInv> vInv(1);",
          "content_same": false
        },
        {
          "line": 2520,
          "old_api": "BlockTxCount",
          "new_api": null,
          "old_text": "cmpctblock.BlockTxCount()",
          "new_text": null,
          "old_line_content": "                for (size_t i = 0; i < cmpctblock.BlockTxCount(); i++) {",
          "new_line_content": "                BlockTransactionsRequest req;",
          "content_same": false
        },
        {
          "line": 2524,
          "old_api": "empty",
          "new_api": null,
          "old_text": "req.indexes.empty()",
          "new_text": null,
          "old_line_content": "                if (req.indexes.empty()) {",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 2527,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "cmpctblock.header.GetHash()",
          "new_text": null,
          "old_line_content": "                    txn.blockhash = cmpctblock.header.GetHash();",
          "new_line_content": "                    BlockTransactions txn;",
          "content_same": false
        },
        {
          "line": 2531,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindex->GetBlockHash()",
          "new_text": null,
          "old_line_content": "                    req.blockhash = pindex->GetBlockHash();",
          "new_line_content": "                } else {",
          "content_same": false
        },
        {
          "line": 2541,
          "old_api": "InitData",
          "new_api": null,
          "old_text": "tempBlock.InitData(cmpctblock, vExtraTxnForCompact)",
          "new_text": null,
          "old_line_content": "                ReadStatus status = tempBlock.InitData(cmpctblock, vExtraTxnForCompact);",
          "new_line_content": "                PartiallyDownloadedBlock tempBlock(&mempool);",
          "content_same": false
        },
        {
          "line": 2547,
          "old_api": "FillBlock",
          "new_api": null,
          "old_text": "tempBlock.FillBlock(*pblock, dummy)",
          "new_text": null,
          "old_line_content": "                status = tempBlock.FillBlock(*pblock, dummy);",
          "new_line_content": "                std::vector<CTransactionRef> dummy;",
          "content_same": false
        },
        {
          "line": 2557,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "cmpctblock.header.GetHash()",
          "new_text": null,
          "old_line_content": "                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());",
          "new_line_content": "                std::vector<CInv> vInv(1);",
          "content_same": false
        },
        {
          "line": 2568,
          "old_api": "ProcessMessage",
          "new_api": null,
          "old_text": "ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, interruptMsgProc, enable_bip61)",
          "new_text": null,
          "old_line_content": "            return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, interruptMsgProc, enable_bip61);",
          "new_line_content": "        if (fProcessBLOCKTXN)",
          "content_same": false
        },
        {
          "line": 2576,
          "old_api": "ProcessHeadersMessage",
          "new_api": null,
          "old_text": "ProcessHeadersMessage(pfrom, connman, {cmpctblock.header}, chainparams, /*punish_duplicate_invalid=*/false)",
          "new_text": null,
          "old_line_content": "            return ProcessHeadersMessage(pfrom, connman, {cmpctblock.header}, chainparams, /*punish_duplicate_invalid=*/false);",
          "new_line_content": "            // will be detected and the peer will be banned.",
          "content_same": false
        },
        {
          "line": 2583,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "                LOCK(cs_main);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 2596,
          "old_api": "ProcessNewBlock",
          "new_api": null,
          "old_text": "ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock)",
          "new_text": null,
          "old_line_content": "            ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);",
          "new_line_content": "            // reconstructed compact blocks as having been requested.",
          "content_same": false
        },
        {
          "line": 2598,
          "old_api": "GetTime",
          "new_api": null,
          "old_text": "GetTime()",
          "new_text": null,
          "old_line_content": "                pfrom->nLastBlockTime = GetTime();",
          "new_line_content": "            if (fNewBlock) {",
          "content_same": false
        },
        {
          "line": 2600,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "                LOCK(cs_main);",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 2603,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "            LOCK(cs_main); // hold cs_main for CBlockIndex::IsValid()",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2609,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "pblock->GetHash()",
          "new_text": null,
          "old_line_content": "                MarkBlockAsReceived(pblock->GetHash());",
          "new_line_content": "                // can't be used to interfere with block relay.",
          "content_same": false
        },
        {
          "line": 2620,
          "old_api": "std::make_shared<CBlock>()",
          "new_api": null,
          "old_text": "std::make_shared<CBlock>()",
          "new_text": null,
          "old_line_content": "        std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2623,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "            LOCK(cs_main);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2625,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapBlocksInFlight.find(resp.blockhash)",
          "new_text": null,
          "old_line_content": "            std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2633,
          "old_api": "FillBlock",
          "new_api": null,
          "old_text": "partialBlock.FillBlock(*pblock, resp.txn)",
          "new_text": null,
          "old_line_content": "            ReadStatus status = partialBlock.FillBlock(*pblock, resp.txn);",
          "new_line_content": "            PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;",
          "content_same": false
        },
        {
          "line": 2635,
          "old_api": "MarkBlockAsReceived",
          "new_api": null,
          "old_text": "MarkBlockAsReceived(resp.blockhash)",
          "new_text": null,
          "old_line_content": "                MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case of whitelist",
          "new_line_content": "            if (status == READ_STATUS_INVALID) {",
          "content_same": false
        },
        {
          "line": 2641,
          "old_api": "GetFetchFlags",
          "new_api": null,
          "old_text": "GetFetchFlags(pfrom)",
          "new_text": null,
          "old_line_content": "                invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom), resp.blockhash));",
          "new_line_content": "                std::vector<CInv> invs;",
          "content_same": false
        },
        {
          "line": 2661,
          "old_api": "MarkBlockAsReceived",
          "new_api": null,
          "old_text": "MarkBlockAsReceived(resp.blockhash)",
          "new_text": null,
          "old_line_content": "                MarkBlockAsReceived(resp.blockhash); // it is now an empty pointer",
          "new_line_content": "                // updated, reject messages go out, etc.",
          "content_same": false
        },
        {
          "line": 2668,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "                mapBlockSource.emplace(resp.blockhash, std::make_pair(pfrom->GetId(), false));",
          "new_line_content": "                // out to be invalid.",
          "content_same": false
        },
        {
          "line": 2679,
          "old_api": "ProcessNewBlock",
          "new_api": null,
          "old_text": "ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock)",
          "new_text": null,
          "old_line_content": "            ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);",
          "new_line_content": "            // in compact block optimistic reconstruction handling.",
          "content_same": false
        },
        {
          "line": 2681,
          "old_api": "GetTime",
          "new_api": null,
          "old_text": "GetTime()",
          "new_text": null,
          "old_line_content": "                pfrom->nLastBlockTime = GetTime();",
          "new_line_content": "            if (fNewBlock) {",
          "content_same": false
        },
        {
          "line": 2683,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "                LOCK(cs_main);",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 2695,
          "old_api": "ReadCompactSize",
          "new_api": null,
          "old_text": "ReadCompactSize(vRecv)",
          "new_text": null,
          "old_line_content": "        unsigned int nCount = ReadCompactSize(vRecv);",
          "new_line_content": "        // Bypass the normal CBlock deserialization, as we don't want to risk deserializing 2000 full blocks.",
          "content_same": false
        },
        {
          "line": 2697,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "            LOCK(cs_main);",
          "new_line_content": "        if (nCount > MAX_HEADERS_RESULTS) {",
          "content_same": false
        },
        {
          "line": 2701,
          "old_api": "resize",
          "new_api": null,
          "old_text": "headers.resize(nCount)",
          "new_text": null,
          "old_line_content": "        headers.resize(nCount);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2704,
          "old_api": "ReadCompactSize",
          "new_api": null,
          "old_text": "ReadCompactSize(vRecv)",
          "new_text": null,
          "old_line_content": "            ReadCompactSize(vRecv); // ignore tx count; assume it is 0.",
          "new_line_content": "            vRecv >> headers[n];",
          "content_same": false
        },
        {
          "line": 2712,
          "old_api": "ProcessHeadersMessage",
          "new_api": null,
          "old_text": "ProcessHeadersMessage(pfrom, connman, headers, chainparams, should_punish)",
          "new_text": null,
          "old_line_content": "        return ProcessHeadersMessage(pfrom, connman, headers, chainparams, should_punish);",
          "new_line_content": "        bool should_punish = !pfrom->fInbound && !pfrom->m_manual_connection;",
          "content_same": false
        },
        {
          "line": 2717,
          "old_api": "std::make_shared<CBlock>()",
          "new_api": null,
          "old_text": "std::make_shared<CBlock>()",
          "new_text": null,
          "old_line_content": "        std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2720,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom->GetId());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2723,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "pblock->GetHash()",
          "new_text": null,
          "old_line_content": "        const uint256 hash(pblock->GetHash());",
          "new_line_content": "        bool forceProcessing = false;",
          "content_same": false
        },
        {
          "line": 2725,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "            LOCK(cs_main);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2728,
          "old_api": "MarkBlockAsReceived",
          "new_api": null,
          "old_text": "MarkBlockAsReceived(hash)",
          "new_text": null,
          "old_line_content": "            forceProcessing |= MarkBlockAsReceived(hash);",
          "new_line_content": "            // need it even though it is not a candidate for a new best tip.",
          "content_same": false
        },
        {
          "line": 2731,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "            mapBlockSource.emplace(hash, std::make_pair(pfrom->GetId(), true));",
          "new_line_content": "            // so the race between here and cs_main in ProcessNewBlock is fine.",
          "content_same": false
        },
        {
          "line": 2734,
          "old_api": "ProcessNewBlock",
          "new_api": null,
          "old_text": "ProcessNewBlock(chainparams, pblock, forceProcessing, &fNewBlock)",
          "new_text": null,
          "old_line_content": "        ProcessNewBlock(chainparams, pblock, forceProcessing, &fNewBlock);",
          "new_line_content": "        bool fNewBlock = false;",
          "content_same": false
        },
        {
          "line": 2736,
          "old_api": "GetTime",
          "new_api": null,
          "old_text": "GetTime()",
          "new_text": null,
          "old_line_content": "            pfrom->nLastBlockTime = GetTime();",
          "new_line_content": "        if (fNewBlock) {",
          "content_same": false
        },
        {
          "line": 2738,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "            LOCK(cs_main);",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 2751,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"Ignoring \\\"getaddr\\\" from outbound connection. peer=%d\\n\", pfrom->GetId());",
          "new_line_content": "        if (!pfrom->fInbound) {",
          "content_same": false
        },
        {
          "line": 2758,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"Ignoring repeated \\\"getaddr\\\". peer=%d\\n\", pfrom->GetId());",
          "new_line_content": "        if (pfrom->fSentAddr) {",
          "content_same": false
        },
        {
          "line": 2763,
          "old_api": "clear",
          "new_api": null,
          "old_text": "pfrom->vAddrToSend.clear()",
          "new_text": null,
          "old_line_content": "        pfrom->vAddrToSend.clear();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2767,
          "old_api": "PushAddress",
          "new_api": null,
          "old_text": "pfrom->PushAddress(addr, insecure_rand)",
          "new_text": null,
          "old_line_content": "            pfrom->PushAddress(addr, insecure_rand);",
          "new_line_content": "        for (const CAddress &addr : vAddr)",
          "content_same": false
        },
        {
          "line": 2772,
          "old_api": "GetLocalServices",
          "new_api": null,
          "old_text": "pfrom->GetLocalServices()",
          "new_text": null,
          "old_line_content": "        if (!(pfrom->GetLocalServices() & NODE_BLOOM) && !pfrom->fWhitelisted)",
          "new_line_content": "    if (strCommand == NetMsgType::MEMPOOL) {",
          "content_same": false
        },
        {
          "line": 2774,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"mempool request with bloom filters disabled, disconnect peer=%d\\n\", pfrom->GetId());",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2779,
          "old_api": "OutboundTargetReached",
          "new_api": null,
          "old_text": "connman->OutboundTargetReached(false)",
          "new_text": null,
          "old_line_content": "        if (connman->OutboundTargetReached(false) && !pfrom->fWhitelisted)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2781,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"mempool request with bandwidth limit reached, disconnect peer=%d\\n\", pfrom->GetId());",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2786,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pfrom->cs_inventory)",
          "new_text": null,
          "old_line_content": "        LOCK(pfrom->cs_inventory);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2807,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(NetMsgType::PONG, nonce)",
          "new_text": null,
          "old_line_content": "            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::PONG, nonce));",
          "new_line_content": "            // return very quickly.",
          "content_same": false
        },
        {
          "line": 2815,
          "old_api": "in_avail",
          "new_api": null,
          "old_text": "vRecv.in_avail()",
          "new_text": null,
          "old_line_content": "        size_t nAvail = vRecv.in_avail();",
          "new_line_content": "        uint64_t nonce = 0;",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": "size",
          "new_api": null,
          "old_text": "mapOrphanTransactions.size()",
          "new_text": null,
          "old_line_content": "    while (mapOrphanTransactions.size() > nMaxOrphans)",
          "new_line_content": "    FastRandomContext rng;",
          "content_same": false
        },
        {
          "line": 2831,
          "old_api": "load",
          "new_api": null,
          "old_text": "pfrom->nMinPingUsecTime.load()",
          "new_text": null,
          "old_line_content": "                        pfrom->nMinPingUsecTime = std::min(pfrom->nMinPingUsecTime.load(), pingUsecTime);",
          "new_line_content": "                        pfrom->nPingUsecTime = pingUsecTime;",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": "GetRandHash",
          "new_api": null,
          "old_text": "GetRandHash()",
          "new_text": null,
          "old_line_content": "        uint256 randomhash = GetRandHash();",
          "new_line_content": "        // Evict a random orphan:",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": "State",
          "new_api": null,
          "old_text": "State(pnode)",
          "new_text": null,
          "old_line_content": "    CNodeState *state = State(pnode);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2854,
          "old_api": "empty",
          "new_api": null,
          "old_text": "sProblem.empty()",
          "new_text": null,
          "old_line_content": "        if (!(sProblem.empty())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": "GetArg",
          "new_api": null,
          "old_text": "gArgs.GetArg(\"-banscore\", DEFAULT_BANSCORE_THRESHOLD)",
          "new_text": null,
          "old_line_content": "    int banscore = gArgs.GetArg(\"-banscore\", DEFAULT_BANSCORE_THRESHOLD);",
          "new_line_content": "    state->nMisbehavior += howmuch;",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d) BAN THRESHOLD EXCEEDED%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed)",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d) BAN THRESHOLD EXCEEDED%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed)",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"%s: %s peer=%d (%d -> %d)%s\\n\", __func__, state->name, pnode, state->nMisbehavior-howmuch, state->nMisbehavior, message_prefixed);",
          "new_line_content": "    } else",
          "content_same": false
        },
        {
          "line": 2872,
          "old_api": "IsWithinSizeConstraints",
          "new_api": null,
          "old_text": "filter.IsWithinSizeConstraints()",
          "new_text": null,
          "old_line_content": "        if (!filter.IsWithinSizeConstraints())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2875,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "            LOCK(cs_main);",
          "new_line_content": "            // There is no excuse for sending a too-large filter",
          "content_same": false
        },
        {
          "line": 2880,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pfrom->cs_filter)",
          "new_text": null,
          "old_line_content": "            LOCK(pfrom->cs_filter);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": "AssertLockHeld",
          "new_api": null,
          "old_text": "AssertLockHeld(cs_main)",
          "new_text": null,
          "old_line_content": "    AssertLockHeld(cs_main);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": "reset",
          "new_api": null,
          "old_text": "recentRejects.reset(new CRollingBloomFilter(120000, 0.000001))",
          "new_text": null,
          "old_line_content": "    recentRejects.reset(new CRollingBloomFilter(120000, 0.000001));",
          "new_line_content": "    // Initialize global variables that cannot be constructed at startup.",
          "content_same": false
        },
        {
          "line": 2895,
          "old_api": "size",
          "new_api": null,
          "old_text": "vData.size()",
          "new_text": null,
          "old_line_content": "        if (vData.size() > MAX_SCRIPT_ELEMENT_SIZE) {",
          "new_line_content": "        bool bad = false;",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "Params().GetConsensus()",
          "new_text": null,
          "old_line_content": "    const Consensus::Params& consensusParams = Params().GetConsensus();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2898,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pfrom->cs_filter)",
          "new_text": null,
          "old_line_content": "            LOCK(pfrom->cs_filter);",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 2900,
          "old_api": "insert",
          "new_api": null,
          "old_text": "pfrom->pfilter->insert(vData)",
          "new_text": null,
          "old_line_content": "                pfrom->pfilter->insert(vData);",
          "new_line_content": "            if (pfrom->pfilter) {",
          "content_same": false
        },
        {
          "line": 855,
          "old_api": "std::bind(&PeerLogicValidation::CheckForStaleTipAndEvictPeers, this, consensusParams)",
          "new_api": null,
          "old_text": "std::bind(&PeerLogicValidation::CheckForStaleTipAndEvictPeers, this, consensusParams)",
          "new_text": null,
          "old_line_content": "    scheduler.scheduleEvery(std::bind(&PeerLogicValidation::CheckForStaleTipAndEvictPeers, this, consensusParams), EXTRA_PEER_CHECK_INTERVAL * 1000);",
          "new_line_content": "    static_assert(EXTRA_PEER_CHECK_INTERVAL < STALE_CHECK_INTERVAL, \"peer eviction timer should be less than stale tip check timer\");",
          "content_same": false
        },
        {
          "line": 2906,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "            LOCK(cs_main);",
          "new_line_content": "        if (bad) {",
          "content_same": false
        },
        {
          "line": 863,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(g_cs_orphans)",
          "new_text": null,
          "old_line_content": "    LOCK(g_cs_orphans);",
          "new_line_content": "void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindex, const std::vector<CTransactionRef>& vtxConflicted) {",
          "content_same": false
        },
        {
          "line": 2913,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pfrom->cs_filter)",
          "new_text": null,
          "old_line_content": "        LOCK(pfrom->cs_filter);",
          "new_line_content": "    if (strCommand == NetMsgType::FILTERCLEAR) {",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapOrphanTransactionsByPrev.find(txin.prevout)",
          "new_text": null,
          "old_line_content": "            auto itByPrev = mapOrphanTransactionsByPrev.find(txin.prevout);",
          "new_line_content": "        for (const auto& txin : tx.vin) {",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "orphanTx.GetHash()",
          "new_text": null,
          "old_line_content": "                const uint256& orphanHash = orphanTx.GetHash();",
          "new_line_content": "                const CTransaction& orphanTx = *(*mi)->second.tx;",
          "content_same": false
        },
        {
          "line": 2924,
          "old_api": "MoneyRange",
          "new_api": null,
          "old_text": "MoneyRange(newFeeFilter)",
          "new_text": null,
          "old_line_content": "        if (MoneyRange(newFeeFilter)) {",
          "new_line_content": "        vRecv >> newFeeFilter;",
          "content_same": false
        },
        {
          "line": 2926,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pfrom->cs_feeFilter)",
          "new_text": null,
          "old_line_content": "                LOCK(pfrom->cs_feeFilter);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 2929,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->GetId());",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 883,
          "old_api": "size",
          "new_api": null,
          "old_text": "vOrphanErase.size()",
          "new_text": null,
          "old_line_content": "    if (vOrphanErase.size()) {",
          "new_line_content": "    // Erase orphan transactions included or precluded by this block",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": "EraseOrphanTx",
          "new_api": null,
          "old_text": "EraseOrphanTx(orphanHash)",
          "new_text": null,
          "old_line_content": "            nErased += EraseOrphanTx(orphanHash);",
          "new_line_content": "        for (const uint256& orphanHash : vOrphanErase) {",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx included or conflicted by block\\n\", nErased)",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": "GetTime",
          "new_api": null,
          "old_text": "GetTime()",
          "new_text": null,
          "old_line_content": "    g_last_tip_update = GetTime();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2941,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(strCommand), pfrom->GetId());",
          "new_line_content": "    // Ignore unknown commands for extensibility",
          "content_same": false
        },
        {
          "line": 2947,
          "old_api": "AssertLockHeld",
          "new_api": null,
          "old_text": "AssertLockHeld(cs_main)",
          "new_text": null,
          "old_line_content": "    AssertLockHeld(cs_main);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2952,
          "old_api": "std::string(NetMsgType::BLOCK)",
          "new_api": null,
          "old_text": "std::string(NetMsgType::BLOCK)",
          "new_text": null,
          "old_line_content": "            connman->PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, std::string(NetMsgType::BLOCK), reject.chRejectCode, reject.strRejectReason, reject.hashBlock));",
          "new_line_content": "        for (const CBlockReject& reject : state.rejects) {",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": "std::make_shared<const CBlockHeaderAndShortTxIDs> (*pblock, true)",
          "new_api": null,
          "old_text": "std::make_shared<const CBlockHeaderAndShortTxIDs> (*pblock, true)",
          "new_text": null,
          "old_line_content": "    std::shared_ptr<const CBlockHeaderAndShortTxIDs> pcmpctblock = std::make_shared<const CBlockHeaderAndShortTxIDs> (*pblock, true);",
          "new_line_content": "void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) {",
          "content_same": false
        },
        {
          "line": 2955,
          "old_api": "clear",
          "new_api": null,
          "old_text": "state.rejects.clear()",
          "new_text": null,
          "old_line_content": "    state.rejects.clear();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2960,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "pnode->addr.ToString()",
          "new_text": null,
          "old_line_content": "            LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pnode->addr.ToString());",
          "new_line_content": "        if (pnode->fWhitelisted)",
          "content_same": false
        },
        {
          "line": 2962,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "pnode->addr.ToString()",
          "new_text": null,
          "old_line_content": "            LogPrintf(\"Warning: not punishing manually-connected peer %s!\\n\", pnode->addr.ToString());",
          "new_line_content": "        else if (pnode->m_manual_connection)",
          "content_same": false
        },
        {
          "line": 916,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "Params().GetConsensus()",
          "new_text": null,
          "old_line_content": "    bool fWitnessEnabled = IsWitnessEnabled(pindex->pprev, Params().GetConsensus());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2965,
          "old_api": "IsLocal",
          "new_api": null,
          "old_text": "pnode->addr.IsLocal()",
          "new_text": null,
          "old_line_content": "            if (pnode->addr.IsLocal())",
          "new_line_content": "            pnode->fDisconnect = true;",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_most_recent_block)",
          "new_text": null,
          "old_line_content": "        LOCK(cs_most_recent_block);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2969,
          "old_api": "Ban",
          "new_api": null,
          "old_text": "connman->Ban(pnode->addr, BanReasonNodeMisbehaving)",
          "new_text": null,
          "old_line_content": "                connman->Ban(pnode->addr, BanReasonNodeMisbehaving);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "connman->ForEachNode([this, &pcmpctblock, pindex, &msgMaker, fWitnessEnabled, &hashBlock](CNode* pnode) {\n        AssertLockHeld(cs_main);\n\n        // TODO: Avoid the repeated-serialization here\n        if (pnode->nVersion < INVALID_CB_NO_BAN_VERSION || pnode->fDisconnect)\n            return;\n        ProcessBlockAvailability(pnode->GetId());\n        CNodeState &state = *State(pnode->GetId());\n        // If the peer has, or we announced to them the previous block already,\n        // but we don't think they have this one, go ahead and announce it\n        if (state.fPreferHeaderAndIDs && (!fWitnessEnabled || state.fWantsCmpctWitness) &&\n                !PeerHasHeader(&state, pindex) && PeerHasHeader(&state, pindex->pprev)) {\n\n            LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", \"PeerLogicValidation::NewPoWValidBlock\",\n                    hashBlock.ToString(), pnode->GetId());\n            connman->PushMessage(pnode, msgMaker.Make(NetMsgType::CMPCTBLOCK, *pcmpctblock));\n            state.pindexBestHeaderSent = pindex;\n        }\n    })",
          "new_text": null,
          "old_line_content": "    connman->ForEachNode([this, &pcmpctblock, pindex, &msgMaker, fWitnessEnabled, &hashBlock](CNode* pnode) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2979,
          "old_api": "Params",
          "new_api": null,
          "old_text": "Params()",
          "new_text": null,
          "old_line_content": "    const CChainParams& chainparams = Params();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pnode->GetId()",
          "new_text": null,
          "old_line_content": "        ProcessBlockAvailability(pnode->GetId());",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": "PeerHasHeader",
          "new_api": null,
          "old_text": "PeerHasHeader(&state, pindex->pprev)",
          "new_text": null,
          "old_line_content": "                !PeerHasHeader(&state, pindex) && PeerHasHeader(&state, pindex->pprev)) {",
          "new_line_content": "        if (state.fPreferHeaderAndIDs && (!fWitnessEnabled || state.fWantsCmpctWitness) &&",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", \"PeerLogicValidation::NewPoWValidBlock\",\n                    hashBlock.ToString(), pnode->GetId())",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", \"PeerLogicValidation::NewPoWValidBlock\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2990,
          "old_api": "empty",
          "new_api": null,
          "old_text": "pfrom->vRecvGetData.empty()",
          "new_text": null,
          "old_line_content": "    if (!pfrom->vRecvGetData.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2997,
          "old_api": "empty",
          "new_api": null,
          "old_text": "pfrom->vRecvGetData.empty()",
          "new_text": null,
          "old_line_content": "    if (!pfrom->vRecvGetData.empty()) return true;",
          "new_line_content": "    // this maintains the order of responses",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": "SetBestHeight",
          "new_api": null,
          "old_text": "connman->SetBestHeight(nNewHeight)",
          "new_text": null,
          "old_line_content": "    connman->SetBestHeight(nNewHeight);",
          "new_line_content": "    const int nNewHeight = pindexNew->nHeight;",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": "SetServiceFlagsIBDCache",
          "new_api": null,
          "old_text": "SetServiceFlagsIBDCache(!fInitialDownload)",
          "new_text": null,
          "old_line_content": "    SetServiceFlagsIBDCache(!fInitialDownload);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3005,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pfrom->cs_vProcessMsg)",
          "new_text": null,
          "old_line_content": "        LOCK(pfrom->cs_vProcessMsg);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3009,
          "old_api": "begin",
          "new_api": null,
          "old_text": "pfrom->vProcessMsg.begin()",
          "new_text": null,
          "old_line_content": "        msgs.splice(msgs.begin(), pfrom->vProcessMsg, pfrom->vProcessMsg.begin());",
          "new_line_content": "        // Just take one message",
          "content_same": false
        },
        {
          "line": 962,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindexToAnnounce->GetBlockHash()",
          "new_text": null,
          "old_line_content": "            vHashes.push_back(pindexToAnnounce->GetBlockHash());",
          "new_line_content": "        while (pindexToAnnounce != pindexFork) {",
          "content_same": false
        },
        {
          "line": 964,
          "old_api": "size",
          "new_api": null,
          "old_text": "vHashes.size()",
          "new_text": null,
          "old_line_content": "            if (vHashes.size() == MAX_BLOCKS_TO_ANNOUNCE) {",
          "new_line_content": "            pindexToAnnounce = pindexToAnnounce->pprev;",
          "content_same": false
        },
        {
          "line": 3014,
          "old_api": "front",
          "new_api": null,
          "old_text": "msgs.front()",
          "new_text": null,
          "old_line_content": "    CNetMessage& msg(msgs.front());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3016,
          "old_api": "GetRecvVersion",
          "new_api": null,
          "old_text": "pfrom->GetRecvVersion()",
          "new_text": null,
          "old_line_content": "    msg.SetVersion(pfrom->GetRecvVersion());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3018,
          "old_api": "MessageStart",
          "new_api": null,
          "old_text": "chainparams.MessageStart()",
          "new_text": null,
          "old_line_content": "    if (memcmp(msg.hdr.pchMessageStart, chainparams.MessageStart(), CMessageHeader::MESSAGE_START_SIZE) != 0) {",
          "new_line_content": "    // Scan for message start",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": "ForEachNode",
          "new_api": null,
          "old_text": "connman->ForEachNode([nNewHeight, &vHashes](CNode* pnode) {\n            if (nNewHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : 0)) {\n                for (const uint256& hash : reverse_iterate(vHashes)) {\n                    pnode->PushBlockHash(hash);\n                }\n            }\n        })",
          "new_text": null,
          "old_line_content": "        connman->ForEachNode([nNewHeight, &vHashes](CNode* pnode) {",
          "new_line_content": "        // Relay inventory, but don't relay old inventory during initial block download.",
          "content_same": false
        },
        {
          "line": 973,
          "old_api": "reverse_iterate",
          "new_api": null,
          "old_text": "reverse_iterate(vHashes)",
          "new_text": null,
          "old_line_content": "                for (const uint256& hash : reverse_iterate(vHashes)) {",
          "new_line_content": "            if (nNewHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : 0)) {",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "WakeMessageHandler",
          "new_api": null,
          "old_text": "connman->WakeMessageHandler()",
          "new_text": null,
          "old_line_content": "        connman->WakeMessageHandler();",
          "new_line_content": "        });",
          "content_same": false
        },
        {
          "line": 3026,
          "old_api": "MessageStart",
          "new_api": null,
          "old_text": "chainparams.MessageStart()",
          "new_text": null,
          "old_line_content": "    if (!hdr.IsValid(chainparams.MessageStart()))",
          "new_line_content": "    CMessageHeader& hdr = msg.hdr;",
          "content_same": false
        },
        {
          "line": 3028,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"PROCESSMESSAGE: ERRORS IN HEADER %s peer=%d\\n\", SanitizeString(hdr.GetCommand()), pfrom->GetId());",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": "GetTime",
          "new_api": null,
          "old_text": "GetTime()",
          "new_text": null,
          "old_line_content": "    nTimeBestReceived = GetTime();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3031,
          "old_api": "GetCommand",
          "new_api": null,
          "old_text": "hdr.GetCommand()",
          "new_text": null,
          "old_line_content": "    std::string strCommand = hdr.GetCommand();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationState& state) {",
          "content_same": false
        },
        {
          "line": 3038,
          "old_api": "GetMessageHash",
          "new_api": null,
          "old_text": "msg.GetMessageHash()",
          "new_text": null,
          "old_line_content": "    const uint256& hash = msg.GetMessageHash();",
          "new_line_content": "    CDataStream& vRecv = msg.vRecv;",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "block.GetHash()",
          "new_text": null,
          "old_line_content": "    const uint256 hash(block.GetHash());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3041,
          "old_api": "begin",
          "new_api": null,
          "old_text": "LogPrint(BCLog::NET, \"%s(%s, %u bytes): CHECKSUM ERROR expected %s was %s\\n\", __func__,\n           SanitizeString(strCommand), nMessageSize,\n           HexStr(hash.begin(), hash.begin()+CMessageHeader::CHECKSUM_SIZE),\n           HexStr(hdr.pchChecksum, hdr.pchChecksum+CMessageHeader::CHECKSUM_SIZE))",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"%s(%s, %u bytes): CHECKSUM ERROR expected %s was %s\\n\", __func__,",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": "IsInvalid",
          "new_api": null,
          "old_text": "state.IsInvalid(nDoS)",
          "new_text": null,
          "old_line_content": "    if (state.IsInvalid(nDoS)) {",
          "new_line_content": "    int nDoS = 0;",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": "GetRejectCode",
          "new_api": null,
          "old_text": "state.GetRejectCode()",
          "new_text": null,
          "old_line_content": "        if (it != mapBlockSource.end() && State(it->second.first) && state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) {",
          "new_line_content": "        // Don't send reject message with code 0 or an internal reject code.",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": "Misbehaving",
          "new_api": null,
          "old_text": "Misbehaving(it->second.first, nDoS)",
          "new_text": null,
          "old_line_content": "                Misbehaving(it->second.first, nDoS);",
          "new_line_content": "            if (nDoS > 0 && it->second.second)",
          "content_same": false
        },
        {
          "line": 3052,
          "old_api": "ProcessMessage",
          "new_api": null,
          "old_text": "ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc, m_enable_bip61)",
          "new_text": null,
          "old_line_content": "        fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc, m_enable_bip61);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3055,
          "old_api": "empty",
          "new_api": null,
          "old_text": "pfrom->vRecvGetData.empty()",
          "new_text": null,
          "old_line_content": "        if (!pfrom->vRecvGetData.empty())",
          "new_line_content": "            return false;",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "state.IsValid()",
          "new_text": null,
          "old_line_content": "    else if (state.IsValid() &&",
          "new_line_content": "    //    just check that there are currently no other blocks in flight.",
          "content_same": false
        },
        {
          "line": 3061,
          "old_api": "std::string(\"error parsing message\")",
          "new_api": null,
          "old_text": "std::string(\"error parsing message\")",
          "new_text": null,
          "old_line_content": "            connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, std::string(\"error parsing message\")));",
          "new_line_content": "        if (m_enable_bip61) {",
          "content_same": false
        },
        {
          "line": 3063,
          "old_api": "what",
          "new_api": null,
          "old_text": "e.what()",
          "new_text": null,
          "old_line_content": "        if (strstr(e.what(), \"end of data\"))",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1017,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapBlockSource.end()",
          "new_text": null,
          "old_line_content": "    if (it != mapBlockSource.end())",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3066,
          "old_api": "what",
          "new_api": null,
          "old_text": "e.what()",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"%s(%s, %u bytes): Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());",
          "new_line_content": "            // Allow exceptions from under-length message on vRecv",
          "content_same": false
        },
        {
          "line": 3068,
          "old_api": "what",
          "new_api": null,
          "old_text": "e.what()",
          "new_text": null,
          "old_line_content": "        else if (strstr(e.what(), \"size too large\"))",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3071,
          "old_api": "what",
          "new_api": null,
          "old_text": "e.what()",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());",
          "new_line_content": "            // Allow exceptions from over-long size",
          "content_same": false
        },
        {
          "line": 3073,
          "old_api": "what",
          "new_api": null,
          "old_text": "e.what()",
          "new_text": null,
          "old_line_content": "        else if (strstr(e.what(), \"non-canonical ReadCompactSize()\"))",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3076,
          "old_api": "what",
          "new_api": null,
          "old_text": "e.what()",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());",
          "new_line_content": "            // Allow exceptions from non-canonical encoding",
          "content_same": false
        },
        {
          "line": 3080,
          "old_api": "PrintExceptionContinue",
          "new_api": null,
          "old_text": "PrintExceptionContinue(&e, \"ProcessMessages()\")",
          "new_text": null,
          "old_line_content": "            PrintExceptionContinue(&e, \"ProcessMessages()\");",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(recentRejects)",
          "new_text": null,
          "old_line_content": "            assert(recentRejects);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 3084,
          "old_api": "PrintExceptionContinue",
          "new_api": null,
          "old_text": "PrintExceptionContinue(&e, \"ProcessMessages()\")",
          "new_text": null,
          "old_line_content": "        PrintExceptionContinue(&e, \"ProcessMessages()\");",
          "new_line_content": "    catch (const std::exception& e) {",
          "content_same": false
        },
        {
          "line": 3086,
          "old_api": "PrintExceptionContinue",
          "new_api": null,
          "old_text": "PrintExceptionContinue(nullptr, \"ProcessMessages()\")",
          "new_text": null,
          "old_line_content": "        PrintExceptionContinue(nullptr, \"ProcessMessages()\");",
          "new_line_content": "    } catch (...) {",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()->GetBlockHash()",
          "new_text": null,
          "old_line_content": "                hashRecentRejectsChainTip = chainActive.Tip()->GetBlockHash();",
          "new_line_content": "                // txs a second chance.",
          "content_same": false
        },
        {
          "line": 3090,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"%s(%s, %u bytes) FAILED peer=%d\\n\", __func__, SanitizeString(strCommand), nMessageSize, pfrom->GetId());",
          "new_line_content": "    if (!fRet) {",
          "content_same": false
        },
        {
          "line": 3093,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1046,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(g_cs_orphans)",
          "new_text": null,
          "old_line_content": "                LOCK(g_cs_orphans);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1050,
          "old_api": "contains",
          "new_api": null,
          "old_text": "recentRejects->contains(inv.hash)",
          "new_text": null,
          "old_line_content": "            return recentRejects->contains(inv.hash) ||",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3101,
          "old_api": "AssertLockHeld",
          "new_api": null,
          "old_text": "AssertLockHeld(cs_main)",
          "new_text": null,
          "old_line_content": "    AssertLockHeld(cs_main);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3103,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pto->GetId()",
          "new_text": null,
          "old_line_content": "    CNodeState &state = *State(pto->GetId());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1057,
          "old_api": "LookupBlockIndex",
          "new_api": null,
          "old_text": "LookupBlockIndex(inv.hash)",
          "new_text": null,
          "old_line_content": "        return LookupBlockIndex(inv.hash) != nullptr;",
          "new_line_content": "    case MSG_WITNESS_BLOCK:",
          "content_same": false
        },
        {
          "line": 3106,
          "old_api": "IsOutboundDisconnectionCandidate",
          "new_api": null,
          "old_text": "IsOutboundDisconnectionCandidate(pto)",
          "new_text": null,
          "old_line_content": "    if (!state.m_chain_sync.m_protect && IsOutboundDisconnectionCandidate(pto) && state.fSyncStarted) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1065,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "tx.GetHash()",
          "new_text": null,
          "old_line_content": "    CInv inv(MSG_TX, tx.GetHash());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3113,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "        if (state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= chainActive.Tip()->nChainWork) {",
          "new_line_content": "        // disconnect from them elsewhere).",
          "content_same": false
        },
        {
          "line": 1068,
          "old_api": "PushInventory",
          "new_api": null,
          "old_text": "pnode->PushInventory(inv)",
          "new_text": null,
          "old_line_content": "        pnode->PushInventory(inv);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3125,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "            state.m_chain_sync.m_work_header = chainActive.Tip();",
          "new_line_content": "            state.m_chain_sync.m_timeout = time_in_seconds + CHAIN_SYNC_TIMEOUT;",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "addr.GetHash()",
          "new_text": null,
          "old_line_content": "    uint64_t hashAddr = addr.GetHash();",
          "new_line_content": "    // at a time so the addrKnowns of the chosen nodes prevent repeats",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": "size",
          "new_api": null,
          "old_text": "best.size()",
          "new_text": null,
          "old_line_content": "    assert(nRelayNodes <= best.size());",
          "new_line_content": "    std::array<std::pair<uint64_t, CNode*>,2> best{{{0, nullptr}, {0, nullptr}}};",
          "content_same": false
        },
        {
          "line": 3133,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "state.pindexBestKnownBlock->GetBlockHash().ToString()",
          "new_text": null,
          "old_line_content": "                LogPrintf(\"Disconnecting outbound peer %d for old chain, best known block = %s\\n\", pto->GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\");",
          "new_line_content": "                // They've run out of time to catch up!",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pnode->GetId()",
          "new_text": null,
          "old_line_content": "            uint64_t hashKey = CSipHasher(hasher).Write(pnode->GetId()).Finalize();",
          "new_line_content": "        if (pnode->nVersion >= CADDR_TIME_VERSION) {",
          "content_same": false
        },
        {
          "line": 3136,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(state.m_chain_sync.m_work_header)",
          "new_text": null,
          "old_line_content": "                assert(state.m_chain_sync.m_work_header);",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 1091,
          "old_api": "begin",
          "new_api": null,
          "old_text": "best.begin()",
          "new_text": null,
          "old_line_content": "                     std::copy(best.begin() + i, best.begin() + nRelayNodes - 1, best.begin() + i + 1);",
          "new_line_content": "                 if (hashKey > best[i].first) {",
          "content_same": false
        },
        {
          "line": 3140,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "                constexpr int64_t HEADERS_RESPONSE_TIME = 120; // 2 minutes",
          "new_line_content": "                state.m_chain_sync.m_sent_getheaders = true;",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": "PushAddress",
          "new_api": null,
          "old_text": "best[i].second->PushAddress(addr, insecure_rand)",
          "new_text": null,
          "old_line_content": "            best[i].second->PushAddress(addr, insecure_rand);",
          "new_line_content": "        for (unsigned int i = 0; i < nRelayNodes && best[i].first != 0; i++) {",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": "std::move(pushfunc)",
          "new_api": null,
          "old_text": "std::move(pushfunc)",
          "new_text": null,
          "old_line_content": "    connman->ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3155,
          "old_api": "GetExtraOutboundCount",
          "new_api": null,
          "old_text": "connman->GetExtraOutboundCount()",
          "new_text": null,
          "old_line_content": "    int extra_peers = connman->GetExtraOutboundCount();",
          "new_line_content": "    // Check whether we have too many outbound peers",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "    const Consensus::Params& consensusParams = chainparams.GetConsensus();",
          "new_line_content": "    bool fWitnessesPresentInARecentCompactBlock;",
          "content_same": false
        },
        {
          "line": 3162,
          "old_api": "std::numeric_limits<int64_t>::max()",
          "new_api": null,
          "old_text": "std::numeric_limits<int64_t>::max()",
          "new_text": null,
          "old_line_content": "        int64_t oldest_block_announcement = std::numeric_limits<int64_t>::max();",
          "new_line_content": "        NodeId worst_peer = -1;",
          "content_same": false
        },
        {
          "line": 1116,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_most_recent_block)",
          "new_text": null,
          "old_line_content": "        LOCK(cs_most_recent_block);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3164,
          "old_api": "ForEachNode",
          "new_api": null,
          "old_text": "connman->ForEachNode([&](CNode* pnode) {\n            AssertLockHeld(cs_main);\n\n            // Ignore non-outbound peers, or nodes marked for disconnect already\n            if (!IsOutboundDisconnectionCandidate(pnode) || pnode->fDisconnect) return;\n            CNodeState *state = State(pnode->GetId());\n            if (state == nullptr) return; // shouldn't be possible, but just in case\n            // Don't evict our protected peers\n            if (state->m_chain_sync.m_protect) return;\n            if (state->m_last_block_announcement < oldest_block_announcement || (state->m_last_block_announcement == oldest_block_announcement && pnode->GetId() > worst_peer)) {\n                worst_peer = pnode->GetId();\n                oldest_block_announcement = state->m_last_block_announcement;\n            }\n        })",
          "new_text": null,
          "old_line_content": "        connman->ForEachNode([&](CNode* pnode) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3168,
          "old_api": "IsOutboundDisconnectionCandidate",
          "new_api": null,
          "old_text": "IsOutboundDisconnectionCandidate(pnode)",
          "new_text": null,
          "old_line_content": "            if (!IsOutboundDisconnectionCandidate(pnode) || pnode->fDisconnect) return;",
          "new_line_content": "            // Ignore non-outbound peers, or nodes marked for disconnect already",
          "content_same": false
        },
        {
          "line": 1124,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "        LOCK(cs_main);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3173,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pnode->GetId()",
          "new_text": null,
          "old_line_content": "            if (state->m_last_block_announcement < oldest_block_announcement || (state->m_last_block_announcement == oldest_block_announcement && pnode->GetId() > worst_peer)) {",
          "new_line_content": "            if (state->m_chain_sync.m_protect) return;",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "pindex->IsValid(BLOCK_VALID_SCRIPTS)",
          "new_text": null,
          "old_line_content": "            if (pindex->HaveTxsDownloaded() && !pindex->IsValid(BLOCK_VALID_SCRIPTS) &&",
          "new_line_content": "        if (pindex) {",
          "content_same": false
        },
        {
          "line": 3179,
          "old_api": "ForNode",
          "new_api": null,
          "old_text": "connman->ForNode(worst_peer, [&](CNode *pnode) {\n                AssertLockHeld(cs_main);\n\n                // Only disconnect a peer that has been connected to us for\n                // some reasonable fraction of our check-frequency, to give\n                // it time for new information to have arrived.\n                // Also don't disconnect any peer we're trying to download a\n                // block from.\n                CNodeState &state = *State(pnode->GetId());\n                if (time_in_seconds - pnode->nTimeConnected > MINIMUM_CONNECT_TIME && state.nBlocksInFlight == 0) {\n                    LogPrint(BCLog::NET, \"disconnecting extra outbound peer=%d (last block announcement received at time %d)\\n\", pnode->GetId(), oldest_block_announcement);\n                    pnode->fDisconnect = true;\n                    return true;\n                } else {\n                    LogPrint(BCLog::NET, \"keeping outbound peer=%d chosen for eviction (connect time: %d, blocks_in_flight: %d)\\n\", pnode->GetId(), pnode->nTimeConnected, state.nBlocksInFlight);\n                    return false;\n                }\n            })",
          "new_text": null,
          "old_line_content": "            bool disconnected = connman->ForNode(worst_peer, [&](CNode *pnode) {",
          "new_line_content": "        if (worst_peer != -1) {",
          "content_same": false
        },
        {
          "line": 3187,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pnode->GetId()",
          "new_text": null,
          "old_line_content": "                CNodeState &state = *State(pnode->GetId());",
          "new_line_content": "                // block from.",
          "content_same": false
        },
        {
          "line": 1140,
          "old_api": "Params",
          "new_api": null,
          "old_text": "Params()",
          "new_text": null,
          "old_line_content": "        if (!ActivateBestChain(state, Params(), a_recent_block)) {",
          "new_line_content": "        CValidationState state;",
          "content_same": false
        },
        {
          "line": 3189,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pnode->GetId()",
          "new_text": null,
          "old_line_content": "                    LogPrint(BCLog::NET, \"disconnecting extra outbound peer=%d (last block announcement received at time %d)\\n\", pnode->GetId(), oldest_block_announcement);",
          "new_line_content": "                if (time_in_seconds - pnode->nTimeConnected > MINIMUM_CONNECT_TIME && state.nBlocksInFlight == 0) {",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3193,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pnode->GetId()",
          "new_text": null,
          "old_line_content": "                    LogPrint(BCLog::NET, \"keeping outbound peer=%d chosen for eviction (connect time: %d, blocks_in_flight: %d)\\n\", pnode->GetId(), pnode->nTimeConnected, state.nBlocksInFlight);",
          "new_line_content": "                } else {",
          "content_same": false
        },
        {
          "line": 1148,
          "old_api": "BlockRequestAllowed",
          "new_api": null,
          "old_text": "BlockRequestAllowed(pindex, consensusParams)",
          "new_text": null,
          "old_line_content": "        send = BlockRequestAllowed(pindex, consensusParams);",
          "new_line_content": "    if (pindex) {",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom->GetId());",
          "new_line_content": "        if (!send) {",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": "GetSendVersion",
          "new_api": null,
          "old_text": "pfrom->GetSendVersion()",
          "new_text": null,
          "old_line_content": "    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3203,
          "old_api": "SetTryNewOutboundPeer",
          "new_api": null,
          "old_text": "connman->SetTryNewOutboundPeer(false)",
          "new_text": null,
          "old_line_content": "                connman->SetTryNewOutboundPeer(false);",
          "new_line_content": "                // network from these extra connections.",
          "content_same": false
        },
        {
          "line": 1156,
          "old_api": "GetBlockTime",
          "new_api": null,
          "old_text": "pindex->GetBlockTime()",
          "new_text": null,
          "old_line_content": "    if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)",
          "new_line_content": "    // never disconnect whitelisted nodes",
          "content_same": false
        },
        {
          "line": 1158,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3211,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1166,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "            (((pfrom->GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom->GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (chainActive.Tip()->nHeight - pindex->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )",
          "new_line_content": "    if (send && !pfrom->fWhitelisted && (",
          "content_same": false
        },
        {
          "line": 3215,
          "old_api": "GetTime",
          "new_api": null,
          "old_text": "GetTime()",
          "new_text": null,
          "old_line_content": "    int64_t time_in_seconds = GetTime();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"Ignore block request below NODE_NETWORK_LIMITED threshold from peer=%d\\n\", pfrom->GetId());",
          "new_line_content": "       )) {",
          "content_same": false
        },
        {
          "line": 3217,
          "old_api": "EvictExtraOutboundPeers",
          "new_api": null,
          "old_text": "EvictExtraOutboundPeers(time_in_seconds)",
          "new_text": null,
          "old_line_content": "    EvictExtraOutboundPeers(time_in_seconds);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3222,
          "old_api": "TipMayBeStale",
          "new_api": null,
          "old_text": "TipMayBeStale(consensusParams)",
          "new_text": null,
          "old_line_content": "        if (!fImporting && !fReindex && connman->GetNetworkActive() && connman->GetUseAddrmanOutgoing() && TipMayBeStale(consensusParams)) {",
          "new_line_content": "        // outbound peer",
          "content_same": false
        },
        {
          "line": 1179,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindex->GetBlockHash()",
          "new_text": null,
          "old_line_content": "        if (a_recent_block && a_recent_block->GetHash() == pindex->GetBlockHash()) {",
          "new_line_content": "        std::shared_ptr<const CBlock> pblock;",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": "MessageStart",
          "new_api": null,
          "old_text": "chainparams.MessageStart()",
          "new_text": null,
          "old_line_content": "            if (!ReadRawBlockFromDisk(block_data, pindex, chainparams.MessageStart())) {",
          "new_line_content": "            std::vector<uint8_t> block_data;",
          "content_same": false
        },
        {
          "line": 1188,
          "old_api": "MakeSpan",
          "new_api": null,
          "old_text": "MakeSpan(block_data)",
          "new_text": null,
          "old_line_content": "            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, MakeSpan(block_data)));",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3237,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "    explicit CompareInvMempoolOrder(CTxMemPool *_mempool)",
          "new_line_content": "public:",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": "std::make_shared<CBlock>()",
          "new_api": null,
          "old_text": "std::make_shared<CBlock>()",
          "new_text": null,
          "old_line_content": "            std::shared_ptr<CBlock> pblockRead = std::make_shared<CBlock>();",
          "new_line_content": "            // Send block from disk",
          "content_same": false
        },
        {
          "line": 3246,
          "old_api": "CompareDepthAndScore",
          "new_api": null,
          "old_text": "mp->CompareDepthAndScore(*b, *a)",
          "new_text": null,
          "old_line_content": "        return mp->CompareDepthAndScore(*b, *a);",
          "new_line_content": "         * fewest ancestors/highest fee to sort later. */",
          "content_same": false
        },
        {
          "line": 1199,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock)",
          "new_text": null,
          "old_line_content": "                connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));",
          "new_line_content": "            if (inv.type == MSG_BLOCK)",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(NetMsgType::BLOCK, *pblock)",
          "new_text": null,
          "old_line_content": "                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));",
          "new_line_content": "            else if (inv.type == MSG_WITNESS_BLOCK)",
          "content_same": false
        },
        {
          "line": 3253,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "Params().GetConsensus()",
          "new_text": null,
          "old_line_content": "    const Consensus::Params& consensusParams = Params().GetConsensus();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1207,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pfrom->cs_filter)",
          "new_text": null,
          "old_line_content": "                    LOCK(pfrom->cs_filter);",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 1210,
          "old_api": "CMerkleBlock",
          "new_api": null,
          "old_text": "CMerkleBlock(*pblock, *pfrom->pfilter)",
          "new_text": null,
          "old_line_content": "                        merkleBlock = CMerkleBlock(*pblock, *pfrom->pfilter);",
          "new_line_content": "                        sendMerkleBlock = true;",
          "content_same": false
        },
        {
          "line": 3260,
          "old_api": "GetSendVersion",
          "new_api": null,
          "old_text": "pto->GetSendVersion()",
          "new_text": null,
          "old_line_content": "        const CNetMsgMaker msgMaker(pto->GetSendVersion());",
          "new_line_content": "        // If we get here, the outgoing message serialization version is set and can't change.",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock)",
          "new_text": null,
          "old_line_content": "                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));",
          "new_line_content": "                if (sendMerkleBlock) {",
          "content_same": false
        },
        {
          "line": 3270,
          "old_api": "GetTimeMicros",
          "new_api": null,
          "old_text": "GetTimeMicros()",
          "new_text": null,
          "old_line_content": "        if (pto->nPingNonceSent == 0 && pto->nPingUsecStart + PING_INTERVAL * 1000000 < GetTimeMicros()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1223,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first])",
          "new_text": null,
          "old_line_content": "                        connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));",
          "new_line_content": "                    for (PairType& pair : merkleBlock.vMatchedTxn)",
          "content_same": false
        },
        {
          "line": 3277,
          "old_api": "GetRandBytes",
          "new_api": null,
          "old_text": "GetRandBytes((unsigned char*)&nonce, sizeof(nonce))",
          "new_text": null,
          "old_line_content": "                GetRandBytes((unsigned char*)&nonce, sizeof(nonce));",
          "new_line_content": "            while (nonce == 0) {",
          "content_same": false
        },
        {
          "line": 3280,
          "old_api": "GetTimeMicros",
          "new_api": null,
          "old_text": "GetTimeMicros()",
          "new_text": null,
          "old_line_content": "            pto->nPingUsecStart = GetTimeMicros();",
          "new_line_content": "            pto->fPingQueued = false;",
          "content_same": false
        },
        {
          "line": 1234,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "                bool fPeerWantsWitness = State(pfrom->GetId())->fWantsCmpctWitness;",
          "new_line_content": "                // instead we respond with the full, non-compact block.",
          "content_same": false
        },
        {
          "line": 3283,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(NetMsgType::PING, nonce)",
          "new_text": null,
          "old_line_content": "                connman->PushMessage(pto, msgMaker.Make(NetMsgType::PING, nonce));",
          "new_line_content": "                pto->nPingNonceSent = nonce;",
          "content_same": false
        },
        {
          "line": 1236,
          "old_api": "Height",
          "new_api": null,
          "old_text": "chainActive.Height()",
          "new_text": null,
          "old_line_content": "                if (CanDirectFetch(consensusParams) && pindex->nHeight >= chainActive.Height() - MAX_CMPCTBLOCK_DEPTH) {",
          "new_line_content": "                int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;",
          "content_same": false
        },
        {
          "line": 3287,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(NetMsgType::PING)",
          "new_text": null,
          "old_line_content": "                connman->PushMessage(pto, msgMaker.Make(NetMsgType::PING));",
          "new_line_content": "                pto->nPingNonceSent = 0;",
          "content_same": false
        },
        {
          "line": 1241,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock)",
          "new_text": null,
          "old_line_content": "                        connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));",
          "new_line_content": "                        CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);",
          "content_same": false
        },
        {
          "line": 3291,
          "old_api": "TRY_LOCK",
          "new_api": null,
          "old_text": "TRY_LOCK(cs_main, lockMain)",
          "new_text": null,
          "old_line_content": "        TRY_LOCK(cs_main, lockMain); // Acquire cs_main for IsInitialBlockDownload() and CNodeState()",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock)",
          "new_text": null,
          "old_line_content": "                    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));",
          "new_line_content": "                } else {",
          "content_same": false
        },
        {
          "line": 3295,
          "old_api": "SendRejectsAndCheckIfBanned",
          "new_api": null,
          "old_text": "SendRejectsAndCheckIfBanned(pto, connman, m_enable_bip61)",
          "new_text": null,
          "old_line_content": "        if (SendRejectsAndCheckIfBanned(pto, connman, m_enable_bip61))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3297,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pto->GetId()",
          "new_text": null,
          "old_line_content": "        CNodeState &state = *State(pto->GetId());",
          "new_line_content": "            return true;",
          "content_same": false
        },
        {
          "line": 3300,
          "old_api": "GetTimeMicros",
          "new_api": null,
          "old_text": "GetTimeMicros()",
          "new_text": null,
          "old_line_content": "        int64_t nNow = GetTimeMicros();",
          "new_line_content": "        // Address refresh broadcast",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()->GetBlockHash()",
          "new_text": null,
          "old_line_content": "            vInv.push_back(CInv(MSG_BLOCK, chainActive.Tip()->GetBlockHash()));",
          "new_line_content": "            std::vector<CInv> vInv;",
          "content_same": false
        },
        {
          "line": 3310,
          "old_api": "PoissonNextSend",
          "new_api": null,
          "old_text": "PoissonNextSend(nNow, AVG_ADDRESS_BROADCAST_INTERVAL)",
          "new_text": null,
          "old_line_content": "            pto->nNextAddrSend = PoissonNextSend(nNow, AVG_ADDRESS_BROADCAST_INTERVAL);",
          "new_line_content": "        if (pto->nNextAddrSend < nNow) {",
          "content_same": false
        },
        {
          "line": 3312,
          "old_api": "size",
          "new_api": null,
          "old_text": "pto->vAddrToSend.size()",
          "new_text": null,
          "old_line_content": "            vAddr.reserve(pto->vAddrToSend.size());",
          "new_line_content": "            std::vector<CAddress> vAddr;",
          "content_same": false
        },
        {
          "line": 1265,
          "old_api": "AssertLockNotHeld",
          "new_api": null,
          "old_text": "AssertLockNotHeld(cs_main)",
          "new_text": null,
          "old_line_content": "    AssertLockNotHeld(cs_main);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1267,
          "old_api": "begin",
          "new_api": null,
          "old_text": "pfrom->vRecvGetData.begin()",
          "new_text": null,
          "old_line_content": "    std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3315,
          "old_api": "GetKey",
          "new_api": null,
          "old_text": "addr.GetKey()",
          "new_text": null,
          "old_line_content": "                if (!pto->addrKnown.contains(addr.GetKey()))",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1269,
          "old_api": "GetSendVersion",
          "new_api": null,
          "old_text": "pfrom->GetSendVersion()",
          "new_text": null,
          "old_line_content": "    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());",
          "new_line_content": "    std::vector<CInv> vNotFound;",
          "content_same": false
        },
        {
          "line": 3317,
          "old_api": "GetKey",
          "new_api": null,
          "old_text": "addr.GetKey()",
          "new_text": null,
          "old_line_content": "                    pto->addrKnown.insert(addr.GetKey());",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 1271,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "        LOCK(cs_main);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3320,
          "old_api": "size",
          "new_api": null,
          "old_text": "vAddr.size()",
          "new_text": null,
          "old_line_content": "                    if (vAddr.size() >= 1000)",
          "new_line_content": "                    // receiver rejects addr messages larger than 1000",
          "content_same": false
        },
        {
          "line": 1273,
          "old_api": "end",
          "new_api": null,
          "old_text": "pfrom->vRecvGetData.end()",
          "new_text": null,
          "old_line_content": "        while (it != pfrom->vRecvGetData.end() && (it->type == MSG_TX || it->type == MSG_WITNESS_TX)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3322,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(NetMsgType::ADDR, vAddr)",
          "new_text": null,
          "old_line_content": "                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));",
          "new_line_content": "                    {",
          "content_same": false
        },
        {
          "line": 3327,
          "old_api": "clear",
          "new_api": null,
          "old_text": "pto->vAddrToSend.clear()",
          "new_text": null,
          "old_line_content": "            pto->vAddrToSend.clear();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3331,
          "old_api": "capacity",
          "new_api": null,
          "old_text": "pto->vAddrToSend.capacity()",
          "new_text": null,
          "old_line_content": "            if (pto->vAddrToSend.capacity() > 40)",
          "new_line_content": "            // we only send the big addr message once",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapRelay.find(inv.hash)",
          "new_text": null,
          "old_line_content": "            auto mi = mapRelay.find(inv.hash);",
          "new_line_content": "            bool push = false;",
          "content_same": false
        },
        {
          "line": 1287,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapRelay.end()",
          "new_text": null,
          "old_line_content": "            if (mi != mapRelay.end()) {",
          "new_line_content": "            int nSendFlags = (inv.type == MSG_TX ? SERIALIZE_TRANSACTION_NO_WITNESS : 0);",
          "content_same": false
        },
        {
          "line": 3337,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "            pindexBestHeader = chainActive.Tip();",
          "new_line_content": "        if (pindexBestHeader == nullptr)",
          "content_same": false
        },
        {
          "line": 1291,
          "old_api": "info",
          "new_api": null,
          "old_text": "mempool.info(inv.hash)",
          "new_text": null,
          "old_line_content": "                auto txinfo = mempool.info(inv.hash);",
          "new_line_content": "            } else if (pfrom->timeLastMempoolReq) {",
          "content_same": false
        },
        {
          "line": 3341,
          "old_api": "GetAdjustedTime",
          "new_api": null,
          "old_text": "GetAdjustedTime()",
          "new_text": null,
          "old_line_content": "            if ((nSyncStarted == 0 && fFetch) || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {",
          "new_line_content": "            // Only actively request headers from a single peer, unless we're close to today.",
          "content_same": false
        },
        {
          "line": 1295,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(nSendFlags, NetMsgType::TX, *txinfo.tx)",
          "new_text": null,
          "old_line_content": "                    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *txinfo.tx));",
          "new_line_content": "                if (txinfo.tx && txinfo.nTime <= pfrom->timeLastMempoolReq) {",
          "content_same": false
        },
        {
          "line": 3343,
          "old_api": "GetBlockTime",
          "new_api": null,
          "old_text": "pindexBestHeader->GetBlockTime()",
          "new_text": null,
          "old_line_content": "                state.nHeadersSyncTimeout = GetTimeMicros() + HEADERS_DOWNLOAD_TIMEOUT_BASE + HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER * (GetAdjustedTime() - pindexBestHeader->GetBlockTime())/(consensusParams.nPowTargetSpacing);",
          "new_line_content": "                state.fSyncStarted = true;",
          "content_same": false
        },
        {
          "line": 1300,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "vNotFound.push_back(inv)",
          "new_text": null,
          "old_line_content": "                vNotFound.push_back(inv);",
          "new_line_content": "            if (!push) {",
          "content_same": false
        },
        {
          "line": 1305,
          "old_api": "end",
          "new_api": null,
          "old_text": "pfrom->vRecvGetData.end()",
          "new_text": null,
          "old_line_content": "    if (it != pfrom->vRecvGetData.end() && !pfrom->fPauseSend) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3355,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pto->GetId()",
          "new_text": null,
          "old_line_content": "                LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->GetId(), pto->nStartingHeight);",
          "new_line_content": "                    pindexStart = pindexStart->pprev;",
          "content_same": false
        },
        {
          "line": 1309,
          "old_api": "ProcessGetBlockData",
          "new_api": null,
          "old_text": "ProcessGetBlockData(pfrom, chainparams, inv, connman)",
          "new_text": null,
          "old_line_content": "            ProcessGetBlockData(pfrom, chainparams, inv, connman);",
          "new_line_content": "            it++;",
          "content_same": false
        },
        {
          "line": 1313,
          "old_api": "begin",
          "new_api": null,
          "old_text": "pfrom->vRecvGetData.begin()",
          "new_text": null,
          "old_line_content": "    pfrom->vRecvGetData.erase(pfrom->vRecvGetData.begin(), it);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1315,
          "old_api": "empty",
          "new_api": null,
          "old_text": "vNotFound.empty()",
          "new_text": null,
          "old_line_content": "    if (!vNotFound.empty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3363,
          "old_api": "IsInitialBlockDownload",
          "new_api": null,
          "old_text": "IsInitialBlockDownload()",
          "new_text": null,
          "old_line_content": "        if (!fReindex && !fImporting && !IsInitialBlockDownload())",
          "new_line_content": "        // transactions become unconfirmed and spams other nodes.",
          "content_same": false
        },
        {
          "line": 3365,
          "old_api": "Broadcast",
          "new_api": null,
          "old_text": "GetMainSignals().Broadcast(nTimeBestReceived, connman)",
          "new_text": null,
          "old_line_content": "            GetMainSignals().Broadcast(nTimeBestReceived, connman);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1323,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(NetMsgType::NOTFOUND, vNotFound)",
          "new_text": null,
          "old_line_content": "        connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::NOTFOUND, vNotFound));",
          "new_line_content": "        // having to download the entire memory pool.",
          "content_same": false
        },
        {
          "line": 1329,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "    if ((pfrom->GetLocalServices() & NODE_WITNESS) && State(pfrom->GetId())->fHaveWitness) {",
          "new_line_content": "    uint32_t nFetchFlags = 0;",
          "content_same": false
        },
        {
          "line": 3379,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pto->cs_inventory)",
          "new_text": null,
          "old_line_content": "            LOCK(pto->cs_inventory);",
          "new_line_content": "            // add all to the inv queue.",
          "content_same": false
        },
        {
          "line": 3382,
          "old_api": "size",
          "new_api": null,
          "old_text": "pto->vBlockHashesToAnnounce.size()",
          "new_text": null,
          "old_line_content": "                                 (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||",
          "new_line_content": "            bool fRevertToInv = ((!state.fPreferHeaders &&",
          "content_same": false
        },
        {
          "line": 1337,
          "old_api": "size",
          "new_api": null,
          "old_text": "req.indexes.size()",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i < req.indexes.size(); i++) {",
          "new_line_content": "    BlockTransactions resp(req);",
          "content_same": false
        },
        {
          "line": 3385,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pto->GetId()",
          "new_text": null,
          "old_line_content": "            ProcessBlockAvailability(pto->GetId()); // ensure pindexBestKnownBlock is up-to-date",
          "new_line_content": "            const CBlockIndex *pBestIndex = nullptr; // last header queued for delivery",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3393,
          "old_api": "LookupBlockIndex",
          "new_api": null,
          "old_text": "LookupBlockIndex(hash)",
          "new_text": null,
          "old_line_content": "                    const CBlockIndex* pindex = LookupBlockIndex(hash);",
          "new_line_content": "                for (const uint256 &hash : pto->vBlockHashesToAnnounce) {",
          "content_same": false
        },
        {
          "line": 1353,
          "old_api": "GetSendVersion",
          "new_api": null,
          "old_text": "pfrom->GetSendVersion()",
          "new_text": null,
          "old_line_content": "    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1364,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "        LOCK(cs_main);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3418,
          "old_api": "GetBlockHeader",
          "new_api": null,
          "old_text": "pindex->GetBlockHeader()",
          "new_text": null,
          "old_line_content": "                        vHeaders.push_back(pindex->GetBlockHeader());",
          "new_line_content": "                        // add this to the headers message",
          "content_same": false
        },
        {
          "line": 3421,
          "old_api": "PeerHasHeader",
          "new_api": null,
          "old_text": "PeerHasHeader(&state, pindex->pprev)",
          "new_text": null,
          "old_line_content": "                    } else if (pindex->pprev == nullptr || PeerHasHeader(&state, pindex->pprev)) {",
          "new_line_content": "                        continue; // keep looking for the first new block",
          "content_same": false
        },
        {
          "line": 1375,
          "old_api": "LookupBlockIndex",
          "new_api": null,
          "old_text": "LookupBlockIndex(headers[0].hashPrevBlock)",
          "new_text": null,
          "old_line_content": "        if (!LookupBlockIndex(headers[0].hashPrevBlock) && nCount < MAX_BLOCKS_TO_ANNOUNCE) {",
          "new_line_content": "        //   nUnconnectingHeaders gets reset back to 0.",
          "content_same": false
        },
        {
          "line": 1377,
          "old_api": "uint256",
          "new_api": null,
          "old_text": "uint256()",
          "new_text": null,
          "old_line_content": "            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));",
          "new_line_content": "            nodestate->nUnconnectingHeaders++;",
          "content_same": false
        },
        {
          "line": 3425,
          "old_api": "GetBlockHeader",
          "new_api": null,
          "old_text": "pindex->GetBlockHeader()",
          "new_text": null,
          "old_line_content": "                        vHeaders.push_back(pindex->GetBlockHeader());",
          "new_line_content": "                        fFoundStartingHeader = true;",
          "content_same": false
        },
        {
          "line": 1382,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "                    pfrom->GetId(), nodestate->nUnconnectingHeaders);",
          "new_line_content": "                    pindexBestHeader->nHeight,",
          "content_same": false
        },
        {
          "line": 1386,
          "old_api": "back",
          "new_api": null,
          "old_text": "headers.back().GetHash()",
          "new_text": null,
          "old_line_content": "            UpdateBlockAvailability(pfrom->GetId(), headers.back().GetHash());",
          "new_line_content": "            // we can use this peer to download.",
          "content_same": false
        },
        {
          "line": 3434,
          "old_api": "empty",
          "new_api": null,
          "old_text": "vHeaders.empty()",
          "new_text": null,
          "old_line_content": "            if (!fRevertToInv && !vHeaders.empty()) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1389,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "                Misbehaving(pfrom->GetId(), 20);",
          "new_line_content": "            if (nodestate->nUnconnectingHeaders % MAX_UNCONNECTING_HEADERS == 0) {",
          "content_same": false
        },
        {
          "line": 3438,
          "old_api": "front",
          "new_api": null,
          "old_text": "LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", __func__,\n                            vHeaders.front().GetHash().ToString(), pto->GetId())",
          "new_text": null,
          "old_line_content": "                    LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", __func__,",
          "new_line_content": "                    // probably means we're doing an initial-ish-sync or they're slow",
          "content_same": false
        },
        {
          "line": 1396,
          "old_api": "IsNull",
          "new_api": null,
          "old_text": "hashLastBlock.IsNull()",
          "new_text": null,
          "old_line_content": "            if (!hashLastBlock.IsNull() && header.hashPrevBlock != hashLastBlock) {",
          "new_line_content": "        for (const CBlockHeader& header : headers) {",
          "content_same": false
        },
        {
          "line": 3445,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_most_recent_block)",
          "new_text": null,
          "old_line_content": "                        LOCK(cs_most_recent_block);",
          "new_line_content": "                    {",
          "content_same": false
        },
        {
          "line": 1400,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "header.GetHash()",
          "new_text": null,
          "old_line_content": "            hashLastBlock = header.GetHash();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3448,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block)",
          "new_text": null,
          "old_line_content": "                                connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block));",
          "new_line_content": "                            if (state.fWantsCmpctWitness || !fWitnessesPresentInMostRecentCompactBlock)",
          "content_same": false
        },
        {
          "line": 3451,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock)",
          "new_text": null,
          "old_line_content": "                                connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));",
          "new_line_content": "                                CBlockHeaderAndShortTxIDs cmpctblock(*most_recent_block, state.fWantsCmpctWitness);",
          "content_same": false
        },
        {
          "line": 1405,
          "old_api": "LookupBlockIndex",
          "new_api": null,
          "old_text": "LookupBlockIndex(hashLastBlock)",
          "new_text": null,
          "old_line_content": "        if (!LookupBlockIndex(hashLastBlock)) {",
          "new_line_content": "        // something new (if these headers are valid).",
          "content_same": false
        },
        {
          "line": 3458,
          "old_api": "ReadBlockFromDisk",
          "new_api": null,
          "old_text": "ReadBlockFromDisk(block, pBestIndex, consensusParams)",
          "new_text": null,
          "old_line_content": "                        bool ret = ReadBlockFromDisk(block, pBestIndex, consensusParams);",
          "new_line_content": "                        CBlock block;",
          "content_same": false
        },
        {
          "line": 1412,
          "old_api": "ProcessNewBlockHeaders",
          "new_api": null,
          "old_text": "ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast, &first_invalid_header)",
          "new_text": null,
          "old_line_content": "    if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast, &first_invalid_header)) {",
          "new_line_content": "    CBlockHeader first_invalid_header;",
          "content_same": false
        },
        {
          "line": 3461,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock)",
          "new_text": null,
          "old_line_content": "                        connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));",
          "new_line_content": "                        CBlockHeaderAndShortTxIDs cmpctblock(block, state.fWantsCmpctWitness);",
          "content_same": false
        },
        {
          "line": 1414,
          "old_api": "IsInvalid",
          "new_api": null,
          "old_text": "state.IsInvalid(nDoS)",
          "new_text": null,
          "old_line_content": "        if (state.IsInvalid(nDoS)) {",
          "new_line_content": "        int nDoS;",
          "content_same": false
        },
        {
          "line": 1417,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "                Misbehaving(pfrom->GetId(), nDoS, \"invalid header received\");",
          "new_line_content": "            if (nDoS > 0) {",
          "content_same": false
        },
        {
          "line": 3465,
          "old_api": "size",
          "new_api": null,
          "old_text": "vHeaders.size()",
          "new_text": null,
          "old_line_content": "                    if (vHeaders.size() > 1) {",
          "new_line_content": "                } else if (state.fPreferHeaders) {",
          "content_same": false
        },
        {
          "line": 1419,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "                LogPrint(BCLog::NET, \"peer=%d: invalid header received\\n\", pfrom->GetId());",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 1421,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "first_invalid_header.GetHash()",
          "new_text": null,
          "old_line_content": "            if (punish_duplicate_invalid && LookupBlockIndex(first_invalid_header.GetHash())) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3471,
          "old_api": "front",
          "new_api": null,
          "old_text": "LogPrint(BCLog::NET, \"%s: sending header %s to peer=%d\\n\", __func__,\n                                vHeaders.front().GetHash().ToString(), pto->GetId())",
          "new_text": null,
          "old_line_content": "                        LogPrint(BCLog::NET, \"%s: sending header %s to peer=%d\\n\", __func__,",
          "new_line_content": "                    } else {",
          "content_same": false
        },
        {
          "line": 3474,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(NetMsgType::HEADERS, vHeaders)",
          "new_text": null,
          "old_line_content": "                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 3483,
          "old_api": "empty",
          "new_api": null,
          "old_text": "pto->vBlockHashesToAnnounce.empty()",
          "new_text": null,
          "old_line_content": "                if (!pto->vBlockHashesToAnnounce.empty()) {",
          "new_line_content": "                // in the past.",
          "content_same": false
        },
        {
          "line": 3492,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "LogPrint(BCLog::NET, \"Announcing block %s not on main chain (tip=%s)\\n\",\n                            hashToAnnounce.ToString(), chainActive.Tip()->GetBlockHash().ToString())",
          "new_text": null,
          "old_line_content": "                        LogPrint(BCLog::NET, \"Announcing block %s not on main chain (tip=%s)\\n\",",
          "new_line_content": "                    if (chainActive[pindex->nHeight] != pindex) {",
          "content_same": false
        },
        {
          "line": 3497,
          "old_api": "PeerHasHeader",
          "new_api": null,
          "old_text": "PeerHasHeader(&state, pindex)",
          "new_text": null,
          "old_line_content": "                    if (!PeerHasHeader(&state, pindex)) {",
          "new_line_content": "                    // If the peer's chain has this block, don't inv it back.",
          "content_same": false
        },
        {
          "line": 3504,
          "old_api": "clear",
          "new_api": null,
          "old_text": "pto->vBlockHashesToAnnounce.clear()",
          "new_text": null,
          "old_line_content": "            pto->vBlockHashesToAnnounce.clear();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1460,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "        LOCK(cs_main);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1463,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->GetId(), nodestate->nUnconnectingHeaders);",
          "new_line_content": "        if (nodestate->nUnconnectingHeaders > 0) {",
          "content_same": false
        },
        {
          "line": 3512,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pto->cs_inventory)",
          "new_text": null,
          "old_line_content": "            LOCK(pto->cs_inventory);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1467,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(pindexLast)",
          "new_text": null,
          "old_line_content": "        assert(pindexLast);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3517,
          "old_api": "CInv",
          "new_api": null,
          "old_text": "CInv(MSG_BLOCK, hash)",
          "new_text": null,
          "old_line_content": "                vInv.push_back(CInv(MSG_BLOCK, hash));",
          "new_line_content": "            for (const uint256& hash : pto->vInventoryBlockToSend) {",
          "content_same": false
        },
        {
          "line": 1474,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "        if (received_new_header && pindexLast->nChainWork > chainActive.Tip()->nChainWork) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3523,
          "old_api": "clear",
          "new_api": null,
          "old_text": "pto->vInventoryBlockToSend.clear()",
          "new_text": null,
          "old_line_content": "            pto->vInventoryBlockToSend.clear();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->GetId(), pfrom->nStartingHeight);",
          "new_line_content": "            // from there instead.",
          "content_same": false
        },
        {
          "line": 3530,
          "old_api": "PoissonNextSendInbound",
          "new_api": null,
          "old_text": "connman->PoissonNextSendInbound(nNow, INVENTORY_BROADCAST_INTERVAL)",
          "new_text": null,
          "old_line_content": "                    pto->nNextInvSend = connman->PoissonNextSendInbound(nNow, INVENTORY_BROADCAST_INTERVAL);",
          "new_line_content": "                if (pto->fInbound) {",
          "content_same": false
        },
        {
          "line": 3533,
          "old_api": "PoissonNextSend",
          "new_api": null,
          "old_text": "PoissonNextSend(nNow, INVENTORY_BROADCAST_INTERVAL >> 1)",
          "new_text": null,
          "old_line_content": "                    pto->nNextInvSend = PoissonNextSend(nNow, INVENTORY_BROADCAST_INTERVAL >> 1);",
          "new_line_content": "                    // Use half the delay for outbound peers, as there is less privacy concern for them.",
          "content_same": false
        },
        {
          "line": 1486,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "        bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1489,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "        if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && chainActive.Tip()->nChainWork <= pindexLast->nChainWork) {",
          "new_line_content": "        // much work as our tip, download as much as possible.",
          "content_same": false
        },
        {
          "line": 3539,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pto->cs_filter)",
          "new_text": null,
          "old_line_content": "                LOCK(pto->cs_filter);",
          "new_line_content": "            if (fSendTrickle) {",
          "content_same": false
        },
        {
          "line": 1493,
          "old_api": "size",
          "new_api": null,
          "old_text": "vToFetch.size()",
          "new_text": null,
          "old_line_content": "            while (pindexWalk && !chainActive.Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {",
          "new_line_content": "            // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.",
          "content_same": false
        },
        {
          "line": 1495,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindexWalk->GetBlockHash()",
          "new_text": null,
          "old_line_content": "                        !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&",
          "new_line_content": "                if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&",
          "content_same": false
        },
        {
          "line": 3545,
          "old_api": "infoAll",
          "new_api": null,
          "old_text": "mempool.infoAll()",
          "new_text": null,
          "old_line_content": "                auto vtxinfo = mempool.infoAll();",
          "new_line_content": "            if (fSendTrickle && pto->fSendMempool) {",
          "content_same": false
        },
        {
          "line": 1498,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "vToFetch.push_back(pindexWalk)",
          "new_text": null,
          "old_line_content": "                    vToFetch.push_back(pindexWalk);",
          "new_line_content": "                    // We don't have this block, and it's not yet in flight.",
          "content_same": false
        },
        {
          "line": 3549,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pto->cs_feeFilter)",
          "new_text": null,
          "old_line_content": "                    LOCK(pto->cs_feeFilter);",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 3553,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pto->cs_filter)",
          "new_text": null,
          "old_line_content": "                LOCK(pto->cs_filter);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1506,
          "old_api": "Contains",
          "new_api": null,
          "old_text": "chainActive.Contains(pindexWalk)",
          "new_text": null,
          "old_line_content": "            if (!chainActive.Contains(pindexWalk)) {",
          "new_line_content": "            // direct fetch and rely on parallel download instead.",
          "content_same": false
        },
        {
          "line": 3556,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "txinfo.tx->GetHash()",
          "new_text": null,
          "old_line_content": "                    const uint256& hash = txinfo.tx->GetHash();",
          "new_line_content": "                for (const auto& txinfo : vtxinfo) {",
          "content_same": false
        },
        {
          "line": 3558,
          "old_api": "erase",
          "new_api": null,
          "old_text": "pto->setInventoryTxToSend.erase(hash)",
          "new_text": null,
          "old_line_content": "                    pto->setInventoryTxToSend.erase(hash);",
          "new_line_content": "                    CInv inv(MSG_TX, hash);",
          "content_same": false
        },
        {
          "line": 3560,
          "old_api": "GetFeePerK",
          "new_api": null,
          "old_text": "txinfo.feeRate.GetFeePerK()",
          "new_text": null,
          "old_line_content": "                        if (txinfo.feeRate.GetFeePerK() < filterrate)",
          "new_line_content": "                    if (filterrate) {",
          "content_same": false
        },
        {
          "line": 1513,
          "old_api": "reverse_iterate",
          "new_api": null,
          "old_text": "reverse_iterate(vToFetch)",
          "new_text": null,
          "old_line_content": "                for (const CBlockIndex *pindex : reverse_iterate(vToFetch)) {",
          "new_line_content": "                // Download as much as possible, from earliest to latest.",
          "content_same": false
        },
        {
          "line": 3564,
          "old_api": "IsRelevantAndUpdate",
          "new_api": null,
          "old_text": "pto->pfilter->IsRelevantAndUpdate(*txinfo.tx)",
          "new_text": null,
          "old_line_content": "                        if (!pto->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;",
          "new_line_content": "                    if (pto->pfilter) {",
          "content_same": false
        },
        {
          "line": 1518,
          "old_api": "GetFetchFlags",
          "new_api": null,
          "old_text": "GetFetchFlags(pfrom)",
          "new_text": null,
          "old_line_content": "                    uint32_t nFetchFlags = GetFetchFlags(pfrom);",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 3566,
          "old_api": "insert",
          "new_api": null,
          "old_text": "pto->filterInventoryKnown.insert(hash)",
          "new_text": null,
          "old_line_content": "                    pto->filterInventoryKnown.insert(hash);",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 1524,
          "old_api": "size",
          "new_api": null,
          "old_text": "vGetData.size()",
          "new_text": null,
          "old_line_content": "                if (vGetData.size() > 1) {",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 3573,
          "old_api": "GetTime",
          "new_api": null,
          "old_text": "GetTime()",
          "new_text": null,
          "old_line_content": "                pto->timeLastMempoolReq = GetTime();",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1528,
          "old_api": "size",
          "new_api": null,
          "old_text": "vGetData.size()",
          "new_text": null,
          "old_line_content": "                if (vGetData.size() > 0) {",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1531,
          "old_api": "CInv",
          "new_api": null,
          "old_text": "CInv(MSG_CMPCT_BLOCK, vGetData[0].hash)",
          "new_text": null,
          "old_line_content": "                        vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);",
          "new_line_content": "                        // In any case, we want to download using a compact block, not a regular one",
          "content_same": false
        },
        {
          "line": 3580,
          "old_api": "size",
          "new_api": null,
          "old_text": "pto->setInventoryTxToSend.size()",
          "new_text": null,
          "old_line_content": "                vInvTx.reserve(pto->setInventoryTxToSend.size());",
          "new_line_content": "                std::vector<std::set<uint256>::iterator> vInvTx;",
          "content_same": false
        },
        {
          "line": 1533,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(NetMsgType::GETDATA, vGetData)",
          "new_text": null,
          "old_line_content": "                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vGetData));",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 3586,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pto->cs_feeFilter)",
          "new_text": null,
          "old_line_content": "                    LOCK(pto->cs_feeFilter);",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 1539,
          "old_api": "IsInitialBlockDownload",
          "new_api": null,
          "old_text": "IsInitialBlockDownload()",
          "new_text": null,
          "old_line_content": "        if (IsInitialBlockDownload() && nCount != MAX_HEADERS_RESULTS) {",
          "new_line_content": "        // chain. Disconnect peers that are on chains with insufficient work.",
          "content_same": false
        },
        {
          "line": 3592,
          "old_api": "end",
          "new_api": null,
          "old_text": "vInvTx.end()",
          "new_text": null,
          "old_line_content": "                std::make_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);",
          "new_line_content": "                CompareInvMempoolOrder compareInvMempoolOrder(&mempool);",
          "content_same": false
        },
        {
          "line": 3596,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pto->cs_filter)",
          "new_text": null,
          "old_line_content": "                LOCK(pto->cs_filter);",
          "new_line_content": "                unsigned int nRelayedTransactions = 0;",
          "content_same": false
        },
        {
          "line": 1551,
          "old_api": "IsOutboundDisconnectionCandidate",
          "new_api": null,
          "old_text": "IsOutboundDisconnectionCandidate(pfrom)",
          "new_text": null,
          "old_line_content": "                if (IsOutboundDisconnectionCandidate(pfrom)) {",
          "new_line_content": "                // as an anti-DoS measure.",
          "content_same": false
        },
        {
          "line": 3599,
          "old_api": "end",
          "new_api": null,
          "old_text": "vInvTx.end()",
          "new_text": null,
          "old_line_content": "                    std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);",
          "new_line_content": "                    // Fetch the top element from the heap",
          "content_same": false
        },
        {
          "line": 3604,
          "old_api": "erase",
          "new_api": null,
          "old_text": "pto->setInventoryTxToSend.erase(it)",
          "new_text": null,
          "old_line_content": "                    pto->setInventoryTxToSend.erase(it);",
          "new_line_content": "                    // Remove it from the to-be-sent set",
          "content_same": false
        },
        {
          "line": 1558,
          "old_api": "IsOutboundDisconnectionCandidate",
          "new_api": null,
          "old_text": "IsOutboundDisconnectionCandidate(pfrom)",
          "new_text": null,
          "old_line_content": "        if (!pfrom->fDisconnect && IsOutboundDisconnectionCandidate(pfrom) && nodestate->pindexBestKnownBlock != nullptr) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3606,
          "old_api": "contains",
          "new_api": null,
          "old_text": "pto->filterInventoryKnown.contains(hash)",
          "new_text": null,
          "old_line_content": "                    if (pto->filterInventoryKnown.contains(hash)) {",
          "new_line_content": "                    // Check if not in the filter already",
          "content_same": false
        },
        {
          "line": 1561,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "            if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= chainActive.Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {",
          "new_line_content": "            // it from the bad/lagging chain logic.",
          "content_same": false
        },
        {
          "line": 3610,
          "old_api": "info",
          "new_api": null,
          "old_text": "mempool.info(hash)",
          "new_text": null,
          "old_line_content": "                    auto txinfo = mempool.info(hash);",
          "new_line_content": "                    // Not in the mempool anymore? don't bother sending it.",
          "content_same": false
        },
        {
          "line": 3614,
          "old_api": "GetFeePerK",
          "new_api": null,
          "old_text": "txinfo.feeRate.GetFeePerK()",
          "new_text": null,
          "old_line_content": "                    if (filterrate && txinfo.feeRate.GetFeePerK() < filterrate) {",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 3617,
          "old_api": "IsRelevantAndUpdate",
          "new_api": null,
          "old_text": "pto->pfilter->IsRelevantAndUpdate(*txinfo.tx)",
          "new_text": null,
          "old_line_content": "                    if (pto->pfilter && !pto->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 3619,
          "old_api": "CInv",
          "new_api": null,
          "old_text": "CInv(MSG_TX, hash)",
          "new_text": null,
          "old_line_content": "                    vInv.push_back(CInv(MSG_TX, hash));",
          "new_line_content": "                    // Send",
          "content_same": false
        },
        {
          "line": 1574,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3623,
          "old_api": "front",
          "new_api": null,
          "old_text": "vRelayExpiration.front()",
          "new_text": null,
          "old_line_content": "                        while (!vRelayExpiration.empty() && vRelayExpiration.front().first < nNow)",
          "new_line_content": "                        // Expire old relay messages",
          "content_same": false
        },
        {
          "line": 1577,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"dropmessagestest DROPPING RECV MESSAGE\\n\")",
          "new_text": null,
          "old_line_content": "        LogPrintf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3625,
          "old_api": "front",
          "new_api": null,
          "old_text": "vRelayExpiration.front()",
          "new_text": null,
          "old_line_content": "                            mapRelay.erase(vRelayExpiration.front().second);",
          "new_line_content": "                        {",
          "content_same": false
        },
        {
          "line": 3629,
          "old_api": "std::move(txinfo.tx)",
          "new_api": null,
          "old_text": "std::move(txinfo.tx)",
          "new_text": null,
          "old_line_content": "                        auto ret = mapRelay.insert(std::make_pair(hash, std::move(txinfo.tx)));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1582,
          "old_api": "GetLocalServices",
          "new_api": null,
          "old_text": "pfrom->GetLocalServices()",
          "new_text": null,
          "old_line_content": "    if (!(pfrom->GetLocalServices() & NODE_BLOOM) &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3631,
          "old_api": "std::make_pair(nNow + 15 * 60 * 1000000, ret.first)",
          "new_api": null,
          "old_text": "std::make_pair(nNow + 15 * 60 * 1000000, ret.first)",
          "new_text": null,
          "old_line_content": "                            vRelayExpiration.push_back(std::make_pair(nNow + 15 * 60 * 1000000, ret.first));",
          "new_line_content": "                        if (ret.second) {",
          "content_same": false
        },
        {
          "line": 3634,
          "old_api": "size",
          "new_api": null,
          "old_text": "vInv.size()",
          "new_text": null,
          "old_line_content": "                    if (vInv.size() == MAX_INV_SZ) {",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 1587,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "            LOCK(cs_main);",
          "new_line_content": "        if (pfrom->nVersion >= NO_BLOOM_VERSION) {",
          "content_same": false
        },
        {
          "line": 3638,
          "old_api": "insert",
          "new_api": null,
          "old_text": "pto->filterInventoryKnown.insert(hash)",
          "new_text": null,
          "old_line_content": "                    pto->filterInventoryKnown.insert(hash);",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 3642,
          "old_api": "empty",
          "new_api": null,
          "old_text": "vInv.empty()",
          "new_text": null,
          "old_line_content": "        if (!vInv.empty())",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1598,
          "old_api": "LogAcceptCategory",
          "new_api": null,
          "old_text": "LogAcceptCategory(BCLog::NET)",
          "new_text": null,
          "old_line_content": "        if (LogAcceptCategory(BCLog::NET)) {",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3646,
          "old_api": "GetTimeMicros",
          "new_api": null,
          "old_text": "GetTimeMicros()",
          "new_text": null,
          "old_line_content": "        nNow = GetTimeMicros();",
          "new_line_content": "        // Detect whether we're stalling",
          "content_same": false
        },
        {
          "line": 1601,
          "old_api": "LIMITED_STRING",
          "new_api": null,
          "old_text": "LIMITED_STRING(strReason, MAX_REJECT_MESSAGE_LENGTH)",
          "new_text": null,
          "old_line_content": "                vRecv >> LIMITED_STRING(strMsg, CMessageHeader::COMMAND_SIZE) >> ccode >> LIMITED_STRING(strReason, MAX_REJECT_MESSAGE_LENGTH);",
          "new_line_content": "                std::string strMsg; unsigned char ccode; std::string strReason;",
          "content_same": false
        },
        {
          "line": 3651,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pto->GetId()",
          "new_text": null,
          "old_line_content": "            LogPrintf(\"Peer=%d is stalling block download, disconnecting\\n\", pto->GetId());",
          "new_line_content": "            // should only happen during initial block download.",
          "content_same": false
        },
        {
          "line": 1604,
          "old_api": "itostr",
          "new_api": null,
          "old_text": "itostr(ccode)",
          "new_text": null,
          "old_line_content": "                ss << strMsg << \" code \" << itostr(ccode) << \": \" << strReason;",
          "new_line_content": "                std::ostringstream ss;",
          "content_same": false
        },
        {
          "line": 1610,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "hash.ToString()",
          "new_text": null,
          "old_line_content": "                    ss << \": hash \" << hash.ToString();",
          "new_line_content": "                    vRecv >> hash;",
          "content_same": false
        },
        {
          "line": 1612,
          "old_api": "str",
          "new_api": null,
          "old_text": "ss.str()",
          "new_text": null,
          "old_line_content": "                LogPrint(BCLog::NET, \"Reject %s\\n\", SanitizeString(ss.str()));",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 3660,
          "old_api": "size",
          "new_api": null,
          "old_text": "state.vBlocksInFlight.size()",
          "new_text": null,
          "old_line_content": "        if (state.vBlocksInFlight.size() > 0) {",
          "new_line_content": "        // to unreasonably increase our timeout.",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::NET, \"Unparseable reject message received\\n\")",
          "new_text": null,
          "old_line_content": "                LogPrint(BCLog::NET, \"Unparseable reject message received\\n\");",
          "new_line_content": "                // Avoid feedback loops by preventing reject messages from triggering a new reject message.",
          "content_same": false
        },
        {
          "line": 3664,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pto->GetId()",
          "new_text": null,
          "old_line_content": "                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->GetId());",
          "new_line_content": "            if (nNow > state.nDownloadingSince + consensusParams.nPowTargetSpacing * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {",
          "content_same": false
        },
        {
          "line": 3670,
          "old_api": "std::numeric_limits<int64_t>::max()",
          "new_api": null,
          "old_text": "std::numeric_limits<int64_t>::max()",
          "new_text": null,
          "old_line_content": "        if (state.fSyncStarted && state.nHeadersSyncTimeout < std::numeric_limits<int64_t>::max()) {",
          "new_line_content": "        // Check for headers sync timeouts",
          "content_same": false
        },
        {
          "line": 3672,
          "old_api": "GetAdjustedTime",
          "new_api": null,
          "old_text": "GetAdjustedTime()",
          "new_text": null,
          "old_line_content": "            if (pindexBestHeader->GetBlockTime() <= GetAdjustedTime() - 24*60*60) {",
          "new_line_content": "            // Detect whether this is a stalling initial-headers-sync peer",
          "content_same": false
        },
        {
          "line": 1626,
          "old_api": "std::string(\"Duplicate version message\")",
          "new_api": null,
          "old_text": "std::string(\"Duplicate version message\")",
          "new_text": null,
          "old_line_content": "                connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(\"Duplicate version message\")));",
          "new_line_content": "            if (enable_bip61) {",
          "content_same": false
        },
        {
          "line": 1628,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "            LOCK(cs_main);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3680,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pto->GetId()",
          "new_text": null,
          "old_line_content": "                        LogPrintf(\"Timeout downloading headers from peer=%d, disconnecting\\n\", pto->GetId());",
          "new_line_content": "                    if (!pto->fWhitelisted) {",
          "content_same": false
        },
        {
          "line": 3684,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pto->GetId()",
          "new_text": null,
          "old_line_content": "                        LogPrintf(\"Timeout downloading headers from whitelisted peer=%d, not disconnecting\\n\", pto->GetId());",
          "new_line_content": "                    } else {",
          "content_same": false
        },
        {
          "line": 1647,
          "old_api": "std::min(nVersion, PROTOCOL_VERSION)",
          "new_api": null,
          "old_text": "std::min(nVersion, PROTOCOL_VERSION)",
          "new_text": null,
          "old_line_content": "        nSendVersion = std::min(nVersion, PROTOCOL_VERSION);",
          "new_line_content": "        vRecv >> nVersion >> nServiceInt >> nTime >> addrMe;",
          "content_same": false
        },
        {
          "line": 3698,
          "old_api": "std::numeric_limits<int64_t>::max()",
          "new_api": null,
          "old_text": "std::numeric_limits<int64_t>::max()",
          "new_text": null,
          "old_line_content": "                state.nHeadersSyncTimeout = std::numeric_limits<int64_t>::max();",
          "new_line_content": "                // disconnect later.",
          "content_same": false
        },
        {
          "line": 1651,
          "old_api": "SetServices",
          "new_api": null,
          "old_text": "connman->SetServices(pfrom->addr, nServices)",
          "new_text": null,
          "old_line_content": "            connman->SetServices(pfrom->addr, nServices);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": "HasAllDesirableServiceFlags",
          "new_api": null,
          "old_text": "HasAllDesirableServiceFlags(nServices)",
          "new_text": null,
          "old_line_content": "        if (!pfrom->fInbound && !pfrom->fFeeler && !pfrom->m_manual_connection && !HasAllDesirableServiceFlags(nServices))",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1655,
          "old_api": "GetDesirableServiceFlags",
          "new_api": null,
          "old_text": "GetDesirableServiceFlags(nServices)",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->GetId(), nServices, GetDesirableServiceFlags(nServices));",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 3704,
          "old_api": "GetTime",
          "new_api": null,
          "old_text": "GetTime()",
          "new_text": null,
          "old_line_content": "        ConsiderEviction(pto, GetTime());",
          "new_line_content": "        // GetTime() is used by this anti-DoS logic so we can test this using mocktime",
          "content_same": false
        },
        {
          "line": 1657,
          "old_api": "Make",
          "new_api": null,
          "old_text": "CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,\n                                   strprintf(\"Expected to offer services %08x\", GetDesirableServiceFlags(nServices)))",
          "new_text": null,
          "old_line_content": "                connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,",
          "new_line_content": "            if (enable_bip61) {",
          "content_same": false
        },
        {
          "line": 3710,
          "old_api": "IsInitialBlockDownload",
          "new_api": null,
          "old_text": "IsInitialBlockDownload()",
          "new_text": null,
          "old_line_content": "        if (!pto->fClient && ((fFetch && !pto->m_limited_node) || !IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {",
          "new_line_content": "        std::vector<CInv> vGetData;",
          "content_same": false
        },
        {
          "line": 3713,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pto->GetId()",
          "new_text": null,
          "old_line_content": "            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);",
          "new_line_content": "            NodeId staller = -1;",
          "content_same": false
        },
        {
          "line": 1666,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->GetId(), nVersion);",
          "new_line_content": "            // disconnect from peers older than this proto version",
          "content_same": false
        },
        {
          "line": 3715,
          "old_api": "GetFetchFlags",
          "new_api": null,
          "old_text": "GetFetchFlags(pto)",
          "new_text": null,
          "old_line_content": "                uint32_t nFetchFlags = GetFetchFlags(pto);",
          "new_line_content": "            for (const CBlockIndex *pindex : vToDownload) {",
          "content_same": false
        },
        {
          "line": 1668,
          "old_api": "Make",
          "new_api": null,
          "old_text": "CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n                                   strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION))",
          "new_text": null,
          "old_line_content": "                connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,",
          "new_line_content": "            if (enable_bip61) {",
          "content_same": false
        },
        {
          "line": 3722,
          "old_api": "State",
          "new_api": null,
          "old_text": "State(staller)",
          "new_text": null,
          "old_line_content": "                if (State(staller)->nStallingSince == 0) {",
          "new_line_content": "            if (state.nBlocksInFlight == 0 && staller != -1) {",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": "empty",
          "new_api": null,
          "old_text": "vRecv.empty()",
          "new_text": null,
          "old_line_content": "        if (!vRecv.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1677,
          "old_api": "empty",
          "new_api": null,
          "old_text": "vRecv.empty()",
          "new_text": null,
          "old_line_content": "        if (!vRecv.empty()) {",
          "new_line_content": "            vRecv >> addrFrom >> nNonce;",
          "content_same": false
        },
        {
          "line": 1681,
          "old_api": "empty",
          "new_api": null,
          "old_text": "vRecv.empty()",
          "new_text": null,
          "old_line_content": "        if (!vRecv.empty()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1684,
          "old_api": "empty",
          "new_api": null,
          "old_text": "vRecv.empty()",
          "new_text": null,
          "old_line_content": "        if (!vRecv.empty())",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3732,
          "old_api": "begin",
          "new_api": null,
          "old_text": "pto->mapAskFor.begin()",
          "new_text": null,
          "old_line_content": "        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)",
          "new_line_content": "        //",
          "content_same": false
        },
        {
          "line": 3734,
          "old_api": "begin",
          "new_api": null,
          "old_text": "pto->mapAskFor.begin()",
          "new_text": null,
          "old_line_content": "            const CInv& inv = (*pto->mapAskFor.begin()).second;",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1687,
          "old_api": "CheckIncomingNonce",
          "new_api": null,
          "old_text": "connman->CheckIncomingNonce(nNonce)",
          "new_text": null,
          "old_line_content": "        if (pfrom->fInbound && !connman->CheckIncomingNonce(nNonce))",
          "new_line_content": "        // Disconnect if we connected to ourself",
          "content_same": false
        },
        {
          "line": 1689,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "pfrom->addr.ToString()",
          "new_text": null,
          "old_line_content": "            LogPrintf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString());",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 3737,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pto->GetId()",
          "new_text": null,
          "old_line_content": "                LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 3741,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(NetMsgType::GETDATA, vGetData)",
          "new_text": null,
          "old_line_content": "                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 1694,
          "old_api": "IsRoutable",
          "new_api": null,
          "old_text": "addrMe.IsRoutable()",
          "new_text": null,
          "old_line_content": "        if (pfrom->fInbound && addrMe.IsRoutable())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1696,
          "old_api": "SeenLocal",
          "new_api": null,
          "old_text": "SeenLocal(addrMe)",
          "new_text": null,
          "old_line_content": "            SeenLocal(addrMe);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 3746,
          "old_api": "erase",
          "new_api": null,
          "old_text": "pto->setAskFor.erase(inv.hash)",
          "new_text": null,
          "old_line_content": "                pto->setAskFor.erase(inv.hash);",
          "new_line_content": "                //If we're not going to ask, don't expect a response.",
          "content_same": false
        },
        {
          "line": 3748,
          "old_api": "begin",
          "new_api": null,
          "old_text": "pto->mapAskFor.begin()",
          "new_text": null,
          "old_line_content": "            pto->mapAskFor.erase(pto->mapAskFor.begin());",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1701,
          "old_api": "GetAdjustedTime",
          "new_api": null,
          "old_text": "GetAdjustedTime()",
          "new_text": null,
          "old_line_content": "            PushNodeVersion(pfrom, connman, GetAdjustedTime());",
          "new_line_content": "        if (pfrom->fInbound)",
          "content_same": false
        },
        {
          "line": 3750,
          "old_api": "empty",
          "new_api": null,
          "old_text": "vGetData.empty()",
          "new_text": null,
          "old_line_content": "        if (!vGetData.empty())",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1703,
          "old_api": "Make",
          "new_api": null,
          "old_text": "CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK)",
          "new_text": null,
          "old_line_content": "        connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1706,
          "old_api": "SetAddrLocal",
          "new_api": null,
          "old_text": "pfrom->SetAddrLocal(addrMe)",
          "new_text": null,
          "old_line_content": "        pfrom->SetAddrLocal(addrMe);",
          "new_line_content": "        pfrom->nServices = nServices;",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pfrom->cs_SubVer)",
          "new_text": null,
          "old_line_content": "            LOCK(pfrom->cs_SubVer);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 3757,
          "old_api": "GetBoolArg",
          "new_api": null,
          "old_text": "gArgs.GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER)",
          "new_text": null,
          "old_line_content": "        if (pto->nVersion >= FEEFILTER_VERSION && gArgs.GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER) &&",
          "new_line_content": "        // We don't want white listed peers to filter txs to us if we have -whitelistforcerelay",
          "content_same": false
        },
        {
          "line": 3764,
          "old_api": "round",
          "new_api": null,
          "old_text": "filterRounder.round(currentFilter)",
          "new_text": null,
          "old_line_content": "                CAmount filterToSend = filterRounder.round(currentFilter);",
          "new_line_content": "                static FeeFilterRounder filterRounder(default_feerate);",
          "content_same": false
        },
        {
          "line": 3766,
          "old_api": "GetFeePerK",
          "new_api": null,
          "old_text": "::minRelayTxFee.GetFeePerK()",
          "new_text": null,
          "old_line_content": "                filterToSend = std::max(filterToSend, ::minRelayTxFee.GetFeePerK());",
          "new_line_content": "                // We always have a fee filter of at least minRelayTxFee",
          "content_same": false
        },
        {
          "line": 3768,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(NetMsgType::FEEFILTER, filterToSend)",
          "new_text": null,
          "old_line_content": "                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::FEEFILTER, filterToSend));",
          "new_line_content": "                if (filterToSend != pto->lastSentFeeFilter) {",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pfrom->cs_filter)",
          "new_text": null,
          "old_line_content": "            LOCK(pfrom->cs_filter);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 3771,
          "old_api": "PoissonNextSend",
          "new_api": null,
          "old_text": "PoissonNextSend(timeNow, AVG_FEEFILTER_BROADCAST_INTERVAL)",
          "new_text": null,
          "old_line_content": "                pto->nextSendTimeFeeFilter = PoissonNextSend(timeNow, AVG_FEEFILTER_BROADCAST_INTERVAL);",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1726,
          "old_api": "SetSendVersion",
          "new_api": null,
          "old_text": "pfrom->SetSendVersion(nSendVersion)",
          "new_text": null,
          "old_line_content": "        pfrom->SetSendVersion(nSendVersion);",
          "new_line_content": "        // Change version",
          "content_same": false
        },
        {
          "line": 3777,
          "old_api": "GetRandInt",
          "new_api": null,
          "old_text": "GetRandInt(MAX_FEEFILTER_CHANGE_DELAY)",
          "new_text": null,
          "old_line_content": "                pto->nextSendTimeFeeFilter = timeNow + GetRandInt(MAX_FEEFILTER_CHANGE_DELAY) * 1000000;",
          "new_line_content": "                     (currentFilter < 3 * pto->lastSentFeeFilter / 4 || currentFilter > 4 * pto->lastSentFeeFilter / 3)) {",
          "content_same": false
        },
        {
          "line": 1731,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "            LOCK(cs_main);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1737,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "        LOCK(cs_main);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 3790,
          "old_api": "clear",
          "new_api": null,
          "old_text": "mapOrphanTransactions.clear()",
          "new_text": null,
          "old_line_content": "        mapOrphanTransactions.clear();",
          "new_line_content": "        // orphan transactions",
          "content_same": false
        },
        {
          "line": 1744,
          "old_api": "IsInitialBlockDownload",
          "new_api": null,
          "old_text": "IsInitialBlockDownload()",
          "new_text": null,
          "old_line_content": "            if (fListen && !IsInitialBlockDownload())",
          "new_line_content": "            // Advertise our address",
          "content_same": false
        },
        {
          "line": 1746,
          "old_api": "GetLocalServices",
          "new_api": null,
          "old_text": "pfrom->GetLocalServices()",
          "new_text": null,
          "old_line_content": "                CAddress addr = GetLocalAddress(&pfrom->addr, pfrom->GetLocalServices());",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1748,
          "old_api": "IsRoutable",
          "new_api": null,
          "old_text": "addr.IsRoutable()",
          "new_text": null,
          "old_line_content": "                if (addr.IsRoutable())",
          "new_line_content": "                FastRandomContext insecure_rand;",
          "content_same": false
        },
        {
          "line": 1750,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "addr.ToString()",
          "new_text": null,
          "old_line_content": "                    LogPrint(BCLog::NET, \"ProcessMessages: advertising address %s\\n\", addr.ToString());",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 1760,
          "old_api": "GetAddressCount",
          "new_api": null,
          "old_text": "connman->GetAddressCount()",
          "new_text": null,
          "old_line_content": "            if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || connman->GetAddressCount() < 1000)",
          "new_line_content": "            // Get recent addresses",
          "content_same": false
        },
        {
          "line": 1762,
          "old_api": "Make",
          "new_api": null,
          "old_text": "CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR)",
          "new_text": null,
          "old_line_content": "                connman->PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR));",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1765,
          "old_api": "MarkAddressGood",
          "new_api": null,
          "old_text": "connman->MarkAddressGood(pfrom->addr)",
          "new_text": null,
          "old_line_content": "            connman->MarkAddressGood(pfrom->addr);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1770,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "pfrom->addr.ToString()",
          "new_text": null,
          "old_line_content": "            remoteAddr = \", peeraddr=\" + pfrom->addr.ToString();",
          "new_line_content": "        if (fLogIPs)",
          "content_same": false
        },
        {
          "line": 1772,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "LogPrint(BCLog::NET, \"receive version message: %s: version %d, blocks=%d, us=%s, peer=%d%s\\n\",\n                  cleanSubVer, pfrom->nVersion,\n                  pfrom->nStartingHeight, addrMe.ToString(), pfrom->GetId(),\n                  remoteAddr)",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"receive version message: %s: version %d, blocks=%d, us=%s, peer=%d%s\\n\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1774,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "                  pfrom->nStartingHeight, addrMe.ToString(), pfrom->GetId(),",
          "new_line_content": "                  cleanSubVer, pfrom->nVersion,",
          "content_same": false
        },
        {
          "line": 1777,
          "old_api": "GetTime",
          "new_api": null,
          "old_text": "GetTime()",
          "new_text": null,
          "old_line_content": "        int64_t nTimeOffset = nTime - GetTime();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1779,
          "old_api": "AddTimeData",
          "new_api": null,
          "old_text": "AddTimeData(pfrom->addr, nTimeOffset)",
          "new_text": null,
          "old_line_content": "        AddTimeData(pfrom->addr, nTimeOffset);",
          "new_line_content": "        pfrom->nTimeOffset = nTimeOffset;",
          "content_same": false
        },
        {
          "line": 1783,
          "old_api": "ParseHex",
          "new_api": null,
          "old_text": "ParseHex(\"60010000000000000000000000ffffff7f00000000ffffff7ffeffff7f01ffffff7f00000000ffffff7f00ffffff7f002f555247454e543a20416c657274206b657920636f6d70726f6d697365642c2075706772616465207265717569726564004630440220653febd6410f470f6bae11cad19c48413becb1ac2c17f908fd0fd53bdc3abd5202206d0e9c96fe88d4a0f01ed9dedae2b6f9e00da94cad0fecaae66ecf689bf71b50\")",
          "new_text": null,
          "old_line_content": "            CDataStream finalAlert(ParseHex(\"60010000000000000000000000ffffff7f00000000ffffff7ffeffff7f01ffffff7f00000000ffffff7f00ffffff7f002f555247454e543a20416c657274206b657920636f6d70726f6d697365642c2075706772616465207265717569726564004630440220653febd6410f470f6bae11cad19c48413becb1ac2c17f908fd0fd53bdc3abd5202206d0e9c96fe88d4a0f01ed9dedae2b6f9e00da94cad0fecaae66ecf689bf71b50\"), SER_NETWORK, PROTOCOL_VERSION);",
          "new_line_content": "        if (pfrom->nVersion <= 70012) {",
          "content_same": false
        },
        {
          "line": 1789,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(pfrom->fInbound == false)",
          "new_text": null,
          "old_line_content": "            assert(pfrom->fInbound == false);",
          "new_line_content": "        if (pfrom->fFeeler) {",
          "content_same": false
        },
        {
          "line": 1797,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "        LOCK(cs_main);",
          "new_line_content": "        // Must have a version message before anything else",
          "content_same": false
        },
        {
          "line": 1803,
          "old_api": "GetSendVersion",
          "new_api": null,
          "old_text": "pfrom->GetSendVersion()",
          "new_text": null,
          "old_line_content": "    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());",
          "new_line_content": "    // At this point, the outgoing message serialization version can't change.",
          "content_same": false
        },
        {
          "line": 1807,
          "old_api": "load",
          "new_api": null,
          "old_text": "pfrom->nVersion.load()",
          "new_text": null,
          "old_line_content": "        pfrom->SetRecvVersion(std::min(pfrom->nVersion.load(), PROTOCOL_VERSION));",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1811,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "            LOCK(cs_main);",
          "new_line_content": "            // Mark this node as currently connected, so we update its timestamp later.",
          "content_same": false
        },
        {
          "line": 1823,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(NetMsgType::SENDHEADERS)",
          "new_text": null,
          "old_line_content": "            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDHEADERS));",
          "new_line_content": "            // nodes)",
          "content_same": false
        },
        {
          "line": 1833,
          "old_api": "GetLocalServices",
          "new_api": null,
          "old_text": "pfrom->GetLocalServices()",
          "new_text": null,
          "old_line_content": "            if (pfrom->GetLocalServices() & NODE_WITNESS)",
          "new_line_content": "            uint64_t nCMPCTBLOCKVersion = 2;",
          "content_same": false
        },
        {
          "line": 1836,
          "old_api": "Make",
          "new_api": null,
          "old_text": "msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion)",
          "new_text": null,
          "old_line_content": "            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));",
          "new_line_content": "            nCMPCTBLOCKVersion = 1;",
          "content_same": false
        },
        {
          "line": 1844,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "        LOCK(cs_main);",
          "new_line_content": "        // Must have a verack message before anything else",
          "content_same": false
        },
        {
          "line": 1854,
          "old_api": "GetAddressCount",
          "new_api": null,
          "old_text": "connman->GetAddressCount()",
          "new_text": null,
          "old_line_content": "        if (pfrom->nVersion < CADDR_TIME_VERSION && connman->GetAddressCount() > 1000)",
          "new_line_content": "        // Don't want addr from older versions unless seeding",
          "content_same": false
        },
        {
          "line": 1856,
          "old_api": "size",
          "new_api": null,
          "old_text": "vAddr.size()",
          "new_text": null,
          "old_line_content": "        if (vAddr.size() > 1000)",
          "new_line_content": "            return true;",
          "content_same": false
        },
        {
          "line": 1858,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "            LOCK(cs_main);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1865,
          "old_api": "GetAdjustedTime",
          "new_api": null,
          "old_text": "GetAdjustedTime()",
          "new_text": null,
          "old_line_content": "        int64_t nNow = GetAdjustedTime();",
          "new_line_content": "        std::vector<CAddress> vAddrOk;",
          "content_same": false
        },
        {
          "line": 1875,
          "old_api": "HasAllDesirableServiceFlags",
          "new_api": null,
          "old_text": "HasAllDesirableServiceFlags(addr.nServices)",
          "new_text": null,
          "old_line_content": "            if (!MayHaveUsefulAddressDB(addr.nServices) && !HasAllDesirableServiceFlags(addr.nServices))",
          "new_line_content": "            // part because we may make feeler connections to them.",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": "AddAddressKnown",
          "new_api": null,
          "old_text": "pfrom->AddAddressKnown(addr)",
          "new_text": null,
          "old_line_content": "            pfrom->AddAddressKnown(addr);",
          "new_line_content": "                addr.nTime = nNow - 5 * 24 * 60 * 60;",
          "content_same": false
        },
        {
          "line": 1885,
          "old_api": "RelayAddress",
          "new_api": null,
          "old_text": "RelayAddress(addr, fReachable, connman)",
          "new_text": null,
          "old_line_content": "                RelayAddress(addr, fReachable, connman);",
          "new_line_content": "                // Relay to a limited number of other nodes",
          "content_same": false
        },
        {
          "line": 1889,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "vAddrOk.push_back(addr)",
          "new_text": null,
          "old_line_content": "                vAddrOk.push_back(addr);",
          "new_line_content": "            if (fReachable)",
          "content_same": false
        },
        {
          "line": 1891,
          "old_api": "AddNewAddresses",
          "new_api": null,
          "old_text": "connman->AddNewAddresses(vAddrOk, pfrom->addr, 2 * 60 * 60)",
          "new_text": null,
          "old_line_content": "        connman->AddNewAddresses(vAddrOk, pfrom->addr, 2 * 60 * 60);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1900,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "        LOCK(cs_main);",
          "new_line_content": "    if (strCommand == NetMsgType::SENDHEADERS) {",
          "content_same": false
        },
        {
          "line": 1909,
          "old_api": "GetLocalServices",
          "new_api": null,
          "old_text": "pfrom->GetLocalServices()",
          "new_text": null,
          "old_line_content": "        if (nCMPCTBLOCKVersion == 1 || ((pfrom->GetLocalServices() & NODE_WITNESS) && nCMPCTBLOCKVersion == 2)) {",
          "new_line_content": "        vRecv >> fAnnounceUsingCMPCTBLOCK >> nCMPCTBLOCKVersion;",
          "content_same": false
        },
        {
          "line": 1912,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "            if (!State(pfrom->GetId())->fProvidesHeaderAndIDs) {",
          "new_line_content": "            // fProvidesHeaderAndIDs is used to \"lock in\" version of compact blocks we send (fWantsCmpctWitness)",
          "content_same": false
        },
        {
          "line": 1916,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "            if (State(pfrom->GetId())->fWantsCmpctWitness == (nCMPCTBLOCKVersion == 2)) // ignore later version announces",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1922,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "                    State(pfrom->GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1);",
          "new_line_content": "                else",
          "content_same": false
        },
        {
          "line": 1931,
          "old_api": "size",
          "new_api": null,
          "old_text": "vInv.size()",
          "new_text": null,
          "old_line_content": "        if (vInv.size() > MAX_INV_SZ)",
          "new_line_content": "        vRecv >> vInv;",
          "content_same": false
        },
        {
          "line": 1933,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "            LOCK(cs_main);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1941,
          "old_api": "GetBoolArg",
          "new_api": null,
          "old_text": "gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)",
          "new_text": null,
          "old_line_content": "        if (pfrom->fWhitelisted && gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY))",
          "new_line_content": "        // Allow whitelisted peers to send data other than blocks in blocks only mode if whitelistrelay is true",
          "content_same": false
        },
        {
          "line": 1944,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "        LOCK(cs_main);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1946,
          "old_api": "GetFetchFlags",
          "new_api": null,
          "old_text": "GetFetchFlags(pfrom)",
          "new_text": null,
          "old_line_content": "        uint32_t nFetchFlags = GetFetchFlags(pfrom);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1953,
          "old_api": "AlreadyHave",
          "new_api": null,
          "old_text": "AlreadyHave(inv)",
          "new_text": null,
          "old_line_content": "            bool fAlreadyHave = AlreadyHave(inv);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1961,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "                UpdateBlockAvailability(pfrom->GetId(), inv.hash);",
          "new_line_content": "            if (inv.type == MSG_BLOCK) {",
          "content_same": false
        },
        {
          "line": 1968,
          "old_api": "GetLocator",
          "new_api": null,
          "old_text": "chainActive.GetLocator(pindexBestHeader)",
          "new_text": null,
          "old_line_content": "                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash));",
          "new_line_content": "                    // then ask for the blocks we need.",
          "content_same": false
        },
        {
          "line": 1974,
          "old_api": "AddInventoryKnown",
          "new_api": null,
          "old_text": "pfrom->AddInventoryKnown(inv)",
          "new_text": null,
          "old_line_content": "                pfrom->AddInventoryKnown(inv);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1976,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "                    LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol peer=%d\\n\", inv.hash.ToString(), pfrom->GetId());",
          "new_line_content": "                if (fBlocksOnly) {",
          "content_same": false
        },
        {
          "line": 1988,
          "old_api": "size",
          "new_api": null,
          "old_text": "vInv.size()",
          "new_text": null,
          "old_line_content": "        if (vInv.size() > MAX_INV_SZ)",
          "new_line_content": "        vRecv >> vInv;",
          "content_same": false
        },
        {
          "line": 1990,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "            LOCK(cs_main);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1995,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom->GetId());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1997,
          "old_api": "size",
          "new_api": null,
          "old_text": "vInv.size()",
          "new_text": null,
          "old_line_content": "        if (vInv.size() > 0) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2001,
          "old_api": "end",
          "new_api": null,
          "old_text": "vInv.end()",
          "new_text": null,
          "old_line_content": "        pfrom->vRecvGetData.insert(pfrom->vRecvGetData.end(), vInv.begin(), vInv.end());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2011,
          "old_api": "size",
          "new_api": null,
          "old_text": "locator.vHave.size()",
          "new_text": null,
          "old_line_content": "        if (locator.vHave.size() > MAX_LOCATOR_SZ) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2027,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_most_recent_block)",
          "new_text": null,
          "old_line_content": "                LOCK(cs_most_recent_block);",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 2031,
          "old_api": "Params",
          "new_api": null,
          "old_text": "Params()",
          "new_text": null,
          "old_line_content": "            if (!ActivateBestChain(state, Params(), a_recent_block)) {",
          "new_line_content": "            CValidationState state;",
          "content_same": false
        },
        {
          "line": 2036,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "        LOCK(cs_main);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2039,
          "old_api": "FindForkInGlobalIndex",
          "new_api": null,
          "old_text": "FindForkInGlobalIndex(chainActive, locator)",
          "new_text": null,
          "old_line_content": "        const CBlockIndex* pindex = FindForkInGlobalIndex(chainActive, locator);",
          "new_line_content": "        // Find the last block the caller has in the main chain",
          "content_same": false
        },
        {
          "line": 2043,
          "old_api": "Next",
          "new_api": null,
          "old_text": "chainActive.Next(pindex)",
          "new_text": null,
          "old_line_content": "            pindex = chainActive.Next(pindex);",
          "new_line_content": "        if (pindex)",
          "content_same": false
        },
        {
          "line": 2045,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pfrom->GetId()",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"getblocks %d to %s limit %d from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), nLimit, pfrom->GetId());",
          "new_line_content": "        int nLimit = 500;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 261,
      "total_additions": 550,
      "total_deletions": 550,
      "total_api_changes": 1361
    },
    "non_api_changes": {
      "has_non_api_changes": false,
      "evidence": {
        "total_diff_lines": 3,
        "api_related_lines": 1361,
        "non_api_lines": 0,
        "non_api_line_numbers": []
      }
    },
    "api_calls_before": 1499,
    "api_calls_after": 1499,
    "diff_info": {
      "added_lines": 2,
      "removed_lines": 1,
      "total_diff_lines": 18
    }
  }
}