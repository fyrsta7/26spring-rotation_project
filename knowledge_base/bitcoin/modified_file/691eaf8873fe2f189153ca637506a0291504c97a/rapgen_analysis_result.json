{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/691eaf8873fe2f189153ca637506a0291504c97a",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/691eaf8873fe2f189153ca637506a0291504c97a/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/691eaf8873fe2f189153ca637506a0291504c97a/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/691eaf8873fe2f189153ca637506a0291504c97a/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 814,
          "old_api": "size",
          "new_api": "GetTime<std::chrono::seconds>()",
          "old_text": "data.size()",
          "new_text": "GetTime<std::chrono::seconds>()",
          "old_line_content": "                node.nSendSize -= data.size();",
          "new_line_content": "            node.m_last_send = GetTime<std::chrono::seconds>();",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": "size",
          "new_api": "static_cast<size_t>(1)",
          "old_text": "eviction_candidates.size()",
          "new_text": "static_cast<size_t>(1)",
          "old_line_content": "            const size_t before = eviction_candidates.size();",
          "new_line_content": "        const size_t protect_per_network{std::max(disadvantaged_to_protect / num_networks, static_cast<size_t>(1))};",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": "EraseLastKElements",
          "new_api": "nodiscard",
          "old_text": "EraseLastKElements(vEvictionCandidates, CompareNetGroupKeyed, 4)",
          "new_text": "nodiscard",
          "old_line_content": "    EraseLastKElements(vEvictionCandidates, CompareNetGroupKeyed, 4);",
          "new_line_content": "[[nodiscard]] std::optional<NodeId> SelectNodeToEvict(std::vector<NodeEvictionCandidate>&& vEvictionCandidates)",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": "empty",
          "new_api": "EraseLastKElements",
          "old_text": "vEvictionCandidates.empty()",
          "new_text": "EraseLastKElements(vEvictionCandidates, CompareNodeBlockTime, 4)",
          "old_line_content": "    if (vEvictionCandidates.empty()) return std::nullopt;",
          "new_line_content": "    EraseLastKElements(vEvictionCandidates, CompareNodeBlockTime, 4);",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": "end",
          "new_api": "empty",
          "old_text": "vEvictionCandidates.end()",
          "new_text": "vEvictionCandidates.empty()",
          "old_line_content": "        vEvictionCandidates.erase(std::remove_if(vEvictionCandidates.begin(),vEvictionCandidates.end(),",
          "new_line_content": "    if (vEvictionCandidates.empty()) return std::nullopt;",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": "HasAllDesirableServiceFlags",
          "new_api": "LOCK",
          "old_text": "HasAllDesirableServiceFlags(node->nServices)",
          "new_text": "LOCK(node->m_tx_relay->cs_filter)",
          "old_line_content": "                                               HasAllDesirableServiceFlags(node->nServices),",
          "new_line_content": "                LOCK(node->m_tx_relay->cs_filter);",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": "push_back",
          "new_api": "GetId",
          "old_text": "vEvictionCandidates.push_back(candidate)",
          "new_text": "node->GetId()",
          "old_line_content": "            vEvictionCandidates.push_back(candidate);",
          "new_line_content": "            NodeEvictionCandidate candidate = {node->GetId(), node->m_connected, node->m_min_ping_time,",
          "content_same": false
        },
        {
          "line": 1090,
          "old_api": "GetId",
          "new_api": "std::move(vEvictionCandidates)",
          "old_text": "pnode->GetId()",
          "new_text": "std::move(vEvictionCandidates)",
          "old_line_content": "        if (pnode->GetId() == *node_id_to_evict) {",
          "new_line_content": "    const std::optional<NodeId> node_id_to_evict = SelectNodeToEvict(std::move(vEvictionCandidates));",
          "content_same": false
        },
        {
          "line": 1108,
          "old_api": "NetworkErrorString",
          "new_api": "Accept",
          "old_text": "NetworkErrorString(nErr)",
          "new_text": "hListenSocket.sock->Accept((struct sockaddr*)&sockaddr, &len)",
          "old_line_content": "            LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));",
          "new_line_content": "    auto sock = hListenSocket.sock->Accept((struct sockaddr*)&sockaddr, &len);",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": "LogPrintf",
          "new_api": "NetworkErrorString",
          "old_text": "LogPrintf(\"Warning: Unknown socket family\\n\")",
          "new_text": "NetworkErrorString(nErr)",
          "old_line_content": "        LogPrintf(\"Warning: Unknown socket family\\n\");",
          "new_line_content": "            LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));",
          "content_same": false
        },
        {
          "line": 1119,
          "old_api": "Get",
          "new_api": "SetSockAddr",
          "old_text": "sock->Get()",
          "new_text": "addr.SetSockAddr((const struct sockaddr*)&sockaddr)",
          "old_line_content": "    const CAddress addr_bind{MaybeFlipIPv6toCJDNS(GetBindAddress(sock->Get())), NODE_NONE};",
          "new_line_content": "    if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {",
          "content_same": false
        },
        {
          "line": 1122,
          "old_api": "AddSocketPermissionFlags",
          "new_api": "MaybeFlipIPv6toCJDNS",
          "old_text": "hListenSocket.AddSocketPermissionFlags(permissionFlags)",
          "new_text": "MaybeFlipIPv6toCJDNS(addr)",
          "old_line_content": "    hListenSocket.AddSocketPermissionFlags(permissionFlags);",
          "new_line_content": "        addr = CAddress{MaybeFlipIPv6toCJDNS(addr), NODE_NONE};",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": "NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::NoBan)",
          "new_api": "AddWhitelistPermissionFlags",
          "old_text": "NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::NoBan)",
          "new_text": "AddWhitelistPermissionFlags(permissionFlags, addr)",
          "old_line_content": "        NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::NoBan);",
          "new_line_content": "    AddWhitelistPermissionFlags(permissionFlags, addr);",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": "LOCK",
          "new_api": "NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::Relay)",
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": "NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::Relay)",
          "old_line_content": "        LOCK(m_nodes_mutex);",
          "new_line_content": "        if (gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)) NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::Relay);",
          "content_same": false
        },
        {
          "line": 1147,
          "old_api": "IsInboundConn",
          "new_api": "NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::NoBan)",
          "old_text": "pnode->IsInboundConn()",
          "new_text": "NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::NoBan)",
          "old_line_content": "            if (pnode->IsInboundConn()) nInbound++;",
          "new_line_content": "        NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::NoBan);",
          "content_same": false
        },
        {
          "line": 1164,
          "old_api": "Get",
          "new_api": "ToString",
          "old_text": "sock->Get()",
          "new_text": "addr.ToString()",
          "old_line_content": "    SetSocketNoDelay(sock->Get());",
          "new_line_content": "        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", addr.ToString());",
          "content_same": false
        },
        {
          "line": 1170,
          "old_api": "ToString",
          "new_api": "Get",
          "old_text": "addr.ToString()",
          "new_text": "sock->Get()",
          "old_line_content": "        LogPrint(BCLog::NET, \"connection from %s dropped (banned)\\n\", addr.ToString());",
          "new_line_content": "    SetSocketNoDelay(sock->Get());",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": "NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::NoBan)",
          "new_api": "ToString",
          "old_text": "NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::NoBan)",
          "new_text": "addr.ToString()",
          "old_line_content": "    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::NoBan) && nInbound + 1 >= nMaxInbound && discouraged)",
          "new_line_content": "        LogPrint(BCLog::NET, \"connection from %s dropped (banned)\\n\", addr.ToString());",
          "content_same": false
        },
        {
          "line": 1184,
          "old_api": "AttemptToEvictConnection",
          "new_api": "ToString",
          "old_text": "AttemptToEvictConnection()",
          "new_text": "addr.ToString()",
          "old_line_content": "        if (!AttemptToEvictConnection()) {",
          "new_line_content": "        LogPrint(BCLog::NET, \"connection from %s dropped (discouraged)\\n\", addr.ToString());",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": "Write",
          "new_api": "LogPrint",
          "old_text": "GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize()",
          "new_text": "LogPrint(BCLog::NET, \"failed to find an eviction candidate - connection dropped (full)\\n\")",
          "old_line_content": "    uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();",
          "new_line_content": "            LogPrint(BCLog::NET, \"failed to find an eviction candidate - connection dropped (full)\\n\");",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": "AddRef",
          "new_api": "NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::BloomFilter)",
          "old_text": "pnode->AddRef()",
          "new_text": "NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::BloomFilter)",
          "old_line_content": "    pnode->AddRef();",
          "new_line_content": "    if (NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::BloomFilter)) {",
          "content_same": false
        },
        {
          "line": 1206,
          "old_api": "ToString",
          "new_api": "CalculateKeyedNetGroup",
          "old_text": "addr.ToString()",
          "new_text": "CalculateKeyedNetGroup(addr)",
          "old_line_content": "    LogPrint(BCLog::NET, \"connection from %s accepted\\n\", addr.ToString());",
          "new_line_content": "    CNode* pnode = new CNode(id, nodeServices, std::move(sock), addr, CalculateKeyedNetGroup(addr), nonce, addr_bind, \"\", ConnectionType::INBOUND, inbound_onion);",
          "content_same": false
        },
        {
          "line": 1210,
          "old_api": "push_back",
          "new_api": "InitializeNode",
          "old_text": "m_nodes.push_back(pnode)",
          "new_text": "m_msgproc->InitializeNode(pnode)",
          "old_line_content": "        m_nodes.push_back(pnode);",
          "new_line_content": "    m_msgproc->InitializeNode(pnode);",
          "content_same": false
        },
        {
          "line": 1262,
          "old_api": "GetId",
          "new_api": "LOCK",
          "old_text": "pnode->GetId()",
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "                    LogPrint(BCLog::NET, \"Network not active, dropping peer=%d\\n\", pnode->GetId());",
          "new_line_content": "        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1281,
          "old_api": "CloseSocketDisconnect",
          "new_api": "end",
          "old_text": "pnode->CloseSocketDisconnect()",
          "new_text": "m_nodes.end()",
          "old_line_content": "                pnode->CloseSocketDisconnect();",
          "new_line_content": "                m_nodes.erase(remove(m_nodes.begin(), m_nodes.end(), pnode), m_nodes.end());",
          "content_same": false
        },
        {
          "line": 1313,
          "old_api": "NotifyNumConnectionsChanged",
          "new_api": "LOCK",
          "old_text": "m_client_interface->NotifyNumConnectionsChanged(nodes_size)",
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "            m_client_interface->NotifyNumConnectionsChanged(nodes_size);",
          "new_line_content": "        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1333,
          "old_api": "count",
          "new_api": "GetTime<std::chrono::seconds>()",
          "old_text": "last_send.count()",
          "new_text": "GetTime<std::chrono::seconds>()",
          "old_line_content": "    if (last_recv.count() == 0 || last_send.count() == 0) {",
          "new_line_content": "    const auto now{GetTime<std::chrono::seconds>()};",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": "GetId",
          "new_api": "load",
          "old_text": "node.GetId()",
          "new_text": "node.m_last_send.load()",
          "old_line_content": "        LogPrint(BCLog::NET, \"socket no message in first %i seconds, %d %d peer=%d\\n\", count_seconds(m_peer_connect_timeout), last_recv.count() != 0, last_send.count() != 0, node.GetId());",
          "new_line_content": "    const auto last_send{node.m_last_send.load()};",
          "content_same": false
        },
        {
          "line": 1339,
          "old_api": "GetId",
          "new_api": "count",
          "old_text": "node.GetId()",
          "new_text": "last_send.count()",
          "old_line_content": "        LogPrint(BCLog::NET, \"socket sending timeout: %is peer=%d\\n\", count_seconds(now - last_send), node.GetId());",
          "new_line_content": "    if (last_recv.count() == 0 || last_send.count() == 0) {",
          "content_same": false
        },
        {
          "line": 1443,
          "old_api": "insert",
          "new_api": "size",
          "old_text": "send_set.insert(pollfd_entry.fd)",
          "new_text": "vpollfds.size()",
          "old_line_content": "        if (pollfd_entry.revents & POLLOUT)           send_set.insert(pollfd_entry.fd);",
          "new_line_content": "    if (poll(vpollfds.data(), vpollfds.size(), SELECT_TIMEOUT_MILLISECONDS) < 0) return;",
          "content_same": false
        },
        {
          "line": 1475,
          "old_api": "FD_SET",
          "new_api": "FD_ZERO",
          "old_text": "FD_SET(hSocket, &fdsetRecv)",
          "new_text": "FD_ZERO(&fdsetRecv)",
          "old_line_content": "        FD_SET(hSocket, &fdsetRecv);",
          "new_line_content": "    FD_ZERO(&fdsetRecv);",
          "content_same": false
        },
        {
          "line": 1476,
          "old_api": "std::max(hSocketMax, hSocket)",
          "new_api": "FD_ZERO",
          "old_text": "std::max(hSocketMax, hSocket)",
          "new_text": "FD_ZERO(&fdsetSend)",
          "old_line_content": "        hSocketMax = std::max(hSocketMax, hSocket);",
          "new_line_content": "    FD_ZERO(&fdsetSend);",
          "content_same": false
        },
        {
          "line": 1481,
          "old_api": "std::max(hSocketMax, hSocket)",
          "new_api": "FD_SET",
          "old_text": "std::max(hSocketMax, hSocket)",
          "new_text": "FD_SET(hSocket, &fdsetRecv)",
          "old_line_content": "        hSocketMax = std::max(hSocketMax, hSocket);",
          "new_line_content": "        FD_SET(hSocket, &fdsetRecv);",
          "content_same": false
        },
        {
          "line": 1486,
          "old_api": "std::max(hSocketMax, hSocket)",
          "new_api": "FD_SET",
          "old_text": "std::max(hSocketMax, hSocket)",
          "new_text": "FD_SET(hSocket, &fdsetSend)",
          "old_line_content": "        hSocketMax = std::max(hSocketMax, hSocket);",
          "new_line_content": "        FD_SET(hSocket, &fdsetSend);",
          "content_same": false
        },
        {
          "line": 1502,
          "old_api": "std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS)",
          "new_api": "WSAGetLastError",
          "old_text": "std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS)",
          "new_text": "WSAGetLastError()",
          "old_line_content": "        if (!interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS)))",
          "new_line_content": "        int nErr = WSAGetLastError();",
          "content_same": false
        },
        {
          "line": 1507,
          "old_api": "FD_ISSET",
          "new_api": "FD_ZERO",
          "old_text": "FD_ISSET(hSocket, &fdsetRecv)",
          "new_text": "FD_ZERO(&fdsetError)",
          "old_line_content": "        if (FD_ISSET(hSocket, &fdsetRecv)) {",
          "new_line_content": "        FD_ZERO(&fdsetError);",
          "content_same": false
        },
        {
          "line": 1508,
          "old_api": "insert",
          "new_api": "std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS)",
          "old_text": "recv_set.insert(hSocket)",
          "new_text": "std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS)",
          "old_line_content": "            recv_set.insert(hSocket);",
          "new_line_content": "        if (!interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS)))",
          "content_same": false
        },
        {
          "line": 1571,
          "old_api": "Get",
          "new_api": "LOCK",
          "old_text": "pnode->m_sock->Get()",
          "new_text": "LOCK(pnode->cs_hSocket)",
          "old_line_content": "            errorSet = error_set.count(pnode->m_sock->Get()) > 0;",
          "new_line_content": "            LOCK(pnode->cs_hSocket);",
          "content_same": false
        },
        {
          "line": 1589,
          "old_api": "CloseSocketDisconnect",
          "new_api": "Recv",
          "old_text": "pnode->CloseSocketDisconnect()",
          "new_text": "pnode->m_sock->Recv(pchBuf, sizeof(pchBuf), MSG_DONTWAIT)",
          "old_line_content": "                    pnode->CloseSocketDisconnect();",
          "new_line_content": "                nBytes = pnode->m_sock->Recv(pchBuf, sizeof(pchBuf), MSG_DONTWAIT);",
          "content_same": false
        },
        {
          "line": 1594,
          "old_api": "begin",
          "new_api": "ReceiveMsgBytes",
          "old_text": "pnode->vRecvMsg.begin()",
          "new_text": "pnode->ReceiveMsgBytes({pchBuf, (size_t)nBytes}, notify)",
          "old_line_content": "                    auto it(pnode->vRecvMsg.begin());",
          "new_line_content": "                if (!pnode->ReceiveMsgBytes({pchBuf, (size_t)nBytes}, notify)) {",
          "content_same": false
        },
        {
          "line": 1595,
          "old_api": "end",
          "new_api": "CloseSocketDisconnect",
          "old_text": "pnode->vRecvMsg.end()",
          "new_text": "pnode->CloseSocketDisconnect()",
          "old_line_content": "                    for (; it != pnode->vRecvMsg.end(); ++it) {",
          "new_line_content": "                    pnode->CloseSocketDisconnect();",
          "content_same": false
        },
        {
          "line": 1601,
          "old_api": "LOCK",
          "new_api": "end",
          "old_text": "LOCK(pnode->cs_vProcessMsg)",
          "new_text": "pnode->vRecvMsg.end()",
          "old_line_content": "                        LOCK(pnode->cs_vProcessMsg);",
          "new_line_content": "                    for (; it != pnode->vRecvMsg.end(); ++it) {",
          "content_same": false
        },
        {
          "line": 1626,
          "old_api": "CloseSocketDisconnect",
          "new_api": "WSAGetLastError",
          "old_text": "pnode->CloseSocketDisconnect()",
          "new_text": "WSAGetLastError()",
          "old_line_content": "                    pnode->CloseSocketDisconnect();",
          "new_line_content": "                int nErr = WSAGetLastError();",
          "content_same": false
        },
        {
          "line": 1684,
          "old_api": "size",
          "new_api": "end",
          "old_text": "seeds.size()",
          "new_text": "seeds.end()",
          "old_line_content": "        seeds_right_now = seeds.size();",
          "new_line_content": "    Shuffle(seeds.begin(), seeds.end(), rng);",
          "content_same": false
        },
        {
          "line": 1717,
          "old_api": "std::min(DNSSEEDS_DELAY_FEW_PEERS, to_wait)",
          "new_api": "count",
          "old_text": "std::min(DNSSEEDS_DELAY_FEW_PEERS, to_wait)",
          "new_text": "seeds_wait_time.count()",
          "old_line_content": "                    std::chrono::seconds w = std::min(DNSSEEDS_DELAY_FEW_PEERS, to_wait);",
          "new_line_content": "                LogPrintf(\"Waiting %d seconds before querying DNS seeds.\\n\", seeds_wait_time.count());",
          "content_same": false
        },
        {
          "line": 1723,
          "old_api": "LOCK",
          "new_api": "std::min(DNSSEEDS_DELAY_FEW_PEERS, to_wait)",
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": "std::min(DNSSEEDS_DELAY_FEW_PEERS, to_wait)",
          "old_line_content": "                        LOCK(m_nodes_mutex);",
          "new_line_content": "                    std::chrono::seconds w = std::min(DNSSEEDS_DELAY_FEW_PEERS, to_wait);",
          "content_same": false
        },
        {
          "line": 1731,
          "old_api": "LogPrintf",
          "new_api": "IsFullOutboundConn",
          "old_text": "LogPrintf(\"P2P peers available. Finished DNS seeding.\\n\")",
          "new_text": "pnode->IsFullOutboundConn()",
          "old_line_content": "                            LogPrintf(\"P2P peers available. Finished DNS seeding.\\n\");",
          "new_line_content": "                            if (pnode->fSuccessfullyConnected && pnode->IsFullOutboundConn()) ++nRelevant;",
          "content_same": false
        },
        {
          "line": 1753,
          "old_api": "AddAddrFetch",
          "new_api": "sleep_for",
          "old_text": "AddAddrFetch(seed)",
          "new_text": "interruptNet.sleep_for(std::chrono::seconds{1})",
          "old_line_content": "            AddAddrFetch(seed);",
          "new_line_content": "                if (!interruptNet.sleep_for(std::chrono::seconds{1})) return;",
          "content_same": false
        },
        {
          "line": 1757,
          "old_api": "GetDesirableServiceFlags",
          "new_api": "LogPrintf",
          "old_text": "GetDesirableServiceFlags(NODE_NONE)",
          "new_text": "LogPrintf(\"Loading addresses from DNS seed %s\\n\", seed)",
          "old_line_content": "            ServiceFlags requiredServiceBits = GetDesirableServiceFlags(NODE_NONE);",
          "new_line_content": "        LogPrintf(\"Loading addresses from DNS seed %s\\n\", seed);",
          "content_same": false
        },
        {
          "line": 1758,
          "old_api": "strprintf",
          "new_api": "HaveNameProxy",
          "old_text": "strprintf(\"x%x.%s\", requiredServiceBits, seed)",
          "new_text": "HaveNameProxy()",
          "old_line_content": "            std::string host = strprintf(\"x%x.%s\", requiredServiceBits, seed);",
          "new_line_content": "        if (HaveNameProxy()) {",
          "content_same": false
        },
        {
          "line": 1764,
          "old_api": "LookupHost",
          "new_api": "strprintf",
          "old_text": "LookupHost(host, vIPs, nMaxIPs, true)",
          "new_text": "strprintf(\"x%x.%s\", requiredServiceBits, seed)",
          "old_line_content": "            if (LookupHost(host, vIPs, nMaxIPs, true)) {",
          "new_line_content": "            std::string host = strprintf(\"x%x.%s\", requiredServiceBits, seed);",
          "content_same": false
        },
        {
          "line": 1807,
          "old_api": "c_str",
          "new_api": "front",
          "old_text": "strDest.c_str()",
          "new_text": "m_addr_fetches.front()",
          "old_line_content": "        OpenNetworkConnection(addr, false, &grant, strDest.c_str(), ConnectionType::ADDR_FETCH);",
          "new_line_content": "        strDest = m_addr_fetches.front();",
          "content_same": false
        },
        {
          "line": 1864,
          "old_api": "ProcessAddrFetch",
          "new_api": "SetSyscallSandboxPolicy",
          "old_text": "ProcessAddrFetch()",
          "new_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET_OPEN_CONNECTION)",
          "old_line_content": "            ProcessAddrFetch();",
          "new_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET_OPEN_CONNECTION);",
          "content_same": false
        },
        {
          "line": 1881,
          "old_api": "GetTime<std::chrono::microseconds>()",
          "new_api": "std::chrono::milliseconds(500)",
          "old_text": "GetTime<std::chrono::microseconds>()",
          "new_text": "std::chrono::milliseconds(500)",
          "old_line_content": "    auto start = GetTime<std::chrono::microseconds>();",
          "new_line_content": "            if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))",
          "content_same": false
        },
        {
          "line": 1887,
          "old_api": "GetBoolArg",
          "new_api": "GetTime<std::chrono::microseconds>()",
          "old_text": "gArgs.GetBoolArg(\"-fixedseeds\", DEFAULT_FIXEDSEEDS)",
          "new_text": "GetTime<std::chrono::microseconds>()",
          "old_line_content": "    bool add_fixed_seeds = gArgs.GetBoolArg(\"-fixedseeds\", DEFAULT_FIXEDSEEDS);",
          "new_line_content": "    auto start = GetTime<std::chrono::microseconds>();",
          "content_same": false
        },
        {
          "line": 1890,
          "old_api": "LogPrintf",
          "new_api": "PoissonNextSend",
          "old_text": "LogPrintf(\"Fixed seeds are disabled\\n\")",
          "new_text": "PoissonNextSend(start, FEELER_INTERVAL)",
          "old_line_content": "        LogPrintf(\"Fixed seeds are disabled\\n\");",
          "new_line_content": "    auto next_feeler = PoissonNextSend(start, FEELER_INTERVAL);",
          "content_same": false
        },
        {
          "line": 1919,
          "old_api": "empty",
          "new_api": "LogPrintf",
          "old_text": "m_added_nodes.empty()",
          "new_text": "LogPrintf(\"Adding fixed seeds as 60 seconds have passed and addrman is empty\\n\")",
          "old_line_content": "                if (m_addr_fetches.empty() && m_added_nodes.empty()) {",
          "new_line_content": "                LogPrintf(\"Adding fixed seeds as 60 seconds have passed and addrman is empty\\n\");",
          "content_same": false
        },
        {
          "line": 1927,
          "old_api": "SetInternal",
          "new_api": "LogPrintf",
          "old_text": "local.SetInternal(\"fixedseeds\")",
          "new_text": "LogPrintf(\"Adding fixed seeds as -dnsseed=0, -addnode is not provided and all -seednode(s) attempted\\n\")",
          "old_line_content": "                local.SetInternal(\"fixedseeds\");",
          "new_line_content": "                    LogPrintf(\"Adding fixed seeds as -dnsseed=0, -addnode is not provided and all -seednode(s) attempted\\n\");",
          "content_same": false
        },
        {
          "line": 1968,
          "old_api": "GetTime<std::chrono::microseconds>()",
          "new_api": "GetAsmap",
          "old_text": "GetTime<std::chrono::microseconds>()",
          "new_text": "addrman.GetAsmap()",
          "old_line_content": "        auto now = GetTime<std::chrono::microseconds>();",
          "new_line_content": "                        setConnected.insert(pnode->addr.GetGroup(addrman.GetAsmap()));",
          "content_same": false
        },
        {
          "line": 2031,
          "old_api": "empty",
          "new_api": "ResolveCollisions",
          "old_text": "m_anchors.empty()",
          "new_text": "addrman.ResolveCollisions()",
          "old_line_content": "            if (anchor && !m_anchors.empty()) {",
          "new_line_content": "        addrman.ResolveCollisions();",
          "content_same": false
        },
        {
          "line": 2033,
          "old_api": "pop_back",
          "new_api": "GetAdjustedTime",
          "old_text": "m_anchors.pop_back()",
          "new_text": "GetAdjustedTime()",
          "old_line_content": "                m_anchors.pop_back();",
          "new_line_content": "        int64_t nANow = GetAdjustedTime();",
          "content_same": false
        },
        {
          "line": 2038,
          "old_api": "ToString",
          "new_api": "back",
          "old_text": "addrConnect.ToString()",
          "new_text": "m_anchors.back()",
          "old_line_content": "                LogPrint(BCLog::NET, \"Trying to make an anchor connection to %s\\n\", addrConnect.ToString());",
          "new_line_content": "                const CAddress addr = m_anchors.back();",
          "content_same": false
        },
        {
          "line": 2061,
          "old_api": "AlreadyConnectedToAddress",
          "new_api": "SelectTriedCollision",
          "old_text": "AlreadyConnectedToAddress(addr)",
          "new_text": "addrman.SelectTriedCollision()",
          "old_line_content": "                } else if (AlreadyConnectedToAddress(addr)) {",
          "new_line_content": "                std::tie(addr, addr_last_try) = addrman.SelectTriedCollision();",
          "content_same": false
        },
        {
          "line": 2067,
          "old_api": "Good",
          "new_api": "AlreadyConnectedToAddress",
          "old_text": "addrman.Good(addr)",
          "new_text": "AlreadyConnectedToAddress(addr)",
          "old_line_content": "                    addrman.Good(addr);",
          "new_line_content": "                } else if (AlreadyConnectedToAddress(addr)) {",
          "content_same": false
        },
        {
          "line": 2073,
          "old_api": "Select",
          "new_api": "Good",
          "old_text": "addrman.Select()",
          "new_text": "addrman.Good(addr)",
          "old_line_content": "                std::tie(addr, addr_last_try) = addrman.Select();",
          "new_line_content": "                    addrman.Good(addr);",
          "content_same": false
        },
        {
          "line": 2125,
          "old_api": "std::min(nMaxConnections - 1, 2)",
          "new_api": "GetRandInt",
          "old_text": "std::min(nMaxConnections - 1, 2)",
          "new_text": "GetRandInt(FEELER_SLEEP_WINDOW * 1000)",
          "old_line_content": "            OpenNetworkConnection(addrConnect, (int)setConnected.size() >= std::min(nMaxConnections - 1, 2), &grant, nullptr, conn_type);",
          "new_line_content": "                int randsleep = GetRandInt(FEELER_SLEEP_WINDOW * 1000);",
          "content_same": false
        },
        {
          "line": 2165,
          "old_api": "empty",
          "new_api": "LOCK",
          "old_text": "addrName.empty()",
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "            if (!addrName.empty()) {",
          "new_line_content": "        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2172,
          "old_api": "GetDefaultPort",
          "new_api": "static_cast<const CService&>(pnode->addr)",
          "old_text": "Params().GetDefaultPort(strAddNode)",
          "new_text": "static_cast<const CService&>(pnode->addr)",
          "old_line_content": "        CService service(LookupNumeric(strAddNode, Params().GetDefaultPort(strAddNode)));",
          "new_line_content": "                mapConnectedByName[std::move(addrName)] = std::make_pair(pnode->IsInboundConn(), static_cast<const CService&>(pnode->addr));",
          "content_same": false
        },
        {
          "line": 2191,
          "old_api": "std::move(addedNode)",
          "new_api": "end",
          "old_text": "std::move(addedNode)",
          "new_text": "mapConnectedByName.end()",
          "old_line_content": "        ret.emplace_back(std::move(addedNode));",
          "new_line_content": "            if (it != mapConnectedByName.end()) {",
          "content_same": false
        },
        {
          "line": 2220,
          "old_api": "std::chrono::seconds(tried ? 60 : 2)",
          "new_api": "c_str",
          "old_text": "std::chrono::seconds(tried ? 60 : 2)",
          "new_text": "info.strAddedNode.c_str()",
          "old_line_content": "        if (!interruptNet.sleep_for(std::chrono::seconds(tried ? 60 : 2)))",
          "new_line_content": "                OpenNetworkConnection(addr, false, &grant, info.strAddedNode.c_str(), ConnectionType::MANUAL);",
          "content_same": false
        },
        {
          "line": 2247,
          "old_api": "ConnectNode",
          "new_api": "AlreadyConnectedToAddress",
          "old_text": "ConnectNode(addrConnect, pszDest, fCountFailure, conn_type)",
          "new_text": "AlreadyConnectedToAddress(addrConnect)",
          "old_line_content": "    CNode* pnode = ConnectNode(addrConnect, pszDest, fCountFailure, conn_type);",
          "new_line_content": "        if (IsLocal(addrConnect) || banned_or_discouraged || AlreadyConnectedToAddress(addrConnect)) {",
          "content_same": false
        },
        {
          "line": 2263,
          "old_api": "SetSyscallSandboxPolicy",
          "new_api": "push_back",
          "old_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::MESSAGE_HANDLER)",
          "new_text": "m_nodes.push_back(pnode)",
          "old_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::MESSAGE_HANDLER);",
          "new_line_content": "        m_nodes.push_back(pnode);",
          "content_same": false
        },
        {
          "line": 2285,
          "old_api": "LOCK",
          "new_api": "ProcessMessages",
          "old_text": "LOCK(pnode->cs_sendProcessing)",
          "new_text": "m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc)",
          "old_line_content": "                    LOCK(pnode->cs_sendProcessing);",
          "new_line_content": "                bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);",
          "content_same": false
        },
        {
          "line": 2319,
          "old_api": "sleep_for",
          "new_api": "Listen",
          "old_text": "interruptNet.sleep_for(err_wait)",
          "new_text": "m_i2p_sam_session->Listen(conn)",
          "old_line_content": "            interruptNet.sleep_for(err_wait);",
          "new_line_content": "        if (!m_i2p_sam_session->Listen(conn)) {",
          "content_same": false
        },
        {
          "line": 2357,
          "old_api": "WSAGetLastError",
          "new_api": "LogPrintf",
          "old_text": "WSAGetLastError()",
          "new_text": "LogPrintf(\"%s\\n\", strError.original)",
          "old_line_content": "        strError = strprintf(Untranslated(\"Error: Couldn't open socket for incoming connections (socket returned error %s)\"), NetworkErrorString(WSAGetLastError()));",
          "new_line_content": "        LogPrintf(\"%s\\n\", strError.original);",
          "content_same": false
        },
        {
          "line": 2364,
          "old_api": "Get",
          "new_api": "LogPrintf",
          "old_text": "sock->Get()",
          "new_text": "LogPrintf(\"%s\\n\", strError.original)",
          "old_line_content": "    setsockopt(sock->Get(), SOL_SOCKET, SO_REUSEADDR, (sockopt_arg_type)&nOne, sizeof(int));",
          "new_line_content": "        LogPrintf(\"%s\\n\", strError.original);",
          "content_same": false
        },
        {
          "line": 2374,
          "old_api": "Get",
          "new_api": "IsIPv6",
          "old_text": "sock->Get()",
          "new_text": "addrBind.IsIPv6()",
          "old_line_content": "        setsockopt(sock->Get(), IPPROTO_IPV6, IPV6_PROTECTION_LEVEL, (const char*)&nProtLevel, sizeof(int));",
          "new_line_content": "    if (addrBind.IsIPv6()) {",
          "content_same": false
        },
        {
          "line": 2380,
          "old_api": "WSAGetLastError",
          "new_api": "Get",
          "old_text": "WSAGetLastError()",
          "new_text": "sock->Get()",
          "old_line_content": "        int nErr = WSAGetLastError();",
          "new_line_content": "        setsockopt(sock->Get(), IPPROTO_IPV6, IPV6_PROTECTION_LEVEL, (const char*)&nProtLevel, sizeof(int));",
          "content_same": false
        },
        {
          "line": 2384,
          "old_api": "NetworkErrorString",
          "new_api": "Get",
          "old_text": "NetworkErrorString(nErr)",
          "new_text": "sock->Get()",
          "old_line_content": "            strError = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"), addrBind.ToString(), NetworkErrorString(nErr));",
          "new_line_content": "    if (::bind(sock->Get(), (struct sockaddr*)&sockaddr, len) == SOCKET_ERROR)",
          "content_same": false
        },
        {
          "line": 2391,
          "old_api": "Get",
          "new_api": "LogPrintf",
          "old_text": "sock->Get()",
          "new_text": "LogPrintf(\"%s\\n\", strError.original)",
          "old_line_content": "    if (listen(sock->Get(), SOMAXCONN) == SOCKET_ERROR)",
          "new_line_content": "        LogPrintf(\"%s\\n\", strError.original);",
          "content_same": false
        },
        {
          "line": 2394,
          "old_api": "LogPrintf",
          "new_api": "ToString",
          "old_text": "LogPrintf(\"%s\\n\", strError.original)",
          "new_text": "addrBind.ToString()",
          "old_line_content": "        LogPrintf(\"%s\\n\", strError.original);",
          "new_line_content": "    LogPrintf(\"Bound to %s\\n\", addrBind.ToString());",
          "content_same": false
        },
        {
          "line": 2431,
          "old_api": "strcmp",
          "new_api": "getifaddrs",
          "old_text": "strcmp(ifa->ifa_name, \"lo\")",
          "new_text": "getifaddrs(&myaddrs)",
          "old_line_content": "            if (strcmp(ifa->ifa_name, \"lo\") == 0) continue;",
          "new_line_content": "    if (getifaddrs(&myaddrs) == 0)",
          "content_same": false
        },
        {
          "line": 2437,
          "old_api": "AddLocal",
          "new_api": "strcmp",
          "old_text": "AddLocal(addr, LOCAL_IF)",
          "new_text": "strcmp(ifa->ifa_name, \"lo\")",
          "old_line_content": "                if (AddLocal(addr, LOCAL_IF))",
          "new_line_content": "            if (strcmp(ifa->ifa_name, \"lo\") == 0) continue;",
          "content_same": false
        },
        {
          "line": 2438,
          "old_api": "ToString",
          "new_api": "strcmp",
          "old_text": "addr.ToString()",
          "new_text": "strcmp(ifa->ifa_name, \"lo0\")",
          "old_line_content": "                    LogPrintf(\"%s: IPv4 %s: %s\\n\", __func__, ifa->ifa_name, addr.ToString());",
          "new_line_content": "            if (strcmp(ifa->ifa_name, \"lo0\") == 0) continue;",
          "content_same": false
        },
        {
          "line": 2444,
          "old_api": "AddLocal",
          "new_api": "ToString",
          "old_text": "AddLocal(addr, LOCAL_IF)",
          "new_text": "addr.ToString()",
          "old_line_content": "                if (AddLocal(addr, LOCAL_IF))",
          "new_line_content": "                    LogPrintf(\"%s: IPv4 %s: %s\\n\", __func__, ifa->ifa_name, addr.ToString());",
          "content_same": false
        },
        {
          "line": 2480,
          "old_api": "fetch_add",
          "new_api": "Init",
          "old_text": "nLastNodeId.fetch_add(1, std::memory_order_relaxed)",
          "new_text": "Init(connOptions)",
          "old_line_content": "    return nLastNodeId.fetch_add(1, std::memory_order_relaxed);",
          "new_line_content": "    Init(connOptions);",
          "content_same": false
        },
        {
          "line": 2486,
          "old_api": "MaybeFlipIPv6toCJDNS",
          "new_api": "fetch_add",
          "old_text": "MaybeFlipIPv6toCJDNS(addr_)",
          "new_text": "nLastNodeId.fetch_add(1, std::memory_order_relaxed)",
          "old_line_content": "    const CService addr{MaybeFlipIPv6toCJDNS(addr_)};",
          "new_line_content": "    return nLastNodeId.fetch_add(1, std::memory_order_relaxed);",
          "content_same": false
        },
        {
          "line": 2492,
          "old_api": "BindListenPort",
          "new_api": "MaybeFlipIPv6toCJDNS",
          "old_text": "BindListenPort(addr, strError, permissions)",
          "new_text": "MaybeFlipIPv6toCJDNS(addr_)",
          "old_line_content": "    if (!BindListenPort(addr, strError, permissions)) {",
          "new_line_content": "    const CService addr{MaybeFlipIPv6toCJDNS(addr_)};",
          "content_same": false
        },
        {
          "line": 2494,
          "old_api": "ThreadSafeMessageBox",
          "new_api": "IsReachable",
          "old_text": "m_client_interface->ThreadSafeMessageBox(strError, \"\", CClientUIInterface::MSG_ERROR)",
          "new_text": "IsReachable(addr)",
          "old_line_content": "            m_client_interface->ThreadSafeMessageBox(strError, \"\", CClientUIInterface::MSG_ERROR);",
          "new_line_content": "    if (!(flags & BF_EXPLICIT) && !IsReachable(addr)) {",
          "content_same": false
        },
        {
          "line": 2500,
          "old_api": "AddLocal",
          "new_api": "ThreadSafeMessageBox",
          "old_text": "AddLocal(addr, LOCAL_BIND)",
          "new_text": "m_client_interface->ThreadSafeMessageBox(strError, \"\", CClientUIInterface::MSG_ERROR)",
          "old_line_content": "        AddLocal(addr, LOCAL_BIND);",
          "new_line_content": "            m_client_interface->ThreadSafeMessageBox(strError, \"\", CClientUIInterface::MSG_ERROR);",
          "content_same": false
        },
        {
          "line": 2522,
          "old_api": "GetListenPort",
          "new_api": "Bind",
          "old_text": "GetListenPort()",
          "new_text": "Bind(addr_bind, BF_EXPLICIT | BF_DONT_ADVERTISE, NetPermissionFlags::None)",
          "old_line_content": "        fBound |= Bind(CService(inaddr6_any, GetListenPort()), BF_NONE, NetPermissionFlags::None);",
          "new_line_content": "        fBound |= Bind(addr_bind, BF_EXPLICIT | BF_DONT_ADVERTISE, NetPermissionFlags::None);",
          "content_same": false
        },
        {
          "line": 2548,
          "old_api": "AddAddrFetch",
          "new_api": "GetProxy",
          "old_text": "AddAddrFetch(strDest)",
          "new_text": "GetProxy(NET_I2P, i2p_sam)",
          "old_line_content": "        AddAddrFetch(strDest);",
          "new_line_content": "    if (GetProxy(NET_I2P, i2p_sam)) {",
          "content_same": false
        },
        {
          "line": 2554,
          "old_api": "size",
          "new_api": "AddAddrFetch",
          "old_text": "m_anchors.size()",
          "new_text": "AddAddrFetch(strDest)",
          "old_line_content": "        if (m_anchors.size() > MAX_BLOCK_RELAY_ONLY_ANCHORS) {",
          "new_line_content": "        AddAddrFetch(strDest);",
          "content_same": false
        },
        {
          "line": 2561,
          "old_api": "_",
          "new_api": "resize",
          "old_text": "_(\"Starting network threads…\").t",
          "new_text": "m_anchors.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS)",
          "old_line_content": "        m_client_interface->InitMessage(_(\"Starting network threads…\").translated);",
          "new_line_content": "            m_anchors.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);",
          "content_same": false
        },
        {
          "line": 2578,
          "old_api": "sert",
          "new_api": "d::make_unique<CSemaphore>(nMaxAddnode);",
          "old_text": "sert(m_msgproc);\n",
          "new_text": "d::make_unique<CSemaphore>(nMaxAddnode);\n",
          "old_line_content": "    assert(m_msgproc);",
          "new_line_content": "        semAddnode = std::make_unique<CSemaphore>(nMaxAddnode);",
          "content_same": false
        },
        {
          "line": 2584,
          "old_api": "CK",
          "new_api": "sert",
          "old_text": "CK(mutexMsgProc);\n",
          "new_text": "sert(m_msgproc);\n",
          "old_line_content": "        LOCK(mutexMsgProc);",
          "new_line_content": "    assert(m_msgproc);",
          "content_same": false
        },
        {
          "line": 2597,
          "old_api": "readOpenAddedConnections",
          "new_api": "GetBoolArg",
          "old_text": "readOpenAddedConnections(); ",
          "new_text": "rgs.GetBoolArg(\"-dnsseed\", DEFAULT_DNSSEED))\n",
          "old_line_content": "    threadOpenAddedConnections = std::thread(&util::TraceThread, \"addcon\", [this] { ThreadOpenAddedConnections(); });",
          "new_line_content": "    if (!gArgs.GetBoolArg(\"-dnsseed\", DEFAULT_DNSSEED))",
          "content_same": false
        },
        {
          "line": 2607,
          "old_api": "empty",
          "new_api": "ThreadSafeMessageBox",
          "old_text": "nnOptions.m_specified_outgoing.empty()) ",
          "new_text": "client_interface->ThreadSafeMessageBox(\n                _(\"Cannot provide specific connections and have addrman find outgoing connections at the same.\"),\n                \"\", CClientUIInterface::MSG_ERROR);\n",
          "old_line_content": "    if (connOptions.m_use_addrman_outgoing || !connOptions.m_specified_outgoing.empty()) {",
          "new_line_content": "            m_client_interface->ThreadSafeMessageBox(",
          "content_same": false
        },
        {
          "line": 2608,
          "old_api": "d::thread(\n            &util::TraceThread, \"opencon\",\n            [this, connect = connOptions.m_specified_outgoing] { ThreadOpenConnections(connect); });",
          "new_api": "\"Cannot provide specific connections and have addrman find outgoing connections at the same.\"),",
          "old_text": "d::thread(\n            &util::TraceThread, \"opencon\",\n            [this, connect = connOptions.m_specified_outgoing] { ThreadOpenConnections(connect); });\n",
          "new_text": "\"Cannot provide specific connections and have addrman find outgoing connections at the same.\"),\n",
          "old_line_content": "        threadOpenConnections = std::thread(",
          "new_line_content": "                _(\"Cannot provide specific connections and have addrman find outgoing connections at the same.\"),",
          "content_same": false
        },
        {
          "line": 2614,
          "old_api": "readMessageHandler",
          "new_api": "d::thread(\n            &util::TraceThread, \"opencon\",\n            [this, connect = connOptions.m_specified_outgoing] { ThreadOpenConnections(connect); });",
          "old_text": "readMessageHandler(); ",
          "new_text": "d::thread(\n            &util::TraceThread, \"opencon\",\n            [this, connect = connOptions.m_specified_outgoing] { ThreadOpenConnections(connect); });\n",
          "old_line_content": "    threadMessageHandler = std::thread(&util::TraceThread, \"msghand\", [this] { ThreadMessageHandler(); });",
          "new_line_content": "        threadOpenConnections = std::thread(",
          "content_same": false
        },
        {
          "line": 2616,
          "old_api": "get",
          "new_api": "readOpenConnections",
          "old_text": "i2p_sam_session.get() !",
          "new_text": "readOpenConnections(connect); ",
          "old_line_content": "    if (connOptions.m_i2p_accept_incoming && m_i2p_sam_session.get() != nullptr) {",
          "new_line_content": "            [this, connect = connOptions.m_specified_outgoing] { ThreadOpenConnections(connect); });",
          "content_same": false
        },
        {
          "line": 2622,
          "old_api": "mpAddresses",
          "new_api": "get",
          "old_text": "mpAddresses(); ",
          "new_text": "i2p_sam_session.get() !",
          "old_line_content": "    scheduler.scheduleEvery([this] { DumpAddresses(); }, DUMP_PEERS_INTERVAL);",
          "new_line_content": "    if (connOptions.m_i2p_accept_incoming && m_i2p_sam_session.get() != nullptr) {",
          "content_same": false
        },
        {
          "line": 2651,
          "old_api": "terruptSocks5",
          "new_api": "CK",
          "old_text": "terruptSocks5(true);\n",
          "new_text": "CK(mutexMsgProc);\n",
          "old_line_content": "    InterruptSocks5(true);",
          "new_line_content": "        LOCK(mutexMsgProc);",
          "content_same": false
        },
        {
          "line": 2674,
          "old_api": "join",
          "new_api": "joinable",
          "old_text": "readOpenConnections.join();\n",
          "new_text": "readI2PAcceptIncoming.joinable()) ",
          "old_line_content": "        threadOpenConnections.join();",
          "new_line_content": "    if (threadI2PAcceptIncoming.joinable()) {",
          "content_same": false
        },
        {
          "line": 2675,
          "old_api": "joinable",
          "new_api": "join",
          "old_text": "readOpenAddedConnections.joinable())\n",
          "new_text": "readI2PAcceptIncoming.join();\n",
          "old_line_content": "    if (threadOpenAddedConnections.joinable())",
          "new_line_content": "        threadI2PAcceptIncoming.join();",
          "content_same": false
        },
        {
          "line": 2686,
          "old_api": "mpAddresses",
          "new_api": "join",
          "old_text": "mpAddresses();\n",
          "new_text": "readSocketHandler.join();\n",
          "old_line_content": "        DumpAddresses();",
          "new_line_content": "        threadSocketHandler.join();",
          "content_same": false
        },
        {
          "line": 2692,
          "old_api": "size",
          "new_api": "mpAddresses",
          "old_text": "chors_to_dump.size() >",
          "new_text": "mpAddresses();\n",
          "old_line_content": "            if (anchors_to_dump.size() > MAX_BLOCK_RELAY_ONLY_ANCHORS) {",
          "new_line_content": "        DumpAddresses();",
          "content_same": false
        },
        {
          "line": 2701,
          "old_api": "swap",
          "new_api": "GetDataDirNet",
          "old_text": "des.swap(m_nodes));",
          "new_text": "rgs.GetDataDirNet() /",
          "old_line_content": "    WITH_LOCK(m_nodes_mutex, nodes.swap(m_nodes));",
          "new_line_content": "            DumpAnchors(gArgs.GetDataDirNet() / ANCHORS_DATABASE_FILENAME, anchors_to_dump);",
          "content_same": false
        },
        {
          "line": 2710,
          "old_api": "clear",
          "new_api": "leteNode",
          "old_text": "nodes_disconnected.clear();\n",
          "new_text": "leteNode(pnode);\n",
          "old_line_content": "    m_nodes_disconnected.clear();",
          "new_line_content": "        DeleteNode(pnode);",
          "content_same": false
        },
        {
          "line": 2718,
          "old_api": "sert",
          "new_api": "reset",
          "old_text": "sert(pnode);\n",
          "new_text": "mOutbound.reset();\n",
          "old_line_content": "    assert(pnode);",
          "new_line_content": "    semOutbound.reset();",
          "content_same": false
        },
        {
          "line": 2719,
          "old_api": "FinalizeNode",
          "new_api": "reset",
          "old_text": "msgproc->FinalizeNode(*pnode);\n",
          "new_text": "mAddnode.reset();\n",
          "old_line_content": "    m_msgproc->FinalizeNode(*pnode);",
          "new_line_content": "    semAddnode.reset();",
          "content_same": false
        },
        {
          "line": 2725,
          "old_api": "terrupt",
          "new_api": "FinalizeNode",
          "old_text": "terrupt();\n",
          "new_text": "msgproc->FinalizeNode(*pnode);\n",
          "old_line_content": "    Interrupt();",
          "new_line_content": "    m_msgproc->FinalizeNode(*pnode);",
          "content_same": false
        },
        {
          "line": 2731,
          "old_api": "GetAddr",
          "new_api": "terrupt",
          "old_text": "drman.GetAddr(max_addresses, max_pct, network);\n",
          "new_text": "terrupt();\n",
          "old_line_content": "    std::vector<CAddress> addresses = addrman.GetAddr(max_addresses, max_pct, network);",
          "new_line_content": "    Interrupt();",
          "content_same": false
        },
        {
          "line": 2748,
          "old_api": "emplace",
          "new_api": "GetAddrBytes",
          "old_text": "addr_response_caches.emplace(cache_id, CachedAddrResponse{});\n",
          "new_text": "questor.addrBind.GetAddrBytes();\n",
          "old_line_content": "    auto r = m_addr_response_caches.emplace(cache_id, CachedAddrResponse{});",
          "new_line_content": "    auto local_socket_bytes = requestor.addrBind.GetAddrBytes();",
          "content_same": false
        },
        {
          "line": 2751,
          "old_api": "tAddresses",
          "new_api": "size",
          "old_text": "tAddresses(max_addresses, max_pct, /* network */ std::nullopt);\n",
          "new_text": "cal_socket_bytes.size())\n",
          "old_line_content": "        cache_entry.m_addrs_response_cache = GetAddresses(max_addresses, max_pct, /* network */ std::nullopt);",
          "new_line_content": "        .Write(local_socket_bytes.data(), local_socket_bytes.size())",
          "content_same": false
        },
        {
          "line": 2794,
          "old_api": "CK",
          "new_api": "push_back",
          "old_text": "CK(m_added_nodes_mutex);\n",
          "new_text": "added_nodes.push_back(strNode);\n",
          "old_line_content": "    LOCK(m_added_nodes_mutex);",
          "new_line_content": "    m_added_nodes.push_back(strNode);",
          "content_same": false
        },
        {
          "line": 2812,
          "old_api": "IsInboundConn",
          "new_api": "CK",
          "old_text": "ode->IsInboundConn() ?",
          "new_text": "CK(m_nodes_mutex);\n",
          "old_line_content": "        if (flags & (pnode->IsInboundConn() ? ConnectionDirection::In : ConnectionDirection::Out)) {",
          "new_line_content": "    LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2828,
          "old_api": "GetAsmap",
          "new_api": "clear",
          "old_text": "drman.GetAsmap());",
          "new_text": "tats.clear();\n",
          "old_line_content": "        vstats.back().m_mapped_as = pnode->addr.GetMappedAS(addrman.GetAsmap());",
          "new_line_content": "    vstats.clear();",
          "content_same": false
        },
        {
          "line": 2834,
          "old_api": "CK",
          "new_api": "GetAsmap",
          "old_text": "CK(m_nodes_mutex);\n",
          "new_text": "drman.GetAsmap());",
          "old_line_content": "    LOCK(m_nodes_mutex);",
          "new_line_content": "        vstats.back().m_mapped_as = pnode->addr.GetMappedAS(addrman.GetAsmap());",
          "content_same": false
        },
        {
          "line": 2923,
          "old_api": "CK",
          "new_api": "tTime<std::chrono::seconds>();",
          "old_text": "CK(cs_totalBytesSent);\n",
          "new_text": "tTime<std::chrono::seconds>();\n",
          "old_line_content": "    LOCK(cs_totalBytesSent);",
          "new_line_content": "    const auto now = GetTime<std::chrono::seconds>();",
          "content_same": false
        },
        {
          "line": 2997,
          "old_api": "TransportSerializer",
          "new_api": "gPrint",
          "old_text": "TransportSerializer());",
          "new_text": "gPrint(BCLog::NET, \"Added connection to %s peer=%d\\n\", m_addr_name, id);\n",
          "old_line_content": "    m_serializer = std::make_unique<V1TransportSerializer>(V1TransportSerializer());",
          "new_line_content": "        LogPrint(BCLog::NET, \"Added connection to %s peer=%d\\n\", m_addr_name, id);",
          "content_same": false
        },
        {
          "line": 3013,
          "old_api": "c_str",
          "new_api": "size",
          "old_text": "ACE6(net, outbound_message,\n        pnode->GetId(),\n        pnode->m_addr_name.c_str(),\n        pnode->ConnectionTypeAsString().c_str(),\n        msg.m_type.c_str(),\n        msg.data.size(),\n        msg.data.data()\n    );\n",
          "new_text": "g.data.size();\n",
          "old_line_content": "    TRACE6(net, outbound_message,",
          "new_line_content": "    size_t nMessageSize = msg.data.size();",
          "content_same": false
        },
        {
          "line": 3015,
          "old_api": "c_str",
          "new_api": "GetBoolArg",
          "old_text": "ode->m_addr_name.c_str(),\n",
          "new_text": "rgs.GetBoolArg(\"-capturemessages\", false)) ",
          "old_line_content": "        pnode->m_addr_name.c_str(),",
          "new_line_content": "    if (gArgs.GetBoolArg(\"-capturemessages\", false)) {",
          "content_same": false
        },
        {
          "line": 3016,
          "old_api": "c_str",
          "new_api": "ptureMessage",
          "old_text": "ode->ConnectionTypeAsString().c_str(),\n",
          "new_text": "ptureMessage(pnode->addr, msg.m_type, msg.data, /*is_incoming=*/false);\n",
          "old_line_content": "        pnode->ConnectionTypeAsString().c_str(),",
          "new_line_content": "        CaptureMessage(pnode->addr, msg.m_type, msg.data, /*is_incoming=*/false);",
          "content_same": false
        },
        {
          "line": 3019,
          "old_api": "data",
          "new_api": "c_str",
          "old_text": "g.data.data()\n ",
          "new_text": "ACE6(net, outbound_message,\n        pnode->GetId(),\n        pnode->m_addr_name.c_str(),\n        pnode->ConnectionTypeAsString().c_str(),\n        msg.m_type.c_str(),\n        msg.data.size(),\n        msg.data.data()\n    );\n",
          "old_line_content": "        msg.data.data()",
          "new_line_content": "    TRACE6(net, outbound_message,",
          "content_same": false
        },
        {
          "line": 3024,
          "old_api": "prepareForTransport",
          "new_api": "size",
          "old_text": "ode->m_serializer->prepareForTransport(msg, serializedHeader);\n",
          "new_text": "g.data.size(),\n",
          "old_line_content": "    pnode->m_serializer->prepareForTransport(msg, serializedHeader);",
          "new_line_content": "        msg.data.size(),",
          "content_same": false
        },
        {
          "line": 3025,
          "old_api": "size",
          "new_api": "data",
          "old_text": "rializedHeader.size();\n",
          "new_text": "g.data.data()\n ",
          "old_line_content": "    size_t nTotalSize = nMessageSize + serializedHeader.size();",
          "new_line_content": "        msg.data.data()",
          "content_same": false
        },
        {
          "line": 3030,
          "old_api": "empty",
          "new_api": "prepareForTransport",
          "old_text": "ode->vSendMsg.empty());",
          "new_text": "ode->m_serializer->prepareForTransport(msg, serializedHeader);\n",
          "old_line_content": "        bool optimisticSend(pnode->vSendMsg.empty());",
          "new_line_content": "    pnode->m_serializer->prepareForTransport(msg, serializedHeader);",
          "content_same": false
        },
        {
          "line": 3043,
          "old_api": "cordBytesSent",
          "new_api": "d::move(serializedHeader));",
          "old_text": "cordBytesSent(nBytesSent);\n",
          "new_text": "d::move(serializedHeader));",
          "old_line_content": "    if (nBytesSent) RecordBytesSent(nBytesSent);",
          "new_line_content": "        pnode->vSendMsg.push_back(std::move(serializedHeader));",
          "content_same": false
        },
        {
          "line": 3049,
          "old_api": "CK",
          "new_api": "cordBytesSent",
          "old_text": "CK(m_nodes_mutex);\n",
          "new_text": "cordBytesSent(nBytesSent);\n",
          "old_line_content": "    LOCK(m_nodes_mutex);",
          "new_line_content": "    if (nBytesSent) RecordBytesSent(nBytesSent);",
          "content_same": false
        },
        {
          "line": 3078,
          "old_api": "Write",
          "new_api": "tRand",
          "old_text": "ipHasher(nSeed0, nSeed1).Write(id);\n",
          "new_text": "tRand(1ULL << 48) *",
          "old_line_content": "    return CSipHasher(nSeed0, nSeed1).Write(id);",
          "new_line_content": "    double unscaled = -log1p(GetRand(1ULL << 48) * -0.0000000000000035527136788 /* -1/2^48 */);",
          "content_same": false
        },
        {
          "line": 3100,
          "old_api": "GetDataDirNet",
          "new_api": "tTime<std::chrono::microseconds>();",
          "old_text": "rgs.GetDataDirNet() /",
          "new_text": "tTime<std::chrono::microseconds>();\n",
          "old_line_content": "    fs::path base_path = gArgs.GetDataDirNet() / \"message_capture\" / clean_addr;",
          "new_line_content": "    auto now = GetTime<std::chrono::microseconds>();",
          "content_same": false
        },
        {
          "line": 3104,
          "old_api": "bridge::fopen(path, \"ab\"),",
          "new_api": "end",
          "old_text": "bridge::fopen(path, \"ab\"), ",
          "new_text": "ean_addr.end(), ",
          "old_line_content": "    CAutoFile f(fsbridge::fopen(path, \"ab\"), SER_DISK, CLIENT_VERSION);",
          "new_line_content": "    std::replace(clean_addr.begin(), clean_addr.end(), ':', '_');",
          "content_same": false
        },
        {
          "line": 3106,
          "old_api": "count",
          "new_api": "GetDataDirNet",
          "old_text": "w.count());",
          "new_text": "rgs.GetDataDirNet() /",
          "old_line_content": "    ser_writedata64(f, now.count());",
          "new_line_content": "    fs::path base_path = gArgs.GetDataDirNet() / \"message_capture\" / clean_addr;",
          "content_same": false
        },
        {
          "line": 3107,
          "old_api": "length",
          "new_api": "::create_directories(base_path);",
          "old_text": "g_type.length());",
          "new_text": "::create_directories(base_path);\n",
          "old_line_content": "    f.write(msg_type.data(), msg_type.length());",
          "new_line_content": "    fs::create_directories(base_path);",
          "content_same": false
        },
        {
          "line": 3112,
          "old_api": "r_writedata32",
          "new_api": "count",
          "old_text": "r_writedata32(f, size);\n",
          "new_text": "w.count());",
          "old_line_content": "    ser_writedata32(f, size);",
          "new_line_content": "    ser_writedata64(f, now.count());",
          "content_same": false
        },
        {
          "line": 3113,
          "old_api": "size",
          "new_api": "length",
          "old_text": "ta.size());",
          "new_text": "g_type.length());",
          "old_line_content": "    f.write((const char*)data.data(), data.size());",
          "new_line_content": "    f.write(msg_type.data(), msg_type.length());",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2063,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "addr.IsValid()",
          "old_line_content": "                    // peer that we're already connected to, just mark that",
          "new_line_content": "                if (!addr.IsValid()) {",
          "content_same": false
        },
        {
          "line": 2066,
          "old_api": null,
          "new_api": "Select",
          "old_text": null,
          "new_text": "addrman.Select(true)",
          "old_line_content": "                    // a currently-connected peer.",
          "new_line_content": "                    std::tie(addr, addr_last_try) = addrman.Select(true);",
          "content_same": false
        },
        {
          "line": 2075,
          "old_api": null,
          "new_api": "Select",
          "old_text": null,
          "new_text": "addrman.Select(true)",
          "old_line_content": "",
          "new_line_content": "                    std::tie(addr, addr_last_try) = addrman.Select(true);",
          "content_same": false
        },
        {
          "line": 2079,
          "old_api": null,
          "new_api": "Select",
          "old_text": null,
          "new_text": "addrman.Select()",
          "old_line_content": "            }",
          "new_line_content": "                std::tie(addr, addr_last_try) = addrman.Select();",
          "content_same": false
        },
        {
          "line": 2083,
          "old_api": null,
          "new_api": "GetAsmap",
          "old_text": null,
          "new_text": "addrman.GetAsmap()",
          "old_line_content": "                break;",
          "new_line_content": "            if (!fFeeler && setConnected.count(addr.GetGroup(addrman.GetAsmap()))) {",
          "content_same": false
        },
        {
          "line": 2088,
          "old_api": null,
          "new_api": "IsLocal",
          "old_text": null,
          "new_text": "IsLocal(addr)",
          "old_line_content": "",
          "new_line_content": "            if (!addr.IsValid() || IsLocal(addr)) {",
          "content_same": false
        },
        {
          "line": 2092,
          "old_api": null,
          "new_api": "IsReachable",
          "old_text": null,
          "new_text": "IsReachable(addr)",
          "old_line_content": "",
          "new_line_content": "            if (!IsReachable(addr))",
          "content_same": false
        },
        {
          "line": 2102,
          "old_api": null,
          "new_api": "HasAllDesirableServiceFlags",
          "old_text": null,
          "new_text": "HasAllDesirableServiceFlags(addr.nServices)",
          "old_line_content": "            // Do not allow non-default ports, unless after 50 invalid",
          "new_line_content": "            if (!fFeeler && !HasAllDesirableServiceFlags(addr.nServices)) {",
          "content_same": false
        },
        {
          "line": 2104,
          "old_api": null,
          "new_api": "MayHaveUsefulAddressDB",
          "old_text": null,
          "new_text": "MayHaveUsefulAddressDB(addr.nServices)",
          "old_line_content": "            // from advertising themselves as a service on another host and",
          "new_line_content": "            } else if (fFeeler && !MayHaveUsefulAddressDB(addr.nServices)) {",
          "content_same": false
        },
        {
          "line": 2113,
          "old_api": null,
          "new_api": "GetNetwork",
          "old_text": null,
          "new_text": "addr.GetNetwork()",
          "old_line_content": "        }",
          "new_line_content": "            if (addr.GetPort() != Params().GetDefaultPort(addr.GetNetwork()) && nTries < 50) {",
          "content_same": false
        },
        {
          "line": 2121,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "addrConnect.IsValid()",
          "old_line_content": "                    return;",
          "new_line_content": "        if (addrConnect.IsValid()) {",
          "content_same": false
        },
        {
          "line": 2126,
          "old_api": null,
          "new_api": "std::chrono::milliseconds(randsleep)",
          "old_text": null,
          "new_text": "std::chrono::milliseconds(randsleep)",
          "old_line_content": "        }",
          "new_line_content": "                if (!interruptNet.sleep_for(std::chrono::milliseconds(randsleep)))",
          "content_same": false
        },
        {
          "line": 2128,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "addrConnect.ToString()",
          "old_line_content": "}",
          "new_line_content": "                LogPrint(BCLog::NET, \"Making feeler connection to %s\\n\", addrConnect.ToString());",
          "content_same": false
        },
        {
          "line": 2131,
          "old_api": null,
          "new_api": "std::min(nMaxConnections - 1, 2)",
          "old_text": null,
          "new_text": "std::min(nMaxConnections - 1, 2)",
          "old_line_content": "{",
          "new_line_content": "            OpenNetworkConnection(addrConnect, (int)setConnected.size() >= std::min(nMaxConnections - 1, 2), &grant, nullptr, conn_type);",
          "content_same": false
        },
        {
          "line": 2139,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "",
          "new_line_content": "    LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2141,
          "old_api": null,
          "new_api": "IsBlockOnlyConn",
          "old_text": null,
          "new_text": "pnode->IsBlockOnlyConn()",
          "old_line_content": "}",
          "new_line_content": "        if (pnode->IsBlockOnlyConn()) {",
          "content_same": false
        },
        {
          "line": 2142,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "ret.push_back(pnode->addr)",
          "old_line_content": "",
          "new_line_content": "            ret.push_back(pnode->addr);",
          "content_same": false
        },
        {
          "line": 2155,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_added_nodes_mutex)",
          "old_line_content": "    // Build a map of all already connected addresses (by IP:port and by name) to inbound/outbound and resolved CService",
          "new_line_content": "        LOCK(m_added_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2156,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "m_added_nodes.size()",
          "old_line_content": "    std::map<CService, bool> mapConnected;",
          "new_line_content": "        ret.reserve(m_added_nodes.size());",
          "content_same": false
        },
        {
          "line": 2157,
          "old_api": null,
          "new_api": "std::back_inserter(lAddresses)",
          "old_text": null,
          "new_text": "std::back_inserter(lAddresses)",
          "old_line_content": "    std::map<std::string, std::pair<bool, CService>> mapConnectedByName;",
          "new_line_content": "        std::copy(m_added_nodes.cbegin(), m_added_nodes.cend(), std::back_inserter(lAddresses));",
          "content_same": false
        },
        {
          "line": 2167,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "pnode->addr.IsValid()",
          "old_line_content": "            }",
          "new_line_content": "            if (pnode->addr.IsValid()) {",
          "content_same": false
        },
        {
          "line": 2168,
          "old_api": null,
          "new_api": "IsInboundConn",
          "old_text": null,
          "new_text": "pnode->IsInboundConn()",
          "old_line_content": "        }",
          "new_line_content": "                mapConnected[pnode->addr] = pnode->IsInboundConn();",
          "content_same": false
        },
        {
          "line": 2171,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "addrName.empty()",
          "old_line_content": "    for (const std::string& strAddNode : lAddresses) {",
          "new_line_content": "            if (!addrName.empty()) {",
          "content_same": false
        },
        {
          "line": 2178,
          "old_api": null,
          "new_api": "GetDefaultPort",
          "old_text": null,
          "new_text": "Params().GetDefaultPort(strAddNode)",
          "old_line_content": "                addedNode.resolvedAddress = service;",
          "new_line_content": "        CService service(LookupNumeric(strAddNode, Params().GetDefaultPort(strAddNode)));",
          "content_same": false
        },
        {
          "line": 2179,
          "old_api": null,
          "new_api": "CService",
          "old_text": null,
          "new_text": "CService()",
          "old_line_content": "                addedNode.fConnected = true;",
          "new_line_content": "        AddedNodeInfo addedNode{strAddNode, CService(), false, false};",
          "content_same": false
        },
        {
          "line": 2180,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "service.IsValid()",
          "old_line_content": "                addedNode.fInbound = it->second;",
          "new_line_content": "        if (service.IsValid()) {",
          "content_same": false
        },
        {
          "line": 2182,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "mapConnected.find(service)",
          "old_line_content": "        } else {",
          "new_line_content": "            auto it = mapConnected.find(service);",
          "content_same": false
        },
        {
          "line": 2183,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapConnected.end()",
          "old_line_content": "            // strAddNode is a name",
          "new_line_content": "            if (it != mapConnected.end()) {",
          "content_same": false
        },
        {
          "line": 2190,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "mapConnectedByName.find(strAddNode)",
          "old_line_content": "        }",
          "new_line_content": "            auto it = mapConnectedByName.find(strAddNode);",
          "content_same": false
        },
        {
          "line": 2197,
          "old_api": null,
          "new_api": "std::move(addedNode)",
          "old_text": null,
          "new_text": "std::move(addedNode)",
          "old_line_content": "void CConnman::ThreadOpenAddedConnections()",
          "new_line_content": "        ret.emplace_back(std::move(addedNode));",
          "content_same": false
        },
        {
          "line": 2205,
          "old_api": null,
          "new_api": "SetSyscallSandboxPolicy",
          "old_text": null,
          "new_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET_ADD_CONNECTION)",
          "old_line_content": "        for (const AddedNodeInfo& info : vInfo) {",
          "new_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET_ADD_CONNECTION);",
          "content_same": false
        },
        {
          "line": 2209,
          "old_api": null,
          "new_api": "GetAddedNodeInfo",
          "old_text": null,
          "new_text": "GetAddedNodeInfo()",
          "old_line_content": "                    // the addednodeinfo state might change.",
          "new_line_content": "        std::vector<AddedNodeInfo> vInfo = GetAddedNodeInfo();",
          "content_same": false
        },
        {
          "line": 2213,
          "old_api": null,
          "new_api": "TryAcquire",
          "old_text": null,
          "new_text": "grant.TryAcquire()",
          "old_line_content": "                CAddress addr(CService(), NODE_NONE);",
          "new_line_content": "                if (!grant.TryAcquire()) {",
          "content_same": false
        },
        {
          "line": 2221,
          "old_api": null,
          "new_api": "std::chrono::milliseconds(500)",
          "old_text": null,
          "new_text": "std::chrono::milliseconds(500)",
          "old_line_content": "            return;",
          "new_line_content": "                if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))",
          "content_same": false
        },
        {
          "line": 2226,
          "old_api": null,
          "new_api": "std::chrono::seconds(tried ? 60 : 2)",
          "old_text": null,
          "new_text": "std::chrono::seconds(tried ? 60 : 2)",
          "old_line_content": "void CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, ConnectionType conn_type)",
          "new_line_content": "        if (!interruptNet.sleep_for(std::chrono::seconds(tried ? 60 : 2)))",
          "content_same": false
        },
        {
          "line": 2234,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(conn_type != ConnectionType::INBOUND)",
          "old_line_content": "        return;",
          "new_line_content": "    assert(conn_type != ConnectionType::INBOUND);",
          "content_same": false
        },
        {
          "line": 2246,
          "old_api": null,
          "new_api": "IsBanned",
          "old_text": null,
          "new_text": "m_banman->IsBanned(addrConnect)",
          "old_line_content": "",
          "new_line_content": "        bool banned_or_discouraged = m_banman && (m_banman->IsDiscouraged(addrConnect) || m_banman->IsBanned(addrConnect));",
          "content_same": false
        },
        {
          "line": 2250,
          "old_api": null,
          "new_api": "std::string(pszDest)",
          "old_text": null,
          "new_text": "std::string(pszDest)",
          "old_line_content": "        return;",
          "new_line_content": "    } else if (FindNode(std::string(pszDest)))",
          "content_same": false
        },
        {
          "line": 2253,
          "old_api": null,
          "new_api": "ConnectNode",
          "old_text": null,
          "new_text": "ConnectNode(addrConnect, pszDest, fCountFailure, conn_type)",
          "old_line_content": "",
          "new_line_content": "    CNode* pnode = ConnectNode(addrConnect, pszDest, fCountFailure, conn_type);",
          "content_same": false
        },
        {
          "line": 2258,
          "old_api": null,
          "new_api": "MoveTo",
          "old_text": null,
          "new_text": "grantOutbound->MoveTo(pnode->grantOutbound)",
          "old_line_content": "    }",
          "new_line_content": "        grantOutbound->MoveTo(pnode->grantOutbound);",
          "content_same": false
        },
        {
          "line": 2260,
          "old_api": null,
          "new_api": "InitializeNode",
          "old_text": null,
          "new_text": "m_msgproc->InitializeNode(pnode)",
          "old_line_content": "",
          "new_line_content": "    m_msgproc->InitializeNode(pnode);",
          "content_same": false
        },
        {
          "line": 2262,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "{",
          "new_line_content": "        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2269,
          "old_api": null,
          "new_api": "SetSyscallSandboxPolicy",
          "old_text": null,
          "new_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::MESSAGE_HANDLER)",
          "old_line_content": "            // Randomize the order in which we process messages from/to our peers.",
          "new_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::MESSAGE_HANDLER);",
          "content_same": false
        },
        {
          "line": 2280,
          "old_api": null,
          "new_api": "Nodes",
          "old_text": null,
          "new_text": "snap.Nodes()",
          "old_line_content": "                fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend);",
          "new_line_content": "            for (CNode* pnode : snap.Nodes()) {",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pnode->cs_sendProcessing)",
          "old_line_content": "            }",
          "new_line_content": "                    LOCK(pnode->cs_sendProcessing);",
          "content_same": false
        },
        {
          "line": 2292,
          "old_api": null,
          "new_api": "SendMessages",
          "old_text": null,
          "new_text": "m_msgproc->SendMessages(pnode)",
          "old_line_content": "        }",
          "new_line_content": "                    m_msgproc->SendMessages(pnode);",
          "content_same": false
        },
        {
          "line": 2300,
          "old_api": null,
          "new_api": "WAIT_LOCK",
          "old_text": null,
          "new_text": "WAIT_LOCK(mutexMsgProc, lock)",
          "old_line_content": "}",
          "new_line_content": "        WAIT_LOCK(mutexMsgProc, lock);",
          "content_same": false
        },
        {
          "line": 2302,
          "old_api": null,
          "new_api": "std::chrono::milliseconds(100)",
          "old_text": null,
          "new_text": "std::chrono::milliseconds(100)",
          "old_line_content": "void CConnman::ThreadI2PAcceptIncoming()",
          "new_line_content": "            condMsgProc.wait_until(lock, std::chrono::steady_clock::now() + std::chrono::milliseconds(100), [this]() EXCLUSIVE_LOCKS_REQUIRED(mutexMsgProc) { return fMsgProcWake; });",
          "content_same": false
        },
        {
          "line": 2310,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "",
          "new_line_content": "    static constexpr auto err_wait_begin = 1s;",
          "content_same": false
        },
        {
          "line": 2311,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "    while (!interruptNet) {",
          "new_line_content": "    static constexpr auto err_wait_cap = 5min;",
          "content_same": false
        },
        {
          "line": 2320,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "conn.me.IsValid()",
          "old_line_content": "            if (err_wait < err_wait_cap) {",
          "new_line_content": "            if (advertising_listen_addr && conn.me.IsValid()) {",
          "content_same": false
        },
        {
          "line": 2321,
          "old_api": null,
          "new_api": "RemoveLocal",
          "old_text": null,
          "new_text": "RemoveLocal(conn.me)",
          "old_line_content": "                err_wait *= 2;",
          "new_line_content": "                RemoveLocal(conn.me);",
          "content_same": false
        },
        {
          "line": 2325,
          "old_api": null,
          "new_api": "sleep_for",
          "old_text": null,
          "new_text": "interruptNet.sleep_for(err_wait)",
          "old_line_content": "        }",
          "new_line_content": "            interruptNet.sleep_for(err_wait);",
          "content_same": false
        },
        {
          "line": 2334,
          "old_api": null,
          "new_api": "AddLocal",
          "old_text": null,
          "new_text": "AddLocal(conn.me, LOCAL_MANUAL)",
          "old_line_content": "        }",
          "new_line_content": "            AddLocal(conn.me, LOCAL_MANUAL);",
          "content_same": false
        },
        {
          "line": 2338,
          "old_api": null,
          "new_api": "Accept",
          "old_text": null,
          "new_text": "m_i2p_sam_session->Accept(conn)",
          "old_line_content": "    }",
          "new_line_content": "        if (!m_i2p_sam_session->Accept(conn)) {",
          "content_same": false
        },
        {
          "line": 2342,
          "old_api": null,
          "new_api": "std::move(conn.sock)",
          "old_text": null,
          "new_text": "std::move(conn.sock)",
          "old_line_content": "{",
          "new_line_content": "        CreateNodeFromAcceptedSocket(std::move(conn.sock), NetPermissionFlags::None,",
          "content_same": false
        },
        {
          "line": 2354,
          "old_api": null,
          "new_api": "GetSockAddr",
          "old_text": null,
          "new_text": "addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len)",
          "old_line_content": "",
          "new_line_content": "    if (!addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len))",
          "content_same": false
        },
        {
          "line": 2356,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "addrBind.ToString()",
          "old_line_content": "    if (!sock) {",
          "new_line_content": "        strError = strprintf(Untranslated(\"Error: Bind address family for %s not supported\"), addrBind.ToString());",
          "content_same": false
        },
        {
          "line": 2361,
          "old_api": null,
          "new_api": "CreateSock",
          "old_text": null,
          "new_text": "CreateSock(addrBind)",
          "old_line_content": "",
          "new_line_content": "    std::unique_ptr<Sock> sock = CreateSock(addrBind);",
          "content_same": false
        },
        {
          "line": 2363,
          "old_api": null,
          "new_api": "WSAGetLastError",
          "old_text": null,
          "new_text": "WSAGetLastError()",
          "old_line_content": "    // the program was closed and restarted.",
          "new_line_content": "        strError = strprintf(Untranslated(\"Error: Couldn't open socket for incoming connections (socket returned error %s)\"), NetworkErrorString(WSAGetLastError()));",
          "content_same": false
        },
        {
          "line": 2376,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "sock->Get()",
          "old_line_content": "    }",
          "new_line_content": "        setsockopt(sock->Get(), IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_arg_type)&nOne, sizeof(int));",
          "content_same": false
        },
        {
          "line": 2386,
          "old_api": null,
          "new_api": "WSAGetLastError",
          "old_text": null,
          "new_text": "WSAGetLastError()",
          "old_line_content": "        return false;",
          "new_line_content": "        int nErr = WSAGetLastError();",
          "content_same": false
        },
        {
          "line": 2390,
          "old_api": null,
          "new_api": "NetworkErrorString",
          "old_text": null,
          "new_text": "NetworkErrorString(nErr)",
          "old_line_content": "    // Listen for incoming connections",
          "new_line_content": "            strError = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"), addrBind.ToString(), NetworkErrorString(nErr));",
          "content_same": false
        },
        {
          "line": 2397,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "sock->Get()",
          "old_line_content": "",
          "new_line_content": "    if (listen(sock->Get(), SOMAXCONN) == SOCKET_ERROR)",
          "content_same": false
        },
        {
          "line": 2399,
          "old_api": null,
          "new_api": "WSAGetLastError",
          "old_text": null,
          "new_text": "WSAGetLastError()",
          "old_line_content": "    return true;",
          "new_line_content": "        strError = strprintf(_(\"Error: Listening for incoming connections failed (listen returned error %s)\"), NetworkErrorString(WSAGetLastError()));",
          "content_same": false
        },
        {
          "line": 2400,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"%s\\n\", strError.original)",
          "old_line_content": "}",
          "new_line_content": "        LogPrintf(\"%s\\n\", strError.original);",
          "content_same": false
        },
        {
          "line": 2404,
          "old_api": null,
          "new_api": "std::move(sock)",
          "old_text": null,
          "new_text": "std::move(sock)",
          "old_line_content": "    if (!fDiscover)",
          "new_line_content": "    vhListenSocket.emplace_back(std::move(sock), permissions);",
          "content_same": false
        },
        {
          "line": 2416,
          "old_api": null,
          "new_api": "gethostname",
          "old_text": null,
          "new_text": "gethostname(pszHostName, sizeof(pszHostName))",
          "old_line_content": "            {",
          "new_line_content": "    if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR)",
          "content_same": false
        },
        {
          "line": 2419,
          "old_api": null,
          "new_api": "LookupHost",
          "old_text": null,
          "new_text": "LookupHost(pszHostName, vaddr, 0, true)",
          "old_line_content": "            }",
          "new_line_content": "        if (LookupHost(pszHostName, vaddr, 0, true))",
          "content_same": false
        },
        {
          "line": 2423,
          "old_api": null,
          "new_api": "AddLocal",
          "old_text": null,
          "new_text": "AddLocal(addr, LOCAL_IF)",
          "old_line_content": "    // Get local host ip",
          "new_line_content": "                if (AddLocal(addr, LOCAL_IF))",
          "content_same": false
        },
        {
          "line": 2424,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "addr.ToString()",
          "old_line_content": "    struct ifaddrs* myaddrs;",
          "new_line_content": "                    LogPrintf(\"%s: %s - %s\\n\", __func__, pszHostName, addr.ToString());",
          "content_same": false
        },
        {
          "line": 2443,
          "old_api": null,
          "new_api": "AddLocal",
          "old_text": null,
          "new_text": "AddLocal(addr, LOCAL_IF)",
          "old_line_content": "                CNetAddr addr(s6->sin6_addr);",
          "new_line_content": "                if (AddLocal(addr, LOCAL_IF))",
          "content_same": false
        },
        {
          "line": 2450,
          "old_api": null,
          "new_api": "AddLocal",
          "old_text": null,
          "new_text": "AddLocal(addr, LOCAL_IF)",
          "old_line_content": "#endif",
          "new_line_content": "                if (AddLocal(addr, LOCAL_IF))",
          "content_same": false
        },
        {
          "line": 2451,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "addr.ToString()",
          "old_line_content": "}",
          "new_line_content": "                    LogPrintf(\"%s: IPv6 %s: %s\\n\", __func__, ifa->ifa_name, addr.ToString());",
          "content_same": false
        },
        {
          "line": 2454,
          "old_api": null,
          "new_api": "freeifaddrs",
          "old_text": null,
          "new_text": "freeifaddrs(myaddrs)",
          "old_line_content": "{",
          "new_line_content": "        freeifaddrs(myaddrs);",
          "content_same": false
        },
        {
          "line": 2461,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"%s: %s\\n\", __func__, active)",
          "old_line_content": "    fNetworkActive = active;",
          "new_line_content": "    LogPrintf(\"%s: %s\\n\", __func__, active);",
          "content_same": false
        },
        {
          "line": 2470,
          "old_api": null,
          "new_api": "NotifyNetworkActiveChanged",
          "old_text": null,
          "new_text": "m_client_interface->NotifyNetworkActiveChanged(fNetworkActive)",
          "old_line_content": "{",
          "new_line_content": "        m_client_interface->NotifyNetworkActiveChanged(fNetworkActive);",
          "content_same": false
        },
        {
          "line": 2477,
          "old_api": null,
          "new_api": "SetTryNewOutboundPeer",
          "old_text": null,
          "new_text": "SetTryNewOutboundPeer(false)",
          "old_line_content": "",
          "new_line_content": "    SetTryNewOutboundPeer(false);",
          "content_same": false
        },
        {
          "line": 2481,
          "old_api": null,
          "new_api": "SetNetworkActive",
          "old_text": null,
          "new_text": "SetNetworkActive(network_active)",
          "old_line_content": "}",
          "new_line_content": "    SetNetworkActive(network_active);",
          "content_same": false
        },
        {
          "line": 2498,
          "old_api": null,
          "new_api": "BindListenPort",
          "old_text": null,
          "new_text": "BindListenPort(addr, strError, permissions)",
          "old_line_content": "",
          "new_line_content": "    if (!BindListenPort(addr, strError, permissions)) {",
          "content_same": false
        },
        {
          "line": 2505,
          "old_api": null,
          "new_api": "NetPermissions::HasFlag(permissions, NetPermissionFlags::NoBan)",
          "old_text": null,
          "new_text": "NetPermissions::HasFlag(permissions, NetPermissionFlags::NoBan)",
          "old_line_content": "",
          "new_line_content": "    if (addr.IsRoutable() && fDiscover && !(flags & BF_DONT_ADVERTISE) && !NetPermissions::HasFlag(permissions, NetPermissionFlags::NoBan)) {",
          "content_same": false
        },
        {
          "line": 2506,
          "old_api": null,
          "new_api": "AddLocal",
          "old_text": null,
          "new_text": "AddLocal(addr, LOCAL_BIND)",
          "old_line_content": "bool CConnman::InitBinds(const Options& options)",
          "new_line_content": "        AddLocal(addr, LOCAL_BIND);",
          "content_same": false
        },
        {
          "line": 2519,
          "old_api": null,
          "new_api": "Bind",
          "old_text": null,
          "new_text": "Bind(addrBind.m_service, (BF_EXPLICIT | BF_REPORT_ERROR), addrBind.m_flags)",
          "old_line_content": "        struct in_addr inaddr_any;",
          "new_line_content": "        fBound |= Bind(addrBind.m_service, (BF_EXPLICIT | BF_REPORT_ERROR), addrBind.m_flags);",
          "content_same": false
        },
        {
          "line": 2526,
          "old_api": null,
          "new_api": "htonl",
          "old_text": null,
          "new_text": "htonl(INADDR_ANY)",
          "old_line_content": "}",
          "new_line_content": "        inaddr_any.s_addr = htonl(INADDR_ANY);",
          "content_same": false
        },
        {
          "line": 2528,
          "old_api": null,
          "new_api": "GetListenPort",
          "old_text": null,
          "new_text": "GetListenPort()",
          "old_line_content": "bool CConnman::Start(CScheduler& scheduler, const Options& connOptions)",
          "new_line_content": "        fBound |= Bind(CService(inaddr6_any, GetListenPort()), BF_NONE, NetPermissionFlags::None);",
          "content_same": false
        },
        {
          "line": 2529,
          "old_api": null,
          "new_api": "GetListenPort",
          "old_text": null,
          "new_text": "GetListenPort()",
          "old_line_content": "{",
          "new_line_content": "        fBound |= Bind(CService(inaddr_any, GetListenPort()), !fBound ? BF_REPORT_ERROR : BF_NONE, NetPermissionFlags::None);",
          "content_same": false
        },
        {
          "line": 2536,
          "old_api": null,
          "new_api": "Init",
          "old_text": null,
          "new_text": "Init(connOptions)",
          "old_line_content": "                \"\", CClientUIInterface::MSG_ERROR);",
          "new_line_content": "    Init(connOptions);",
          "content_same": false
        },
        {
          "line": 2538,
          "old_api": null,
          "new_api": "InitBinds",
          "old_text": null,
          "new_text": "InitBinds(connOptions)",
          "old_line_content": "        return false;",
          "new_line_content": "    if (fListen && !InitBinds(connOptions)) {",
          "content_same": false
        },
        {
          "line": 2540,
          "old_api": null,
          "new_api": "ThreadSafeMessageBox",
          "old_text": null,
          "new_text": "m_client_interface->ThreadSafeMessageBox(\n                _(\"Failed to listen on any port. Use -listen=0 if you want this.\"),\n                \"\", CClientUIInterface::MSG_ERROR)",
          "old_line_content": "",
          "new_line_content": "            m_client_interface->ThreadSafeMessageBox(",
          "content_same": false
        },
        {
          "line": 2541,
          "old_api": null,
          "new_api": "_",
          "old_text": null,
          "new_text": "_(\"Failed to listen on any port. Use -listen=0 if you want this.\")",
          "old_line_content": "    proxyType i2p_sam;",
          "new_line_content": "                _(\"Failed to listen on any port. Use -listen=0 if you want this.\"),",
          "content_same": false
        },
        {
          "line": 2549,
          "old_api": null,
          "new_api": "GetDataDirNet",
          "old_text": null,
          "new_text": "gArgs.GetDataDirNet()",
          "old_line_content": "    }",
          "new_line_content": "        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(gArgs.GetDataDirNet() / \"i2p_private_key\",",
          "content_same": false
        },
        {
          "line": 2559,
          "old_api": null,
          "new_api": "GetDataDirNet",
          "old_text": null,
          "new_text": "gArgs.GetDataDirNet()",
          "old_line_content": "",
          "new_line_content": "        m_anchors = ReadAnchors(gArgs.GetDataDirNet() / ANCHORS_DATABASE_FILENAME);",
          "content_same": false
        },
        {
          "line": 2560,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "m_anchors.size()",
          "old_line_content": "    if (m_client_interface) {",
          "new_line_content": "        if (m_anchors.size() > MAX_BLOCK_RELAY_ONLY_ANCHORS) {",
          "content_same": false
        },
        {
          "line": 2563,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "m_anchors.size()",
          "old_line_content": "",
          "new_line_content": "        LogPrintf(\"%i block-relay-only anchors will be tried for connections.\\n\", m_anchors.size());",
          "content_same": false
        },
        {
          "line": 2567,
          "old_api": null,
          "new_api": "_",
          "old_text": null,
          "new_text": "_(\"Starting network threads…\").t",
          "old_line_content": "        // initialize semaphore",
          "new_line_content": "        m_client_interface->InitMessage(_(\"Starting network threads…\").translated);",
          "content_same": false
        },
        {
          "line": 2574,
          "old_api": null,
          "new_api": "d::min(m_max_outbound, nMaxConnections));",
          "old_text": null,
          "new_text": "d::min(m_max_outbound, nMaxConnections));",
          "old_line_content": "",
          "new_line_content": "        semOutbound = std::make_unique<CSemaphore>(std::min(m_max_outbound, nMaxConnections));",
          "content_same": false
        },
        {
          "line": 2585,
          "old_api": null,
          "new_api": "terruptSocks5",
          "old_text": null,
          "new_text": "terruptSocks5(false);\n",
          "old_line_content": "        fMsgProcWake = false;",
          "new_line_content": "    InterruptSocks5(false);",
          "content_same": false
        },
        {
          "line": 2586,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "terruptNet.reset();\n",
          "old_line_content": "    }",
          "new_line_content": "    interruptNet.reset();",
          "content_same": false
        },
        {
          "line": 2590,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(mutexMsgProc);\n",
          "old_line_content": "",
          "new_line_content": "        LOCK(mutexMsgProc);",
          "content_same": false
        },
        {
          "line": 2595,
          "old_api": null,
          "new_api": "readSocketHandler",
          "old_text": null,
          "new_text": "readSocketHandler(); ",
          "old_line_content": "",
          "new_line_content": "    threadSocketHandler = std::thread(&util::TraceThread, \"net\", [this] { ThreadSocketHandler(); });",
          "content_same": false
        },
        {
          "line": 2598,
          "old_api": null,
          "new_api": "gPrintf",
          "old_text": null,
          "new_text": "gPrintf(\"DNS seeding disabled\\n\");\n",
          "old_line_content": "",
          "new_line_content": "        LogPrintf(\"DNS seeding disabled\\n\");",
          "content_same": false
        },
        {
          "line": 2600,
          "old_api": null,
          "new_api": "readDNSAddressSeed",
          "old_text": null,
          "new_text": "readDNSAddressSeed(); ",
          "old_line_content": "        if (m_client_interface) {",
          "new_line_content": "        threadDNSAddressSeed = std::thread(&util::TraceThread, \"dnsseed\", [this] { ThreadDNSAddressSeed(); });",
          "content_same": false
        },
        {
          "line": 2603,
          "old_api": null,
          "new_api": "readOpenAddedConnections",
          "old_text": null,
          "new_text": "readOpenAddedConnections(); ",
          "old_line_content": "                \"\", CClientUIInterface::MSG_ERROR);",
          "new_line_content": "    threadOpenAddedConnections = std::thread(&util::TraceThread, \"addcon\", [this] { ThreadOpenAddedConnections(); });",
          "content_same": false
        },
        {
          "line": 2605,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "nnOptions.m_specified_outgoing.empty()) ",
          "old_line_content": "        return false;",
          "new_line_content": "    if (connOptions.m_use_addrman_outgoing && !connOptions.m_specified_outgoing.empty()) {",
          "content_same": false
        },
        {
          "line": 2613,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "nnOptions.m_specified_outgoing.empty()) ",
          "old_line_content": "    // Process messages",
          "new_line_content": "    if (connOptions.m_use_addrman_outgoing || !connOptions.m_specified_outgoing.empty()) {",
          "content_same": false
        },
        {
          "line": 2620,
          "old_api": null,
          "new_api": "readMessageHandler",
          "old_text": null,
          "new_text": "readMessageHandler(); ",
          "old_line_content": "",
          "new_line_content": "    threadMessageHandler = std::thread(&util::TraceThread, \"msghand\", [this] { ThreadMessageHandler(); });",
          "content_same": false
        },
        {
          "line": 2624,
          "old_api": null,
          "new_api": "readI2PAcceptIncoming",
          "old_text": null,
          "new_text": "readI2PAcceptIncoming(); ",
          "old_line_content": "    return true;",
          "new_line_content": "            std::thread(&util::TraceThread, \"i2paccept\", [this] { ThreadI2PAcceptIncoming(); });",
          "content_same": false
        },
        {
          "line": 2628,
          "old_api": null,
          "new_api": "mpAddresses",
          "old_text": null,
          "new_text": "mpAddresses(); ",
          "old_line_content": "{",
          "new_line_content": "    scheduler.scheduleEvery([this] { DumpAddresses(); }, DUMP_PEERS_INTERVAL);",
          "content_same": false
        },
        {
          "line": 2642,
          "old_api": null,
          "new_api": "ACleanup",
          "old_text": null,
          "new_text": "ACleanup();\n",
          "old_line_content": "void CConnman::Interrupt()",
          "new_line_content": "        WSACleanup();",
          "content_same": false
        },
        {
          "line": 2654,
          "old_api": null,
          "new_api": "notify_all",
          "old_text": null,
          "new_text": "ndMsgProc.notify_all();\n",
          "old_line_content": "        for (int i=0; i<m_max_outbound; i++) {",
          "new_line_content": "    condMsgProc.notify_all();",
          "content_same": false
        },
        {
          "line": 2656,
          "old_api": null,
          "new_api": "terruptNet",
          "old_text": null,
          "new_text": "terruptNet();\n",
          "old_line_content": "        }",
          "new_line_content": "    interruptNet();",
          "content_same": false
        },
        {
          "line": 2657,
          "old_api": null,
          "new_api": "terruptSocks5",
          "old_text": null,
          "new_text": "terruptSocks5(true);\n",
          "old_line_content": "    }",
          "new_line_content": "    InterruptSocks5(true);",
          "content_same": false
        },
        {
          "line": 2667,
          "old_api": null,
          "new_api": "post",
          "old_text": null,
          "new_text": "mAddnode->post();\n",
          "old_line_content": "{",
          "new_line_content": "            semAddnode->post();",
          "content_same": false
        },
        {
          "line": 2681,
          "old_api": null,
          "new_api": "joinable",
          "old_text": null,
          "new_text": "readOpenAddedConnections.joinable())\n",
          "old_line_content": "}",
          "new_line_content": "    if (threadOpenAddedConnections.joinable())",
          "content_same": false
        },
        {
          "line": 2682,
          "old_api": null,
          "new_api": "join",
          "old_text": null,
          "new_text": "readOpenAddedConnections.join();\n",
          "old_line_content": "",
          "new_line_content": "        threadOpenAddedConnections.join();",
          "content_same": false
        },
        {
          "line": 2683,
          "old_api": null,
          "new_api": "joinable",
          "old_text": null,
          "new_text": "readDNSAddressSeed.joinable())\n",
          "old_line_content": "void CConnman::StopNodes()",
          "new_line_content": "    if (threadDNSAddressSeed.joinable())",
          "content_same": false
        },
        {
          "line": 2684,
          "old_api": null,
          "new_api": "join",
          "old_text": null,
          "new_text": "readDNSAddressSeed.join();\n",
          "old_line_content": "{",
          "new_line_content": "        threadDNSAddressSeed.join();",
          "content_same": false
        },
        {
          "line": 2685,
          "old_api": null,
          "new_api": "joinable",
          "old_text": null,
          "new_text": "readSocketHandler.joinable())\n",
          "old_line_content": "    if (fAddressesInitialized) {",
          "new_line_content": "    if (threadSocketHandler.joinable())",
          "content_same": false
        },
        {
          "line": 2697,
          "old_api": null,
          "new_api": "tCurrentBlockRelayOnlyConns",
          "old_text": null,
          "new_text": "tCurrentBlockRelayOnlyConns();\n",
          "old_line_content": "    }",
          "new_line_content": "            std::vector<CAddress> anchors_to_dump = GetCurrentBlockRelayOnlyConns();",
          "content_same": false
        },
        {
          "line": 2698,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "chors_to_dump.size() >",
          "old_line_content": "",
          "new_line_content": "            if (anchors_to_dump.size() > MAX_BLOCK_RELAY_ONLY_ANCHORS) {",
          "content_same": false
        },
        {
          "line": 2699,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "chors_to_dump.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);\n",
          "old_line_content": "    // Delete peer connections.",
          "new_line_content": "                anchors_to_dump.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);",
          "content_same": false
        },
        {
          "line": 2707,
          "old_api": null,
          "new_api": "swap",
          "old_text": null,
          "new_text": "des.swap(m_nodes));",
          "old_line_content": "    for (CNode* pnode : m_nodes_disconnected) {",
          "new_line_content": "    WITH_LOCK(m_nodes_mutex, nodes.swap(m_nodes));",
          "content_same": false
        },
        {
          "line": 2709,
          "old_api": null,
          "new_api": "CloseSocketDisconnect",
          "old_text": null,
          "new_text": "ode->CloseSocketDisconnect();\n",
          "old_line_content": "    }",
          "new_line_content": "        pnode->CloseSocketDisconnect();",
          "content_same": false
        },
        {
          "line": 2714,
          "old_api": null,
          "new_api": "leteNode",
          "old_text": null,
          "new_text": "leteNode(pnode);\n",
          "old_line_content": "}",
          "new_line_content": "        DeleteNode(pnode);",
          "content_same": false
        },
        {
          "line": 2716,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "nodes_disconnected.clear();\n",
          "old_line_content": "void CConnman::DeleteNode(CNode* pnode)",
          "new_line_content": "    m_nodes_disconnected.clear();",
          "content_same": false
        },
        {
          "line": 2717,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "ListenSocket.clear();\n",
          "old_line_content": "{",
          "new_line_content": "    vhListenSocket.clear();",
          "content_same": false
        },
        {
          "line": 2724,
          "old_api": null,
          "new_api": "sert",
          "old_text": null,
          "new_text": "sert(pnode);\n",
          "old_line_content": "{",
          "new_line_content": "    assert(pnode);",
          "content_same": false
        },
        {
          "line": 2732,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "op();\n",
          "old_line_content": "    if (m_banman) {",
          "new_line_content": "    Stop();",
          "content_same": false
        },
        {
          "line": 2737,
          "old_api": null,
          "new_api": "GetAddr",
          "old_text": null,
          "new_text": "drman.GetAddr(max_addresses, max_pct, network);\n",
          "old_line_content": "    return addresses;",
          "new_line_content": "    std::vector<CAddress> addresses = addrman.GetAddr(max_addresses, max_pct, network);",
          "content_same": false
        },
        {
          "line": 2739,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "dresses.end(),\n",
          "old_line_content": "",
          "new_line_content": "        addresses.erase(std::remove_if(addresses.begin(), addresses.end(),",
          "content_same": false
        },
        {
          "line": 2740,
          "old_api": null,
          "new_api": "IsBanned",
          "old_text": null,
          "new_text": "banman->IsBanned(addr);}",
          "old_line_content": "std::vector<CAddress> CConnman::GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct)",
          "new_line_content": "                        [this](const CAddress& addr){return m_banman->IsDiscouraged(addr) || m_banman->IsBanned(addr);}),",
          "content_same": false
        },
        {
          "line": 2741,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "dresses.end());",
          "old_line_content": "{",
          "new_line_content": "                        addresses.end());",
          "content_same": false
        },
        {
          "line": 2749,
          "old_api": null,
          "new_api": "Write",
          "old_text": null,
          "new_text": "tDeterministicRandomizer(RANDOMIZER_ID_ADDRCACHE)\n        .Write(requestor.addr.GetNetwork())\n        .Write(local_socket_bytes.data(), local_socket_bytes.size())\n        .Finalize();\n",
          "old_line_content": "    CachedAddrResponse& cache_entry = r.first->second;",
          "new_line_content": "    uint64_t cache_id = GetDeterministicRandomizer(RANDOMIZER_ID_ADDRCACHE)",
          "content_same": false
        },
        {
          "line": 2750,
          "old_api": null,
          "new_api": "GetNetwork",
          "old_text": null,
          "new_text": "questor.addr.GetNetwork())\n",
          "old_line_content": "    if (cache_entry.m_cache_entry_expiration < current_time) { // If emplace() added new one it has expiration 0.",
          "new_line_content": "        .Write(requestor.addr.GetNetwork())",
          "content_same": false
        },
        {
          "line": 2753,
          "old_api": null,
          "new_api": "tTime<std::chrono::microseconds>();",
          "old_text": null,
          "new_text": "tTime<std::chrono::microseconds>();\n",
          "old_line_content": "        // and the usefulness of ADDR responses to honest users.",
          "new_line_content": "    const auto current_time = GetTime<std::chrono::microseconds>();",
          "content_same": false
        },
        {
          "line": 2754,
          "old_api": null,
          "new_api": "emplace",
          "old_text": null,
          "new_text": "addr_response_caches.emplace(cache_id, CachedAddrResponse{});\n",
          "old_line_content": "        //",
          "new_line_content": "    auto r = m_addr_response_caches.emplace(cache_id, CachedAddrResponse{});",
          "content_same": false
        },
        {
          "line": 2757,
          "old_api": null,
          "new_api": "tAddresses",
          "old_text": null,
          "new_text": "tAddresses(max_addresses, max_pct, /* network */ std::nullopt);\n",
          "old_line_content": "        // By the time an attacker scraped enough AddrMan records, most of",
          "new_line_content": "        cache_entry.m_addrs_response_cache = GetAddresses(max_addresses, max_pct, /* network */ std::nullopt);",
          "content_same": false
        },
        {
          "line": 2782,
          "old_api": null,
          "new_api": "d::chrono::hours(6));",
          "old_text": null,
          "new_text": "d::chrono::hours(6));",
          "old_line_content": "{",
          "new_line_content": "        cache_entry.m_cache_entry_expiration = current_time + std::chrono::hours(21) + GetRandMillis(std::chrono::hours(6));",
          "content_same": false
        },
        {
          "line": 2789,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_added_nodes_mutex);\n",
          "old_line_content": "    return true;",
          "new_line_content": "    LOCK(m_added_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2800,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_added_nodes_mutex);\n",
          "old_line_content": "    }",
          "new_line_content": "    LOCK(m_added_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2801,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "added_nodes.end(); ",
          "old_line_content": "    return false;",
          "new_line_content": "    for(std::vector<std::string>::iterator it = m_added_nodes.begin(); it != m_added_nodes.end(); ++it) {",
          "content_same": false
        },
        {
          "line": 2803,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "added_nodes.erase(it);\n",
          "old_line_content": "",
          "new_line_content": "            m_added_nodes.erase(it);",
          "content_same": false
        },
        {
          "line": 2814,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "nodes.size();\n",
          "old_line_content": "        }",
          "new_line_content": "        return m_nodes.size();",
          "content_same": false
        },
        {
          "line": 2818,
          "old_api": null,
          "new_api": "IsInboundConn",
          "old_text": null,
          "new_text": "ode->IsInboundConn() ?",
          "old_line_content": "}",
          "new_line_content": "        if (flags & (pnode->IsInboundConn() ? ConnectionDirection::In : ConnectionDirection::Out)) {",
          "content_same": false
        },
        {
          "line": 2829,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_nodes_mutex);\n",
          "old_line_content": "    }",
          "new_line_content": "    LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2830,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "nodes.size());",
          "old_line_content": "}",
          "new_line_content": "    vstats.reserve(m_nodes.size());",
          "content_same": false
        },
        {
          "line": 2832,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "tats.emplace_back();\n",
          "old_line_content": "bool CConnman::DisconnectNode(const std::string& strNode)",
          "new_line_content": "        vstats.emplace_back();",
          "content_same": false
        },
        {
          "line": 2833,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "tats.back());",
          "old_line_content": "{",
          "new_line_content": "        pnode->CopyStats(vstats.back());",
          "content_same": false
        },
        {
          "line": 2840,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_nodes_mutex);\n",
          "old_line_content": "    return false;",
          "new_line_content": "    LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2841,
          "old_api": null,
          "new_api": "ndNode",
          "old_text": null,
          "new_text": "ndNode(strNode)) ",
          "old_line_content": "}",
          "new_line_content": "    if (CNode* pnode = FindNode(strNode)) {",
          "content_same": false
        },
        {
          "line": 2842,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "ode->GetId());",
          "old_line_content": "",
          "new_line_content": "        LogPrint(BCLog::NET, \"disconnect by address%s matched peer=%d; disconnecting\\n\", (fLogIPs ? strprintf(\"=%s\", strNode) : \"\"), pnode->GetId());",
          "content_same": false
        },
        {
          "line": 2852,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_nodes_mutex);\n",
          "old_line_content": "        }",
          "new_line_content": "    LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2854,
          "old_api": null,
          "new_api": "Match",
          "old_text": null,
          "new_text": "bnet.Match(pnode->addr)) ",
          "old_line_content": "    return disconnected;",
          "new_line_content": "        if (subnet.Match(pnode->addr)) {",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "node.vSendMsg.end()",
          "old_line_content": "        if (nBytes > 0) {",
          "new_line_content": "            if (it + 1 != node.vSendMsg.end()) {",
          "content_same": false
        },
        {
          "line": 2855,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "ode->GetId());",
          "old_line_content": "}",
          "new_line_content": "            LogPrint(BCLog::NET, \"disconnect by subnet%s matched peer=%d; disconnecting\\n\", (fLogIPs ? strprintf(\"=%s\", subnet.ToString()) : \"\"), pnode->GetId());",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data.size()",
          "old_line_content": "            nSentSize += nBytes;",
          "new_line_content": "            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()) + node.nSendOffset, data.size() - node.nSendOffset, flags);",
          "content_same": false
        },
        {
          "line": 2865,
          "old_api": null,
          "new_api": "ubNet",
          "old_text": null,
          "new_text": "ubNet(addr));",
          "old_line_content": "    for(CNode* pnode : m_nodes) {",
          "new_line_content": "    return DisconnectNode(CSubNet(addr));",
          "content_same": false
        },
        {
          "line": 818,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data.size()",
          "old_line_content": "                // could not send full message; stop sending more",
          "new_line_content": "            if (node.nSendOffset == data.size()) {",
          "content_same": false
        },
        {
          "line": 820,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data.size()",
          "old_line_content": "            }",
          "new_line_content": "                node.nSendSize -= data.size();",
          "content_same": false
        },
        {
          "line": 2870,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_nodes_mutex);\n",
          "old_line_content": "        }",
          "new_line_content": "    LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2872,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "ode->GetId()) ",
          "old_line_content": "    return false;",
          "new_line_content": "        if (id == pnode->GetId()) {",
          "content_same": false
        },
        {
          "line": 2873,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "ode->GetId());",
          "old_line_content": "}",
          "new_line_content": "            LogPrint(BCLog::NET, \"disconnect by id peer=%d; disconnecting\\n\", pnode->GetId());",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": null,
          "new_api": "WSAGetLastError",
          "old_text": null,
          "new_text": "WSAGetLastError()",
          "old_line_content": "            // couldn't send anything at all",
          "new_line_content": "                int nErr = WSAGetLastError();",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": null,
          "new_api": "NetworkErrorString",
          "old_text": null,
          "new_text": "NetworkErrorString(nErr)",
          "old_line_content": "        }",
          "new_line_content": "                    LogPrint(BCLog::NET, \"socket send error for peer=%d: %s\\n\", node.GetId(), NetworkErrorString(nErr));",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": null,
          "new_api": "CloseSocketDisconnect",
          "old_text": null,
          "new_text": "node.CloseSocketDisconnect()",
          "old_line_content": "    }",
          "new_line_content": "                    node.CloseSocketDisconnect();",
          "content_same": false
        },
        {
          "line": 2888,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(cs_totalBytesSent);\n",
          "old_line_content": "        // timeframe expired, reset cycle",
          "new_line_content": "    LOCK(cs_totalBytesSent);",
          "content_same": false
        },
        {
          "line": 841,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "node.vSendMsg.end()",
          "old_line_content": "}",
          "new_line_content": "    if (it == node.vSendMsg.end()) {",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(node.nSendOffset == 0)",
          "old_line_content": "",
          "new_line_content": "        assert(node.nSendOffset == 0);",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(node.nSendSize == 0)",
          "old_line_content": "static bool ReverseCompareNodeMinPingTime(const NodeEvictionCandidate &a, const NodeEvictionCandidate &b)",
          "new_line_content": "        assert(node.nSendSize == 0);",
          "content_same": false
        },
        {
          "line": 2891,
          "old_api": null,
          "new_api": "tTime<std::chrono::seconds>();",
          "old_text": null,
          "new_text": "tTime<std::chrono::seconds>();\n",
          "old_line_content": "    }",
          "new_line_content": "    const auto now = GetTime<std::chrono::seconds>();",
          "content_same": false
        },
        {
          "line": 845,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "node.vSendMsg.begin()",
          "old_line_content": "    return a.m_min_ping_time > b.m_min_ping_time;",
          "new_line_content": "    node.vSendMsg.erase(node.vSendMsg.begin(), it);",
          "content_same": false
        },
        {
          "line": 2904,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(cs_totalBytesSent);\n",
          "old_line_content": "    return MAX_UPLOAD_TIMEFRAME;",
          "new_line_content": "    LOCK(cs_totalBytesSent);",
          "content_same": false
        },
        {
          "line": 2915,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(cs_totalBytesSent);\n",
          "old_line_content": "",
          "new_line_content": "    LOCK(cs_totalBytesSent);",
          "content_same": false
        },
        {
          "line": 2919,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "axOutboundCycleStartTime.count() =",
          "old_line_content": "}",
          "new_line_content": "    if (nMaxOutboundCycleStartTime.count() == 0)",
          "content_same": false
        },
        {
          "line": 2929,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(cs_totalBytesSent);\n",
          "old_line_content": "        // keep a large enough buffer to at least relay each block once",
          "new_line_content": "    LOCK(cs_totalBytesSent);",
          "content_same": false
        },
        {
          "line": 2936,
          "old_api": null,
          "new_api": "tMaxOutboundTimeLeftInCycle",
          "old_text": null,
          "new_text": "tMaxOutboundTimeLeftInCycle();\n",
          "old_line_content": "        return true;",
          "new_line_content": "        const std::chrono::seconds timeLeftInCycle = GetMaxOutboundTimeLeftInCycle();",
          "content_same": false
        },
        {
          "line": 2949,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(cs_totalBytesSent);\n",
          "old_line_content": "",
          "new_line_content": "    LOCK(cs_totalBytesSent);",
          "content_same": false
        },
        {
          "line": 915,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "elements.end()",
          "old_line_content": "{",
          "new_line_content": "    std::sort(elements.begin(), elements.end(), comparator);",
          "content_same": false
        },
        {
          "line": 916,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "elements.size()",
          "old_line_content": "    // Protect the half of the remaining nodes which have been connected the longest.",
          "new_line_content": "    size_t eraseSize = std::min(k, elements.size());",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "elements.end()",
          "old_line_content": "    // This replicates the non-eviction implicit behavior, and precludes attacks that start later.",
          "new_line_content": "    elements.erase(std::remove_if(elements.end() - eraseSize, elements.end(), predicate), elements.end());",
          "content_same": false
        },
        {
          "line": 2963,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(cs_totalBytesSent);\n",
          "old_line_content": "    return nLocalServices;",
          "new_line_content": "    LOCK(cs_totalBytesSent);",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "eviction_candidates.size()",
          "old_line_content": "    std::array<Net, 3> networks{",
          "new_line_content": "    const size_t initial_size = eviction_candidates.size();",
          "content_same": false
        },
        {
          "line": 2976,
          "old_api": null,
          "new_api": "tTime<std::chrono::seconds>()},",
          "old_text": null,
          "new_text": "tTime<std::chrono::seconds>()},",
          "old_line_content": "      id(idIn),",
          "new_line_content": "      m_connected{GetTime<std::chrono::seconds>()},",
          "content_same": false
        },
        {
          "line": 2979,
          "old_api": null,
          "new_api": "ToStringIPPort",
          "old_text": null,
          "new_text": "dr.ToStringIPPort() :",
          "old_line_content": "      nLocalServices(nLocalServicesIn)",
          "new_line_content": "      m_addr_name{addrNameIn.empty() ? addr.ToStringIPPort() : addrNameIn},",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": null,
          "new_api": "cend",
          "old_text": null,
          "new_text": "eviction_candidates.cend()",
          "old_line_content": "    // the first opportunity to recover unused protected slots from the previous iteration.",
          "new_line_content": "        n.count = std::count_if(eviction_candidates.cbegin(), eviction_candidates.cend(),",
          "content_same": false
        },
        {
          "line": 2987,
          "old_api": null,
          "new_api": "sert",
          "old_text": null,
          "new_text": "sert(conn_type_in == ConnectionType::INBOUND);\n",
          "old_line_content": "        mapRecvBytesPerMsgCmd[msg] = 0;",
          "new_line_content": "    if (inbound_onion) assert(conn_type_in == ConnectionType::INBOUND);",
          "content_same": false
        },
        {
          "line": 2989,
          "old_api": null,
          "new_api": "d::make_unique<TxRelay>();",
          "old_text": null,
          "new_text": "d::make_unique<TxRelay>();\n",
          "old_line_content": "",
          "new_line_content": "        m_tx_relay = std::make_unique<TxRelay>();",
          "content_same": false
        },
        {
          "line": 2992,
          "old_api": null,
          "new_api": "tAllNetMessageTypes",
          "old_text": null,
          "new_text": "tAllNetMessageTypes())\n",
          "old_line_content": "    } else {",
          "new_line_content": "    for (const std::string &msg : getAllNetMessageTypes())",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "networks.end()",
          "old_line_content": "    while (num_protected < max_protect_by_network) {",
          "new_line_content": "    std::stable_sort(networks.begin(), networks.end(), [](Net a, Net b) { return a.count < b.count; });",
          "content_same": false
        },
        {
          "line": 2999,
          "old_api": null,
          "new_api": "gPrint",
          "old_text": null,
          "new_text": "gPrint(BCLog::NET, \"Added connection peer=%d\\n\", id);\n",
          "old_line_content": "",
          "new_line_content": "        LogPrint(BCLog::NET, \"Added connection peer=%d\\n\", id);",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "networks.end()",
          "old_line_content": "        // Early exit flag if there are no remaining candidates by disadvantaged network.",
          "new_line_content": "        auto num_networks = std::count_if(networks.begin(), networks.end(), [](const Net& n) { return n.count; });",
          "content_same": false
        },
        {
          "line": 3002,
          "old_api": null,
          "new_api": "rams",
          "old_text": null,
          "new_text": "rams(), ",
          "old_line_content": "    return pnode && pnode->fSuccessfullyConnected && !pnode->fDisconnect;",
          "new_line_content": "    m_deserializer = std::make_unique<V1TransportDeserializer>(V1TransportDeserializer(Params(), id, SER_NETWORK, INIT_PROTO_VERSION));",
          "content_same": false
        },
        {
          "line": 3003,
          "old_api": null,
          "new_api": "TransportSerializer",
          "old_text": null,
          "new_text": "TransportSerializer());",
          "old_line_content": "}",
          "new_line_content": "    m_serializer = std::make_unique<V1TransportSerializer>(V1TransportSerializer());",
          "content_same": false
        },
        {
          "line": 965,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "eviction_candidates.size()",
          "old_line_content": "            if (before > after) {",
          "new_line_content": "            const size_t before = eviction_candidates.size();",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": null,
          "new_api": "CompareNodeNetworkTime",
          "old_text": null,
          "new_text": "CompareNodeNetworkTime(n.is_local, n.id)",
          "old_line_content": "                protected_at_least_one = true;",
          "new_line_content": "            EraseLastKElements(eviction_candidates, CompareNodeNetworkTime(n.is_local, n.id),",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "eviction_candidates.size()",
          "old_line_content": "                    break;",
          "new_line_content": "            const size_t after = eviction_candidates.size();",
          "content_same": false
        },
        {
          "line": 3020,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "ode->GetId(),\n",
          "old_line_content": "    );",
          "new_line_content": "        pnode->GetId(),",
          "content_same": false
        },
        {
          "line": 3021,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "ode->m_addr_name.c_str(),\n",
          "old_line_content": "",
          "new_line_content": "        pnode->m_addr_name.c_str(),",
          "content_same": false
        },
        {
          "line": 3022,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "ode->ConnectionTypeAsString().c_str(),\n",
          "old_line_content": "    // make sure we use the appropriate network transport format",
          "new_line_content": "        pnode->ConnectionTypeAsString().c_str(),",
          "content_same": false
        },
        {
          "line": 3023,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "g.m_type.c_str(),\n",
          "old_line_content": "    std::vector<unsigned char> serializedHeader;",
          "new_line_content": "        msg.m_type.c_str(),",
          "content_same": false
        },
        {
          "line": 3031,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "rializedHeader.size();\n",
          "old_line_content": "",
          "new_line_content": "    size_t nTotalSize = nMessageSize + serializedHeader.size();",
          "content_same": false
        },
        {
          "line": 3035,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(pnode->cs_vSend);\n",
          "old_line_content": "",
          "new_line_content": "        LOCK(pnode->cs_vSend);",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "eviction_candidates.size()",
          "old_line_content": "{",
          "new_line_content": "    assert(num_protected == initial_size - eviction_candidates.size());",
          "content_same": false
        },
        {
          "line": 3036,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "ode->vSendMsg.empty());",
          "old_line_content": "        if (pnode->nSendSize > nSendBufferMaxSize) pnode->fPauseSend = true;",
          "new_line_content": "        bool optimisticSend(pnode->vSendMsg.empty());",
          "content_same": false
        },
        {
          "line": 990,
          "old_api": null,
          "new_api": "EraseLastKElements",
          "old_text": null,
          "new_text": "EraseLastKElements(eviction_candidates, ReverseCompareNodeTimeConnected, remaining_to_protect)",
          "old_line_content": "",
          "new_line_content": "    EraseLastKElements(eviction_candidates, ReverseCompareNodeTimeConnected, remaining_to_protect);",
          "content_same": false
        },
        {
          "line": 3044,
          "old_api": null,
          "new_api": "d::move(msg.data));",
          "old_text": null,
          "new_text": "d::move(msg.data));",
          "old_line_content": "}",
          "new_line_content": "        if (nMessageSize) pnode->vSendMsg.push_back(std::move(msg.data));",
          "content_same": false
        },
        {
          "line": 3047,
          "old_api": null,
          "new_api": "cketSendData",
          "old_text": null,
          "new_text": "cketSendData(*pnode);\n",
          "old_line_content": "{",
          "new_line_content": "        if (optimisticSend) nBytesSent = SocketSendData(*pnode);",
          "content_same": false
        },
        {
          "line": 1002,
          "old_api": null,
          "new_api": "EraseLastKElements",
          "old_text": null,
          "new_text": "EraseLastKElements(vEvictionCandidates, ReverseCompareNodeMinPingTime, 8)",
          "old_line_content": "                       [](const NodeEvictionCandidate& n) { return !n.fRelayTxes && n.fRelevantServices; });",
          "new_line_content": "    EraseLastKElements(vEvictionCandidates, ReverseCompareNodeMinPingTime, 8);",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": null,
          "new_api": "EraseLastKElements",
          "old_text": null,
          "new_text": "EraseLastKElements(vEvictionCandidates, CompareNodeTXTime, 4)",
          "old_line_content": "    // An attacker cannot manipulate this metric without performing useful work.",
          "new_line_content": "    EraseLastKElements(vEvictionCandidates, CompareNodeTXTime, 4);",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": null,
          "new_api": "EraseLastKElements",
          "old_text": null,
          "new_text": "EraseLastKElements(vEvictionCandidates, CompareNodeBlockRelayOnlyTime, 8,\n                       [](const NodeEvictionCandidate& n) { return !n.fRelayTxes && n.fRelevantServices; })",
          "old_line_content": "",
          "new_line_content": "    EraseLastKElements(vEvictionCandidates, CompareNodeBlockRelayOnlyTime, 8,",
          "content_same": false
        },
        {
          "line": 3055,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_nodes_mutex);\n",
          "old_line_content": "    }",
          "new_line_content": "    LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 3057,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "ode->GetId() =",
          "old_line_content": "}",
          "new_line_content": "        if(pnode->GetId() == id) {",
          "content_same": false
        },
        {
          "line": 3062,
          "old_api": null,
          "new_api": "nc",
          "old_text": null,
          "new_text": "nc(found);\n",
          "old_line_content": "        // If this function were called from multiple threads simultaneously",
          "new_line_content": "    return found != nullptr && NodeFullyConnected(found) && func(found);",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": null,
          "new_api": "ProtectEvictionCandidatesByRatio",
          "old_text": null,
          "new_text": "ProtectEvictionCandidatesByRatio(vEvictionCandidates)",
          "old_line_content": "    //  then we probably don't want to evict it no matter what.",
          "new_line_content": "    ProtectEvictionCandidatesByRatio(vEvictionCandidates);",
          "content_same": false
        },
        {
          "line": 3067,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "next_send_inv_to_incoming.load() <",
          "old_line_content": "    return m_next_send_inv_to_incoming;",
          "new_line_content": "    if (m_next_send_inv_to_incoming.load() < now) {",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "vEvictionCandidates.end()",
          "old_line_content": "    // (vEvictionCandidates is already sorted by reverse connect time)",
          "new_line_content": "    if (std::any_of(vEvictionCandidates.begin(),vEvictionCandidates.end(),[](NodeEvictionCandidate const &n){return n.prefer_evict;})) {",
          "content_same": false
        },
        {
          "line": 1024,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "vEvictionCandidates.end()",
          "old_line_content": "    uint64_t naMostConnections;",
          "new_line_content": "        vEvictionCandidates.erase(std::remove_if(vEvictionCandidates.begin(),vEvictionCandidates.end(),",
          "content_same": false
        },
        {
          "line": 1025,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "vEvictionCandidates.end()",
          "old_line_content": "    unsigned int nMostConnections = 0;",
          "new_line_content": "                                  [](NodeEvictionCandidate const &n){return !n.prefer_evict;}),vEvictionCandidates.end());",
          "content_same": false
        },
        {
          "line": 3071,
          "old_api": null,
          "new_api": "issonNextSend",
          "old_text": null,
          "new_text": "issonNextSend(now, average_interval);\n",
          "old_line_content": "{",
          "new_line_content": "        m_next_send_inv_to_incoming = PoissonNextSend(now, average_interval);",
          "content_same": false
        },
        {
          "line": 3079,
          "old_api": null,
          "new_api": "d::chrono::duration_cast<std::chrono::microseconds>(unscaled * average_interval + 0.5us);",
          "old_text": null,
          "new_text": "d::chrono::duration_cast<std::chrono::microseconds>(unscaled * average_interval + 0.5us);\n",
          "old_line_content": "}",
          "new_line_content": "    return now + std::chrono::duration_cast<std::chrono::microseconds>(unscaled * average_interval + 0.5us);",
          "content_same": false
        },
        {
          "line": 1036,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "group.push_back(node)",
          "old_line_content": "            naMostConnections = node.nKeyedNetGroup;",
          "new_line_content": "        group.push_back(node);",
          "content_same": false
        },
        {
          "line": 3084,
          "old_api": null,
          "new_api": "Write",
          "old_text": null,
          "new_text": "ipHasher(nSeed0, nSeed1).Write(id);\n",
          "old_line_content": "",
          "new_line_content": "    return CSipHasher(nSeed0, nSeed1).Write(id);",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "group.size()",
          "old_line_content": "",
          "new_line_content": "        if (group.size() > nMostConnections || (group.size() == nMostConnections && grouptime > nMostConnectionsTime)) {",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "group.size()",
          "old_line_content": "    // Reduce to the network group with the most connections",
          "new_line_content": "            nMostConnections = group.size();",
          "content_same": false
        },
        {
          "line": 3089,
          "old_api": null,
          "new_api": "GetAsmap",
          "old_text": null,
          "new_text": "drman.GetAsmap()))",
          "old_line_content": "{",
          "new_line_content": "    std::vector<unsigned char> vchNetGroup(ad.GetGroup(addrman.GetAsmap()));",
          "content_same": false
        },
        {
          "line": 3091,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "hNetGroup.size()).",
          "old_line_content": "    // not at socket receive/send time.",
          "new_line_content": "    return GetDeterministicRandomizer(RANDOMIZER_ID_NETGROUP).Write(vchNetGroup.data(), vchNetGroup.size()).Finalize();",
          "content_same": false
        },
        {
          "line": 1047,
          "old_api": null,
          "new_api": "std::move(mapNetGroupNodes[naMostConnections])",
          "old_text": null,
          "new_text": "std::move(mapNetGroupNodes[naMostConnections])",
          "old_line_content": "/** Try to find a connection to evict when the node is full.",
          "new_line_content": "    vEvictionCandidates = std::move(mapNetGroupNodes[naMostConnections]);",
          "content_same": false
        },
        {
          "line": 1050,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "vEvictionCandidates.front()",
          "old_line_content": " *  The strategy used here is to protect a small number of peers",
          "new_line_content": "    return vEvictionCandidates.front().id;",
          "content_same": false
        },
        {
          "line": 3103,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "dr.ToString();\n",
          "old_line_content": "    fs::path path = base_path / (is_incoming ? \"msgs_recv.dat\" : \"msgs_sent.dat\");",
          "new_line_content": "    std::string clean_addr = addr.ToString();",
          "content_same": false
        },
        {
          "line": 3110,
          "old_api": null,
          "new_api": "bridge::fopen(path, \"ab\"),",
          "old_text": null,
          "new_text": "bridge::fopen(path, \"ab\"), ",
          "old_line_content": "    }",
          "new_line_content": "    CAutoFile f(fsbridge::fopen(path, \"ab\"), SER_DISK, CLIENT_VERSION);",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "            if (node->fDisconnect)",
          "new_line_content": "        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 3114,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "g_type.length(); ",
          "old_line_content": "}",
          "new_line_content": "    for (auto i = msg_type.length(); i < CMessageHeader::COMMAND_SIZE; ++i) {",
          "content_same": false
        },
        {
          "line": 1068,
          "old_api": null,
          "new_api": "HasPermission",
          "old_text": null,
          "new_text": "node->HasPermission(NetPermissionFlags::NoBan)",
          "old_line_content": "            bool peer_relay_txes = false;",
          "new_line_content": "            if (node->HasPermission(NetPermissionFlags::NoBan))",
          "content_same": false
        },
        {
          "line": 3117,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "ta.size();\n",
          "old_line_content": "",
          "new_line_content": "    uint32_t size = data.size();",
          "content_same": false
        },
        {
          "line": 1070,
          "old_api": null,
          "new_api": "IsInboundConn",
          "old_text": null,
          "new_text": "node->IsInboundConn()",
          "old_line_content": "            if (node->m_tx_relay != nullptr) {",
          "new_line_content": "            if (!node->IsInboundConn())",
          "content_same": false
        },
        {
          "line": 3118,
          "old_api": null,
          "new_api": "r_writedata32",
          "old_text": null,
          "new_text": "r_writedata32(f, size);\n",
          "old_line_content": "",
          "new_line_content": "    ser_writedata32(f, size);",
          "content_same": false
        },
        {
          "line": 3119,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "ta.size());",
          "old_line_content": "",
          "new_line_content": "    f.write((const char*)data.data(), data.size());",
          "content_same": false
        },
        {
          "line": 1083,
          "old_api": null,
          "new_api": "HasAllDesirableServiceFlags",
          "old_text": null,
          "new_text": "HasAllDesirableServiceFlags(node->nServices)",
          "old_line_content": "    }",
          "new_line_content": "                                               HasAllDesirableServiceFlags(node->nServices),",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": null,
          "new_api": "IsLocal",
          "old_text": null,
          "new_text": "node->addr.IsLocal()",
          "old_line_content": "    if (!node_id_to_evict) {",
          "new_line_content": "                                               node->m_prefer_evict, node->addr.IsLocal(),",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": null,
          "new_api": "ConnectedThroughNetwork",
          "old_text": null,
          "new_text": "node->ConnectedThroughNetwork()",
          "old_line_content": "        return false;",
          "new_line_content": "                                               node->ConnectedThroughNetwork()};",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "vEvictionCandidates.push_back(candidate)",
          "old_line_content": "    }",
          "new_line_content": "            vEvictionCandidates.push_back(candidate);",
          "content_same": false
        },
        {
          "line": 1094,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "        }",
          "new_line_content": "    LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1096,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pnode->GetId()",
          "old_line_content": "    return false;",
          "new_line_content": "        if (pnode->GetId() == *node_id_to_evict) {",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pnode->GetId()",
          "old_line_content": "}",
          "new_line_content": "            LogPrint(BCLog::NET, \"selected %s connection for eviction peer=%d; disconnecting\\n\", pnode->ConnectionTypeAsString(), pnode->GetId());",
          "content_same": false
        },
        {
          "line": 1112,
          "old_api": null,
          "new_api": "WSAGetLastError",
          "old_text": null,
          "new_text": "WSAGetLastError()",
          "old_line_content": "",
          "new_line_content": "        const int nErr = WSAGetLastError();",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"Warning: Unknown socket family\\n\")",
          "old_line_content": "",
          "new_line_content": "        LogPrintf(\"Warning: Unknown socket family\\n\");",
          "content_same": false
        },
        {
          "line": 1125,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "sock->Get()",
          "old_line_content": "}",
          "new_line_content": "    const CAddress addr_bind{MaybeFlipIPv6toCJDNS(GetBindAddress(sock->Get())), NODE_NONE};",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": null,
          "new_api": "AddSocketPermissionFlags",
          "old_text": null,
          "new_text": "hListenSocket.AddSocketPermissionFlags(permissionFlags)",
          "old_line_content": "                                            NetPermissionFlags permissionFlags,",
          "new_line_content": "    hListenSocket.AddSocketPermissionFlags(permissionFlags);",
          "content_same": false
        },
        {
          "line": 1130,
          "old_api": null,
          "new_api": "std::move(sock)",
          "old_text": null,
          "new_text": "std::move(sock)",
          "old_line_content": "                                            const CAddress& addr)",
          "new_line_content": "    CreateNodeFromAcceptedSocket(std::move(sock), permissionFlags, addr_bind, addr);",
          "content_same": false
        },
        {
          "line": 1142,
          "old_api": null,
          "new_api": "NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::Implicit)",
          "old_text": null,
          "new_text": "NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::Implicit)",
          "old_line_content": "    }",
          "new_line_content": "    if (NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::Implicit)) {",
          "content_same": false
        },
        {
          "line": 1143,
          "old_api": null,
          "new_api": "NetPermissions::ClearFlag(permissionFlags, NetPermissionFlags::Implicit)",
          "old_text": null,
          "new_text": "NetPermissions::ClearFlag(permissionFlags, NetPermissionFlags::Implicit)",
          "old_line_content": "",
          "new_line_content": "        NetPermissions::ClearFlag(permissionFlags, NetPermissionFlags::Implicit);",
          "content_same": false
        },
        {
          "line": 1144,
          "old_api": null,
          "new_api": "NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::ForceRelay)",
          "old_text": null,
          "new_text": "NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::ForceRelay)",
          "old_line_content": "    {",
          "new_line_content": "        if (gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::ForceRelay);",
          "content_same": false
        },
        {
          "line": 1146,
          "old_api": null,
          "new_api": "NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::Mempool)",
          "old_text": null,
          "new_text": "NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::Mempool)",
          "old_line_content": "        for (const CNode* pnode : m_nodes) {",
          "new_line_content": "        NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::Mempool);",
          "content_same": false
        },
        {
          "line": 1151,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "    if (!fNetworkActive) {",
          "new_line_content": "        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": null,
          "new_api": "IsInboundConn",
          "old_text": null,
          "new_text": "pnode->IsInboundConn()",
          "old_line_content": "        return;",
          "new_line_content": "            if (pnode->IsInboundConn()) nInbound++;",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "sock->Get()",
          "old_line_content": "    // According to the internet TCP_NODELAY is not carried into accepted sockets",
          "new_line_content": "    if (!IsSelectableSocket(sock->Get()))",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": null,
          "new_api": "IsBanned",
          "old_text": null,
          "new_text": "m_banman->IsBanned(addr)",
          "old_line_content": "",
          "new_line_content": "    bool banned = m_banman && m_banman->IsBanned(addr);",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": null,
          "new_api": "NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::NoBan)",
          "old_text": null,
          "new_text": "NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::NoBan)",
          "old_line_content": "    // Only accept connections from discouraged peers if our inbound slots aren't (almost) full.",
          "new_line_content": "    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::NoBan) && banned)",
          "content_same": false
        },
        {
          "line": 1181,
          "old_api": null,
          "new_api": "IsDiscouraged",
          "old_text": null,
          "new_text": "m_banman->IsDiscouraged(addr)",
          "old_line_content": "",
          "new_line_content": "    bool discouraged = m_banman && m_banman->IsDiscouraged(addr);",
          "content_same": false
        },
        {
          "line": 1182,
          "old_api": null,
          "new_api": "NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::NoBan)",
          "old_text": null,
          "new_text": "NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::NoBan)",
          "old_line_content": "    if (nInbound >= nMaxInbound)",
          "new_line_content": "    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::NoBan) && nInbound + 1 >= nMaxInbound && discouraged)",
          "content_same": false
        },
        {
          "line": 1190,
          "old_api": null,
          "new_api": "AttemptToEvictConnection",
          "old_text": null,
          "new_text": "AttemptToEvictConnection()",
          "old_line_content": "",
          "new_line_content": "        if (!AttemptToEvictConnection()) {",
          "content_same": false
        },
        {
          "line": 1197,
          "old_api": null,
          "new_api": "GetNewNodeId",
          "old_text": null,
          "new_text": "GetNewNodeId()",
          "old_line_content": "    }",
          "new_line_content": "    NodeId id = GetNewNodeId();",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": null,
          "new_api": "Write",
          "old_text": null,
          "new_text": "GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize()",
          "old_line_content": "",
          "new_line_content": "    uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();",
          "content_same": false
        },
        {
          "line": 1202,
          "old_api": null,
          "new_api": "static_cast<ServiceFlags>(nodeServices | NODE_BLOOM)",
          "old_text": null,
          "new_text": "static_cast<ServiceFlags>(nodeServices | NODE_BLOOM)",
          "old_line_content": "    pnode->m_permissionFlags = permissionFlags;",
          "new_line_content": "        nodeServices = static_cast<ServiceFlags>(nodeServices | NODE_BLOOM);",
          "content_same": false
        },
        {
          "line": 1205,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "m_onion_binds.end()",
          "old_line_content": "",
          "new_line_content": "    const bool inbound_onion = std::find(m_onion_binds.begin(), m_onion_binds.end(), addr_bind) != m_onion_binds.end();",
          "content_same": false
        },
        {
          "line": 1207,
          "old_api": null,
          "new_api": "AddRef",
          "old_text": null,
          "new_text": "pnode->AddRef()",
          "old_line_content": "",
          "new_line_content": "    pnode->AddRef();",
          "content_same": false
        },
        {
          "line": 1212,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "addr.ToString()",
          "old_line_content": "",
          "new_line_content": "    LogPrint(BCLog::NET, \"connection from %s accepted\\n\", addr.ToString());",
          "content_same": false
        },
        {
          "line": 1215,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "}",
          "new_line_content": "        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1216,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "m_nodes.push_back(pnode)",
          "old_line_content": "",
          "new_line_content": "        m_nodes.push_back(pnode);",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": null,
          "new_api": "RandAddEvent",
          "old_text": null,
          "new_text": "RandAddEvent((uint32_t)id)",
          "old_line_content": "    switch (conn_type) {",
          "new_line_content": "    RandAddEvent((uint32_t)id);",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "WITH_LOCK(m_nodes_mutex,\n                                         return std::count_if(m_nodes.begin(), m_nodes.end(), [conn_type](CNode* node) { return node->m_conn_type == conn_type; });)",
          "old_line_content": "    // Max total outbound connections already exist",
          "new_line_content": "    int existing_connections = WITH_LOCK(m_nodes_mutex,",
          "content_same": false
        },
        {
          "line": 1246,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "m_nodes.end()",
          "old_line_content": "    CSemaphoreGrant grant(*semOutbound, true);",
          "new_line_content": "                                         return std::count_if(m_nodes.begin(), m_nodes.end(), [conn_type](CNode* node) { return node->m_conn_type == conn_type; }););",
          "content_same": false
        },
        {
          "line": 1255,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "address.c_str()",
          "old_line_content": "    {",
          "new_line_content": "    OpenNetworkConnection(CAddress(), false, &grant, address.c_str(), conn_type);",
          "content_same": false
        },
        {
          "line": 1268,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pnode->GetId()",
          "old_line_content": "        // Disconnect unused nodes",
          "new_line_content": "                    LogPrint(BCLog::NET, \"Network not active, dropping peer=%d\\n\", pnode->GetId());",
          "content_same": false
        },
        {
          "line": 1287,
          "old_api": null,
          "new_api": "CloseSocketDisconnect",
          "old_text": null,
          "new_text": "pnode->CloseSocketDisconnect()",
          "old_line_content": "        }",
          "new_line_content": "                pnode->CloseSocketDisconnect();",
          "content_same": false
        },
        {
          "line": 1290,
          "old_api": null,
          "new_api": "Release",
          "old_text": null,
          "new_text": "pnode->Release()",
          "old_line_content": "        // Delete disconnected nodes",
          "new_line_content": "                pnode->Release();",
          "content_same": false
        },
        {
          "line": 1291,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "m_nodes_disconnected.push_back(pnode)",
          "old_line_content": "        std::list<CNode*> nodes_disconnected_copy = m_nodes_disconnected;",
          "new_line_content": "                m_nodes_disconnected.push_back(pnode);",
          "content_same": false
        },
        {
          "line": 1301,
          "old_api": null,
          "new_api": "GetRefCount",
          "old_text": null,
          "new_text": "pnode->GetRefCount()",
          "old_line_content": "}",
          "new_line_content": "            if (pnode->GetRefCount() <= 0) {",
          "content_same": false
        },
        {
          "line": 1302,
          "old_api": null,
          "new_api": "remove",
          "old_text": null,
          "new_text": "m_nodes_disconnected.remove(pnode)",
          "old_line_content": "",
          "new_line_content": "                m_nodes_disconnected.remove(pnode);",
          "content_same": false
        },
        {
          "line": 1303,
          "old_api": null,
          "new_api": "DeleteNode",
          "old_text": null,
          "new_text": "DeleteNode(pnode)",
          "old_line_content": "void CConnman::NotifyNumConnectionsChanged()",
          "new_line_content": "                DeleteNode(pnode);",
          "content_same": false
        },
        {
          "line": 1314,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "m_nodes.size()",
          "old_line_content": "        }",
          "new_line_content": "        nodes_size = m_nodes.size();",
          "content_same": false
        },
        {
          "line": 1319,
          "old_api": null,
          "new_api": "NotifyNumConnectionsChanged",
          "old_text": null,
          "new_text": "m_client_interface->NotifyNumConnectionsChanged(nodes_size)",
          "old_line_content": "{",
          "new_line_content": "            m_client_interface->NotifyNumConnectionsChanged(nodes_size);",
          "content_same": false
        },
        {
          "line": 1335,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "node.m_last_recv.load()",
          "old_line_content": "        return true;",
          "new_line_content": "    const auto last_recv{node.m_last_recv.load()};",
          "content_same": false
        },
        {
          "line": 1337,
          "old_api": null,
          "new_api": "ShouldRunInactivityChecks",
          "old_text": null,
          "new_text": "ShouldRunInactivityChecks(node, now)",
          "old_line_content": "",
          "new_line_content": "    if (!ShouldRunInactivityChecks(node, now)) return false;",
          "content_same": false
        },
        {
          "line": 1340,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "node.GetId()",
          "old_line_content": "        return true;",
          "new_line_content": "        LogPrint(BCLog::NET, \"socket no message in first %i seconds, %d %d peer=%d\\n\", count_seconds(m_peer_connect_timeout), last_recv.count() != 0, last_send.count() != 0, node.GetId());",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "node.GetId()",
          "old_line_content": "        return true;",
          "new_line_content": "        LogPrint(BCLog::NET, \"socket sending timeout: %is peer=%d\\n\", count_seconds(now - last_send), node.GetId());",
          "content_same": false
        },
        {
          "line": 1350,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "node.GetId()",
          "old_line_content": "        return true;",
          "new_line_content": "        LogPrint(BCLog::NET, \"socket receive timeout: %is peer=%d\\n\", count_seconds(now - last_recv), node.GetId());",
          "content_same": false
        },
        {
          "line": 1355,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "node.GetId()",
          "old_line_content": "",
          "new_line_content": "        LogPrint(BCLog::NET, \"version handshake timeout peer=%d\\n\", node.GetId());",
          "content_same": false
        },
        {
          "line": 1368,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "hListenSocket.sock->Get()",
          "old_line_content": "        //   happens when optimistic write failed, we choose to first drain the",
          "new_line_content": "        recv_set.insert(hListenSocket.sock->Get());",
          "content_same": false
        },
        {
          "line": 1386,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pnode->cs_vSend)",
          "old_line_content": "            continue;",
          "new_line_content": "            LOCK(pnode->cs_vSend);",
          "content_same": false
        },
        {
          "line": 1387,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "pnode->vSendMsg.empty()",
          "old_line_content": "        }",
          "new_line_content": "            select_send = !pnode->vSendMsg.empty();",
          "content_same": false
        },
        {
          "line": 1390,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pnode->cs_hSocket)",
          "old_line_content": "        if (select_send) {",
          "new_line_content": "        LOCK(pnode->cs_hSocket);",
          "content_same": false
        },
        {
          "line": 1397,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "pnode->m_sock->Get()",
          "old_line_content": "    }",
          "new_line_content": "            send_set.insert(pnode->m_sock->Get());",
          "content_same": false
        },
        {
          "line": 1401,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "pnode->m_sock->Get()",
          "old_line_content": "",
          "new_line_content": "            recv_set.insert(pnode->m_sock->Get());",
          "content_same": false
        },
        {
          "line": 1405,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "error_set.empty()",
          "old_line_content": "                            std::set<SOCKET>& send_set,",
          "new_line_content": "    return !recv_set.empty() || !send_set.empty() || !error_set.empty();",
          "content_same": false
        },
        {
          "line": 1415,
          "old_api": null,
          "new_api": "GenerateSelectSet",
          "old_text": null,
          "new_text": "GenerateSelectSet(nodes, recv_select_set, send_select_set, error_select_set)",
          "old_line_content": "    for (SOCKET socket_id : recv_select_set) {",
          "new_line_content": "    if (!GenerateSelectSet(nodes, recv_select_set, send_select_set, error_select_set)) {",
          "content_same": false
        },
        {
          "line": 1416,
          "old_api": null,
          "new_api": "std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS)",
          "old_text": null,
          "new_text": "std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS)",
          "old_line_content": "        pollfds[socket_id].fd = socket_id;",
          "new_line_content": "        interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS));",
          "content_same": false
        },
        {
          "line": 1438,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "pollfds.size()",
          "old_line_content": "",
          "new_line_content": "    vpollfds.reserve(pollfds.size());",
          "content_same": false
        },
        {
          "line": 1440,
          "old_api": null,
          "new_api": "std::move(it.second)",
          "old_text": null,
          "new_text": "std::move(it.second)",
          "old_line_content": "",
          "new_line_content": "        vpollfds.push_back(std::move(it.second));",
          "content_same": false
        },
        {
          "line": 1448,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "recv_set.insert(pollfd_entry.fd)",
          "old_line_content": "void CConnman::SocketEvents(const std::vector<CNode*>& nodes,",
          "new_line_content": "        if (pollfd_entry.revents & POLLIN)            recv_set.insert(pollfd_entry.fd);",
          "content_same": false
        },
        {
          "line": 1449,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "send_set.insert(pollfd_entry.fd)",
          "old_line_content": "                            std::set<SOCKET>& recv_set,",
          "new_line_content": "        if (pollfd_entry.revents & POLLOUT)           send_set.insert(pollfd_entry.fd);",
          "content_same": false
        },
        {
          "line": 1450,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "error_set.insert(pollfd_entry.fd)",
          "old_line_content": "                            std::set<SOCKET>& send_set,",
          "new_line_content": "        if (pollfd_entry.revents & (POLLERR|POLLHUP)) error_set.insert(pollfd_entry.fd);",
          "content_same": false
        },
        {
          "line": 1460,
          "old_api": null,
          "new_api": "GenerateSelectSet",
          "old_text": null,
          "new_text": "GenerateSelectSet(nodes, recv_select_set, send_select_set, error_select_set)",
          "old_line_content": "    // Find which sockets have data to receive",
          "new_line_content": "    if (!GenerateSelectSet(nodes, recv_select_set, send_select_set, error_select_set)) {",
          "content_same": false
        },
        {
          "line": 1461,
          "old_api": null,
          "new_api": "std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS)",
          "old_text": null,
          "new_text": "std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS)",
          "old_line_content": "    //",
          "new_line_content": "        interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS));",
          "content_same": false
        },
        {
          "line": 1477,
          "old_api": null,
          "new_api": "FD_ZERO",
          "old_text": null,
          "new_text": "FD_ZERO(&fdsetError)",
          "old_line_content": "    }",
          "new_line_content": "    FD_ZERO(&fdsetError);",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": null,
          "new_api": "std::max(hSocketMax, hSocket)",
          "old_text": null,
          "new_text": "std::max(hSocketMax, hSocket)",
          "old_line_content": "    }",
          "new_line_content": "        hSocketMax = std::max(hSocketMax, hSocket);",
          "content_same": false
        },
        {
          "line": 1487,
          "old_api": null,
          "new_api": "std::max(hSocketMax, hSocket)",
          "old_text": null,
          "new_text": "std::max(hSocketMax, hSocket)",
          "old_line_content": "    }",
          "new_line_content": "        hSocketMax = std::max(hSocketMax, hSocket);",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": null,
          "new_api": "FD_SET",
          "old_text": null,
          "new_text": "FD_SET(hSocket, &fdsetError)",
          "old_line_content": "    if (interruptNet)",
          "new_line_content": "        FD_SET(hSocket, &fdsetError);",
          "content_same": false
        },
        {
          "line": 1492,
          "old_api": null,
          "new_api": "std::max(hSocketMax, hSocket)",
          "old_text": null,
          "new_text": "std::max(hSocketMax, hSocket)",
          "old_line_content": "        return;",
          "new_line_content": "        hSocketMax = std::max(hSocketMax, hSocket);",
          "content_same": false
        },
        {
          "line": 1495,
          "old_api": null,
          "new_api": "select",
          "old_text": null,
          "new_text": "select(hSocketMax + 1, &fdsetRecv, &fdsetSend, &fdsetError, &timeout)",
          "old_line_content": "    {",
          "new_line_content": "    int nSelect = select(hSocketMax + 1, &fdsetRecv, &fdsetSend, &fdsetError, &timeout);",
          "content_same": false
        },
        {
          "line": 1503,
          "old_api": null,
          "new_api": "NetworkErrorString",
          "old_text": null,
          "new_text": "NetworkErrorString(nErr)",
          "old_line_content": "            return;",
          "new_line_content": "        LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));",
          "content_same": false
        },
        {
          "line": 1505,
          "old_api": null,
          "new_api": "FD_SET",
          "old_text": null,
          "new_text": "FD_SET(i, &fdsetRecv)",
          "old_line_content": "",
          "new_line_content": "            FD_SET(i, &fdsetRecv);",
          "content_same": false
        },
        {
          "line": 1506,
          "old_api": null,
          "new_api": "FD_ZERO",
          "old_text": null,
          "new_text": "FD_ZERO(&fdsetSend)",
          "old_line_content": "    for (SOCKET hSocket : recv_select_set) {",
          "new_line_content": "        FD_ZERO(&fdsetSend);",
          "content_same": false
        },
        {
          "line": 1525,
          "old_api": null,
          "new_api": "FD_ISSET",
          "old_text": null,
          "new_text": "FD_ISSET(hSocket, &fdsetError)",
          "old_line_content": "",
          "new_line_content": "        if (FD_ISSET(hSocket, &fdsetError)) {",
          "content_same": false
        },
        {
          "line": 1526,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "error_set.insert(hSocket)",
          "old_line_content": "void CConnman::SocketHandler()",
          "new_line_content": "            error_set.insert(hSocket);",
          "content_same": false
        },
        {
          "line": 1545,
          "old_api": null,
          "new_api": "Nodes",
          "old_text": null,
          "new_text": "snap.Nodes()",
          "old_line_content": "    // Accept new connections from listening sockets.",
          "new_line_content": "        SocketEvents(snap.Nodes(), recv_set, send_set, error_set);",
          "content_same": false
        },
        {
          "line": 1548,
          "old_api": null,
          "new_api": "Nodes",
          "old_text": null,
          "new_text": "snap.Nodes()",
          "old_line_content": "",
          "new_line_content": "        SocketHandlerConnected(snap.Nodes(), recv_set, send_set, error_set);",
          "content_same": false
        },
        {
          "line": 1552,
          "old_api": null,
          "new_api": "SocketHandlerListening",
          "old_text": null,
          "new_text": "SocketHandlerListening(recv_set)",
          "old_line_content": "                                      const std::set<SOCKET>& error_set)",
          "new_line_content": "    SocketHandlerListening(recv_set);",
          "content_same": false
        },
        {
          "line": 1575,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "pnode->m_sock->Get()",
          "old_line_content": "            // typical socket buffer is 8K-64K",
          "new_line_content": "            recvSet = recv_set.count(pnode->m_sock->Get()) > 0;",
          "content_same": false
        },
        {
          "line": 1576,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "pnode->m_sock->Get()",
          "old_line_content": "            uint8_t pchBuf[0x10000];",
          "new_line_content": "            sendSet = send_set.count(pnode->m_sock->Get()) > 0;",
          "content_same": false
        },
        {
          "line": 1577,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "pnode->m_sock->Get()",
          "old_line_content": "            int nBytes = 0;",
          "new_line_content": "            errorSet = error_set.count(pnode->m_sock->Get()) > 0;",
          "content_same": false
        },
        {
          "line": 1585,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pnode->cs_hSocket)",
          "old_line_content": "            if (nBytes > 0)",
          "new_line_content": "                LOCK(pnode->cs_hSocket);",
          "content_same": false
        },
        {
          "line": 1597,
          "old_api": null,
          "new_api": "RecordBytesRecv",
          "old_text": null,
          "new_text": "RecordBytesRecv(nBytes)",
          "old_line_content": "                        // the single possible partially deserialized message are held by TransportDeserializer",
          "new_line_content": "                RecordBytesRecv(nBytes);",
          "content_same": false
        },
        {
          "line": 1600,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "pnode->vRecvMsg.begin()",
          "old_line_content": "                    {",
          "new_line_content": "                    auto it(pnode->vRecvMsg.begin());",
          "content_same": false
        },
        {
          "line": 1607,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pnode->cs_vProcessMsg)",
          "old_line_content": "                }",
          "new_line_content": "                        LOCK(pnode->cs_vProcessMsg);",
          "content_same": false
        },
        {
          "line": 1608,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "pnode->vRecvMsg.begin()",
          "old_line_content": "            }",
          "new_line_content": "                        pnode->vProcessMsg.splice(pnode->vProcessMsg.end(), pnode->vRecvMsg, pnode->vRecvMsg.begin(), it);",
          "content_same": false
        },
        {
          "line": 1612,
          "old_api": null,
          "new_api": "WakeMessageHandler",
          "old_text": null,
          "new_text": "WakeMessageHandler()",
          "old_line_content": "                if (!pnode->fDisconnect) {",
          "new_line_content": "                    WakeMessageHandler();",
          "content_same": false
        },
        {
          "line": 1619,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pnode->GetId()",
          "old_line_content": "                // error",
          "new_line_content": "                    LogPrint(BCLog::NET, \"socket closed for peer=%d\\n\", pnode->GetId());",
          "content_same": false
        },
        {
          "line": 1621,
          "old_api": null,
          "new_api": "CloseSocketDisconnect",
          "old_text": null,
          "new_text": "pnode->CloseSocketDisconnect()",
          "old_line_content": "                if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)",
          "new_line_content": "                pnode->CloseSocketDisconnect();",
          "content_same": false
        },
        {
          "line": 1630,
          "old_api": null,
          "new_api": "NetworkErrorString",
          "old_text": null,
          "new_text": "NetworkErrorString(nErr)",
          "old_line_content": "",
          "new_line_content": "                        LogPrint(BCLog::NET, \"socket recv error for peer=%d: %s\\n\", pnode->GetId(), NetworkErrorString(nErr));",
          "content_same": false
        },
        {
          "line": 1632,
          "old_api": null,
          "new_api": "CloseSocketDisconnect",
          "old_text": null,
          "new_text": "pnode->CloseSocketDisconnect()",
          "old_line_content": "            // Send data",
          "new_line_content": "                    pnode->CloseSocketDisconnect();",
          "content_same": false
        },
        {
          "line": 1639,
          "old_api": null,
          "new_api": "SocketSendData",
          "old_text": null,
          "new_text": "SocketSendData(*pnode)",
          "old_line_content": "}",
          "new_line_content": "            size_t bytes_sent = WITH_LOCK(pnode->cs_vSend, return SocketSendData(*pnode));",
          "content_same": false
        },
        {
          "line": 1640,
          "old_api": null,
          "new_api": "RecordBytesSent",
          "old_text": null,
          "new_text": "RecordBytesSent(bytes_sent)",
          "old_line_content": "",
          "new_line_content": "            if (bytes_sent) RecordBytesSent(bytes_sent);",
          "content_same": false
        },
        {
          "line": 1643,
          "old_api": null,
          "new_api": "InactivityCheck",
          "old_text": null,
          "new_text": "InactivityCheck(*pnode)",
          "old_line_content": "    for (const ListenSocket& listen_socket : vhListenSocket) {",
          "new_line_content": "        if (InactivityCheck(*pnode)) pnode->fDisconnect = true;",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "listen_socket.sock->Get()",
          "old_line_content": "void CConnman::ThreadSocketHandler()",
          "new_line_content": "        if (recv_set.count(listen_socket.sock->Get()) > 0) {",
          "content_same": false
        },
        {
          "line": 1654,
          "old_api": null,
          "new_api": "AcceptConnection",
          "old_text": null,
          "new_text": "AcceptConnection(listen_socket)",
          "old_line_content": "{",
          "new_line_content": "            AcceptConnection(listen_socket);",
          "content_same": false
        },
        {
          "line": 1661,
          "old_api": null,
          "new_api": "SetSyscallSandboxPolicy",
          "old_text": null,
          "new_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET)",
          "old_line_content": "    }",
          "new_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET);",
          "content_same": false
        },
        {
          "line": 1664,
          "old_api": null,
          "new_api": "DisconnectNodes",
          "old_text": null,
          "new_text": "DisconnectNodes()",
          "old_line_content": "void CConnman::WakeMessageHandler()",
          "new_line_content": "        DisconnectNodes();",
          "content_same": false
        },
        {
          "line": 1665,
          "old_api": null,
          "new_api": "NotifyNumConnectionsChanged",
          "old_text": null,
          "new_text": "NotifyNumConnectionsChanged()",
          "old_line_content": "{",
          "new_line_content": "        NotifyNumConnectionsChanged();",
          "content_same": false
        },
        {
          "line": 1666,
          "old_api": null,
          "new_api": "SocketHandler",
          "old_text": null,
          "new_text": "SocketHandler()",
          "old_line_content": "    {",
          "new_line_content": "        SocketHandler();",
          "content_same": false
        },
        {
          "line": 1673,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(mutexMsgProc)",
          "old_line_content": "void CConnman::ThreadDNSAddressSeed()",
          "new_line_content": "        LOCK(mutexMsgProc);",
          "content_same": false
        },
        {
          "line": 1676,
          "old_api": null,
          "new_api": "notify_one",
          "old_text": null,
          "new_text": "condMsgProc.notify_one()",
          "old_line_content": "    FastRandomContext rng;",
          "new_line_content": "    condMsgProc.notify_one();",
          "content_same": false
        },
        {
          "line": 1681,
          "old_api": null,
          "new_api": "SetSyscallSandboxPolicy",
          "old_text": null,
          "new_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::INITIALIZATION_DNS_SEED)",
          "old_line_content": "",
          "new_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::INITIALIZATION_DNS_SEED);",
          "content_same": false
        },
        {
          "line": 1683,
          "old_api": null,
          "new_api": "DNSSeeds",
          "old_text": null,
          "new_text": "Params().DNSSeeds()",
          "old_line_content": "        // When -forcednsseed is provided, query all.",
          "new_line_content": "    std::vector<std::string> seeds = Params().DNSSeeds();",
          "content_same": false
        },
        {
          "line": 1688,
          "old_api": null,
          "new_api": "GetBoolArg",
          "old_text": null,
          "new_text": "gArgs.GetBoolArg(\"-forcednsseed\", DEFAULT_FORCEDNSSEED)",
          "old_line_content": "        // deleted.",
          "new_line_content": "    if (gArgs.GetBoolArg(\"-forcednsseed\", DEFAULT_FORCEDNSSEED)) {",
          "content_same": false
        },
        {
          "line": 1690,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "seeds.size()",
          "old_line_content": "    }",
          "new_line_content": "        seeds_right_now = seeds.size();",
          "content_same": false
        },
        {
          "line": 1691,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "addrman.size()",
          "old_line_content": "",
          "new_line_content": "    } else if (addrman.size() == 0) {",
          "content_same": false
        },
        {
          "line": 1695,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "seeds.size()",
          "old_line_content": "    //   creating fewer identifying DNS requests, reduces trust by",
          "new_line_content": "        seeds_right_now = seeds.size();",
          "content_same": false
        },
        {
          "line": 1716,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "addrman.size()",
          "old_line_content": "                    // this thread entirely freeing up its resources",
          "new_line_content": "            if (addrman.size() > 0) {",
          "content_same": false
        },
        {
          "line": 1719,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "to_wait.count()",
          "old_line_content": "                    to_wait -= w;",
          "new_line_content": "                while (to_wait.count() > 0) {",
          "content_same": false
        },
        {
          "line": 1724,
          "old_api": null,
          "new_api": "sleep_for",
          "old_text": null,
          "new_text": "interruptNet.sleep_for(w)",
          "old_line_content": "                        for (const CNode* pnode : m_nodes) {",
          "new_line_content": "                    if (!interruptNet.sleep_for(w)) return;",
          "content_same": false
        },
        {
          "line": 1729,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "                        if (found > 0) {",
          "new_line_content": "                        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1736,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"%d addresses found from DNS seeds\\n\", found)",
          "old_line_content": "                    }",
          "new_line_content": "                            LogPrintf(\"%d addresses found from DNS seeds\\n\", found);",
          "content_same": false
        },
        {
          "line": 1737,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"P2P peers available. Finished DNS seeding.\\n\")",
          "old_line_content": "                }",
          "new_line_content": "                            LogPrintf(\"P2P peers available. Finished DNS seeding.\\n\");",
          "content_same": false
        },
        {
          "line": 1739,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"P2P peers available. Skipped DNS seeding.\\n\")",
          "old_line_content": "        }",
          "new_line_content": "                            LogPrintf(\"P2P peers available. Skipped DNS seeding.\\n\");",
          "content_same": false
        },
        {
          "line": 1759,
          "old_api": null,
          "new_api": "AddAddrFetch",
          "old_text": null,
          "new_text": "AddAddrFetch(seed)",
          "old_line_content": "            CNetAddr resolveSource;",
          "new_line_content": "            AddAddrFetch(seed);",
          "content_same": false
        },
        {
          "line": 1763,
          "old_api": null,
          "new_api": "GetDesirableServiceFlags",
          "old_text": null,
          "new_text": "GetDesirableServiceFlags(NODE_NONE)",
          "old_line_content": "            unsigned int nMaxIPs = 256; // Limits number of IPs learned from a DNS seed",
          "new_line_content": "            ServiceFlags requiredServiceBits = GetDesirableServiceFlags(NODE_NONE);",
          "content_same": false
        },
        {
          "line": 1766,
          "old_api": null,
          "new_api": "SetInternal",
          "old_text": null,
          "new_text": "resolveSource.SetInternal(host)",
          "old_line_content": "                    int nOneDay = 24*3600;",
          "new_line_content": "            if (!resolveSource.SetInternal(host)) {",
          "content_same": false
        },
        {
          "line": 1770,
          "old_api": null,
          "new_api": "LookupHost",
          "old_text": null,
          "new_text": "LookupHost(host, vIPs, nMaxIPs, true)",
          "old_line_content": "                    found++;",
          "new_line_content": "            if (LookupHost(host, vIPs, nMaxIPs, true)) {",
          "content_same": false
        },
        {
          "line": 1773,
          "old_api": null,
          "new_api": "GetDefaultPort",
          "old_text": null,
          "new_text": "Params().GetDefaultPort()",
          "old_line_content": "            } else {",
          "new_line_content": "                    CAddress addr = CAddress(CService(ip, Params().GetDefaultPort()), requiredServiceBits);",
          "content_same": false
        },
        {
          "line": 1774,
          "old_api": null,
          "new_api": "randrange",
          "old_text": null,
          "new_text": "rng.randrange(4*nOneDay)",
          "old_line_content": "                // We now avoid directly using results from DNS Seeds which do not support service bit filtering,",
          "new_line_content": "                    addr.nTime = GetTime() - 3*nOneDay - rng.randrange(4*nOneDay); // use a random age between 3 and 7 days old",
          "content_same": false
        },
        {
          "line": 1775,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "vAdd.push_back(addr)",
          "old_line_content": "                // instead using them as a addrfetch to get nodes with our desired service bits.",
          "new_line_content": "                    vAdd.push_back(addr);",
          "content_same": false
        },
        {
          "line": 1778,
          "old_api": null,
          "new_api": "Add",
          "old_text": null,
          "new_text": "addrman.Add(vAdd, resolveSource)",
          "old_line_content": "        }",
          "new_line_content": "                addrman.Add(vAdd, resolveSource);",
          "content_same": false
        },
        {
          "line": 1782,
          "old_api": null,
          "new_api": "AddAddrFetch",
          "old_text": null,
          "new_text": "AddAddrFetch(seed)",
          "old_line_content": "}",
          "new_line_content": "                AddAddrFetch(seed);",
          "content_same": false
        },
        {
          "line": 1787,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"%d addresses found from DNS seeds\\n\", found)",
          "old_line_content": "",
          "new_line_content": "    LogPrintf(\"%d addresses found from DNS seeds\\n\", found);",
          "content_same": false
        },
        {
          "line": 1792,
          "old_api": null,
          "new_api": "GetTimeMillis",
          "old_text": null,
          "new_text": "GetTimeMillis()",
          "old_line_content": "}",
          "new_line_content": "    int64_t nStart = GetTimeMillis();",
          "content_same": false
        },
        {
          "line": 1794,
          "old_api": null,
          "new_api": "DumpPeerAddresses",
          "old_text": null,
          "new_text": "DumpPeerAddresses(::gArgs, addrman)",
          "old_line_content": "void CConnman::ProcessAddrFetch()",
          "new_line_content": "    DumpPeerAddresses(::gArgs, addrman);",
          "content_same": false
        },
        {
          "line": 1796,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "LogPrint(BCLog::NET, \"Flushed %d addresses to peers.dat  %dms\\n\",\n           addrman.size(), GetTimeMillis() - nStart)",
          "old_line_content": "    std::string strDest;",
          "new_line_content": "    LogPrint(BCLog::NET, \"Flushed %d addresses to peers.dat  %dms\\n\",",
          "content_same": false
        },
        {
          "line": 1797,
          "old_api": null,
          "new_api": "GetTimeMillis",
          "old_text": null,
          "new_text": "GetTimeMillis()",
          "old_line_content": "    {",
          "new_line_content": "           addrman.size(), GetTimeMillis() - nStart);",
          "content_same": false
        },
        {
          "line": 1804,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_addr_fetches_mutex)",
          "old_line_content": "    CAddress addr;",
          "new_line_content": "        LOCK(m_addr_fetches_mutex);",
          "content_same": false
        },
        {
          "line": 1805,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "m_addr_fetches.empty()",
          "old_line_content": "    CSemaphoreGrant grant(*semOutbound, true);",
          "new_line_content": "        if (m_addr_fetches.empty())",
          "content_same": false
        },
        {
          "line": 1808,
          "old_api": null,
          "new_api": "pop_front",
          "old_text": null,
          "new_text": "m_addr_fetches.pop_front()",
          "old_line_content": "    }",
          "new_line_content": "        m_addr_fetches.pop_front();",
          "content_same": false
        },
        {
          "line": 1813,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "strDest.c_str()",
          "old_line_content": "    return m_try_another_outbound_peer;",
          "new_line_content": "        OpenNetworkConnection(addr, false, &grant, strDest.c_str(), ConnectionType::ADDR_FETCH);",
          "content_same": false
        },
        {
          "line": 1825,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::NET, \"net: setting try another outbound peer=%s\\n\", flag ? \"true\" : \"false\")",
          "old_line_content": "// Also exclude peers that haven't finished initial connection handshake yet",
          "new_line_content": "    LogPrint(BCLog::NET, \"net: setting try another outbound peer=%s\\n\", flag ? \"true\" : \"false\");",
          "content_same": false
        },
        {
          "line": 1838,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "    }",
          "new_line_content": "        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1840,
          "old_api": null,
          "new_api": "IsFullOutboundConn",
          "old_text": null,
          "new_text": "pnode->IsFullOutboundConn()",
          "old_line_content": "}",
          "new_line_content": "            if (pnode->fSuccessfullyConnected && !pnode->fDisconnect && pnode->IsFullOutboundConn()) {",
          "content_same": false
        },
        {
          "line": 1845,
          "old_api": null,
          "new_api": "std::max(full_outbound_peers - m_max_outbound_full_relay, 0)",
          "old_text": null,
          "new_text": "std::max(full_outbound_peers - m_max_outbound_full_relay, 0)",
          "old_line_content": "    {",
          "new_line_content": "    return std::max(full_outbound_peers - m_max_outbound_full_relay, 0);",
          "content_same": false
        },
        {
          "line": 1852,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "    }",
          "new_line_content": "        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1854,
          "old_api": null,
          "new_api": "IsBlockOnlyConn",
          "old_text": null,
          "new_text": "pnode->IsBlockOnlyConn()",
          "old_line_content": "}",
          "new_line_content": "            if (pnode->fSuccessfullyConnected && !pnode->fDisconnect && pnode->IsBlockOnlyConn()) {",
          "content_same": false
        },
        {
          "line": 1859,
          "old_api": null,
          "new_api": "std::max(block_relay_peers - m_max_outbound_block_relay, 0)",
          "old_text": null,
          "new_text": "std::max(block_relay_peers - m_max_outbound_block_relay, 0)",
          "old_line_content": "    // Connect to specific addresses",
          "new_line_content": "    return std::max(block_relay_peers - m_max_outbound_block_relay, 0);",
          "content_same": false
        },
        {
          "line": 1866,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "connect.empty()",
          "old_line_content": "            {",
          "new_line_content": "    if (!connect.empty())",
          "content_same": false
        },
        {
          "line": 1870,
          "old_api": null,
          "new_api": "ProcessAddrFetch",
          "old_text": null,
          "new_text": "ProcessAddrFetch()",
          "old_line_content": "                {",
          "new_line_content": "            ProcessAddrFetch();",
          "content_same": false
        },
        {
          "line": 1874,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "strAddr.c_str()",
          "old_line_content": "            }",
          "new_line_content": "                OpenNetworkConnection(addr, false, nullptr, strAddr.c_str(), ConnectionType::MANUAL);",
          "content_same": false
        },
        {
          "line": 1877,
          "old_api": null,
          "new_api": "std::chrono::milliseconds(500)",
          "old_text": null,
          "new_text": "std::chrono::milliseconds(500)",
          "old_line_content": "        }",
          "new_line_content": "                    if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))",
          "content_same": false
        },
        {
          "line": 1891,
          "old_api": null,
          "new_api": "PoissonNextSend",
          "old_text": null,
          "new_text": "PoissonNextSend(start, EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL)",
          "old_line_content": "    }",
          "new_line_content": "    auto next_extra_block_relay = PoissonNextSend(start, EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL);",
          "content_same": false
        },
        {
          "line": 1892,
          "old_api": null,
          "new_api": "GetBoolArg",
          "old_text": null,
          "new_text": "gArgs.GetBoolArg(\"-dnsseed\", DEFAULT_DNSSEED)",
          "old_line_content": "",
          "new_line_content": "    const bool dnsseed = gArgs.GetBoolArg(\"-dnsseed\", DEFAULT_DNSSEED);",
          "content_same": false
        },
        {
          "line": 1893,
          "old_api": null,
          "new_api": "GetBoolArg",
          "old_text": null,
          "new_text": "gArgs.GetBoolArg(\"-fixedseeds\", DEFAULT_FIXEDSEEDS)",
          "old_line_content": "    while (!interruptNet)",
          "new_line_content": "    bool add_fixed_seeds = gArgs.GetBoolArg(\"-fixedseeds\", DEFAULT_FIXEDSEEDS);",
          "content_same": false
        },
        {
          "line": 1896,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"Fixed seeds are disabled\\n\")",
          "old_line_content": "",
          "new_line_content": "        LogPrintf(\"Fixed seeds are disabled\\n\");",
          "content_same": false
        },
        {
          "line": 1901,
          "old_api": null,
          "new_api": "ProcessAddrFetch",
          "old_text": null,
          "new_text": "ProcessAddrFetch()",
          "old_line_content": "        if (interruptNet)",
          "new_line_content": "        ProcessAddrFetch();",
          "content_same": false
        },
        {
          "line": 1903,
          "old_api": null,
          "new_api": "std::chrono::milliseconds(500)",
          "old_text": null,
          "new_text": "std::chrono::milliseconds(500)",
          "old_line_content": "",
          "new_line_content": "        if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))",
          "content_same": false
        },
        {
          "line": 1910,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "addrman.size()",
          "old_line_content": "            // It is cheapest to check if enough time has passed first.",
          "new_line_content": "        if (add_fixed_seeds && addrman.size() == 0) {",
          "content_same": false
        },
        {
          "line": 1917,
          "old_api": null,
          "new_api": "GetTime<std::chrono::seconds>()",
          "old_text": null,
          "new_text": "GetTime<std::chrono::seconds>()",
          "old_line_content": "            if (!add_fixed_seeds_now && !dnsseed) {",
          "new_line_content": "            if (GetTime<std::chrono::seconds>() > start + std::chrono::minutes{1}) {",
          "content_same": false
        },
        {
          "line": 1924,
          "old_api": null,
          "new_api": "LOCK2",
          "old_text": null,
          "new_text": "LOCK2(m_addr_fetches_mutex, m_added_nodes_mutex)",
          "old_line_content": "",
          "new_line_content": "                LOCK2(m_addr_fetches_mutex, m_added_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1925,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "m_added_nodes.empty()",
          "old_line_content": "            if (add_fixed_seeds_now) {",
          "new_line_content": "                if (m_addr_fetches.empty() && m_added_nodes.empty()) {",
          "content_same": false
        },
        {
          "line": 1933,
          "old_api": null,
          "new_api": "SetInternal",
          "old_text": null,
          "new_text": "local.SetInternal(\"fixedseeds\")",
          "old_line_content": "        //",
          "new_line_content": "                local.SetInternal(\"fixedseeds\");",
          "content_same": false
        },
        {
          "line": 1934,
          "old_api": null,
          "new_api": "FixedSeeds",
          "old_text": null,
          "new_text": "Params().FixedSeeds()",
          "old_line_content": "        // Choose an address to connect to based on most recently seen",
          "new_line_content": "                addrman.Add(ConvertSeeds(Params().FixedSeeds()), local);",
          "content_same": false
        },
        {
          "line": 1950,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "                // is to not use multiple of our limited outbound slots on a single netgroup",
          "new_line_content": "            LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1952,
          "old_api": null,
          "new_api": "IsFullOutboundConn",
          "old_text": null,
          "new_text": "pnode->IsFullOutboundConn()",
          "old_line_content": "                // also have the added issue that they could be attacker controlled and used",
          "new_line_content": "                if (pnode->IsFullOutboundConn()) nOutboundFullRelay++;",
          "content_same": false
        },
        {
          "line": 1953,
          "old_api": null,
          "new_api": "IsBlockOnlyConn",
          "old_text": null,
          "new_text": "pnode->IsBlockOnlyConn()",
          "old_line_content": "                // to prevent us from connecting to particular hosts if we used them here.",
          "new_line_content": "                if (pnode->IsBlockOnlyConn()) nOutboundBlockRelay++;",
          "content_same": false
        },
        {
          "line": 1974,
          "old_api": null,
          "new_api": "GetTime<std::chrono::microseconds>()",
          "old_text": null,
          "new_text": "GetTime<std::chrono::microseconds>()",
          "old_line_content": "        // priority. Then we open OUTBOUND_FULL_RELAY priority until we",
          "new_line_content": "        auto now = GetTime<std::chrono::microseconds>();",
          "content_same": false
        },
        {
          "line": 1989,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "m_anchors.empty()",
          "old_line_content": "            conn_type = ConnectionType::BLOCK_RELAY;",
          "new_line_content": "        if (!m_anchors.empty() && (nOutboundBlockRelay < m_max_outbound_block_relay)) {",
          "content_same": false
        },
        {
          "line": 1996,
          "old_api": null,
          "new_api": "GetTryNewOutboundPeer",
          "old_text": null,
          "new_text": "GetTryNewOutboundPeer()",
          "old_line_content": "            //",
          "new_line_content": "        } else if (GetTryNewOutboundPeer()) {",
          "content_same": false
        },
        {
          "line": 2020,
          "old_api": null,
          "new_api": "PoissonNextSend",
          "old_text": null,
          "new_text": "PoissonNextSend(now, EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL)",
          "old_line_content": "        } else {",
          "new_line_content": "            next_extra_block_relay = PoissonNextSend(now, EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL);",
          "content_same": false
        },
        {
          "line": 2023,
          "old_api": null,
          "new_api": "PoissonNextSend",
          "old_text": null,
          "new_text": "PoissonNextSend(now, FEELER_INTERVAL)",
          "old_line_content": "        }",
          "new_line_content": "            next_feeler = PoissonNextSend(now, FEELER_INTERVAL);",
          "content_same": false
        },
        {
          "line": 2037,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "m_anchors.empty()",
          "old_line_content": "                addrConnect = addr;",
          "new_line_content": "            if (anchor && !m_anchors.empty()) {",
          "content_same": false
        },
        {
          "line": 2039,
          "old_api": null,
          "new_api": "pop_back",
          "old_text": null,
          "new_text": "m_anchors.pop_back()",
          "old_line_content": "                break;",
          "new_line_content": "                m_anchors.pop_back();",
          "content_same": false
        },
        {
          "line": 2040,
          "old_api": null,
          "new_api": "IsReachable",
          "old_text": null,
          "new_text": "IsReachable(addr)",
          "old_line_content": "            }",
          "new_line_content": "                if (!addr.IsValid() || IsLocal(addr) || !IsReachable(addr) ||",
          "content_same": false
        },
        {
          "line": 2041,
          "old_api": null,
          "new_api": "HasAllDesirableServiceFlags",
          "old_text": null,
          "new_text": "HasAllDesirableServiceFlags(addr.nServices)",
          "old_line_content": "",
          "new_line_content": "                    !HasAllDesirableServiceFlags(addr.nServices) ||",
          "content_same": false
        },
        {
          "line": 2042,
          "old_api": null,
          "new_api": "GetAsmap",
          "old_text": null,
          "new_text": "addrman.GetAsmap()",
          "old_line_content": "            // If we didn't find an appropriate destination after trying 100 addresses fetched from addrman,",
          "new_line_content": "                    setConnected.count(addr.GetGroup(addrman.GetAsmap()))) continue;",
          "content_same": false
        },
        {
          "line": 2044,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "addrConnect.ToString()",
          "old_line_content": "            // already-connected network ranges, ...) before trying new addrman addresses.",
          "new_line_content": "                LogPrint(BCLog::NET, \"Trying to make an anchor connection to %s\\n\", addrConnect.ToString());",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2055,
          "old_api": "SelectTriedCollision",
          "new_api": null,
          "old_text": "addrman.SelectTriedCollision()",
          "new_text": null,
          "old_line_content": "                std::tie(addr, addr_last_try) = addrman.SelectTriedCollision();",
          "new_line_content": "            CAddress addr;",
          "content_same": false
        },
        {
          "line": 2057,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "addr.IsValid()",
          "new_text": null,
          "old_line_content": "                if (!addr.IsValid()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2060,
          "old_api": "Select",
          "new_api": null,
          "old_text": "addrman.Select(true)",
          "new_text": null,
          "old_line_content": "                    std::tie(addr, addr_last_try) = addrman.Select(true);",
          "new_line_content": "                // an empty (invalid) address if there are no collisions to try.",
          "content_same": false
        },
        {
          "line": 2069,
          "old_api": "Select",
          "new_api": null,
          "old_text": "addrman.Select(true)",
          "new_text": null,
          "old_line_content": "                    std::tie(addr, addr_last_try) = addrman.Select(true);",
          "new_line_content": "                    // peer that we're already connected to, just mark that",
          "content_same": false
        },
        {
          "line": 2077,
          "old_api": "GetAsmap",
          "new_api": null,
          "old_text": "addrman.GetAsmap()",
          "new_text": null,
          "old_line_content": "            if (!fFeeler && setConnected.count(addr.GetGroup(addrman.GetAsmap()))) {",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 2082,
          "old_api": "IsLocal",
          "new_api": null,
          "old_text": "IsLocal(addr)",
          "new_text": null,
          "old_line_content": "            if (!addr.IsValid() || IsLocal(addr)) {",
          "new_line_content": "            // Require outbound connections, other than feelers, to be to distinct network groups",
          "content_same": false
        },
        {
          "line": 2086,
          "old_api": "IsReachable",
          "new_api": null,
          "old_text": "IsReachable(addr)",
          "new_text": null,
          "old_line_content": "            if (!IsReachable(addr))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2096,
          "old_api": "HasAllDesirableServiceFlags",
          "new_api": null,
          "old_text": "HasAllDesirableServiceFlags(addr.nServices)",
          "new_text": null,
          "old_line_content": "            if (!fFeeler && !HasAllDesirableServiceFlags(addr.nServices)) {",
          "new_line_content": "            if (nANow - addr_last_try < 600 && nTries < 30)",
          "content_same": false
        },
        {
          "line": 2098,
          "old_api": "MayHaveUsefulAddressDB",
          "new_api": null,
          "old_text": "MayHaveUsefulAddressDB(addr.nServices)",
          "new_text": null,
          "old_line_content": "            } else if (fFeeler && !MayHaveUsefulAddressDB(addr.nServices)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2107,
          "old_api": "GetNetwork",
          "new_api": null,
          "old_text": "addr.GetNetwork()",
          "new_text": null,
          "old_line_content": "            if (addr.GetPort() != Params().GetDefaultPort(addr.GetNetwork()) && nTries < 50) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2115,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "addrConnect.IsValid()",
          "new_text": null,
          "old_line_content": "        if (addrConnect.IsValid()) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2119,
          "old_api": "GetRandInt",
          "new_api": null,
          "old_text": "GetRandInt(FEELER_SLEEP_WINDOW * 1000)",
          "new_text": null,
          "old_line_content": "                int randsleep = GetRandInt(FEELER_SLEEP_WINDOW * 1000);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2120,
          "old_api": "std::chrono::milliseconds(randsleep)",
          "new_api": null,
          "old_text": "std::chrono::milliseconds(randsleep)",
          "new_text": null,
          "old_line_content": "                if (!interruptNet.sleep_for(std::chrono::milliseconds(randsleep)))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2122,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "addrConnect.ToString()",
          "new_text": null,
          "old_line_content": "                LogPrint(BCLog::NET, \"Making feeler connection to %s\\n\", addrConnect.ToString());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2133,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "    LOCK(m_nodes_mutex);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2135,
          "old_api": "IsBlockOnlyConn",
          "new_api": null,
          "old_text": "pnode->IsBlockOnlyConn()",
          "new_text": null,
          "old_line_content": "        if (pnode->IsBlockOnlyConn()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2136,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "ret.push_back(pnode->addr)",
          "new_text": null,
          "old_line_content": "            ret.push_back(pnode->addr);",
          "new_line_content": "std::vector<CAddress> CConnman::GetCurrentBlockRelayOnlyConns() const",
          "content_same": false
        },
        {
          "line": 2149,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_added_nodes_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_added_nodes_mutex);",
          "new_line_content": "std::vector<AddedNodeInfo> CConnman::GetAddedNodeInfo() const",
          "content_same": false
        },
        {
          "line": 2150,
          "old_api": "size",
          "new_api": null,
          "old_text": "m_added_nodes.size()",
          "new_text": null,
          "old_line_content": "        ret.reserve(m_added_nodes.size());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2151,
          "old_api": "std::back_inserter(lAddresses)",
          "new_api": null,
          "old_text": "std::back_inserter(lAddresses)",
          "new_text": null,
          "old_line_content": "        std::copy(m_added_nodes.cbegin(), m_added_nodes.cend(), std::back_inserter(lAddresses));",
          "new_line_content": "    std::vector<AddedNodeInfo> ret;",
          "content_same": false
        },
        {
          "line": 2159,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_nodes_mutex);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2161,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "pnode->addr.IsValid()",
          "new_text": null,
          "old_line_content": "            if (pnode->addr.IsValid()) {",
          "new_line_content": "    // Build a map of all already connected addresses (by IP:port and by name) to inbound/outbound and resolved CService",
          "content_same": false
        },
        {
          "line": 2162,
          "old_api": "IsInboundConn",
          "new_api": null,
          "old_text": "pnode->IsInboundConn()",
          "new_text": null,
          "old_line_content": "                mapConnected[pnode->addr] = pnode->IsInboundConn();",
          "new_line_content": "    std::map<CService, bool> mapConnected;",
          "content_same": false
        },
        {
          "line": 2166,
          "old_api": "static_cast<const CService&>(pnode->addr)",
          "new_api": null,
          "old_text": "static_cast<const CService&>(pnode->addr)",
          "new_text": null,
          "old_line_content": "                mapConnectedByName[std::move(addrName)] = std::make_pair(pnode->IsInboundConn(), static_cast<const CService&>(pnode->addr));",
          "new_line_content": "        for (const CNode* pnode : m_nodes) {",
          "content_same": false
        },
        {
          "line": 2173,
          "old_api": "CService",
          "new_api": null,
          "old_text": "CService()",
          "new_text": null,
          "old_line_content": "        AddedNodeInfo addedNode{strAddNode, CService(), false, false};",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2174,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "service.IsValid()",
          "new_text": null,
          "old_line_content": "        if (service.IsValid()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2176,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapConnected.find(service)",
          "new_text": null,
          "old_line_content": "            auto it = mapConnected.find(service);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2177,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapConnected.end()",
          "new_text": null,
          "old_line_content": "            if (it != mapConnected.end()) {",
          "new_line_content": "    for (const std::string& strAddNode : lAddresses) {",
          "content_same": false
        },
        {
          "line": 2184,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapConnectedByName.find(strAddNode)",
          "new_text": null,
          "old_line_content": "            auto it = mapConnectedByName.find(strAddNode);",
          "new_line_content": "                addedNode.resolvedAddress = service;",
          "content_same": false
        },
        {
          "line": 2185,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapConnectedByName.end()",
          "new_text": null,
          "old_line_content": "            if (it != mapConnectedByName.end()) {",
          "new_line_content": "                addedNode.fConnected = true;",
          "content_same": false
        },
        {
          "line": 2199,
          "old_api": "SetSyscallSandboxPolicy",
          "new_api": null,
          "old_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET_ADD_CONNECTION)",
          "new_text": null,
          "old_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET_ADD_CONNECTION);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2203,
          "old_api": "GetAddedNodeInfo",
          "new_api": null,
          "old_text": "GetAddedNodeInfo()",
          "new_text": null,
          "old_line_content": "        std::vector<AddedNodeInfo> vInfo = GetAddedNodeInfo();",
          "new_line_content": "void CConnman::ThreadOpenAddedConnections()",
          "content_same": false
        },
        {
          "line": 2207,
          "old_api": "TryAcquire",
          "new_api": null,
          "old_text": "grant.TryAcquire()",
          "new_text": null,
          "old_line_content": "                if (!grant.TryAcquire()) {",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2214,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "info.strAddedNode.c_str()",
          "new_text": null,
          "old_line_content": "                OpenNetworkConnection(addr, false, &grant, info.strAddedNode.c_str(), ConnectionType::MANUAL);",
          "new_line_content": "                    // If we've used up our semaphore and need a new one, let's not wait here since while we are waiting",
          "content_same": false
        },
        {
          "line": 2215,
          "old_api": "std::chrono::milliseconds(500)",
          "new_api": null,
          "old_text": "std::chrono::milliseconds(500)",
          "new_text": null,
          "old_line_content": "                if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))",
          "new_line_content": "                    // the addednodeinfo state might change.",
          "content_same": false
        },
        {
          "line": 2228,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(conn_type != ConnectionType::INBOUND)",
          "new_text": null,
          "old_line_content": "    assert(conn_type != ConnectionType::INBOUND);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2240,
          "old_api": "IsBanned",
          "new_api": null,
          "old_text": "m_banman->IsBanned(addrConnect)",
          "new_text": null,
          "old_line_content": "        bool banned_or_discouraged = m_banman && (m_banman->IsDiscouraged(addrConnect) || m_banman->IsBanned(addrConnect));",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 2241,
          "old_api": "AlreadyConnectedToAddress",
          "new_api": null,
          "old_text": "AlreadyConnectedToAddress(addrConnect)",
          "new_text": null,
          "old_line_content": "        if (IsLocal(addrConnect) || banned_or_discouraged || AlreadyConnectedToAddress(addrConnect)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2244,
          "old_api": "std::string(pszDest)",
          "new_api": null,
          "old_text": "std::string(pszDest)",
          "new_text": null,
          "old_line_content": "    } else if (FindNode(std::string(pszDest)))",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2252,
          "old_api": "MoveTo",
          "new_api": null,
          "old_text": "grantOutbound->MoveTo(pnode->grantOutbound)",
          "new_text": null,
          "old_line_content": "        grantOutbound->MoveTo(pnode->grantOutbound);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2254,
          "old_api": "InitializeNode",
          "new_api": null,
          "old_text": "m_msgproc->InitializeNode(pnode)",
          "new_text": null,
          "old_line_content": "    m_msgproc->InitializeNode(pnode);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2256,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_nodes_mutex);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 2257,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "m_nodes.push_back(pnode)",
          "new_text": null,
          "old_line_content": "        m_nodes.push_back(pnode);",
          "new_line_content": "    if (grantOutbound)",
          "content_same": false
        },
        {
          "line": 2274,
          "old_api": "Nodes",
          "new_api": null,
          "old_text": "snap.Nodes()",
          "new_text": null,
          "old_line_content": "            for (CNode* pnode : snap.Nodes()) {",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": "ProcessMessages",
          "new_api": null,
          "old_text": "m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc)",
          "new_text": null,
          "old_line_content": "                bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2286,
          "old_api": "SendMessages",
          "new_api": null,
          "old_text": "m_msgproc->SendMessages(pnode)",
          "new_text": null,
          "old_line_content": "                    m_msgproc->SendMessages(pnode);",
          "new_line_content": "                fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend);",
          "content_same": false
        },
        {
          "line": 2294,
          "old_api": "WAIT_LOCK",
          "new_api": null,
          "old_text": "WAIT_LOCK(mutexMsgProc, lock)",
          "new_text": null,
          "old_line_content": "        WAIT_LOCK(mutexMsgProc, lock);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2296,
          "old_api": "std::chrono::milliseconds(100)",
          "new_api": null,
          "old_text": "std::chrono::milliseconds(100)",
          "new_text": null,
          "old_line_content": "            condMsgProc.wait_until(lock, std::chrono::steady_clock::now() + std::chrono::milliseconds(100), [this]() EXCLUSIVE_LOCKS_REQUIRED(mutexMsgProc) { return fMsgProcWake; });",
          "new_line_content": "                    return;",
          "content_same": false
        },
        {
          "line": 2304,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "    static constexpr auto err_wait_begin = 1s;",
          "new_line_content": "        fMsgProcWake = false;",
          "content_same": false
        },
        {
          "line": 2305,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "    static constexpr auto err_wait_cap = 5min;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2313,
          "old_api": "Listen",
          "new_api": null,
          "old_text": "m_i2p_sam_session->Listen(conn)",
          "new_text": null,
          "old_line_content": "        if (!m_i2p_sam_session->Listen(conn)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2314,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "conn.me.IsValid()",
          "new_text": null,
          "old_line_content": "            if (advertising_listen_addr && conn.me.IsValid()) {",
          "new_line_content": "    bool advertising_listen_addr = false;",
          "content_same": false
        },
        {
          "line": 2315,
          "old_api": "RemoveLocal",
          "new_api": null,
          "old_text": "RemoveLocal(conn.me)",
          "new_text": null,
          "old_line_content": "                RemoveLocal(conn.me);",
          "new_line_content": "    i2p::Connection conn;",
          "content_same": false
        },
        {
          "line": 2328,
          "old_api": "AddLocal",
          "new_api": null,
          "old_text": "AddLocal(conn.me, LOCAL_MANUAL)",
          "new_text": null,
          "old_line_content": "            AddLocal(conn.me, LOCAL_MANUAL);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2332,
          "old_api": "Accept",
          "new_api": null,
          "old_text": "m_i2p_sam_session->Accept(conn)",
          "new_text": null,
          "old_line_content": "        if (!m_i2p_sam_session->Accept(conn)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2336,
          "old_api": "std::move(conn.sock)",
          "new_api": null,
          "old_text": "std::move(conn.sock)",
          "new_text": null,
          "old_line_content": "        CreateNodeFromAcceptedSocket(std::move(conn.sock), NetPermissionFlags::None,",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2348,
          "old_api": "GetSockAddr",
          "new_api": null,
          "old_text": "addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len)",
          "new_text": null,
          "old_line_content": "    if (!addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len))",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2350,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "addrBind.ToString()",
          "new_text": null,
          "old_line_content": "        strError = strprintf(Untranslated(\"Error: Bind address family for %s not supported\"), addrBind.ToString());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2351,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"%s\\n\", strError.original)",
          "new_text": null,
          "old_line_content": "        LogPrintf(\"%s\\n\", strError.original);",
          "new_line_content": "    // Create socket for listening for incoming connections",
          "content_same": false
        },
        {
          "line": 2355,
          "old_api": "CreateSock",
          "new_api": null,
          "old_text": "CreateSock(addrBind)",
          "new_text": null,
          "old_line_content": "    std::unique_ptr<Sock> sock = CreateSock(addrBind);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2358,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"%s\\n\", strError.original)",
          "new_text": null,
          "old_line_content": "        LogPrintf(\"%s\\n\", strError.original);",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 2368,
          "old_api": "IsIPv6",
          "new_api": null,
          "old_text": "addrBind.IsIPv6()",
          "new_text": null,
          "old_line_content": "    if (addrBind.IsIPv6()) {",
          "new_line_content": "    // Allow binding if the port is still in TIME_WAIT state after",
          "content_same": false
        },
        {
          "line": 2378,
          "old_api": "Get",
          "new_api": null,
          "old_text": "sock->Get()",
          "new_text": null,
          "old_line_content": "    if (::bind(sock->Get(), (struct sockaddr*)&sockaddr, len) == SOCKET_ERROR)",
          "new_line_content": "#ifdef WIN32",
          "content_same": false
        },
        {
          "line": 2382,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "addrBind.ToString()",
          "new_text": null,
          "old_line_content": "            strError = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"), addrBind.ToString(), PACKAGE_NAME);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2385,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"%s\\n\", strError.original)",
          "new_text": null,
          "old_line_content": "        LogPrintf(\"%s\\n\", strError.original);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2393,
          "old_api": "WSAGetLastError",
          "new_api": null,
          "old_text": "WSAGetLastError()",
          "new_text": null,
          "old_line_content": "        strError = strprintf(_(\"Error: Listening for incoming connections failed (listen returned error %s)\"), NetworkErrorString(WSAGetLastError()));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2398,
          "old_api": "std::move(sock)",
          "new_api": null,
          "old_text": "std::move(sock)",
          "new_text": null,
          "old_line_content": "    vhListenSocket.emplace_back(std::move(sock), permissions);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2410,
          "old_api": "gethostname",
          "new_api": null,
          "old_text": "gethostname(pszHostName, sizeof(pszHostName))",
          "new_text": null,
          "old_line_content": "    if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR)",
          "new_line_content": "    if (!fDiscover)",
          "content_same": false
        },
        {
          "line": 2413,
          "old_api": "LookupHost",
          "new_api": null,
          "old_text": "LookupHost(pszHostName, vaddr, 0, true)",
          "new_text": null,
          "old_line_content": "        if (LookupHost(pszHostName, vaddr, 0, true))",
          "new_line_content": "#ifdef WIN32",
          "content_same": false
        },
        {
          "line": 2417,
          "old_api": "AddLocal",
          "new_api": null,
          "old_text": "AddLocal(addr, LOCAL_IF)",
          "new_text": null,
          "old_line_content": "                if (AddLocal(addr, LOCAL_IF))",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2418,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "addr.ToString()",
          "new_text": null,
          "old_line_content": "                    LogPrintf(\"%s: %s - %s\\n\", __func__, pszHostName, addr.ToString());",
          "new_line_content": "        std::vector<CNetAddr> vaddr;",
          "content_same": false
        },
        {
          "line": 2425,
          "old_api": "getifaddrs",
          "new_api": null,
          "old_text": "getifaddrs(&myaddrs)",
          "new_text": null,
          "old_line_content": "    if (getifaddrs(&myaddrs) == 0)",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2432,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(ifa->ifa_name, \"lo0\")",
          "new_text": null,
          "old_line_content": "            if (strcmp(ifa->ifa_name, \"lo0\") == 0) continue;",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "addr.ToString()",
          "new_text": null,
          "old_line_content": "                    LogPrintf(\"%s: IPv6 %s: %s\\n\", __func__, ifa->ifa_name, addr.ToString());",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2448,
          "old_api": "freeifaddrs",
          "new_api": null,
          "old_text": "freeifaddrs(myaddrs)",
          "new_text": null,
          "old_line_content": "        freeifaddrs(myaddrs);",
          "new_line_content": "                struct sockaddr_in6* s6 = (struct sockaddr_in6*)(ifa->ifa_addr);",
          "content_same": false
        },
        {
          "line": 2455,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"%s: %s\\n\", __func__, active)",
          "new_text": null,
          "old_line_content": "    LogPrintf(\"%s: %s\\n\", __func__, active);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2464,
          "old_api": "NotifyNetworkActiveChanged",
          "new_api": null,
          "old_text": "m_client_interface->NotifyNetworkActiveChanged(fNetworkActive)",
          "new_text": null,
          "old_line_content": "        m_client_interface->NotifyNetworkActiveChanged(fNetworkActive);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 2471,
          "old_api": "SetTryNewOutboundPeer",
          "new_api": null,
          "old_text": "SetTryNewOutboundPeer(false)",
          "new_text": null,
          "old_line_content": "    SetTryNewOutboundPeer(false);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2474,
          "old_api": "Init",
          "new_api": null,
          "old_text": "Init(connOptions)",
          "new_text": null,
          "old_line_content": "    Init(connOptions);",
          "new_line_content": "CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In, AddrMan& addrman_in, bool network_active)",
          "content_same": false
        },
        {
          "line": 2475,
          "old_api": "SetNetworkActive",
          "new_api": null,
          "old_text": "SetNetworkActive(network_active)",
          "new_text": null,
          "old_line_content": "    SetNetworkActive(network_active);",
          "new_line_content": "    : addrman(addrman_in), nSeed0(nSeed0In), nSeed1(nSeed1In)",
          "content_same": false
        },
        {
          "line": 2488,
          "old_api": "IsReachable",
          "new_api": null,
          "old_text": "IsReachable(addr)",
          "new_text": null,
          "old_line_content": "    if (!(flags & BF_EXPLICIT) && !IsReachable(addr)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2499,
          "old_api": "NetPermissions::HasFlag(permissions, NetPermissionFlags::NoBan)",
          "new_api": null,
          "old_text": "NetPermissions::HasFlag(permissions, NetPermissionFlags::NoBan)",
          "new_text": null,
          "old_line_content": "    if (addr.IsRoutable() && fDiscover && !(flags & BF_DONT_ADVERTISE) && !NetPermissions::HasFlag(permissions, NetPermissionFlags::NoBan)) {",
          "new_line_content": "        if ((flags & BF_REPORT_ERROR) && m_client_interface) {",
          "content_same": false
        },
        {
          "line": 2510,
          "old_api": "Bind",
          "new_api": null,
          "old_text": "Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR), NetPermissionFlags::None)",
          "new_text": null,
          "old_line_content": "        fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR), NetPermissionFlags::None);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2513,
          "old_api": "Bind",
          "new_api": null,
          "old_text": "Bind(addrBind.m_service, (BF_EXPLICIT | BF_REPORT_ERROR), addrBind.m_flags)",
          "new_text": null,
          "old_line_content": "        fBound |= Bind(addrBind.m_service, (BF_EXPLICIT | BF_REPORT_ERROR), addrBind.m_flags);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2520,
          "old_api": "htonl",
          "new_api": null,
          "old_text": "htonl(INADDR_ANY)",
          "new_text": null,
          "old_line_content": "        inaddr_any.s_addr = htonl(INADDR_ANY);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2523,
          "old_api": "GetListenPort",
          "new_api": null,
          "old_text": "GetListenPort()",
          "new_text": null,
          "old_line_content": "        fBound |= Bind(CService(inaddr_any, GetListenPort()), !fBound ? BF_REPORT_ERROR : BF_NONE, NetPermissionFlags::None);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2530,
          "old_api": "Init",
          "new_api": null,
          "old_text": "Init(connOptions)",
          "new_text": null,
          "old_line_content": "    Init(connOptions);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2532,
          "old_api": "InitBinds",
          "new_api": null,
          "old_text": "InitBinds(connOptions)",
          "new_text": null,
          "old_line_content": "    if (fListen && !InitBinds(connOptions)) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2534,
          "old_api": "ThreadSafeMessageBox",
          "new_api": null,
          "old_text": "m_client_interface->ThreadSafeMessageBox(\n                _(\"Failed to listen on any port. Use -listen=0 if you want this.\"),\n                \"\", CClientUIInterface::MSG_ERROR)",
          "new_text": null,
          "old_line_content": "            m_client_interface->ThreadSafeMessageBox(",
          "new_line_content": "bool CConnman::Start(CScheduler& scheduler, const Options& connOptions)",
          "content_same": false
        },
        {
          "line": 2535,
          "old_api": "_",
          "new_api": null,
          "old_text": "_(\"Failed to listen on any port. Use -listen=0 if you want this.\")",
          "new_text": null,
          "old_line_content": "                _(\"Failed to listen on any port. Use -listen=0 if you want this.\"),",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2542,
          "old_api": "GetProxy",
          "new_api": null,
          "old_text": "GetProxy(NET_I2P, i2p_sam)",
          "new_text": null,
          "old_line_content": "    if (GetProxy(NET_I2P, i2p_sam)) {",
          "new_line_content": "                \"\", CClientUIInterface::MSG_ERROR);",
          "content_same": false
        },
        {
          "line": 2543,
          "old_api": "GetDataDirNet",
          "new_api": null,
          "old_text": "gArgs.GetDataDirNet()",
          "new_text": null,
          "old_line_content": "        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(gArgs.GetDataDirNet() / \"i2p_private_key\",",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2553,
          "old_api": "GetDataDirNet",
          "new_api": null,
          "old_text": "gArgs.GetDataDirNet()",
          "new_text": null,
          "old_line_content": "        m_anchors = ReadAnchors(gArgs.GetDataDirNet() / ANCHORS_DATABASE_FILENAME);",
          "new_line_content": "    for (const auto& strDest : connOptions.vSeedNodes) {",
          "content_same": false
        },
        {
          "line": 2555,
          "old_api": "resize",
          "new_api": null,
          "old_text": "m_anchors.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS)",
          "new_text": null,
          "old_line_content": "            m_anchors.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2557,
          "old_api": "size",
          "new_api": null,
          "old_text": "m_anchors.size()",
          "new_text": null,
          "old_line_content": "        LogPrintf(\"%i block-relay-only anchors will be tried for connections.\\n\", m_anchors.size());",
          "new_line_content": "    if (m_use_addrman_outgoing) {",
          "content_same": false
        },
        {
          "line": 2568,
          "old_api": "d::min(m_max_outbound, nMaxConnections));",
          "new_api": null,
          "old_text": "d::min(m_max_outbound, nMaxConnections));",
          "new_text": null,
          "old_line_content": "        semOutbound = std::make_unique<CSemaphore>(std::min(m_max_outbound, nMaxConnections));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2572,
          "old_api": "d::make_unique<CSemaphore>(nMaxAddnode);",
          "new_api": null,
          "old_text": "d::make_unique<CSemaphore>(nMaxAddnode);\n",
          "new_text": null,
          "old_line_content": "        semAddnode = std::make_unique<CSemaphore>(nMaxAddnode);",
          "new_line_content": "    if (semOutbound == nullptr) {",
          "content_same": false
        },
        {
          "line": 2579,
          "old_api": "terruptSocks5",
          "new_api": null,
          "old_text": "terruptSocks5(false);\n",
          "new_text": null,
          "old_line_content": "    InterruptSocks5(false);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2580,
          "old_api": "reset",
          "new_api": null,
          "old_text": "terruptNet.reset();\n",
          "new_text": null,
          "old_line_content": "    interruptNet.reset();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2589,
          "old_api": "readSocketHandler",
          "new_api": null,
          "old_text": "readSocketHandler(); ",
          "new_text": null,
          "old_line_content": "    threadSocketHandler = std::thread(&util::TraceThread, \"net\", [this] { ThreadSocketHandler(); });",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2591,
          "old_api": "GetBoolArg",
          "new_api": null,
          "old_text": "rgs.GetBoolArg(\"-dnsseed\", DEFAULT_DNSSEED))\n",
          "new_text": null,
          "old_line_content": "    if (!gArgs.GetBoolArg(\"-dnsseed\", DEFAULT_DNSSEED))",
          "new_line_content": "        fMsgProcWake = false;",
          "content_same": false
        },
        {
          "line": 2592,
          "old_api": "gPrintf",
          "new_api": null,
          "old_text": "gPrintf(\"DNS seeding disabled\\n\");\n",
          "new_text": null,
          "old_line_content": "        LogPrintf(\"DNS seeding disabled\\n\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2594,
          "old_api": "readDNSAddressSeed",
          "new_api": null,
          "old_text": "readDNSAddressSeed(); ",
          "new_text": null,
          "old_line_content": "        threadDNSAddressSeed = std::thread(&util::TraceThread, \"dnsseed\", [this] { ThreadDNSAddressSeed(); });",
          "new_line_content": "    // Send and receive from sockets, accept connections",
          "content_same": false
        },
        {
          "line": 2599,
          "old_api": "empty",
          "new_api": null,
          "old_text": "nnOptions.m_specified_outgoing.empty()) ",
          "new_text": null,
          "old_line_content": "    if (connOptions.m_use_addrman_outgoing && !connOptions.m_specified_outgoing.empty()) {",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 2601,
          "old_api": "ThreadSafeMessageBox",
          "new_api": null,
          "old_text": "client_interface->ThreadSafeMessageBox(\n                _(\"Cannot provide specific connections and have addrman find outgoing connections at the same.\"),\n                \"\", CClientUIInterface::MSG_ERROR);\n",
          "new_text": null,
          "old_line_content": "            m_client_interface->ThreadSafeMessageBox(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2602,
          "old_api": "\"Cannot provide specific connections and have addrman find outgoing connections at the same.\"),",
          "new_api": null,
          "old_text": "\"Cannot provide specific connections and have addrman find outgoing connections at the same.\"),\n",
          "new_text": null,
          "old_line_content": "                _(\"Cannot provide specific connections and have addrman find outgoing connections at the same.\"),",
          "new_line_content": "    // Initiate manual connections",
          "content_same": false
        },
        {
          "line": 2610,
          "old_api": "readOpenConnections",
          "new_api": null,
          "old_text": "readOpenConnections(connect); ",
          "new_text": null,
          "old_line_content": "            [this, connect = connOptions.m_specified_outgoing] { ThreadOpenConnections(connect); });",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2618,
          "old_api": "readI2PAcceptIncoming",
          "new_api": null,
          "old_text": "readI2PAcceptIncoming(); ",
          "new_text": null,
          "old_line_content": "            std::thread(&util::TraceThread, \"i2paccept\", [this] { ThreadI2PAcceptIncoming(); });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2636,
          "old_api": "ACleanup",
          "new_api": null,
          "old_text": "ACleanup();\n",
          "new_text": null,
          "old_line_content": "        WSACleanup();",
          "new_line_content": "    CNetCleanup() {}",
          "content_same": false
        },
        {
          "line": 2645,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(mutexMsgProc);\n",
          "new_text": null,
          "old_line_content": "        LOCK(mutexMsgProc);",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 2648,
          "old_api": "notify_all",
          "new_api": null,
          "old_text": "ndMsgProc.notify_all();\n",
          "new_text": null,
          "old_line_content": "    condMsgProc.notify_all();",
          "new_line_content": "void CConnman::Interrupt()",
          "content_same": false
        },
        {
          "line": 2650,
          "old_api": "terruptNet",
          "new_api": null,
          "old_text": "terruptNet();\n",
          "new_text": null,
          "old_line_content": "    interruptNet();",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2655,
          "old_api": "post",
          "new_api": null,
          "old_text": "mOutbound->post();\n",
          "new_text": null,
          "old_line_content": "            semOutbound->post();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2668,
          "old_api": "joinable",
          "new_api": null,
          "old_text": "readI2PAcceptIncoming.joinable()) ",
          "new_text": null,
          "old_line_content": "    if (threadI2PAcceptIncoming.joinable()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2669,
          "old_api": "join",
          "new_api": null,
          "old_text": "readI2PAcceptIncoming.join();\n",
          "new_text": null,
          "old_line_content": "        threadI2PAcceptIncoming.join();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2671,
          "old_api": "joinable",
          "new_api": null,
          "old_text": "readMessageHandler.joinable())\n",
          "new_text": null,
          "old_line_content": "    if (threadMessageHandler.joinable())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2672,
          "old_api": "join",
          "new_api": null,
          "old_text": "readMessageHandler.join();\n",
          "new_text": null,
          "old_line_content": "        threadMessageHandler.join();",
          "new_line_content": "void CConnman::StopThreads()",
          "content_same": false
        },
        {
          "line": 2673,
          "old_api": "joinable",
          "new_api": null,
          "old_text": "readOpenConnections.joinable())\n",
          "new_text": null,
          "old_line_content": "    if (threadOpenConnections.joinable())",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2676,
          "old_api": "join",
          "new_api": null,
          "old_text": "readOpenAddedConnections.join();\n",
          "new_text": null,
          "old_line_content": "        threadOpenAddedConnections.join();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2691,
          "old_api": "tCurrentBlockRelayOnlyConns",
          "new_api": null,
          "old_text": "tCurrentBlockRelayOnlyConns();\n",
          "new_text": null,
          "old_line_content": "            std::vector<CAddress> anchors_to_dump = GetCurrentBlockRelayOnlyConns();",
          "new_line_content": "    if (fAddressesInitialized) {",
          "content_same": false
        },
        {
          "line": 2693,
          "old_api": "resize",
          "new_api": null,
          "old_text": "chors_to_dump.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);\n",
          "new_text": null,
          "old_line_content": "                anchors_to_dump.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);",
          "new_line_content": "        fAddressesInitialized = false;",
          "content_same": false
        },
        {
          "line": 2695,
          "old_api": "GetDataDirNet",
          "new_api": null,
          "old_text": "rgs.GetDataDirNet() /",
          "new_text": null,
          "old_line_content": "            DumpAnchors(gArgs.GetDataDirNet() / ANCHORS_DATABASE_FILENAME, anchors_to_dump);",
          "new_line_content": "        if (m_use_addrman_outgoing) {",
          "content_same": false
        },
        {
          "line": 2703,
          "old_api": "CloseSocketDisconnect",
          "new_api": null,
          "old_text": "ode->CloseSocketDisconnect();\n",
          "new_text": null,
          "old_line_content": "        pnode->CloseSocketDisconnect();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2704,
          "old_api": "leteNode",
          "new_api": null,
          "old_text": "leteNode(pnode);\n",
          "new_text": null,
          "old_line_content": "        DeleteNode(pnode);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2708,
          "old_api": "leteNode",
          "new_api": null,
          "old_text": "leteNode(pnode);\n",
          "new_text": null,
          "old_line_content": "        DeleteNode(pnode);",
          "new_line_content": "    for (CNode* pnode : nodes) {",
          "content_same": false
        },
        {
          "line": 2711,
          "old_api": "clear",
          "new_api": null,
          "old_text": "ListenSocket.clear();\n",
          "new_text": null,
          "old_line_content": "    vhListenSocket.clear();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2712,
          "old_api": "reset",
          "new_api": null,
          "old_text": "mOutbound.reset();\n",
          "new_text": null,
          "old_line_content": "    semOutbound.reset();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2713,
          "old_api": "reset",
          "new_api": null,
          "old_text": "mAddnode.reset();\n",
          "new_text": null,
          "old_line_content": "    semAddnode.reset();",
          "new_line_content": "    for (CNode* pnode : m_nodes_disconnected) {",
          "content_same": false
        },
        {
          "line": 2726,
          "old_api": "op",
          "new_api": null,
          "old_text": "op();\n",
          "new_text": null,
          "old_line_content": "    Stop();",
          "new_line_content": "    delete pnode;",
          "content_same": false
        },
        {
          "line": 2733,
          "old_api": "end",
          "new_api": null,
          "old_text": "dresses.end(),\n",
          "new_text": null,
          "old_line_content": "        addresses.erase(std::remove_if(addresses.begin(), addresses.end(),",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2734,
          "old_api": "IsBanned",
          "new_api": null,
          "old_text": "banman->IsBanned(addr);}",
          "new_text": null,
          "old_line_content": "                        [this](const CAddress& addr){return m_banman->IsDiscouraged(addr) || m_banman->IsBanned(addr);}),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2735,
          "old_api": "end",
          "new_api": null,
          "old_text": "dresses.end());",
          "new_text": null,
          "old_line_content": "                        addresses.end());",
          "new_line_content": "std::vector<CAddress> CConnman::GetAddresses(size_t max_addresses, size_t max_pct, std::optional<Network> network) const",
          "content_same": false
        },
        {
          "line": 2742,
          "old_api": "GetAddrBytes",
          "new_api": null,
          "old_text": "questor.addrBind.GetAddrBytes();\n",
          "new_text": null,
          "old_line_content": "    auto local_socket_bytes = requestor.addrBind.GetAddrBytes();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2743,
          "old_api": "Write",
          "new_api": null,
          "old_text": "tDeterministicRandomizer(RANDOMIZER_ID_ADDRCACHE)\n        .Write(requestor.addr.GetNetwork())\n        .Write(local_socket_bytes.data(), local_socket_bytes.size())\n        .Finalize();\n",
          "new_text": null,
          "old_line_content": "    uint64_t cache_id = GetDeterministicRandomizer(RANDOMIZER_ID_ADDRCACHE)",
          "new_line_content": "    return addresses;",
          "content_same": false
        },
        {
          "line": 2744,
          "old_api": "GetNetwork",
          "new_api": null,
          "old_text": "questor.addr.GetNetwork())\n",
          "new_text": null,
          "old_line_content": "        .Write(requestor.addr.GetNetwork())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2745,
          "old_api": "size",
          "new_api": null,
          "old_text": "cal_socket_bytes.size())\n",
          "new_text": null,
          "old_line_content": "        .Write(local_socket_bytes.data(), local_socket_bytes.size())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2747,
          "old_api": "tTime<std::chrono::microseconds>();",
          "new_api": null,
          "old_text": "tTime<std::chrono::microseconds>();\n",
          "new_text": null,
          "old_line_content": "    const auto current_time = GetTime<std::chrono::microseconds>();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2776,
          "old_api": "d::chrono::hours(6));",
          "new_api": null,
          "old_text": "d::chrono::hours(6));",
          "new_text": null,
          "old_line_content": "        cache_entry.m_cache_entry_expiration = current_time + std::chrono::hours(21) + GetRandMillis(std::chrono::hours(6));",
          "new_line_content": "        // in the ADDR response are no longer active.",
          "content_same": false
        },
        {
          "line": 2783,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(m_added_nodes_mutex);\n",
          "new_text": null,
          "old_line_content": "    LOCK(m_added_nodes_mutex);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2788,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "added_nodes.push_back(strNode);\n",
          "new_text": null,
          "old_line_content": "    m_added_nodes.push_back(strNode);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2795,
          "old_api": "end",
          "new_api": null,
          "old_text": "added_nodes.end(); ",
          "new_text": null,
          "old_line_content": "    for(std::vector<std::string>::iterator it = m_added_nodes.begin(); it != m_added_nodes.end(); ++it) {",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 2797,
          "old_api": "erase",
          "new_api": null,
          "old_text": "added_nodes.erase(it);\n",
          "new_text": null,
          "old_line_content": "            m_added_nodes.erase(it);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2806,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(m_nodes_mutex);\n",
          "new_text": null,
          "old_line_content": "    LOCK(m_nodes_mutex);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2808,
          "old_api": "size",
          "new_api": null,
          "old_text": "nodes.size();\n",
          "new_text": null,
          "old_line_content": "        return m_nodes.size();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2822,
          "old_api": "clear",
          "new_api": null,
          "old_text": "tats.clear();\n",
          "new_text": null,
          "old_line_content": "    vstats.clear();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2823,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(m_nodes_mutex);\n",
          "new_text": null,
          "old_line_content": "    LOCK(m_nodes_mutex);",
          "new_line_content": "    return nNum;",
          "content_same": false
        },
        {
          "line": 2824,
          "old_api": "size",
          "new_api": null,
          "old_text": "nodes.size());",
          "new_text": null,
          "old_line_content": "    vstats.reserve(m_nodes.size());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2826,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "tats.emplace_back();\n",
          "new_text": null,
          "old_line_content": "        vstats.emplace_back();",
          "new_line_content": "void CConnman::GetNodeStats(std::vector<CNodeStats>& vstats) const",
          "content_same": false
        },
        {
          "line": 2827,
          "old_api": "back",
          "new_api": null,
          "old_text": "tats.back());",
          "new_text": null,
          "old_line_content": "        pnode->CopyStats(vstats.back());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2835,
          "old_api": "ndNode",
          "new_api": null,
          "old_text": "ndNode(strNode)) ",
          "new_text": null,
          "old_line_content": "    if (CNode* pnode = FindNode(strNode)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2836,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "ode->GetId());",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"disconnect by address%s matched peer=%d; disconnecting\\n\", (fLogIPs ? strprintf(\"=%s\", strNode) : \"\"), pnode->GetId());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2846,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(m_nodes_mutex);\n",
          "new_text": null,
          "old_line_content": "    LOCK(m_nodes_mutex);",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 2848,
          "old_api": "Match",
          "new_api": null,
          "old_text": "bnet.Match(pnode->addr)) ",
          "new_text": null,
          "old_line_content": "        if (subnet.Match(pnode->addr)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2849,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "ode->GetId());",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"disconnect by subnet%s matched peer=%d; disconnecting\\n\", (fLogIPs ? strprintf(\"=%s\", subnet.ToString()) : \"\"), pnode->GetId());",
          "new_line_content": "bool CConnman::DisconnectNode(const CSubNet& subnet)",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": "size",
          "new_api": null,
          "old_text": "data.size()",
          "new_text": null,
          "old_line_content": "            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()) + node.nSendOffset, data.size() - node.nSendOffset, MSG_NOSIGNAL | MSG_DONTWAIT);",
          "new_line_content": "            int flags = MSG_NOSIGNAL | MSG_DONTWAIT;",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": "GetTime<std::chrono::seconds>()",
          "new_api": null,
          "old_text": "GetTime<std::chrono::seconds>()",
          "new_text": null,
          "old_line_content": "            node.m_last_send = GetTime<std::chrono::seconds>();",
          "new_line_content": "                flags |= MSG_MORE;",
          "content_same": false
        },
        {
          "line": 2859,
          "old_api": "ubNet",
          "new_api": null,
          "old_text": "ubNet(addr));",
          "new_text": null,
          "old_line_content": "    return DisconnectNode(CSubNet(addr));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": "size",
          "new_api": null,
          "old_text": "data.size()",
          "new_text": null,
          "old_line_content": "            if (node.nSendOffset == data.size()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2864,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(m_nodes_mutex);\n",
          "new_text": null,
          "old_line_content": "    LOCK(m_nodes_mutex);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2866,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "ode->GetId()) ",
          "new_text": null,
          "old_line_content": "        if (id == pnode->GetId()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2867,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "ode->GetId());",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"disconnect by id peer=%d; disconnecting\\n\", pnode->GetId());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": "WSAGetLastError",
          "new_api": null,
          "old_text": "WSAGetLastError()",
          "new_text": null,
          "old_line_content": "                int nErr = WSAGetLastError();",
          "new_line_content": "                // could not send full message; stop sending more",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": "NetworkErrorString",
          "new_api": null,
          "old_text": "NetworkErrorString(nErr)",
          "new_text": null,
          "old_line_content": "                    LogPrint(BCLog::NET, \"socket send error for peer=%d: %s\\n\", node.GetId(), NetworkErrorString(nErr));",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 827,
          "old_api": "CloseSocketDisconnect",
          "new_api": null,
          "old_text": "node.CloseSocketDisconnect()",
          "new_text": null,
          "old_line_content": "                    node.CloseSocketDisconnect();",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 2882,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(cs_totalBytesSent);\n",
          "new_text": null,
          "old_line_content": "    LOCK(cs_totalBytesSent);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": "end",
          "new_api": null,
          "old_text": "node.vSendMsg.end()",
          "new_text": null,
          "old_line_content": "    if (it == node.vSendMsg.end()) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(node.nSendOffset == 0)",
          "new_text": null,
          "old_line_content": "        assert(node.nSendOffset == 0);",
          "new_line_content": "            // couldn't send anything at all",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(node.nSendSize == 0)",
          "new_text": null,
          "old_line_content": "        assert(node.nSendSize == 0);",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 2885,
          "old_api": "tTime<std::chrono::seconds>();",
          "new_api": null,
          "old_text": "tTime<std::chrono::seconds>();\n",
          "new_text": null,
          "old_line_content": "    const auto now = GetTime<std::chrono::seconds>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": "begin",
          "new_api": null,
          "old_text": "node.vSendMsg.begin()",
          "new_text": null,
          "old_line_content": "    node.vSendMsg.erase(node.vSendMsg.begin(), it);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2898,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(cs_totalBytesSent);\n",
          "new_text": null,
          "old_line_content": "    LOCK(cs_totalBytesSent);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2909,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(cs_totalBytesSent);\n",
          "new_text": null,
          "old_line_content": "    LOCK(cs_totalBytesSent);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2913,
          "old_api": "count",
          "new_api": null,
          "old_text": "axOutboundCycleStartTime.count() =",
          "new_text": null,
          "old_line_content": "    if (nMaxOutboundCycleStartTime.count() == 0)",
          "new_line_content": "std::chrono::seconds CConnman::GetMaxOutboundTimeLeftInCycle() const",
          "content_same": false
        },
        {
          "line": 2917,
          "old_api": "tTime<std::chrono::seconds>();",
          "new_api": null,
          "old_text": "tTime<std::chrono::seconds>();\n",
          "new_text": null,
          "old_line_content": "    const auto now = GetTime<std::chrono::seconds>();",
          "new_line_content": "        return 0s;",
          "content_same": false
        },
        {
          "line": 2930,
          "old_api": "tMaxOutboundTimeLeftInCycle",
          "new_api": null,
          "old_text": "tMaxOutboundTimeLeftInCycle();\n",
          "new_text": null,
          "old_line_content": "        const std::chrono::seconds timeLeftInCycle = GetMaxOutboundTimeLeftInCycle();",
          "new_line_content": "    if (nMaxOutboundLimit == 0)",
          "content_same": false
        },
        {
          "line": 2943,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(cs_totalBytesSent);\n",
          "new_text": null,
          "old_line_content": "    LOCK(cs_totalBytesSent);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": "end",
          "new_api": null,
          "old_text": "elements.end()",
          "new_text": null,
          "old_line_content": "    std::sort(elements.begin(), elements.end(), comparator);",
          "new_line_content": "//! Sort an array by the specified comparator, then erase the last K elements where predicate is true.",
          "content_same": false
        },
        {
          "line": 910,
          "old_api": "size",
          "new_api": null,
          "old_text": "elements.size()",
          "new_text": null,
          "old_line_content": "    size_t eraseSize = std::min(k, elements.size());",
          "new_line_content": "template <typename T, typename Comparator>",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": "end",
          "new_api": null,
          "old_text": "elements.end()",
          "new_text": null,
          "old_line_content": "    elements.erase(std::remove_if(elements.end() - eraseSize, elements.end(), predicate), elements.end());",
          "new_line_content": "static void EraseLastKElements(",
          "content_same": false
        },
        {
          "line": 2957,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(cs_totalBytesSent);\n",
          "new_text": null,
          "old_line_content": "    LOCK(cs_totalBytesSent);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": "size",
          "new_api": null,
          "old_text": "eviction_candidates.size()",
          "new_text": null,
          "old_line_content": "    const size_t initial_size = eviction_candidates.size();",
          "new_line_content": "    // Protect the half of the remaining nodes which have been connected the longest.",
          "content_same": false
        },
        {
          "line": 2970,
          "old_api": "tTime<std::chrono::seconds>()},",
          "new_api": null,
          "old_text": "tTime<std::chrono::seconds>()},",
          "new_text": null,
          "old_line_content": "      m_connected{GetTime<std::chrono::seconds>()},",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2973,
          "old_api": "ToStringIPPort",
          "new_api": null,
          "old_text": "dr.ToStringIPPort() :",
          "new_text": null,
          "old_line_content": "      m_addr_name{addrNameIn.empty() ? addr.ToStringIPPort() : addrNameIn},",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": "cend",
          "new_api": null,
          "old_text": "eviction_candidates.cend()",
          "new_text": null,
          "old_line_content": "        n.count = std::count_if(eviction_candidates.cbegin(), eviction_candidates.cend(),",
          "new_line_content": "    struct Net { bool is_local; Network id; size_t count; };",
          "content_same": false
        },
        {
          "line": 2981,
          "old_api": "sert",
          "new_api": null,
          "old_text": "sert(conn_type_in == ConnectionType::INBOUND);\n",
          "new_text": null,
          "old_line_content": "    if (inbound_onion) assert(conn_type_in == ConnectionType::INBOUND);",
          "new_line_content": "      nKeyedNetGroup(nKeyedNetGroupIn),",
          "content_same": false
        },
        {
          "line": 2983,
          "old_api": "d::make_unique<TxRelay>();",
          "new_api": null,
          "old_text": "d::make_unique<TxRelay>();\n",
          "new_text": null,
          "old_line_content": "        m_tx_relay = std::make_unique<TxRelay>();",
          "new_line_content": "      nLocalHostNonce(nLocalHostNonceIn),",
          "content_same": false
        },
        {
          "line": 2986,
          "old_api": "tAllNetMessageTypes",
          "new_api": null,
          "old_text": "tAllNetMessageTypes())\n",
          "new_text": null,
          "old_line_content": "    for (const std::string &msg : getAllNetMessageTypes())",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": "end",
          "new_api": null,
          "old_text": "networks.end()",
          "new_text": null,
          "old_line_content": "    std::stable_sort(networks.begin(), networks.end(), [](Net a, Net b) { return a.count < b.count; });",
          "new_line_content": "                                [&n](const NodeEvictionCandidate& c) {",
          "content_same": false
        },
        {
          "line": 2991,
          "old_api": "gPrint",
          "new_api": null,
          "old_text": "gPrint(BCLog::NET, \"Added connection to %s peer=%d\\n\", m_addr_name, id);\n",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"Added connection to %s peer=%d\\n\", m_addr_name, id);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2993,
          "old_api": "gPrint",
          "new_api": null,
          "old_text": "gPrint(BCLog::NET, \"Added connection peer=%d\\n\", id);\n",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"Added connection peer=%d\\n\", id);",
          "new_line_content": "        mapRecvBytesPerMsgCmd[msg] = 0;",
          "content_same": false
        },
        {
          "line": 948,
          "old_api": "end",
          "new_api": null,
          "old_text": "networks.end()",
          "new_text": null,
          "old_line_content": "        auto num_networks = std::count_if(networks.begin(), networks.end(), [](const Net& n) { return n.count; });",
          "new_line_content": "    // Protect up to 25% of the eviction candidates by disadvantaged network.",
          "content_same": false
        },
        {
          "line": 2996,
          "old_api": "rams",
          "new_api": null,
          "old_text": "rams(), ",
          "new_text": null,
          "old_line_content": "    m_deserializer = std::make_unique<V1TransportDeserializer>(V1TransportDeserializer(Params(), id, SER_NETWORK, INIT_PROTO_VERSION));",
          "new_line_content": "    if (fLogIPs) {",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "static_cast<size_t>(1)",
          "new_api": null,
          "old_text": "static_cast<size_t>(1)",
          "new_text": null,
          "old_line_content": "        const size_t protect_per_network{std::max(disadvantaged_to_protect / num_networks, static_cast<size_t>(1))};",
          "new_line_content": "        // Count the number of disadvantaged networks from which we have peers to protect.",
          "content_same": false
        },
        {
          "line": 3007,
          "old_api": "size",
          "new_api": null,
          "old_text": "g.data.size();\n",
          "new_text": null,
          "old_line_content": "    size_t nMessageSize = msg.data.size();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": "CompareNodeNetworkTime",
          "new_api": null,
          "old_text": "CompareNodeNetworkTime(n.is_local, n.id)",
          "new_text": null,
          "old_line_content": "            EraseLastKElements(eviction_candidates, CompareNodeNetworkTime(n.is_local, n.id),",
          "new_line_content": "        // Early exit flag if there are no remaining candidates by disadvantaged network.",
          "content_same": false
        },
        {
          "line": 3008,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "ode->GetId());",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\", msg.m_type, nMessageSize, pnode->GetId());",
          "new_line_content": "    return pnode && pnode->fSuccessfullyConnected && !pnode->fDisconnect;",
          "content_same": false
        },
        {
          "line": 3009,
          "old_api": "GetBoolArg",
          "new_api": null,
          "old_text": "rgs.GetBoolArg(\"-capturemessages\", false)) ",
          "new_text": null,
          "old_line_content": "    if (gArgs.GetBoolArg(\"-capturemessages\", false)) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3010,
          "old_api": "ptureMessage",
          "new_api": null,
          "old_text": "ptureMessage(pnode->addr, msg.m_type, msg.data, /*is_incoming=*/false);\n",
          "new_text": null,
          "old_line_content": "        CaptureMessage(pnode->addr, msg.m_type, msg.data, /*is_incoming=*/false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 964,
          "old_api": "size",
          "new_api": null,
          "old_text": "eviction_candidates.size()",
          "new_text": null,
          "old_line_content": "            const size_t after = eviction_candidates.size();",
          "new_line_content": "            if (n.count == 0) continue;",
          "content_same": false
        },
        {
          "line": 3017,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "g.m_type.c_str(),\n",
          "new_text": null,
          "old_line_content": "        msg.m_type.c_str(),",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3018,
          "old_api": "size",
          "new_api": null,
          "old_text": "g.data.size(),\n",
          "new_text": null,
          "old_line_content": "        msg.data.size(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3029,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(pnode->cs_vSend);\n",
          "new_text": null,
          "old_line_content": "        LOCK(pnode->cs_vSend);",
          "new_line_content": "    std::vector<unsigned char> serializedHeader;",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": "size",
          "new_api": null,
          "old_text": "eviction_candidates.size()",
          "new_text": null,
          "old_line_content": "    assert(num_protected == initial_size - eviction_candidates.size());",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": "EraseLastKElements",
          "new_api": null,
          "old_text": "EraseLastKElements(eviction_candidates, ReverseCompareNodeTimeConnected, remaining_to_protect)",
          "new_text": null,
          "old_line_content": "    EraseLastKElements(eviction_candidates, ReverseCompareNodeTimeConnected, remaining_to_protect);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": "nodiscard",
          "new_api": null,
          "old_text": "nodiscard",
          "new_text": null,
          "old_line_content": "[[nodiscard]] std::optional<NodeId> SelectNodeToEvict(std::vector<NodeEvictionCandidate>&& vEvictionCandidates)",
          "new_line_content": "    // we want to protect based on uptime accordingly.",
          "content_same": false
        },
        {
          "line": 3037,
          "old_api": "d::move(serializedHeader));",
          "new_api": null,
          "old_text": "d::move(serializedHeader));",
          "new_text": null,
          "old_line_content": "        pnode->vSendMsg.push_back(std::move(serializedHeader));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3038,
          "old_api": "d::move(msg.data));",
          "new_api": null,
          "old_text": "d::move(msg.data));",
          "new_text": null,
          "old_line_content": "        if (nMessageSize) pnode->vSendMsg.push_back(std::move(msg.data));",
          "new_line_content": "        //log total amount of bytes per message type",
          "content_same": false
        },
        {
          "line": 3041,
          "old_api": "cketSendData",
          "new_api": null,
          "old_text": "cketSendData(*pnode);\n",
          "new_text": null,
          "old_line_content": "        if (optimisticSend) nBytesSent = SocketSendData(*pnode);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": "EraseLastKElements",
          "new_api": null,
          "old_text": "EraseLastKElements(vEvictionCandidates, ReverseCompareNodeMinPingTime, 8)",
          "new_text": null,
          "old_line_content": "    EraseLastKElements(vEvictionCandidates, ReverseCompareNodeMinPingTime, 8);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": "EraseLastKElements",
          "new_api": null,
          "old_text": "EraseLastKElements(vEvictionCandidates, CompareNodeBlockRelayOnlyTime, 8,\n                       [](const NodeEvictionCandidate& n) { return !n.fRelayTxes && n.fRelevantServices; })",
          "new_text": null,
          "old_line_content": "    EraseLastKElements(vEvictionCandidates, CompareNodeBlockRelayOnlyTime, 8,",
          "new_line_content": "    // An attacker cannot manipulate this metric without physically moving nodes closer to the target.",
          "content_same": false
        },
        {
          "line": 3051,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "ode->GetId() =",
          "new_text": null,
          "old_line_content": "        if(pnode->GetId() == id) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": "EraseLastKElements",
          "new_api": null,
          "old_text": "EraseLastKElements(vEvictionCandidates, CompareNodeBlockTime, 4)",
          "new_text": null,
          "old_line_content": "    EraseLastKElements(vEvictionCandidates, CompareNodeBlockTime, 4);",
          "new_line_content": "    // Protect up to 8 non-tx-relay peers that have sent us novel blocks.",
          "content_same": false
        },
        {
          "line": 3056,
          "old_api": "nc",
          "new_api": null,
          "old_text": "nc(found);\n",
          "new_text": null,
          "old_line_content": "    return found != nullptr && NodeFullyConnected(found) && func(found);",
          "new_line_content": "    for (auto&& pnode : m_nodes) {",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": "ProtectEvictionCandidatesByRatio",
          "new_api": null,
          "old_text": "ProtectEvictionCandidatesByRatio(vEvictionCandidates)",
          "new_text": null,
          "old_line_content": "    ProtectEvictionCandidatesByRatio(vEvictionCandidates);",
          "new_line_content": "    // Protect 4 nodes that most recently sent us novel blocks.",
          "content_same": false
        },
        {
          "line": 3061,
          "old_api": "load",
          "new_api": null,
          "old_text": "next_send_inv_to_incoming.load() <",
          "new_text": null,
          "old_line_content": "    if (m_next_send_inv_to_incoming.load() < now) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3065,
          "old_api": "issonNextSend",
          "new_api": null,
          "old_text": "issonNextSend(now, average_interval);\n",
          "new_text": null,
          "old_line_content": "        m_next_send_inv_to_incoming = PoissonNextSend(now, average_interval);",
          "new_line_content": "std::chrono::microseconds CConnman::PoissonNextSendInbound(std::chrono::microseconds now, std::chrono::seconds average_interval)",
          "content_same": false
        },
        {
          "line": 1017,
          "old_api": "end",
          "new_api": null,
          "old_text": "vEvictionCandidates.end()",
          "new_text": null,
          "old_line_content": "    if (std::any_of(vEvictionCandidates.begin(),vEvictionCandidates.end(),[](NodeEvictionCandidate const &n){return n.prefer_evict;})) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": "end",
          "new_api": null,
          "old_text": "vEvictionCandidates.end()",
          "new_text": null,
          "old_line_content": "                                  [](NodeEvictionCandidate const &n){return !n.prefer_evict;}),vEvictionCandidates.end());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3072,
          "old_api": "tRand",
          "new_api": null,
          "old_text": "tRand(1ULL << 48) *",
          "new_text": null,
          "old_line_content": "    double unscaled = -log1p(GetRand(1ULL << 48) * -0.0000000000000035527136788 /* -1/2^48 */);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3073,
          "old_api": "d::chrono::duration_cast<std::chrono::microseconds>(unscaled * average_interval + 0.5us);",
          "new_api": null,
          "old_text": "d::chrono::duration_cast<std::chrono::microseconds>(unscaled * average_interval + 0.5us);\n",
          "new_text": null,
          "old_line_content": "    return now + std::chrono::duration_cast<std::chrono::microseconds>(unscaled * average_interval + 0.5us);",
          "new_line_content": "    return m_next_send_inv_to_incoming;",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "group.push_back(node)",
          "new_text": null,
          "old_line_content": "        group.push_back(node);",
          "new_line_content": "    uint64_t naMostConnections;",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": "size",
          "new_api": null,
          "old_text": "group.size()",
          "new_text": null,
          "old_line_content": "        if (group.size() > nMostConnections || (group.size() == nMostConnections && grouptime > nMostConnectionsTime)) {",
          "new_line_content": "    std::map<uint64_t, std::vector<NodeEvictionCandidate> > mapNetGroupNodes;",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": "size",
          "new_api": null,
          "old_text": "group.size()",
          "new_text": null,
          "old_line_content": "            nMostConnections = group.size();",
          "new_line_content": "    for (const NodeEvictionCandidate &node : vEvictionCandidates) {",
          "content_same": false
        },
        {
          "line": 3083,
          "old_api": "GetAsmap",
          "new_api": null,
          "old_text": "drman.GetAsmap()))",
          "new_text": null,
          "old_line_content": "    std::vector<unsigned char> vchNetGroup(ad.GetGroup(addrman.GetAsmap()));",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3085,
          "old_api": "size",
          "new_api": null,
          "old_text": "hNetGroup.size()).",
          "new_text": null,
          "old_line_content": "    return GetDeterministicRandomizer(RANDOMIZER_ID_NETGROUP).Write(vchNetGroup.data(), vchNetGroup.size()).Finalize();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": "std::move(mapNetGroupNodes[naMostConnections])",
          "new_api": null,
          "old_text": "std::move(mapNetGroupNodes[naMostConnections])",
          "new_text": null,
          "old_line_content": "    vEvictionCandidates = std::move(mapNetGroupNodes[naMostConnections]);",
          "new_line_content": "            nMostConnectionsTime = grouptime;",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": "front",
          "new_api": null,
          "old_text": "vEvictionCandidates.front()",
          "new_text": null,
          "old_line_content": "    return vEvictionCandidates.front().id;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3094,
          "old_api": "tTime<std::chrono::microseconds>();",
          "new_api": null,
          "old_text": "tTime<std::chrono::microseconds>();\n",
          "new_text": null,
          "old_line_content": "    auto now = GetTime<std::chrono::microseconds>();",
          "new_line_content": "void CaptureMessage(const CAddress& addr, const std::string& msg_type, const Span<const unsigned char>& data, bool is_incoming)",
          "content_same": false
        },
        {
          "line": 3097,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "dr.ToString();\n",
          "new_text": null,
          "old_line_content": "    std::string clean_addr = addr.ToString();",
          "new_line_content": "    // not at socket receive/send time.",
          "content_same": false
        },
        {
          "line": 3098,
          "old_api": "end",
          "new_api": null,
          "old_text": "ean_addr.end(), ",
          "new_text": null,
          "old_line_content": "    std::replace(clean_addr.begin(), clean_addr.end(), ':', '_');",
          "new_line_content": "    // This ensures that the messages are always in order from an application",
          "content_same": false
        },
        {
          "line": 3101,
          "old_api": "::create_directories(base_path);",
          "new_api": null,
          "old_text": "::create_directories(base_path);\n",
          "new_text": null,
          "old_line_content": "    fs::create_directories(base_path);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_nodes_mutex);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 3108,
          "old_api": "length",
          "new_api": null,
          "old_text": "g_type.length(); ",
          "new_text": null,
          "old_line_content": "    for (auto i = msg_type.length(); i < CMessageHeader::COMMAND_SIZE; ++i) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": "HasPermission",
          "new_api": null,
          "old_text": "node->HasPermission(NetPermissionFlags::NoBan)",
          "new_text": null,
          "old_line_content": "            if (node->HasPermission(NetPermissionFlags::NoBan))",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3111,
          "old_api": "size",
          "new_api": null,
          "old_text": "ta.size();\n",
          "new_text": null,
          "old_line_content": "    uint32_t size = data.size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1064,
          "old_api": "IsInboundConn",
          "new_api": null,
          "old_text": "node->IsInboundConn()",
          "new_text": null,
          "old_line_content": "            if (!node->IsInboundConn())",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1071,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(node->m_tx_relay->cs_filter)",
          "new_text": null,
          "old_line_content": "                LOCK(node->m_tx_relay->cs_filter);",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 1075,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "node->GetId()",
          "new_text": null,
          "old_line_content": "            NodeEvictionCandidate candidate = {node->GetId(), node->m_connected, node->m_min_ping_time,",
          "new_line_content": "            bool peer_filter_not_null = false;",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": "IsLocal",
          "new_api": null,
          "old_text": "node->addr.IsLocal()",
          "new_text": null,
          "old_line_content": "                                               node->m_prefer_evict, node->addr.IsLocal(),",
          "new_line_content": "                peer_filter_not_null = node->m_tx_relay->pfilter != nullptr;",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": "ConnectedThroughNetwork",
          "new_api": null,
          "old_text": "node->ConnectedThroughNetwork()",
          "new_text": null,
          "old_line_content": "                                               node->ConnectedThroughNetwork()};",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": "std::move(vEvictionCandidates)",
          "new_api": null,
          "old_text": "std::move(vEvictionCandidates)",
          "new_text": null,
          "old_line_content": "    const std::optional<NodeId> node_id_to_evict = SelectNodeToEvict(std::move(vEvictionCandidates));",
          "new_line_content": "                                               peer_relay_txes, peer_filter_not_null, node->nKeyedNetGroup,",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "    LOCK(m_nodes_mutex);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1091,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pnode->GetId()",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"selected %s connection for eviction peer=%d; disconnecting\\n\", pnode->ConnectionTypeAsString(), pnode->GetId());",
          "new_line_content": "    if (!node_id_to_evict) {",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": "Accept",
          "new_api": null,
          "old_text": "hListenSocket.sock->Accept((struct sockaddr*)&sockaddr, &len)",
          "new_text": null,
          "old_line_content": "    auto sock = hListenSocket.sock->Accept((struct sockaddr*)&sockaddr, &len);",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": "WSAGetLastError",
          "new_api": null,
          "old_text": "WSAGetLastError()",
          "new_text": null,
          "old_line_content": "        const int nErr = WSAGetLastError();",
          "new_line_content": "    struct sockaddr_storage sockaddr;",
          "content_same": false
        },
        {
          "line": 1113,
          "old_api": "SetSockAddr",
          "new_api": null,
          "old_text": "addr.SetSockAddr((const struct sockaddr*)&sockaddr)",
          "new_text": null,
          "old_line_content": "    if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {",
          "new_line_content": "        if (nErr != WSAEWOULDBLOCK) {",
          "content_same": false
        },
        {
          "line": 1116,
          "old_api": "MaybeFlipIPv6toCJDNS",
          "new_api": null,
          "old_text": "MaybeFlipIPv6toCJDNS(addr)",
          "new_text": null,
          "old_line_content": "        addr = CAddress{MaybeFlipIPv6toCJDNS(addr), NODE_NONE};",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 1124,
          "old_api": "std::move(sock)",
          "new_api": null,
          "old_text": "std::move(sock)",
          "new_text": null,
          "old_line_content": "    CreateNodeFromAcceptedSocket(std::move(sock), permissionFlags, addr_bind, addr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": "AddWhitelistPermissionFlags",
          "new_api": null,
          "old_text": "AddWhitelistPermissionFlags(permissionFlags, addr)",
          "new_text": null,
          "old_line_content": "    AddWhitelistPermissionFlags(permissionFlags, addr);",
          "new_line_content": "                                            const CAddress& addr_bind,",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": "NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::Implicit)",
          "new_api": null,
          "old_text": "NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::Implicit)",
          "new_text": null,
          "old_line_content": "    if (NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::Implicit)) {",
          "new_line_content": "                                            const CAddress& addr)",
          "content_same": false
        },
        {
          "line": 1137,
          "old_api": "NetPermissions::ClearFlag(permissionFlags, NetPermissionFlags::Implicit)",
          "new_api": null,
          "old_text": "NetPermissions::ClearFlag(permissionFlags, NetPermissionFlags::Implicit)",
          "new_text": null,
          "old_line_content": "        NetPermissions::ClearFlag(permissionFlags, NetPermissionFlags::Implicit);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1138,
          "old_api": "NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::ForceRelay)",
          "new_api": null,
          "old_text": "NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::ForceRelay)",
          "new_text": null,
          "old_line_content": "        if (gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::ForceRelay);",
          "new_line_content": "    int nInbound = 0;",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": "NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::Relay)",
          "new_api": null,
          "old_text": "NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::Relay)",
          "new_text": null,
          "old_line_content": "        if (gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)) NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::Relay);",
          "new_line_content": "    int nMaxInbound = nMaxConnections - m_max_outbound;",
          "content_same": false
        },
        {
          "line": 1140,
          "old_api": "NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::Mempool)",
          "new_api": null,
          "old_text": "NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::Mempool)",
          "new_text": null,
          "old_line_content": "        NetPermissions::AddFlag(permissionFlags, NetPermissionFlags::Mempool);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1152,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "addr.ToString()",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"connection from %s dropped: not accepting new connections\\n\", addr.ToString());",
          "new_line_content": "        for (const CNode* pnode : m_nodes) {",
          "content_same": false
        },
        {
          "line": 1156,
          "old_api": "Get",
          "new_api": null,
          "old_text": "sock->Get()",
          "new_text": null,
          "old_line_content": "    if (!IsSelectableSocket(sock->Get()))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": "IsBanned",
          "new_api": null,
          "old_text": "m_banman->IsBanned(addr)",
          "new_text": null,
          "old_line_content": "    bool banned = m_banman && m_banman->IsBanned(addr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": "NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::NoBan)",
          "new_api": null,
          "old_text": "NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::NoBan)",
          "new_text": null,
          "old_line_content": "    if (!NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::NoBan) && banned)",
          "new_line_content": "    // According to the internet TCP_NODELAY is not carried into accepted sockets",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": "IsDiscouraged",
          "new_api": null,
          "old_text": "m_banman->IsDiscouraged(addr)",
          "new_text": null,
          "old_line_content": "    bool discouraged = m_banman && m_banman->IsDiscouraged(addr);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1178,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "addr.ToString()",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"connection from %s dropped (discouraged)\\n\", addr.ToString());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1186,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::NET, \"failed to find an eviction candidate - connection dropped (full)\\n\")",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"failed to find an eviction candidate - connection dropped (full)\\n\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": "GetNewNodeId",
          "new_api": null,
          "old_text": "GetNewNodeId()",
          "new_text": null,
          "old_line_content": "    NodeId id = GetNewNodeId();",
          "new_line_content": "            // No connection to evict, disconnect the new connection",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": "NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::BloomFilter)",
          "new_api": null,
          "old_text": "NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::BloomFilter)",
          "new_text": null,
          "old_line_content": "    if (NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::BloomFilter)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1196,
          "old_api": "static_cast<ServiceFlags>(nodeServices | NODE_BLOOM)",
          "new_api": null,
          "old_text": "static_cast<ServiceFlags>(nodeServices | NODE_BLOOM)",
          "new_text": null,
          "old_line_content": "        nodeServices = static_cast<ServiceFlags>(nodeServices | NODE_BLOOM);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1199,
          "old_api": "end",
          "new_api": null,
          "old_text": "m_onion_binds.end()",
          "new_text": null,
          "old_line_content": "    const bool inbound_onion = std::find(m_onion_binds.begin(), m_onion_binds.end(), addr_bind) != m_onion_binds.end();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1200,
          "old_api": "CalculateKeyedNetGroup",
          "new_api": null,
          "old_text": "CalculateKeyedNetGroup(addr)",
          "new_text": null,
          "old_line_content": "    CNode* pnode = new CNode(id, nodeServices, std::move(sock), addr, CalculateKeyedNetGroup(addr), nonce, addr_bind, \"\", ConnectionType::INBOUND, inbound_onion);",
          "new_line_content": "    ServiceFlags nodeServices = nLocalServices;",
          "content_same": false
        },
        {
          "line": 1204,
          "old_api": "InitializeNode",
          "new_api": null,
          "old_text": "m_msgproc->InitializeNode(pnode)",
          "new_text": null,
          "old_line_content": "    m_msgproc->InitializeNode(pnode);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1209,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_nodes_mutex);",
          "new_line_content": "    pnode->m_prefer_evict = discouraged;",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": "RandAddEvent",
          "new_api": null,
          "old_text": "RandAddEvent((uint32_t)id)",
          "new_text": null,
          "old_line_content": "    RandAddEvent((uint32_t)id);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": "begin",
          "new_api": null,
          "old_text": "WITH_LOCK(m_nodes_mutex,\n                                         return std::count_if(m_nodes.begin(), m_nodes.end(), [conn_type](CNode* node) { return node->m_conn_type == conn_type; });)",
          "new_text": null,
          "old_line_content": "    int existing_connections = WITH_LOCK(m_nodes_mutex,",
          "new_line_content": "    // no limit for FEELER connections since they're short-lived",
          "content_same": false
        },
        {
          "line": 1240,
          "old_api": "end",
          "new_api": null,
          "old_text": "m_nodes.end()",
          "new_text": null,
          "old_line_content": "                                         return std::count_if(m_nodes.begin(), m_nodes.end(), [conn_type](CNode* node) { return node->m_conn_type == conn_type; }););",
          "new_line_content": "    case ConnectionType::FEELER:",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "address.c_str()",
          "new_text": null,
          "old_line_content": "    OpenNetworkConnection(CAddress(), false, &grant, address.c_str(), conn_type);",
          "new_line_content": "    if (max_connections != std::nullopt && existing_connections >= max_connections) return false;",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_nodes_mutex);",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 1275,
          "old_api": "end",
          "new_api": null,
          "old_text": "m_nodes.end()",
          "new_text": null,
          "old_line_content": "                m_nodes.erase(remove(m_nodes.begin(), m_nodes.end(), pnode), m_nodes.end());",
          "new_line_content": "        std::vector<CNode*> nodes_copy = m_nodes;",
          "content_same": false
        },
        {
          "line": 1278,
          "old_api": "Release",
          "new_api": null,
          "old_text": "pnode->grantOutbound.Release()",
          "new_text": null,
          "old_line_content": "                pnode->grantOutbound.Release();",
          "new_line_content": "            if (pnode->fDisconnect)",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "m_nodes_disconnected.push_back(pnode)",
          "new_text": null,
          "old_line_content": "                m_nodes_disconnected.push_back(pnode);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1295,
          "old_api": "GetRefCount",
          "new_api": null,
          "old_text": "pnode->GetRefCount()",
          "new_text": null,
          "old_line_content": "            if (pnode->GetRefCount() <= 0) {",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1296,
          "old_api": "remove",
          "new_api": null,
          "old_text": "m_nodes_disconnected.remove(pnode)",
          "new_text": null,
          "old_line_content": "                m_nodes_disconnected.remove(pnode);",
          "new_line_content": "        // Delete disconnected nodes",
          "content_same": false
        },
        {
          "line": 1297,
          "old_api": "DeleteNode",
          "new_api": null,
          "old_text": "DeleteNode(pnode)",
          "new_text": null,
          "old_line_content": "                DeleteNode(pnode);",
          "new_line_content": "        std::list<CNode*> nodes_disconnected_copy = m_nodes_disconnected;",
          "content_same": false
        },
        {
          "line": 1307,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_nodes_mutex);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1308,
          "old_api": "size",
          "new_api": null,
          "old_text": "m_nodes.size()",
          "new_text": null,
          "old_line_content": "        nodes_size = m_nodes.size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1327,
          "old_api": "GetTime<std::chrono::seconds>()",
          "new_api": null,
          "old_text": "GetTime<std::chrono::seconds>()",
          "new_text": null,
          "old_line_content": "    const auto now{GetTime<std::chrono::seconds>()};",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1328,
          "old_api": "load",
          "new_api": null,
          "old_text": "node.m_last_send.load()",
          "new_text": null,
          "old_line_content": "    const auto last_send{node.m_last_send.load()};",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1329,
          "old_api": "load",
          "new_api": null,
          "old_text": "node.m_last_recv.load()",
          "new_text": null,
          "old_line_content": "    const auto last_recv{node.m_last_recv.load()};",
          "new_line_content": "bool CConnman::InactivityCheck(const CNode& node) const",
          "content_same": false
        },
        {
          "line": 1331,
          "old_api": "ShouldRunInactivityChecks",
          "new_api": null,
          "old_text": "ShouldRunInactivityChecks(node, now)",
          "new_text": null,
          "old_line_content": "    if (!ShouldRunInactivityChecks(node, now)) return false;",
          "new_line_content": "    // Tests that see disconnects after using mocktime can start nodes with a",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "node.GetId()",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"socket receive timeout: %is peer=%d\\n\", count_seconds(now - last_recv), node.GetId());",
          "new_line_content": "    if (now > last_send + TIMEOUT_INTERVAL) {",
          "content_same": false
        },
        {
          "line": 1349,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "node.GetId()",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"version handshake timeout peer=%d\\n\", node.GetId());",
          "new_line_content": "    if (now > last_recv + TIMEOUT_INTERVAL) {",
          "content_same": false
        },
        {
          "line": 1362,
          "old_api": "Get",
          "new_api": null,
          "old_text": "hListenSocket.sock->Get()",
          "new_text": null,
          "old_line_content": "        recv_set.insert(hListenSocket.sock->Get());",
          "new_line_content": "bool CConnman::GenerateSelectSet(const std::vector<CNode*>& nodes,",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pnode->cs_vSend)",
          "new_text": null,
          "old_line_content": "            LOCK(pnode->cs_vSend);",
          "new_line_content": "        // * Hand off all complete messages to the processor, to be handled without",
          "content_same": false
        },
        {
          "line": 1381,
          "old_api": "empty",
          "new_api": null,
          "old_text": "pnode->vSendMsg.empty()",
          "new_text": null,
          "old_line_content": "            select_send = !pnode->vSendMsg.empty();",
          "new_line_content": "        //   blocking here.",
          "content_same": false
        },
        {
          "line": 1384,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pnode->cs_hSocket)",
          "new_text": null,
          "old_line_content": "        LOCK(pnode->cs_hSocket);",
          "new_line_content": "        bool select_send;",
          "content_same": false
        },
        {
          "line": 1389,
          "old_api": "Get",
          "new_api": null,
          "old_text": "pnode->m_sock->Get()",
          "new_text": null,
          "old_line_content": "        error_set.insert(pnode->m_sock->Get());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1391,
          "old_api": "Get",
          "new_api": null,
          "old_text": "pnode->m_sock->Get()",
          "new_text": null,
          "old_line_content": "            send_set.insert(pnode->m_sock->Get());",
          "new_line_content": "        if (!pnode->m_sock) {",
          "content_same": false
        },
        {
          "line": 1399,
          "old_api": "empty",
          "new_api": null,
          "old_text": "error_set.empty()",
          "new_text": null,
          "old_line_content": "    return !recv_set.empty() || !send_set.empty() || !error_set.empty();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1409,
          "old_api": "GenerateSelectSet",
          "new_api": null,
          "old_text": "GenerateSelectSet(nodes, recv_select_set, send_select_set, error_select_set)",
          "new_text": null,
          "old_line_content": "    if (!GenerateSelectSet(nodes, recv_select_set, send_select_set, error_select_set)) {",
          "new_line_content": "void CConnman::SocketEvents(const std::vector<CNode*>& nodes,",
          "content_same": false
        },
        {
          "line": 1410,
          "old_api": "std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS)",
          "new_api": null,
          "old_text": "std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS)",
          "new_text": null,
          "old_line_content": "        interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS));",
          "new_line_content": "                            std::set<SOCKET>& recv_set,",
          "content_same": false
        },
        {
          "line": 1432,
          "old_api": "size",
          "new_api": null,
          "old_text": "pollfds.size()",
          "new_text": null,
          "old_line_content": "    vpollfds.reserve(pollfds.size());",
          "new_line_content": "        pollfds[socket_id].fd = socket_id;",
          "content_same": false
        },
        {
          "line": 1434,
          "old_api": "std::move(it.second)",
          "new_api": null,
          "old_text": "std::move(it.second)",
          "new_text": null,
          "old_line_content": "        vpollfds.push_back(std::move(it.second));",
          "new_line_content": "        pollfds[socket_id].events |= POLLERR|POLLHUP;",
          "content_same": false
        },
        {
          "line": 1437,
          "old_api": "size",
          "new_api": null,
          "old_text": "vpollfds.size()",
          "new_text": null,
          "old_line_content": "    if (poll(vpollfds.data(), vpollfds.size(), SELECT_TIMEOUT_MILLISECONDS) < 0) return;",
          "new_line_content": "    std::vector<struct pollfd> vpollfds;",
          "content_same": false
        },
        {
          "line": 1442,
          "old_api": "insert",
          "new_api": null,
          "old_text": "recv_set.insert(pollfd_entry.fd)",
          "new_text": null,
          "old_line_content": "        if (pollfd_entry.revents & POLLIN)            recv_set.insert(pollfd_entry.fd);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1444,
          "old_api": "insert",
          "new_api": null,
          "old_text": "error_set.insert(pollfd_entry.fd)",
          "new_text": null,
          "old_line_content": "        if (pollfd_entry.revents & (POLLERR|POLLHUP)) error_set.insert(pollfd_entry.fd);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1454,
          "old_api": "GenerateSelectSet",
          "new_api": null,
          "old_text": "GenerateSelectSet(nodes, recv_select_set, send_select_set, error_select_set)",
          "new_text": null,
          "old_line_content": "    if (!GenerateSelectSet(nodes, recv_select_set, send_select_set, error_select_set)) {",
          "new_line_content": "void CConnman::SocketEvents(const std::vector<CNode*>& nodes,",
          "content_same": false
        },
        {
          "line": 1455,
          "old_api": "std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS)",
          "new_api": null,
          "old_text": "std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS)",
          "new_text": null,
          "old_line_content": "        interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS));",
          "new_line_content": "                            std::set<SOCKET>& recv_set,",
          "content_same": false
        },
        {
          "line": 1469,
          "old_api": "FD_ZERO",
          "new_api": null,
          "old_text": "FD_ZERO(&fdsetRecv)",
          "new_text": null,
          "old_line_content": "    FD_ZERO(&fdsetRecv);",
          "new_line_content": "    timeout.tv_sec  = 0;",
          "content_same": false
        },
        {
          "line": 1470,
          "old_api": "FD_ZERO",
          "new_api": null,
          "old_text": "FD_ZERO(&fdsetSend)",
          "new_text": null,
          "old_line_content": "    FD_ZERO(&fdsetSend);",
          "new_line_content": "    timeout.tv_usec = SELECT_TIMEOUT_MILLISECONDS * 1000; // frequency to poll pnode->vSend",
          "content_same": false
        },
        {
          "line": 1471,
          "old_api": "FD_ZERO",
          "new_api": null,
          "old_text": "FD_ZERO(&fdsetError)",
          "new_text": null,
          "old_line_content": "    FD_ZERO(&fdsetError);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1480,
          "old_api": "FD_SET",
          "new_api": null,
          "old_text": "FD_SET(hSocket, &fdsetSend)",
          "new_text": null,
          "old_line_content": "        FD_SET(hSocket, &fdsetSend);",
          "new_line_content": "    for (SOCKET hSocket : recv_select_set) {",
          "content_same": false
        },
        {
          "line": 1485,
          "old_api": "FD_SET",
          "new_api": null,
          "old_text": "FD_SET(hSocket, &fdsetError)",
          "new_text": null,
          "old_line_content": "        FD_SET(hSocket, &fdsetError);",
          "new_line_content": "    for (SOCKET hSocket : send_select_set) {",
          "content_same": false
        },
        {
          "line": 1489,
          "old_api": "select",
          "new_api": null,
          "old_text": "select(hSocketMax + 1, &fdsetRecv, &fdsetSend, &fdsetError, &timeout)",
          "new_text": null,
          "old_line_content": "    int nSelect = select(hSocketMax + 1, &fdsetRecv, &fdsetSend, &fdsetError, &timeout);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1496,
          "old_api": "WSAGetLastError",
          "new_api": null,
          "old_text": "WSAGetLastError()",
          "new_text": null,
          "old_line_content": "        int nErr = WSAGetLastError();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1497,
          "old_api": "NetworkErrorString",
          "new_api": null,
          "old_text": "NetworkErrorString(nErr)",
          "new_text": null,
          "old_line_content": "        LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));",
          "new_line_content": "    if (interruptNet)",
          "content_same": false
        },
        {
          "line": 1499,
          "old_api": "FD_SET",
          "new_api": null,
          "old_text": "FD_SET(i, &fdsetRecv)",
          "new_text": null,
          "old_line_content": "            FD_SET(i, &fdsetRecv);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1500,
          "old_api": "FD_ZERO",
          "new_api": null,
          "old_text": "FD_ZERO(&fdsetSend)",
          "new_text": null,
          "old_line_content": "        FD_ZERO(&fdsetSend);",
          "new_line_content": "    if (nSelect == SOCKET_ERROR)",
          "content_same": false
        },
        {
          "line": 1501,
          "old_api": "FD_ZERO",
          "new_api": null,
          "old_text": "FD_ZERO(&fdsetError)",
          "new_text": null,
          "old_line_content": "        FD_ZERO(&fdsetError);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1539,
          "old_api": "Nodes",
          "new_api": null,
          "old_text": "snap.Nodes()",
          "new_text": null,
          "old_line_content": "        SocketEvents(snap.Nodes(), recv_set, send_set, error_set);",
          "new_line_content": "        const NodesSnapshot snap{*this, /*shuffle=*/false};",
          "content_same": false
        },
        {
          "line": 1542,
          "old_api": "Nodes",
          "new_api": null,
          "old_text": "snap.Nodes()",
          "new_text": null,
          "old_line_content": "        SocketHandlerConnected(snap.Nodes(), recv_set, send_set, error_set);",
          "new_line_content": "        // listening sockets in one call (\"readiness\" as in poll(2) or",
          "content_same": false
        },
        {
          "line": 1546,
          "old_api": "SocketHandlerListening",
          "new_api": null,
          "old_text": "SocketHandlerListening(recv_set)",
          "new_text": null,
          "old_line_content": "    SocketHandlerListening(recv_set);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1565,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pnode->cs_hSocket)",
          "new_text": null,
          "old_line_content": "            LOCK(pnode->cs_hSocket);",
          "new_line_content": "        // Receive",
          "content_same": false
        },
        {
          "line": 1569,
          "old_api": "Get",
          "new_api": null,
          "old_text": "pnode->m_sock->Get()",
          "new_text": null,
          "old_line_content": "            recvSet = recv_set.count(pnode->m_sock->Get()) > 0;",
          "new_line_content": "        bool errorSet = false;",
          "content_same": false
        },
        {
          "line": 1570,
          "old_api": "Get",
          "new_api": null,
          "old_text": "pnode->m_sock->Get()",
          "new_text": null,
          "old_line_content": "            sendSet = send_set.count(pnode->m_sock->Get()) > 0;",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1579,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pnode->cs_hSocket)",
          "new_text": null,
          "old_line_content": "                LOCK(pnode->cs_hSocket);",
          "new_line_content": "        if (recvSet || errorSet)",
          "content_same": false
        },
        {
          "line": 1583,
          "old_api": "Recv",
          "new_api": null,
          "old_text": "pnode->m_sock->Recv(pchBuf, sizeof(pchBuf), MSG_DONTWAIT)",
          "new_text": null,
          "old_line_content": "                nBytes = pnode->m_sock->Recv(pchBuf, sizeof(pchBuf), MSG_DONTWAIT);",
          "new_line_content": "            int nBytes = 0;",
          "content_same": false
        },
        {
          "line": 1588,
          "old_api": "ReceiveMsgBytes",
          "new_api": null,
          "old_text": "pnode->ReceiveMsgBytes({pchBuf, (size_t)nBytes}, notify)",
          "new_text": null,
          "old_line_content": "                if (!pnode->ReceiveMsgBytes({pchBuf, (size_t)nBytes}, notify)) {",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1591,
          "old_api": "RecordBytesRecv",
          "new_api": null,
          "old_text": "RecordBytesRecv(nBytes)",
          "new_text": null,
          "old_line_content": "                RecordBytesRecv(nBytes);",
          "new_line_content": "            if (nBytes > 0)",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": "begin",
          "new_api": null,
          "old_text": "pnode->vRecvMsg.begin()",
          "new_text": null,
          "old_line_content": "                        pnode->vProcessMsg.splice(pnode->vProcessMsg.end(), pnode->vRecvMsg, pnode->vRecvMsg.begin(), it);",
          "new_line_content": "                        // vRecvMsg contains only completed CNetMessage",
          "content_same": false
        },
        {
          "line": 1606,
          "old_api": "WakeMessageHandler",
          "new_api": null,
          "old_text": "WakeMessageHandler()",
          "new_text": null,
          "old_line_content": "                    WakeMessageHandler();",
          "new_line_content": "                    {",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pnode->GetId()",
          "new_text": null,
          "old_line_content": "                    LogPrint(BCLog::NET, \"socket closed for peer=%d\\n\", pnode->GetId());",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": "CloseSocketDisconnect",
          "new_api": null,
          "old_text": "pnode->CloseSocketDisconnect()",
          "new_text": null,
          "old_line_content": "                pnode->CloseSocketDisconnect();",
          "new_line_content": "            else if (nBytes == 0)",
          "content_same": false
        },
        {
          "line": 1620,
          "old_api": "WSAGetLastError",
          "new_api": null,
          "old_text": "WSAGetLastError()",
          "new_text": null,
          "old_line_content": "                int nErr = WSAGetLastError();",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1624,
          "old_api": "NetworkErrorString",
          "new_api": null,
          "old_text": "NetworkErrorString(nErr)",
          "new_text": null,
          "old_line_content": "                        LogPrint(BCLog::NET, \"socket recv error for peer=%d: %s\\n\", pnode->GetId(), NetworkErrorString(nErr));",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1633,
          "old_api": "SocketSendData",
          "new_api": null,
          "old_text": "SocketSendData(*pnode)",
          "new_text": null,
          "old_line_content": "            size_t bytes_sent = WITH_LOCK(pnode->cs_vSend, return SocketSendData(*pnode));",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1634,
          "old_api": "RecordBytesSent",
          "new_api": null,
          "old_text": "RecordBytesSent(bytes_sent)",
          "new_text": null,
          "old_line_content": "            if (bytes_sent) RecordBytesSent(bytes_sent);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1637,
          "old_api": "InactivityCheck",
          "new_api": null,
          "old_text": "InactivityCheck(*pnode)",
          "new_text": null,
          "old_line_content": "        if (InactivityCheck(*pnode)) pnode->fDisconnect = true;",
          "new_line_content": "        if (sendSet) {",
          "content_same": false
        },
        {
          "line": 1647,
          "old_api": "Get",
          "new_api": null,
          "old_text": "listen_socket.sock->Get()",
          "new_text": null,
          "old_line_content": "        if (recv_set.count(listen_socket.sock->Get()) > 0) {",
          "new_line_content": "void CConnman::SocketHandlerListening(const std::set<SOCKET>& recv_set)",
          "content_same": false
        },
        {
          "line": 1648,
          "old_api": "AcceptConnection",
          "new_api": null,
          "old_text": "AcceptConnection(listen_socket)",
          "new_text": null,
          "old_line_content": "            AcceptConnection(listen_socket);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1655,
          "old_api": "SetSyscallSandboxPolicy",
          "new_api": null,
          "old_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET)",
          "new_text": null,
          "old_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": "DisconnectNodes",
          "new_api": null,
          "old_text": "DisconnectNodes()",
          "new_text": null,
          "old_line_content": "        DisconnectNodes();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1659,
          "old_api": "NotifyNumConnectionsChanged",
          "new_api": null,
          "old_text": "NotifyNumConnectionsChanged()",
          "new_text": null,
          "old_line_content": "        NotifyNumConnectionsChanged();",
          "new_line_content": "void CConnman::ThreadSocketHandler()",
          "content_same": false
        },
        {
          "line": 1660,
          "old_api": "SocketHandler",
          "new_api": null,
          "old_text": "SocketHandler()",
          "new_text": null,
          "old_line_content": "        SocketHandler();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1667,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(mutexMsgProc)",
          "new_text": null,
          "old_line_content": "        LOCK(mutexMsgProc);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1670,
          "old_api": "notify_one",
          "new_api": null,
          "old_text": "condMsgProc.notify_one()",
          "new_text": null,
          "old_line_content": "    condMsgProc.notify_one();",
          "new_line_content": "void CConnman::WakeMessageHandler()",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": "SetSyscallSandboxPolicy",
          "new_api": null,
          "old_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::INITIALIZATION_DNS_SEED)",
          "new_text": null,
          "old_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::INITIALIZATION_DNS_SEED);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1677,
          "old_api": "DNSSeeds",
          "new_api": null,
          "old_text": "Params().DNSSeeds()",
          "new_text": null,
          "old_line_content": "    std::vector<std::string> seeds = Params().DNSSeeds();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1678,
          "old_api": "end",
          "new_api": null,
          "old_text": "seeds.end()",
          "new_text": null,
          "old_line_content": "    Shuffle(seeds.begin(), seeds.end(), rng);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1682,
          "old_api": "GetBoolArg",
          "new_api": null,
          "old_text": "gArgs.GetBoolArg(\"-forcednsseed\", DEFAULT_FORCEDNSSEED)",
          "new_text": null,
          "old_line_content": "    if (gArgs.GetBoolArg(\"-forcednsseed\", DEFAULT_FORCEDNSSEED)) {",
          "new_line_content": "    FastRandomContext rng;",
          "content_same": false
        },
        {
          "line": 1685,
          "old_api": "size",
          "new_api": null,
          "old_text": "addrman.size()",
          "new_text": null,
          "old_line_content": "    } else if (addrman.size() == 0) {",
          "new_line_content": "    int seeds_right_now = 0; // Number of seeds left before testing if we have enough connections",
          "content_same": false
        },
        {
          "line": 1689,
          "old_api": "size",
          "new_api": null,
          "old_text": "seeds.size()",
          "new_text": null,
          "old_line_content": "        seeds_right_now = seeds.size();",
          "new_line_content": "        // When -forcednsseed is provided, query all.",
          "content_same": false
        },
        {
          "line": 1704,
          "old_api": "size",
          "new_api": null,
          "old_text": "addrman.size()",
          "new_text": null,
          "old_line_content": "    const std::chrono::seconds seeds_wait_time = (addrman.size() >= DNSSEEDS_DELAY_PEER_THRESHOLD ? DNSSEEDS_DELAY_MANY_PEERS : DNSSEEDS_DELAY_FEW_PEERS);",
          "new_line_content": "    // * When querying DNS seeds query a few at once, this ensures",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": "count",
          "new_api": null,
          "old_text": "seeds_wait_time.count()",
          "new_text": null,
          "old_line_content": "                LogPrintf(\"Waiting %d seconds before querying DNS seeds.\\n\", seeds_wait_time.count());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1713,
          "old_api": "count",
          "new_api": null,
          "old_text": "to_wait.count()",
          "new_text": null,
          "old_line_content": "                while (to_wait.count() > 0) {",
          "new_line_content": "        if (seeds_right_now == 0) {",
          "content_same": false
        },
        {
          "line": 1718,
          "old_api": "sleep_for",
          "new_api": null,
          "old_text": "interruptNet.sleep_for(w)",
          "new_text": null,
          "old_line_content": "                    if (!interruptNet.sleep_for(w)) return;",
          "new_line_content": "                std::chrono::seconds to_wait = seeds_wait_time;",
          "content_same": false
        },
        {
          "line": 1725,
          "old_api": "IsFullOutboundConn",
          "new_api": null,
          "old_text": "pnode->IsFullOutboundConn()",
          "new_text": null,
          "old_line_content": "                            if (pnode->fSuccessfullyConnected && pnode->IsFullOutboundConn()) ++nRelevant;",
          "new_line_content": "                    to_wait -= w;",
          "content_same": false
        },
        {
          "line": 1730,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"%d addresses found from DNS seeds\\n\", found)",
          "new_text": null,
          "old_line_content": "                            LogPrintf(\"%d addresses found from DNS seeds\\n\", found);",
          "new_line_content": "                        for (const CNode* pnode : m_nodes) {",
          "content_same": false
        },
        {
          "line": 1733,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"P2P peers available. Skipped DNS seeding.\\n\")",
          "new_text": null,
          "old_line_content": "                            LogPrintf(\"P2P peers available. Skipped DNS seeding.\\n\");",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 1745,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"Waiting for network to be reactivated before querying DNS seeds.\\n\")",
          "new_text": null,
          "old_line_content": "            LogPrintf(\"Waiting for network to be reactivated before querying DNS seeds.\\n\");",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1747,
          "old_api": "sleep_for",
          "new_api": null,
          "old_text": "interruptNet.sleep_for(std::chrono::seconds{1})",
          "new_text": null,
          "old_line_content": "                if (!interruptNet.sleep_for(std::chrono::seconds{1})) return;",
          "new_line_content": "        if (interruptNet) return;",
          "content_same": false
        },
        {
          "line": 1752,
          "old_api": "HaveNameProxy",
          "new_api": null,
          "old_text": "HaveNameProxy()",
          "new_text": null,
          "old_line_content": "        if (HaveNameProxy()) {",
          "new_line_content": "            do {",
          "content_same": false
        },
        {
          "line": 1760,
          "old_api": "SetInternal",
          "new_api": null,
          "old_text": "resolveSource.SetInternal(host)",
          "new_text": null,
          "old_line_content": "            if (!resolveSource.SetInternal(host)) {",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 1767,
          "old_api": "GetDefaultPort",
          "new_api": null,
          "old_text": "Params().GetDefaultPort()",
          "new_text": null,
          "old_line_content": "                    CAddress addr = CAddress(CService(ip, Params().GetDefaultPort()), requiredServiceBits);",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 1768,
          "old_api": "randrange",
          "new_api": null,
          "old_text": "rng.randrange(4*nOneDay)",
          "new_text": null,
          "old_line_content": "                    addr.nTime = GetTime() - 3*nOneDay - rng.randrange(4*nOneDay); // use a random age between 3 and 7 days old",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1769,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "vAdd.push_back(addr)",
          "new_text": null,
          "old_line_content": "                    vAdd.push_back(addr);",
          "new_line_content": "            unsigned int nMaxIPs = 256; // Limits number of IPs learned from a DNS seed",
          "content_same": false
        },
        {
          "line": 1772,
          "old_api": "Add",
          "new_api": null,
          "old_text": "addrman.Add(vAdd, resolveSource)",
          "new_text": null,
          "old_line_content": "                addrman.Add(vAdd, resolveSource);",
          "new_line_content": "                    int nOneDay = 24*3600;",
          "content_same": false
        },
        {
          "line": 1776,
          "old_api": "AddAddrFetch",
          "new_api": null,
          "old_text": "AddAddrFetch(seed)",
          "new_text": null,
          "old_line_content": "                AddAddrFetch(seed);",
          "new_line_content": "                    found++;",
          "content_same": false
        },
        {
          "line": 1781,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"%d addresses found from DNS seeds\\n\", found)",
          "new_text": null,
          "old_line_content": "    LogPrintf(\"%d addresses found from DNS seeds\\n\", found);",
          "new_line_content": "                // instead using them as a addrfetch to get nodes with our desired service bits.",
          "content_same": false
        },
        {
          "line": 1786,
          "old_api": "GetTimeMillis",
          "new_api": null,
          "old_text": "GetTimeMillis()",
          "new_text": null,
          "old_line_content": "    int64_t nStart = GetTimeMillis();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1788,
          "old_api": "DumpPeerAddresses",
          "new_api": null,
          "old_text": "DumpPeerAddresses(::gArgs, addrman)",
          "new_text": null,
          "old_line_content": "    DumpPeerAddresses(::gArgs, addrman);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1790,
          "old_api": "size",
          "new_api": null,
          "old_text": "LogPrint(BCLog::NET, \"Flushed %d addresses to peers.dat  %dms\\n\",\n           addrman.size(), GetTimeMillis() - nStart)",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::NET, \"Flushed %d addresses to peers.dat  %dms\\n\",",
          "new_line_content": "void CConnman::DumpAddresses()",
          "content_same": false
        },
        {
          "line": 1791,
          "old_api": "GetTimeMillis",
          "new_api": null,
          "old_text": "GetTimeMillis()",
          "new_text": null,
          "old_line_content": "           addrman.size(), GetTimeMillis() - nStart);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1798,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_addr_fetches_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_addr_fetches_mutex);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1799,
          "old_api": "empty",
          "new_api": null,
          "old_text": "m_addr_fetches.empty()",
          "new_text": null,
          "old_line_content": "        if (m_addr_fetches.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1801,
          "old_api": "front",
          "new_api": null,
          "old_text": "m_addr_fetches.front()",
          "new_text": null,
          "old_line_content": "        strDest = m_addr_fetches.front();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1802,
          "old_api": "pop_front",
          "new_api": null,
          "old_text": "m_addr_fetches.pop_front()",
          "new_text": null,
          "old_line_content": "        m_addr_fetches.pop_front();",
          "new_line_content": "    std::string strDest;",
          "content_same": false
        },
        {
          "line": 1819,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::NET, \"net: setting try another outbound peer=%s\\n\", flag ? \"true\" : \"false\")",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::NET, \"net: setting try another outbound peer=%s\\n\", flag ? \"true\" : \"false\");",
          "new_line_content": "    return m_try_another_outbound_peer;",
          "content_same": false
        },
        {
          "line": 1832,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_nodes_mutex);",
          "new_line_content": "// (so that we don't decide we're over our desired connection limit, and then",
          "content_same": false
        },
        {
          "line": 1834,
          "old_api": "IsFullOutboundConn",
          "new_api": null,
          "old_text": "pnode->IsFullOutboundConn()",
          "new_text": null,
          "old_line_content": "            if (pnode->fSuccessfullyConnected && !pnode->fDisconnect && pnode->IsFullOutboundConn()) {",
          "new_line_content": "int CConnman::GetExtraFullOutboundCount() const",
          "content_same": false
        },
        {
          "line": 1839,
          "old_api": "std::max(full_outbound_peers - m_max_outbound_full_relay, 0)",
          "new_api": null,
          "old_text": "std::max(full_outbound_peers - m_max_outbound_full_relay, 0)",
          "new_text": null,
          "old_line_content": "    return std::max(full_outbound_peers - m_max_outbound_full_relay, 0);",
          "new_line_content": "        for (const CNode* pnode : m_nodes) {",
          "content_same": false
        },
        {
          "line": 1846,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_nodes_mutex);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1848,
          "old_api": "IsBlockOnlyConn",
          "new_api": null,
          "old_text": "pnode->IsBlockOnlyConn()",
          "new_text": null,
          "old_line_content": "            if (pnode->fSuccessfullyConnected && !pnode->fDisconnect && pnode->IsBlockOnlyConn()) {",
          "new_line_content": "int CConnman::GetExtraBlockRelayCount() const",
          "content_same": false
        },
        {
          "line": 1853,
          "old_api": "std::max(block_relay_peers - m_max_outbound_block_relay, 0)",
          "new_api": null,
          "old_text": "std::max(block_relay_peers - m_max_outbound_block_relay, 0)",
          "new_text": null,
          "old_line_content": "    return std::max(block_relay_peers - m_max_outbound_block_relay, 0);",
          "new_line_content": "        for (const CNode* pnode : m_nodes) {",
          "content_same": false
        },
        {
          "line": 1858,
          "old_api": "SetSyscallSandboxPolicy",
          "new_api": null,
          "old_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET_OPEN_CONNECTION)",
          "new_text": null,
          "old_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET_OPEN_CONNECTION);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1860,
          "old_api": "empty",
          "new_api": null,
          "old_text": "connect.empty()",
          "new_text": null,
          "old_line_content": "    if (!connect.empty())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1868,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "strAddr.c_str()",
          "new_text": null,
          "old_line_content": "                OpenNetworkConnection(addr, false, nullptr, strAddr.c_str(), ConnectionType::MANUAL);",
          "new_line_content": "        for (int64_t nLoop = 0;; nLoop++)",
          "content_same": false
        },
        {
          "line": 1871,
          "old_api": "std::chrono::milliseconds(500)",
          "new_api": null,
          "old_text": "std::chrono::milliseconds(500)",
          "new_text": null,
          "old_line_content": "                    if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))",
          "new_line_content": "            for (const std::string& strAddr : connect)",
          "content_same": false
        },
        {
          "line": 1875,
          "old_api": "std::chrono::milliseconds(500)",
          "new_api": null,
          "old_text": "std::chrono::milliseconds(500)",
          "new_text": null,
          "old_line_content": "            if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))",
          "new_line_content": "                for (int i = 0; i < 10 && i < nLoop; i++)",
          "content_same": false
        },
        {
          "line": 1884,
          "old_api": "PoissonNextSend",
          "new_api": null,
          "old_text": "PoissonNextSend(start, FEELER_INTERVAL)",
          "new_text": null,
          "old_line_content": "    auto next_feeler = PoissonNextSend(start, FEELER_INTERVAL);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1885,
          "old_api": "PoissonNextSend",
          "new_api": null,
          "old_text": "PoissonNextSend(start, EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL)",
          "new_text": null,
          "old_line_content": "    auto next_extra_block_relay = PoissonNextSend(start, EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1886,
          "old_api": "GetBoolArg",
          "new_api": null,
          "old_text": "gArgs.GetBoolArg(\"-dnsseed\", DEFAULT_DNSSEED)",
          "new_text": null,
          "old_line_content": "    const bool dnsseed = gArgs.GetBoolArg(\"-dnsseed\", DEFAULT_DNSSEED);",
          "new_line_content": "    // Initiate network connections",
          "content_same": false
        },
        {
          "line": 1895,
          "old_api": "ProcessAddrFetch",
          "new_api": null,
          "old_text": "ProcessAddrFetch()",
          "new_text": null,
          "old_line_content": "        ProcessAddrFetch();",
          "new_line_content": "    if (!add_fixed_seeds) {",
          "content_same": false
        },
        {
          "line": 1897,
          "old_api": "std::chrono::milliseconds(500)",
          "new_api": null,
          "old_text": "std::chrono::milliseconds(500)",
          "new_text": null,
          "old_line_content": "        if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1904,
          "old_api": "size",
          "new_api": null,
          "old_text": "addrman.size()",
          "new_text": null,
          "old_line_content": "        if (add_fixed_seeds && addrman.size() == 0) {",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 1911,
          "old_api": "GetTime<std::chrono::seconds>()",
          "new_api": null,
          "old_text": "GetTime<std::chrono::seconds>()",
          "new_text": null,
          "old_line_content": "            if (GetTime<std::chrono::seconds>() > start + std::chrono::minutes{1}) {",
          "new_line_content": "            // When the node starts with an empty peers.dat, there are a few other sources of peers before",
          "content_same": false
        },
        {
          "line": 1913,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"Adding fixed seeds as 60 seconds have passed and addrman is empty\\n\")",
          "new_text": null,
          "old_line_content": "                LogPrintf(\"Adding fixed seeds as 60 seconds have passed and addrman is empty\\n\");",
          "new_line_content": "            // If none of those are available, we fallback on to fixed seeds immediately, else we allow",
          "content_same": false
        },
        {
          "line": 1918,
          "old_api": "LOCK2",
          "new_api": null,
          "old_text": "LOCK2(m_addr_fetches_mutex, m_added_nodes_mutex)",
          "new_text": null,
          "old_line_content": "                LOCK2(m_addr_fetches_mutex, m_added_nodes_mutex);",
          "new_line_content": "                add_fixed_seeds_now = true;",
          "content_same": false
        },
        {
          "line": 1921,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"Adding fixed seeds as -dnsseed=0, -addnode is not provided and all -seednode(s) attempted\\n\")",
          "new_text": null,
          "old_line_content": "                    LogPrintf(\"Adding fixed seeds as -dnsseed=0, -addnode is not provided and all -seednode(s) attempted\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1928,
          "old_api": "FixedSeeds",
          "new_api": null,
          "old_text": "Params().FixedSeeds()",
          "new_text": null,
          "old_line_content": "                addrman.Add(ConvertSeeds(Params().FixedSeeds()), local);",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1944,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "            LOCK(m_nodes_mutex);",
          "new_line_content": "        // Only connect out to one peer per network group (/16 for IPv4).",
          "content_same": false
        },
        {
          "line": 1946,
          "old_api": "IsFullOutboundConn",
          "new_api": null,
          "old_text": "pnode->IsFullOutboundConn()",
          "new_text": null,
          "old_line_content": "                if (pnode->IsFullOutboundConn()) nOutboundFullRelay++;",
          "new_line_content": "        int nOutboundBlockRelay = 0;",
          "content_same": false
        },
        {
          "line": 1947,
          "old_api": "IsBlockOnlyConn",
          "new_api": null,
          "old_text": "pnode->IsBlockOnlyConn()",
          "new_text": null,
          "old_line_content": "                if (pnode->IsBlockOnlyConn()) nOutboundBlockRelay++;",
          "new_line_content": "        std::set<std::vector<unsigned char> > setConnected;",
          "content_same": false
        },
        {
          "line": 1962,
          "old_api": "GetAsmap",
          "new_api": null,
          "old_text": "addrman.GetAsmap()",
          "new_text": null,
          "old_line_content": "                        setConnected.insert(pnode->addr.GetGroup(addrman.GetAsmap()));",
          "new_line_content": "                    case ConnectionType::MANUAL:",
          "content_same": false
        },
        {
          "line": 1983,
          "old_api": "empty",
          "new_api": null,
          "old_text": "m_anchors.empty()",
          "new_text": null,
          "old_line_content": "        if (!m_anchors.empty() && (nOutboundBlockRelay < m_max_outbound_block_relay)) {",
          "new_line_content": "        // GetTryNewOutboundPeer() gets set when a stale tip is detected, so we",
          "content_same": false
        },
        {
          "line": 1990,
          "old_api": "GetTryNewOutboundPeer",
          "new_api": null,
          "old_text": "GetTryNewOutboundPeer()",
          "new_text": null,
          "old_line_content": "        } else if (GetTryNewOutboundPeer()) {",
          "new_line_content": "            conn_type = ConnectionType::BLOCK_RELAY;",
          "content_same": false
        },
        {
          "line": 2014,
          "old_api": "PoissonNextSend",
          "new_api": null,
          "old_text": "PoissonNextSend(now, EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL)",
          "new_text": null,
          "old_line_content": "            next_extra_block_relay = PoissonNextSend(now, EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL);",
          "new_line_content": "            //   newest block-relay-only peer delivers a block more recently.",
          "content_same": false
        },
        {
          "line": 2017,
          "old_api": "PoissonNextSend",
          "new_api": null,
          "old_text": "PoissonNextSend(now, FEELER_INTERVAL)",
          "new_text": null,
          "old_line_content": "            next_feeler = PoissonNextSend(now, FEELER_INTERVAL);",
          "new_line_content": "            // Because we can promote these connections to block-relay-only",
          "content_same": false
        },
        {
          "line": 2025,
          "old_api": "ResolveCollisions",
          "new_api": null,
          "old_text": "addrman.ResolveCollisions()",
          "new_text": null,
          "old_line_content": "        addrman.ResolveCollisions();",
          "new_line_content": "            fFeeler = true;",
          "content_same": false
        },
        {
          "line": 2027,
          "old_api": "GetAdjustedTime",
          "new_api": null,
          "old_text": "GetAdjustedTime()",
          "new_text": null,
          "old_line_content": "        int64_t nANow = GetAdjustedTime();",
          "new_line_content": "            // skip to next iteration of while loop",
          "content_same": false
        },
        {
          "line": 2032,
          "old_api": "back",
          "new_api": null,
          "old_text": "m_anchors.back()",
          "new_text": null,
          "old_line_content": "                const CAddress addr = m_anchors.back();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2034,
          "old_api": "IsReachable",
          "new_api": null,
          "old_text": "IsReachable(addr)",
          "new_text": null,
          "old_line_content": "                if (!addr.IsValid() || IsLocal(addr) || !IsReachable(addr) ||",
          "new_line_content": "        int nTries = 0;",
          "content_same": false
        },
        {
          "line": 2035,
          "old_api": "HasAllDesirableServiceFlags",
          "new_api": null,
          "old_text": "HasAllDesirableServiceFlags(addr.nServices)",
          "new_text": null,
          "old_line_content": "                    !HasAllDesirableServiceFlags(addr.nServices) ||",
          "new_line_content": "        while (!interruptNet)",
          "content_same": false
        },
        {
          "line": 2036,
          "old_api": "GetAsmap",
          "new_api": null,
          "old_text": "addrman.GetAsmap()",
          "new_text": null,
          "old_line_content": "                    setConnected.count(addr.GetGroup(addrman.GetAsmap()))) continue;",
          "new_line_content": "        {",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 137,
      "total_additions": 410,
      "total_deletions": 409,
      "total_api_changes": 956
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 7,
        "api_related_lines": 956,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          809,
          810,
          806
        ]
      }
    },
    "api_calls_before": 1076,
    "api_calls_after": 1077,
    "diff_info": {
      "added_lines": 7,
      "removed_lines": 1,
      "total_diff_lines": 20
    }
  }
}