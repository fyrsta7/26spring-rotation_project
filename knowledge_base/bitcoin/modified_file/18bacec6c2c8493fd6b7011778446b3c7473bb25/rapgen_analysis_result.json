{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/18bacec6c2c8493fd6b7011778446b3c7473bb25",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/18bacec6c2c8493fd6b7011778446b3c7473bb25/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/18bacec6c2c8493fd6b7011778446b3c7473bb25/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/18bacec6c2c8493fd6b7011778446b3c7473bb25/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 497,
          "old_api": "HaveCoinInCache",
          "new_api": "push_back",
          "old_text": "pcoinsTip->HaveCoinInCache(outpoint)",
          "new_text": "coins_to_uncache.push_back(txin.prevout)",
          "old_line_content": "            bool had_coin_in_cache = pcoinsTip->HaveCoinInCache(outpoint);",
          "new_line_content": "                coins_to_uncache.push_back(txin.prevout);",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": "DoS",
          "new_api": "AreInputsStandard",
          "old_text": "state.DoS(0, false, REJECT_NONSTANDARD, \"non-BIP68-final\")",
          "new_text": "AreInputsStandard(tx, view)",
          "old_line_content": "            return state.DoS(0, false, REJECT_NONSTANDARD, \"non-BIP68-final\");",
          "new_line_content": "        if (fRequireStandard && !AreInputsStandard(tx, view))",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": "AreInputsStandard",
          "new_api": "IsWitnessStandard",
          "old_text": "AreInputsStandard(tx, view)",
          "new_text": "IsWitnessStandard(tx, view)",
          "old_line_content": "        if (fRequireStandard && !AreInputsStandard(tx, view))",
          "new_line_content": "        if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": "Invalid",
          "new_api": "DoS",
          "old_text": "state.Invalid(false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\")",
          "new_text": "state.DoS(0, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true)",
          "old_line_content": "            return state.Invalid(false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");",
          "new_line_content": "            return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);",
          "content_same": false
        },
        {
          "line": 542,
          "old_api": "DoS",
          "new_api": "GetValueOut",
          "old_text": "state.DoS(0, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true)",
          "new_text": "tx.GetValueOut()",
          "old_line_content": "            return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);",
          "new_line_content": "        CAmount nValueOut = tx.GetValueOut();",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": "GetValueOut",
          "new_api": "ApplyDelta",
          "old_text": "tx.GetValueOut()",
          "new_text": "pool.ApplyDelta(hash, nModifiedFees)",
          "old_line_content": "        CAmount nValueOut = tx.GetValueOut();",
          "new_line_content": "        pool.ApplyDelta(hash, nModifiedFees);",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": "strprintf",
          "new_api": "GetFee",
          "old_text": "strprintf(\"%d < %d\", nFees, mempoolRejectFee)",
          "new_text": "::minRelayTxFee.GetFee(nSize)",
          "old_line_content": "            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", false, strprintf(\"%d < %d\", nFees, mempoolRejectFee));",
          "new_line_content": "        if (fLimitFree && nModifiedFees < ::minRelayTxFee.GetFee(nSize)) {",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": "DoS",
          "new_api": "Invalid",
          "old_text": "state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\")",
          "new_text": "state.Invalid(false,\n                REJECT_HIGHFEE, \"absurdly-high-fee\",\n                strprintf(\"%d > %d\", nFees, nAbsurdFee))",
          "old_line_content": "            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\");",
          "new_line_content": "            return state.Invalid(false,",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": "strprintf",
          "new_api": "GetArg",
          "old_text": "strprintf(\"%d > %d\", nFees, nAbsurdFee)",
          "new_text": "GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT)",
          "old_line_content": "                strprintf(\"%d > %d\", nFees, nAbsurdFee));",
          "new_line_content": "        size_t nLimitAncestors = GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": "GetArg",
          "new_api": "CalculateMemPoolAncestors",
          "old_text": "GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)",
          "new_text": "pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)",
          "old_line_content": "        size_t nLimitAncestorSize = GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;",
          "new_line_content": "        if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "GetArg",
          "new_api": "DoS",
          "old_text": "GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT)",
          "new_text": "state.DoS(0, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString)",
          "old_line_content": "        size_t nLimitDescendants = GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);",
          "new_line_content": "            return state.DoS(0, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": "count",
          "new_api": "ToString",
          "old_text": "setConflicts.count(hashAncestor)",
          "new_text": "strprintf(\"%s spends conflicting transaction %s\",\n                                           hash.ToString(),\n                                           hashAncestor.ToString())",
          "old_line_content": "            if (setConflicts.count(hashAncestor))",
          "new_line_content": "                                 strprintf(\"%s spends conflicting transaction %s\",",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": "DoS",
          "new_api": "ToString",
          "old_text": "state.DoS(10, false,\n                                 REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n                                 strprintf(\"%s spends conflicting transaction %s\",\n                                           hash.ToString(),\n                                           hashAncestor.ToString()))",
          "new_text": "hashAncestor.ToString()",
          "old_line_content": "                return state.DoS(10, false,",
          "new_line_content": "                                           hashAncestor.ToString()));",
          "content_same": false
        },
        {
          "line": 640,
          "old_api": "end",
          "new_api": "insert",
          "old_text": "pool.mapTx.end()",
          "new_text": "setIterConflicting.insert(mi)",
          "old_line_content": "                if (mi == pool.mapTx.end())",
          "new_line_content": "                setIterConflicting.insert(mi);",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": "DoS",
          "new_api": "ToString",
          "old_text": "state.DoS(0, false,\n                            REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                            strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                                  hash.ToString(),\n                                  newFeeRate.ToString(),\n                                  oldFeeRate.ToString()))",
          "new_text": "newFeeRate.ToString()",
          "old_line_content": "                    return state.DoS(0, false,",
          "new_line_content": "                                  newFeeRate.ToString(),",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": "ToString",
          "new_api": "GetTx",
          "old_text": "newFeeRate.ToString()",
          "new_text": "mi->GetTx()",
          "old_line_content": "                                  newFeeRate.ToString(),",
          "new_line_content": "                for (const CTxIn &txin : mi->GetTx().vin)",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "CalculateDescendants",
          "new_api": "GetTxSize",
          "old_text": "pool.CalculateDescendants(it, allConflicting)",
          "new_text": "it->GetTxSize()",
          "old_line_content": "                    pool.CalculateDescendants(it, allConflicting);",
          "new_line_content": "                    nConflictingSize += it->GetTxSize();",
          "content_same": false
        },
        {
          "line": 690,
          "old_api": "GetModifiedFee",
          "new_api": "DoS",
          "old_text": "it->GetModifiedFee()",
          "new_text": "state.DoS(0, false,\n                        REJECT_NONSTANDARD, \"too many potential replacements\", false,\n                        strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                            hash.ToString(),\n                            nConflictingCount,\n                            maxDescendantsToVisit))",
          "old_line_content": "                    nConflictingFees += it->GetModifiedFee();",
          "new_line_content": "                return state.DoS(0, false,",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": "end",
          "new_api": "ToString",
          "old_text": "pool.mapTx.end()",
          "new_text": "hash.ToString()",
          "old_line_content": "                    if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end())",
          "new_line_content": "                                                  hash.ToString(), j));",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": "GetFee",
          "new_api": "ToString",
          "old_text": "::incrementalRelayFee.GetFee(nSize)",
          "new_text": "strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                              hash.ToString(),\n                              FormatMoney(nDeltaFees),\n                              FormatMoney(::incrementalRelayFee.GetFee(nSize)))",
          "old_line_content": "            if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))",
          "new_line_content": "                        strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": "DoS",
          "new_api": "FormatMoney",
          "old_text": "state.DoS(0, false,\n                        REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                        strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                              hash.ToString(),\n                              FormatMoney(nDeltaFees),\n                              FormatMoney(::incrementalRelayFee.GetFee(nSize))))",
          "new_text": "FormatMoney(nDeltaFees)",
          "old_line_content": "                return state.DoS(0, false,",
          "new_line_content": "                              FormatMoney(nDeltaFees),",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": "ToString",
          "new_api": "GetSharedTx",
          "old_text": "hash.ToString()",
          "new_text": "it->GetSharedTx()",
          "old_line_content": "                    hash.ToString(),",
          "new_line_content": "                plTxnReplaced->push_back(it->GetSharedTx());",
          "content_same": false
        },
        {
          "line": 802,
          "old_api": "addUnchecked",
          "new_api": "GetArg",
          "old_text": "pool.addUnchecked(hash, entry, setAncestors, validForFeeEstimation)",
          "new_text": "GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY)",
          "old_line_content": "        pool.addUnchecked(hash, entry, setAncestors, validForFeeEstimation);",
          "new_line_content": "            LimitMempoolSize(pool, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": "DoS",
          "new_api": "TransactionAddedToMempool",
          "old_text": "state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full\")",
          "new_text": "GetMainSignals().TransactionAddedToMempool(ptx)",
          "old_line_content": "                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full\");",
          "new_line_content": "    GetMainSignals().TransactionAddedToMempool(ptx);",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": "Uncache",
          "new_api": "FlushStateToDisk",
          "old_text": "pcoinsTip->Uncache(hashTx)",
          "new_text": "FlushStateToDisk(chainparams, stateDummy, FLUSH_STATE_PERIODIC)",
          "old_line_content": "            pcoinsTip->Uncache(hashTx);",
          "new_line_content": "    FlushStateToDisk(chainparams, stateDummy, FLUSH_STATE_PERIODIC);",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": "error",
          "new_api": "Get",
          "old_text": "error(\"%s: OpenBlockFile failed\", __func__)",
          "new_text": "file.Get()",
          "old_line_content": "                return error(\"%s: OpenBlockFile failed\", __func__);",
          "new_line_content": "                fseek(file.Get(), postx.nTxOffset, SEEK_CUR);",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": "what",
          "new_api": "error",
          "old_text": "e.what()",
          "new_text": "error(\"%s: txid mismatch\", __func__)",
          "old_line_content": "                return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());",
          "new_line_content": "                return error(\"%s: txid mismatch\", __func__);",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": "ReadBlockFromDisk",
          "new_api": "GetBlockHash",
          "old_text": "ReadBlockFromDisk(block, pindexSlow, consensusParams)",
          "new_text": "pindexSlow->GetBlockHash()",
          "old_line_content": "        if (ReadBlockFromDisk(block, pindexSlow, consensusParams)) {",
          "new_line_content": "                    hashBlock = pindexSlow->GetBlockHash();",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": "IsNull",
          "new_api": "GetSerializeSize",
          "old_text": "fileout.IsNull()",
          "new_text": "GetSerializeSize(fileout, block)",
          "old_line_content": "    if (fileout.IsNull())",
          "new_line_content": "    unsigned int nSize = GetSerializeSize(fileout, block);",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": "error",
          "new_api": "FLATDATA",
          "old_text": "error(\"WriteBlockToDisk: OpenBlockFile failed\")",
          "new_text": "FLATDATA(messageStart)",
          "old_line_content": "        return error(\"WriteBlockToDisk: OpenBlockFile failed\");",
          "new_line_content": "    fileout << FLATDATA(messageStart) << nSize;",
          "content_same": false
        },
        {
          "line": 916,
          "old_api": "GetSerializeSize",
          "new_api": "Get",
          "old_text": "GetSerializeSize(fileout, block)",
          "new_text": "fileout.Get()",
          "old_line_content": "    unsigned int nSize = GetSerializeSize(fileout, block);",
          "new_line_content": "    long fileOutPos = ftell(fileout.Get());",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": "SetNull",
          "new_api": "IsNull",
          "old_text": "block.SetNull()",
          "new_text": "filein.IsNull()",
          "old_line_content": "    block.SetNull();",
          "new_line_content": "    if (filein.IsNull())",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": "ToString",
          "new_api": "GetHash",
          "old_text": "pos.ToString()",
          "new_text": "block.GetHash()",
          "old_line_content": "        return error(\"%s: Deserialize or I/O error - %s at %s\", __func__, e.what(), pos.ToString());",
          "new_line_content": "    if (!CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": "GetBlockPos",
          "new_api": "ToString",
          "old_text": "pindex->GetBlockPos()",
          "new_text": "pindex->GetBlockPos().ToString()",
          "old_line_content": "    if (!ReadBlockFromDisk(block, pindex->GetBlockPos(), consensusParams))",
          "new_line_content": "                pindex->ToString(), pindex->GetBlockPos().ToString());",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": "load",
          "new_api": "Tip",
          "old_text": "latchToFalse.load(std::memory_order_relaxed)",
          "new_text": "chainActive.Tip()",
          "old_line_content": "    if (latchToFalse.load(std::memory_order_relaxed))",
          "new_line_content": "    if (chainActive.Tip() == NULL)",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": "Tip",
          "new_api": "GetTime",
          "old_text": "chainActive.Tip()",
          "new_text": "GetTime()",
          "old_line_content": "    if (chainActive.Tip() == NULL)",
          "new_line_content": "    if (chainActive.Tip()->GetBlockTime() < (GetTime() - nMaxTipAge))",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": "GetConsensus",
          "new_api": "LogPrintf",
          "old_text": "chainParams.GetConsensus()",
          "new_text": "LogPrintf(\"Leaving InitialBlockDownload (latching to false)\\n\")",
          "old_line_content": "    if (chainActive.Tip()->nChainWork < UintToArith256(chainParams.GetConsensus().nMinimumChainWork))",
          "new_line_content": "    LogPrintf(\"Leaving InitialBlockDownload (latching to false)\\n\");",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": "Tip",
          "new_api": "std::string(\"'Warning: Large-work fork detected, forking after block \")",
          "old_text": "chainActive.Tip()",
          "new_text": "std::string(\"'Warning: Large-work fork detected, forking after block \")",
          "old_line_content": "    if (pindexBestForkTip || (pindexBestInvalid && pindexBestInvalid->nChainWork > chainActive.Tip()->nChainWork + (GetBlockProof(*chainActive.Tip()) * 6)))",
          "new_line_content": "            std::string warning = std::string(\"'Warning: Large-work fork detected, forking after block \") +",
          "content_same": false
        },
        {
          "line": 1036,
          "old_api": "GetfLargeWorkForkFound",
          "new_api": "AlertNotify",
          "old_text": "GetfLargeWorkForkFound()",
          "new_text": "AlertNotify(warning)",
          "old_line_content": "        if (!GetfLargeWorkForkFound() && pindexBestForkBase)",
          "new_line_content": "            AlertNotify(warning);",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": "AlertNotify",
          "new_api": "ToString",
          "old_text": "AlertNotify(warning)",
          "new_text": "LogPrintf(\"%s: Warning: Large valid fork found\\n  forking the chain at height %d (%s)\\n  lasting to height %d (%s).\\nChain state database corruption likely.\\n\", __func__,\n                   pindexBestForkBase->nHeight, pindexBestForkBase->phashBlock->ToString(),\n                   pindexBestForkTip->nHeight, pindexBestForkTip->phashBlock->ToString())",
          "old_line_content": "            AlertNotify(warning);",
          "new_line_content": "            LogPrintf(\"%s: Warning: Large valid fork found\\n  forking the chain at height %d (%s)\\n  lasting to height %d (%s).\\nChain state database corruption likely.\\n\", __func__,",
          "content_same": false
        },
        {
          "line": 1047,
          "old_api": "SetfLargeWorkForkFound",
          "new_api": "LogPrintf",
          "old_text": "SetfLargeWorkForkFound(true)",
          "new_text": "LogPrintf(\"%s: Warning: Found invalid chain at least ~6 blocks longer than our best chain.\\nChain state database corruption likely.\\n\", __func__)",
          "old_line_content": "            SetfLargeWorkForkFound(true);",
          "new_line_content": "            LogPrintf(\"%s: Warning: Found invalid chain at least ~6 blocks longer than our best chain.\\nChain state database corruption likely.\\n\", __func__);",
          "content_same": false
        },
        {
          "line": 1100,
          "old_api": "ToString",
          "new_api": "Tip",
          "old_text": "LogPrintf(\"%s: invalid block=%s  height=%d  log2_work=%.8g  date=%s\\n\", __func__,\n      pindexNew->GetBlockHash().ToString(), pindexNew->nHeight,\n      log(pindexNew->nChainWork.getdouble())/log(2.0), DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\",\n      pindexNew->GetBlockTime()))",
          "new_text": "chainActive.Tip()",
          "old_line_content": "    LogPrintf(\"%s: invalid block=%s  height=%d  log2_work=%.8g  date=%s\\n\", __func__,",
          "new_line_content": "    CBlockIndex *tip = chainActive.Tip();",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": "ToString",
          "new_api": "assert (tip)",
          "old_text": "pindexNew->GetBlockHash().ToString()",
          "new_text": "assert (tip)",
          "old_line_content": "      pindexNew->GetBlockHash().ToString(), pindexNew->nHeight,",
          "new_line_content": "    assert (tip);",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": "GetBlockTime",
          "new_api": "ToString",
          "old_text": "DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\",\n      pindexNew->GetBlockTime())",
          "new_text": "LogPrintf(\"%s:  current best=%s  height=%d  log2_work=%.8g  date=%s\\n\", __func__,\n      tip->GetBlockHash().ToString(), chainActive.Height(), log(tip->nChainWork.getdouble())/log(2.0),\n      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", tip->GetBlockTime()))",
          "old_line_content": "      log(pindexNew->nChainWork.getdouble())/log(2.0), DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\",",
          "new_line_content": "    LogPrintf(\"%s:  current best=%s  height=%d  log2_work=%.8g  date=%s\\n\", __func__,",
          "content_same": false
        },
        {
          "line": 1103,
          "old_api": "GetBlockTime",
          "new_api": "log",
          "old_text": "pindexNew->GetBlockTime()",
          "new_text": "log(2.0)",
          "old_line_content": "      pindexNew->GetBlockTime()));",
          "new_line_content": "      tip->GetBlockHash().ToString(), chainActive.Height(), log(tip->nChainWork.getdouble())/log(2.0),",
          "content_same": false
        },
        {
          "line": 1104,
          "old_api": "Tip",
          "new_api": "GetBlockTime",
          "old_text": "chainActive.Tip()",
          "new_text": "tip->GetBlockTime()",
          "old_line_content": "    CBlockIndex *tip = chainActive.Tip();",
          "new_line_content": "      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", tip->GetBlockTime()));",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": "assert (tip)",
          "new_api": "CheckForkWarningConditions",
          "old_text": "assert (tip)",
          "new_text": "CheckForkWarningConditions()",
          "old_line_content": "    assert (tip);",
          "new_line_content": "    CheckForkWarningConditions();",
          "content_same": false
        },
        {
          "line": 1109,
          "old_api": "CheckForkWarningConditions",
          "new_api": "CorruptionPossible",
          "old_text": "CheckForkWarningConditions()",
          "new_text": "state.CorruptionPossible()",
          "old_line_content": "    CheckForkWarningConditions();",
          "new_line_content": "    if (!state.CorruptionPossible()) {",
          "content_same": false
        },
        {
          "line": 1113,
          "old_api": "CorruptionPossible",
          "new_api": "InvalidChainFound",
          "old_text": "state.CorruptionPossible()",
          "new_text": "InvalidChainFound(pindex)",
          "old_line_content": "    if (!state.CorruptionPossible()) {",
          "new_line_content": "        InvalidChainFound(pindex);",
          "content_same": false
        },
        {
          "line": 1124,
          "old_api": "IsCoinBase",
          "new_api": "back",
          "old_text": "tx.IsCoinBase()",
          "new_text": "txundo.vprevout.back()",
          "old_line_content": "    if (!tx.IsCoinBase()) {",
          "new_line_content": "            bool is_spent = inputs.SpendCoin(txin.prevout, &txundo.vprevout.back());",
          "content_same": false
        },
        {
          "line": 1125,
          "old_api": "size",
          "new_api": "assert",
          "old_text": "tx.vin.size()",
          "new_text": "assert(is_spent)",
          "old_line_content": "        txundo.vprevout.reserve(tx.vin.size());",
          "new_line_content": "            assert(is_spent);",
          "content_same": false
        },
        {
          "line": 1129,
          "old_api": "assert",
          "new_api": "AddCoins",
          "old_text": "assert(is_spent)",
          "new_text": "AddCoins(inputs, tx, nHeight)",
          "old_line_content": "            assert(is_spent);",
          "new_line_content": "    AddCoins(inputs, tx, nHeight);",
          "content_same": false
        },
        {
          "line": 1164,
          "old_api": "GetSpendHeight",
          "new_api": "size",
          "old_text": "GetSpendHeight(inputs)",
          "new_text": "tx.vin.size()",
          "old_line_content": "        if (!Consensus::CheckTxInputs(tx, state, inputs, GetSpendHeight(inputs)))",
          "new_line_content": "            pvChecks->reserve(tx.vin.size());",
          "content_same": false
        },
        {
          "line": 1233,
          "old_api": "IsNull",
          "new_api": "GetSerializeSize",
          "old_text": "fileout.IsNull()",
          "new_text": "GetSerializeSize(fileout, blockundo)",
          "old_line_content": "    if (fileout.IsNull())",
          "new_line_content": "    unsigned int nSize = GetSerializeSize(fileout, blockundo);",
          "content_same": false
        },
        {
          "line": 1234,
          "old_api": "error",
          "new_api": "FLATDATA",
          "old_text": "error(\"%s: OpenUndoFile failed\", __func__)",
          "new_text": "FLATDATA(messageStart)",
          "old_line_content": "        return error(\"%s: OpenUndoFile failed\", __func__);",
          "new_line_content": "    fileout << FLATDATA(messageStart) << nSize;",
          "content_same": false
        },
        {
          "line": 1237,
          "old_api": "GetSerializeSize",
          "new_api": "Get",
          "old_text": "GetSerializeSize(fileout, blockundo)",
          "new_text": "fileout.Get()",
          "old_line_content": "    unsigned int nSize = GetSerializeSize(fileout, blockundo);",
          "new_line_content": "    long fileOutPos = ftell(fileout.Get());",
          "content_same": false
        },
        {
          "line": 1272,
          "old_api": "what",
          "new_api": "GetHash",
          "old_text": "e.what()",
          "new_text": "verifier.GetHash()",
          "old_line_content": "        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());",
          "new_line_content": "    if (hashChecksum != verifier.GetHash())",
          "content_same": false
        },
        {
          "line": 1286,
          "old_api": "LogPrintf",
          "new_api": "StartShutdown",
          "old_text": "LogPrintf(\"*** %s\\n\", strMessage)",
          "new_text": "StartShutdown()",
          "old_line_content": "    LogPrintf(\"*** %s\\n\", strMessage);",
          "new_line_content": "    StartShutdown();",
          "content_same": false
        },
        {
          "line": 1349,
          "old_api": "IsNull",
          "new_api": "GetBlockHash",
          "old_text": "pos.IsNull()",
          "new_text": "pindex->pprev->GetBlockHash()",
          "old_line_content": "    if (pos.IsNull()) {",
          "new_line_content": "    if (!UndoReadFromDisk(blockUndo, pos, pindex->pprev->GetBlockHash())) {",
          "content_same": false
        },
        {
          "line": 1354,
          "old_api": "error",
          "new_api": "size",
          "old_text": "error(\"DisconnectBlock(): failure reading undo data\")",
          "new_text": "block.vtx.size()",
          "old_line_content": "        error(\"DisconnectBlock(): failure reading undo data\");",
          "new_line_content": "    if (blockUndo.vtxundo.size() + 1 != block.vtx.size()) {",
          "content_same": false
        },
        {
          "line": 1366,
          "old_api": "GetHash",
          "new_api": "size",
          "old_text": "tx.GetHash()",
          "new_text": "tx.vout.size()",
          "old_line_content": "        uint256 hash = tx.GetHash();",
          "new_line_content": "        for (size_t o = 0; o < tx.vout.size(); o++) {",
          "content_same": false
        },
        {
          "line": 1370,
          "old_api": "size",
          "new_api": "SpendCoin",
          "old_text": "tx.vout.size()",
          "new_text": "view.SpendCoin(out, &coin)",
          "old_line_content": "        for (size_t o = 0; o < tx.vout.size(); o++) {",
          "new_line_content": "                bool is_spent = view.SpendCoin(out, &coin);",
          "content_same": false
        },
        {
          "line": 1406,
          "old_api": "LOCK",
          "new_api": "OpenBlockFile",
          "old_text": "LOCK(cs_LastBlockFile)",
          "new_text": "OpenBlockFile(posOld)",
          "old_line_content": "    LOCK(cs_LastBlockFile);",
          "new_line_content": "    FILE *fileOld = OpenBlockFile(posOld);",
          "content_same": false
        },
        {
          "line": 1410,
          "old_api": "OpenBlockFile",
          "new_api": "FileCommit",
          "old_text": "OpenBlockFile(posOld)",
          "new_text": "FileCommit(fileOld)",
          "old_line_content": "    FILE *fileOld = OpenBlockFile(posOld);",
          "new_line_content": "        FileCommit(fileOld);",
          "content_same": false
        },
        {
          "line": 1414,
          "old_api": "FileCommit",
          "new_api": "OpenUndoFile",
          "old_text": "FileCommit(fileOld)",
          "new_text": "OpenUndoFile(posOld)",
          "old_line_content": "        FileCommit(fileOld);",
          "new_line_content": "    fileOld = OpenUndoFile(posOld);",
          "content_same": false
        },
        {
          "line": 1418,
          "old_api": "OpenUndoFile",
          "new_api": "FileCommit",
          "old_text": "OpenUndoFile(posOld)",
          "new_text": "FileCommit(fileOld)",
          "old_line_content": "    fileOld = OpenUndoFile(posOld);",
          "new_line_content": "        FileCommit(fileOld);",
          "content_same": false
        },
        {
          "line": 1441,
          "old_api": "LOCK",
          "new_api": "VersionBitsState",
          "old_text": "LOCK(cs_main)",
          "new_text": "VersionBitsState(pindexPrev, params, (Consensus::DeploymentPos)i, versionbitscache)",
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "        ThresholdState state = VersionBitsState(pindexPrev, params, (Consensus::DeploymentPos)i, versionbitscache);",
          "content_same": false
        },
        {
          "line": 1495,
          "old_api": "AssertLockHeld",
          "new_api": "GetHash",
          "old_text": "AssertLockHeld(cs_main)",
          "new_text": "block.GetHash()",
          "old_line_content": "    AssertLockHeld(cs_main);",
          "new_line_content": "           (*pindex->phashBlock == block.GetHash()));",
          "content_same": false
        },
        {
          "line": 1496,
          "old_api": "assert",
          "new_api": "GetTimeMicros",
          "old_text": "assert(pindex)",
          "new_text": "GetTimeMicros()",
          "old_line_content": "    assert(pindex);",
          "new_line_content": "    int64_t nTimeStart = GetTimeMicros();",
          "content_same": false
        },
        {
          "line": 1499,
          "old_api": "GetHash",
          "new_api": "GetConsensus",
          "old_text": "block.GetHash()",
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "           (*pindex->phashBlock == block.GetHash()));",
          "new_line_content": "    if (!CheckBlock(block, state, chainparams.GetConsensus(), !fJustCheck, !fJustCheck))",
          "content_same": false
        },
        {
          "line": 1500,
          "old_api": "GetTimeMicros",
          "new_api": "FormatStateMessage",
          "old_text": "GetTimeMicros()",
          "new_text": "FormatStateMessage(state)",
          "old_line_content": "    int64_t nTimeStart = GetTimeMicros();",
          "new_line_content": "        return error(\"%s: Consensus::CheckBlock: %s\", __func__, FormatStateMessage(state));",
          "content_same": false
        },
        {
          "line": 1503,
          "old_api": "GetConsensus",
          "new_api": "GetBlockHash",
          "old_text": "chainparams.GetConsensus()",
          "new_text": "pindex->pprev->GetBlockHash()",
          "old_line_content": "    if (!CheckBlock(block, state, chainparams.GetConsensus(), !fJustCheck, !fJustCheck))",
          "new_line_content": "    uint256 hashPrevBlock = pindex->pprev == NULL ? uint256() : pindex->pprev->GetBlockHash();",
          "content_same": false
        },
        {
          "line": 1504,
          "old_api": "FormatStateMessage",
          "new_api": "GetBestBlock",
          "old_text": "FormatStateMessage(state)",
          "new_text": "view.GetBestBlock()",
          "old_line_content": "        return error(\"%s: Consensus::CheckBlock: %s\", __func__, FormatStateMessage(state));",
          "new_line_content": "    assert(hashPrevBlock == view.GetBestBlock());",
          "content_same": false
        },
        {
          "line": 1508,
          "old_api": "GetBestBlock",
          "new_api": "GetConsensus",
          "old_text": "view.GetBestBlock()",
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "    assert(hashPrevBlock == view.GetBestBlock());",
          "new_line_content": "    if (block.GetHash() == chainparams.GetConsensus().hashGenesisBlock) {",
          "content_same": false
        },
        {
          "line": 1525,
          "old_api": "find",
          "new_api": "GetConsensus",
          "old_text": "mapBlockIndex.find(hashAssumeValid)",
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "        BlockMap::const_iterator  it = mapBlockIndex.find(hashAssumeValid);",
          "new_line_content": "                pindexBestHeader->nChainWork >= UintToArith256(chainparams.GetConsensus().nMinimumChainWork)) {",
          "content_same": false
        },
        {
          "line": 1571,
          "old_api": "GetConsensus",
          "new_api": "size",
          "old_text": "chainparams.GetConsensus()",
          "new_text": "tx->vout.size()",
          "old_line_content": "    fEnforceBIP30 = fEnforceBIP30 && (!pindexBIP34height || !(pindexBIP34height->GetBlockHash() == chainparams.GetConsensus().BIP34Hash));",
          "new_line_content": "            for (size_t o = 0; o < tx->vout.size(); o++) {",
          "content_same": false
        },
        {
          "line": 1634,
          "old_api": "size",
          "new_api": "HaveInputs",
          "old_text": "tx.vin.size()",
          "new_text": "view.HaveInputs(tx)",
          "old_line_content": "        nInputs += tx.vin.size();",
          "new_line_content": "            if (!view.HaveInputs(tx))",
          "content_same": false
        },
        {
          "line": 1646,
          "old_api": "size",
          "new_api": "SequenceLocks",
          "old_text": "tx.vin.size()",
          "new_text": "SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)",
          "old_line_content": "            for (size_t j = 0; j < tx.vin.size(); j++) {",
          "new_line_content": "            if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {",
          "content_same": false
        },
        {
          "line": 1647,
          "old_api": "AccessCoin",
          "new_api": "error",
          "old_text": "view.AccessCoin(tx.vin[j].prevout)",
          "new_text": "error(\"%s: contains a non-BIP68-final transaction\", __func__)",
          "old_line_content": "                prevheights[j] = view.AccessCoin(tx.vin[j].prevout).nHeight;",
          "new_line_content": "                return state.DoS(100, error(\"%s: contains a non-BIP68-final transaction\", __func__),",
          "content_same": false
        },
        {
          "line": 1662,
          "old_api": "error",
          "new_api": "IsCoinBase",
          "old_text": "error(\"ConnectBlock(): too many sigops\")",
          "new_text": "tx.IsCoinBase()",
          "old_line_content": "            return state.DoS(100, error(\"ConnectBlock(): too many sigops\"),",
          "new_line_content": "        if (!tx.IsCoinBase())",
          "content_same": false
        },
        {
          "line": 1668,
          "old_api": "GetValueOut",
          "new_api": "CheckInputs",
          "old_text": "tx.GetValueOut()",
          "new_text": "CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : NULL)",
          "old_line_content": "            nFees += view.GetValueIn(tx)-tx.GetValueOut();",
          "new_line_content": "            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : NULL))",
          "content_same": false
        },
        {
          "line": 1680,
          "old_api": "CTxUndo",
          "new_api": "GetHash",
          "old_text": "CTxUndo()",
          "new_text": "tx.GetHash()",
          "old_line_content": "            blockundo.vtxundo.push_back(CTxUndo());",
          "new_line_content": "        vPos.push_back(std::make_pair(tx.GetHash(), pos));",
          "content_same": false
        },
        {
          "line": 1684,
          "old_api": "GetHash",
          "new_api": "size",
          "old_text": "tx.GetHash()",
          "new_text": "block.vtx.size()",
          "old_line_content": "        vPos.push_back(std::make_pair(tx.GetHash(), pos));",
          "new_line_content": "    LogPrint(BCLog::BENCH, \"      - Connect %u transactions: %.2fms (%.3fms/tx, %.3fms/txin) [%.2fs]\\n\", (unsigned)block.vtx.size(), 0.001 * (nTime3 - nTime2), 0.001 * (nTime3 - nTime2) / block.vtx.size(), nInputs <= 1 ? 0 : 0.001 * (nTime3 - nTime2) / (nInputs-1), nTimeConnect * 0.000001);",
          "content_same": false
        },
        {
          "line": 1687,
          "old_api": "GetTimeMicros",
          "new_api": "GetValueOut",
          "old_text": "GetTimeMicros()",
          "new_text": "block.vtx[0]->GetValueOut()",
          "old_line_content": "    int64_t nTime3 = GetTimeMicros(); nTimeConnect += nTime3 - nTime2;",
          "new_line_content": "    if (block.vtx[0]->GetValueOut() > blockReward)",
          "content_same": false
        },
        {
          "line": 1688,
          "old_api": "size",
          "new_api": "DoS",
          "old_text": "block.vtx.size()",
          "new_text": "state.DoS(100,\n                         error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n                               block.vtx[0]->GetValueOut(), blockReward),\n                               REJECT_INVALID, \"bad-cb-amount\")",
          "old_line_content": "    LogPrint(BCLog::BENCH, \"      - Connect %u transactions: %.2fms (%.3fms/tx, %.3fms/txin) [%.2fs]\\n\", (unsigned)block.vtx.size(), 0.001 * (nTime3 - nTime2), 0.001 * (nTime3 - nTime2) / block.vtx.size(), nInputs <= 1 ? 0 : 0.001 * (nTime3 - nTime2) / (nInputs-1), nTimeConnect * 0.000001);",
          "new_line_content": "        return state.DoS(100,",
          "content_same": false
        },
        {
          "line": 1690,
          "old_api": "GetConsensus",
          "new_api": "GetValueOut",
          "old_text": "chainparams.GetConsensus()",
          "new_text": "block.vtx[0]->GetValueOut()",
          "old_line_content": "    CAmount blockReward = nFees + GetBlockSubsidy(pindex->nHeight, chainparams.GetConsensus());",
          "new_line_content": "                               block.vtx[0]->GetValueOut(), blockReward),",
          "content_same": false
        },
        {
          "line": 1693,
          "old_api": "GetValueOut",
          "new_api": "Wait",
          "old_text": "error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n                               block.vtx[0]->GetValueOut(), blockReward)",
          "new_text": "control.Wait()",
          "old_line_content": "                         error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",",
          "new_line_content": "    if (!control.Wait())",
          "content_same": false
        },
        {
          "line": 1694,
          "old_api": "GetValueOut",
          "new_api": "error",
          "old_text": "block.vtx[0]->GetValueOut()",
          "new_text": "error(\"%s: CheckQueue failed\", __func__)",
          "old_line_content": "                               block.vtx[0]->GetValueOut(), blockReward),",
          "new_line_content": "        return state.DoS(100, error(\"%s: CheckQueue failed\", __func__), REJECT_INVALID, \"block-validation-failed\");",
          "content_same": false
        },
        {
          "line": 1706,
          "old_api": "IsValid",
          "new_api": "::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION)",
          "old_text": "pindex->IsValid(BLOCK_VALID_SCRIPTS)",
          "new_text": "::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION)",
          "old_line_content": "    if (pindex->GetUndoPos().IsNull() || !pindex->IsValid(BLOCK_VALID_SCRIPTS))",
          "new_line_content": "            if (!FindUndoPos(state, pindex->nFile, _pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 40))",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": "IsNull",
          "new_api": "MessageStart",
          "old_text": "pindex->GetUndoPos().IsNull()",
          "new_text": "chainparams.MessageStart()",
          "old_line_content": "        if (pindex->GetUndoPos().IsNull()) {",
          "new_line_content": "            if (!UndoWriteToDisk(blockundo, _pos, pindex->pprev->GetBlockHash(), chainparams.MessageStart()))",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": "insert",
          "new_api": "WriteTxIndex",
          "old_text": "setDirtyBlockIndex.insert(pindex)",
          "new_text": "pblocktree->WriteTxIndex(vPos)",
          "old_line_content": "        setDirtyBlockIndex.insert(pindex);",
          "new_line_content": "        if (!pblocktree->WriteTxIndex(vPos))",
          "content_same": false
        },
        {
          "line": 1725,
          "old_api": "WriteTxIndex",
          "new_api": "GetBlockHash",
          "old_text": "pblocktree->WriteTxIndex(vPos)",
          "new_text": "pindex->GetBlockHash()",
          "old_line_content": "        if (!pblocktree->WriteTxIndex(vPos))",
          "new_line_content": "    view.SetBestBlock(pindex->GetBlockHash());",
          "content_same": false
        },
        {
          "line": 1731,
          "old_api": "GetTimeMicros",
          "new_api": "LogPrint",
          "old_text": "GetTimeMicros()",
          "new_text": "LogPrint(BCLog::BENCH, \"    - Callbacks: %.2fms [%.2fs]\\n\", 0.001 * (nTime6 - nTime5), nTimeCallbacks * 0.000001)",
          "old_line_content": "    int64_t nTime5 = GetTimeMicros(); nTimeIndex += nTime5 - nTime4;",
          "new_line_content": "    LogPrint(BCLog::BENCH, \"    - Callbacks: %.2fms [%.2fs]\\n\", 0.001 * (nTime6 - nTime5), nTimeCallbacks * 0.000001);",
          "content_same": false
        },
        {
          "line": 1781,
          "old_api": "GetArg",
          "new_api": "std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024)",
          "old_text": "GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE)",
          "new_text": "std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024)",
          "old_line_content": "    int64_t nMempoolSizeMax = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;",
          "new_line_content": "    bool fCacheLarge = mode == FLUSH_STATE_PERIODIC && cacheSize > std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024);",
          "content_same": false
        },
        {
          "line": 1800,
          "old_api": "FlushBlockFile",
          "new_api": "size",
          "old_text": "FlushBlockFile()",
          "new_text": "setDirtyFileInfo.size()",
          "old_line_content": "        FlushBlockFile();",
          "new_line_content": "            vFiles.reserve(setDirtyFileInfo.size());",
          "content_same": false
        },
        {
          "line": 1806,
          "old_api": "std::make_pair(*it, &vinfoBlockFile[*it])",
          "new_api": "size",
          "old_text": "std::make_pair(*it, &vinfoBlockFile[*it])",
          "new_text": "setDirtyBlockIndex.size()",
          "old_line_content": "                vFiles.push_back(std::make_pair(*it, &vinfoBlockFile[*it]));",
          "new_line_content": "            vBlocks.reserve(setDirtyBlockIndex.size());",
          "content_same": false
        },
        {
          "line": 1807,
          "old_api": "erase",
          "new_api": "end",
          "old_text": "setDirtyFileInfo.erase(it++)",
          "new_text": "setDirtyBlockIndex.end()",
          "old_line_content": "                setDirtyFileInfo.erase(it++);",
          "new_line_content": "            for (std::set<CBlockIndex*>::iterator it = setDirtyBlockIndex.begin(); it != setDirtyBlockIndex.end(); ) {",
          "content_same": false
        },
        {
          "line": 1811,
          "old_api": "end",
          "new_api": "WriteBatchSync",
          "old_text": "setDirtyBlockIndex.end()",
          "new_text": "pblocktree->WriteBatchSync(vFiles, nLastBlockFile, vBlocks)",
          "old_line_content": "            for (std::set<CBlockIndex*>::iterator it = setDirtyBlockIndex.begin(); it != setDirtyBlockIndex.end(); ) {",
          "new_line_content": "            if (!pblocktree->WriteBatchSync(vFiles, nLastBlockFile, vBlocks)) {",
          "content_same": false
        },
        {
          "line": 1812,
          "old_api": "push_back",
          "new_api": "AbortNode",
          "old_text": "vBlocks.push_back(*it)",
          "new_text": "AbortNode(state, \"Failed to write to block index database\")",
          "old_line_content": "                vBlocks.push_back(*it);",
          "new_line_content": "                return AbortNode(state, \"Failed to write to block index database\");",
          "content_same": false
        },
        {
          "line": 1831,
          "old_api": "GetCacheSize",
          "new_api": "AbortNode",
          "old_text": "pcoinsTip->GetCacheSize()",
          "new_text": "AbortNode(state, \"Failed to write to coin database\")",
          "old_line_content": "        if (!CheckDiskSpace(48 * 2 * 2 * pcoinsTip->GetCacheSize()))",
          "new_line_content": "            return AbortNode(state, \"Failed to write to coin database\");",
          "content_same": false
        },
        {
          "line": 1840,
          "old_api": "GetLocator",
          "new_api": "what",
          "old_text": "chainActive.GetLocator()",
          "new_text": "e.what()",
          "old_line_content": "        GetMainSignals().SetBestChain(chainActive.GetLocator());",
          "new_line_content": "        return AbortNode(state, std::string(\"System error while flushing: \") + e.what());",
          "content_same": false
        },
        {
          "line": 1888,
          "old_api": "GetConsensus",
          "new_api": "DoWarning",
          "old_text": "chainParams.GetConsensus()",
          "new_text": "DoWarning(strWarning)",
          "old_line_content": "            ThresholdState state = checker.GetStateFor(pindex, chainParams.GetConsensus(), warningcache[bit]);",
          "new_line_content": "                    DoWarning(strWarning);",
          "content_same": false
        },
        {
          "line": 1890,
          "old_api": "_",
          "new_api": "push_back",
          "old_text": "_(\"Warning: unknown new rules activated (versionbit %i)\")",
          "new_text": "warningMessages.push_back(strWarning)",
          "old_line_content": "                const std::string strWarning = strprintf(_(\"Warning: unknown new rules activated (versionbit %i)\"), bit);",
          "new_line_content": "                    warningMessages.push_back(strWarning);",
          "content_same": false
        },
        {
          "line": 1912,
          "old_api": "DoWarning",
          "new_api": "Tip",
          "old_text": "DoWarning(strWarning)",
          "new_text": "chainActive.Tip()",
          "old_line_content": "            DoWarning(strWarning);",
          "new_line_content": "      chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(), chainActive.Tip()->nVersion,",
          "content_same": false
        },
        {
          "line": 1915,
          "old_api": "1fMiB",
          "new_api": "GetCacheSize",
          "old_text": "LogPrintf(\"%s: new best=%s height=%d version=0x%08x log2_work=%.8g tx=%lu date='%s' progress=%f cache=%.1fMiB(%utxo)\", __func__,\n      chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(), chainActive.Tip()->nVersion,\n      log(chainActive.Tip()->nChainWork.getdouble())/log(2.0), (unsigned long)chainActive.Tip()->nChainTx,\n      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()),\n      GuessVerificationProgress(chainParams.TxData(), chainActive.Tip()), pcoinsTip->DynamicMemoryUsage() * (1.0 / (1<<20)), pcoinsTip->GetCacheSize())",
          "new_text": "pcoinsTip->GetCacheSize()",
          "old_line_content": "    LogPrintf(\"%s: new best=%s height=%d version=0x%08x log2_work=%.8g tx=%lu date='%s' progress=%f cache=%.1fMiB(%utxo)\", __func__,",
          "new_line_content": "      GuessVerificationProgress(chainParams.TxData(), chainActive.Tip()), pcoinsTip->DynamicMemoryUsage() * (1.0 / (1<<20)), pcoinsTip->GetCacheSize());",
          "content_same": false
        },
        {
          "line": 1916,
          "old_api": "Tip",
          "new_api": "empty",
          "old_text": "chainActive.Tip()",
          "new_text": "warningMessages.empty()",
          "old_line_content": "      chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(), chainActive.Tip()->nVersion,",
          "new_line_content": "    if (!warningMessages.empty())",
          "content_same": false
        },
        {
          "line": 1917,
          "old_api": "Tip",
          "new_api": "boost::algorithm::join(warningMessages, \", \")",
          "old_text": "chainActive.Tip()",
          "new_text": "boost::algorithm::join(warningMessages, \", \")",
          "old_line_content": "      log(chainActive.Tip()->nChainWork.getdouble())/log(2.0), (unsigned long)chainActive.Tip()->nChainTx,",
          "new_line_content": "        LogPrintf(\" warning='%s'\", boost::algorithm::join(warningMessages, \", \"));",
          "content_same": false
        },
        {
          "line": 1918,
          "old_api": "Tip",
          "new_api": "LogPrintf",
          "old_text": "chainActive.Tip()->GetBlockTime()",
          "new_text": "LogPrintf(\"\\n\")",
          "old_line_content": "      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()),",
          "new_line_content": "    LogPrintf(\"\\n\");",
          "content_same": false
        },
        {
          "line": 1939,
          "old_api": "assert",
          "new_api": "GetConsensus",
          "old_text": "assert(pindexDelete)",
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "    assert(pindexDelete);",
          "new_line_content": "    if (!ReadBlockFromDisk(block, pindexDelete, chainparams.GetConsensus()))",
          "content_same": false
        },
        {
          "line": 1946,
          "old_api": "GetTimeMicros",
          "new_api": "ToString",
          "old_text": "GetTimeMicros()",
          "new_text": "pindexDelete->GetBlockHash().ToString()",
          "old_line_content": "    int64_t nStart = GetTimeMicros();",
          "new_line_content": "            return error(\"DisconnectTip(): DisconnectBlock %s failed\", pindexDelete->GetBlockHash().ToString());",
          "content_same": false
        },
        {
          "line": 1950,
          "old_api": "ToString",
          "new_api": "GetTimeMicros",
          "old_text": "pindexDelete->GetBlockHash().ToString()",
          "new_text": "GetTimeMicros()",
          "old_line_content": "            return error(\"DisconnectTip(): DisconnectBlock %s failed\", pindexDelete->GetBlockHash().ToString());",
          "new_line_content": "    LogPrint(BCLog::BENCH, \"- Disconnect block: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);",
          "content_same": false
        },
        {
          "line": 1952,
          "old_api": "assert",
          "new_api": "FlushStateToDisk",
          "old_text": "assert(flushed)",
          "new_text": "FlushStateToDisk(chainparams, state, FLUSH_STATE_IF_NEEDED)",
          "old_line_content": "        assert(flushed);",
          "new_line_content": "    if (!FlushStateToDisk(chainparams, state, FLUSH_STATE_IF_NEEDED))",
          "content_same": false
        },
        {
          "line": 1962,
          "old_api": "addTransaction",
          "new_api": "begin",
          "old_text": "disconnectpool->addTransaction(*it)",
          "new_text": "disconnectpool->queuedTx.get<insertion_order>().begin()",
          "old_line_content": "            disconnectpool->addTransaction(*it);",
          "new_line_content": "            auto it = disconnectpool->queuedTx.get<insertion_order>().begin();",
          "content_same": false
        },
        {
          "line": 1964,
          "old_api": "DynamicMemoryUsage",
          "new_api": "removeEntry",
          "old_text": "disconnectpool->DynamicMemoryUsage()",
          "new_text": "disconnectpool->removeEntry(it)",
          "old_line_content": "        while (disconnectpool->DynamicMemoryUsage() > MAX_DISCONNECTED_TX_POOL_SIZE * 1000) {",
          "new_line_content": "            disconnectpool->removeEntry(it);",
          "content_same": false
        },
        {
          "line": 2019,
          "old_api": "boost::bind(&ConnectTrace::NotifyEntryRemoved, this, _1, _2)",
          "new_api": "back",
          "old_text": "boost::bind(&ConnectTrace::NotifyEntryRemoved, this, _1, _2)",
          "new_text": "blocksConnected.back()",
          "old_line_content": "        pool.NotifyEntryRemoved.disconnect(boost::bind(&ConnectTrace::NotifyEntryRemoved, this, _1, _2));",
          "new_line_content": "        assert(!blocksConnected.back().pindex);",
          "content_same": false
        },
        {
          "line": 2023,
          "old_api": "back",
          "new_api": "std::move(pblock)",
          "old_text": "blocksConnected.back()",
          "new_text": "std::move(pblock)",
          "old_line_content": "        assert(!blocksConnected.back().pindex);",
          "new_line_content": "        blocksConnected.back().pblock = std::move(pblock);",
          "content_same": false
        },
        {
          "line": 2024,
          "old_api": "assert",
          "new_api": "emplace_back",
          "old_text": "assert(pindex)",
          "new_text": "blocksConnected.emplace_back()",
          "old_line_content": "        assert(pindex);",
          "new_line_content": "        blocksConnected.emplace_back();",
          "content_same": false
        },
        {
          "line": 2061,
          "old_api": "GetTimeMicros",
          "new_api": "GetConsensus",
          "old_text": "GetTimeMicros()",
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "    int64_t nTime1 = GetTimeMicros();",
          "new_line_content": "        if (!ReadBlockFromDisk(*pblockNew, pindexNew, chainparams.GetConsensus()))",
          "content_same": false
        },
        {
          "line": 2075,
          "old_api": "LogPrint",
          "new_api": "BlockChecked",
          "old_text": "LogPrint(BCLog::BENCH, \"  - Load block from disk: %.2fms [%.2fs]\\n\", (nTime2 - nTime1) * 0.001, nTimeReadFromDisk * 0.000001)",
          "new_text": "GetMainSignals().BlockChecked(blockConnecting, state)",
          "old_line_content": "    LogPrint(BCLog::BENCH, \"  - Load block from disk: %.2fms [%.2fs]\\n\", (nTime2 - nTime1) * 0.001, nTimeReadFromDisk * 0.000001);",
          "new_line_content": "        GetMainSignals().BlockChecked(blockConnecting, state);",
          "content_same": false
        },
        {
          "line": 2078,
          "old_api": "ConnectBlock",
          "new_api": "InvalidBlockFound",
          "old_text": "ConnectBlock(blockConnecting, state, pindexNew, view, chainparams)",
          "new_text": "InvalidBlockFound(pindexNew, state)",
          "old_line_content": "        bool rv = ConnectBlock(blockConnecting, state, pindexNew, view, chainparams);",
          "new_line_content": "                InvalidBlockFound(pindexNew, state);",
          "content_same": false
        },
        {
          "line": 2079,
          "old_api": "BlockChecked",
          "new_api": "ToString",
          "old_text": "GetMainSignals().BlockChecked(blockConnecting, state)",
          "new_text": "pindexNew->GetBlockHash().ToString()",
          "old_line_content": "        GetMainSignals().BlockChecked(blockConnecting, state);",
          "new_line_content": "            return error(\"ConnectTip(): ConnectBlock %s failed\", pindexNew->GetBlockHash().ToString());",
          "content_same": false
        },
        {
          "line": 2081,
          "old_api": "IsInvalid",
          "new_api": "GetTimeMicros",
          "old_text": "state.IsInvalid()",
          "new_text": "GetTimeMicros()",
          "old_line_content": "            if (state.IsInvalid())",
          "new_line_content": "        nTime3 = GetTimeMicros(); nTimeConnectTotal += nTime3 - nTime2;",
          "content_same": false
        },
        {
          "line": 2082,
          "old_api": "InvalidBlockFound",
          "new_api": "LogPrint",
          "old_text": "InvalidBlockFound(pindexNew, state)",
          "new_text": "LogPrint(BCLog::BENCH, \"  - Connect total: %.2fms [%.2fs]\\n\", (nTime3 - nTime2) * 0.001, nTimeConnectTotal * 0.000001)",
          "old_line_content": "                InvalidBlockFound(pindexNew, state);",
          "new_line_content": "        LogPrint(BCLog::BENCH, \"  - Connect total: %.2fms [%.2fs]\\n\", (nTime3 - nTime2) * 0.001, nTimeConnectTotal * 0.000001);",
          "content_same": false
        },
        {
          "line": 2083,
          "old_api": "ToString",
          "new_api": "Flush",
          "old_text": "pindexNew->GetBlockHash().ToString()",
          "new_text": "view.Flush()",
          "old_line_content": "            return error(\"ConnectTip(): ConnectBlock %s failed\", pindexNew->GetBlockHash().ToString());",
          "new_line_content": "        bool flushed = view.Flush();",
          "content_same": false
        },
        {
          "line": 2086,
          "old_api": "LogPrint",
          "new_api": "GetTimeMicros",
          "old_text": "LogPrint(BCLog::BENCH, \"  - Connect total: %.2fms [%.2fs]\\n\", (nTime3 - nTime2) * 0.001, nTimeConnectTotal * 0.000001)",
          "new_text": "GetTimeMicros()",
          "old_line_content": "        LogPrint(BCLog::BENCH, \"  - Connect total: %.2fms [%.2fs]\\n\", (nTime3 - nTime2) * 0.001, nTimeConnectTotal * 0.000001);",
          "new_line_content": "    int64_t nTime4 = GetTimeMicros(); nTimeFlush += nTime4 - nTime3;",
          "content_same": false
        },
        {
          "line": 2087,
          "old_api": "Flush",
          "new_api": "LogPrint",
          "old_text": "view.Flush()",
          "new_text": "LogPrint(BCLog::BENCH, \"  - Flush: %.2fms [%.2fs]\\n\", (nTime4 - nTime3) * 0.001, nTimeFlush * 0.000001)",
          "old_line_content": "        bool flushed = view.Flush();",
          "new_line_content": "    LogPrint(BCLog::BENCH, \"  - Flush: %.2fms [%.2fs]\\n\", (nTime4 - nTime3) * 0.001, nTimeFlush * 0.000001);",
          "content_same": false
        },
        {
          "line": 2091,
          "old_api": "LogPrint",
          "new_api": "GetTimeMicros",
          "old_text": "LogPrint(BCLog::BENCH, \"  - Flush: %.2fms [%.2fs]\\n\", (nTime4 - nTime3) * 0.001, nTimeFlush * 0.000001)",
          "new_text": "GetTimeMicros()",
          "old_line_content": "    LogPrint(BCLog::BENCH, \"  - Flush: %.2fms [%.2fs]\\n\", (nTime4 - nTime3) * 0.001, nTimeFlush * 0.000001);",
          "new_line_content": "    int64_t nTime5 = GetTimeMicros(); nTimeChainState += nTime5 - nTime4;",
          "content_same": false
        },
        {
          "line": 2095,
          "old_api": "GetTimeMicros",
          "new_api": "removeForBlock",
          "old_text": "GetTimeMicros()",
          "new_text": "disconnectpool.removeForBlock(blockConnecting.vtx)",
          "old_line_content": "    int64_t nTime5 = GetTimeMicros(); nTimeChainState += nTime5 - nTime4;",
          "new_line_content": "    disconnectpool.removeForBlock(blockConnecting.vtx);",
          "content_same": false
        },
        {
          "line": 2099,
          "old_api": "removeForBlock",
          "new_api": "GetTimeMicros",
          "old_text": "disconnectpool.removeForBlock(blockConnecting.vtx)",
          "new_text": "GetTimeMicros()",
          "old_line_content": "    disconnectpool.removeForBlock(blockConnecting.vtx);",
          "new_line_content": "    int64_t nTime6 = GetTimeMicros(); nTimePostConnect += nTime6 - nTime5; nTimeTotal += nTime6 - nTime1;",
          "content_same": false
        },
        {
          "line": 2101,
          "old_api": "UpdateTip",
          "new_api": "LogPrint",
          "old_text": "UpdateTip(pindexNew, chainparams)",
          "new_text": "LogPrint(BCLog::BENCH, \"- Connect block: %.2fms [%.2fs]\\n\", (nTime6 - nTime1) * 0.001, nTimeTotal * 0.000001)",
          "old_line_content": "    UpdateTip(pindexNew, chainparams);",
          "new_line_content": "    LogPrint(BCLog::BENCH, \"- Connect block: %.2fms [%.2fs]\\n\", (nTime6 - nTime1) * 0.001, nTimeTotal * 0.000001);",
          "content_same": false
        },
        {
          "line": 2103,
          "old_api": "GetTimeMicros",
          "new_api": "std::move(pthisBlock)",
          "old_text": "GetTimeMicros()",
          "new_text": "std::move(pthisBlock)",
          "old_line_content": "    int64_t nTime6 = GetTimeMicros(); nTimePostConnect += nTime6 - nTime5; nTimeTotal += nTime6 - nTime1;",
          "new_line_content": "    connectTrace.BlockConnected(pindexNew, std::move(pthisBlock));",
          "content_same": false
        },
        {
          "line": 2174,
          "old_api": "Tip",
          "new_api": "empty",
          "old_text": "chainActive.Tip()",
          "new_text": "setBlockIndexCandidates.empty()",
          "old_line_content": "    while (it != setBlockIndexCandidates.end() && setBlockIndexCandidates.value_comp()(*it, chainActive.Tip())) {",
          "new_line_content": "    assert(!setBlockIndexCandidates.empty());",
          "content_same": false
        },
        {
          "line": 2194,
          "old_api": "Tip",
          "new_api": "UpdateMempoolForReorg",
          "old_text": "chainActive.Tip()",
          "new_text": "UpdateMempoolForReorg(disconnectpool, false)",
          "old_line_content": "    while (chainActive.Tip() && chainActive.Tip() != pindexFork) {",
          "new_line_content": "            UpdateMempoolForReorg(disconnectpool, false);",
          "content_same": false
        },
        {
          "line": 2212,
          "old_api": "clear",
          "new_api": "push_back",
          "old_text": "vpindexToConnect.clear()",
          "new_text": "vpindexToConnect.push_back(pindexIter)",
          "old_line_content": "        vpindexToConnect.clear();",
          "new_line_content": "            vpindexToConnect.push_back(pindexIter);",
          "content_same": false
        },
        {
          "line": 2223,
          "old_api": "std::shared_ptr<const CBlock>()",
          "new_api": "back",
          "old_text": "std::shared_ptr<const CBlock>()",
          "new_text": "vpindexToConnect.back()",
          "old_line_content": "            if (!ConnectTip(state, chainparams, pindexConnect, pindexConnect == pindexMostWork ? pblock : std::shared_ptr<const CBlock>(), connectTrace, disconnectpool)) {",
          "new_line_content": "                        InvalidChainFound(vpindexToConnect.back());",
          "content_same": false
        },
        {
          "line": 2224,
          "old_api": "IsInvalid",
          "new_api": "CValidationState",
          "old_text": "state.IsInvalid()",
          "new_text": "CValidationState()",
          "old_line_content": "                if (state.IsInvalid()) {",
          "new_line_content": "                    state = CValidationState();",
          "content_same": false
        },
        {
          "line": 2236,
          "old_api": "UpdateMempoolForReorg",
          "new_api": "PruneBlockIndexCandidates",
          "old_text": "UpdateMempoolForReorg(disconnectpool, false)",
          "new_text": "PruneBlockIndexCandidates()",
          "old_line_content": "                    UpdateMempoolForReorg(disconnectpool, false);",
          "new_line_content": "                PruneBlockIndexCandidates();",
          "content_same": false
        },
        {
          "line": 2255,
          "old_api": "check",
          "new_api": "back",
          "old_text": "mempool.check(pcoinsTip)",
          "new_text": "vpindexToConnect.back()",
          "old_line_content": "    mempool.check(pcoinsTip);",
          "new_line_content": "        CheckForkWarningConditionsOnNewFork(vpindexToConnect.back());",
          "content_same": false
        },
        {
          "line": 2314,
          "old_api": "FindMostWorkChain",
          "new_api": "Tip",
          "old_text": "FindMostWorkChain()",
          "new_text": "chainActive.Tip()",
          "old_line_content": "                pindexMostWork = FindMostWorkChain();",
          "new_line_content": "            if (pindexMostWork == NULL || pindexMostWork == chainActive.Tip())",
          "content_same": false
        },
        {
          "line": 2330,
          "old_api": "Tip",
          "new_api": "GetBlocksConnected",
          "old_text": "chainActive.Tip()",
          "new_text": "connectTrace.GetBlocksConnected()",
          "old_line_content": "            pindexNewTip = chainActive.Tip();",
          "new_line_content": "            for (const PerBlockConnectTrace& trace : connectTrace.GetBlocksConnected()) {",
          "content_same": false
        },
        {
          "line": 2331,
          "old_api": "FindFork",
          "new_api": "assert",
          "old_text": "chainActive.FindFork(pindexOldTip)",
          "new_text": "assert(trace.pblock && trace.pindex)",
          "old_line_content": "            pindexFork = chainActive.FindFork(pindexOldTip);",
          "new_line_content": "                assert(trace.pblock && trace.pindex);",
          "content_same": false
        },
        {
          "line": 2332,
          "old_api": "IsInitialBlockDownload",
          "new_api": "BlockConnected",
          "old_text": "IsInitialBlockDownload()",
          "new_text": "GetMainSignals().BlockConnected(trace.pblock, trace.pindex, *trace.conflictedTxs)",
          "old_line_content": "            fInitialDownload = IsInitialBlockDownload();",
          "new_line_content": "                GetMainSignals().BlockConnected(trace.pblock, trace.pindex, *trace.conflictedTxs);",
          "content_same": false
        },
        {
          "line": 2344,
          "old_api": "UpdatedBlockTip",
          "new_api": "NotifyBlockTip",
          "old_text": "GetMainSignals().UpdatedBlockTip(pindexNewTip, pindexFork, fInitialDownload)",
          "new_text": "uiInterface.NotifyBlockTip(fInitialDownload, pindexNewTip)",
          "old_line_content": "        GetMainSignals().UpdatedBlockTip(pindexNewTip, pindexFork, fInitialDownload);",
          "new_line_content": "            uiInterface.NotifyBlockTip(fInitialDownload, pindexNewTip);",
          "content_same": false
        },
        {
          "line": 2386,
          "old_api": "PruneBlockIndexCandidates",
          "new_api": "ActivateBestChain",
          "old_text": "PruneBlockIndexCandidates()",
          "new_text": "ActivateBestChain(state, params)",
          "old_line_content": "            PruneBlockIndexCandidates();",
          "new_line_content": "    return ActivateBestChain(state, params);",
          "content_same": false
        },
        {
          "line": 2395,
          "old_api": "AssertLockHeld",
          "new_api": "insert",
          "old_text": "AssertLockHeld(cs_main)",
          "new_text": "setDirtyBlockIndex.insert(pindex)",
          "old_line_content": "    AssertLockHeld(cs_main);",
          "new_line_content": "    setDirtyBlockIndex.insert(pindex);",
          "content_same": false
        },
        {
          "line": 2399,
          "old_api": "insert",
          "new_api": "Contains",
          "old_text": "setDirtyBlockIndex.insert(pindex)",
          "new_text": "chainActive.Contains(pindex)",
          "old_line_content": "    setDirtyBlockIndex.insert(pindex);",
          "new_line_content": "    while (chainActive.Contains(pindex)) {",
          "content_same": false
        },
        {
          "line": 2400,
          "old_api": "erase",
          "new_api": "Tip",
          "old_text": "setBlockIndexCandidates.erase(pindex)",
          "new_text": "chainActive.Tip()",
          "old_line_content": "    setBlockIndexCandidates.erase(pindex);",
          "new_line_content": "        CBlockIndex *pindexWalk = chainActive.Tip();",
          "content_same": false
        },
        {
          "line": 2403,
          "old_api": "Contains",
          "new_api": "erase",
          "old_text": "chainActive.Contains(pindex)",
          "new_text": "setBlockIndexCandidates.erase(pindexWalk)",
          "old_line_content": "    while (chainActive.Contains(pindex)) {",
          "new_line_content": "        setBlockIndexCandidates.erase(pindexWalk);",
          "content_same": false
        },
        {
          "line": 2406,
          "old_api": "insert",
          "new_api": "DisconnectTip",
          "old_text": "setDirtyBlockIndex.insert(pindexWalk)",
          "new_text": "DisconnectTip(state, chainparams, &disconnectpool)",
          "old_line_content": "        setDirtyBlockIndex.insert(pindexWalk);",
          "new_line_content": "        if (!DisconnectTip(state, chainparams, &disconnectpool)) {",
          "content_same": false
        },
        {
          "line": 2420,
          "old_api": "UpdateMempoolForReorg",
          "new_api": "begin",
          "old_text": "UpdateMempoolForReorg(disconnectpool, true)",
          "new_text": "mapBlockIndex.begin()",
          "old_line_content": "    UpdateMempoolForReorg(disconnectpool, true);",
          "new_line_content": "    BlockMap::iterator it = mapBlockIndex.begin();",
          "content_same": false
        },
        {
          "line": 2443,
          "old_api": "begin",
          "new_api": "insert",
          "old_text": "mapBlockIndex.begin()",
          "new_text": "setDirtyBlockIndex.insert(it->second)",
          "old_line_content": "    BlockMap::iterator it = mapBlockIndex.begin();",
          "new_line_content": "            setDirtyBlockIndex.insert(it->second);",
          "content_same": false
        },
        {
          "line": 2444,
          "old_api": "end",
          "new_api": "Tip",
          "old_text": "mapBlockIndex.end()",
          "new_text": "chainActive.Tip()",
          "old_line_content": "    while (it != mapBlockIndex.end()) {",
          "new_line_content": "            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->nChainTx && setBlockIndexCandidates.value_comp()(chainActive.Tip(), it->second)) {",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": "GetAncestor",
          "new_api": "insert",
          "old_text": "it->second->GetAncestor(nHeight)",
          "new_text": "setBlockIndexCandidates.insert(it->second)",
          "old_line_content": "        if (!it->second->IsValid() && it->second->GetAncestor(nHeight) == pindex) {",
          "new_line_content": "                setBlockIndexCandidates.insert(it->second);",
          "content_same": false
        },
        {
          "line": 2488,
          "old_api": "end",
          "new_api": "BuildSkip",
          "old_text": "mapBlockIndex.end()",
          "new_text": "pindexNew->BuildSkip()",
          "old_line_content": "    if (miPrev != mapBlockIndex.end())",
          "new_line_content": "        pindexNew->BuildSkip();",
          "content_same": false
        },
        {
          "line": 2492,
          "old_api": "BuildSkip",
          "new_api": "RaiseValidity",
          "old_text": "pindexNew->BuildSkip()",
          "new_text": "pindexNew->RaiseValidity(BLOCK_VALID_TREE)",
          "old_line_content": "        pindexNew->BuildSkip();",
          "new_line_content": "    pindexNew->RaiseValidity(BLOCK_VALID_TREE);",
          "content_same": false
        },
        {
          "line": 2496,
          "old_api": "RaiseValidity",
          "new_api": "insert",
          "old_text": "pindexNew->RaiseValidity(BLOCK_VALID_TREE)",
          "new_text": "setDirtyBlockIndex.insert(pindexNew)",
          "old_line_content": "    pindexNew->RaiseValidity(BLOCK_VALID_TREE);",
          "new_line_content": "    setDirtyBlockIndex.insert(pindexNew);",
          "content_same": false
        },
        {
          "line": 2514,
          "old_api": "IsWitnessEnabled",
          "new_api": "insert",
          "old_text": "IsWitnessEnabled(pindexNew->pprev, consensusParams)",
          "new_text": "setDirtyBlockIndex.insert(pindexNew)",
          "old_line_content": "    if (IsWitnessEnabled(pindexNew->pprev, consensusParams)) {",
          "new_line_content": "    setDirtyBlockIndex.insert(pindexNew);",
          "content_same": false
        },
        {
          "line": 2523,
          "old_api": "push_back",
          "new_api": "front",
          "old_text": "queue.push_back(pindexNew)",
          "new_text": "queue.front()",
          "old_line_content": "        queue.push_back(pindexNew);",
          "new_line_content": "            CBlockIndex *pindex = queue.front();",
          "content_same": false
        },
        {
          "line": 2527,
          "old_api": "front",
          "new_api": "LOCK",
          "old_text": "queue.front()",
          "new_text": "LOCK(cs_nBlockSequenceId)",
          "old_line_content": "            CBlockIndex *pindex = queue.front();",
          "new_line_content": "                LOCK(cs_nBlockSequenceId);",
          "content_same": false
        },
        {
          "line": 2531,
          "old_api": "LOCK",
          "new_api": "insert",
          "old_text": "LOCK(cs_nBlockSequenceId)",
          "new_text": "setBlockIndexCandidates.insert(pindex)",
          "old_line_content": "                LOCK(cs_nBlockSequenceId);",
          "new_line_content": "                setBlockIndexCandidates.insert(pindex);",
          "content_same": false
        },
        {
          "line": 2542,
          "old_api": "erase",
          "new_api": "IsValid",
          "old_text": "mapBlocksUnlinked.erase(it)",
          "new_text": "pindexNew->pprev->IsValid(BLOCK_VALID_TREE)",
          "old_line_content": "                mapBlocksUnlinked.erase(it);",
          "new_line_content": "        if (pindexNew->pprev && pindexNew->pprev->IsValid(BLOCK_VALID_TREE)) {",
          "content_same": false
        },
        {
          "line": 2556,
          "old_api": "LOCK",
          "new_api": "resize",
          "old_text": "LOCK(cs_LastBlockFile)",
          "new_text": "vinfoBlockFile.resize(nFile + 1)",
          "old_line_content": "    LOCK(cs_LastBlockFile);",
          "new_line_content": "        vinfoBlockFile.resize(nFile + 1);",
          "content_same": false
        },
        {
          "line": 2578,
          "old_api": "FlushBlockFile",
          "new_api": "AddBlock",
          "old_text": "FlushBlockFile(!fKnown)",
          "new_text": "vinfoBlockFile[nFile].AddBlock(nHeight, nTime)",
          "old_line_content": "        FlushBlockFile(!fKnown);",
          "new_line_content": "    vinfoBlockFile[nFile].AddBlock(nHeight, nTime);",
          "content_same": false
        },
        {
          "line": 2594,
          "old_api": "CheckDiskSpace",
          "new_api": "AllocateFileRange",
          "old_text": "CheckDiskSpace(nNewChunks * BLOCKFILE_CHUNK_SIZE - pos.nPos)",
          "new_text": "AllocateFileRange(file, pos.nPos, nNewChunks * BLOCKFILE_CHUNK_SIZE - pos.nPos)",
          "old_line_content": "            if (CheckDiskSpace(nNewChunks * BLOCKFILE_CHUNK_SIZE - pos.nPos)) {",
          "new_line_content": "                    AllocateFileRange(file, pos.nPos, nNewChunks * BLOCKFILE_CHUNK_SIZE - pos.nPos);",
          "content_same": false
        },
        {
          "line": 2595,
          "old_api": "OpenBlockFile",
          "new_api": "fclose",
          "old_text": "OpenBlockFile(pos)",
          "new_text": "fclose(file)",
          "old_line_content": "                FILE *file = OpenBlockFile(pos);",
          "new_line_content": "                    fclose(file);",
          "content_same": false
        },
        {
          "line": 2599,
          "old_api": "fclose",
          "new_api": "Error",
          "old_text": "fclose(file)",
          "new_text": "state.Error(\"out of disk space\")",
          "old_line_content": "                    fclose(file);",
          "new_line_content": "                return state.Error(\"out of disk space\");",
          "content_same": false
        },
        {
          "line": 2603,
          "old_api": "Error",
          "new_api": "insert",
          "old_text": "state.Error(\"out of disk space\")",
          "new_text": "setDirtyFileInfo.insert(nFile)",
          "old_line_content": "                return state.Error(\"out of disk space\");",
          "new_line_content": "    setDirtyFileInfo.insert(nFile);",
          "content_same": false
        },
        {
          "line": 2627,
          "old_api": "CheckDiskSpace",
          "new_api": "AllocateFileRange",
          "old_text": "CheckDiskSpace(nNewChunks * UNDOFILE_CHUNK_SIZE - pos.nPos)",
          "new_text": "AllocateFileRange(file, pos.nPos, nNewChunks * UNDOFILE_CHUNK_SIZE - pos.nPos)",
          "old_line_content": "        if (CheckDiskSpace(nNewChunks * UNDOFILE_CHUNK_SIZE - pos.nPos)) {",
          "new_line_content": "                AllocateFileRange(file, pos.nPos, nNewChunks * UNDOFILE_CHUNK_SIZE - pos.nPos);",
          "content_same": false
        },
        {
          "line": 2628,
          "old_api": "OpenUndoFile",
          "new_api": "fclose",
          "old_text": "OpenUndoFile(pos)",
          "new_text": "fclose(file)",
          "old_line_content": "            FILE *file = OpenUndoFile(pos);",
          "new_line_content": "                fclose(file);",
          "content_same": false
        },
        {
          "line": 2632,
          "old_api": "fclose",
          "new_api": "Error",
          "old_text": "fclose(file)",
          "new_text": "state.Error(\"out of disk space\")",
          "old_line_content": "                fclose(file);",
          "new_line_content": "            return state.Error(\"out of disk space\");",
          "content_same": false
        },
        {
          "line": 2684,
          "old_api": "::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS)",
          "new_api": "IsCoinBase",
          "old_text": "::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS)",
          "new_text": "block.vtx[0]->IsCoinBase()",
          "old_line_content": "    if (block.vtx.empty() || block.vtx.size() > MAX_BLOCK_BASE_SIZE || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) > MAX_BLOCK_BASE_SIZE)",
          "new_line_content": "    if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())",
          "content_same": false
        },
        {
          "line": 2688,
          "old_api": "IsCoinBase",
          "new_api": "DoS",
          "old_text": "block.vtx[0]->IsCoinBase()",
          "new_text": "state.DoS(100, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\")",
          "old_line_content": "    if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())",
          "new_line_content": "            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");",
          "content_same": false
        },
        {
          "line": 2692,
          "old_api": "DoS",
          "new_api": "CheckTransaction",
          "old_text": "state.DoS(100, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\")",
          "new_text": "CheckTransaction(*tx, state, false)",
          "old_line_content": "            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");",
          "new_line_content": "        if (!CheckTransaction(*tx, state, false))",
          "content_same": false
        },
        {
          "line": 2753,
          "old_api": "GetWitnessCommitmentIndex",
          "new_api": "resize",
          "old_text": "GetWitnessCommitmentIndex(block)",
          "new_text": "tx.vin[0].scriptWitness.stack.resize(1)",
          "old_line_content": "    int commitpos = GetWitnessCommitmentIndex(block);",
          "new_line_content": "        tx.vin[0].scriptWitness.stack.resize(1);",
          "content_same": false
        },
        {
          "line": 2755,
          "old_api": "HasWitness",
          "new_api": "std::move(tx)",
          "old_text": "block.vtx[0]->HasWitness()",
          "new_text": "std::move(tx)",
          "old_line_content": "    if (commitpos != -1 && IsWitnessEnabled(pindexPrev, consensusParams) && !block.vtx[0]->HasWitness()) {",
          "new_line_content": "        block.vtx[0] = MakeTransactionRef(std::move(tx));",
          "content_same": false
        },
        {
          "line": 2766,
          "old_api": "GetWitnessCommitmentIndex",
          "new_api": "BlockWitnessMerkleRoot",
          "old_text": "GetWitnessCommitmentIndex(block)",
          "new_text": "BlockWitnessMerkleRoot(block, NULL)",
          "old_line_content": "    int commitpos = GetWitnessCommitmentIndex(block);",
          "new_line_content": "            uint256 witnessroot = BlockWitnessMerkleRoot(block, NULL);",
          "content_same": false
        },
        {
          "line": 2770,
          "old_api": "BlockWitnessMerkleRoot",
          "new_api": "resize",
          "old_text": "BlockWitnessMerkleRoot(block, NULL)",
          "new_text": "out.scriptPubKey.resize(38)",
          "old_line_content": "            uint256 witnessroot = BlockWitnessMerkleRoot(block, NULL);",
          "new_line_content": "            out.scriptPubKey.resize(38);",
          "content_same": false
        },
        {
          "line": 2781,
          "old_api": "begin",
          "new_api": "std::move(tx)",
          "old_text": "witnessroot.begin()",
          "new_text": "std::move(tx)",
          "old_line_content": "            memcpy(&out.scriptPubKey[6], witnessroot.begin(), 32);",
          "new_line_content": "            block.vtx[0] = MakeTransactionRef(std::move(tx));",
          "content_same": false
        },
        {
          "line": 2784,
          "old_api": "push_back",
          "new_api": "UpdateUncommittedBlockStructures",
          "old_text": "tx.vout.push_back(out)",
          "new_text": "UpdateUncommittedBlockStructures(block, pindexPrev, consensusParams)",
          "old_line_content": "            tx.vout.push_back(out);",
          "new_line_content": "    UpdateUncommittedBlockStructures(block, pindexPrev, consensusParams);",
          "content_same": false
        },
        {
          "line": 2797,
          "old_api": "assert",
          "new_api": "DoS",
          "old_text": "assert(pindexPrev != NULL)",
          "new_text": "state.DoS(100, false, REJECT_INVALID, \"bad-diffbits\", false, \"incorrect proof of work\")",
          "old_line_content": "    assert(pindexPrev != NULL);",
          "new_line_content": "        return state.DoS(100, false, REJECT_INVALID, \"bad-diffbits\", false, \"incorrect proof of work\");",
          "content_same": false
        },
        {
          "line": 2800,
          "old_api": "GetNextWorkRequired",
          "new_api": "GetMedianTimePast",
          "old_text": "GetNextWorkRequired(pindexPrev, &block, consensusParams)",
          "new_text": "pindexPrev->GetMedianTimePast()",
          "old_line_content": "    if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))",
          "new_line_content": "    if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())",
          "content_same": false
        },
        {
          "line": 2801,
          "old_api": "DoS",
          "new_api": "Invalid",
          "old_text": "state.DoS(100, false, REJECT_INVALID, \"bad-diffbits\", false, \"incorrect proof of work\")",
          "new_text": "state.Invalid(false, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\")",
          "old_line_content": "        return state.DoS(100, false, REJECT_INVALID, \"bad-diffbits\", false, \"incorrect proof of work\");",
          "new_line_content": "        return state.Invalid(false, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");",
          "content_same": false
        },
        {
          "line": 2804,
          "old_api": "GetMedianTimePast",
          "new_api": "GetBlockTime",
          "old_text": "pindexPrev->GetMedianTimePast()",
          "new_text": "block.GetBlockTime()",
          "old_line_content": "    if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())",
          "new_line_content": "    if (block.GetBlockTime() > nAdjustedTime + MAX_FUTURE_BLOCK_TIME)",
          "content_same": false
        },
        {
          "line": 2834,
          "old_api": "GetBlockTime",
          "new_api": "IsFinalTx",
          "old_text": "block.GetBlockTime()",
          "new_text": "IsFinalTx(*tx, nHeight, nLockTimeCutoff)",
          "old_line_content": "                              : block.GetBlockTime();",
          "new_line_content": "        if (!IsFinalTx(*tx, nHeight, nLockTimeCutoff)) {",
          "content_same": false
        },
        {
          "line": 2862,
          "old_api": "VersionBitsState",
          "new_api": "BlockWitnessMerkleRoot",
          "old_text": "VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache)",
          "new_text": "BlockWitnessMerkleRoot(block, &malleated)",
          "old_line_content": "    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == THRESHOLD_ACTIVE) {",
          "new_line_content": "            uint256 hashWitness = BlockWitnessMerkleRoot(block, &malleated);",
          "content_same": false
        },
        {
          "line": 2866,
          "old_api": "BlockWitnessMerkleRoot",
          "new_api": "size",
          "old_text": "BlockWitnessMerkleRoot(block, &malleated)",
          "new_text": "block.vtx[0]->vin[0].scriptWitness.stack[0].size()",
          "old_line_content": "            uint256 hashWitness = BlockWitnessMerkleRoot(block, &malleated);",
          "new_line_content": "            if (block.vtx[0]->vin[0].scriptWitness.stack.size() != 1 || block.vtx[0]->vin[0].scriptWitness.stack[0].size() != 32) {",
          "content_same": false
        },
        {
          "line": 2870,
          "old_api": "size",
          "new_api": "begin",
          "old_text": "block.vtx[0]->vin[0].scriptWitness.stack[0].size()",
          "new_text": "hashWitness.begin()",
          "old_line_content": "            if (block.vtx[0]->vin[0].scriptWitness.stack.size() != 1 || block.vtx[0]->vin[0].scriptWitness.stack[0].size() != 32) {",
          "new_line_content": "            if (memcmp(hashWitness.begin(), &block.vtx[0]->vout[commitpos].scriptPubKey[6], 32)) {",
          "content_same": false
        },
        {
          "line": 2908,
          "old_api": "find",
          "new_api": "end",
          "old_text": "mapBlockIndex.find(hash)",
          "new_text": "mapBlockIndex.end()",
          "old_line_content": "    BlockMap::iterator miSelf = mapBlockIndex.find(hash);",
          "new_line_content": "        if (miSelf != mapBlockIndex.end()) {",
          "content_same": false
        },
        {
          "line": 2918,
          "old_api": "ToString",
          "new_api": "GetConsensus",
          "old_text": "hash.ToString()",
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "                return state.Invalid(error(\"%s: block %s is marked invalid\", __func__, hash.ToString()), 0, \"duplicate\");",
          "new_line_content": "        if (!CheckBlockHeader(block, state, chainparams.GetConsensus()))",
          "content_same": false
        },
        {
          "line": 2923,
          "old_api": "FormatStateMessage",
          "new_api": "find",
          "old_text": "FormatStateMessage(state)",
          "new_text": "mapBlockIndex.find(block.hashPrevBlock)",
          "old_line_content": "            return error(\"%s: Consensus::CheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));",
          "new_line_content": "        BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);",
          "content_same": false
        },
        {
          "line": 2928,
          "old_api": "end",
          "new_api": "error",
          "old_text": "mapBlockIndex.end()",
          "new_text": "error(\"%s: prev block invalid\", __func__)",
          "old_line_content": "        if (mi == mapBlockIndex.end())",
          "new_line_content": "            return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");",
          "content_same": false
        },
        {
          "line": 2932,
          "old_api": "error",
          "new_api": "GetRejectReason",
          "old_text": "error(\"%s: prev block invalid\", __func__)",
          "new_text": "state.GetRejectReason().c_str()",
          "old_line_content": "            return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");",
          "new_line_content": "            return error(\"%s: CheckIndexAgainstCheckpoint(): %s\", __func__, state.GetRejectReason().c_str());",
          "content_same": false
        },
        {
          "line": 2934,
          "old_api": "assert",
          "new_api": "GetAdjustedTime",
          "old_text": "assert(pindexPrev)",
          "new_text": "GetAdjustedTime()",
          "old_line_content": "        assert(pindexPrev);",
          "new_line_content": "        if (!ContextualCheckBlockHeader(block, state, chainparams.GetConsensus(), pindexPrev, GetAdjustedTime()))",
          "content_same": false
        },
        {
          "line": 2935,
          "old_api": "CheckIndexAgainstCheckpoint",
          "new_api": "FormatStateMessage",
          "old_text": "CheckIndexAgainstCheckpoint(pindexPrev, state, chainparams, hash)",
          "new_text": "FormatStateMessage(state)",
          "old_line_content": "        if (fCheckpointsEnabled && !CheckIndexAgainstCheckpoint(pindexPrev, state, chainparams, hash))",
          "new_line_content": "            return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));",
          "content_same": false
        },
        {
          "line": 2938,
          "old_api": "GetAdjustedTime",
          "new_api": "AddToBlockIndex",
          "old_text": "GetAdjustedTime()",
          "new_text": "AddToBlockIndex(block)",
          "old_line_content": "        if (!ContextualCheckBlockHeader(block, state, chainparams.GetConsensus(), pindexPrev, GetAdjustedTime()))",
          "new_line_content": "        pindex = AddToBlockIndex(block);",
          "content_same": false
        },
        {
          "line": 3012,
          "old_api": "GetConsensus",
          "new_api": "insert",
          "old_text": "chainparams.GetConsensus()",
          "new_text": "setDirtyBlockIndex.insert(pindex)",
          "old_line_content": "    if (!CheckBlock(block, state, chainparams.GetConsensus()) ||",
          "new_line_content": "            setDirtyBlockIndex.insert(pindex);",
          "content_same": false
        },
        {
          "line": 3014,
          "old_api": "CorruptionPossible",
          "new_api": "FormatStateMessage",
          "old_text": "state.CorruptionPossible()",
          "new_text": "FormatStateMessage(state)",
          "old_line_content": "        if (state.IsInvalid() && !state.CorruptionPossible()) {",
          "new_line_content": "        return error(\"%s: %s\", __func__, FormatStateMessage(state));",
          "content_same": false
        },
        {
          "line": 3030,
          "old_api": "::GetSerializeSize(block, SER_DISK, CLIENT_VERSION)",
          "new_api": "GetBlockTime",
          "old_text": "::GetSerializeSize(block, SER_DISK, CLIENT_VERSION)",
          "new_text": "block.GetBlockTime()",
          "old_line_content": "        unsigned int nBlockSize = ::GetSerializeSize(block, SER_DISK, CLIENT_VERSION);",
          "new_line_content": "        if (!FindBlockPos(state, blockPos, nBlockSize+8, nHeight, block.GetBlockTime(), dbp != NULL))",
          "content_same": false
        },
        {
          "line": 3034,
          "old_api": "GetBlockTime",
          "new_api": "AbortNode",
          "old_text": "block.GetBlockTime()",
          "new_text": "AbortNode(state, \"Failed to write block\")",
          "old_line_content": "        if (!FindBlockPos(state, blockPos, nBlockSize+8, nHeight, block.GetBlockTime(), dbp != NULL))",
          "new_line_content": "                AbortNode(state, \"Failed to write block\");",
          "content_same": false
        },
        {
          "line": 3035,
          "old_api": "error",
          "new_api": "GetConsensus",
          "old_text": "error(\"AcceptBlock(): FindBlockPos failed\")",
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "            return error(\"AcceptBlock(): FindBlockPos failed\");",
          "new_line_content": "        if (!ReceivedBlockTransactions(block, state, pindex, blockPos, chainparams.GetConsensus()))",
          "content_same": false
        },
        {
          "line": 3038,
          "old_api": "AbortNode",
          "new_api": "what",
          "old_text": "AbortNode(state, \"Failed to write block\")",
          "new_text": "e.what()",
          "old_line_content": "                AbortNode(state, \"Failed to write block\");",
          "new_line_content": "        return AbortNode(state, std::string(\"System error: \") + e.what());",
          "content_same": false
        },
        {
          "line": 3042,
          "old_api": "what",
          "new_api": "FlushStateToDisk",
          "old_text": "e.what()",
          "new_text": "FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE)",
          "old_line_content": "        return AbortNode(state, std::string(\"System error: \") + e.what());",
          "new_line_content": "        FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE); // we just allocated more disk space for block files",
          "content_same": false
        },
        {
          "line": 3061,
          "old_api": "LOCK",
          "new_api": "AcceptBlock",
          "old_text": "LOCK(cs_main)",
          "new_text": "AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, NULL, fNewBlock)",
          "old_line_content": "        LOCK(cs_main);",
          "new_line_content": "            ret = AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, NULL, fNewBlock);",
          "content_same": false
        },
        {
          "line": 3065,
          "old_api": "AcceptBlock",
          "new_api": "BlockChecked",
          "old_text": "AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, NULL, fNewBlock)",
          "new_text": "GetMainSignals().BlockChecked(*pblock, state)",
          "old_line_content": "            ret = AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, NULL, fNewBlock);",
          "new_line_content": "            GetMainSignals().BlockChecked(*pblock, state);",
          "content_same": false
        },
        {
          "line": 3070,
          "old_api": "error",
          "new_api": "NotifyHeaderTip",
          "old_text": "error(\"%s: AcceptBlock FAILED\", __func__)",
          "new_text": "NotifyHeaderTip()",
          "old_line_content": "            return error(\"%s: AcceptBlock FAILED\", __func__);",
          "new_line_content": "    NotifyHeaderTip();",
          "content_same": false
        },
        {
          "line": 3074,
          "old_api": "NotifyHeaderTip",
          "new_api": "error",
          "old_text": "NotifyHeaderTip()",
          "new_text": "error(\"%s: ActivateBestChain failed\", __func__)",
          "old_line_content": "    NotifyHeaderTip();",
          "new_line_content": "        return error(\"%s: ActivateBestChain failed\", __func__);",
          "content_same": false
        },
        {
          "line": 3096,
          "old_api": "GetAdjustedTime",
          "new_api": "GetConsensus",
          "old_text": "GetAdjustedTime()",
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "    if (!ContextualCheckBlockHeader(block, state, chainparams.GetConsensus(), pindexPrev, GetAdjustedTime()))",
          "new_line_content": "    if (!ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindexPrev))",
          "content_same": false
        },
        {
          "line": 3098,
          "old_api": "GetConsensus",
          "new_api": "ConnectBlock",
          "old_text": "chainparams.GetConsensus()",
          "new_text": "ConnectBlock(block, state, &indexDummy, viewNew, chainparams, true)",
          "old_line_content": "    if (!CheckBlock(block, state, chainparams.GetConsensus(), fCheckPOW, fCheckMerkleRoot))",
          "new_line_content": "    if (!ConnectBlock(block, state, &indexDummy, viewNew, chainparams, true))",
          "content_same": false
        },
        {
          "line": 3100,
          "old_api": "GetConsensus",
          "new_api": "IsValid",
          "old_text": "chainparams.GetConsensus()",
          "new_text": "state.IsValid()",
          "old_line_content": "    if (!ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindexPrev))",
          "new_line_content": "    assert(state.IsValid());",
          "content_same": false
        },
        {
          "line": 3158,
          "old_api": "end",
          "new_api": "LogPrintf",
          "old_text": "setFilesToPrune.end()",
          "new_text": "LogPrintf(\"Prune: %s deleted blk/rev (%05u)\\n\", __func__, *it)",
          "old_line_content": "    for (std::set<int>::iterator it = setFilesToPrune.begin(); it != setFilesToPrune.end(); ++it) {",
          "new_line_content": "        LogPrintf(\"Prune: %s deleted blk/rev (%05u)\\n\", __func__, *it);",
          "content_same": false
        },
        {
          "line": 3181,
          "old_api": "PruneOneBlockFile",
          "new_api": "LogPrintf",
          "old_text": "PruneOneBlockFile(fileNumber)",
          "new_text": "LogPrintf(\"Prune (Manual): prune_height=%d removed %d blk/rev pairs\\n\", nLastBlockWeCanPrune, count)",
          "old_line_content": "        PruneOneBlockFile(fileNumber);",
          "new_line_content": "    LogPrintf(\"Prune (Manual): prune_height=%d removed %d blk/rev pairs\\n\", nLastBlockWeCanPrune, count);",
          "content_same": false
        },
        {
          "line": 3213,
          "old_api": "LOCK2",
          "new_api": "Tip",
          "old_text": "LOCK2(cs_main, cs_LastBlockFile)",
          "new_text": "chainActive.Tip()",
          "old_line_content": "    LOCK2(cs_main, cs_LastBlockFile);",
          "new_line_content": "    if ((uint64_t)chainActive.Tip()->nHeight <= nPruneAfterHeight) {",
          "content_same": false
        },
        {
          "line": 3260,
          "old_api": "GetDataDir",
          "new_api": "_",
          "old_text": "GetDataDir()",
          "new_text": "_(\"Error: Disk space is low!\")",
          "old_line_content": "    uint64_t nFreeBytesAvailable = fs::space(GetDataDir()).available;",
          "new_line_content": "        return AbortNode(\"Disk space is low!\", _(\"Error: Disk space is low!\"));",
          "content_same": false
        },
        {
          "line": 3271,
          "old_api": "IsNull",
          "new_api": "fsbridge::fopen(path, \"rb+\")",
          "old_text": "pos.IsNull()",
          "new_text": "fsbridge::fopen(path, \"rb+\")",
          "old_line_content": "    if (pos.IsNull())",
          "new_line_content": "    FILE* file = fsbridge::fopen(path, \"rb+\");",
          "content_same": false
        },
        {
          "line": 3273,
          "old_api": "GetBlockPosFilename",
          "new_api": "fsbridge::fopen(path, \"wb+\")",
          "old_text": "GetBlockPosFilename(pos, prefix)",
          "new_text": "fsbridge::fopen(path, \"wb+\")",
          "old_line_content": "    fs::path path = GetBlockPosFilename(pos, prefix);",
          "new_line_content": "        file = fsbridge::fopen(path, \"wb+\");",
          "content_same": false
        },
        {
          "line": 3275,
          "old_api": "fsbridge::fopen(path, \"rb+\")",
          "new_api": "string",
          "old_text": "fsbridge::fopen(path, \"rb+\")",
          "new_text": "path.string()",
          "old_line_content": "    FILE* file = fsbridge::fopen(path, \"rb+\");",
          "new_line_content": "        LogPrintf(\"Unable to open file %s\\n\", path.string());",
          "content_same": false
        },
        {
          "line": 3279,
          "old_api": "string",
          "new_api": "fseek",
          "old_text": "path.string()",
          "new_text": "fseek(file, pos.nPos, SEEK_SET)",
          "old_line_content": "        LogPrintf(\"Unable to open file %s\\n\", path.string());",
          "new_line_content": "        if (fseek(file, pos.nPos, SEEK_SET)) {",
          "content_same": false
        },
        {
          "line": 3308,
          "old_api": "IsNull",
          "new_api": "find",
          "old_text": "hash.IsNull()",
          "new_text": "mapBlockIndex.find(hash)",
          "old_line_content": "    if (hash.IsNull())",
          "new_line_content": "    BlockMap::iterator mi = mapBlockIndex.find(hash);",
          "content_same": false
        },
        {
          "line": 3331,
          "old_api": "boost::this_thread::interruption_point()",
          "new_api": "size",
          "old_text": "boost::this_thread::interruption_point()",
          "new_text": "mapBlockIndex.size()",
          "old_line_content": "    boost::this_thread::interruption_point();",
          "new_line_content": "    vSortedByHeight.reserve(mapBlockIndex.size());",
          "content_same": false
        },
        {
          "line": 3335,
          "old_api": "size",
          "new_api": "std::make_pair(pindex->nHeight, pindex)",
          "old_text": "mapBlockIndex.size()",
          "new_text": "std::make_pair(pindex->nHeight, pindex)",
          "old_line_content": "    vSortedByHeight.reserve(mapBlockIndex.size());",
          "new_line_content": "        vSortedByHeight.push_back(std::make_pair(pindex->nHeight, pindex));",
          "content_same": false
        },
        {
          "line": 3341,
          "old_api": "end",
          "new_api": "GetBlockProof",
          "old_text": "vSortedByHeight.end()",
          "new_text": "GetBlockProof(*pindex)",
          "old_line_content": "    sort(vSortedByHeight.begin(), vSortedByHeight.end());",
          "new_line_content": "        pindex->nChainWork = (pindex->pprev ? pindex->pprev->nChainWork : 0) + GetBlockProof(*pindex);",
          "content_same": false
        },
        {
          "line": 3362,
          "old_api": "insert",
          "new_api": "BuildSkip",
          "old_text": "setBlockIndexCandidates.insert(pindex)",
          "new_text": "pindex->BuildSkip()",
          "old_line_content": "            setBlockIndexCandidates.insert(pindex);",
          "new_line_content": "            pindex->BuildSkip();",
          "content_same": false
        },
        {
          "line": 3372,
          "old_api": "ReadLastBlockFile",
          "new_api": "ReadBlockFileInfo",
          "old_text": "pblocktree->ReadLastBlockFile(nLastBlockFile)",
          "new_text": "pblocktree->ReadBlockFileInfo(nFile, vinfoBlockFile[nFile])",
          "old_line_content": "    pblocktree->ReadLastBlockFile(nLastBlockFile);",
          "new_line_content": "        pblocktree->ReadBlockFileInfo(nFile, vinfoBlockFile[nFile]);",
          "content_same": false
        },
        {
          "line": 3374,
          "old_api": "LogPrintf",
          "new_api": "ToString",
          "old_text": "LogPrintf(\"%s: last block file = %i\\n\", __func__, nLastBlockFile)",
          "new_text": "vinfoBlockFile[nLastBlockFile].ToString()",
          "old_line_content": "    LogPrintf(\"%s: last block file = %i\\n\", __func__, nLastBlockFile);",
          "new_line_content": "    LogPrintf(\"%s: last block file info: %s\\n\", __func__, vinfoBlockFile[nLastBlockFile].ToString());",
          "content_same": false
        },
        {
          "line": 3378,
          "old_api": "ToString",
          "new_api": "push_back",
          "old_text": "vinfoBlockFile[nLastBlockFile].ToString()",
          "new_text": "vinfoBlockFile.push_back(info)",
          "old_line_content": "    LogPrintf(\"%s: last block file info: %s\\n\", __func__, vinfoBlockFile[nLastBlockFile].ToString());",
          "new_line_content": "            vinfoBlockFile.push_back(info);",
          "content_same": false
        },
        {
          "line": 3409,
          "old_api": "LogPrintf",
          "new_api": "ReadReindexing",
          "old_text": "LogPrintf(\"LoadBlockIndexDB(): Block files have previously been pruned\\n\")",
          "new_text": "pblocktree->ReadReindexing(fReindexing)",
          "old_line_content": "        LogPrintf(\"LoadBlockIndexDB(): Block files have previously been pruned\\n\");",
          "new_line_content": "    pblocktree->ReadReindexing(fReindexing);",
          "content_same": false
        },
        {
          "line": 3413,
          "old_api": "ReadReindexing",
          "new_api": "ReadFlag",
          "old_text": "pblocktree->ReadReindexing(fReindexing)",
          "new_text": "pblocktree->ReadFlag(\"txindex\", fTxIndex)",
          "old_line_content": "    pblocktree->ReadReindexing(fReindexing);",
          "new_line_content": "    pblocktree->ReadFlag(\"txindex\", fTxIndex);",
          "content_same": false
        },
        {
          "line": 3417,
          "old_api": "ReadFlag",
          "new_api": "GetBestBlock",
          "old_text": "pblocktree->ReadFlag(\"txindex\", fTxIndex)",
          "new_text": "pcoinsTip->GetBestBlock()",
          "old_line_content": "    pblocktree->ReadFlag(\"txindex\", fTxIndex);",
          "new_line_content": "    BlockMap::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());",
          "content_same": false
        },
        {
          "line": 3418,
          "old_api": "LogPrintf",
          "new_api": "end",
          "old_text": "LogPrintf(\"%s: transaction index %s\\n\", __func__, fTxIndex ? \"enabled\" : \"disabled\")",
          "new_text": "mapBlockIndex.end()",
          "old_line_content": "    LogPrintf(\"%s: transaction index %s\\n\", __func__, fTxIndex ? \"enabled\" : \"disabled\");",
          "new_line_content": "    if (it == mapBlockIndex.end())",
          "content_same": false
        },
        {
          "line": 3422,
          "old_api": "end",
          "new_api": "PruneBlockIndexCandidates",
          "old_text": "mapBlockIndex.end()",
          "new_text": "PruneBlockIndexCandidates()",
          "old_line_content": "    if (it == mapBlockIndex.end())",
          "new_line_content": "    PruneBlockIndexCandidates();",
          "content_same": false
        },
        {
          "line": 3424,
          "old_api": "SetTip",
          "new_api": "Tip",
          "old_text": "chainActive.SetTip(it->second)",
          "new_text": "LogPrintf(\"%s: hashBestChain=%s height=%d date=%s progress=%f\\n\", __func__,\n        chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(),\n        DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()),\n        GuessVerificationProgress(chainparams.TxData(), chainActive.Tip()))",
          "old_line_content": "    chainActive.SetTip(it->second);",
          "new_line_content": "    LogPrintf(\"%s: hashBestChain=%s height=%d date=%s progress=%f\\n\", __func__,",
          "content_same": false
        },
        {
          "line": 3426,
          "old_api": "PruneBlockIndexCandidates",
          "new_api": "Tip",
          "old_text": "PruneBlockIndexCandidates()",
          "new_text": "chainActive.Tip()->GetBlockTime()",
          "old_line_content": "    PruneBlockIndexCandidates();",
          "new_line_content": "        DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()),",
          "content_same": false
        },
        {
          "line": 3456,
          "old_api": "Height",
          "new_api": "Tip",
          "old_text": "chainActive.Height()",
          "new_text": "chainActive.Tip()",
          "old_line_content": "        nCheckDepth = chainActive.Height();",
          "new_line_content": "    CBlockIndex* pindexState = chainActive.Tip();",
          "content_same": false
        },
        {
          "line": 3465,
          "old_api": "LogPrintf",
          "new_api": "Height",
          "old_text": "LogPrintf(\"[0%%]...\")",
          "new_text": "chainActive.Height()",
          "old_line_content": "    LogPrintf(\"[0%%]...\");",
          "new_line_content": "        int percentageDone = std::max(1, std::min(99, (int)(((double)(chainActive.Height() - pindex->nHeight)) / (double)nCheckDepth * (nCheckLevel >= 4 ? 50 : 100))));",
          "content_same": false
        },
        {
          "line": 3468,
          "old_api": "boost::this_thread::interruption_point()",
          "new_api": "LogPrintf",
          "old_text": "boost::this_thread::interruption_point()",
          "new_text": "LogPrintf(\"[%d%%]...\", percentageDone)",
          "old_line_content": "        boost::this_thread::interruption_point();",
          "new_line_content": "            LogPrintf(\"[%d%%]...\", percentageDone);",
          "content_same": false
        },
        {
          "line": 3472,
          "old_api": "LogPrintf",
          "new_api": "Height",
          "old_text": "LogPrintf(\"[%d%%]...\", percentageDone)",
          "new_text": "chainActive.Height()",
          "old_line_content": "            LogPrintf(\"[%d%%]...\", percentageDone);",
          "new_line_content": "        if (pindex->nHeight < chainActive.Height()-nCheckDepth)",
          "content_same": false
        },
        {
          "line": 3476,
          "old_api": "Height",
          "new_api": "LogPrintf",
          "old_text": "chainActive.Height()",
          "new_text": "LogPrintf(\"VerifyDB(): block verification stopping at height %d (pruning, no data)\\n\", pindex->nHeight)",
          "old_line_content": "        if (pindex->nHeight < chainActive.Height()-nCheckDepth)",
          "new_line_content": "            LogPrintf(\"VerifyDB(): block verification stopping at height %d (pruning, no data)\\n\", pindex->nHeight);",
          "content_same": false
        },
        {
          "line": 3485,
          "old_api": "GetConsensus",
          "new_api": "ToString",
          "old_text": "chainparams.GetConsensus()",
          "new_text": "error(\"%s: *** found bad block at %d, hash=%s (%s)\\n\", __func__,\n                         pindex->nHeight, pindex->GetBlockHash().ToString(), FormatStateMessage(state))",
          "old_line_content": "        if (!ReadBlockFromDisk(block, pindex, chainparams.GetConsensus()))",
          "new_line_content": "            return error(\"%s: *** found bad block at %d, hash=%s (%s)\\n\", __func__,",
          "content_same": false
        },
        {
          "line": 3486,
          "old_api": "ToString",
          "new_api": "FormatStateMessage",
          "old_text": "pindex->GetBlockHash().ToString()",
          "new_text": "FormatStateMessage(state)",
          "old_line_content": "            return error(\"VerifyDB(): *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());",
          "new_line_content": "                         pindex->nHeight, pindex->GetBlockHash().ToString(), FormatStateMessage(state));",
          "content_same": false
        },
        {
          "line": 3490,
          "old_api": "FormatStateMessage",
          "new_api": "GetUndoPos",
          "old_text": "FormatStateMessage(state)",
          "new_text": "pindex->GetUndoPos()",
          "old_line_content": "                         pindex->nHeight, pindex->GetBlockHash().ToString(), FormatStateMessage(state));",
          "new_line_content": "            CDiskBlockPos pos = pindex->GetUndoPos();",
          "content_same": false
        },
        {
          "line": 3497,
          "old_api": "ToString",
          "new_api": "DynamicMemoryUsage",
          "old_text": "pindex->GetBlockHash().ToString()",
          "new_text": "pcoinsTip->DynamicMemoryUsage()",
          "old_line_content": "                    return error(\"VerifyDB(): *** found bad undo data at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());",
          "new_line_content": "        if (nCheckLevel >= 3 && pindex == pindexState && (coins.DynamicMemoryUsage() + pcoinsTip->DynamicMemoryUsage()) <= nCoinCacheUsage) {",
          "content_same": false
        },
        {
          "line": 3514,
          "old_api": "ShutdownRequested",
          "new_api": "Height",
          "old_text": "ShutdownRequested()",
          "new_text": "chainActive.Height()",
          "old_line_content": "        if (ShutdownRequested())",
          "new_line_content": "        return error(\"VerifyDB(): *** coin database inconsistencies found (last %i blocks, %i good transactions before that)\\n\", chainActive.Height() - pindexFailure->nHeight + 1, nGoodTransactions);",
          "content_same": false
        },
        {
          "line": 3524,
          "old_api": "boost::this_thread::interruption_point()",
          "new_api": "GetConsensus",
          "old_text": "boost::this_thread::interruption_point()",
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "            boost::this_thread::interruption_point();",
          "new_line_content": "            if (!ReadBlockFromDisk(block, pindex, chainparams.GetConsensus()))",
          "content_same": false
        },
        {
          "line": 3525,
          "old_api": "Height",
          "new_api": "ToString",
          "old_text": "chainActive.Height()",
          "new_text": "pindex->GetBlockHash().ToString()",
          "old_line_content": "            uiInterface.ShowProgress(_(\"Verifying blocks...\"), std::max(1, std::min(99, 100 - (int)(((double)(chainActive.Height() - pindex->nHeight)) / (double)nCheckDepth * 50))));",
          "new_line_content": "                return error(\"VerifyDB(): *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());",
          "content_same": false
        },
        {
          "line": 3526,
          "old_api": "Next",
          "new_api": "ConnectBlock",
          "old_text": "chainActive.Next(pindex)",
          "new_text": "ConnectBlock(block, state, pindex, coins, chainparams)",
          "old_line_content": "            pindex = chainActive.Next(pindex);",
          "new_line_content": "            if (!ConnectBlock(block, state, pindex, coins, chainparams))",
          "content_same": false
        },
        {
          "line": 3531,
          "old_api": "ToString",
          "new_api": "LogPrintf",
          "old_text": "pindex->GetBlockHash().ToString()",
          "new_text": "LogPrintf(\"[DONE].\\n\")",
          "old_line_content": "                return error(\"VerifyDB(): *** found unconnectable block at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());",
          "new_line_content": "    LogPrintf(\"[DONE].\\n\");",
          "content_same": false
        },
        {
          "line": 3543,
          "old_api": "LOCK",
          "new_api": "GetConsensus",
          "old_text": "LOCK(cs_main)",
          "new_text": "params.GetConsensus()",
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "        if (IsWitnessEnabled(chainActive[nHeight - 1], params.GetConsensus()) && !(chainActive[nHeight]->nStatus & BLOCK_OPT_WITNESS)) {",
          "content_same": false
        },
        {
          "line": 3565,
          "old_api": "DisconnectTip",
          "new_api": "FlushStateToDisk",
          "old_text": "DisconnectTip(state, params, NULL)",
          "new_text": "FlushStateToDisk(params, state, FLUSH_STATE_PERIODIC)",
          "old_line_content": "        if (!DisconnectTip(state, params, NULL)) {",
          "new_line_content": "        if (!FlushStateToDisk(params, state, FLUSH_STATE_PERIODIC))",
          "content_same": false
        },
        {
          "line": 3610,
          "old_api": "insert",
          "new_api": "PruneBlockIndexCandidates",
          "old_text": "setBlockIndexCandidates.insert(pindexIter)",
          "new_text": "PruneBlockIndexCandidates()",
          "old_line_content": "            setBlockIndexCandidates.insert(pindexIter);",
          "new_line_content": "    PruneBlockIndexCandidates();",
          "content_same": false
        },
        {
          "line": 3614,
          "old_api": "PruneBlockIndexCandidates",
          "new_api": "FlushStateToDisk",
          "old_text": "PruneBlockIndexCandidates()",
          "new_text": "FlushStateToDisk(params, state, FLUSH_STATE_ALWAYS)",
          "old_line_content": "    PruneBlockIndexCandidates();",
          "new_line_content": "    if (!FlushStateToDisk(params, state, FLUSH_STATE_ALWAYS)) {",
          "content_same": false
        },
        {
          "line": 3632,
          "old_api": "SetTip",
          "new_api": "clear",
          "old_text": "chainActive.SetTip(NULL)",
          "new_text": "mapBlocksUnlinked.clear()",
          "old_line_content": "    chainActive.SetTip(NULL);",
          "new_line_content": "    mapBlocksUnlinked.clear();",
          "content_same": false
        },
        {
          "line": 3667,
          "old_api": "Genesis",
          "new_api": "GetBoolArg",
          "old_text": "chainActive.Genesis()",
          "new_text": "GetBoolArg(\"-txindex\", DEFAULT_TXINDEX)",
          "old_line_content": "    if (chainActive.Genesis() != NULL)",
          "new_line_content": "    fTxIndex = GetBoolArg(\"-txindex\", DEFAULT_TXINDEX);",
          "content_same": false
        },
        {
          "line": 3680,
          "old_api": "::GetSerializeSize(block, SER_DISK, CLIENT_VERSION)",
          "new_api": "error",
          "old_text": "::GetSerializeSize(block, SER_DISK, CLIENT_VERSION)",
          "new_text": "error(\"LoadBlockIndex(): FindBlockPos failed\")",
          "old_line_content": "            unsigned int nBlockSize = ::GetSerializeSize(block, SER_DISK, CLIENT_VERSION);",
          "new_line_content": "                return error(\"LoadBlockIndex(): FindBlockPos failed\");",
          "content_same": false
        },
        {
          "line": 3683,
          "old_api": "GetBlockTime",
          "new_api": "AddToBlockIndex",
          "old_text": "block.GetBlockTime()",
          "new_text": "AddToBlockIndex(block)",
          "old_line_content": "            if (!FindBlockPos(state, blockPos, nBlockSize+8, 0, block.GetBlockTime()))",
          "new_line_content": "            CBlockIndex *pindex = AddToBlockIndex(block);",
          "content_same": false
        },
        {
          "line": 3684,
          "old_api": "error",
          "new_api": "GetConsensus",
          "old_text": "error(\"LoadBlockIndex(): FindBlockPos failed\")",
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "                return error(\"LoadBlockIndex(): FindBlockPos failed\");",
          "new_line_content": "            if (!ReceivedBlockTransactions(block, state, pindex, blockPos, chainparams.GetConsensus()))",
          "content_same": false
        },
        {
          "line": 3685,
          "old_api": "MessageStart",
          "new_api": "error",
          "old_text": "chainparams.MessageStart()",
          "new_text": "error(\"LoadBlockIndex(): genesis block not accepted\")",
          "old_line_content": "            if (!WriteBlockToDisk(block, blockPos, chainparams.MessageStart()))",
          "new_line_content": "                return error(\"LoadBlockIndex(): genesis block not accepted\");",
          "content_same": false
        },
        {
          "line": 3687,
          "old_api": "AddToBlockIndex",
          "new_api": "FlushStateToDisk",
          "old_text": "AddToBlockIndex(block)",
          "new_text": "FlushStateToDisk(chainparams, state, FLUSH_STATE_ALWAYS)",
          "old_line_content": "            CBlockIndex *pindex = AddToBlockIndex(block);",
          "new_line_content": "            return FlushStateToDisk(chainparams, state, FLUSH_STATE_ALWAYS);",
          "content_same": false
        },
        {
          "line": 3689,
          "old_api": "error",
          "new_api": "what",
          "old_text": "error(\"LoadBlockIndex(): genesis block not accepted\")",
          "new_text": "e.what()",
          "old_line_content": "                return error(\"LoadBlockIndex(): genesis block not accepted\");",
          "new_line_content": "            return error(\"LoadBlockIndex(): failed to initialize block database: %s\", e.what());",
          "content_same": false
        },
        {
          "line": 3710,
          "old_api": "GetPos",
          "new_api": "SetPos",
          "old_text": "blkdat.GetPos()",
          "new_text": "blkdat.SetPos(nRewind)",
          "old_line_content": "        uint64_t nRewind = blkdat.GetPos();",
          "new_line_content": "            blkdat.SetPos(nRewind);",
          "content_same": false
        },
        {
          "line": 3712,
          "old_api": "boost::this_thread::interruption_point()",
          "new_api": "SetLimit",
          "old_text": "boost::this_thread::interruption_point()",
          "new_text": "blkdat.SetLimit()",
          "old_line_content": "            boost::this_thread::interruption_point();",
          "new_line_content": "            blkdat.SetLimit(); // remove former limit",
          "content_same": false
        },
        {
          "line": 3736,
          "old_api": "GetPos",
          "new_api": "SetPos",
          "old_text": "blkdat.GetPos()",
          "new_text": "blkdat.SetPos(nBlockPos)",
          "old_line_content": "                uint64_t nBlockPos = blkdat.GetPos();",
          "new_line_content": "                blkdat.SetPos(nBlockPos);",
          "content_same": false
        },
        {
          "line": 3740,
          "old_api": "SetPos",
          "new_api": "GetPos",
          "old_text": "blkdat.SetPos(nBlockPos)",
          "new_text": "blkdat.GetPos()",
          "old_line_content": "                blkdat.SetPos(nBlockPos);",
          "new_line_content": "                nRewind = blkdat.GetPos();",
          "content_same": false
        },
        {
          "line": 3744,
          "old_api": "GetPos",
          "new_api": "end",
          "old_text": "blkdat.GetPos()",
          "new_text": "mapBlockIndex.end()",
          "old_line_content": "                nRewind = blkdat.GetPos();",
          "new_line_content": "                if (hash != chainparams.GetConsensus().hashGenesisBlock && mapBlockIndex.find(block.hashPrevBlock) == mapBlockIndex.end()) {",
          "content_same": false
        },
        {
          "line": 3748,
          "old_api": "end",
          "new_api": "std::make_pair(block.hashPrevBlock, *dbp)",
          "old_text": "mapBlockIndex.end()",
          "new_text": "std::make_pair(block.hashPrevBlock, *dbp)",
          "old_line_content": "                if (hash != chainparams.GetConsensus().hashGenesisBlock && mapBlockIndex.find(block.hashPrevBlock) == mapBlockIndex.end()) {",
          "new_line_content": "                        mapBlocksUnknownParent.insert(std::make_pair(block.hashPrevBlock, *dbp));",
          "content_same": false
        },
        {
          "line": 3758,
          "old_api": "LOCK",
          "new_api": "IsError",
          "old_text": "LOCK(cs_main)",
          "new_text": "state.IsError()",
          "old_line_content": "                    LOCK(cs_main);",
          "new_line_content": "                    if (state.IsError())",
          "content_same": false
        },
        {
          "line": 3760,
          "old_api": "AcceptBlock",
          "new_api": "GetConsensus",
          "old_text": "AcceptBlock(pblock, state, chainparams, NULL, true, dbp, NULL)",
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "                    if (AcceptBlock(pblock, state, chainparams, NULL, true, dbp, NULL))",
          "new_line_content": "                } else if (hash != chainparams.GetConsensus().hashGenesisBlock && mapBlockIndex[hash]->nHeight % 1000 == 0) {",
          "content_same": false
        },
        {
          "line": 3765,
          "old_api": "ToString",
          "new_api": "GetConsensus",
          "old_text": "hash.ToString()",
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "                    LogPrint(BCLog::REINDEX, \"Block Import: already had block %s at height %d\\n\", hash.ToString(), mapBlockIndex[hash]->nHeight);",
          "new_line_content": "                if (hash == chainparams.GetConsensus().hashGenesisBlock) {",
          "content_same": false
        },
        {
          "line": 3776,
          "old_api": "NotifyHeaderTip",
          "new_api": "push_back",
          "old_text": "NotifyHeaderTip()",
          "new_text": "queue.push_back(hash)",
          "old_line_content": "                NotifyHeaderTip();",
          "new_line_content": "                queue.push_back(hash);",
          "content_same": false
        },
        {
          "line": 3780,
          "old_api": "push_back",
          "new_api": "equal_range",
          "old_text": "queue.push_back(hash)",
          "new_text": "mapBlocksUnknownParent.equal_range(head)",
          "old_line_content": "                queue.push_back(hash);",
          "new_line_content": "                    std::pair<std::multimap<uint256, CDiskBlockPos>::iterator, std::multimap<uint256, CDiskBlockPos>::iterator> range = mapBlocksUnknownParent.equal_range(head);",
          "content_same": false
        },
        {
          "line": 3783,
          "old_api": "pop_front",
          "new_api": "std::make_shared<CBlock>()",
          "old_text": "queue.pop_front()",
          "new_text": "std::make_shared<CBlock>()",
          "old_line_content": "                    queue.pop_front();",
          "new_line_content": "                        std::shared_ptr<CBlock> pblockrecursive = std::make_shared<CBlock>();",
          "content_same": false
        },
        {
          "line": 3784,
          "old_api": "equal_range",
          "new_api": "GetConsensus",
          "old_text": "mapBlocksUnknownParent.equal_range(head)",
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "                    std::pair<std::multimap<uint256, CDiskBlockPos>::iterator, std::multimap<uint256, CDiskBlockPos>::iterator> range = mapBlocksUnknownParent.equal_range(head);",
          "new_line_content": "                        if (ReadBlockFromDisk(*pblockrecursive, it->second, chainparams.GetConsensus()))",
          "content_same": false
        },
        {
          "line": 3787,
          "old_api": "std::make_shared<CBlock>()",
          "new_api": "ToString",
          "old_text": "std::make_shared<CBlock>()",
          "new_text": "head.ToString()",
          "old_line_content": "                        std::shared_ptr<CBlock> pblockrecursive = std::make_shared<CBlock>();",
          "new_line_content": "                                    head.ToString());",
          "content_same": false
        },
        {
          "line": 3788,
          "old_api": "GetConsensus",
          "new_api": "LOCK",
          "old_text": "chainparams.GetConsensus()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "                        if (ReadBlockFromDisk(*pblockrecursive, it->second, chainparams.GetConsensus()))",
          "new_line_content": "                            LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 3790,
          "old_api": "ToString",
          "new_api": "AcceptBlock",
          "old_text": "pblockrecursive->GetHash().ToString()",
          "new_text": "AcceptBlock(pblockrecursive, dummy, chainparams, NULL, true, &it->second, NULL)",
          "old_line_content": "                            LogPrint(BCLog::REINDEX, \"%s: Processing out of order child %s of %s\\n\", __func__, pblockrecursive->GetHash().ToString(),",
          "new_line_content": "                            if (AcceptBlock(pblockrecursive, dummy, chainparams, NULL, true, &it->second, NULL))",
          "content_same": false
        },
        {
          "line": 3797,
          "old_api": "GetHash",
          "new_api": "erase",
          "old_text": "pblockrecursive->GetHash()",
          "new_text": "mapBlocksUnknownParent.erase(it)",
          "old_line_content": "                                queue.push_back(pblockrecursive->GetHash());",
          "new_line_content": "                        mapBlocksUnknownParent.erase(it);",
          "content_same": false
        },
        {
          "line": 3802,
          "old_api": "NotifyHeaderTip",
          "new_api": "what",
          "old_text": "NotifyHeaderTip()",
          "new_text": "e.what()",
          "old_line_content": "                        NotifyHeaderTip();",
          "new_line_content": "                LogPrintf(\"%s: Deserialize or I/O error - %s\\n\", __func__, e.what());",
          "content_same": false
        },
        {
          "line": 3835,
          "old_api": "end",
          "new_api": "size",
          "old_text": "mapBlockIndex.end()",
          "new_text": "mapBlockIndex.size()",
          "old_line_content": "    for (BlockMap::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); it++) {",
          "new_line_content": "    assert(forward.size() == mapBlockIndex.size());",
          "content_same": false
        },
        {
          "line": 4033,
          "old_api": "Params",
          "new_api": "IsNull",
          "old_text": "Params()",
          "new_text": "file.IsNull()",
          "old_line_content": "    const CChainParams& chainparams = Params();",
          "new_line_content": "    if (file.IsNull()) {",
          "content_same": false
        },
        {
          "line": 4034,
          "old_api": "GetArg",
          "new_api": "LogPrintf",
          "old_text": "GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY)",
          "new_text": "LogPrintf(\"Failed to open mempool file from disk. Continuing anyway.\\n\")",
          "old_line_content": "    int64_t nExpiryTimeout = GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60;",
          "new_line_content": "        LogPrintf(\"Failed to open mempool file from disk. Continuing anyway.\\n\");",
          "content_same": false
        },
        {
          "line": 4065,
          "old_api": "GetHash",
          "new_api": "LOCK",
          "old_text": "tx->GetHash()",
          "new_text": "LOCK(cs_main)",
          "old_line_content": "                mempool.PrioritiseTransaction(tx->GetHash(), amountdelta);",
          "new_line_content": "                LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 4089,
          "old_api": "what",
          "new_api": "LogPrintf",
          "old_text": "e.what()",
          "new_text": "LogPrintf(\"Imported mempool transactions from disk: %i successes, %i failed, %i expired\\n\", count, failed, skipped)",
          "old_line_content": "        LogPrintf(\"Failed to deserialize mempool data on disk: %s. Continuing anyway.\\n\", e.what());",
          "new_line_content": "    LogPrintf(\"Imported mempool transactions from disk: %i successes, %i failed, %i expired\\n\", count, failed, skipped);",
          "content_same": false
        },
        {
          "line": 4105,
          "old_api": "LOCK",
          "new_api": "infoAll",
          "old_text": "LOCK(mempool.cs)",
          "new_text": "mempool.infoAll()",
          "old_line_content": "        LOCK(mempool.cs);",
          "new_line_content": "        vinfo = mempool.infoAll();",
          "content_same": false
        },
        {
          "line": 4130,
          "old_api": "GetHash",
          "new_api": "Get",
          "old_text": "i.tx->GetHash()",
          "new_text": "file.Get()",
          "old_line_content": "            mapDeltas.erase(i.tx->GetHash());",
          "new_line_content": "        FileCommit(file.Get());",
          "content_same": false
        },
        {
          "line": 4134,
          "old_api": "Get",
          "new_api": "LogPrintf",
          "old_text": "file.Get()",
          "new_text": "LogPrintf(\"Dumped mempool: %gs to copy, %gs to dump\\n\", (mid-start)*0.000001, (last-mid)*0.000001)",
          "old_line_content": "        FileCommit(file.Get());",
          "new_line_content": "        LogPrintf(\"Dumped mempool: %gs to copy, %gs to dump\\n\", (mid-start)*0.000001, (last-mid)*0.000001);",
          "content_same": false
        },
        {
          "line": 4136,
          "old_api": "GetDataDir",
          "new_api": "what",
          "old_text": "GetDataDir()",
          "new_text": "e.what()",
          "old_line_content": "        RenameOver(GetDataDir() / \"mempool.dat.new\", GetDataDir() / \"mempool.dat\");",
          "new_line_content": "        LogPrintf(\"Failed to dump mempool: %s. Continuing anyway.\\n\", e.what());",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 4101,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(mempool.cs)",
          "old_line_content": "    std::map<uint256, CAmount> mapDeltas;",
          "new_line_content": "        LOCK(mempool.cs);",
          "content_same": false
        },
        {
          "line": 2055,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": " * The block is added to connectTrace if connection succeeds.",
          "new_line_content": "    assert(pindexNew->pprev == chainActive.Tip());",
          "content_same": false
        },
        {
          "line": 2057,
          "old_api": null,
          "new_api": "GetTimeMicros",
          "old_text": null,
          "new_text": "GetTimeMicros()",
          "old_line_content": "bool static ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool)",
          "new_line_content": "    int64_t nTime1 = GetTimeMicros();",
          "content_same": false
        },
        {
          "line": 2060,
          "old_api": null,
          "new_api": "std::make_shared<CBlock>()",
          "old_text": null,
          "new_text": "std::make_shared<CBlock>()",
          "old_line_content": "    // Read block from disk.",
          "new_line_content": "        std::shared_ptr<CBlock> pblockNew = std::make_shared<CBlock>();",
          "content_same": false
        },
        {
          "line": 4108,
          "old_api": null,
          "new_api": "GetTimeMicros",
          "old_text": null,
          "new_text": "GetTimeMicros()",
          "old_line_content": "        }",
          "new_line_content": "    int64_t mid = GetTimeMicros();",
          "content_same": false
        },
        {
          "line": 2062,
          "old_api": null,
          "new_api": "AbortNode",
          "old_text": null,
          "new_text": "AbortNode(state, \"Failed to read block\")",
          "old_line_content": "    std::shared_ptr<const CBlock> pthisBlock;",
          "new_line_content": "            return AbortNode(state, \"Failed to read block\");",
          "content_same": false
        },
        {
          "line": 4111,
          "old_api": null,
          "new_api": "GetDataDir",
          "old_text": null,
          "new_text": "GetDataDir()",
          "old_line_content": "",
          "new_line_content": "        FILE* filestr = fsbridge::fopen(GetDataDir() / \"mempool.dat.new\", \"wb\");",
          "content_same": false
        },
        {
          "line": 2069,
          "old_api": null,
          "new_api": "GetTimeMicros",
          "old_text": null,
          "new_text": "GetTimeMicros()",
          "old_line_content": "        pthisBlock = pblock;",
          "new_line_content": "    int64_t nTime2 = GetTimeMicros(); nTimeReadFromDisk += nTime2 - nTime1;",
          "content_same": false
        },
        {
          "line": 2071,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::BENCH, \"  - Load block from disk: %.2fms [%.2fs]\\n\", (nTime2 - nTime1) * 0.001, nTimeReadFromDisk * 0.000001)",
          "old_line_content": "    const CBlock& blockConnecting = *pthisBlock;",
          "new_line_content": "    LogPrint(BCLog::BENCH, \"  - Load block from disk: %.2fms [%.2fs]\\n\", (nTime2 - nTime1) * 0.001, nTimeReadFromDisk * 0.000001);",
          "content_same": false
        },
        {
          "line": 4121,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vinfo.size()",
          "old_line_content": "",
          "new_line_content": "        file << (uint64_t)vinfo.size();",
          "content_same": false
        },
        {
          "line": 2074,
          "old_api": null,
          "new_api": "ConnectBlock",
          "old_text": null,
          "new_text": "ConnectBlock(blockConnecting, state, pindexNew, view, chainparams)",
          "old_line_content": "    int64_t nTime3;",
          "new_line_content": "        bool rv = ConnectBlock(blockConnecting, state, pindexNew, view, chainparams);",
          "content_same": false
        },
        {
          "line": 2077,
          "old_api": null,
          "new_api": "IsInvalid",
          "old_text": null,
          "new_text": "state.IsInvalid()",
          "old_line_content": "        CCoinsViewCache view(pcoinsTip);",
          "new_line_content": "            if (state.IsInvalid())",
          "content_same": false
        },
        {
          "line": 4126,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "i.tx->GetHash()",
          "old_line_content": "        for (const auto& i : vinfo) {",
          "new_line_content": "            mapDeltas.erase(i.tx->GetHash());",
          "content_same": false
        },
        {
          "line": 4131,
          "old_api": null,
          "new_api": "fclose",
          "old_text": null,
          "new_text": "file.fclose()",
          "old_line_content": "        }",
          "new_line_content": "        file.fclose();",
          "content_same": false
        },
        {
          "line": 2084,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(flushed)",
          "old_line_content": "        }",
          "new_line_content": "        assert(flushed);",
          "content_same": false
        },
        {
          "line": 4132,
          "old_api": null,
          "new_api": "GetDataDir",
          "old_text": null,
          "new_text": "GetDataDir()",
          "old_line_content": "",
          "new_line_content": "        RenameOver(GetDataDir() / \"mempool.dat.new\", GetDataDir() / \"mempool.dat\");",
          "content_same": false
        },
        {
          "line": 4133,
          "old_api": null,
          "new_api": "GetTimeMicros",
          "old_text": null,
          "new_text": "GetTimeMicros()",
          "old_line_content": "        file << mapDeltas;",
          "new_line_content": "        int64_t last = GetTimeMicros();",
          "content_same": false
        },
        {
          "line": 2089,
          "old_api": null,
          "new_api": "FlushStateToDisk",
          "old_text": null,
          "new_text": "FlushStateToDisk(chainparams, state, FLUSH_STATE_IF_NEEDED)",
          "old_line_content": "    }",
          "new_line_content": "    if (!FlushStateToDisk(chainparams, state, FLUSH_STATE_IF_NEEDED))",
          "content_same": false
        },
        {
          "line": 2092,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::BENCH, \"  - Writing chainstate: %.2fms [%.2fs]\\n\", (nTime5 - nTime4) * 0.001, nTimeChainState * 0.000001)",
          "old_line_content": "    // Write the chain state to disk, if necessary.",
          "new_line_content": "    LogPrint(BCLog::BENCH, \"  - Writing chainstate: %.2fms [%.2fs]\\n\", (nTime5 - nTime4) * 0.001, nTimeChainState * 0.000001);",
          "content_same": false
        },
        {
          "line": 2094,
          "old_api": null,
          "new_api": "removeForBlock",
          "old_text": null,
          "new_text": "mempool.removeForBlock(blockConnecting.vtx, pindexNew->nHeight)",
          "old_line_content": "        return false;",
          "new_line_content": "    mempool.removeForBlock(blockConnecting.vtx, pindexNew->nHeight);",
          "content_same": false
        },
        {
          "line": 2097,
          "old_api": null,
          "new_api": "UpdateTip",
          "old_text": null,
          "new_text": "UpdateTip(pindexNew, chainparams)",
          "old_line_content": "    // Remove conflicting transactions from the mempool.;",
          "new_line_content": "    UpdateTip(pindexNew, chainparams);",
          "content_same": false
        },
        {
          "line": 4145,
          "old_api": null,
          "new_api": "time",
          "old_text": null,
          "new_text": "time(NULL)",
          "old_line_content": "double GuessVerificationProgress(const ChainTxData& data, CBlockIndex *pindex) {",
          "new_line_content": "    int64_t nNow = time(NULL);",
          "content_same": false
        },
        {
          "line": 2100,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::BENCH, \"  - Connect postprocess: %.2fms [%.2fs]\\n\", (nTime6 - nTime5) * 0.001, nTimePostConnect * 0.000001)",
          "old_line_content": "    // Update chainActive & related variables.",
          "new_line_content": "    LogPrint(BCLog::BENCH, \"  - Connect postprocess: %.2fms [%.2fs]\\n\", (nTime6 - nTime5) * 0.001, nTimePostConnect * 0.000001);",
          "content_same": false
        },
        {
          "line": 4152,
          "old_api": null,
          "new_api": "GetBlockTime",
          "old_text": null,
          "new_text": "pindex->GetBlockTime()",
          "old_line_content": "",
          "new_line_content": "        fTxTotal = pindex->nChainTx + (nNow - pindex->GetBlockTime()) * data.dTxRate;",
          "content_same": false
        },
        {
          "line": 4164,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "mapBlockIndex.begin()",
          "old_line_content": "public:",
          "new_line_content": "        BlockMap::iterator it1 = mapBlockIndex.begin();",
          "content_same": false
        },
        {
          "line": 2117,
          "old_api": null,
          "new_api": "rbegin",
          "old_text": null,
          "new_text": "setBlockIndexCandidates.rbegin()",
          "old_line_content": "        CBlockIndex *pindexNew = NULL;",
          "new_line_content": "            std::set<CBlockIndex*, CBlockIndexWorkComparator>::reverse_iterator it = setBlockIndexCandidates.rbegin();",
          "content_same": false
        },
        {
          "line": 2118,
          "old_api": null,
          "new_api": "rend",
          "old_text": null,
          "new_text": "setBlockIndexCandidates.rend()",
          "old_line_content": "",
          "new_line_content": "            if (it == setBlockIndexCandidates.rend())",
          "content_same": false
        },
        {
          "line": 4165,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapBlockIndex.end()",
          "old_line_content": "    CMainCleanup() {}",
          "new_line_content": "        for (; it1 != mapBlockIndex.end(); it1++)",
          "content_same": false
        },
        {
          "line": 4167,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "mapBlockIndex.clear()",
          "old_line_content": "        // block headers",
          "new_line_content": "        mapBlockIndex.clear();",
          "content_same": false
        },
        {
          "line": 2127,
          "old_api": null,
          "new_api": "Contains",
          "old_text": null,
          "new_text": "chainActive.Contains(pindexTest)",
          "old_line_content": "        // Check whether all blocks on the path between the currently active chain and the candidate are valid.",
          "new_line_content": "        while (pindexTest && !chainActive.Contains(pindexTest)) {",
          "content_same": false
        },
        {
          "line": 2128,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(pindexTest->nChainTx || pindexTest->nHeight == 0)",
          "old_line_content": "        // Just going until the active chain is an optimization, as we know all blocks in it are valid already.",
          "new_line_content": "            assert(pindexTest->nChainTx || pindexTest->nHeight == 0);",
          "content_same": false
        },
        {
          "line": 2149,
          "old_api": null,
          "new_api": "std::make_pair(pindexFailed->pprev, pindexFailed)",
          "old_text": null,
          "new_text": "std::make_pair(pindexFailed->pprev, pindexFailed)",
          "old_line_content": "                    } else if (fMissingData) {",
          "new_line_content": "                        mapBlocksUnlinked.insert(std::make_pair(pindexFailed->pprev, pindexFailed));",
          "content_same": false
        },
        {
          "line": 2151,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "setBlockIndexCandidates.erase(pindexFailed)",
          "old_line_content": "                        // so that if the block arrives in the future we can try adding",
          "new_line_content": "                    setBlockIndexCandidates.erase(pindexFailed);",
          "content_same": false
        },
        {
          "line": 2154,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "setBlockIndexCandidates.erase(pindexTest)",
          "old_line_content": "                    }",
          "new_line_content": "                setBlockIndexCandidates.erase(pindexTest);",
          "content_same": false
        },
        {
          "line": 2169,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "setBlockIndexCandidates.begin()",
          "old_line_content": "/** Delete all entries in setBlockIndexCandidates that are worse than the current tip. */",
          "new_line_content": "    std::set<CBlockIndex*, CBlockIndexWorkComparator>::iterator it = setBlockIndexCandidates.begin();",
          "content_same": false
        },
        {
          "line": 2170,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "static void PruneBlockIndexCandidates() {",
          "new_line_content": "    while (it != setBlockIndexCandidates.end() && setBlockIndexCandidates.value_comp()(*it, chainActive.Tip())) {",
          "content_same": false
        },
        {
          "line": 2171,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "setBlockIndexCandidates.erase(it++)",
          "old_line_content": "    // Note that we can't delete the current block itself, as we may need to return to it later in case a",
          "new_line_content": "        setBlockIndexCandidates.erase(it++);",
          "content_same": false
        },
        {
          "line": 2183,
          "old_api": null,
          "new_api": "AssertLockHeld",
          "old_text": null,
          "new_text": "AssertLockHeld(cs_main)",
          "old_line_content": " * pblock is either NULL or a pointer to a CBlock corresponding to pindexMostWork.",
          "new_line_content": "    AssertLockHeld(cs_main);",
          "content_same": false
        },
        {
          "line": 2184,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": " */",
          "new_line_content": "    const CBlockIndex *pindexOldTip = chainActive.Tip();",
          "content_same": false
        },
        {
          "line": 2185,
          "old_api": null,
          "new_api": "FindFork",
          "old_text": null,
          "new_text": "chainActive.FindFork(pindexMostWork)",
          "old_line_content": "static bool ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace)",
          "new_line_content": "    const CBlockIndex *pindexFork = chainActive.FindFork(pindexMostWork);",
          "content_same": false
        },
        {
          "line": 2190,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "",
          "new_line_content": "    while (chainActive.Tip() && chainActive.Tip() != pindexFork) {",
          "content_same": false
        },
        {
          "line": 2191,
          "old_api": null,
          "new_api": "DisconnectTip",
          "old_text": null,
          "new_text": "DisconnectTip(state, chainparams, &disconnectpool)",
          "old_line_content": "    // Disconnect active blocks which are no longer in the best chain.",
          "new_line_content": "        if (!DisconnectTip(state, chainparams, &disconnectpool)) {",
          "content_same": false
        },
        {
          "line": 2207,
          "old_api": null,
          "new_api": "std::min(nHeight + 32, pindexMostWork->nHeight)",
          "old_text": null,
          "new_text": "std::min(nHeight + 32, pindexMostWork->nHeight)",
          "old_line_content": "    int nHeight = pindexFork ? pindexFork->nHeight : -1;",
          "new_line_content": "        int nTargetHeight = std::min(nHeight + 32, pindexMostWork->nHeight);",
          "content_same": false
        },
        {
          "line": 2208,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "vpindexToConnect.clear()",
          "old_line_content": "    while (fContinue && nHeight != pindexMostWork->nHeight) {",
          "new_line_content": "        vpindexToConnect.clear();",
          "content_same": false
        },
        {
          "line": 2209,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "vpindexToConnect.reserve(nTargetHeight - nHeight)",
          "old_line_content": "        // Don't iterate the entire list of potential improvements toward the best tip, as we likely only need",
          "new_line_content": "        vpindexToConnect.reserve(nTargetHeight - nHeight);",
          "content_same": false
        },
        {
          "line": 2210,
          "old_api": null,
          "new_api": "GetAncestor",
          "old_text": null,
          "new_text": "pindexMostWork->GetAncestor(nTargetHeight)",
          "old_line_content": "        // a few blocks along the way.",
          "new_line_content": "        CBlockIndex *pindexIter = pindexMostWork->GetAncestor(nTargetHeight);",
          "content_same": false
        },
        {
          "line": 2219,
          "old_api": null,
          "new_api": "std::shared_ptr<const CBlock>()",
          "old_text": null,
          "new_text": "std::shared_ptr<const CBlock>()",
          "old_line_content": "        nHeight = nTargetHeight;",
          "new_line_content": "            if (!ConnectTip(state, chainparams, pindexConnect, pindexConnect == pindexMostWork ? pblock : std::shared_ptr<const CBlock>(), connectTrace, disconnectpool)) {",
          "content_same": false
        },
        {
          "line": 2220,
          "old_api": null,
          "new_api": "IsInvalid",
          "old_text": null,
          "new_text": "state.IsInvalid()",
          "old_line_content": "",
          "new_line_content": "                if (state.IsInvalid()) {",
          "content_same": false
        },
        {
          "line": 2222,
          "old_api": null,
          "new_api": "CorruptionPossible",
          "old_text": null,
          "new_text": "state.CorruptionPossible()",
          "old_line_content": "        BOOST_REVERSE_FOREACH(CBlockIndex *pindexConnect, vpindexToConnect) {",
          "new_line_content": "                    if (!state.CorruptionPossible())",
          "content_same": false
        },
        {
          "line": 2232,
          "old_api": null,
          "new_api": "UpdateMempoolForReorg",
          "old_text": null,
          "new_text": "UpdateMempoolForReorg(disconnectpool, false)",
          "old_line_content": "                } else {",
          "new_line_content": "                    UpdateMempoolForReorg(disconnectpool, false);",
          "content_same": false
        },
        {
          "line": 2237,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "                    return false;",
          "new_line_content": "                if (!pindexOldTip || chainActive.Tip()->nChainWork > pindexOldTip->nChainWork) {",
          "content_same": false
        },
        {
          "line": 2249,
          "old_api": null,
          "new_api": "UpdateMempoolForReorg",
          "old_text": null,
          "new_text": "UpdateMempoolForReorg(disconnectpool, true)",
          "old_line_content": "",
          "new_line_content": "        UpdateMempoolForReorg(disconnectpool, true);",
          "content_same": false
        },
        {
          "line": 2251,
          "old_api": null,
          "new_api": "check",
          "old_text": null,
          "new_text": "mempool.check(pcoinsTip)",
          "old_line_content": "        // If any blocks were disconnected, disconnectpool may be non empty.  Add",
          "new_line_content": "    mempool.check(pcoinsTip);",
          "content_same": false
        },
        {
          "line": 2257,
          "old_api": null,
          "new_api": "CheckForkWarningConditions",
          "old_text": null,
          "new_text": "CheckForkWarningConditions()",
          "old_line_content": "    // Callbacks/notifications for a new best chain.",
          "new_line_content": "        CheckForkWarningConditions();",
          "content_same": false
        },
        {
          "line": 2268,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "    bool fInitialBlockDownload = false;",
          "new_line_content": "        LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2273,
          "old_api": null,
          "new_api": "IsInitialBlockDownload",
          "old_text": null,
          "new_text": "IsInitialBlockDownload()",
          "old_line_content": "        pindexHeader = pindexBestHeader;",
          "new_line_content": "            fInitialBlockDownload = IsInitialBlockDownload();",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": null,
          "new_api": "NotifyHeaderTip",
          "old_text": null,
          "new_text": "uiInterface.NotifyHeaderTip(fInitialBlockDownload, pindexHeader)",
          "old_line_content": "        }",
          "new_line_content": "        uiInterface.NotifyHeaderTip(fInitialBlockDownload, pindexHeader);",
          "content_same": false
        },
        {
          "line": 2296,
          "old_api": null,
          "new_api": "GetArg",
          "old_text": null,
          "new_text": "GetArg(\"-stopatheight\", DEFAULT_STOPATHEIGHT)",
          "old_line_content": "    // sanely for performance or correctness!",
          "new_line_content": "    int nStopAtHeight = GetArg(\"-stopatheight\", DEFAULT_STOPATHEIGHT);",
          "content_same": false
        },
        {
          "line": 2298,
          "old_api": null,
          "new_api": "boost::this_thread::interruption_point()",
          "old_text": null,
          "new_text": "boost::this_thread::interruption_point()",
          "old_line_content": "    CBlockIndex *pindexMostWork = NULL;",
          "new_line_content": "        boost::this_thread::interruption_point();",
          "content_same": false
        },
        {
          "line": 2299,
          "old_api": null,
          "new_api": "ShutdownRequested",
          "old_text": null,
          "new_text": "ShutdownRequested()",
          "old_line_content": "    CBlockIndex *pindexNewTip = NULL;",
          "new_line_content": "        if (ShutdownRequested())",
          "content_same": false
        },
        {
          "line": 2305,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "",
          "new_line_content": "            LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2308,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "        {",
          "new_line_content": "            CBlockIndex *pindexOldTip = chainActive.Tip();",
          "content_same": false
        },
        {
          "line": 2310,
          "old_api": null,
          "new_api": "FindMostWorkChain",
          "old_text": null,
          "new_text": "FindMostWorkChain()",
          "old_line_content": "            ConnectTrace connectTrace(mempool); // Destructed before cs_main is unlocked",
          "new_line_content": "                pindexMostWork = FindMostWorkChain();",
          "content_same": false
        },
        {
          "line": 2319,
          "old_api": null,
          "new_api": "GetBlockHash",
          "old_text": null,
          "new_text": "pindexMostWork->GetBlockHash()",
          "old_line_content": "                return true;",
          "new_line_content": "            if (!ActivateBestChainStep(state, chainparams, pindexMostWork, pblock && pblock->GetHash() == pindexMostWork->GetBlockHash() ? pblock : nullBlockPtr, fInvalidFound, connectTrace))",
          "content_same": false
        },
        {
          "line": 2326,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "            if (fInvalidFound) {",
          "new_line_content": "            pindexNewTip = chainActive.Tip();",
          "content_same": false
        },
        {
          "line": 2327,
          "old_api": null,
          "new_api": "FindFork",
          "old_text": null,
          "new_text": "chainActive.FindFork(pindexOldTip)",
          "old_line_content": "                // Wipe cache, we may need another branch now.",
          "new_line_content": "            pindexFork = chainActive.FindFork(pindexOldTip);",
          "content_same": false
        },
        {
          "line": 2328,
          "old_api": null,
          "new_api": "IsInitialBlockDownload",
          "old_text": null,
          "new_text": "IsInitialBlockDownload()",
          "old_line_content": "                pindexMostWork = NULL;",
          "new_line_content": "            fInitialDownload = IsInitialBlockDownload();",
          "content_same": false
        },
        {
          "line": 2340,
          "old_api": null,
          "new_api": "UpdatedBlockTip",
          "old_text": null,
          "new_text": "GetMainSignals().UpdatedBlockTip(pindexNewTip, pindexFork, fInitialDownload)",
          "old_line_content": "",
          "new_line_content": "        GetMainSignals().UpdatedBlockTip(pindexNewTip, pindexFork, fInitialDownload);",
          "content_same": false
        },
        {
          "line": 2347,
          "old_api": null,
          "new_api": "StartShutdown",
          "old_text": null,
          "new_text": "StartShutdown()",
          "old_line_content": "        if (pindexFork != pindexNewTip) {",
          "new_line_content": "        if (nStopAtHeight && pindexNewTip && pindexNewTip->nHeight >= nStopAtHeight) StartShutdown();",
          "content_same": false
        },
        {
          "line": 2349,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "        }",
          "new_line_content": "    CheckBlockIndex(chainparams.GetConsensus());",
          "content_same": false
        },
        {
          "line": 2352,
          "old_api": null,
          "new_api": "FlushStateToDisk",
          "old_text": null,
          "new_text": "FlushStateToDisk(chainparams, state, FLUSH_STATE_PERIODIC)",
          "old_line_content": "    } while (pindexNewTip != pindexMostWork);",
          "new_line_content": "    if (!FlushStateToDisk(chainparams, state, FLUSH_STATE_PERIODIC)) {",
          "content_same": false
        },
        {
          "line": 2363,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "",
          "new_line_content": "        LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2364,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "bool PreciousBlock(CValidationState& state, const CChainParams& params, CBlockIndex *pindex)",
          "new_line_content": "        if (pindex->nChainWork < chainActive.Tip()->nChainWork) {",
          "content_same": false
        },
        {
          "line": 2373,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "setBlockIndexCandidates.erase(pindex)",
          "old_line_content": "            // The chain has been extended since the last call, reset the counter.",
          "new_line_content": "        setBlockIndexCandidates.erase(pindex);",
          "content_same": false
        },
        {
          "line": 2375,
          "old_api": null,
          "new_api": "std::numeric_limits<int32_t>::min()",
          "old_text": null,
          "new_text": "std::numeric_limits<int32_t>::min()",
          "old_line_content": "        }",
          "new_line_content": "        if (nBlockReverseSequenceId > std::numeric_limits<int32_t>::min()) {",
          "content_same": false
        },
        {
          "line": 2380,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "pindex->IsValid(BLOCK_VALID_TRANSACTIONS)",
          "old_line_content": "            // We can't keep reducing the counter if somebody really wants to",
          "new_line_content": "        if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && pindex->nChainTx) {",
          "content_same": false
        },
        {
          "line": 2381,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "setBlockIndexCandidates.insert(pindex)",
          "old_line_content": "            // call preciousblock 2**31-1 times on the same set of tips...",
          "new_line_content": "            setBlockIndexCandidates.insert(pindex);",
          "content_same": false
        },
        {
          "line": 2382,
          "old_api": null,
          "new_api": "PruneBlockIndexCandidates",
          "old_text": null,
          "new_text": "PruneBlockIndexCandidates()",
          "old_line_content": "            nBlockReverseSequenceId--;",
          "new_line_content": "            PruneBlockIndexCandidates();",
          "content_same": false
        },
        {
          "line": 2391,
          "old_api": null,
          "new_api": "AssertLockHeld",
          "old_text": null,
          "new_text": "AssertLockHeld(cs_main)",
          "old_line_content": "}",
          "new_line_content": "    AssertLockHeld(cs_main);",
          "content_same": false
        },
        {
          "line": 2396,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "setBlockIndexCandidates.erase(pindex)",
          "old_line_content": "",
          "new_line_content": "    setBlockIndexCandidates.erase(pindex);",
          "content_same": false
        },
        {
          "line": 2402,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "setDirtyBlockIndex.insert(pindexWalk)",
          "old_line_content": "    DisconnectedBlockTransactions disconnectpool;",
          "new_line_content": "        setDirtyBlockIndex.insert(pindexWalk);",
          "content_same": false
        },
        {
          "line": 2409,
          "old_api": null,
          "new_api": "UpdateMempoolForReorg",
          "old_text": null,
          "new_text": "UpdateMempoolForReorg(disconnectpool, false)",
          "old_line_content": "        // unconditionally valid already, so force disconnect away from it.",
          "new_line_content": "            UpdateMempoolForReorg(disconnectpool, false);",
          "content_same": false
        },
        {
          "line": 2416,
          "old_api": null,
          "new_api": "UpdateMempoolForReorg",
          "old_text": null,
          "new_text": "UpdateMempoolForReorg(disconnectpool, true)",
          "old_line_content": "    }",
          "new_line_content": "    UpdateMempoolForReorg(disconnectpool, true);",
          "content_same": false
        },
        {
          "line": 2421,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapBlockIndex.end()",
          "old_line_content": "",
          "new_line_content": "    while (it != mapBlockIndex.end()) {",
          "content_same": false
        },
        {
          "line": 2422,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "    // The resulting new best tip may not be in setBlockIndexCandidates anymore, so",
          "new_line_content": "        if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->nChainTx && !setBlockIndexCandidates.value_comp()(it->second, chainActive.Tip())) {",
          "content_same": false
        },
        {
          "line": 2423,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "setBlockIndexCandidates.insert(it->second)",
          "old_line_content": "    // add it again.",
          "new_line_content": "            setBlockIndexCandidates.insert(it->second);",
          "content_same": false
        },
        {
          "line": 2428,
          "old_api": null,
          "new_api": "InvalidChainFound",
          "old_text": null,
          "new_text": "InvalidChainFound(pindex)",
          "old_line_content": "        }",
          "new_line_content": "    InvalidChainFound(pindex);",
          "content_same": false
        },
        {
          "line": 2429,
          "old_api": null,
          "new_api": "IsInitialBlockDownload",
          "old_text": null,
          "new_text": "IsInitialBlockDownload()",
          "old_line_content": "        it++;",
          "new_line_content": "    uiInterface.NotifyBlockTip(IsInitialBlockDownload(), pindex->pprev);",
          "content_same": false
        },
        {
          "line": 2434,
          "old_api": null,
          "new_api": "AssertLockHeld",
          "old_text": null,
          "new_text": "AssertLockHeld(cs_main)",
          "old_line_content": "    return true;",
          "new_line_content": "    AssertLockHeld(cs_main);",
          "content_same": false
        },
        {
          "line": 2439,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "mapBlockIndex.begin()",
          "old_line_content": "",
          "new_line_content": "    BlockMap::iterator it = mapBlockIndex.begin();",
          "content_same": false
        },
        {
          "line": 2440,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapBlockIndex.end()",
          "old_line_content": "    int nHeight = pindex->nHeight;",
          "new_line_content": "    while (it != mapBlockIndex.end()) {",
          "content_same": false
        },
        {
          "line": 2441,
          "old_api": null,
          "new_api": "GetAncestor",
          "old_text": null,
          "new_text": "it->second->GetAncestor(nHeight)",
          "old_line_content": "",
          "new_line_content": "        if (!it->second->IsValid() && it->second->GetAncestor(nHeight) == pindex) {",
          "content_same": false
        },
        {
          "line": 2459,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "setDirtyBlockIndex.insert(pindex)",
          "old_line_content": "    // Remove the invalidity flag from all ancestors too.",
          "new_line_content": "            setDirtyBlockIndex.insert(pindex);",
          "content_same": false
        },
        {
          "line": 2469,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "block.GetHash()",
          "old_line_content": "",
          "new_line_content": "    uint256 hash = block.GetHash();",
          "content_same": false
        },
        {
          "line": 2470,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "mapBlockIndex.find(hash)",
          "old_line_content": "static CBlockIndex* AddToBlockIndex(const CBlockHeader& block)",
          "new_line_content": "    BlockMap::iterator it = mapBlockIndex.find(hash);",
          "content_same": false
        },
        {
          "line": 2471,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapBlockIndex.end()",
          "old_line_content": "{",
          "new_line_content": "    if (it != mapBlockIndex.end())",
          "content_same": false
        },
        {
          "line": 2476,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(pindexNew)",
          "old_line_content": "        return it->second;",
          "new_line_content": "    assert(pindexNew);",
          "content_same": false
        },
        {
          "line": 2481,
          "old_api": null,
          "new_api": "std::make_pair(hash, pindexNew)",
          "old_text": null,
          "new_text": "std::make_pair(hash, pindexNew)",
          "old_line_content": "    // We assign the sequence id to blocks only when the full data is available,",
          "new_line_content": "    BlockMap::iterator mi = mapBlockIndex.insert(std::make_pair(hash, pindexNew)).first;",
          "content_same": false
        },
        {
          "line": 2483,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "mapBlockIndex.find(block.hashPrevBlock)",
          "old_line_content": "    // competitive advantage.",
          "new_line_content": "    BlockMap::iterator miPrev = mapBlockIndex.find(block.hashPrevBlock);",
          "content_same": false
        },
        {
          "line": 2484,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapBlockIndex.end()",
          "old_line_content": "    pindexNew->nSequenceId = 0;",
          "new_line_content": "    if (miPrev != mapBlockIndex.end())",
          "content_same": false
        },
        {
          "line": 2490,
          "old_api": null,
          "new_api": "std::max(pindexNew->pprev->nTimeMax, pindexNew->nTime)",
          "old_text": null,
          "new_text": "std::max(pindexNew->pprev->nTimeMax, pindexNew->nTime)",
          "old_line_content": "        pindexNew->pprev = (*miPrev).second;",
          "new_line_content": "    pindexNew->nTimeMax = (pindexNew->pprev ? std::max(pindexNew->pprev->nTimeMax, pindexNew->nTime) : pindexNew->nTime);",
          "content_same": false
        },
        {
          "line": 2491,
          "old_api": null,
          "new_api": "GetBlockProof",
          "old_text": null,
          "new_text": "GetBlockProof(*pindexNew)",
          "old_line_content": "        pindexNew->nHeight = pindexNew->pprev->nHeight + 1;",
          "new_line_content": "    pindexNew->nChainWork = (pindexNew->pprev ? pindexNew->pprev->nChainWork : 0) + GetBlockProof(*pindexNew);",
          "content_same": false
        },
        {
          "line": 2504,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "block.vtx.size()",
          "old_line_content": "",
          "new_line_content": "    pindexNew->nTx = block.vtx.size();",
          "content_same": false
        },
        {
          "line": 2510,
          "old_api": null,
          "new_api": "IsWitnessEnabled",
          "old_text": null,
          "new_text": "IsWitnessEnabled(pindexNew->pprev, consensusParams)",
          "old_line_content": "    pindexNew->nFile = pos.nFile;",
          "new_line_content": "    if (IsWitnessEnabled(pindexNew->pprev, consensusParams)) {",
          "content_same": false
        },
        {
          "line": 2513,
          "old_api": null,
          "new_api": "RaiseValidity",
          "old_text": null,
          "new_text": "pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS)",
          "old_line_content": "    pindexNew->nStatus |= BLOCK_HAVE_DATA;",
          "new_line_content": "    pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS);",
          "content_same": false
        },
        {
          "line": 2519,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "queue.push_back(pindexNew)",
          "old_line_content": "",
          "new_line_content": "        queue.push_back(pindexNew);",
          "content_same": false
        },
        {
          "line": 2522,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "queue.empty()",
          "old_line_content": "        std::deque<CBlockIndex*> queue;",
          "new_line_content": "        while (!queue.empty()) {",
          "content_same": false
        },
        {
          "line": 2524,
          "old_api": null,
          "new_api": "pop_front",
          "old_text": null,
          "new_text": "queue.pop_front()",
          "old_line_content": "",
          "new_line_content": "            queue.pop_front();",
          "content_same": false
        },
        {
          "line": 2530,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "            {",
          "new_line_content": "            if (chainActive.Tip() == NULL || !setBlockIndexCandidates.value_comp()(pindex, chainActive.Tip())) {",
          "content_same": false
        },
        {
          "line": 2533,
          "old_api": null,
          "new_api": "equal_range",
          "old_text": null,
          "new_text": "mapBlocksUnlinked.equal_range(pindex)",
          "old_line_content": "            }",
          "new_line_content": "            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex);",
          "content_same": false
        },
        {
          "line": 2536,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "queue.push_back(it->second)",
          "old_line_content": "            }",
          "new_line_content": "                queue.push_back(it->second);",
          "content_same": false
        },
        {
          "line": 2538,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "mapBlocksUnlinked.erase(it)",
          "old_line_content": "            while (range.first != range.second) {",
          "new_line_content": "                mapBlocksUnlinked.erase(it);",
          "content_same": false
        },
        {
          "line": 2543,
          "old_api": null,
          "new_api": "std::make_pair(pindexNew->pprev, pindexNew)",
          "old_text": null,
          "new_text": "std::make_pair(pindexNew->pprev, pindexNew)",
          "old_line_content": "            }",
          "new_line_content": "            mapBlocksUnlinked.insert(std::make_pair(pindexNew->pprev, pindexNew));",
          "content_same": false
        },
        {
          "line": 496,
          "old_api": null,
          "new_api": "HaveCoinInCache",
          "old_text": null,
          "new_text": "pcoinsTip->HaveCoinInCache(txin.prevout)",
          "old_line_content": "            COutPoint outpoint(hash, out);",
          "new_line_content": "            if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": null,
          "new_api": "HaveCoin",
          "old_text": null,
          "new_text": "view.HaveCoin(txin.prevout)",
          "old_line_content": "                if (!had_coin_in_cache) {",
          "new_line_content": "            if (!view.HaveCoin(txin.prevout)) {",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "tx.vout.size()",
          "old_line_content": "                }",
          "new_line_content": "                for (size_t out = 0; out < tx.vout.size(); out++) {",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": null,
          "new_api": "COutPoint",
          "old_text": null,
          "new_text": "COutPoint(hash, out)",
          "old_line_content": "            }",
          "new_line_content": "                    if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {",
          "content_same": false
        },
        {
          "line": 2552,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_LastBlockFile)",
          "old_line_content": "}",
          "new_line_content": "    LOCK(cs_LastBlockFile);",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": null,
          "new_api": "Invalid",
          "old_text": null,
          "new_text": "state.Invalid(false, REJECT_DUPLICATE, \"txn-already-known\")",
          "old_line_content": "        }",
          "new_line_content": "                        return state.Invalid(false, REJECT_DUPLICATE, \"txn-already-known\");",
          "content_same": false
        },
        {
          "line": 2555,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vinfoBlockFile.size()",
          "old_line_content": "{",
          "new_line_content": "    if (vinfoBlockFile.size() <= nFile) {",
          "content_same": false
        },
        {
          "line": 2562,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vinfoBlockFile.size()",
          "old_line_content": "",
          "new_line_content": "            if (vinfoBlockFile.size() <= nFile) {",
          "content_same": false
        },
        {
          "line": 2563,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "vinfoBlockFile.resize(nFile + 1)",
          "old_line_content": "    if (!fKnown) {",
          "new_line_content": "                vinfoBlockFile.resize(nFile + 1);",
          "content_same": false
        },
        {
          "line": 516,
          "old_api": null,
          "new_api": "GetBestBlock",
          "old_text": null,
          "new_text": "view.GetBestBlock()",
          "old_line_content": "            }",
          "new_line_content": "        view.GetBestBlock();",
          "content_same": false
        },
        {
          "line": 518,
          "old_api": null,
          "new_api": "GetValueIn",
          "old_text": null,
          "new_text": "view.GetValueIn(tx)",
          "old_line_content": "",
          "new_line_content": "        nValueIn = view.GetValueIn(tx);",
          "content_same": false
        },
        {
          "line": 521,
          "old_api": null,
          "new_api": "SetBackend",
          "old_text": null,
          "new_text": "view.SetBackend(dummy)",
          "old_line_content": "",
          "new_line_content": "        view.SetBackend(dummy);",
          "content_same": false
        },
        {
          "line": 2572,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "vinfoBlockFile[nLastBlockFile].ToString()",
          "old_line_content": "    }",
          "new_line_content": "            LogPrintf(\"Leaving block file %i: %s\\n\", nLastBlockFile, vinfoBlockFile[nLastBlockFile].ToString());",
          "content_same": false
        },
        {
          "line": 2574,
          "old_api": null,
          "new_api": "FlushBlockFile",
          "old_text": null,
          "new_text": "FlushBlockFile(!fKnown)",
          "old_line_content": "    if ((int)nFile != nLastBlockFile) {",
          "new_line_content": "        FlushBlockFile(!fKnown);",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": null,
          "new_api": "CheckSequenceLocks",
          "old_text": null,
          "new_text": "CheckSequenceLocks(tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp)",
          "old_line_content": "        // block; we don't want our mempool filled up with transactions that can't",
          "new_line_content": "        if (!CheckSequenceLocks(tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": null,
          "new_api": "DoS",
          "old_text": null,
          "new_text": "state.DoS(0, false, REJECT_NONSTANDARD, \"non-BIP68-final\")",
          "old_line_content": "        // be mined yet.",
          "new_line_content": "            return state.DoS(0, false, REJECT_NONSTANDARD, \"non-BIP68-final\");",
          "content_same": false
        },
        {
          "line": 2580,
          "old_api": null,
          "new_api": "std::max(pos.nPos + nAddSize, vinfoBlockFile[nFile].nSize)",
          "old_text": null,
          "new_text": "std::max(pos.nPos + nAddSize, vinfoBlockFile[nFile].nSize)",
          "old_line_content": "    }",
          "new_line_content": "        vinfoBlockFile[nFile].nSize = std::max(pos.nPos + nAddSize, vinfoBlockFile[nFile].nSize);",
          "content_same": false
        },
        {
          "line": 534,
          "old_api": null,
          "new_api": "Invalid",
          "old_text": null,
          "new_text": "state.Invalid(false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\")",
          "old_line_content": "        }",
          "new_line_content": "            return state.Invalid(false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": null,
          "new_api": "GetTransactionSigOpCost",
          "old_text": null,
          "new_text": "GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS)",
          "old_line_content": "        // Check for non-standard witness in P2WSH",
          "new_line_content": "        int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);",
          "content_same": false
        },
        {
          "line": 2590,
          "old_api": null,
          "new_api": "CheckDiskSpace",
          "old_text": null,
          "new_text": "CheckDiskSpace(nNewChunks * BLOCKFILE_CHUNK_SIZE - pos.nPos)",
          "old_line_content": "        unsigned int nNewChunks = (vinfoBlockFile[nFile].nSize + BLOCKFILE_CHUNK_SIZE - 1) / BLOCKFILE_CHUNK_SIZE;",
          "new_line_content": "            if (CheckDiskSpace(nNewChunks * BLOCKFILE_CHUNK_SIZE - pos.nPos)) {",
          "content_same": false
        },
        {
          "line": 2591,
          "old_api": null,
          "new_api": "OpenBlockFile",
          "old_text": null,
          "new_text": "OpenBlockFile(pos)",
          "old_line_content": "        if (nNewChunks > nOldChunks) {",
          "new_line_content": "                FILE *file = OpenBlockFile(pos);",
          "content_same": false
        },
        {
          "line": 2593,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"Pre-allocating up to position 0x%x in blk%05u.dat\\n\", nNewChunks * BLOCKFILE_CHUNK_SIZE, pos.nFile)",
          "old_line_content": "                fCheckForPruning = true;",
          "new_line_content": "                    LogPrintf(\"Pre-allocating up to position 0x%x in blk%05u.dat\\n\", nNewChunks * BLOCKFILE_CHUNK_SIZE, pos.nFile);",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": null,
          "new_api": "AccessCoin",
          "old_text": null,
          "new_text": "view.AccessCoin(txin.prevout)",
          "old_line_content": "        // Keep track of transactions that spend a coinbase, which we re-scan",
          "new_line_content": "            const Coin &coin = view.AccessCoin(txin.prevout);",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": null,
          "new_api": "IsCoinBase",
          "old_text": null,
          "new_text": "coin.IsCoinBase()",
          "old_line_content": "        // during reorgs to ensure COINBASE_MATURITY is still met.",
          "new_line_content": "            if (coin.IsCoinBase()) {",
          "content_same": false
        },
        {
          "line": 559,
          "old_api": null,
          "new_api": "Height",
          "old_text": null,
          "new_text": "chainActive.Height()",
          "old_line_content": "                break;",
          "new_line_content": "        CTxMemPoolEntry entry(ptx, nFees, nAcceptTime, chainActive.Height(),",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": null,
          "new_api": "GetTxSize",
          "old_text": null,
          "new_text": "entry.GetTxSize()",
          "old_line_content": "        }",
          "new_line_content": "        unsigned int nSize = entry.GetTxSize();",
          "content_same": false
        },
        {
          "line": 2611,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_LastBlockFile)",
          "old_line_content": "static bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigned int nAddSize)",
          "new_line_content": "    LOCK(cs_LastBlockFile);",
          "content_same": false
        },
        {
          "line": 2616,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "setDirtyFileInfo.insert(nFile)",
          "old_line_content": "",
          "new_line_content": "    setDirtyFileInfo.insert(nFile);",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": null,
          "new_api": "DoS",
          "old_text": null,
          "new_text": "state.DoS(0, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n                strprintf(\"%d\", nSigOpsCost))",
          "old_line_content": "        // itself can contain sigops MAX_STANDARD_TX_SIGOPS is less than",
          "new_line_content": "            return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": null,
          "new_api": "strprintf",
          "old_text": null,
          "new_text": "strprintf(\"%d\", nSigOpsCost)",
          "old_line_content": "        // MAX_BLOCK_SIGOPS; we still consider this an invalid rather than",
          "new_line_content": "                strprintf(\"%d\", nSigOpsCost));",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": null,
          "new_api": "GetArg",
          "old_text": null,
          "new_text": "GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE)",
          "old_line_content": "        if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)",
          "new_line_content": "        CAmount mempoolRejectFee = pool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);",
          "content_same": false
        },
        {
          "line": 2623,
          "old_api": null,
          "new_api": "CheckDiskSpace",
          "old_text": null,
          "new_text": "CheckDiskSpace(nNewChunks * UNDOFILE_CHUNK_SIZE - pos.nPos)",
          "old_line_content": "    unsigned int nNewChunks = (nNewSize + UNDOFILE_CHUNK_SIZE - 1) / UNDOFILE_CHUNK_SIZE;",
          "new_line_content": "        if (CheckDiskSpace(nNewChunks * UNDOFILE_CHUNK_SIZE - pos.nPos)) {",
          "content_same": false
        },
        {
          "line": 2624,
          "old_api": null,
          "new_api": "OpenUndoFile",
          "old_text": null,
          "new_text": "OpenUndoFile(pos)",
          "old_line_content": "    if (nNewChunks > nOldChunks) {",
          "new_line_content": "            FILE *file = OpenUndoFile(pos);",
          "content_same": false
        },
        {
          "line": 2626,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"Pre-allocating up to position 0x%x in rev%05u.dat\\n\", nNewChunks * UNDOFILE_CHUNK_SIZE, pos.nFile)",
          "old_line_content": "            fCheckForPruning = true;",
          "new_line_content": "                LogPrintf(\"Pre-allocating up to position 0x%x in rev%05u.dat\\n\", nNewChunks * UNDOFILE_CHUNK_SIZE, pos.nFile);",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": null,
          "new_api": "DoS",
          "old_text": null,
          "new_text": "state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\")",
          "old_line_content": "        }",
          "new_line_content": "            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\");",
          "content_same": false
        },
        {
          "line": 585,
          "old_api": null,
          "new_api": "strprintf",
          "old_text": null,
          "new_text": "strprintf(\"%d > %d\", nFees, nAbsurdFee)",
          "old_line_content": "",
          "new_line_content": "                strprintf(\"%d > %d\", nFees, nAbsurdFee));",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": null,
          "new_api": "GetArg",
          "old_text": null,
          "new_text": "GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)",
          "old_line_content": "",
          "new_line_content": "        size_t nLimitAncestorSize = GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": null,
          "new_api": "GetArg",
          "old_text": null,
          "new_text": "GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT)",
          "old_line_content": "        // Calculate in-mempool ancestors, up to a limit.",
          "new_line_content": "        size_t nLimitDescendants = GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": null,
          "new_api": "GetArg",
          "old_text": null,
          "new_text": "GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)",
          "old_line_content": "        CTxMemPool::setEntries setAncestors;",
          "new_line_content": "        size_t nLimitDescendantSize = GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;",
          "content_same": false
        },
        {
          "line": 2641,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "block.GetHash()",
          "old_line_content": "",
          "new_line_content": "    if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))",
          "content_same": false
        },
        {
          "line": 2642,
          "old_api": null,
          "new_api": "DoS",
          "old_text": null,
          "new_text": "state.DoS(50, false, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\")",
          "old_line_content": "static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW = true)",
          "new_line_content": "        return state.DoS(50, false, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "ancestorIt->GetTx().GetHash()",
          "old_line_content": "        // pathological case by making sure setConflicts and setAncestors don't",
          "new_line_content": "            const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "setConflicts.count(hashAncestor)",
          "old_line_content": "        // intersect.",
          "new_line_content": "            if (setConflicts.count(hashAncestor))",
          "content_same": false
        },
        {
          "line": 607,
          "old_api": null,
          "new_api": "DoS",
          "old_text": null,
          "new_text": "state.DoS(10, false,\n                                 REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n                                 strprintf(\"%s spends conflicting transaction %s\",\n                                           hash.ToString(),\n                                           hashAncestor.ToString()))",
          "old_line_content": "        {",
          "new_line_content": "                return state.DoS(10, false,",
          "content_same": false
        },
        {
          "line": 2656,
          "old_api": null,
          "new_api": "CheckBlockHeader",
          "old_text": null,
          "new_text": "CheckBlockHeader(block, state, consensusParams, fCheckPOW)",
          "old_line_content": "        return true;",
          "new_line_content": "    if (!CheckBlockHeader(block, state, consensusParams, fCheckPOW))",
          "content_same": false
        },
        {
          "line": 610,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "hash.ToString()",
          "old_line_content": "            {",
          "new_line_content": "                                           hash.ToString(),",
          "content_same": false
        },
        {
          "line": 2662,
          "old_api": null,
          "new_api": "BlockMerkleRoot",
          "old_text": null,
          "new_text": "BlockMerkleRoot(block, &mutated)",
          "old_line_content": "",
          "new_line_content": "        uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &mutated);",
          "content_same": false
        },
        {
          "line": 2664,
          "old_api": null,
          "new_api": "DoS",
          "old_text": null,
          "new_text": "state.DoS(100, false, REJECT_INVALID, \"bad-txnmrklroot\", true, \"hashMerkleRoot mismatch\")",
          "old_line_content": "    if (fCheckMerkleRoot) {",
          "new_line_content": "            return state.DoS(100, false, REJECT_INVALID, \"bad-txnmrklroot\", true, \"hashMerkleRoot mismatch\");",
          "content_same": false
        },
        {
          "line": 2670,
          "old_api": null,
          "new_api": "DoS",
          "old_text": null,
          "new_text": "state.DoS(100, false, REJECT_INVALID, \"bad-txns-duplicate\", true, \"duplicate transaction\")",
          "old_line_content": "        // Check for merkle tree malleability (CVE-2012-2459): repeating sequences",
          "new_line_content": "            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-duplicate\", true, \"duplicate transaction\");",
          "content_same": false
        },
        {
          "line": 625,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pool.cs)",
          "old_line_content": "",
          "new_line_content": "        LOCK(pool.cs);",
          "content_same": false
        },
        {
          "line": 626,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "setConflicts.size()",
          "old_line_content": "        // If we don't hold the lock allConflicting might be incomplete; the",
          "new_line_content": "        const bool fReplacementTransaction = setConflicts.size();",
          "content_same": false
        },
        {
          "line": 2680,
          "old_api": null,
          "new_api": "::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS)",
          "old_text": null,
          "new_text": "::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS)",
          "old_line_content": "    // Note that witness malleability is checked in ContextualCheckBlock, so no",
          "new_line_content": "    if (block.vtx.empty() || block.vtx.size() > MAX_BLOCK_BASE_SIZE || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) > MAX_BLOCK_BASE_SIZE)",
          "content_same": false
        },
        {
          "line": 2681,
          "old_api": null,
          "new_api": "DoS",
          "old_text": null,
          "new_text": "state.DoS(100, false, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\")",
          "old_line_content": "    // checks that use witness data may be performed here.",
          "new_line_content": "        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\");",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "pool.mapTx.find(hashConflicting)",
          "old_line_content": "            const int maxDescendantsToVisit = 100;",
          "new_line_content": "                CTxMemPool::txiter mi = pool.mapTx.find(hashConflicting);",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "pool.mapTx.end()",
          "old_line_content": "            CTxMemPool::setEntries setIterConflicting;",
          "new_line_content": "                if (mi == pool.mapTx.end())",
          "content_same": false
        },
        {
          "line": 2686,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "block.vtx.size()",
          "old_line_content": "",
          "new_line_content": "    for (unsigned int i = 1; i < block.vtx.size(); i++)",
          "content_same": false
        },
        {
          "line": 2687,
          "old_api": null,
          "new_api": "IsCoinBase",
          "old_text": null,
          "new_text": "block.vtx[i]->IsCoinBase()",
          "old_line_content": "    // First transaction must be coinbase, the rest must not be",
          "new_line_content": "        if (block.vtx[i]->IsCoinBase())",
          "content_same": false
        },
        {
          "line": 2693,
          "old_api": null,
          "new_api": "GetRejectReason",
          "old_text": null,
          "new_text": "state.GetRejectReason()",
          "old_line_content": "",
          "new_line_content": "            return state.Invalid(false, state.GetRejectCode(), state.GetRejectReason(),",
          "content_same": false
        },
        {
          "line": 2694,
          "old_api": null,
          "new_api": "GetDebugMessage",
          "old_text": null,
          "new_text": "state.GetDebugMessage()",
          "old_line_content": "    // Check transactions",
          "new_line_content": "                                 strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));",
          "content_same": false
        },
        {
          "line": 2699,
          "old_api": null,
          "new_api": "GetLegacySigOpCount",
          "old_text": null,
          "new_text": "GetLegacySigOpCount(*tx)",
          "old_line_content": "",
          "new_line_content": "        nSigOps += GetLegacySigOpCount(*tx);",
          "content_same": false
        },
        {
          "line": 2702,
          "old_api": null,
          "new_api": "DoS",
          "old_text": null,
          "new_text": "state.DoS(100, false, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\")",
          "old_line_content": "    {",
          "new_line_content": "        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\");",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": null,
          "new_api": "GetTxSize",
          "old_text": null,
          "new_text": "mi->GetTxSize()",
          "old_line_content": "                // descendants. While that does mean high feerate children are",
          "new_line_content": "                CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());",
          "content_same": false
        },
        {
          "line": 661,
          "old_api": null,
          "new_api": "DoS",
          "old_text": null,
          "new_text": "state.DoS(0, false,\n                            REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                            strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                                  hash.ToString(),\n                                  newFeeRate.ToString(),\n                                  oldFeeRate.ToString()))",
          "old_line_content": "                // mitigating most cases.",
          "new_line_content": "                    return state.DoS(0, false,",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                                  hash.ToString(),\n                                  newFeeRate.ToString(),\n                                  oldFeeRate.ToString())",
          "old_line_content": "                if (newFeeRate <= oldFeeRate)",
          "new_line_content": "                            strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "hash.ToString()",
          "old_line_content": "                {",
          "new_line_content": "                                  hash.ToString(),",
          "content_same": false
        },
        {
          "line": 2712,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "}",
          "new_line_content": "    if (*pindexPrev->phashBlock == chainparams.GetConsensus().hashGenesisBlock)",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "oldFeeRate.ToString()",
          "old_line_content": "                            REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,",
          "new_line_content": "                                  oldFeeRate.ToString()));",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "setConflictsParents.insert(txin.prevout.hash)",
          "old_line_content": "                }",
          "new_line_content": "                    setConflictsParents.insert(txin.prevout.hash);",
          "content_same": false
        },
        {
          "line": 2719,
          "old_api": null,
          "new_api": "Checkpoints",
          "old_text": null,
          "new_text": "chainparams.Checkpoints()",
          "old_line_content": "    int nHeight = pindexPrev->nHeight+1;",
          "new_line_content": "    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(chainparams.Checkpoints());",
          "content_same": false
        },
        {
          "line": 2721,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight)",
          "old_line_content": "    // GetLastCheckpoint finds the last checkpoint in MapCheckpoints that's in our",
          "new_line_content": "        return state.DoS(100, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");",
          "content_same": false
        },
        {
          "line": 674,
          "old_api": null,
          "new_api": "GetCountWithDescendants",
          "old_text": null,
          "new_text": "mi->GetCountWithDescendants()",
          "old_line_content": "                {",
          "new_line_content": "                nConflictingCount += mi->GetCountWithDescendants();",
          "content_same": false
        },
        {
          "line": 2728,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "}",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2729,
          "old_api": null,
          "new_api": "VersionBitsState",
          "old_text": null,
          "new_text": "VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_SEGWIT, versionbitscache)",
          "old_line_content": "",
          "new_line_content": "    return (VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == THRESHOLD_ACTIVE);",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": null,
          "new_api": "CalculateDescendants",
          "old_text": null,
          "new_text": "pool.CalculateDescendants(it, allConflicting)",
          "old_line_content": "            if (nConflictingCount <= maxDescendantsToVisit) {",
          "new_line_content": "                    pool.CalculateDescendants(it, allConflicting);",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": null,
          "new_api": "GetModifiedFee",
          "old_text": null,
          "new_text": "it->GetModifiedFee()",
          "old_line_content": "                for (CTxMemPool::txiter it : setIterConflicting) {",
          "new_line_content": "                    nConflictingFees += it->GetModifiedFee();",
          "content_same": false
        },
        {
          "line": 2737,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "block.vtx.empty()",
          "old_line_content": "// commitment occurs, or -1 if not found.",
          "new_line_content": "    if (!block.vtx.empty()) {",
          "content_same": false
        },
        {
          "line": 2738,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "block.vtx[0]->vout.size()",
          "old_line_content": "static int GetWitnessCommitmentIndex(const CBlock& block)",
          "new_line_content": "        for (size_t o = 0; o < block.vtx[0]->vout.size(); o++) {",
          "content_same": false
        },
        {
          "line": 2739,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "block.vtx[0]->vout[o].scriptPubKey.size()",
          "old_line_content": "{",
          "new_line_content": "            if (block.vtx[0]->vout[o].scriptPubKey.size() >= 38 && block.vtx[0]->vout[o].scriptPubKey[0] == OP_RETURN && block.vtx[0]->vout[o].scriptPubKey[1] == 0x24 && block.vtx[0]->vout[o].scriptPubKey[2] == 0xaa && block.vtx[0]->vout[o].scriptPubKey[3] == 0x21 && block.vtx[0]->vout[o].scriptPubKey[4] == 0xa9 && block.vtx[0]->vout[o].scriptPubKey[5] == 0xed) {",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                            hash.ToString(),\n                            nConflictingCount,\n                            maxDescendantsToVisit)",
          "old_line_content": "                }",
          "new_line_content": "                        strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "hash.ToString()",
          "old_line_content": "            } else {",
          "new_line_content": "                            hash.ToString(),",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "tx.vin.size()",
          "old_line_content": "                            nConflictingCount,",
          "new_line_content": "            for (unsigned int j = 0; j < tx.vin.size(); j++)",
          "content_same": false
        },
        {
          "line": 2749,
          "old_api": null,
          "new_api": "GetWitnessCommitmentIndex",
          "old_text": null,
          "new_text": "GetWitnessCommitmentIndex(block)",
          "old_line_content": "}",
          "new_line_content": "    int commitpos = GetWitnessCommitmentIndex(block);",
          "content_same": false
        },
        {
          "line": 2751,
          "old_api": null,
          "new_api": "HasWitness",
          "old_text": null,
          "new_text": "block.vtx[0]->HasWitness()",
          "old_line_content": "void UpdateUncommittedBlockStructures(CBlock& block, const CBlockIndex* pindexPrev, const Consensus::Params& consensusParams)",
          "new_line_content": "    if (commitpos != -1 && IsWitnessEnabled(pindexPrev, consensusParams) && !block.vtx[0]->HasWitness()) {",
          "content_same": false
        },
        {
          "line": 704,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "setConflictsParents.count(tx.vin[j].prevout.hash)",
          "old_line_content": "                // We don't want to accept replacements that require low",
          "new_line_content": "                if (!setConflictsParents.count(tx.vin[j].prevout.hash))",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "pool.mapTx.end()",
          "old_line_content": "                {",
          "new_line_content": "                    if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end())",
          "content_same": false
        },
        {
          "line": 710,
          "old_api": null,
          "new_api": "DoS",
          "old_text": null,
          "new_text": "state.DoS(0, false,\n                                         REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\", false,\n                                         strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n                                                  hash.ToString(), j))",
          "old_line_content": "                    // Rather than check the UTXO set - potentially expensive -",
          "new_line_content": "                        return state.DoS(0, false,",
          "content_same": false
        },
        {
          "line": 712,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n                                                  hash.ToString(), j)",
          "old_line_content": "                    // tx that's in the mempool.",
          "new_line_content": "                                         strprintf(\"replacement %s adds unconfirmed input, idx %d\",",
          "content_same": false
        },
        {
          "line": 2762,
          "old_api": null,
          "new_api": "GetWitnessCommitmentIndex",
          "old_text": null,
          "new_text": "GetWitnessCommitmentIndex(block)",
          "old_line_content": "",
          "new_line_content": "    int commitpos = GetWitnessCommitmentIndex(block);",
          "content_same": false
        },
        {
          "line": 2767,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "witnessroot.begin()",
          "old_line_content": "    std::vector<unsigned char> ret(32, 0x00);",
          "new_line_content": "            CHash256().Write(witnessroot.begin(), 32).Write(&ret[0], 32).Finalize(witnessroot.begin());",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": null,
          "new_api": "DoS",
          "old_text": null,
          "new_text": "state.DoS(0, false,\n                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                                 strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                                          hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)))",
          "old_line_content": "            // replaces - if we did the bandwidth used by those conflicting",
          "new_line_content": "                return state.DoS(0, false,",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                                          hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees))",
          "old_line_content": "            if (nModifiedFees < nConflictingFees)",
          "new_line_content": "                                 strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": null,
          "new_api": "FormatMoney",
          "old_text": null,
          "new_text": "FormatMoney(nConflictingFees)",
          "old_line_content": "            {",
          "new_line_content": "                                          hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));",
          "content_same": false
        },
        {
          "line": 2777,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "witnessroot.begin()",
          "old_line_content": "            out.scriptPubKey[2] = 0xaa;",
          "new_line_content": "            memcpy(&out.scriptPubKey[6], witnessroot.begin(), 32);",
          "content_same": false
        },
        {
          "line": 2778,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "out.scriptPubKey.end()",
          "old_line_content": "            out.scriptPubKey[3] = 0x21;",
          "new_line_content": "            commitment = std::vector<unsigned char>(out.scriptPubKey.begin(), out.scriptPubKey.end());",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": null,
          "new_api": "GetFee",
          "old_text": null,
          "new_text": "::incrementalRelayFee.GetFee(nSize)",
          "old_line_content": "",
          "new_line_content": "            if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))",
          "content_same": false
        },
        {
          "line": 2780,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "tx.vout.push_back(out)",
          "old_line_content": "            out.scriptPubKey[5] = 0xed;",
          "new_line_content": "            tx.vout.push_back(out);",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": null,
          "new_api": "DoS",
          "old_text": null,
          "new_text": "state.DoS(0, false,\n                        REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                        strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                              hash.ToString(),\n                              FormatMoney(nDeltaFees),\n                              FormatMoney(::incrementalRelayFee.GetFee(nSize))))",
          "old_line_content": "            // new transaction must pay for its own bandwidth.",
          "new_line_content": "                return state.DoS(0, false,",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "hash.ToString()",
          "old_line_content": "            {",
          "new_line_content": "                              hash.ToString(),",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": null,
          "new_api": "GetFee",
          "old_text": null,
          "new_text": "::incrementalRelayFee.GetFee(nSize)",
          "old_line_content": "                        REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,",
          "new_line_content": "                              FormatMoney(::incrementalRelayFee.GetFee(nSize))));",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": null,
          "new_api": "RequireStandard",
          "old_text": null,
          "new_text": "chainparams.RequireStandard()",
          "old_line_content": "            }",
          "new_line_content": "        if (!chainparams.RequireStandard()) {",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": null,
          "new_api": "GetArg",
          "old_text": null,
          "new_text": "GetArg(\"-promiscuousmempoolflags\", scriptVerifyFlags)",
          "old_line_content": "        }",
          "new_line_content": "            scriptVerifyFlags = GetArg(\"-promiscuousmempoolflags\", scriptVerifyFlags);",
          "content_same": false
        },
        {
          "line": 2793,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(pindexPrev != NULL)",
          "old_line_content": " *  By \"context\", we mean only the previous block headers, but not the UTXO",
          "new_line_content": "    assert(pindexPrev != NULL);",
          "content_same": false
        },
        {
          "line": 2796,
          "old_api": null,
          "new_api": "GetNextWorkRequired",
          "old_text": null,
          "new_text": "GetNextWorkRequired(pindexPrev, &block, consensusParams)",
          "old_line_content": "{",
          "new_line_content": "    if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": null,
          "new_api": "CheckInputs",
          "old_text": null,
          "new_text": "CheckInputs(tx, state, view, true, scriptVerifyFlags, true, txdata)",
          "old_line_content": "",
          "new_line_content": "        if (!CheckInputs(tx, state, view, true, scriptVerifyFlags, true, txdata)) {",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": null,
          "new_api": "CheckInputs",
          "old_text": null,
          "new_text": "CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, txdata)",
          "old_line_content": "            // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we",
          "new_line_content": "            if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, txdata) &&",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": null,
          "new_api": "CheckInputs",
          "old_text": null,
          "new_text": "CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, txdata)",
          "old_line_content": "            // need to turn both off, and compare against just turning off CLEANSTACK",
          "new_line_content": "                !CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, txdata)) {",
          "content_same": false
        },
        {
          "line": 758,
          "old_api": null,
          "new_api": "SetCorruptionPossible",
          "old_text": null,
          "new_text": "state.SetCorruptionPossible()",
          "old_line_content": "            CValidationState stateDummy; // Want reported failures to be from first CheckInputs",
          "new_line_content": "                state.SetCorruptionPossible();",
          "content_same": false
        },
        {
          "line": 2812,
          "old_api": null,
          "new_api": "strprintf",
          "old_text": null,
          "new_text": "strprintf(\"bad-version(0x%08x)\", block.nVersion)",
          "old_line_content": "    // check for version 2, 3 and 4 upgrades",
          "new_line_content": "            return state.Invalid(false, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),",
          "content_same": false
        },
        {
          "line": 2813,
          "old_api": null,
          "new_api": "strprintf",
          "old_text": null,
          "new_text": "strprintf(\"rejected nVersion=0x%08x block\", block.nVersion)",
          "old_line_content": "    if((block.nVersion < 2 && nHeight >= consensusParams.BIP34Height) ||",
          "new_line_content": "                                 strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": null,
          "new_api": "CheckInputs",
          "old_text": null,
          "new_text": "CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true, txdata)",
          "old_line_content": "        //",
          "new_line_content": "        if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true, txdata))",
          "content_same": false
        },
        {
          "line": 774,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "error(\"%s: BUG! PLEASE REPORT THIS! ConnectInputs failed against MANDATORY but not STANDARD flags %s, %s\",\n                __func__, hash.ToString(), FormatStateMessage(state))",
          "old_line_content": "        // invalid blocks, however allowing such transactions into the mempool",
          "new_line_content": "            return error(\"%s: BUG! PLEASE REPORT THIS! ConnectInputs failed against MANDATORY but not STANDARD flags %s, %s\",",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": null,
          "new_api": "FormatStateMessage",
          "old_text": null,
          "new_text": "FormatStateMessage(state)",
          "old_line_content": "        // can be exploited as a DoS attack.",
          "new_line_content": "                __func__, hash.ToString(), FormatStateMessage(state));",
          "content_same": false
        },
        {
          "line": 2824,
          "old_api": null,
          "new_api": "VersionBitsState",
          "old_text": null,
          "new_text": "VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_CSV, versionbitscache)",
          "old_line_content": "    const int nHeight = pindexPrev == NULL ? 0 : pindexPrev->nHeight + 1;",
          "new_line_content": "    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "LogPrint(BCLog::MEMPOOL, \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",\n                    it->GetTx().GetHash().ToString(),\n                    hash.ToString(),\n                    FormatMoney(nModifiedFees - nConflictingFees),\n                    (int)nSize - (int)nConflictingSize)",
          "old_line_content": "",
          "new_line_content": "            LogPrint(BCLog::MEMPOOL, \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "it->GetTx().GetHash().ToString()",
          "old_line_content": "        // Remove conflicting transactions from the mempool",
          "new_line_content": "                    it->GetTx().GetHash().ToString(),",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "hash.ToString()",
          "old_line_content": "        for (const CTxMemPool::txiter it : allConflicting)",
          "new_line_content": "                    hash.ToString(),",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": null,
          "new_api": "FormatMoney",
          "old_text": null,
          "new_text": "FormatMoney(nModifiedFees - nConflictingFees)",
          "old_line_content": "        {",
          "new_line_content": "                    FormatMoney(nModifiedFees - nConflictingFees),",
          "content_same": false
        },
        {
          "line": 2829,
          "old_api": null,
          "new_api": "GetMedianTimePast",
          "old_text": null,
          "new_text": "pindexPrev->GetMedianTimePast()",
          "old_line_content": "        nLockTimeFlags |= LOCKTIME_MEDIAN_TIME_PAST;",
          "new_line_content": "                              ? pindexPrev->GetMedianTimePast()",
          "content_same": false
        },
        {
          "line": 2830,
          "old_api": null,
          "new_api": "GetBlockTime",
          "old_text": null,
          "new_text": "block.GetBlockTime()",
          "old_line_content": "    }",
          "new_line_content": "                              : block.GetBlockTime();",
          "content_same": false
        },
        {
          "line": 2835,
          "old_api": null,
          "new_api": "DoS",
          "old_text": null,
          "new_text": "state.DoS(10, false, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\")",
          "old_line_content": "",
          "new_line_content": "            return state.DoS(10, false, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\");",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": null,
          "new_api": "RemoveStaged",
          "old_text": null,
          "new_text": "pool.RemoveStaged(allConflicting, false, MemPoolRemovalReason::REPLACED)",
          "old_line_content": "                    (int)nSize - (int)nConflictingSize);",
          "new_line_content": "        pool.RemoveStaged(allConflicting, false, MemPoolRemovalReason::REPLACED);",
          "content_same": false
        },
        {
          "line": 2842,
          "old_api": null,
          "new_api": "CScript",
          "old_text": null,
          "new_text": "CScript()",
          "old_line_content": "",
          "new_line_content": "        CScript expect = CScript() << nHeight;",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": null,
          "new_api": "HasNoInputsOf",
          "old_text": null,
          "new_text": "pool.HasNoInputsOf(tx)",
          "old_line_content": "        // This transaction should only count for fee estimation if it isn't a",
          "new_line_content": "        bool validForFeeEstimation = !fReplacementTransaction && IsCurrentForFeeEstimation() && pool.HasNoInputsOf(tx);",
          "content_same": false
        },
        {
          "line": 2843,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "expect.size()",
          "old_line_content": "    // Enforce rule that the coinbase starts with serialized block height",
          "new_line_content": "        if (block.vtx[0]->vin[0].scriptSig.size() < expect.size() ||",
          "content_same": false
        },
        {
          "line": 2844,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "block.vtx[0]->vin[0].scriptSig.begin()",
          "old_line_content": "    if (nHeight >= consensusParams.BIP34Height)",
          "new_line_content": "            !std::equal(expect.begin(), expect.end(), block.vtx[0]->vin[0].scriptSig.begin())) {",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": null,
          "new_api": "addUnchecked",
          "old_text": null,
          "new_text": "pool.addUnchecked(hash, entry, setAncestors, validForFeeEstimation)",
          "old_line_content": "        // transactions in the mempool.",
          "new_line_content": "        pool.addUnchecked(hash, entry, setAncestors, validForFeeEstimation);",
          "content_same": false
        },
        {
          "line": 2845,
          "old_api": null,
          "new_api": "DoS",
          "old_text": null,
          "new_text": "state.DoS(100, false, REJECT_INVALID, \"bad-cb-height\", false, \"block height mismatch in coinbase\")",
          "old_line_content": "    {",
          "new_line_content": "            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-height\", false, \"block height mismatch in coinbase\");",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": null,
          "new_api": "exists",
          "old_text": null,
          "new_text": "pool.exists(hash)",
          "old_line_content": "",
          "new_line_content": "            if (!pool.exists(hash))",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": null,
          "new_api": "DoS",
          "old_text": null,
          "new_text": "state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full\")",
          "old_line_content": "        // trim mempool and check if tx was trimmed",
          "new_line_content": "                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full\");",
          "content_same": false
        },
        {
          "line": 2858,
          "old_api": null,
          "new_api": "VersionBitsState",
          "old_text": null,
          "new_text": "VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache)",
          "old_line_content": "    // * There must be at least one output whose scriptPubKey is a single 36-byte push, the first 4 bytes of which are",
          "new_line_content": "    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == THRESHOLD_ACTIVE) {",
          "content_same": false
        },
        {
          "line": 2859,
          "old_api": null,
          "new_api": "GetWitnessCommitmentIndex",
          "old_text": null,
          "new_text": "GetWitnessCommitmentIndex(block)",
          "old_line_content": "    //   {0xaa, 0x21, 0xa9, 0xed}, and the following 32 bytes are SHA256^2(witness root, witness nonce). In case there are",
          "new_line_content": "        int commitpos = GetWitnessCommitmentIndex(block);",
          "content_same": false
        },
        {
          "line": 819,
          "old_api": null,
          "new_api": "AcceptToMemoryPoolWorker",
          "old_text": null,
          "new_text": "AcceptToMemoryPoolWorker(chainparams, pool, state, tx, fLimitFree, pfMissingInputs, nAcceptTime, plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee, coins_to_uncache)",
          "old_line_content": "                        bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,",
          "new_line_content": "    bool res = AcceptToMemoryPoolWorker(chainparams, pool, state, tx, fLimitFree, pfMissingInputs, nAcceptTime, plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee, coins_to_uncache);",
          "content_same": false
        },
        {
          "line": 2867,
          "old_api": null,
          "new_api": "strprintf",
          "old_text": null,
          "new_text": "strprintf(\"%s : invalid witness nonce size\", __func__)",
          "old_line_content": "            // The malleation check is ignored; as the transaction tree itself",
          "new_line_content": "                return state.DoS(100, false, REJECT_INVALID, \"bad-witness-nonce-size\", true, strprintf(\"%s : invalid witness nonce size\", __func__));",
          "content_same": false
        },
        {
          "line": 2869,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "hashWitness.begin()",
          "old_line_content": "            // witness tree.",
          "new_line_content": "            CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0]->vin[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": null,
          "new_api": "Uncache",
          "old_text": null,
          "new_text": "pcoinsTip->Uncache(hashTx)",
          "old_line_content": "    std::vector<COutPoint> coins_to_uncache;",
          "new_line_content": "            pcoinsTip->Uncache(hashTx);",
          "content_same": false
        },
        {
          "line": 2880,
          "old_api": null,
          "new_api": "HasWitness",
          "old_text": null,
          "new_text": "tx->HasWitness()",
          "old_line_content": "",
          "new_line_content": "            if (tx->HasWitness()) {",
          "content_same": false
        },
        {
          "line": 2881,
          "old_api": null,
          "new_api": "strprintf",
          "old_text": null,
          "new_text": "strprintf(\"%s : unexpected witness data found\", __func__)",
          "old_line_content": "    // No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room for spam",
          "new_line_content": "                return state.DoS(100, false, REJECT_INVALID, \"unexpected-witness\", true, strprintf(\"%s : unexpected witness data found\", __func__));",
          "content_same": false
        },
        {
          "line": 834,
          "old_api": null,
          "new_api": "Params",
          "old_text": null,
          "new_text": "Params()",
          "old_line_content": "bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx, bool fLimitFree,",
          "new_line_content": "    const CChainParams& chainparams = Params();",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": null,
          "new_api": "GetTime",
          "old_text": null,
          "new_text": "GetTime()",
          "old_line_content": "                        bool* pfMissingInputs, std::list<CTransactionRef>* plTxnReplaced,",
          "new_line_content": "    return AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, fLimitFree, pfMissingInputs, GetTime(), plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee);",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "bool GetTransaction(const uint256 &hash, CTransactionRef &txOut, const Consensus::Params& consensusParams, uint256 &hashBlock, bool fAllowSlow)",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2892,
          "old_api": null,
          "new_api": "GetBlockWeight",
          "old_text": null,
          "new_text": "GetBlockWeight(block)",
          "old_line_content": "    // coinbase witness, it would be possible for the weight to be too",
          "new_line_content": "    if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {",
          "content_same": false
        },
        {
          "line": 845,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "mempool.get(hash)",
          "old_line_content": "    CBlockIndex *pindexSlow = NULL;",
          "new_line_content": "    CTransactionRef ptx = mempool.get(hash);",
          "content_same": false
        },
        {
          "line": 2893,
          "old_api": null,
          "new_api": "strprintf",
          "old_text": null,
          "new_text": "strprintf(\"%s : weight limit failed\", __func__)",
          "old_line_content": "    // large by filling up the coinbase witness, which doesn't change",
          "new_line_content": "        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-weight\", false, strprintf(\"%s : weight limit failed\", __func__));",
          "content_same": false
        },
        {
          "line": 2901,
          "old_api": null,
          "new_api": "AssertLockHeld",
          "old_text": null,
          "new_text": "AssertLockHeld(cs_main)",
          "old_line_content": "}",
          "new_line_content": "    AssertLockHeld(cs_main);",
          "content_same": false
        },
        {
          "line": 854,
          "old_api": null,
          "new_api": "ReadTxIndex",
          "old_text": null,
          "new_text": "pblocktree->ReadTxIndex(hash, postx)",
          "old_line_content": "    }",
          "new_line_content": "        if (pblocktree->ReadTxIndex(hash, postx)) {",
          "content_same": false
        },
        {
          "line": 2903,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "block.GetHash()",
          "old_line_content": "static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex)",
          "new_line_content": "    uint256 hash = block.GetHash();",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": null,
          "new_api": "IsNull",
          "old_text": null,
          "new_text": "file.IsNull()",
          "old_line_content": "    if (fTxIndex) {",
          "new_line_content": "            if (file.IsNull())",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"%s: OpenBlockFile failed\", __func__)",
          "old_line_content": "        CDiskTxPos postx;",
          "new_line_content": "                return error(\"%s: OpenBlockFile failed\", __func__);",
          "content_same": false
        },
        {
          "line": 2904,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "mapBlockIndex.find(hash)",
          "old_line_content": "{",
          "new_line_content": "    BlockMap::iterator miSelf = mapBlockIndex.find(hash);",
          "content_same": false
        },
        {
          "line": 2906,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "    // Check for duplicate",
          "new_line_content": "    if (hash != chainparams.GetConsensus().hashGenesisBlock) {",
          "content_same": false
        },
        {
          "line": 864,
          "old_api": null,
          "new_api": "what",
          "old_text": null,
          "new_text": "e.what()",
          "old_line_content": "                file >> header;",
          "new_line_content": "                return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "header.GetHash()",
          "old_line_content": "                file >> txOut;",
          "new_line_content": "            hashBlock = header.GetHash();",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "txOut->GetHash()",
          "old_line_content": "            } catch (const std::exception& e) {",
          "new_line_content": "            if (txOut->GetHash() != hash)",
          "content_same": false
        },
        {
          "line": 2914,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "hash.ToString()",
          "old_line_content": "            pindex = miSelf->second;",
          "new_line_content": "                return state.Invalid(error(\"%s: block %s is marked invalid\", __func__, hash.ToString()), 0, \"duplicate\");",
          "content_same": false
        },
        {
          "line": 2919,
          "old_api": null,
          "new_api": "FormatStateMessage",
          "old_text": null,
          "new_text": "FormatStateMessage(state)",
          "old_line_content": "            return true;",
          "new_line_content": "            return error(\"%s: Consensus::CheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": null,
          "new_api": "AccessByTxid",
          "old_text": null,
          "new_text": "AccessByTxid(*pcoinsTip, hash)",
          "old_line_content": "        }",
          "new_line_content": "        const Coin& coin = AccessByTxid(*pcoinsTip, hash);",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": null,
          "new_api": "IsSpent",
          "old_text": null,
          "new_text": "coin.IsSpent()",
          "old_line_content": "    }",
          "new_line_content": "        if (!coin.IsSpent()) pindexSlow = chainActive[coin.nHeight];",
          "content_same": false
        },
        {
          "line": 2924,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapBlockIndex.end()",
          "old_line_content": "",
          "new_line_content": "        if (mi == mapBlockIndex.end())",
          "content_same": false
        },
        {
          "line": 2925,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"%s: prev block not found\", __func__)",
          "old_line_content": "        // Get prev block index",
          "new_line_content": "            return state.DoS(10, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": null,
          "new_api": "ReadBlockFromDisk",
          "old_text": null,
          "new_text": "ReadBlockFromDisk(block, pindexSlow, consensusParams)",
          "old_line_content": "    }",
          "new_line_content": "        if (ReadBlockFromDisk(block, pindexSlow, consensusParams)) {",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "tx->GetHash()",
          "old_line_content": "    if (pindexSlow) {",
          "new_line_content": "                if (tx->GetHash() == hash) {",
          "content_same": false
        },
        {
          "line": 2930,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(pindexPrev)",
          "old_line_content": "        pindexPrev = (*mi).second;",
          "new_line_content": "        assert(pindexPrev);",
          "content_same": false
        },
        {
          "line": 2931,
          "old_api": null,
          "new_api": "CheckIndexAgainstCheckpoint",
          "old_text": null,
          "new_text": "CheckIndexAgainstCheckpoint(pindexPrev, state, chainparams, hash)",
          "old_line_content": "        if (pindexPrev->nStatus & BLOCK_FAILED_MASK)",
          "new_line_content": "        if (fCheckpointsEnabled && !CheckIndexAgainstCheckpoint(pindexPrev, state, chainparams, hash))",
          "content_same": false
        },
        {
          "line": 2943,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "",
          "new_line_content": "    CheckBlockIndex(chainparams.GetConsensus());",
          "content_same": false
        },
        {
          "line": 2952,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "// Exposed wrapper for AcceptBlockHeader",
          "new_line_content": "        LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 2955,
          "old_api": null,
          "new_api": "AcceptBlockHeader",
          "old_text": null,
          "new_text": "AcceptBlockHeader(header, state, chainparams, &pindex)",
          "old_line_content": "    {",
          "new_line_content": "            if (!AcceptBlockHeader(header, state, chainparams, &pindex)) {",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": null,
          "new_api": "IsNull",
          "old_text": null,
          "new_text": "fileout.IsNull()",
          "old_line_content": "static bool WriteBlockToDisk(const CBlock& block, CDiskBlockPos& pos, const CMessageHeader::MessageStartChars& messageStart)",
          "new_line_content": "    if (fileout.IsNull())",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"WriteBlockToDisk: OpenBlockFile failed\")",
          "old_line_content": "{",
          "new_line_content": "        return error(\"WriteBlockToDisk: OpenBlockFile failed\");",
          "content_same": false
        },
        {
          "line": 2963,
          "old_api": null,
          "new_api": "NotifyHeaderTip",
          "old_text": null,
          "new_text": "NotifyHeaderTip()",
          "old_line_content": "                *ppindex = pindex;",
          "new_line_content": "    NotifyHeaderTip();",
          "content_same": false
        },
        {
          "line": 918,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"WriteBlockToDisk: ftell failed\")",
          "old_line_content": "",
          "new_line_content": "        return error(\"WriteBlockToDisk: ftell failed\");",
          "content_same": false
        },
        {
          "line": 2973,
          "old_api": null,
          "new_api": "AssertLockHeld",
          "old_text": null,
          "new_text": "AssertLockHeld(cs_main)",
          "old_line_content": "{",
          "new_line_content": "    AssertLockHeld(cs_main);",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": null,
          "new_api": "SetNull",
          "old_text": null,
          "new_text": "block.SetNull()",
          "old_line_content": "}",
          "new_line_content": "    block.SetNull();",
          "content_same": false
        },
        {
          "line": 2978,
          "old_api": null,
          "new_api": "AcceptBlockHeader",
          "old_text": null,
          "new_text": "AcceptBlockHeader(block, state, chainparams, &pindex)",
          "old_line_content": "",
          "new_line_content": "    if (!AcceptBlockHeader(block, state, chainparams, &pindex))",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pos.ToString()",
          "old_line_content": "",
          "new_line_content": "        return error(\"ReadBlockFromDisk: OpenBlockFile failed for %s\", pos.ToString());",
          "content_same": false
        },
        {
          "line": 2985,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "    // Try to process all requested blocks that we don't have, but only",
          "new_line_content": "    bool fHasMoreWork = (chainActive.Tip() ? pindex->nChainWork > chainActive.Tip()->nChainWork : true);",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pos.ToString()",
          "old_line_content": "    try {",
          "new_line_content": "        return error(\"%s: Deserialize or I/O error - %s at %s\", __func__, e.what(), pos.ToString());",
          "content_same": false
        },
        {
          "line": 2991,
          "old_api": null,
          "new_api": "Height",
          "old_text": null,
          "new_text": "chainActive.Height()",
          "old_line_content": "    // pruning, because pruning will not delete block files that contain any",
          "new_line_content": "    bool fTooFarAhead = (pindex->nHeight > int(chainActive.Height() + MIN_BLOCKS_TO_KEEP));",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pos.ToString()",
          "old_line_content": "    }",
          "new_line_content": "        return error(\"ReadBlockFromDisk: Errors in block header at %s\", pos.ToString());",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": null,
          "new_api": "GetBlockPos",
          "old_text": null,
          "new_text": "pindex->GetBlockPos()",
          "old_line_content": "}",
          "new_line_content": "    if (!ReadBlockFromDisk(block, pindex->GetBlockPos(), consensusParams))",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": null,
          "new_api": "GetBlockHash",
          "old_text": null,
          "new_text": "pindex->GetBlockHash()",
          "old_line_content": "bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex, const Consensus::Params& consensusParams)",
          "new_line_content": "    if (block.GetHash() != pindex->GetBlockHash())",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "error(\"ReadBlockFromDisk(CBlock&, CBlockIndex*): GetHash() doesn't match index for %s at %s\",\n                pindex->ToString(), pindex->GetBlockPos().ToString())",
          "old_line_content": "{",
          "new_line_content": "        return error(\"ReadBlockFromDisk(CBlock&, CBlockIndex*): GetHash() doesn't match index for %s at %s\",",
          "content_same": false
        },
        {
          "line": 3008,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "        if (fTooFarAhead) return true;      // Block height is too high",
          "new_line_content": "    if (!CheckBlock(block, state, chainparams.GetConsensus()) ||",
          "content_same": false
        },
        {
          "line": 3009,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "    }",
          "new_line_content": "        !ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindex->pprev)) {",
          "content_same": false
        },
        {
          "line": 3010,
          "old_api": null,
          "new_api": "CorruptionPossible",
          "old_text": null,
          "new_text": "state.CorruptionPossible()",
          "old_line_content": "    if (fNewBlock) *fNewBlock = true;",
          "new_line_content": "        if (state.IsInvalid() && !state.CorruptionPossible()) {",
          "content_same": false
        },
        {
          "line": 3019,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "    }",
          "new_line_content": "    if (!IsInitialBlockDownload() && chainActive.Tip() == pindex->pprev)",
          "content_same": false
        },
        {
          "line": 3020,
          "old_api": null,
          "new_api": "NewPoWValidBlock",
          "old_text": null,
          "new_text": "GetMainSignals().NewPoWValidBlock(pindex, pblock)",
          "old_line_content": "",
          "new_line_content": "        GetMainSignals().NewPoWValidBlock(pindex, pblock);",
          "content_same": false
        },
        {
          "line": 974,
          "old_api": null,
          "new_api": "Params",
          "old_text": null,
          "new_text": "Params()",
          "old_line_content": "}",
          "new_line_content": "    const CChainParams& chainParams = Params();",
          "content_same": false
        },
        {
          "line": 3026,
          "old_api": null,
          "new_api": "::GetSerializeSize(block, SER_DISK, CLIENT_VERSION)",
          "old_text": null,
          "new_text": "::GetSerializeSize(block, SER_DISK, CLIENT_VERSION)",
          "old_line_content": "    int nHeight = pindex->nHeight;",
          "new_line_content": "        unsigned int nBlockSize = ::GetSerializeSize(block, SER_DISK, CLIENT_VERSION);",
          "content_same": false
        },
        {
          "line": 979,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "latchToFalse.load(std::memory_order_relaxed)",
          "old_line_content": "",
          "new_line_content": "    if (latchToFalse.load(std::memory_order_relaxed))",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "    // Optimization: pre-test latch before taking the lock.",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 3031,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"AcceptBlock(): FindBlockPos failed\")",
          "old_line_content": "        CDiskBlockPos blockPos;",
          "new_line_content": "            return error(\"AcceptBlock(): FindBlockPos failed\");",
          "content_same": false
        },
        {
          "line": 3033,
          "old_api": null,
          "new_api": "MessageStart",
          "old_text": null,
          "new_text": "chainparams.MessageStart()",
          "old_line_content": "            blockPos = *dbp;",
          "new_line_content": "            if (!WriteBlockToDisk(block, blockPos, chainparams.MessageStart()))",
          "content_same": false
        },
        {
          "line": 3036,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"AcceptBlock(): ReceivedBlockTransactions failed\")",
          "old_line_content": "        if (dbp == NULL)",
          "new_line_content": "            return error(\"AcceptBlock(): ReceivedBlockTransactions failed\");",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainParams.GetConsensus()",
          "old_line_content": "    if (fImporting || fReindex)",
          "new_line_content": "    if (chainActive.Tip()->nChainWork < UintToArith256(chainParams.GetConsensus().nMinimumChainWork))",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": null,
          "new_api": "store",
          "old_text": null,
          "new_text": "latchToFalse.store(true, std::memory_order_relaxed)",
          "old_line_content": "        return true;",
          "new_line_content": "    latchToFalse.store(true, std::memory_order_relaxed);",
          "content_same": false
        },
        {
          "line": 1002,
          "old_api": null,
          "new_api": "NotifyAlertChanged",
          "old_text": null,
          "new_text": "uiInterface.NotifyAlertChanged()",
          "old_line_content": "CBlockIndex *pindexBestForkTip = NULL, *pindexBestForkBase = NULL;",
          "new_line_content": "    uiInterface.NotifyAlertChanged();",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": null,
          "new_api": "GetArg",
          "old_text": null,
          "new_text": "GetArg(\"-alertnotify\", \"\")",
          "old_line_content": "",
          "new_line_content": "    std::string strCmd = GetArg(\"-alertnotify\", \"\");",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "strCmd.empty()",
          "old_line_content": "static void AlertNotify(const std::string& strMessage)",
          "new_line_content": "    if (strCmd.empty()) return;",
          "content_same": false
        },
        {
          "line": 3055,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "        if (fNewBlock) *fNewBlock = false;",
          "new_line_content": "        bool ret = CheckBlock(*pblock, state, chainparams.GetConsensus());",
          "content_same": false
        },
        {
          "line": 3057,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "        // Ensure that CheckBlock() passes before calling AcceptBlock, as",
          "new_line_content": "        LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": null,
          "new_api": "SanitizeString",
          "old_text": null,
          "new_text": "SanitizeString(strMessage)",
          "old_line_content": "    // Alert text should be plain ascii coming from a trusted source, but to",
          "new_line_content": "    std::string safeStatus = SanitizeString(strMessage);",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": null,
          "new_api": "boost::replace_all(strCmd, \"%s\", safeStatus)",
          "old_text": null,
          "new_text": "boost::replace_all(strCmd, \"%s\", safeStatus)",
          "old_line_content": "    // the whole string before passing it to the shell:",
          "new_line_content": "    boost::replace_all(strCmd, \"%s\", safeStatus);",
          "content_same": false
        },
        {
          "line": 3063,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "        if (ret) {",
          "new_line_content": "        CheckBlockIndex(chainparams.GetConsensus());",
          "content_same": false
        },
        {
          "line": 3066,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"%s: AcceptBlock FAILED\", __func__)",
          "old_line_content": "        }",
          "new_line_content": "            return error(\"%s: AcceptBlock FAILED\", __func__);",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": null,
          "new_api": "AssertLockHeld",
          "old_text": null,
          "new_text": "AssertLockHeld(cs_main)",
          "old_line_content": "}",
          "new_line_content": "    AssertLockHeld(cs_main);",
          "content_same": false
        },
        {
          "line": 1022,
          "old_api": null,
          "new_api": "IsInitialBlockDownload",
          "old_text": null,
          "new_text": "IsInitialBlockDownload()",
          "old_line_content": "{",
          "new_line_content": "    if (IsInitialBlockDownload())",
          "content_same": false
        },
        {
          "line": 3073,
          "old_api": null,
          "new_api": "ActivateBestChain",
          "old_text": null,
          "new_text": "ActivateBestChain(state, chainparams, pblock)",
          "old_line_content": "",
          "new_line_content": "    if (!ActivateBestChain(state, chainparams, pblock))",
          "content_same": false
        },
        {
          "line": 1027,
          "old_api": null,
          "new_api": "Height",
          "old_text": null,
          "new_text": "chainActive.Height()",
          "old_line_content": "        return;",
          "new_line_content": "    if (pindexBestForkTip && chainActive.Height() - pindexBestForkTip->nHeight >= 72)",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "    // of our head, drop it",
          "new_line_content": "    if (pindexBestForkTip || (pindexBestInvalid && pindexBestInvalid->nChainWork > chainActive.Tip()->nChainWork + (GetBlockProof(*chainActive.Tip()) * 6)))",
          "content_same": false
        },
        {
          "line": 1032,
          "old_api": null,
          "new_api": "GetfLargeWorkForkFound",
          "old_text": null,
          "new_text": "GetfLargeWorkForkFound()",
          "old_line_content": "        pindexBestForkTip = NULL;",
          "new_line_content": "        if (!GetfLargeWorkForkFound() && pindexBestForkBase)",
          "content_same": false
        },
        {
          "line": 3081,
          "old_api": null,
          "new_api": "AssertLockHeld",
          "old_text": null,
          "new_text": "AssertLockHeld(cs_main)",
          "old_line_content": "}",
          "new_line_content": "    AssertLockHeld(cs_main);",
          "content_same": false
        },
        {
          "line": 3082,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "",
          "new_line_content": "    assert(pindexPrev && pindexPrev == chainActive.Tip());",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": null,
          "new_api": "std::string(\"'\")",
          "old_text": null,
          "new_text": "std::string(\"'\")",
          "old_line_content": "    {",
          "new_line_content": "                pindexBestForkBase->phashBlock->ToString() + std::string(\"'\");",
          "content_same": false
        },
        {
          "line": 3083,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "block.GetHash()",
          "old_line_content": "bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW, bool fCheckMerkleRoot)",
          "new_line_content": "    if (fCheckpointsEnabled && !CheckIndexAgainstCheckpoint(pindexPrev, state, chainparams, block.GetHash()))",
          "content_same": false
        },
        {
          "line": 3084,
          "old_api": null,
          "new_api": "GetRejectReason",
          "old_text": null,
          "new_text": "state.GetRejectReason().c_str()",
          "old_line_content": "{",
          "new_line_content": "        return error(\"%s: CheckIndexAgainstCheckpoint(): %s\", __func__, state.GetRejectReason().c_str());",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pindexBestForkBase->phashBlock->ToString()",
          "old_line_content": "        }",
          "new_line_content": "                   pindexBestForkBase->nHeight, pindexBestForkBase->phashBlock->ToString(),",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pindexBestForkTip->phashBlock->ToString()",
          "old_line_content": "        if (pindexBestForkTip && pindexBestForkBase)",
          "new_line_content": "                   pindexBestForkTip->nHeight, pindexBestForkTip->phashBlock->ToString());",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": null,
          "new_api": "SetfLargeWorkForkFound",
          "old_text": null,
          "new_text": "SetfLargeWorkForkFound(true)",
          "old_line_content": "        {",
          "new_line_content": "            SetfLargeWorkForkFound(true);",
          "content_same": false
        },
        {
          "line": 3092,
          "old_api": null,
          "new_api": "GetAdjustedTime",
          "old_text": null,
          "new_text": "GetAdjustedTime()",
          "old_line_content": "    indexDummy.pprev = pindexPrev;",
          "new_line_content": "    if (!ContextualCheckBlockHeader(block, state, chainparams.GetConsensus(), pindexPrev, GetAdjustedTime()))",
          "content_same": false
        },
        {
          "line": 3093,
          "old_api": null,
          "new_api": "FormatStateMessage",
          "old_text": null,
          "new_text": "FormatStateMessage(state)",
          "old_line_content": "    indexDummy.nHeight = pindexPrev->nHeight + 1;",
          "new_line_content": "        return error(\"%s: Consensus::ContextualCheckBlockHeader: %s\", __func__, FormatStateMessage(state));",
          "content_same": false
        },
        {
          "line": 3094,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "",
          "new_line_content": "    if (!CheckBlock(block, state, chainparams.GetConsensus(), fCheckPOW, fCheckMerkleRoot))",
          "content_same": false
        },
        {
          "line": 3095,
          "old_api": null,
          "new_api": "FormatStateMessage",
          "old_text": null,
          "new_text": "FormatStateMessage(state)",
          "old_line_content": "    // NOTE: CheckBlockHeader is called by CheckBlock",
          "new_line_content": "        return error(\"%s: Consensus::CheckBlock: %s\", __func__, FormatStateMessage(state));",
          "content_same": false
        },
        {
          "line": 1048,
          "old_api": null,
          "new_api": "SetfLargeWorkInvalidChainFound",
          "old_text": null,
          "new_text": "SetfLargeWorkInvalidChainFound(true)",
          "old_line_content": "        }",
          "new_line_content": "            SetfLargeWorkInvalidChainFound(true);",
          "content_same": false
        },
        {
          "line": 1053,
          "old_api": null,
          "new_api": "SetfLargeWorkForkFound",
          "old_text": null,
          "new_text": "SetfLargeWorkForkFound(false)",
          "old_line_content": "        }",
          "new_line_content": "        SetfLargeWorkForkFound(false);",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": null,
          "new_api": "SetfLargeWorkInvalidChainFound",
          "old_text": null,
          "new_text": "SetfLargeWorkInvalidChainFound(false)",
          "old_line_content": "    }",
          "new_line_content": "        SetfLargeWorkInvalidChainFound(false);",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": null,
          "new_api": "AssertLockHeld",
          "old_text": null,
          "new_text": "AssertLockHeld(cs_main)",
          "old_line_content": "}",
          "new_line_content": "    AssertLockHeld(cs_main);",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "{",
          "new_line_content": "    CBlockIndex* plonger = chainActive.Tip();",
          "content_same": false
        },
        {
          "line": 3122,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapBlockIndex.end()",
          "old_line_content": "",
          "new_line_content": "    for (BlockMap::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); ++it) {",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": null,
          "new_api": "GetBlockProof",
          "old_text": null,
          "new_text": "GetBlockProof(*pfork)",
          "old_line_content": "    // or a chain that is entirely longer than ours and invalid (note that this should be detected by both)",
          "new_line_content": "            pindexNewForkTip->nChainWork - pfork->nChainWork > (GetBlockProof(*pfork) * 7) &&",
          "content_same": false
        },
        {
          "line": 1082,
          "old_api": null,
          "new_api": "Height",
          "old_text": null,
          "new_text": "chainActive.Height()",
          "old_line_content": "    // We define it this way because it allows us to only store the highest fork tip (+ base) which meets",
          "new_line_content": "            chainActive.Height() - pindexNewForkTip->nHeight < 72)",
          "content_same": false
        },
        {
          "line": 3130,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "setDirtyBlockIndex.insert(pindex)",
          "old_line_content": "            pindex->nStatus &= ~BLOCK_HAVE_UNDO;",
          "new_line_content": "            setDirtyBlockIndex.insert(pindex);",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": null,
          "new_api": "CheckForkWarningConditions",
          "old_text": null,
          "new_text": "CheckForkWarningConditions()",
          "old_line_content": "        pindexBestForkTip = pindexNewForkTip;",
          "new_line_content": "    CheckForkWarningConditions();",
          "content_same": false
        },
        {
          "line": 3136,
          "old_api": null,
          "new_api": "equal_range",
          "old_text": null,
          "new_text": "mapBlocksUnlinked.equal_range(pindex->pprev)",
          "old_line_content": "            // Prune from mapBlocksUnlinked -- any block we prune would have",
          "new_line_content": "            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex->pprev);",
          "content_same": false
        },
        {
          "line": 3141,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "mapBlocksUnlinked.erase(_it)",
          "old_line_content": "            while (range.first != range.second) {",
          "new_line_content": "                    mapBlocksUnlinked.erase(_it);",
          "content_same": false
        },
        {
          "line": 1096,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "LogPrintf(\"%s: invalid block=%s  height=%d  log2_work=%.8g  date=%s\\n\", __func__,\n      pindexNew->GetBlockHash().ToString(), pindexNew->nHeight,\n      log(pindexNew->nChainWork.getdouble())/log(2.0), DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\",\n      pindexNew->GetBlockTime()))",
          "old_line_content": "{",
          "new_line_content": "    LogPrintf(\"%s: invalid block=%s  height=%d  log2_work=%.8g  date=%s\\n\", __func__,",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pindexNew->GetBlockHash().ToString()",
          "old_line_content": "    if (!pindexBestInvalid || pindexNew->nChainWork > pindexBestInvalid->nChainWork)",
          "new_line_content": "      pindexNew->GetBlockHash().ToString(), pindexNew->nHeight,",
          "content_same": false
        },
        {
          "line": 1098,
          "old_api": null,
          "new_api": "GetBlockTime",
          "old_text": null,
          "new_text": "DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\",\n      pindexNew->GetBlockTime())",
          "old_line_content": "        pindexBestInvalid = pindexNew;",
          "new_line_content": "      log(pindexNew->nChainWork.getdouble())/log(2.0), DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\",",
          "content_same": false
        },
        {
          "line": 1099,
          "old_api": null,
          "new_api": "GetBlockTime",
          "old_text": null,
          "new_text": "pindexNew->GetBlockTime()",
          "old_line_content": "",
          "new_line_content": "      pindexNew->GetBlockTime()));",
          "content_same": false
        },
        {
          "line": 3147,
          "old_api": null,
          "new_api": "SetNull",
          "old_text": null,
          "new_text": "vinfoBlockFile[fileNumber].SetNull()",
          "old_line_content": "            }",
          "new_line_content": "    vinfoBlockFile[fileNumber].SetNull();",
          "content_same": false
        },
        {
          "line": 3148,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "setDirtyFileInfo.insert(fileNumber)",
          "old_line_content": "        }",
          "new_line_content": "    setDirtyFileInfo.insert(fileNumber);",
          "content_same": false
        },
        {
          "line": 3154,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "setFilesToPrune.end()",
          "old_line_content": "",
          "new_line_content": "    for (std::set<int>::iterator it = setFilesToPrune.begin(); it != setFilesToPrune.end(); ++it) {",
          "content_same": false
        },
        {
          "line": 3156,
          "old_api": null,
          "new_api": "GetBlockPosFilename",
          "old_text": null,
          "new_text": "GetBlockPosFilename(pos, \"blk\")",
          "old_line_content": "void UnlinkPrunedFiles(const std::set<int>& setFilesToPrune)",
          "new_line_content": "        fs::remove(GetBlockPosFilename(pos, \"blk\"));",
          "content_same": false
        },
        {
          "line": 3157,
          "old_api": null,
          "new_api": "GetBlockPosFilename",
          "old_text": null,
          "new_text": "GetBlockPosFilename(pos, \"rev\")",
          "old_line_content": "{",
          "new_line_content": "        fs::remove(GetBlockPosFilename(pos, \"rev\"));",
          "content_same": false
        },
        {
          "line": 1111,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "setDirtyBlockIndex.insert(pindex)",
          "old_line_content": "",
          "new_line_content": "        setDirtyBlockIndex.insert(pindex);",
          "content_same": false
        },
        {
          "line": 1112,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "setBlockIndexCandidates.erase(pindex)",
          "old_line_content": "void static InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state) {",
          "new_line_content": "        setBlockIndexCandidates.erase(pindex);",
          "content_same": false
        },
        {
          "line": 3165,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(fPruneMode && nManualPruneHeight > 0)",
          "old_line_content": "",
          "new_line_content": "    assert(fPruneMode && nManualPruneHeight > 0);",
          "content_same": false
        },
        {
          "line": 3167,
          "old_api": null,
          "new_api": "LOCK2",
          "old_text": null,
          "new_text": "LOCK2(cs_main, cs_LastBlockFile)",
          "old_line_content": "static void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight)",
          "new_line_content": "    LOCK2(cs_main, cs_LastBlockFile);",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": null,
          "new_api": "IsCoinBase",
          "old_text": null,
          "new_text": "tx.IsCoinBase()",
          "old_line_content": "",
          "new_line_content": "    if (!tx.IsCoinBase()) {",
          "content_same": false
        },
        {
          "line": 1121,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "tx.vin.size()",
          "old_line_content": "void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, CTxUndo &txundo, int nHeight)",
          "new_line_content": "        txundo.vprevout.reserve(tx.vin.size());",
          "content_same": false
        },
        {
          "line": 3168,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "{",
          "new_line_content": "    if (chainActive.Tip() == NULL)",
          "content_same": false
        },
        {
          "line": 1123,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "txundo.vprevout.emplace_back()",
          "old_line_content": "    // mark inputs spent",
          "new_line_content": "            txundo.vprevout.emplace_back();",
          "content_same": false
        },
        {
          "line": 3177,
          "old_api": null,
          "new_api": "PruneOneBlockFile",
          "old_text": null,
          "new_text": "PruneOneBlockFile(fileNumber)",
          "old_line_content": "    int count=0;",
          "new_line_content": "        PruneOneBlockFile(fileNumber);",
          "content_same": false
        },
        {
          "line": 3178,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "setFilesToPrune.insert(fileNumber)",
          "old_line_content": "    for (int fileNumber = 0; fileNumber < nLastBlockFile; fileNumber++) {",
          "new_line_content": "        setFilesToPrune.insert(fileNumber);",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": null,
          "new_api": "UpdateCoins",
          "old_text": null,
          "new_text": "UpdateCoins(tx, inputs, txundo, nHeight)",
          "old_line_content": "",
          "new_line_content": "    UpdateCoins(tx, inputs, txundo, nHeight);",
          "content_same": false
        },
        {
          "line": 3188,
          "old_api": null,
          "new_api": "Params",
          "old_text": null,
          "new_text": "Params()",
          "old_line_content": "/* This function is called from the RPC code for pruneblockchain */",
          "new_line_content": "    const CChainParams& chainparams = Params();",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": null,
          "new_api": "CachingTransactionSignatureChecker",
          "old_text": null,
          "new_text": "CachingTransactionSignatureChecker(ptxTo, nIn, amount, cacheStore, *txdata)",
          "old_line_content": "",
          "new_line_content": "    return VerifyScript(scriptSig, scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, amount, cacheStore, *txdata), &error);",
          "content_same": false
        },
        {
          "line": 3189,
          "old_api": null,
          "new_api": "FlushStateToDisk",
          "old_text": null,
          "new_text": "FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE, nManualPruneHeight)",
          "old_line_content": "void PruneBlockFilesManual(int nManualPruneHeight)",
          "new_line_content": "    FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE, nManualPruneHeight);",
          "content_same": false
        },
        {
          "line": 1146,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "}",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1147,
          "old_api": null,
          "new_api": "GetBestBlock",
          "old_text": null,
          "new_text": "inputs.GetBestBlock()",
          "old_line_content": "",
          "new_line_content": "    CBlockIndex* pindexPrev = mapBlockIndex.find(inputs.GetBestBlock())->second;",
          "content_same": false
        },
        {
          "line": 1158,
          "old_api": null,
          "new_api": "IsCoinBase",
          "old_text": null,
          "new_text": "tx.IsCoinBase()",
          "old_line_content": " * instead of being performed inline.",
          "new_line_content": "    if (!tx.IsCoinBase())",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": null,
          "new_api": "GetSpendHeight",
          "old_text": null,
          "new_text": "GetSpendHeight(inputs)",
          "old_line_content": "static bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)",
          "new_line_content": "        if (!Consensus::CheckTxInputs(tx, state, inputs, GetSpendHeight(inputs)))",
          "content_same": false
        },
        {
          "line": 3209,
          "old_api": null,
          "new_api": "LOCK2",
          "old_text": null,
          "new_text": "LOCK2(cs_main, cs_LastBlockFile)",
          "old_line_content": " * @param[out]   setFilesToPrune   The set of file indices that can be unlinked will be returned",
          "new_line_content": "    LOCK2(cs_main, cs_LastBlockFile);",
          "content_same": false
        },
        {
          "line": 3210,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": " */",
          "new_line_content": "    if (chainActive.Tip() == NULL || nPruneTarget == 0) {",
          "content_same": false
        },
        {
          "line": 3218,
          "old_api": null,
          "new_api": "CalculateCurrentUsage",
          "old_text": null,
          "new_text": "CalculateCurrentUsage()",
          "old_line_content": "        return;",
          "new_line_content": "    uint64_t nCurrentUsage = CalculateCurrentUsage();",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "tx.vin.size()",
          "old_line_content": "        // is safe because block merkle hashes are still computed and checked,",
          "new_line_content": "            for (unsigned int i = 0; i < tx.vin.size(); i++) {",
          "content_same": false
        },
        {
          "line": 1178,
          "old_api": null,
          "new_api": "AccessCoin",
          "old_text": null,
          "new_text": "inputs.AccessCoin(prevout)",
          "old_line_content": "        // this optimization would allow an invalid chain to be accepted.",
          "new_line_content": "                const Coin& coin = inputs.AccessCoin(prevout);",
          "content_same": false
        },
        {
          "line": 1179,
          "old_api": null,
          "new_api": "IsSpent",
          "old_text": null,
          "new_text": "coin.IsSpent()",
          "old_line_content": "        if (fScriptChecks) {",
          "new_line_content": "                assert(!coin.IsSpent());",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": null,
          "new_api": "CScriptCheck",
          "old_text": null,
          "new_text": "CScriptCheck()",
          "old_line_content": "",
          "new_line_content": "                    pvChecks->push_back(CScriptCheck());",
          "content_same": false
        },
        {
          "line": 1193,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "pvChecks->back()",
          "old_line_content": "                // Verify signature",
          "new_line_content": "                    check.swap(pvChecks->back());",
          "content_same": false
        },
        {
          "line": 1194,
          "old_api": null,
          "new_api": "check",
          "old_text": null,
          "new_text": "check()",
          "old_line_content": "                CScriptCheck check(scriptPubKey, amount, tx, i, flags, cacheStore, &txdata);",
          "new_line_content": "                } else if (!check()) {",
          "content_same": false
        },
        {
          "line": 3240,
          "old_api": null,
          "new_api": "PruneOneBlockFile",
          "old_text": null,
          "new_text": "PruneOneBlockFile(fileNumber)",
          "old_line_content": "            // don't prune files that could have a block within MIN_BLOCKS_TO_KEEP of the main chain's tip but keep scanning",
          "new_line_content": "            PruneOneBlockFile(fileNumber);",
          "content_same": false
        },
        {
          "line": 3242,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "setFilesToPrune.insert(fileNumber)",
          "old_line_content": "                continue;",
          "new_line_content": "            setFilesToPrune.insert(fileNumber);",
          "content_same": false
        },
        {
          "line": 3248,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::PRUNE, \"Prune: target=%dMiB actual=%dMiB diff=%dMiB max_prune_height=%d removed %d blk/rev pairs\\n\",\n           nPruneTarget/1024/1024, nCurrentUsage/1024/1024,\n           ((int64_t)nPruneTarget - (int64_t)nCurrentUsage)/1024/1024,\n           nLastBlockWeCanPrune, count)",
          "old_line_content": "            count++;",
          "new_line_content": "    LogPrint(BCLog::PRUNE, \"Prune: target=%dMiB actual=%dMiB diff=%dMiB max_prune_height=%d removed %d blk/rev pairs\\n\",",
          "content_same": false
        },
        {
          "line": 1204,
          "old_api": null,
          "new_api": "check2",
          "old_text": null,
          "new_text": "check2()",
          "old_line_content": "                        // avoid splitting the network between upgraded and",
          "new_line_content": "                        if (check2())",
          "content_same": false
        },
        {
          "line": 1205,
          "old_api": null,
          "new_api": "GetScriptError",
          "old_text": null,
          "new_text": "check.GetScriptError()",
          "old_line_content": "                        // non-upgraded nodes.",
          "new_line_content": "                            return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));",
          "content_same": false
        },
        {
          "line": 3256,
          "old_api": null,
          "new_api": "GetDataDir",
          "old_text": null,
          "new_text": "GetDataDir()",
          "old_line_content": "}",
          "new_line_content": "    uint64_t nFreeBytesAvailable = fs::space(GetDataDir()).available;",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": null,
          "new_api": "GetScriptError",
          "old_text": null,
          "new_text": "check.GetScriptError()",
          "old_line_content": "                    // said during an upgrade careful thought should be taken",
          "new_line_content": "                    return state.DoS(100,false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));",
          "content_same": false
        },
        {
          "line": 3267,
          "old_api": null,
          "new_api": "IsNull",
          "old_text": null,
          "new_text": "pos.IsNull()",
          "old_line_content": "}",
          "new_line_content": "    if (pos.IsNull())",
          "content_same": false
        },
        {
          "line": 3269,
          "old_api": null,
          "new_api": "GetBlockPosFilename",
          "old_text": null,
          "new_text": "GetBlockPosFilename(pos, prefix)",
          "old_line_content": "static FILE* OpenDiskFile(const CDiskBlockPos &pos, const char *prefix, bool fReadOnly)",
          "new_line_content": "    fs::path path = GetBlockPosFilename(pos, prefix);",
          "content_same": false
        },
        {
          "line": 3270,
          "old_api": null,
          "new_api": "parent_path",
          "old_text": null,
          "new_text": "path.parent_path()",
          "old_line_content": "{",
          "new_line_content": "    fs::create_directories(path.parent_path());",
          "content_same": false
        },
        {
          "line": 1229,
          "old_api": null,
          "new_api": "IsNull",
          "old_text": null,
          "new_text": "fileout.IsNull()",
          "old_line_content": "bool UndoWriteToDisk(const CBlockUndo& blockundo, CDiskBlockPos& pos, const uint256& hashBlock, const CMessageHeader::MessageStartChars& messageStart)",
          "new_line_content": "    if (fileout.IsNull())",
          "content_same": false
        },
        {
          "line": 1230,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"%s: OpenUndoFile failed\", __func__)",
          "old_line_content": "{",
          "new_line_content": "        return error(\"%s: OpenUndoFile failed\", __func__);",
          "content_same": false
        },
        {
          "line": 3280,
          "old_api": null,
          "new_api": "string",
          "old_text": null,
          "new_text": "path.string()",
          "old_line_content": "        return NULL;",
          "new_line_content": "            LogPrintf(\"Unable to seek to position %u of %s\\n\", pos.nPos, path.string());",
          "content_same": false
        },
        {
          "line": 3281,
          "old_api": null,
          "new_api": "fclose",
          "old_text": null,
          "new_text": "fclose(file)",
          "old_line_content": "    }",
          "new_line_content": "            fclose(file);",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"%s: ftell failed\", __func__)",
          "old_line_content": "",
          "new_line_content": "        return error(\"%s: ftell failed\", __func__);",
          "content_same": false
        },
        {
          "line": 3289,
          "old_api": null,
          "new_api": "OpenDiskFile",
          "old_text": null,
          "new_text": "OpenDiskFile(pos, \"blk\", fReadOnly)",
          "old_line_content": "    return file;",
          "new_line_content": "    return OpenDiskFile(pos, \"blk\", fReadOnly);",
          "content_same": false
        },
        {
          "line": 3294,
          "old_api": null,
          "new_api": "OpenDiskFile",
          "old_text": null,
          "new_text": "OpenDiskFile(pos, \"rev\", fReadOnly)",
          "old_line_content": "}",
          "new_line_content": "    return OpenDiskFile(pos, \"rev\", fReadOnly);",
          "content_same": false
        },
        {
          "line": 1247,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "hasher.GetHash()",
          "old_line_content": "    // calculate & write checksum",
          "new_line_content": "    fileout << hasher.GetHash();",
          "content_same": false
        },
        {
          "line": 3299,
          "old_api": null,
          "new_api": "strprintf",
          "old_text": null,
          "new_text": "strprintf(\"%s%05u.dat\", prefix, pos.nFile)",
          "old_line_content": "}",
          "new_line_content": "    return GetDataDir() / \"blocks\" / strprintf(\"%s%05u.dat\", prefix, pos.nFile);",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": null,
          "new_api": "IsNull",
          "old_text": null,
          "new_text": "filein.IsNull()",
          "old_line_content": "bool UndoReadFromDisk(CBlockUndo& blockundo, const CDiskBlockPos& pos, const uint256& hashBlock)",
          "new_line_content": "    if (filein.IsNull())",
          "content_same": false
        },
        {
          "line": 1257,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"%s: OpenUndoFile failed\", __func__)",
          "old_line_content": "{",
          "new_line_content": "        return error(\"%s: OpenUndoFile failed\", __func__);",
          "content_same": false
        },
        {
          "line": 3304,
          "old_api": null,
          "new_api": "IsNull",
          "old_text": null,
          "new_text": "hash.IsNull()",
          "old_line_content": "}",
          "new_line_content": "    if (hash.IsNull())",
          "content_same": false
        },
        {
          "line": 3309,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapBlockIndex.end()",
          "old_line_content": "        return NULL;",
          "new_line_content": "    if (mi != mapBlockIndex.end())",
          "content_same": false
        },
        {
          "line": 3315,
          "old_api": null,
          "new_api": "std::string(__func__)",
          "old_text": null,
          "new_text": "std::string(__func__)",
          "old_line_content": "",
          "new_line_content": "        throw std::runtime_error(std::string(__func__) + \": new CBlockIndex failed\");",
          "content_same": false
        },
        {
          "line": 1268,
          "old_api": null,
          "new_api": "what",
          "old_text": null,
          "new_text": "e.what()",
          "old_line_content": "        verifier >> blockundo;",
          "new_line_content": "        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());",
          "content_same": false
        },
        {
          "line": 3316,
          "old_api": null,
          "new_api": "std::make_pair(hash, pindexNew)",
          "old_text": null,
          "new_text": "std::make_pair(hash, pindexNew)",
          "old_line_content": "    // Create new",
          "new_line_content": "    mi = mapBlockIndex.insert(std::make_pair(hash, pindexNew)).first;",
          "content_same": false
        },
        {
          "line": 1273,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"%s: Checksum mismatch\", __func__)",
          "old_line_content": "    }",
          "new_line_content": "        return error(\"%s: Checksum mismatch\", __func__);",
          "content_same": false
        },
        {
          "line": 3324,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "}",
          "new_line_content": "    if (!pblocktree->LoadBlockIndexGuts(chainparams.GetConsensus(), InsertBlockIndex))",
          "content_same": false
        },
        {
          "line": 3327,
          "old_api": null,
          "new_api": "boost::this_thread::interruption_point()",
          "old_text": null,
          "new_text": "boost::this_thread::interruption_point()",
          "old_line_content": "{",
          "new_line_content": "    boost::this_thread::interruption_point();",
          "content_same": false
        },
        {
          "line": 1281,
          "old_api": null,
          "new_api": "SetMiscWarning",
          "old_text": null,
          "new_text": "SetMiscWarning(strMessage)",
          "old_line_content": "",
          "new_line_content": "    SetMiscWarning(strMessage);",
          "content_same": false
        },
        {
          "line": 1282,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"*** %s\\n\", strMessage)",
          "old_line_content": "/** Abort with a message */",
          "new_line_content": "    LogPrintf(\"*** %s\\n\", strMessage);",
          "content_same": false
        },
        {
          "line": 1283,
          "old_api": null,
          "new_api": "ThreadSafeMessageBox",
          "old_text": null,
          "new_text": "uiInterface.ThreadSafeMessageBox(\n        userMessage.empty() ? _(\"Error: A fatal internal error occurred, see debug.log for details\") : userMessage,\n        \"\", CClientUIInterface::MSG_ERROR)",
          "old_line_content": "bool AbortNode(const std::string& strMessage, const std::string& userMessage=\"\")",
          "new_line_content": "    uiInterface.ThreadSafeMessageBox(",
          "content_same": false
        },
        {
          "line": 1284,
          "old_api": null,
          "new_api": "_",
          "old_text": null,
          "new_text": "_(\"Error: A fatal internal error occurred, see debug.log for details\")",
          "old_line_content": "{",
          "new_line_content": "        userMessage.empty() ? _(\"Error: A fatal internal error occurred, see debug.log for details\") : userMessage,",
          "content_same": false
        },
        {
          "line": 3337,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "vSortedByHeight.end()",
          "old_line_content": "    {",
          "new_line_content": "    sort(vSortedByHeight.begin(), vSortedByHeight.end());",
          "content_same": false
        },
        {
          "line": 1292,
          "old_api": null,
          "new_api": "AbortNode",
          "old_text": null,
          "new_text": "AbortNode(strMessage, userMessage)",
          "old_line_content": "}",
          "new_line_content": "    AbortNode(strMessage, userMessage);",
          "content_same": false
        },
        {
          "line": 1293,
          "old_api": null,
          "new_api": "Error",
          "old_text": null,
          "new_text": "state.Error(strMessage)",
          "old_line_content": "",
          "new_line_content": "    return state.Error(strMessage);",
          "content_same": false
        },
        {
          "line": 3342,
          "old_api": null,
          "new_api": "std::max(pindex->pprev->nTimeMax, pindex->nTime)",
          "old_text": null,
          "new_text": "std::max(pindex->pprev->nTimeMax, pindex->nTime)",
          "old_line_content": "    for (const std::pair<int, CBlockIndex*>& item : vSortedByHeight)",
          "new_line_content": "        pindex->nTimeMax = (pindex->pprev ? std::max(pindex->pprev->nTimeMax, pindex->nTime) : pindex->nTime);",
          "content_same": false
        },
        {
          "line": 3351,
          "old_api": null,
          "new_api": "std::make_pair(pindex->pprev, pindex)",
          "old_text": null,
          "new_text": "std::make_pair(pindex->pprev, pindex)",
          "old_line_content": "                if (pindex->pprev->nChainTx) {",
          "new_line_content": "                    mapBlocksUnlinked.insert(std::make_pair(pindex->pprev, pindex));",
          "content_same": false
        },
        {
          "line": 3357,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "pindex->IsValid(BLOCK_VALID_TRANSACTIONS)",
          "old_line_content": "            } else {",
          "new_line_content": "        if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->nChainTx || pindex->pprev == NULL))",
          "content_same": false
        },
        {
          "line": 3358,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "setBlockIndexCandidates.insert(pindex)",
          "old_line_content": "                pindex->nChainTx = pindex->nTx;",
          "new_line_content": "            setBlockIndexCandidates.insert(pindex);",
          "content_same": false
        },
        {
          "line": 3363,
          "old_api": null,
          "new_api": "CBlockIndexWorkComparator",
          "old_text": null,
          "new_text": "CBlockIndexWorkComparator()(pindexBestHeader, pindex)",
          "old_line_content": "        if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->nChainWork > pindexBestInvalid->nChainWork))",
          "new_line_content": "        if (pindex->IsValid(BLOCK_VALID_TREE) && (pindexBestHeader == NULL || CBlockIndexWorkComparator()(pindexBestHeader, pindex)))",
          "content_same": false
        },
        {
          "line": 1316,
          "old_api": null,
          "new_api": "HaveCoin",
          "old_text": null,
          "new_text": "view.HaveCoin(out)",
          "old_line_content": "int ApplyTxInUndo(Coin&& undo, CCoinsViewCache& view, const COutPoint& out)",
          "new_line_content": "    if (view.HaveCoin(out)) fClean = false; // overwriting transaction output",
          "content_same": false
        },
        {
          "line": 3368,
          "old_api": null,
          "new_api": "ReadLastBlockFile",
          "old_text": null,
          "new_text": "pblocktree->ReadLastBlockFile(nLastBlockFile)",
          "old_line_content": "            pindexBestHeader = pindex;",
          "new_line_content": "    pblocktree->ReadLastBlockFile(nLastBlockFile);",
          "content_same": false
        },
        {
          "line": 3369,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "vinfoBlockFile.resize(nLastBlockFile + 1)",
          "old_line_content": "    }",
          "new_line_content": "    vinfoBlockFile.resize(nLastBlockFile + 1);",
          "content_same": false
        },
        {
          "line": 1322,
          "old_api": null,
          "new_api": "AccessByTxid",
          "old_text": null,
          "new_text": "AccessByTxid(view, out.hash)",
          "old_line_content": "    if (undo.nHeight == 0) {",
          "new_line_content": "        const Coin& alternate = AccessByTxid(view, out.hash);",
          "content_same": false
        },
        {
          "line": 1323,
          "old_api": null,
          "new_api": "IsSpent",
          "old_text": null,
          "new_text": "alternate.IsSpent()",
          "old_line_content": "        // Missing undo metadata (height and coinbase). Older versions included this",
          "new_line_content": "        if (!alternate.IsSpent()) {",
          "content_same": false
        },
        {
          "line": 3370,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"%s: last block file = %i\\n\", __func__, nLastBlockFile)",
          "old_line_content": "",
          "new_line_content": "    LogPrintf(\"%s: last block file = %i\\n\", __func__, nLastBlockFile);",
          "content_same": false
        },
        {
          "line": 3377,
          "old_api": null,
          "new_api": "ReadBlockFileInfo",
          "old_text": null,
          "new_text": "pblocktree->ReadBlockFileInfo(nFile, info)",
          "old_line_content": "    }",
          "new_line_content": "        if (pblocktree->ReadBlockFileInfo(nFile, info)) {",
          "content_same": false
        },
        {
          "line": 1330,
          "old_api": null,
          "new_api": "std::move(undo)",
          "old_text": null,
          "new_text": "std::move(undo)",
          "old_line_content": "        } else {",
          "new_line_content": "    view.AddCoin(out, std::move(undo), undo.fCoinBase);",
          "content_same": false
        },
        {
          "line": 3385,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"Checking all blk files are present...\\n\")",
          "old_line_content": "        }",
          "new_line_content": "    LogPrintf(\"Checking all blk files are present...\\n\");",
          "content_same": false
        },
        {
          "line": 1339,
          "old_api": null,
          "new_api": "GetBestBlock",
          "old_text": null,
          "new_text": "view.GetBestBlock()",
          "old_line_content": "/** Undo the effects of this block (with given index) on the UTXO set represented by coins.",
          "new_line_content": "    assert(pindex->GetBlockHash() == view.GetBestBlock());",
          "content_same": false
        },
        {
          "line": 3391,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "setBlkDataFiles.insert(pindex->nFile)",
          "old_line_content": "    for (const std::pair<uint256, CBlockIndex*>& item : mapBlockIndex)",
          "new_line_content": "            setBlkDataFiles.insert(pindex->nFile);",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": null,
          "new_api": "GetUndoPos",
          "old_text": null,
          "new_text": "pindex->GetUndoPos()",
          "old_line_content": "",
          "new_line_content": "    CDiskBlockPos pos = pindex->GetUndoPos();",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": null,
          "new_api": "IsNull",
          "old_text": null,
          "new_text": "pos.IsNull()",
          "old_line_content": "    bool fClean = true;",
          "new_line_content": "    if (pos.IsNull()) {",
          "content_same": false
        },
        {
          "line": 1346,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"DisconnectBlock(): no undo data available\")",
          "old_line_content": "",
          "new_line_content": "        error(\"DisconnectBlock(): no undo data available\");",
          "content_same": false
        },
        {
          "line": 3394,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "setBlkDataFiles.end()",
          "old_line_content": "        if (pindex->nStatus & BLOCK_HAVE_DATA) {",
          "new_line_content": "    for (std::set<int>::iterator it = setBlkDataFiles.begin(); it != setBlkDataFiles.end(); it++)",
          "content_same": false
        },
        {
          "line": 3397,
          "old_api": null,
          "new_api": "OpenBlockFile",
          "old_text": null,
          "new_text": "OpenBlockFile(pos, true)",
          "old_line_content": "    }",
          "new_line_content": "        if (CAutoFile(OpenBlockFile(pos, true), SER_DISK, CLIENT_VERSION).IsNull()) {",
          "content_same": false
        },
        {
          "line": 1355,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"DisconnectBlock(): block and undo data inconsistent\")",
          "old_line_content": "        return DISCONNECT_FAILED;",
          "new_line_content": "        error(\"DisconnectBlock(): block and undo data inconsistent\");",
          "content_same": false
        },
        {
          "line": 3403,
          "old_api": null,
          "new_api": "ReadFlag",
          "old_text": null,
          "new_text": "pblocktree->ReadFlag(\"prunedblockfiles\", fHavePruned)",
          "old_line_content": "        }",
          "new_line_content": "    pblocktree->ReadFlag(\"prunedblockfiles\", fHavePruned);",
          "content_same": false
        },
        {
          "line": 3405,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"LoadBlockIndexDB(): Block files have previously been pruned\\n\")",
          "old_line_content": "",
          "new_line_content": "        LogPrintf(\"LoadBlockIndexDB(): Block files have previously been pruned\\n\");",
          "content_same": false
        },
        {
          "line": 1360,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "block.vtx.size()",
          "old_line_content": "        return DISCONNECT_FAILED;",
          "new_line_content": "    for (int i = block.vtx.size() - 1; i >= 0; i--) {",
          "content_same": false
        },
        {
          "line": 1362,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "tx.GetHash()",
          "old_line_content": "",
          "new_line_content": "        uint256 hash = tx.GetHash();",
          "content_same": false
        },
        {
          "line": 3414,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"%s: transaction index %s\\n\", __func__, fTxIndex ? \"enabled\" : \"disabled\")",
          "old_line_content": "    fReindex |= fReindexing;",
          "new_line_content": "    LogPrintf(\"%s: transaction index %s\\n\", __func__, fTxIndex ? \"enabled\" : \"disabled\");",
          "content_same": false
        },
        {
          "line": 1367,
          "old_api": null,
          "new_api": "IsUnspendable",
          "old_text": null,
          "new_text": "tx.vout[o].scriptPubKey.IsUnspendable()",
          "old_line_content": "",
          "new_line_content": "            if (!tx.vout[o].scriptPubKey.IsUnspendable()) {",
          "content_same": false
        },
        {
          "line": 3420,
          "old_api": null,
          "new_api": "SetTip",
          "old_text": null,
          "new_text": "chainActive.SetTip(it->second)",
          "old_line_content": "    // Load pointer to end of best chain",
          "new_line_content": "    chainActive.SetTip(it->second);",
          "content_same": false
        },
        {
          "line": 3425,
          "old_api": null,
          "new_api": "Height",
          "old_text": null,
          "new_text": "chainActive.Height()",
          "old_line_content": "",
          "new_line_content": "        chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(),",
          "content_same": false
        },
        {
          "line": 3427,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "",
          "new_line_content": "        GuessVerificationProgress(chainparams.TxData(), chainActive.Tip()));",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "tx.vin.size()",
          "old_line_content": "",
          "new_line_content": "            if (txundo.vprevout.size() != tx.vin.size()) {",
          "content_same": false
        },
        {
          "line": 1381,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"DisconnectBlock(): transaction and undo data inconsistent\")",
          "old_line_content": "        // restore inputs",
          "new_line_content": "                error(\"DisconnectBlock(): transaction and undo data inconsistent\");",
          "content_same": false
        },
        {
          "line": 1386,
          "old_api": null,
          "new_api": "std::move(txundo.vprevout[j])",
          "old_text": null,
          "new_text": "std::move(txundo.vprevout[j])",
          "old_line_content": "                return DISCONNECT_FAILED;",
          "new_line_content": "                int res = ApplyTxInUndo(std::move(txundo.vprevout[j]), view, out);",
          "content_same": false
        },
        {
          "line": 3434,
          "old_api": null,
          "new_api": "_",
          "old_text": null,
          "new_text": "_(\"Verifying blocks...\")",
          "old_line_content": "}",
          "new_line_content": "    uiInterface.ShowProgress(_(\"Verifying blocks...\"), 0);",
          "content_same": false
        },
        {
          "line": 3439,
          "old_api": null,
          "new_api": "ShowProgress",
          "old_text": null,
          "new_text": "uiInterface.ShowProgress(\"\", 100)",
          "old_line_content": "}",
          "new_line_content": "    uiInterface.ShowProgress(\"\", 100);",
          "content_same": false
        },
        {
          "line": 1395,
          "old_api": null,
          "new_api": "GetBlockHash",
          "old_text": null,
          "new_text": "pindex->pprev->GetBlockHash()",
          "old_line_content": "        }",
          "new_line_content": "    view.SetBestBlock(pindex->pprev->GetBlockHash());",
          "content_same": false
        },
        {
          "line": 3444,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "}",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 3445,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "",
          "new_line_content": "    if (chainActive.Tip() == NULL || chainActive.Tip()->pprev == NULL)",
          "content_same": false
        },
        {
          "line": 1402,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_LastBlockFile)",
          "old_line_content": "}",
          "new_line_content": "    LOCK(cs_LastBlockFile);",
          "content_same": false
        },
        {
          "line": 3451,
          "old_api": null,
          "new_api": "Height",
          "old_text": null,
          "new_text": "chainActive.Height()",
          "old_line_content": "",
          "new_line_content": "    if (nCheckDepth > chainActive.Height())",
          "content_same": false
        },
        {
          "line": 3452,
          "old_api": null,
          "new_api": "Height",
          "old_text": null,
          "new_text": "chainActive.Height()",
          "old_line_content": "    // Verify blocks in the best chain",
          "new_line_content": "        nCheckDepth = chainActive.Height();",
          "content_same": false
        },
        {
          "line": 3453,
          "old_api": null,
          "new_api": "std::min(4, nCheckLevel)",
          "old_text": null,
          "new_text": "std::min(4, nCheckLevel)",
          "old_line_content": "    if (nCheckDepth <= 0)",
          "new_line_content": "    nCheckLevel = std::max(0, std::min(4, nCheckLevel));",
          "content_same": false
        },
        {
          "line": 3454,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel)",
          "old_line_content": "        nCheckDepth = 1000000000; // suffices until the year 19000",
          "new_line_content": "    LogPrintf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);",
          "content_same": false
        },
        {
          "line": 1409,
          "old_api": null,
          "new_api": "TruncateFile",
          "old_text": null,
          "new_text": "TruncateFile(fileOld, vinfoBlockFile[nLastBlockFile].nSize)",
          "old_line_content": "",
          "new_line_content": "            TruncateFile(fileOld, vinfoBlockFile[nLastBlockFile].nSize);",
          "content_same": false
        },
        {
          "line": 1411,
          "old_api": null,
          "new_api": "fclose",
          "old_text": null,
          "new_text": "fclose(fileOld)",
          "old_line_content": "    if (fileOld) {",
          "new_line_content": "        fclose(fileOld);",
          "content_same": false
        },
        {
          "line": 3461,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"[0%%]...\")",
          "old_line_content": "    CBlockIndex* pindexFailure = NULL;",
          "new_line_content": "    LogPrintf(\"[0%%]...\");",
          "content_same": false
        },
        {
          "line": 3462,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "    int nGoodTransactions = 0;",
          "new_line_content": "    for (CBlockIndex* pindex = chainActive.Tip(); pindex && pindex->pprev; pindex = pindex->pprev)",
          "content_same": false
        },
        {
          "line": 3464,
          "old_api": null,
          "new_api": "boost::this_thread::interruption_point()",
          "old_text": null,
          "new_text": "boost::this_thread::interruption_point()",
          "old_line_content": "    int reportDone = 0;",
          "new_line_content": "        boost::this_thread::interruption_point();",
          "content_same": false
        },
        {
          "line": 1417,
          "old_api": null,
          "new_api": "TruncateFile",
          "old_text": null,
          "new_text": "TruncateFile(fileOld, vinfoBlockFile[nLastBlockFile].nUndoSize)",
          "old_line_content": "",
          "new_line_content": "            TruncateFile(fileOld, vinfoBlockFile[nLastBlockFile].nUndoSize);",
          "content_same": false
        },
        {
          "line": 1419,
          "old_api": null,
          "new_api": "fclose",
          "old_text": null,
          "new_text": "fclose(fileOld)",
          "old_line_content": "    if (fileOld) {",
          "new_line_content": "        fclose(fileOld);",
          "content_same": false
        },
        {
          "line": 3471,
          "old_api": null,
          "new_api": "_",
          "old_text": null,
          "new_text": "_(\"Verifying blocks...\")",
          "old_line_content": "            // report every 10% step",
          "new_line_content": "        uiInterface.ShowProgress(_(\"Verifying blocks...\"), percentageDone);",
          "content_same": false
        },
        {
          "line": 1428,
          "old_api": null,
          "new_api": "RenameThread",
          "old_text": null,
          "new_text": "RenameThread(\"bitcoin-scriptch\")",
          "old_line_content": "",
          "new_line_content": "    RenameThread(\"bitcoin-scriptch\");",
          "content_same": false
        },
        {
          "line": 1429,
          "old_api": null,
          "new_api": "Thread",
          "old_text": null,
          "new_text": "scriptcheckqueue.Thread()",
          "old_line_content": "static CCheckQueue<CScriptCheck> scriptcheckqueue(128);",
          "new_line_content": "    scriptcheckqueue.Thread();",
          "content_same": false
        },
        {
          "line": 3481,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "            break;",
          "new_line_content": "        if (!ReadBlockFromDisk(block, pindex, chainparams.GetConsensus()))",
          "content_same": false
        },
        {
          "line": 3482,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pindex->GetBlockHash().ToString()",
          "old_line_content": "        }",
          "new_line_content": "            return error(\"VerifyDB(): *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());",
          "content_same": false
        },
        {
          "line": 3484,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "        // check level 0: read from disk",
          "new_line_content": "        if (nCheckLevel >= 1 && !CheckBlock(block, state, chainparams.GetConsensus()))",
          "content_same": false
        },
        {
          "line": 1437,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "VersionBitsCache versionbitscache;",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1443,
          "old_api": null,
          "new_api": "VersionBitsMask",
          "old_text": null,
          "new_text": "VersionBitsMask(params, (Consensus::DeploymentPos)i)",
          "old_line_content": "",
          "new_line_content": "            nVersion |= VersionBitsMask(params, (Consensus::DeploymentPos)i);",
          "content_same": false
        },
        {
          "line": 3491,
          "old_api": null,
          "new_api": "IsNull",
          "old_text": null,
          "new_text": "pos.IsNull()",
          "old_line_content": "        // check level 2: verify undo validity",
          "new_line_content": "            if (!pos.IsNull()) {",
          "content_same": false
        },
        {
          "line": 3492,
          "old_api": null,
          "new_api": "GetBlockHash",
          "old_text": null,
          "new_text": "pindex->pprev->GetBlockHash()",
          "old_line_content": "        if (nCheckLevel >= 2 && pindex) {",
          "new_line_content": "                if (!UndoReadFromDisk(undo, pos, pindex->pprev->GetBlockHash()))",
          "content_same": false
        },
        {
          "line": 3493,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pindex->GetBlockHash().ToString()",
          "old_line_content": "            CBlockUndo undo;",
          "new_line_content": "                    return error(\"VerifyDB(): *** found bad undo data at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());",
          "content_same": false
        },
        {
          "line": 3498,
          "old_api": null,
          "new_api": "DisconnectBlock",
          "old_text": null,
          "new_text": "DisconnectBlock(block, pindex, coins)",
          "old_line_content": "            }",
          "new_line_content": "            DisconnectResult res = DisconnectBlock(block, pindex, coins);",
          "content_same": false
        },
        {
          "line": 3500,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pindex->GetBlockHash().ToString()",
          "old_line_content": "        // check level 3: check for inconsistencies during memory-only disconnect of tip blocks",
          "new_line_content": "                return error(\"VerifyDB(): *** irrecoverable inconsistency in block data at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());",
          "content_same": false
        },
        {
          "line": 3507,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "block.vtx.size()",
          "old_line_content": "            if (res == DISCONNECT_UNCLEAN) {",
          "new_line_content": "                nGoodTransactions += block.vtx.size();",
          "content_same": false
        },
        {
          "line": 1462,
          "old_api": null,
          "new_api": "std::numeric_limits<int64_t>::max()",
          "old_text": null,
          "new_text": "std::numeric_limits<int64_t>::max()",
          "old_line_content": "public:",
          "new_line_content": "    int64_t EndTime(const Consensus::Params& params) const { return std::numeric_limits<int64_t>::max(); }",
          "content_same": false
        },
        {
          "line": 3510,
          "old_api": null,
          "new_api": "ShutdownRequested",
          "old_text": null,
          "new_text": "ShutdownRequested()",
          "old_line_content": "            } else {",
          "new_line_content": "        if (ShutdownRequested())",
          "content_same": false
        },
        {
          "line": 1470,
          "old_api": null,
          "new_api": "ComputeBlockVersion",
          "old_text": null,
          "new_text": "ComputeBlockVersion(pindex->pprev, params)",
          "old_line_content": "    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const",
          "new_line_content": "               ((ComputeBlockVersion(pindex->pprev, params) >> bit) & 1) == 0;",
          "content_same": false
        },
        {
          "line": 3519,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "",
          "new_line_content": "        while (pindex != chainActive.Tip()) {",
          "content_same": false
        },
        {
          "line": 3520,
          "old_api": null,
          "new_api": "boost::this_thread::interruption_point()",
          "old_text": null,
          "new_text": "boost::this_thread::interruption_point()",
          "old_line_content": "    // check level 4: try reconnecting blocks",
          "new_line_content": "            boost::this_thread::interruption_point();",
          "content_same": false
        },
        {
          "line": 3521,
          "old_api": null,
          "new_api": "Height",
          "old_text": null,
          "new_text": "chainActive.Height()",
          "old_line_content": "    if (nCheckLevel >= 4) {",
          "new_line_content": "            uiInterface.ShowProgress(_(\"Verifying blocks...\"), std::max(1, std::min(99, 100 - (int)(((double)(chainActive.Height() - pindex->nHeight)) / (double)nCheckDepth * 50))));",
          "content_same": false
        },
        {
          "line": 3522,
          "old_api": null,
          "new_api": "Next",
          "old_text": null,
          "new_text": "chainActive.Next(pindex)",
          "old_line_content": "        CBlockIndex *pindex = pindexState;",
          "new_line_content": "            pindex = chainActive.Next(pindex);",
          "content_same": false
        },
        {
          "line": 3527,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pindex->GetBlockHash().ToString()",
          "old_line_content": "            CBlock block;",
          "new_line_content": "                return error(\"VerifyDB(): *** found unconnectable block at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());",
          "content_same": false
        },
        {
          "line": 3532,
          "old_api": null,
          "new_api": "Height",
          "old_text": null,
          "new_text": "chainActive.Height()",
          "old_line_content": "        }",
          "new_line_content": "    LogPrintf(\"No coin database inconsistencies in last %i blocks (%i transactions)\\n\", chainActive.Height() - pindexState->nHeight, nGoodTransactions);",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": null,
          "new_api": "AssertLockHeld",
          "old_text": null,
          "new_text": "AssertLockHeld(cs_main)",
          "old_line_content": " *  can fail if those validity checks fail (among other reasons). */",
          "new_line_content": "    AssertLockHeld(cs_main);",
          "content_same": false
        },
        {
          "line": 1492,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(pindex)",
          "old_line_content": "static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex,",
          "new_line_content": "    assert(pindex);",
          "content_same": false
        },
        {
          "line": 3539,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "}",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1494,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "assert((pindex->phashBlock == NULL) ||\n           (*pindex->phashBlock == block.GetHash()))",
          "old_line_content": "{",
          "new_line_content": "    assert((pindex->phashBlock == NULL) ||",
          "content_same": false
        },
        {
          "line": 3542,
          "old_api": null,
          "new_api": "Height",
          "old_text": null,
          "new_text": "chainActive.Height()",
          "old_line_content": "{",
          "new_line_content": "    while (nHeight <= chainActive.Height()) {",
          "content_same": false
        },
        {
          "line": 3551,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "    }",
          "new_line_content": "    CBlockIndex* pindex = chainActive.Tip();",
          "content_same": false
        },
        {
          "line": 3552,
          "old_api": null,
          "new_api": "Height",
          "old_text": null,
          "new_text": "chainActive.Height()",
          "old_line_content": "",
          "new_line_content": "    while (chainActive.Height() >= nHeight) {",
          "content_same": false
        },
        {
          "line": 3553,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "    // nHeight is now the height of the first insufficiently-validated block, or tipheight + 1",
          "new_line_content": "        if (fPruneMode && !(chainActive.Tip()->nStatus & BLOCK_HAVE_DATA)) {",
          "content_same": false
        },
        {
          "line": 1510,
          "old_api": null,
          "new_api": "GetBlockHash",
          "old_text": null,
          "new_text": "pindex->GetBlockHash()",
          "old_line_content": "    // Special case for the genesis block, skipping connection of its transactions",
          "new_line_content": "            view.SetBestBlock(pindex->GetBlockHash());",
          "content_same": false
        },
        {
          "line": 3561,
          "old_api": null,
          "new_api": "DisconnectTip",
          "old_text": null,
          "new_text": "DisconnectTip(state, params, NULL)",
          "old_line_content": "            // will fail (and require a needless reindex/redownload",
          "new_line_content": "        if (!DisconnectTip(state, params, NULL)) {",
          "content_same": false
        },
        {
          "line": 3562,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"RewindBlockIndex: unable to disconnect block at height %i\", pindex->nHeight)",
          "old_line_content": "            // of the blockchain).",
          "new_line_content": "            return error(\"RewindBlockIndex: unable to disconnect block at height %i\", pindex->nHeight);",
          "content_same": false
        },
        {
          "line": 1515,
          "old_api": null,
          "new_api": "IsNull",
          "old_text": null,
          "new_text": "hashAssumeValid.IsNull()",
          "old_line_content": "        return true;",
          "new_line_content": "    if (!hashAssumeValid.IsNull()) {",
          "content_same": false
        },
        {
          "line": 1521,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "mapBlockIndex.find(hashAssumeValid)",
          "old_line_content": "        // A suitable default value is included with the software and updated from time to time.  Because validity",
          "new_line_content": "        BlockMap::const_iterator  it = mapBlockIndex.find(hashAssumeValid);",
          "content_same": false
        },
        {
          "line": 1522,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapBlockIndex.end()",
          "old_line_content": "        //  relative to a piece of software is an objective fact these defaults can be easily reviewed.",
          "new_line_content": "        if (it != mapBlockIndex.end()) {",
          "content_same": false
        },
        {
          "line": 1523,
          "old_api": null,
          "new_api": "GetAncestor",
          "old_text": null,
          "new_text": "it->second->GetAncestor(pindex->nHeight)",
          "old_line_content": "        // This setting doesn't force the selection of any particular chain but makes validating some faster by",
          "new_line_content": "            if (it->second->GetAncestor(pindex->nHeight) == pindex &&",
          "content_same": false
        },
        {
          "line": 1524,
          "old_api": null,
          "new_api": "GetAncestor",
          "old_text": null,
          "new_text": "pindexBestHeader->GetAncestor(pindex->nHeight)",
          "old_line_content": "        //  effectively caching the result of part of the verification.",
          "new_line_content": "                pindexBestHeader->GetAncestor(pindex->nHeight) == pindex &&",
          "content_same": false
        },
        {
          "line": 3572,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapBlockIndex.end()",
          "old_line_content": "",
          "new_line_content": "    for (BlockMap::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); it++) {",
          "content_same": false
        },
        {
          "line": 3580,
          "old_api": null,
          "new_api": "Contains",
          "old_text": null,
          "new_text": "chainActive.Contains(pindexIter)",
          "old_line_content": "        // is on chainActive, it must be because we are a pruning node, and",
          "new_line_content": "        if (IsWitnessEnabled(pindexIter->pprev, params.GetConsensus()) && !(pindexIter->nStatus & BLOCK_OPT_WITNESS) && !chainActive.Contains(pindexIter)) {",
          "content_same": false
        },
        {
          "line": 3582,
          "old_api": null,
          "new_api": "std::min<unsigned int>(pindexIter->nStatus & BLOCK_VALID_MASK, BLOCK_VALID_TREE)",
          "old_text": null,
          "new_text": "std::min<unsigned int>(pindexIter->nStatus & BLOCK_VALID_MASK, BLOCK_VALID_TREE)",
          "old_line_content": "        // rewind all the way.  Blocks remaining on chainActive at this point",
          "new_line_content": "            pindexIter->nStatus = std::min<unsigned int>(pindexIter->nStatus & BLOCK_VALID_MASK, BLOCK_VALID_TREE) | (pindexIter->nStatus & ~BLOCK_VALID_MASK);",
          "content_same": false
        },
        {
          "line": 1535,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "                //  that are hardly doing any signature verification at all in testing without having to",
          "new_line_content": "                fScriptChecks = (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, chainparams.GetConsensus()) <= 60 * 60 * 24 * 7 * 2);",
          "content_same": false
        },
        {
          "line": 1540,
          "old_api": null,
          "new_api": "GetTimeMicros",
          "old_text": null,
          "new_text": "GetTimeMicros()",
          "old_line_content": "            }",
          "new_line_content": "    int64_t nTime1 = GetTimeMicros(); nTimeCheck += nTime1 - nTimeStart;",
          "content_same": false
        },
        {
          "line": 1541,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::BENCH, \"    - Sanity checks: %.2fms [%.2fs]\\n\", 0.001 * (nTime1 - nTimeStart), nTimeCheck * 0.000001)",
          "old_line_content": "        }",
          "new_line_content": "    LogPrint(BCLog::BENCH, \"    - Sanity checks: %.2fms [%.2fs]\\n\", 0.001 * (nTime1 - nTimeStart), nTimeCheck * 0.000001);",
          "content_same": false
        },
        {
          "line": 3594,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "setDirtyBlockIndex.insert(pindexIter)",
          "old_line_content": "            pindexIter->nTx = 0;",
          "new_line_content": "            setDirtyBlockIndex.insert(pindexIter);",
          "content_same": false
        },
        {
          "line": 3596,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "setBlockIndexCandidates.erase(pindexIter)",
          "old_line_content": "            pindexIter->nSequenceId = 0;",
          "new_line_content": "            setBlockIndexCandidates.erase(pindexIter);",
          "content_same": false
        },
        {
          "line": 3597,
          "old_api": null,
          "new_api": "equal_range",
          "old_text": null,
          "new_text": "mapBlocksUnlinked.equal_range(pindexIter->pprev)",
          "old_line_content": "            // Make sure it gets written.",
          "new_line_content": "            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> ret = mapBlocksUnlinked.equal_range(pindexIter->pprev);",
          "content_same": false
        },
        {
          "line": 1556,
          "old_api": null,
          "new_api": "uint256S",
          "old_text": null,
          "new_text": "uint256S(\"0x00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec\")",
          "old_line_content": "    // Now that the whole chain is irreversibly beyond that time it is applied to all blocks except the",
          "new_line_content": "                          !((pindex->nHeight==91842 && pindex->GetBlockHash() == uint256S(\"0x00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec\")) ||",
          "content_same": false
        },
        {
          "line": 1557,
          "old_api": null,
          "new_api": "uint256S",
          "old_text": null,
          "new_text": "uint256S(\"0x00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721\")",
          "old_line_content": "    // two in the chain that violate it. This prevents exploiting the issue against nodes during their",
          "new_line_content": "                           (pindex->nHeight==91880 && pindex->GetBlockHash() == uint256S(\"0x00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721\")));",
          "content_same": false
        },
        {
          "line": 3605,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "pindexIter->IsValid(BLOCK_VALID_TRANSACTIONS)",
          "old_line_content": "                } else {",
          "new_line_content": "        } else if (pindexIter->IsValid(BLOCK_VALID_TRANSACTIONS) && pindexIter->nChainTx) {",
          "content_same": false
        },
        {
          "line": 3606,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "setBlockIndexCandidates.insert(pindexIter)",
          "old_line_content": "                    ++ret.first;",
          "new_line_content": "            setBlockIndexCandidates.insert(pindexIter);",
          "content_same": false
        },
        {
          "line": 3612,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "params.GetConsensus()",
          "old_line_content": "    }",
          "new_line_content": "    CheckBlockIndex(params.GetConsensus());",
          "content_same": false
        },
        {
          "line": 1565,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "    // time BIP34 activated, in each of the existing pairs the duplicate coinbase had overwritten the first",
          "new_line_content": "    CBlockIndex *pindexBIP34height = pindex->pprev->GetAncestor(chainparams.GetConsensus().BIP34Height);",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "    // duplicate transactions descending from the known pairs either.",
          "new_line_content": "    fEnforceBIP30 = fEnforceBIP30 && (!pindexBIP34height || !(pindexBIP34height->GetBlockHash() == chainparams.GetConsensus().BIP34Hash));",
          "content_same": false
        },
        {
          "line": 1572,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "tx->GetHash()",
          "old_line_content": "",
          "new_line_content": "                if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {",
          "content_same": false
        },
        {
          "line": 1573,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"ConnectBlock(): tried to overwrite transaction\")",
          "old_line_content": "    if (fEnforceBIP30) {",
          "new_line_content": "                    return state.DoS(100, error(\"ConnectBlock(): tried to overwrite transaction\"),",
          "content_same": false
        },
        {
          "line": 3626,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "// of the peer-processing logic assumes a consistent",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 3627,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "setBlockIndexCandidates.clear()",
          "old_line_content": "// block index state",
          "new_line_content": "    setBlockIndexCandidates.clear();",
          "content_same": false
        },
        {
          "line": 3628,
          "old_api": null,
          "new_api": "SetTip",
          "old_text": null,
          "new_text": "chainActive.SetTip(NULL)",
          "old_line_content": "void UnloadBlockIndex()",
          "new_line_content": "    chainActive.SetTip(NULL);",
          "content_same": false
        },
        {
          "line": 1582,
          "old_api": null,
          "new_api": "GetBlockTime",
          "old_text": null,
          "new_text": "pindex->GetBlockTime()",
          "old_line_content": "    }",
          "new_line_content": "    bool fStrictPayToScriptHash = (pindex->GetBlockTime() >= nBIP16SwitchTime);",
          "content_same": false
        },
        {
          "line": 3633,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "vinfoBlockFile.clear()",
          "old_line_content": "    pindexBestInvalid = NULL;",
          "new_line_content": "    vinfoBlockFile.clear();",
          "content_same": false
        },
        {
          "line": 1587,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "",
          "new_line_content": "    if (pindex->nHeight >= chainparams.GetConsensus().BIP66Height) {",
          "content_same": false
        },
        {
          "line": 3638,
          "old_api": null,
          "new_api": "Clear",
          "old_text": null,
          "new_text": "versionbitscache.Clear()",
          "old_line_content": "    nLastBlockFile = 0;",
          "new_line_content": "    versionbitscache.Clear();",
          "content_same": false
        },
        {
          "line": 1592,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "        flags |= SCRIPT_VERIFY_DERSIG;",
          "new_line_content": "    if (pindex->nHeight >= chainparams.GetConsensus().BIP65Height) {",
          "content_same": false
        },
        {
          "line": 1598,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "    }",
          "new_line_content": "    if (VersionBitsState(pindex->pprev, chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {",
          "content_same": false
        },
        {
          "line": 3646,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "mapBlockIndex.clear()",
          "old_line_content": "",
          "new_line_content": "    mapBlockIndex.clear();",
          "content_same": false
        },
        {
          "line": 1604,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "        nLockTimeFlags |= LOCKTIME_VERIFY_SEQUENCE;",
          "new_line_content": "    if (IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus())) {",
          "content_same": false
        },
        {
          "line": 3653,
          "old_api": null,
          "new_api": "LoadBlockIndexDB",
          "old_text": null,
          "new_text": "LoadBlockIndexDB(chainparams)",
          "old_line_content": "",
          "new_line_content": "    if (!fReindex && !LoadBlockIndexDB(chainparams))",
          "content_same": false
        },
        {
          "line": 1609,
          "old_api": null,
          "new_api": "GetTimeMicros",
          "old_text": null,
          "new_text": "GetTimeMicros()",
          "old_line_content": "        flags |= SCRIPT_VERIFY_WITNESS;",
          "new_line_content": "    int64_t nTime2 = GetTimeMicros(); nTimeForks += nTime2 - nTime1;",
          "content_same": false
        },
        {
          "line": 1610,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::BENCH, \"    - Fork checks: %.2fms [%.2fs]\\n\", 0.001 * (nTime2 - nTime1), nTimeForks * 0.000001)",
          "old_line_content": "        flags |= SCRIPT_VERIFY_NULLDUMMY;",
          "new_line_content": "    LogPrint(BCLog::BENCH, \"    - Fork checks: %.2fms [%.2fs]\\n\", 0.001 * (nTime2 - nTime1), nTimeForks * 0.000001);",
          "content_same": false
        },
        {
          "line": 3660,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "}",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 3663,
          "old_api": null,
          "new_api": "Genesis",
          "old_text": null,
          "new_text": "chainActive.Genesis()",
          "old_line_content": "{",
          "new_line_content": "    if (chainActive.Genesis() != NULL)",
          "content_same": false
        },
        {
          "line": 1620,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "block.vtx.size()",
          "old_line_content": "    std::vector<int> prevheights;",
          "new_line_content": "    CDiskTxPos pos(pindex->GetBlockPos(), GetSizeOfCompactSize(block.vtx.size()));",
          "content_same": false
        },
        {
          "line": 3668,
          "old_api": null,
          "new_api": "WriteFlag",
          "old_text": null,
          "new_text": "pblocktree->WriteFlag(\"txindex\", fTxIndex)",
          "old_line_content": "        return true;",
          "new_line_content": "    pblocktree->WriteFlag(\"txindex\", fTxIndex);",
          "content_same": false
        },
        {
          "line": 1622,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "block.vtx.size()",
          "old_line_content": "    int nInputs = 0;",
          "new_line_content": "    vPos.reserve(block.vtx.size());",
          "content_same": false
        },
        {
          "line": 1623,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "block.vtx.size()",
          "old_line_content": "    int64_t nSigOpsCost = 0;",
          "new_line_content": "    blockundo.vtxundo.reserve(block.vtx.size() - 1);",
          "content_same": false
        },
        {
          "line": 3669,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"Initializing databases...\\n\")",
          "old_line_content": "",
          "new_line_content": "    LogPrintf(\"Initializing databases...\\n\");",
          "content_same": false
        },
        {
          "line": 1625,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "block.vtx.size()",
          "old_line_content": "    std::vector<std::pair<uint256, CDiskTxPos> > vPos;",
          "new_line_content": "    txdata.reserve(block.vtx.size()); // Required so that pointers to individual PrecomputedTransactionData don't get invalidated",
          "content_same": false
        },
        {
          "line": 3674,
          "old_api": null,
          "new_api": "GenesisBlock",
          "old_text": null,
          "new_text": "chainparams.GenesisBlock()",
          "old_line_content": "",
          "new_line_content": "            CBlock &block = const_cast<CBlock&>(chainparams.GenesisBlock());",
          "content_same": false
        },
        {
          "line": 3676,
          "old_api": null,
          "new_api": "::GetSerializeSize(block, SER_DISK, CLIENT_VERSION)",
          "old_text": null,
          "new_text": "::GetSerializeSize(block, SER_DISK, CLIENT_VERSION)",
          "old_line_content": "    if (!fReindex) {",
          "new_line_content": "            unsigned int nBlockSize = ::GetSerializeSize(block, SER_DISK, CLIENT_VERSION);",
          "content_same": false
        },
        {
          "line": 3679,
          "old_api": null,
          "new_api": "GetBlockTime",
          "old_text": null,
          "new_text": "block.GetBlockTime()",
          "old_line_content": "            // Start new block file",
          "new_line_content": "            if (!FindBlockPos(state, blockPos, nBlockSize+8, 0, block.GetBlockTime()))",
          "content_same": false
        },
        {
          "line": 1632,
          "old_api": null,
          "new_api": "IsCoinBase",
          "old_text": null,
          "new_text": "tx.IsCoinBase()",
          "old_line_content": "        const CTransaction &tx = *(block.vtx[i]);",
          "new_line_content": "        if (!tx.IsCoinBase())",
          "content_same": false
        },
        {
          "line": 3681,
          "old_api": null,
          "new_api": "MessageStart",
          "old_text": null,
          "new_text": "chainparams.MessageStart()",
          "old_line_content": "            CDiskBlockPos blockPos;",
          "new_line_content": "            if (!WriteBlockToDisk(block, blockPos, chainparams.MessageStart()))",
          "content_same": false
        },
        {
          "line": 3682,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"LoadBlockIndex(): writing genesis block to disk failed\")",
          "old_line_content": "            CValidationState state;",
          "new_line_content": "                return error(\"LoadBlockIndex(): writing genesis block to disk failed\");",
          "content_same": false
        },
        {
          "line": 1635,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"ConnectBlock(): inputs missing/spent\")",
          "old_line_content": "",
          "new_line_content": "                return state.DoS(100, error(\"ConnectBlock(): inputs missing/spent\"),",
          "content_same": false
        },
        {
          "line": 1641,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "tx.vin.size()",
          "old_line_content": "",
          "new_line_content": "            prevheights.resize(tx.vin.size());",
          "content_same": false
        },
        {
          "line": 1642,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "tx.vin.size()",
          "old_line_content": "            // Check that transaction is BIP68 final",
          "new_line_content": "            for (size_t j = 0; j < tx.vin.size(); j++) {",
          "content_same": false
        },
        {
          "line": 1643,
          "old_api": null,
          "new_api": "AccessCoin",
          "old_text": null,
          "new_text": "view.AccessCoin(tx.vin[j].prevout)",
          "old_line_content": "            // BIP68 lock checks (as opposed to nLockTime checks) must",
          "new_line_content": "                prevheights[j] = view.AccessCoin(tx.vin[j].prevout).nHeight;",
          "content_same": false
        },
        {
          "line": 3700,
          "old_api": null,
          "new_api": "GetTimeMillis",
          "old_text": null,
          "new_text": "GetTimeMillis()",
          "old_line_content": "bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskBlockPos *dbp)",
          "new_line_content": "    int64_t nStart = GetTimeMillis();",
          "content_same": false
        },
        {
          "line": 1656,
          "old_api": null,
          "new_api": "GetTransactionSigOpCost",
          "old_text": null,
          "new_text": "GetTransactionSigOpCost(tx, view, flags)",
          "old_line_content": "        // GetTransactionSigOpCost counts 3 types of sigops:",
          "new_line_content": "        nSigOpsCost += GetTransactionSigOpCost(tx, view, flags);",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"ConnectBlock(): too many sigops\")",
          "old_line_content": "        // * p2sh (when P2SH enabled in flags and excludes coinbase)",
          "new_line_content": "            return state.DoS(100, error(\"ConnectBlock(): too many sigops\"),",
          "content_same": false
        },
        {
          "line": 3706,
          "old_api": null,
          "new_api": "GetPos",
          "old_text": null,
          "new_text": "blkdat.GetPos()",
          "old_line_content": "    int nLoaded = 0;",
          "new_line_content": "        uint64_t nRewind = blkdat.GetPos();",
          "content_same": false
        },
        {
          "line": 3707,
          "old_api": null,
          "new_api": "eof",
          "old_text": null,
          "new_text": "blkdat.eof()",
          "old_line_content": "    try {",
          "new_line_content": "        while (!blkdat.eof()) {",
          "content_same": false
        },
        {
          "line": 1661,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "txdata.emplace_back(tx)",
          "old_line_content": "        if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST)",
          "new_line_content": "        txdata.emplace_back(tx);",
          "content_same": false
        },
        {
          "line": 3708,
          "old_api": null,
          "new_api": "boost::this_thread::interruption_point()",
          "old_text": null,
          "new_text": "boost::this_thread::interruption_point()",
          "old_line_content": "        // This takes over fileIn and calls fclose() on it in the CBufferedFile destructor",
          "new_line_content": "            boost::this_thread::interruption_point();",
          "content_same": false
        },
        {
          "line": 1664,
          "old_api": null,
          "new_api": "GetValueOut",
          "old_text": null,
          "new_text": "tx.GetValueOut()",
          "old_line_content": "",
          "new_line_content": "            nFees += view.GetValueIn(tx)-tx.GetValueOut();",
          "content_same": false
        },
        {
          "line": 1669,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                    tx.GetHash().ToString(), FormatStateMessage(state))",
          "old_line_content": "",
          "new_line_content": "                return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",",
          "content_same": false
        },
        {
          "line": 1670,
          "old_api": null,
          "new_api": "FormatStateMessage",
          "old_text": null,
          "new_text": "FormatStateMessage(state)",
          "old_line_content": "            std::vector<CScriptCheck> vChecks;",
          "new_line_content": "                    tx.GetHash().ToString(), FormatStateMessage(state));",
          "content_same": false
        },
        {
          "line": 1671,
          "old_api": null,
          "new_api": "Add",
          "old_text": null,
          "new_text": "control.Add(vChecks)",
          "old_line_content": "            bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */",
          "new_line_content": "            control.Add(vChecks);",
          "content_same": false
        },
        {
          "line": 3717,
          "old_api": null,
          "new_api": "MessageStart",
          "old_text": null,
          "new_text": "chainparams.MessageStart()",
          "old_line_content": "            unsigned int nSize = 0;",
          "new_line_content": "                blkdat.FindByte(chainparams.MessageStart()[0]);",
          "content_same": false
        },
        {
          "line": 3718,
          "old_api": null,
          "new_api": "GetPos",
          "old_text": null,
          "new_text": "blkdat.GetPos()",
          "old_line_content": "            try {",
          "new_line_content": "                nRewind = blkdat.GetPos()+1;",
          "content_same": false
        },
        {
          "line": 3719,
          "old_api": null,
          "new_api": "FLATDATA",
          "old_text": null,
          "new_text": "FLATDATA(buf)",
          "old_line_content": "                // locate a header",
          "new_line_content": "                blkdat >> FLATDATA(buf);",
          "content_same": false
        },
        {
          "line": 3720,
          "old_api": null,
          "new_api": "MessageStart",
          "old_text": null,
          "new_text": "chainparams.MessageStart()",
          "old_line_content": "                unsigned char buf[CMessageHeader::MESSAGE_START_SIZE];",
          "new_line_content": "                if (memcmp(buf, chainparams.MessageStart(), CMessageHeader::MESSAGE_START_SIZE))",
          "content_same": false
        },
        {
          "line": 1676,
          "old_api": null,
          "new_api": "CTxUndo",
          "old_text": null,
          "new_text": "CTxUndo()",
          "old_line_content": "        }",
          "new_line_content": "            blockundo.vtxundo.push_back(CTxUndo());",
          "content_same": false
        },
        {
          "line": 1678,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "blockundo.vtxundo.back()",
          "old_line_content": "        CTxUndo undoDummy;",
          "new_line_content": "        UpdateCoins(tx, view, i == 0 ? undoDummy : blockundo.vtxundo.back(), pindex->nHeight);",
          "content_same": false
        },
        {
          "line": 1681,
          "old_api": null,
          "new_api": "::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION)",
          "old_text": null,
          "new_text": "::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION)",
          "old_line_content": "        }",
          "new_line_content": "        pos.nTxOffset += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);",
          "content_same": false
        },
        {
          "line": 1683,
          "old_api": null,
          "new_api": "GetTimeMicros",
          "old_text": null,
          "new_text": "GetTimeMicros()",
          "old_line_content": "",
          "new_line_content": "    int64_t nTime3 = GetTimeMicros(); nTimeConnect += nTime3 - nTime2;",
          "content_same": false
        },
        {
          "line": 3732,
          "old_api": null,
          "new_api": "GetPos",
          "old_text": null,
          "new_text": "blkdat.GetPos()",
          "old_line_content": "                break;",
          "new_line_content": "                uint64_t nBlockPos = blkdat.GetPos();",
          "content_same": false
        },
        {
          "line": 1686,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainparams.GetConsensus()",
          "old_line_content": "    }",
          "new_line_content": "    CAmount blockReward = nFees + GetBlockSubsidy(pindex->nHeight, chainparams.GetConsensus());",
          "content_same": false
        },
        {
          "line": 3735,
          "old_api": null,
          "new_api": "SetLimit",
          "old_text": null,
          "new_text": "blkdat.SetLimit(nBlockPos + nSize)",
          "old_line_content": "                // read block",
          "new_line_content": "                blkdat.SetLimit(nBlockPos + nSize);",
          "content_same": false
        },
        {
          "line": 1689,
          "old_api": null,
          "new_api": "GetValueOut",
          "old_text": null,
          "new_text": "error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n                               block.vtx[0]->GetValueOut(), blockReward)",
          "old_line_content": "",
          "new_line_content": "                         error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",",
          "content_same": false
        },
        {
          "line": 3737,
          "old_api": null,
          "new_api": "std::make_shared<CBlock>()",
          "old_text": null,
          "new_text": "std::make_shared<CBlock>()",
          "old_line_content": "                if (dbp)",
          "new_line_content": "                std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();",
          "content_same": false
        },
        {
          "line": 1695,
          "old_api": null,
          "new_api": "GetTimeMicros",
          "old_text": null,
          "new_text": "GetTimeMicros()",
          "old_line_content": "                               REJECT_INVALID, \"bad-cb-amount\");",
          "new_line_content": "    int64_t nTime4 = GetTimeMicros(); nTimeVerify += nTime4 - nTime2;",
          "content_same": false
        },
        {
          "line": 1696,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::BENCH, \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs]\\n\", nInputs - 1, 0.001 * (nTime4 - nTime2), nInputs <= 1 ? 0 : 0.001 * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * 0.000001)",
          "old_line_content": "",
          "new_line_content": "    LogPrint(BCLog::BENCH, \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs]\\n\", nInputs - 1, 0.001 * (nTime4 - nTime2), nInputs <= 1 ? 0 : 0.001 * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * 0.000001);",
          "content_same": false
        },
        {
          "line": 3743,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "block.GetHash()",
          "old_line_content": "                blkdat >> block;",
          "new_line_content": "                uint256 hash = block.GetHash();",
          "content_same": false
        },
        {
          "line": 3745,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "hash.ToString()",
          "old_line_content": "",
          "new_line_content": "                    LogPrint(BCLog::REINDEX, \"%s: Out of order block %s, parent %s not known\\n\", __func__, hash.ToString(),",
          "content_same": false
        },
        {
          "line": 3746,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "block.hashPrevBlock.ToString()",
          "old_line_content": "                // detect out of order blocks, and store them for later",
          "new_line_content": "                            block.hashPrevBlock.ToString());",
          "content_same": false
        },
        {
          "line": 1702,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "pindex->IsValid(BLOCK_VALID_SCRIPTS)",
          "old_line_content": "    if (fJustCheck)",
          "new_line_content": "    if (pindex->GetUndoPos().IsNull() || !pindex->IsValid(BLOCK_VALID_SCRIPTS))",
          "content_same": false
        },
        {
          "line": 1704,
          "old_api": null,
          "new_api": "IsNull",
          "old_text": null,
          "new_text": "pindex->GetUndoPos().IsNull()",
          "old_line_content": "",
          "new_line_content": "        if (pindex->GetUndoPos().IsNull()) {",
          "content_same": false
        },
        {
          "line": 3753,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "mapBlockIndex.count(hash)",
          "old_line_content": "                    continue;",
          "new_line_content": "                if (mapBlockIndex.count(hash) == 0 || (mapBlockIndex[hash]->nStatus & BLOCK_HAVE_DATA) == 0) {",
          "content_same": false
        },
        {
          "line": 3754,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "                }",
          "new_line_content": "                    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 1707,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "error(\"ConnectBlock(): FindUndoPos failed\")",
          "old_line_content": "    {",
          "new_line_content": "                return error(\"ConnectBlock(): FindUndoPos failed\");",
          "content_same": false
        },
        {
          "line": 3756,
          "old_api": null,
          "new_api": "AcceptBlock",
          "old_text": null,
          "new_text": "AcceptBlock(pblock, state, chainparams, NULL, true, dbp, NULL)",
          "old_line_content": "                // process in case the block isn't known yet",
          "new_line_content": "                    if (AcceptBlock(pblock, state, chainparams, NULL, true, dbp, NULL))",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": null,
          "new_api": "AbortNode",
          "old_text": null,
          "new_text": "AbortNode(state, \"Failed to write undo data\")",
          "old_line_content": "            CDiskBlockPos _pos;",
          "new_line_content": "                return AbortNode(state, \"Failed to write undo data\");",
          "content_same": false
        },
        {
          "line": 3761,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "hash.ToString()",
          "old_line_content": "                        nLoaded++;",
          "new_line_content": "                    LogPrint(BCLog::REINDEX, \"Block Import: already had block %s at height %d\\n\", hash.ToString(), mapBlockIndex[hash]->nHeight);",
          "content_same": false
        },
        {
          "line": 1716,
          "old_api": null,
          "new_api": "RaiseValidity",
          "old_text": null,
          "new_text": "pindex->RaiseValidity(BLOCK_VALID_SCRIPTS)",
          "old_line_content": "            pindex->nUndoPos = _pos.nPos;",
          "new_line_content": "        pindex->RaiseValidity(BLOCK_VALID_SCRIPTS);",
          "content_same": false
        },
        {
          "line": 1717,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "setDirtyBlockIndex.insert(pindex)",
          "old_line_content": "            pindex->nStatus |= BLOCK_HAVE_UNDO;",
          "new_line_content": "        setDirtyBlockIndex.insert(pindex);",
          "content_same": false
        },
        {
          "line": 3767,
          "old_api": null,
          "new_api": "ActivateBestChain",
          "old_text": null,
          "new_text": "ActivateBestChain(state, chainparams)",
          "old_line_content": "",
          "new_line_content": "                    if (!ActivateBestChain(state, chainparams)) {",
          "content_same": false
        },
        {
          "line": 1722,
          "old_api": null,
          "new_api": "AbortNode",
          "old_text": null,
          "new_text": "AbortNode(state, \"Failed to write transaction index\")",
          "old_line_content": "    }",
          "new_line_content": "            return AbortNode(state, \"Failed to write transaction index\");",
          "content_same": false
        },
        {
          "line": 3772,
          "old_api": null,
          "new_api": "NotifyHeaderTip",
          "old_text": null,
          "new_text": "NotifyHeaderTip()",
          "old_line_content": "                        break;",
          "new_line_content": "                NotifyHeaderTip();",
          "content_same": false
        },
        {
          "line": 1727,
          "old_api": null,
          "new_api": "GetTimeMicros",
          "old_text": null,
          "new_text": "GetTimeMicros()",
          "old_line_content": "",
          "new_line_content": "    int64_t nTime5 = GetTimeMicros(); nTimeIndex += nTime5 - nTime4;",
          "content_same": false
        },
        {
          "line": 1728,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::BENCH, \"    - Index writing: %.2fms [%.2fs]\\n\", 0.001 * (nTime5 - nTime4), nTimeIndex * 0.000001)",
          "old_line_content": "    // add this block to the view's block chain",
          "new_line_content": "    LogPrint(BCLog::BENCH, \"    - Index writing: %.2fms [%.2fs]\\n\", 0.001 * (nTime5 - nTime4), nTimeIndex * 0.000001);",
          "content_same": false
        },
        {
          "line": 3777,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "queue.empty()",
          "old_line_content": "",
          "new_line_content": "                while (!queue.empty()) {",
          "content_same": false
        },
        {
          "line": 1730,
          "old_api": null,
          "new_api": "GetTimeMicros",
          "old_text": null,
          "new_text": "GetTimeMicros()",
          "old_line_content": "",
          "new_line_content": "    int64_t nTime6 = GetTimeMicros(); nTimeCallbacks += nTime6 - nTime5;",
          "content_same": false
        },
        {
          "line": 3778,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "queue.front()",
          "old_line_content": "                // Recursively process earlier encountered successors of this block",
          "new_line_content": "                    uint256 head = queue.front();",
          "content_same": false
        },
        {
          "line": 3779,
          "old_api": null,
          "new_api": "pop_front",
          "old_text": null,
          "new_text": "queue.pop_front()",
          "old_line_content": "                std::deque<uint256> queue;",
          "new_line_content": "                    queue.pop_front();",
          "content_same": false
        },
        {
          "line": 3786,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "pblockrecursive->GetHash().ToString()",
          "old_line_content": "                        std::multimap<uint256, CDiskBlockPos>::iterator it = range.first;",
          "new_line_content": "                            LogPrint(BCLog::REINDEX, \"%s: Processing out of order child %s of %s\\n\", __func__, pblockrecursive->GetHash().ToString(),",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": null,
          "new_api": "DynamicMemoryUsage",
          "old_text": null,
          "new_text": "mempool.DynamicMemoryUsage()",
          "old_line_content": " * if they're too large, if it's been a while since the last write,",
          "new_line_content": "    int64_t nMempoolUsage = mempool.DynamicMemoryUsage();",
          "content_same": false
        },
        {
          "line": 1744,
          "old_api": null,
          "new_api": "LOCK2",
          "old_text": null,
          "new_text": "LOCK2(cs_main, cs_LastBlockFile)",
          "old_line_content": " * or always and in all cases if we're in prune mode and are deleting files.",
          "new_line_content": "    LOCK2(cs_main, cs_LastBlockFile);",
          "content_same": false
        },
        {
          "line": 3793,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "pblockrecursive->GetHash()",
          "old_line_content": "                            CValidationState dummy;",
          "new_line_content": "                                queue.push_back(pblockrecursive->GetHash());",
          "content_same": false
        },
        {
          "line": 3798,
          "old_api": null,
          "new_api": "NotifyHeaderTip",
          "old_text": null,
          "new_text": "NotifyHeaderTip()",
          "old_line_content": "                            }",
          "new_line_content": "                        NotifyHeaderTip();",
          "content_same": false
        },
        {
          "line": 1753,
          "old_api": null,
          "new_api": "FindFilesToPruneManual",
          "old_text": null,
          "new_text": "FindFilesToPruneManual(setFilesToPrune, nManualPruneHeight)",
          "old_line_content": "    bool fFlushForPrune = false;",
          "new_line_content": "            FindFilesToPruneManual(setFilesToPrune, nManualPruneHeight);",
          "content_same": false
        },
        {
          "line": 1755,
          "old_api": null,
          "new_api": "PruneAfterHeight",
          "old_text": null,
          "new_text": "chainparams.PruneAfterHeight()",
          "old_line_content": "    if (fPruneMode && (fCheckForPruning || nManualPruneHeight > 0) && !fReindex) {",
          "new_line_content": "            FindFilesToPrune(setFilesToPrune, chainparams.PruneAfterHeight());",
          "content_same": false
        },
        {
          "line": 1758,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "setFilesToPrune.empty()",
          "old_line_content": "        } else {",
          "new_line_content": "        if (!setFilesToPrune.empty()) {",
          "content_same": false
        },
        {
          "line": 1761,
          "old_api": null,
          "new_api": "WriteFlag",
          "old_text": null,
          "new_text": "pblocktree->WriteFlag(\"prunedblockfiles\", true)",
          "old_line_content": "        }",
          "new_line_content": "                pblocktree->WriteFlag(\"prunedblockfiles\", true);",
          "content_same": false
        },
        {
          "line": 3809,
          "old_api": null,
          "new_api": "GetTimeMillis",
          "old_text": null,
          "new_text": "GetTimeMillis()",
          "old_line_content": "    } catch (const std::runtime_error& e) {",
          "new_line_content": "        LogPrintf(\"Loaded %i blocks from external file in %dms\\n\", nLoaded, GetTimeMillis() - nStart);",
          "content_same": false
        },
        {
          "line": 1766,
          "old_api": null,
          "new_api": "GetTimeMicros",
          "old_text": null,
          "new_text": "GetTimeMicros()",
          "old_line_content": "                fHavePruned = true;",
          "new_line_content": "    int64_t nNow = GetTimeMicros();",
          "content_same": false
        },
        {
          "line": 3819,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "    if (!fCheckBlockIndex) {",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 3824,
          "old_api": null,
          "new_api": "Height",
          "old_text": null,
          "new_text": "chainActive.Height()",
          "old_line_content": "",
          "new_line_content": "    if (chainActive.Height() < 0) {",
          "content_same": false
        },
        {
          "line": 1777,
          "old_api": null,
          "new_api": "GetArg",
          "old_text": null,
          "new_text": "GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE)",
          "old_line_content": "    }",
          "new_line_content": "    int64_t nMempoolSizeMax = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;",
          "content_same": false
        },
        {
          "line": 1778,
          "old_api": null,
          "new_api": "DynamicMemoryUsage",
          "old_text": null,
          "new_text": "pcoinsTip->DynamicMemoryUsage()",
          "old_line_content": "    if (nLastSetChain == 0) {",
          "new_line_content": "    int64_t cacheSize = pcoinsTip->DynamicMemoryUsage() * DB_PEAK_USAGE_FACTOR;",
          "content_same": false
        },
        {
          "line": 1779,
          "old_api": null,
          "new_api": "std::max<int64_t>(nMempoolSizeMax - nMempoolUsage, 0)",
          "old_text": null,
          "new_text": "std::max<int64_t>(nMempoolSizeMax - nMempoolUsage, 0)",
          "old_line_content": "        nLastSetChain = nNow;",
          "new_line_content": "    int64_t nTotalSpace = nCoinCacheUsage + std::max<int64_t>(nMempoolSizeMax - nMempoolUsage, 0);",
          "content_same": false
        },
        {
          "line": 3825,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "mapBlockIndex.size()",
          "old_line_content": "    // During a reindex, we read the genesis block and call CheckBlockIndex before ActivateBestChain,",
          "new_line_content": "        assert(mapBlockIndex.size() <= 1);",
          "content_same": false
        },
        {
          "line": 3831,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapBlockIndex.end()",
          "old_line_content": "    }",
          "new_line_content": "    for (BlockMap::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); it++) {",
          "content_same": false
        },
        {
          "line": 3832,
          "old_api": null,
          "new_api": "std::make_pair(it->second->pprev, it->second)",
          "old_text": null,
          "new_text": "std::make_pair(it->second->pprev, it->second)",
          "old_line_content": "",
          "new_line_content": "        forward.insert(std::make_pair(it->second->pprev, it->second));",
          "content_same": false
        },
        {
          "line": 3837,
          "old_api": null,
          "new_api": "equal_range",
          "old_text": null,
          "new_text": "forward.equal_range(NULL)",
          "old_line_content": "    }",
          "new_line_content": "    std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeGenesis = forward.equal_range(NULL);",
          "content_same": false
        },
        {
          "line": 3840,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(rangeGenesis.first == rangeGenesis.second)",
          "old_line_content": "",
          "new_line_content": "    assert(rangeGenesis.first == rangeGenesis.second); // There is only one index entry with parent NULL.",
          "content_same": false
        },
        {
          "line": 1793,
          "old_api": null,
          "new_api": "CheckDiskSpace",
          "old_text": null,
          "new_text": "CheckDiskSpace(0)",
          "old_line_content": "    bool fDoFullFlush = (mode == FLUSH_STATE_ALWAYS) || fCacheLarge || fCacheCritical || fPeriodicFlush || fFlushForPrune;",
          "new_line_content": "        if (!CheckDiskSpace(0))",
          "content_same": false
        },
        {
          "line": 1794,
          "old_api": null,
          "new_api": "Error",
          "old_text": null,
          "new_text": "state.Error(\"out of disk space\")",
          "old_line_content": "    // Write blocks and block index to disk.",
          "new_line_content": "            return state.Error(\"out of disk space\");",
          "content_same": false
        },
        {
          "line": 1796,
          "old_api": null,
          "new_api": "FlushBlockFile",
          "old_text": null,
          "new_text": "FlushBlockFile()",
          "old_line_content": "        // Depend on nMinDiskSpace to ensure we can write block index",
          "new_line_content": "        FlushBlockFile();",
          "content_same": false
        },
        {
          "line": 1801,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "setDirtyFileInfo.end()",
          "old_line_content": "        // Then update all block file information (which may refer to block and undo files).",
          "new_line_content": "            for (std::set<int>::iterator it = setDirtyFileInfo.begin(); it != setDirtyFileInfo.end(); ) {",
          "content_same": false
        },
        {
          "line": 1802,
          "old_api": null,
          "new_api": "std::make_pair(*it, &vinfoBlockFile[*it])",
          "old_text": null,
          "new_text": "std::make_pair(*it, &vinfoBlockFile[*it])",
          "old_line_content": "        {",
          "new_line_content": "                vFiles.push_back(std::make_pair(*it, &vinfoBlockFile[*it]));",
          "content_same": false
        },
        {
          "line": 1803,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "setDirtyFileInfo.erase(it++)",
          "old_line_content": "            std::vector<std::pair<int, const CBlockFileInfo*> > vFiles;",
          "new_line_content": "                setDirtyFileInfo.erase(it++);",
          "content_same": false
        },
        {
          "line": 1808,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "vBlocks.push_back(*it)",
          "old_line_content": "            }",
          "new_line_content": "                vBlocks.push_back(*it);",
          "content_same": false
        },
        {
          "line": 1809,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "setDirtyBlockIndex.erase(it++)",
          "old_line_content": "            std::vector<const CBlockIndex*> vBlocks;",
          "new_line_content": "                setDirtyBlockIndex.erase(it++);",
          "content_same": false
        },
        {
          "line": 1817,
          "old_api": null,
          "new_api": "UnlinkPrunedFiles",
          "old_text": null,
          "new_text": "UnlinkPrunedFiles(setFilesToPrune)",
          "old_line_content": "            }",
          "new_line_content": "            UnlinkPrunedFiles(setFilesToPrune);",
          "content_same": false
        },
        {
          "line": 3867,
          "old_api": null,
          "new_api": "GetBlockHash",
          "old_text": null,
          "new_text": "pindex->GetBlockHash()",
          "old_line_content": "",
          "new_line_content": "            assert(pindex->GetBlockHash() == consensusParams.hashGenesisBlock); // Genesis block's hash must match.",
          "content_same": false
        },
        {
          "line": 3868,
          "old_api": null,
          "new_api": "Genesis",
          "old_text": null,
          "new_text": "chainActive.Genesis()",
          "old_line_content": "        // Begin: actual consistency checks.",
          "new_line_content": "            assert(pindex == chainActive.Genesis()); // The current active chain's genesis block must be this block.",
          "content_same": false
        },
        {
          "line": 3870,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(pindex->nSequenceId <= 0)",
          "old_line_content": "            // Genesis block checks.",
          "new_line_content": "        if (pindex->nChainTx == 0) assert(pindex->nSequenceId <= 0);  // nSequenceId can't be set positive for blocks that aren't linked (negative is used for preciousblock)",
          "content_same": false
        },
        {
          "line": 1827,
          "old_api": null,
          "new_api": "GetCacheSize",
          "old_text": null,
          "new_text": "pcoinsTip->GetCacheSize()",
          "old_line_content": "        // Pushing a new one to the database can cause it to be written",
          "new_line_content": "        if (!CheckDiskSpace(48 * 2 * 2 * pcoinsTip->GetCacheSize()))",
          "content_same": false
        },
        {
          "line": 1828,
          "old_api": null,
          "new_api": "Error",
          "old_text": null,
          "new_text": "state.Error(\"out of disk space\")",
          "old_line_content": "        // twice (once in the log, and once in the tables). This is already",
          "new_line_content": "            return state.Error(\"out of disk space\");",
          "content_same": false
        },
        {
          "line": 3875,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(!(pindex->nStatus & BLOCK_HAVE_DATA) == (pindex->nTx == 0))",
          "old_line_content": "        // VALID_TRANSACTIONS is equivalent to nTx > 0 for all nodes (whether or not pruning has occurred).",
          "new_line_content": "            assert(!(pindex->nStatus & BLOCK_HAVE_DATA) == (pindex->nTx == 0));",
          "content_same": false
        },
        {
          "line": 1830,
          "old_api": null,
          "new_api": "Flush",
          "old_text": null,
          "new_text": "pcoinsTip->Flush()",
          "old_line_content": "        // overwrite one. Still, use a conservative safety factor of 2.",
          "new_line_content": "        if (!pcoinsTip->Flush())",
          "content_same": false
        },
        {
          "line": 3876,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(pindexFirstMissing == pindexFirstNeverProcessed)",
          "old_line_content": "        // HAVE_DATA is only equivalent to nTx > 0 (or VALID_TRANSACTIONS) if no pruning has occurred.",
          "new_line_content": "            assert(pindexFirstMissing == pindexFirstNeverProcessed);",
          "content_same": false
        },
        {
          "line": 3881,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(pindex->nStatus & BLOCK_HAVE_DATA)",
          "old_line_content": "        } else {",
          "new_line_content": "        if (pindex->nStatus & BLOCK_HAVE_UNDO) assert(pindex->nStatus & BLOCK_HAVE_DATA);",
          "content_same": false
        },
        {
          "line": 3882,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TRANSACTIONS) == (pindex->nTx > 0))",
          "old_line_content": "            // If we have pruned, then we can only say that HAVE_DATA implies nTx > 0",
          "new_line_content": "        assert(((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TRANSACTIONS) == (pindex->nTx > 0)); // This is pruning-independent.",
          "content_same": false
        },
        {
          "line": 1836,
          "old_api": null,
          "new_api": "GetLocator",
          "old_text": null,
          "new_text": "chainActive.GetLocator()",
          "old_line_content": "        nLastFlush = nNow;",
          "new_line_content": "        GetMainSignals().SetBestChain(chainActive.GetLocator());",
          "content_same": false
        },
        {
          "line": 3884,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert((pindexFirstNeverProcessed != NULL) == (pindex->nChainTx == 0))",
          "old_line_content": "        }",
          "new_line_content": "        assert((pindexFirstNeverProcessed != NULL) == (pindex->nChainTx == 0)); // nChainTx != 0 is used to signal that all parent blocks have been processed (but may have been pruned).",
          "content_same": false
        },
        {
          "line": 3887,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(pindex->pprev == NULL || pindex->nChainWork >= pindex->pprev->nChainWork)",
          "old_line_content": "        // All parents having had data (at some point) is equivalent to all parents being VALID_TRANSACTIONS, which is equivalent to nChainTx being set.",
          "new_line_content": "        assert(pindex->pprev == NULL || pindex->nChainWork >= pindex->pprev->nChainWork); // For every block except the genesis block, the chainwork must be larger than the parent's.",
          "content_same": false
        },
        {
          "line": 1847,
          "old_api": null,
          "new_api": "Params",
          "old_text": null,
          "new_text": "Params()",
          "old_line_content": "}",
          "new_line_content": "    const CChainParams& chainparams = Params();",
          "content_same": false
        },
        {
          "line": 1848,
          "old_api": null,
          "new_api": "FlushStateToDisk",
          "old_text": null,
          "new_text": "FlushStateToDisk(chainparams, state, FLUSH_STATE_ALWAYS)",
          "old_line_content": "",
          "new_line_content": "    FlushStateToDisk(chainparams, state, FLUSH_STATE_ALWAYS);",
          "content_same": false
        },
        {
          "line": 3897,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "        if (pindexFirstInvalid == NULL) {",
          "new_line_content": "        if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && pindexFirstNeverProcessed == NULL) {",
          "content_same": false
        },
        {
          "line": 1854,
          "old_api": null,
          "new_api": "Params",
          "old_text": null,
          "new_text": "Params()",
          "old_line_content": "",
          "new_line_content": "    const CChainParams& chainparams = Params();",
          "content_same": false
        },
        {
          "line": 1855,
          "old_api": null,
          "new_api": "FlushStateToDisk",
          "old_text": null,
          "new_text": "FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE)",
          "old_line_content": "void PruneAndFlush() {",
          "new_line_content": "    FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE);",
          "content_same": false
        },
        {
          "line": 3903,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "                // If this block sorts at least as good as the current tip and",
          "new_line_content": "                if (pindexFirstMissing == NULL || pindex == chainActive.Tip()) {",
          "content_same": false
        },
        {
          "line": 3904,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "setBlockIndexCandidates.count(pindex)",
          "old_line_content": "                // is valid and we have all data for its parents, it must be in",
          "new_line_content": "                    assert(setBlockIndexCandidates.count(pindex));",
          "content_same": false
        },
        {
          "line": 1861,
          "old_api": null,
          "new_api": "SetMiscWarning",
          "old_text": null,
          "new_text": "SetMiscWarning(strWarning)",
          "old_line_content": "",
          "new_line_content": "    SetMiscWarning(strWarning);",
          "content_same": false
        },
        {
          "line": 1863,
          "old_api": null,
          "new_api": "AlertNotify",
          "old_text": null,
          "new_text": "AlertNotify(strWarning)",
          "old_line_content": "{",
          "new_line_content": "        AlertNotify(strWarning);",
          "content_same": false
        },
        {
          "line": 3911,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "setBlockIndexCandidates.count(pindex)",
          "old_line_content": "                // setBlockIndexCandidates but had to be removed because of the missing data.",
          "new_line_content": "            assert(setBlockIndexCandidates.count(pindex) == 0);",
          "content_same": false
        },
        {
          "line": 3914,
          "old_api": null,
          "new_api": "equal_range",
          "old_text": null,
          "new_text": "mapBlocksUnlinked.equal_range(pindex->pprev)",
          "old_line_content": "        } else { // If this block sorts worse than the current tip or some ancestor's block has never been seen, it cannot be in setBlockIndexCandidates.",
          "new_line_content": "        std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeUnlinked = mapBlocksUnlinked.equal_range(pindex->pprev);",
          "content_same": false
        },
        {
          "line": 3917,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(rangeUnlinked.first->first == pindex->pprev)",
          "old_line_content": "        // Check whether this block is in mapBlocksUnlinked.",
          "new_line_content": "            assert(rangeUnlinked.first->first == pindex->pprev);",
          "content_same": false
        },
        {
          "line": 1870,
          "old_api": null,
          "new_api": "SetTip",
          "old_text": null,
          "new_text": "chainActive.SetTip(pindexNew)",
          "old_line_content": "}",
          "new_line_content": "    chainActive.SetTip(pindexNew);",
          "content_same": false
        },
        {
          "line": 1873,
          "old_api": null,
          "new_api": "AddTransactionsUpdated",
          "old_text": null,
          "new_text": "mempool.AddTransactionsUpdated(1)",
          "old_line_content": "void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {",
          "new_line_content": "    mempool.AddTransactionsUpdated(1);",
          "content_same": false
        },
        {
          "line": 1875,
          "old_api": null,
          "new_api": "notify_all",
          "old_text": null,
          "new_text": "cvBlockChange.notify_all()",
          "old_line_content": "",
          "new_line_content": "    cvBlockChange.notify_all();",
          "content_same": false
        },
        {
          "line": 1878,
          "old_api": null,
          "new_api": "IsInitialBlockDownload",
          "old_text": null,
          "new_text": "IsInitialBlockDownload()",
          "old_line_content": "",
          "new_line_content": "    if (!IsInitialBlockDownload())",
          "content_same": false
        },
        {
          "line": 3926,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(foundInUnlinked)",
          "old_line_content": "            rangeUnlinked.first++;",
          "new_line_content": "            assert(foundInUnlinked);",
          "content_same": false
        },
        {
          "line": 3928,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(!foundInUnlinked)",
          "old_line_content": "        if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed != NULL && pindexFirstInvalid == NULL) {",
          "new_line_content": "        if (!(pindex->nStatus & BLOCK_HAVE_DATA)) assert(!foundInUnlinked); // Can't be in mapBlocksUnlinked if we don't HAVE_DATA",
          "content_same": false
        },
        {
          "line": 1881,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "    std::vector<std::string> warningMessages;",
          "new_line_content": "        const CBlockIndex* pindex = chainActive.Tip();",
          "content_same": false
        },
        {
          "line": 3929,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(!foundInUnlinked)",
          "old_line_content": "            // If this block has block data available, some parent was never received, and has no invalid parents, it must be in mapBlocksUnlinked.",
          "new_line_content": "        if (pindexFirstMissing == NULL) assert(!foundInUnlinked); // We aren't missing data for any parent -- cannot be in mapBlocksUnlinked.",
          "content_same": false
        },
        {
          "line": 1884,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainParams.GetConsensus()",
          "old_line_content": "        int nUpgraded = 0;",
          "new_line_content": "            ThresholdState state = checker.GetStateFor(pindex, chainParams.GetConsensus(), warningcache[bit]);",
          "content_same": false
        },
        {
          "line": 1886,
          "old_api": null,
          "new_api": "_",
          "old_text": null,
          "new_text": "_(\"Warning: unknown new rules activated (versionbit %i)\")",
          "old_line_content": "        for (int bit = 0; bit < VERSIONBITS_NUM_BITS; bit++) {",
          "new_line_content": "                const std::string strWarning = strprintf(_(\"Warning: unknown new rules activated (versionbit %i)\"), bit);",
          "content_same": false
        },
        {
          "line": 3941,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "setBlockIndexCandidates.count(pindex)",
          "old_line_content": "            //    data for some intermediate block between chainActive and the",
          "new_line_content": "            if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && setBlockIndexCandidates.count(pindex) == 0) {",
          "content_same": false
        },
        {
          "line": 3943,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(foundInUnlinked)",
          "old_line_content": "            // So if this block is itself better than chainActive.Tip() and it wasn't in",
          "new_line_content": "                    assert(foundInUnlinked);",
          "content_same": false
        },
        {
          "line": 1897,
          "old_api": null,
          "new_api": "GetConsensus",
          "old_text": null,
          "new_text": "chainParams.GetConsensus()",
          "old_line_content": "        }",
          "new_line_content": "            int32_t nExpectedVersion = ComputeBlockVersion(pindex->pprev, chainParams.GetConsensus());",
          "content_same": false
        },
        {
          "line": 1903,
          "old_api": null,
          "new_api": "_",
          "old_text": null,
          "new_text": "_(\"%d of last 100 blocks have unexpected version\")",
          "old_line_content": "                ++nUpgraded;",
          "new_line_content": "            warningMessages.push_back(strprintf(_(\"%d of last 100 blocks have unexpected version\"), nUpgraded));",
          "content_same": false
        },
        {
          "line": 3951,
          "old_api": null,
          "new_api": "equal_range",
          "old_text": null,
          "new_text": "forward.equal_range(pindex)",
          "old_line_content": "        // assert(pindex->GetBlockHash() == pindex->GetBlockHeader().GetHash()); // Perhaps too slow",
          "new_line_content": "        std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> range = forward.equal_range(pindex);",
          "content_same": false
        },
        {
          "line": 1906,
          "old_api": null,
          "new_api": "_",
          "old_text": null,
          "new_text": "_(\"Warning: Unknown block versions being mined! It's possible unknown rules are in effect\")",
          "old_line_content": "        if (nUpgraded > 0)",
          "new_line_content": "            std::string strWarning = _(\"Warning: Unknown block versions being mined! It's possible unknown rules are in effect\");",
          "content_same": false
        },
        {
          "line": 1908,
          "old_api": null,
          "new_api": "DoWarning",
          "old_text": null,
          "new_text": "DoWarning(strWarning)",
          "old_line_content": "        if (nUpgraded > 100/2)",
          "new_line_content": "            DoWarning(strWarning);",
          "content_same": false
        },
        {
          "line": 1911,
          "old_api": null,
          "new_api": "1fMiB",
          "old_text": null,
          "new_text": "LogPrintf(\"%s: new best=%s height=%d version=0x%08x log2_work=%.8g tx=%lu date='%s' progress=%f cache=%.1fMiB(%utxo)\", __func__,\n      chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(), chainActive.Tip()->nVersion,\n      log(chainActive.Tip()->nChainWork.getdouble())/log(2.0), (unsigned long)chainActive.Tip()->nChainTx,\n      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()),\n      GuessVerificationProgress(chainParams.TxData(), chainActive.Tip()), pcoinsTip->DynamicMemoryUsage() * (1.0 / (1<<20)), pcoinsTip->GetCacheSize())",
          "old_line_content": "            // notify GetWarnings(), called by Qt and the JSON-RPC code to warn the user:",
          "new_line_content": "    LogPrintf(\"%s: new best=%s height=%d version=0x%08x log2_work=%.8g tx=%lu date='%s' progress=%f cache=%.1fMiB(%utxo)\", __func__,",
          "content_same": false
        },
        {
          "line": 1913,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "        }",
          "new_line_content": "      log(chainActive.Tip()->nChainWork.getdouble())/log(2.0), (unsigned long)chainActive.Tip()->nChainTx,",
          "content_same": false
        },
        {
          "line": 1914,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()->GetBlockTime()",
          "old_line_content": "    }",
          "new_line_content": "      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()),",
          "content_same": false
        },
        {
          "line": 3973,
          "old_api": null,
          "new_api": "equal_range",
          "old_text": null,
          "new_text": "forward.equal_range(pindexPar)",
          "old_line_content": "            if (pindex == pindexFirstNotScriptsValid) pindexFirstNotScriptsValid = NULL;",
          "new_line_content": "            std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangePar = forward.equal_range(pindexPar);",
          "content_same": false
        },
        {
          "line": 3975,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(rangePar.first != rangePar.second)",
          "old_line_content": "            CBlockIndex* pindexPar = pindex->pprev;",
          "new_line_content": "                assert(rangePar.first != rangePar.second); // Our parent must have at least the node we're coming from as child.",
          "content_same": false
        },
        {
          "line": 1934,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "  * in any case).",
          "new_line_content": "    CBlockIndex *pindexDelete = chainActive.Tip();",
          "content_same": false
        },
        {
          "line": 1935,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(pindexDelete)",
          "old_line_content": "  */",
          "new_line_content": "    assert(pindexDelete);",
          "content_same": false
        },
        {
          "line": 1937,
          "old_api": null,
          "new_api": "std::make_shared<CBlock>()",
          "old_text": null,
          "new_text": "std::make_shared<CBlock>()",
          "old_line_content": "{",
          "new_line_content": "    std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();",
          "content_same": false
        },
        {
          "line": 1940,
          "old_api": null,
          "new_api": "AbortNode",
          "old_text": null,
          "new_text": "AbortNode(state, \"Failed to read block\")",
          "old_line_content": "    // Read block from disk.",
          "new_line_content": "        return AbortNode(state, \"Failed to read block\");",
          "content_same": false
        },
        {
          "line": 1942,
          "old_api": null,
          "new_api": "GetTimeMicros",
          "old_text": null,
          "new_text": "GetTimeMicros()",
          "old_line_content": "    CBlock& block = *pblock;",
          "new_line_content": "    int64_t nStart = GetTimeMicros();",
          "content_same": false
        },
        {
          "line": 1945,
          "old_api": null,
          "new_api": "DisconnectBlock",
          "old_text": null,
          "new_text": "DisconnectBlock(block, pindexDelete, view)",
          "old_line_content": "    // Apply the block atomically to the chain state.",
          "new_line_content": "        if (DisconnectBlock(block, pindexDelete, view) != DISCONNECT_OK)",
          "content_same": false
        },
        {
          "line": 3994,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "forward.size()",
          "old_line_content": "        }",
          "new_line_content": "    assert(nNodes == forward.size());",
          "content_same": false
        },
        {
          "line": 1947,
          "old_api": null,
          "new_api": "Flush",
          "old_text": null,
          "new_text": "view.Flush()",
          "old_line_content": "    {",
          "new_line_content": "        bool flushed = view.Flush();",
          "content_same": false
        },
        {
          "line": 1948,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(flushed)",
          "old_line_content": "        CCoinsViewCache view(pcoinsTip);",
          "new_line_content": "        assert(flushed);",
          "content_same": false
        },
        {
          "line": 3999,
          "old_api": null,
          "new_api": "DateTimeStrFormat",
          "old_text": null,
          "new_text": "DateTimeStrFormat(\"%Y-%m-%d\", nTimeLast)",
          "old_line_content": "}",
          "new_line_content": "    return strprintf(\"CBlockFileInfo(blocks=%u, size=%u, heights=%u...%u, time=%s...%s)\", nBlocks, nSize, nHeightFirst, nHeightLast, DateTimeStrFormat(\"%Y-%m-%d\", nTimeFirst), DateTimeStrFormat(\"%Y-%m-%d\", nTimeLast));",
          "content_same": false
        },
        {
          "line": 4004,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "vinfoBlockFile.at(n)",
          "old_line_content": "}",
          "new_line_content": "    return &vinfoBlockFile.at(n);",
          "content_same": false
        },
        {
          "line": 1957,
          "old_api": null,
          "new_api": "rend",
          "old_text": null,
          "new_text": "block.vtx.rend()",
          "old_line_content": "        return false;",
          "new_line_content": "        for (auto it = block.vtx.rbegin(); it != block.vtx.rend(); ++it) {",
          "content_same": false
        },
        {
          "line": 1958,
          "old_api": null,
          "new_api": "addTransaction",
          "old_text": null,
          "new_text": "disconnectpool->addTransaction(*it)",
          "old_line_content": "",
          "new_line_content": "            disconnectpool->addTransaction(*it);",
          "content_same": false
        },
        {
          "line": 1960,
          "old_api": null,
          "new_api": "DynamicMemoryUsage",
          "old_text": null,
          "new_text": "disconnectpool->DynamicMemoryUsage()",
          "old_line_content": "        // Save transactions to re-add to mempool at end of reorg",
          "new_line_content": "        while (disconnectpool->DynamicMemoryUsage() > MAX_DISCONNECTED_TX_POOL_SIZE * 1000) {",
          "content_same": false
        },
        {
          "line": 4009,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "}",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 4010,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "",
          "new_line_content": "    return VersionBitsState(chainActive.Tip(), params, pos, versionbitscache);",
          "content_same": false
        },
        {
          "line": 1963,
          "old_api": null,
          "new_api": "removeRecursive",
          "old_text": null,
          "new_text": "mempool.removeRecursive(**it, MemPoolRemovalReason::REORG)",
          "old_line_content": "        }",
          "new_line_content": "            mempool.removeRecursive(**it, MemPoolRemovalReason::REORG);",
          "content_same": false
        },
        {
          "line": 4015,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "}",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 4016,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "",
          "new_line_content": "    return VersionBitsStatistics(chainActive.Tip(), params, pos);",
          "content_same": false
        },
        {
          "line": 1969,
          "old_api": null,
          "new_api": "UpdateTip",
          "old_text": null,
          "new_text": "UpdateTip(pindexDelete->pprev, chainparams)",
          "old_line_content": "        }",
          "new_line_content": "    UpdateTip(pindexDelete->pprev, chainparams);",
          "content_same": false
        },
        {
          "line": 1972,
          "old_api": null,
          "new_api": "BlockDisconnected",
          "old_text": null,
          "new_text": "GetMainSignals().BlockDisconnected(pblock)",
          "old_line_content": "    // Update chainActive and related variables.",
          "new_line_content": "    GetMainSignals().BlockDisconnected(pblock);",
          "content_same": false
        },
        {
          "line": 4021,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs_main)",
          "old_line_content": "}",
          "new_line_content": "    LOCK(cs_main);",
          "content_same": false
        },
        {
          "line": 4022,
          "old_api": null,
          "new_api": "Tip",
          "old_text": null,
          "new_text": "chainActive.Tip()",
          "old_line_content": "",
          "new_line_content": "    return VersionBitsStateSinceHeight(chainActive.Tip(), params, pos, versionbitscache);",
          "content_same": false
        },
        {
          "line": 4029,
          "old_api": null,
          "new_api": "Params",
          "old_text": null,
          "new_text": "Params()",
          "old_line_content": "static const uint64_t MEMPOOL_DUMP_VERSION = 1;",
          "new_line_content": "    const CChainParams& chainparams = Params();",
          "content_same": false
        },
        {
          "line": 4030,
          "old_api": null,
          "new_api": "GetArg",
          "old_text": null,
          "new_text": "GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY)",
          "old_line_content": "",
          "new_line_content": "    int64_t nExpiryTimeout = GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60;",
          "content_same": false
        },
        {
          "line": 4031,
          "old_api": null,
          "new_api": "GetDataDir",
          "old_text": null,
          "new_text": "GetDataDir()",
          "old_line_content": "bool LoadMempool(void)",
          "new_line_content": "    FILE* filestr = fsbridge::fopen(GetDataDir() / \"mempool.dat\", \"rb\");",
          "content_same": false
        },
        {
          "line": 1986,
          "old_api": null,
          "new_api": "std::make_shared<std::vector<CTransactionRef>>()",
          "old_text": null,
          "new_text": "std::make_shared<std::vector<CTransactionRef>>()",
          "old_line_content": "struct PerBlockConnectTrace {",
          "new_line_content": "    PerBlockConnectTrace() : conflictedTxs(std::make_shared<std::vector<CTransactionRef>>()) {}",
          "content_same": false
        },
        {
          "line": 4041,
          "old_api": null,
          "new_api": "GetTime",
          "old_text": null,
          "new_text": "GetTime()",
          "old_line_content": "",
          "new_line_content": "    int64_t nNow = GetTime();",
          "content_same": false
        },
        {
          "line": 2011,
          "old_api": null,
          "new_api": "boost::bind(&ConnectTrace::NotifyEntryRemoved, this, _1, _2)",
          "old_text": null,
          "new_text": "boost::bind(&ConnectTrace::NotifyEntryRemoved, this, _1, _2)",
          "old_line_content": "    CTxMemPool &pool;",
          "new_line_content": "        pool.NotifyEntryRemoved.connect(boost::bind(&ConnectTrace::NotifyEntryRemoved, this, _1, _2));",
          "content_same": false
        },
        {
          "line": 4061,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "tx->GetHash()",
          "old_line_content": "            file >> nFeeDelta;",
          "new_line_content": "                mempool.PrioritiseTransaction(tx->GetHash(), amountdelta);",
          "content_same": false
        },
        {
          "line": 4066,
          "old_api": null,
          "new_api": "AcceptToMemoryPoolWithTime",
          "old_text": null,
          "new_text": "AcceptToMemoryPoolWithTime(chainparams, mempool, state, tx, true, NULL, nTime, NULL, false, 0)",
          "old_line_content": "            }",
          "new_line_content": "                AcceptToMemoryPoolWithTime(chainparams, mempool, state, tx, true, NULL, nTime, NULL, false, 0);",
          "content_same": false
        },
        {
          "line": 4067,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "state.IsValid()",
          "old_line_content": "            CValidationState state;",
          "new_line_content": "                if (state.IsValid()) {",
          "content_same": false
        },
        {
          "line": 2020,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(pindex)",
          "old_line_content": "    }",
          "new_line_content": "        assert(pindex);",
          "content_same": false
        },
        {
          "line": 2021,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(pblock)",
          "old_line_content": "",
          "new_line_content": "        assert(pblock);",
          "content_same": false
        },
        {
          "line": 2022,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "blocksConnected.back()",
          "old_line_content": "    void BlockConnected(CBlockIndex* pindex, std::shared_ptr<const CBlock> pblock) {",
          "new_line_content": "        blocksConnected.back().pindex = pindex;",
          "content_same": false
        },
        {
          "line": 4075,
          "old_api": null,
          "new_api": "ShutdownRequested",
          "old_text": null,
          "new_text": "ShutdownRequested()",
          "old_line_content": "                }",
          "new_line_content": "            if (ShutdownRequested())",
          "content_same": false
        },
        {
          "line": 2033,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "blocksConnected.back()",
          "old_line_content": "        // blocks are added after all the conflicted transactions have",
          "new_line_content": "        assert(!blocksConnected.back().pindex);",
          "content_same": false
        },
        {
          "line": 2034,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "blocksConnected.back().conflictedTxs->empty()",
          "old_line_content": "        // been filled in. Thus, the last entry should always be an empty",
          "new_line_content": "        assert(blocksConnected.back().conflictedTxs->empty());",
          "content_same": false
        },
        {
          "line": 2035,
          "old_api": null,
          "new_api": "pop_back",
          "old_text": null,
          "new_text": "blocksConnected.pop_back()",
          "old_line_content": "        // one waiting for the transactions from the next block. We pop",
          "new_line_content": "        blocksConnected.pop_back();",
          "content_same": false
        },
        {
          "line": 4082,
          "old_api": null,
          "new_api": "PrioritiseTransaction",
          "old_text": null,
          "new_text": "mempool.PrioritiseTransaction(i.first, i.second)",
          "old_line_content": "        std::map<uint256, CAmount> mapDeltas;",
          "new_line_content": "            mempool.PrioritiseTransaction(i.first, i.second);",
          "content_same": false
        },
        {
          "line": 4085,
          "old_api": null,
          "new_api": "what",
          "old_text": null,
          "new_text": "e.what()",
          "old_line_content": "        for (const auto& i : mapDeltas) {",
          "new_line_content": "        LogPrintf(\"Failed to deserialize mempool data on disk: %s. Continuing anyway.\\n\", e.what());",
          "content_same": false
        },
        {
          "line": 2040,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "blocksConnected.back()",
          "old_line_content": "        return blocksConnected;",
          "new_line_content": "        assert(!blocksConnected.back().pindex);",
          "content_same": false
        },
        {
          "line": 2042,
          "old_api": null,
          "new_api": "std::move(txRemoved)",
          "old_text": null,
          "new_text": "std::move(txRemoved)",
          "old_line_content": "",
          "new_line_content": "            blocksConnected.back().conflictedTxs->emplace_back(std::move(txRemoved));",
          "content_same": false
        },
        {
          "line": 4095,
          "old_api": null,
          "new_api": "GetTimeMicros",
          "old_text": null,
          "new_text": "GetTimeMicros()",
          "old_line_content": "}",
          "new_line_content": "    int64_t start = GetTimeMicros();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 4099,
          "old_api": "GetTimeMicros",
          "new_api": null,
          "old_text": "GetTimeMicros()",
          "new_text": null,
          "old_line_content": "    int64_t start = GetTimeMicros();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2059,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "    assert(pindexNew->pprev == chainActive.Tip());",
          "new_line_content": "    if (!pblock) {",
          "content_same": false
        },
        {
          "line": 4109,
          "old_api": "infoAll",
          "new_api": null,
          "old_text": "mempool.infoAll()",
          "new_text": null,
          "old_line_content": "        vinfo = mempool.infoAll();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2064,
          "old_api": "std::make_shared<CBlock>()",
          "new_api": null,
          "old_text": "std::make_shared<CBlock>()",
          "new_text": null,
          "old_line_content": "        std::shared_ptr<CBlock> pblockNew = std::make_shared<CBlock>();",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 2065,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "        if (!ReadBlockFromDisk(*pblockNew, pindexNew, chainparams.GetConsensus()))",
          "new_line_content": "        pthisBlock = pblock;",
          "content_same": false
        },
        {
          "line": 2066,
          "old_api": "AbortNode",
          "new_api": null,
          "old_text": "AbortNode(state, \"Failed to read block\")",
          "new_text": null,
          "old_line_content": "            return AbortNode(state, \"Failed to read block\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4112,
          "old_api": "GetTimeMicros",
          "new_api": null,
          "old_text": "GetTimeMicros()",
          "new_text": null,
          "old_line_content": "    int64_t mid = GetTimeMicros();",
          "new_line_content": "        if (!filestr) {",
          "content_same": false
        },
        {
          "line": 4115,
          "old_api": "GetDataDir",
          "new_api": null,
          "old_text": "GetDataDir()",
          "new_text": null,
          "old_line_content": "        FILE* filestr = fsbridge::fopen(GetDataDir() / \"mempool.dat.new\", \"wb\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2073,
          "old_api": "GetTimeMicros",
          "new_api": null,
          "old_text": "GetTimeMicros()",
          "new_text": null,
          "old_line_content": "    int64_t nTime2 = GetTimeMicros(); nTimeReadFromDisk += nTime2 - nTime1;",
          "new_line_content": "        CCoinsViewCache view(pcoinsTip);",
          "content_same": false
        },
        {
          "line": 4125,
          "old_api": "size",
          "new_api": null,
          "old_text": "vinfo.size()",
          "new_text": null,
          "old_line_content": "        file << (uint64_t)vinfo.size();",
          "new_line_content": "            file << (int64_t)i.nFeeDelta;",
          "content_same": false
        },
        {
          "line": 2085,
          "old_api": "GetTimeMicros",
          "new_api": null,
          "old_text": "GetTimeMicros()",
          "new_text": null,
          "old_line_content": "        nTime3 = GetTimeMicros(); nTimeConnectTotal += nTime3 - nTime2;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4135,
          "old_api": "fclose",
          "new_api": null,
          "old_text": "file.fclose()",
          "new_text": null,
          "old_line_content": "        file.fclose();",
          "new_line_content": "    } catch (const std::exception& e) {",
          "content_same": false
        },
        {
          "line": 2088,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(flushed)",
          "new_text": null,
          "old_line_content": "        assert(flushed);",
          "new_line_content": "    // Write the chain state to disk, if necessary.",
          "content_same": false
        },
        {
          "line": 4137,
          "old_api": "GetTimeMicros",
          "new_api": null,
          "old_text": "GetTimeMicros()",
          "new_text": null,
          "old_line_content": "        int64_t last = GetTimeMicros();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2090,
          "old_api": "GetTimeMicros",
          "new_api": null,
          "old_text": "GetTimeMicros()",
          "new_text": null,
          "old_line_content": "    int64_t nTime4 = GetTimeMicros(); nTimeFlush += nTime4 - nTime3;",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 4138,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"Dumped mempool: %gs to copy, %gs to dump\\n\", (mid-start)*0.000001, (last-mid)*0.000001)",
          "new_text": null,
          "old_line_content": "        LogPrintf(\"Dumped mempool: %gs to copy, %gs to dump\\n\", (mid-start)*0.000001, (last-mid)*0.000001);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 4140,
          "old_api": "what",
          "new_api": null,
          "old_text": "e.what()",
          "new_text": null,
          "old_line_content": "        LogPrintf(\"Failed to dump mempool: %s. Continuing anyway.\\n\", e.what());",
          "new_line_content": "//! Guess how far we are in the verification process at the given block index",
          "content_same": false
        },
        {
          "line": 2093,
          "old_api": "FlushStateToDisk",
          "new_api": null,
          "old_text": "FlushStateToDisk(chainparams, state, FLUSH_STATE_IF_NEEDED)",
          "new_text": null,
          "old_line_content": "    if (!FlushStateToDisk(chainparams, state, FLUSH_STATE_IF_NEEDED))",
          "new_line_content": "    // Remove conflicting transactions from the mempool.;",
          "content_same": false
        },
        {
          "line": 2096,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::BENCH, \"  - Writing chainstate: %.2fms [%.2fs]\\n\", (nTime5 - nTime4) * 0.001, nTimeChainState * 0.000001)",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::BENCH, \"  - Writing chainstate: %.2fms [%.2fs]\\n\", (nTime5 - nTime4) * 0.001, nTimeChainState * 0.000001);",
          "new_line_content": "    // Update chainActive & related variables.",
          "content_same": false
        },
        {
          "line": 2098,
          "old_api": "removeForBlock",
          "new_api": null,
          "old_text": "mempool.removeForBlock(blockConnecting.vtx, pindexNew->nHeight)",
          "new_text": null,
          "old_line_content": "    mempool.removeForBlock(blockConnecting.vtx, pindexNew->nHeight);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4149,
          "old_api": "time",
          "new_api": null,
          "old_text": "time(NULL)",
          "new_text": null,
          "old_line_content": "    int64_t nNow = time(NULL);",
          "new_line_content": "    if (pindex->nChainTx <= data.nTxCount) {",
          "content_same": false
        },
        {
          "line": 2104,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::BENCH, \"  - Connect postprocess: %.2fms [%.2fs]\\n\", (nTime6 - nTime5) * 0.001, nTimePostConnect * 0.000001)",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::BENCH, \"  - Connect postprocess: %.2fms [%.2fs]\\n\", (nTime6 - nTime5) * 0.001, nTimePostConnect * 0.000001);",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 2105,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::BENCH, \"- Connect block: %.2fms [%.2fs]\\n\", (nTime6 - nTime1) * 0.001, nTimeTotal * 0.000001)",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::BENCH, \"- Connect block: %.2fms [%.2fs]\\n\", (nTime6 - nTime1) * 0.001, nTimeTotal * 0.000001);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2107,
          "old_api": "std::move(pthisBlock)",
          "new_api": null,
          "old_text": "std::move(pthisBlock)",
          "new_text": null,
          "old_line_content": "    connectTrace.BlockConnected(pindexNew, std::move(pthisBlock));",
          "new_line_content": "/**",
          "content_same": false
        },
        {
          "line": 4156,
          "old_api": "GetBlockTime",
          "new_api": null,
          "old_text": "pindex->GetBlockTime()",
          "new_text": null,
          "old_line_content": "        fTxTotal = pindex->nChainTx + (nNow - pindex->GetBlockTime()) * data.dTxRate;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 4168,
          "old_api": "begin",
          "new_api": null,
          "old_text": "mapBlockIndex.begin()",
          "new_text": null,
          "old_line_content": "        BlockMap::iterator it1 = mapBlockIndex.begin();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2121,
          "old_api": "rbegin",
          "new_api": null,
          "old_text": "setBlockIndexCandidates.rbegin()",
          "new_text": null,
          "old_line_content": "            std::set<CBlockIndex*, CBlockIndexWorkComparator>::reverse_iterator it = setBlockIndexCandidates.rbegin();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2122,
          "old_api": "rend",
          "new_api": null,
          "old_text": "setBlockIndexCandidates.rend()",
          "new_text": null,
          "old_line_content": "            if (it == setBlockIndexCandidates.rend())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4169,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapBlockIndex.end()",
          "new_text": null,
          "old_line_content": "        for (; it1 != mapBlockIndex.end(); it1++)",
          "new_line_content": "} instance_of_cmaincleanup;",
          "content_same": false
        },
        {
          "line": 4171,
          "old_api": "clear",
          "new_api": null,
          "old_text": "mapBlockIndex.clear()",
          "new_text": null,
          "old_line_content": "        mapBlockIndex.clear();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2131,
          "old_api": "Contains",
          "new_api": null,
          "old_text": "chainActive.Contains(pindexTest)",
          "new_text": null,
          "old_line_content": "        while (pindexTest && !chainActive.Contains(pindexTest)) {",
          "new_line_content": "            // which block files have been deleted.  Remove those as candidates",
          "content_same": false
        },
        {
          "line": 2132,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(pindexTest->nChainTx || pindexTest->nHeight == 0)",
          "new_text": null,
          "old_line_content": "            assert(pindexTest->nChainTx || pindexTest->nHeight == 0);",
          "new_line_content": "            // for the most work chain if we come across them; we can't switch",
          "content_same": false
        },
        {
          "line": 2153,
          "old_api": "std::make_pair(pindexFailed->pprev, pindexFailed)",
          "new_api": null,
          "old_text": "std::make_pair(pindexFailed->pprev, pindexFailed)",
          "new_text": null,
          "old_line_content": "                        mapBlocksUnlinked.insert(std::make_pair(pindexFailed->pprev, pindexFailed));",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 2155,
          "old_api": "erase",
          "new_api": null,
          "old_text": "setBlockIndexCandidates.erase(pindexFailed)",
          "new_text": null,
          "old_line_content": "                    setBlockIndexCandidates.erase(pindexFailed);",
          "new_line_content": "                fInvalidAncestor = true;",
          "content_same": false
        },
        {
          "line": 2158,
          "old_api": "erase",
          "new_api": null,
          "old_text": "setBlockIndexCandidates.erase(pindexTest)",
          "new_text": null,
          "old_line_content": "                setBlockIndexCandidates.erase(pindexTest);",
          "new_line_content": "            pindexTest = pindexTest->pprev;",
          "content_same": false
        },
        {
          "line": 2173,
          "old_api": "begin",
          "new_api": null,
          "old_text": "setBlockIndexCandidates.begin()",
          "new_text": null,
          "old_line_content": "    std::set<CBlockIndex*, CBlockIndexWorkComparator>::iterator it = setBlockIndexCandidates.begin();",
          "new_line_content": "    // Either the current tip or a successor of it we're working towards is left in setBlockIndexCandidates.",
          "content_same": false
        },
        {
          "line": 2175,
          "old_api": "erase",
          "new_api": null,
          "old_text": "setBlockIndexCandidates.erase(it++)",
          "new_text": null,
          "old_line_content": "        setBlockIndexCandidates.erase(it++);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2178,
          "old_api": "empty",
          "new_api": null,
          "old_text": "setBlockIndexCandidates.empty()",
          "new_text": null,
          "old_line_content": "    assert(!setBlockIndexCandidates.empty());",
          "new_line_content": " * Try to make some progress towards making pindexMostWork the active block.",
          "content_same": false
        },
        {
          "line": 2187,
          "old_api": "AssertLockHeld",
          "new_api": null,
          "old_text": "AssertLockHeld(cs_main)",
          "new_text": null,
          "old_line_content": "    AssertLockHeld(cs_main);",
          "new_line_content": "    // Disconnect active blocks which are no longer in the best chain.",
          "content_same": false
        },
        {
          "line": 2188,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "    const CBlockIndex *pindexOldTip = chainActive.Tip();",
          "new_line_content": "    bool fBlocksDisconnected = false;",
          "content_same": false
        },
        {
          "line": 2189,
          "old_api": "FindFork",
          "new_api": null,
          "old_text": "chainActive.FindFork(pindexMostWork)",
          "new_text": null,
          "old_line_content": "    const CBlockIndex *pindexFork = chainActive.FindFork(pindexMostWork);",
          "new_line_content": "    DisconnectedBlockTransactions disconnectpool;",
          "content_same": false
        },
        {
          "line": 2195,
          "old_api": "DisconnectTip",
          "new_api": null,
          "old_text": "DisconnectTip(state, chainparams, &disconnectpool)",
          "new_text": null,
          "old_line_content": "        if (!DisconnectTip(state, chainparams, &disconnectpool)) {",
          "new_line_content": "            return false;",
          "content_same": false
        },
        {
          "line": 2198,
          "old_api": "UpdateMempoolForReorg",
          "new_api": null,
          "old_text": "UpdateMempoolForReorg(disconnectpool, false)",
          "new_text": null,
          "old_line_content": "            UpdateMempoolForReorg(disconnectpool, false);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2211,
          "old_api": "std::min(nHeight + 32, pindexMostWork->nHeight)",
          "new_api": null,
          "old_text": "std::min(nHeight + 32, pindexMostWork->nHeight)",
          "new_text": null,
          "old_line_content": "        int nTargetHeight = std::min(nHeight + 32, pindexMostWork->nHeight);",
          "new_line_content": "        while (pindexIter && pindexIter->nHeight != nHeight) {",
          "content_same": false
        },
        {
          "line": 2213,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "vpindexToConnect.reserve(nTargetHeight - nHeight)",
          "new_text": null,
          "old_line_content": "        vpindexToConnect.reserve(nTargetHeight - nHeight);",
          "new_line_content": "            pindexIter = pindexIter->pprev;",
          "content_same": false
        },
        {
          "line": 2214,
          "old_api": "GetAncestor",
          "new_api": null,
          "old_text": "pindexMostWork->GetAncestor(nTargetHeight)",
          "new_text": null,
          "old_line_content": "        CBlockIndex *pindexIter = pindexMostWork->GetAncestor(nTargetHeight);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2216,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "vpindexToConnect.push_back(pindexIter)",
          "new_text": null,
          "old_line_content": "            vpindexToConnect.push_back(pindexIter);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2226,
          "old_api": "CorruptionPossible",
          "new_api": null,
          "old_text": "state.CorruptionPossible()",
          "new_text": null,
          "old_line_content": "                    if (!state.CorruptionPossible())",
          "new_line_content": "                    fContinue = false;",
          "content_same": false
        },
        {
          "line": 2227,
          "old_api": "back",
          "new_api": null,
          "old_text": "vpindexToConnect.back()",
          "new_text": null,
          "old_line_content": "                        InvalidChainFound(vpindexToConnect.back());",
          "new_line_content": "                    break;",
          "content_same": false
        },
        {
          "line": 2228,
          "old_api": "CValidationState",
          "new_api": null,
          "old_text": "CValidationState()",
          "new_text": null,
          "old_line_content": "                    state = CValidationState();",
          "new_line_content": "                } else {",
          "content_same": false
        },
        {
          "line": 2240,
          "old_api": "PruneBlockIndexCandidates",
          "new_api": null,
          "old_text": "PruneBlockIndexCandidates()",
          "new_text": null,
          "old_line_content": "                PruneBlockIndexCandidates();",
          "new_line_content": "                    break;",
          "content_same": false
        },
        {
          "line": 2241,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "                if (!pindexOldTip || chainActive.Tip()->nChainWork > pindexOldTip->nChainWork) {",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 2253,
          "old_api": "UpdateMempoolForReorg",
          "new_api": null,
          "old_text": "UpdateMempoolForReorg(disconnectpool, true)",
          "new_text": null,
          "old_line_content": "        UpdateMempoolForReorg(disconnectpool, true);",
          "new_line_content": "    // Callbacks/notifications for a new best chain.",
          "content_same": false
        },
        {
          "line": 2259,
          "old_api": "back",
          "new_api": null,
          "old_text": "vpindexToConnect.back()",
          "new_text": null,
          "old_line_content": "        CheckForkWarningConditionsOnNewFork(vpindexToConnect.back());",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 2261,
          "old_api": "CheckForkWarningConditions",
          "new_api": null,
          "old_text": "CheckForkWarningConditions()",
          "new_text": null,
          "old_line_content": "        CheckForkWarningConditions();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2272,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "        LOCK(cs_main);",
          "new_line_content": "            fNotify = true;",
          "content_same": false
        },
        {
          "line": 2277,
          "old_api": "IsInitialBlockDownload",
          "new_api": null,
          "old_text": "IsInitialBlockDownload()",
          "new_text": null,
          "old_line_content": "            fInitialBlockDownload = IsInitialBlockDownload();",
          "new_line_content": "    // Send block tip changed notifications without cs_main",
          "content_same": false
        },
        {
          "line": 2283,
          "old_api": "NotifyHeaderTip",
          "new_api": null,
          "old_text": "uiInterface.NotifyHeaderTip(fInitialBlockDownload, pindexHeader)",
          "new_text": null,
          "old_line_content": "        uiInterface.NotifyHeaderTip(fInitialBlockDownload, pindexHeader);",
          "new_line_content": "/**",
          "content_same": false
        },
        {
          "line": 2300,
          "old_api": "GetArg",
          "new_api": null,
          "old_text": "GetArg(\"-stopatheight\", DEFAULT_STOPATHEIGHT)",
          "new_text": null,
          "old_line_content": "    int nStopAtHeight = GetArg(\"-stopatheight\", DEFAULT_STOPATHEIGHT);",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 2302,
          "old_api": "boost::this_thread::interruption_point()",
          "new_api": null,
          "old_text": "boost::this_thread::interruption_point()",
          "new_text": null,
          "old_line_content": "        boost::this_thread::interruption_point();",
          "new_line_content": "        const CBlockIndex *pindexFork;",
          "content_same": false
        },
        {
          "line": 2303,
          "old_api": "ShutdownRequested",
          "new_api": null,
          "old_text": "ShutdownRequested()",
          "new_text": null,
          "old_line_content": "        if (ShutdownRequested())",
          "new_line_content": "        bool fInitialDownload;",
          "content_same": false
        },
        {
          "line": 2309,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "            LOCK(cs_main);",
          "new_line_content": "            if (pindexMostWork == NULL) {",
          "content_same": false
        },
        {
          "line": 2312,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "            CBlockIndex *pindexOldTip = chainActive.Tip();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2318,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "            if (pindexMostWork == NULL || pindexMostWork == chainActive.Tip())",
          "new_line_content": "            std::shared_ptr<const CBlock> nullBlockPtr;",
          "content_same": false
        },
        {
          "line": 2323,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindexMostWork->GetBlockHash()",
          "new_text": null,
          "old_line_content": "            if (!ActivateBestChainStep(state, chainparams, pindexMostWork, pblock && pblock->GetHash() == pindexMostWork->GetBlockHash() ? pblock : nullBlockPtr, fInvalidFound, connectTrace))",
          "new_line_content": "                // Wipe cache, we may need another branch now.",
          "content_same": false
        },
        {
          "line": 2334,
          "old_api": "GetBlocksConnected",
          "new_api": null,
          "old_text": "connectTrace.GetBlocksConnected()",
          "new_text": null,
          "old_line_content": "            for (const PerBlockConnectTrace& trace : connectTrace.GetBlocksConnected()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2335,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(trace.pblock && trace.pindex)",
          "new_text": null,
          "old_line_content": "                assert(trace.pblock && trace.pindex);",
          "new_line_content": "        // When we reach this point, we switched to a new tip (stored in pindexNewTip).",
          "content_same": false
        },
        {
          "line": 2336,
          "old_api": "BlockConnected",
          "new_api": null,
          "old_text": "GetMainSignals().BlockConnected(trace.pblock, trace.pindex, *trace.conflictedTxs)",
          "new_text": null,
          "old_line_content": "                GetMainSignals().BlockConnected(trace.pblock, trace.pindex, *trace.conflictedTxs);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2348,
          "old_api": "NotifyBlockTip",
          "new_api": null,
          "old_text": "uiInterface.NotifyBlockTip(fInitialDownload, pindexNewTip)",
          "new_text": null,
          "old_line_content": "            uiInterface.NotifyBlockTip(fInitialDownload, pindexNewTip);",
          "new_line_content": "    } while (pindexNewTip != pindexMostWork);",
          "content_same": false
        },
        {
          "line": 2351,
          "old_api": "StartShutdown",
          "new_api": null,
          "old_text": "StartShutdown()",
          "new_text": null,
          "old_line_content": "        if (nStopAtHeight && pindexNewTip && pindexNewTip->nHeight >= nStopAtHeight) StartShutdown();",
          "new_line_content": "    // Write changes periodically to disk, after relay.",
          "content_same": false
        },
        {
          "line": 2353,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "    CheckBlockIndex(chainparams.GetConsensus());",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 2356,
          "old_api": "FlushStateToDisk",
          "new_api": null,
          "old_text": "FlushStateToDisk(chainparams, state, FLUSH_STATE_PERIODIC)",
          "new_text": null,
          "old_line_content": "    if (!FlushStateToDisk(chainparams, state, FLUSH_STATE_PERIODIC)) {",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 2367,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "        LOCK(cs_main);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2376,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "        nLastPreciousChainwork = chainActive.Tip()->nChainWork;",
          "new_line_content": "            // We can't keep reducing the counter if somebody really wants to",
          "content_same": false
        },
        {
          "line": 2377,
          "old_api": "erase",
          "new_api": null,
          "old_text": "setBlockIndexCandidates.erase(pindex)",
          "new_text": null,
          "old_line_content": "        setBlockIndexCandidates.erase(pindex);",
          "new_line_content": "            // call preciousblock 2**31-1 times on the same set of tips...",
          "content_same": false
        },
        {
          "line": 2379,
          "old_api": "std::numeric_limits<int32_t>::min()",
          "new_api": null,
          "old_text": "std::numeric_limits<int32_t>::min()",
          "new_text": null,
          "old_line_content": "        if (nBlockReverseSequenceId > std::numeric_limits<int32_t>::min()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2384,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "pindex->IsValid(BLOCK_VALID_TRANSACTIONS)",
          "new_text": null,
          "old_line_content": "        if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && pindex->nChainTx) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2385,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setBlockIndexCandidates.insert(pindex)",
          "new_text": null,
          "old_line_content": "            setBlockIndexCandidates.insert(pindex);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2390,
          "old_api": "ActivateBestChain",
          "new_api": null,
          "old_text": "ActivateBestChain(state, params)",
          "new_text": null,
          "old_line_content": "    return ActivateBestChain(state, params);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2404,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "        CBlockIndex *pindexWalk = chainActive.Tip();",
          "new_line_content": "        // ActivateBestChain considers blocks already in chainActive",
          "content_same": false
        },
        {
          "line": 2407,
          "old_api": "erase",
          "new_api": null,
          "old_text": "setBlockIndexCandidates.erase(pindexWalk)",
          "new_text": null,
          "old_line_content": "        setBlockIndexCandidates.erase(pindexWalk);",
          "new_line_content": "            // It's probably hopeless to try to make the mempool consistent",
          "content_same": false
        },
        {
          "line": 2410,
          "old_api": "DisconnectTip",
          "new_api": null,
          "old_text": "DisconnectTip(state, chainparams, &disconnectpool)",
          "new_text": null,
          "old_line_content": "        if (!DisconnectTip(state, chainparams, &disconnectpool)) {",
          "new_line_content": "            return false;",
          "content_same": false
        },
        {
          "line": 2413,
          "old_api": "UpdateMempoolForReorg",
          "new_api": null,
          "old_text": "UpdateMempoolForReorg(disconnectpool, false)",
          "new_text": null,
          "old_line_content": "            UpdateMempoolForReorg(disconnectpool, false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2424,
          "old_api": "begin",
          "new_api": null,
          "old_text": "mapBlockIndex.begin()",
          "new_text": null,
          "old_line_content": "    BlockMap::iterator it = mapBlockIndex.begin();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2425,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapBlockIndex.end()",
          "new_text": null,
          "old_line_content": "    while (it != mapBlockIndex.end()) {",
          "new_line_content": "        it++;",
          "content_same": false
        },
        {
          "line": 2426,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "        if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->nChainTx && !setBlockIndexCandidates.value_comp()(it->second, chainActive.Tip())) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2427,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setBlockIndexCandidates.insert(it->second)",
          "new_text": null,
          "old_line_content": "            setBlockIndexCandidates.insert(it->second);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2432,
          "old_api": "InvalidChainFound",
          "new_api": null,
          "old_text": "InvalidChainFound(pindex)",
          "new_text": null,
          "old_line_content": "    InvalidChainFound(pindex);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2433,
          "old_api": "IsInitialBlockDownload",
          "new_api": null,
          "old_text": "IsInitialBlockDownload()",
          "new_text": null,
          "old_line_content": "    uiInterface.NotifyBlockTip(IsInitialBlockDownload(), pindex->pprev);",
          "new_line_content": "bool ResetBlockFailureFlags(CBlockIndex *pindex) {",
          "content_same": false
        },
        {
          "line": 2438,
          "old_api": "AssertLockHeld",
          "new_api": null,
          "old_text": "AssertLockHeld(cs_main)",
          "new_text": null,
          "old_line_content": "    AssertLockHeld(cs_main);",
          "new_line_content": "    // Remove the invalidity flag from this block and all its descendants.",
          "content_same": false
        },
        {
          "line": 2447,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setDirtyBlockIndex.insert(it->second)",
          "new_text": null,
          "old_line_content": "            setDirtyBlockIndex.insert(it->second);",
          "new_line_content": "            if (it->second == pindexBestInvalid) {",
          "content_same": false
        },
        {
          "line": 2448,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->nChainTx && setBlockIndexCandidates.value_comp()(chainActive.Tip(), it->second)) {",
          "new_line_content": "                // Reset invalid block marker if it was pointing to one of those.",
          "content_same": false
        },
        {
          "line": 2449,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setBlockIndexCandidates.insert(it->second)",
          "new_text": null,
          "old_line_content": "                setBlockIndexCandidates.insert(it->second);",
          "new_line_content": "                pindexBestInvalid = NULL;",
          "content_same": false
        },
        {
          "line": 2463,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setDirtyBlockIndex.insert(pindex)",
          "new_text": null,
          "old_line_content": "            setDirtyBlockIndex.insert(pindex);",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 2473,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "block.GetHash()",
          "new_text": null,
          "old_line_content": "    uint256 hash = block.GetHash();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2474,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapBlockIndex.find(hash)",
          "new_text": null,
          "old_line_content": "    BlockMap::iterator it = mapBlockIndex.find(hash);",
          "new_line_content": "    // Construct new block index object",
          "content_same": false
        },
        {
          "line": 2475,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapBlockIndex.end()",
          "new_text": null,
          "old_line_content": "    if (it != mapBlockIndex.end())",
          "new_line_content": "    CBlockIndex* pindexNew = new CBlockIndex(block);",
          "content_same": false
        },
        {
          "line": 2480,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(pindexNew)",
          "new_text": null,
          "old_line_content": "    assert(pindexNew);",
          "new_line_content": "    pindexNew->nSequenceId = 0;",
          "content_same": false
        },
        {
          "line": 2485,
          "old_api": "std::make_pair(hash, pindexNew)",
          "new_api": null,
          "old_text": "std::make_pair(hash, pindexNew)",
          "new_text": null,
          "old_line_content": "    BlockMap::iterator mi = mapBlockIndex.insert(std::make_pair(hash, pindexNew)).first;",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2487,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapBlockIndex.find(block.hashPrevBlock)",
          "new_text": null,
          "old_line_content": "    BlockMap::iterator miPrev = mapBlockIndex.find(block.hashPrevBlock);",
          "new_line_content": "        pindexNew->nHeight = pindexNew->pprev->nHeight + 1;",
          "content_same": false
        },
        {
          "line": 2494,
          "old_api": "std::max(pindexNew->pprev->nTimeMax, pindexNew->nTime)",
          "new_api": null,
          "old_text": "std::max(pindexNew->pprev->nTimeMax, pindexNew->nTime)",
          "new_text": null,
          "old_line_content": "    pindexNew->nTimeMax = (pindexNew->pprev ? std::max(pindexNew->pprev->nTimeMax, pindexNew->nTime) : pindexNew->nTime);",
          "new_line_content": "        pindexBestHeader = pindexNew;",
          "content_same": false
        },
        {
          "line": 2495,
          "old_api": "GetBlockProof",
          "new_api": null,
          "old_text": "GetBlockProof(*pindexNew)",
          "new_text": null,
          "old_line_content": "    pindexNew->nChainWork = (pindexNew->pprev ? pindexNew->pprev->nChainWork : 0) + GetBlockProof(*pindexNew);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2500,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setDirtyBlockIndex.insert(pindexNew)",
          "new_text": null,
          "old_line_content": "    setDirtyBlockIndex.insert(pindexNew);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2508,
          "old_api": "size",
          "new_api": null,
          "old_text": "block.vtx.size()",
          "new_text": null,
          "old_line_content": "    pindexNew->nTx = block.vtx.size();",
          "new_line_content": "    pindexNew->nUndoPos = 0;",
          "content_same": false
        },
        {
          "line": 2517,
          "old_api": "RaiseValidity",
          "new_api": null,
          "old_text": "pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS)",
          "new_text": null,
          "old_line_content": "    pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS);",
          "new_line_content": "        // If pindexNew is the genesis block or all parents are BLOCK_VALID_TRANSACTIONS.",
          "content_same": false
        },
        {
          "line": 2518,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setDirtyBlockIndex.insert(pindexNew)",
          "new_text": null,
          "old_line_content": "    setDirtyBlockIndex.insert(pindexNew);",
          "new_line_content": "        std::deque<CBlockIndex*> queue;",
          "content_same": false
        },
        {
          "line": 2526,
          "old_api": "empty",
          "new_api": null,
          "old_text": "queue.empty()",
          "new_text": null,
          "old_line_content": "        while (!queue.empty()) {",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 2528,
          "old_api": "pop_front",
          "new_api": null,
          "old_text": "queue.pop_front()",
          "new_text": null,
          "old_line_content": "            queue.pop_front();",
          "new_line_content": "                pindex->nSequenceId = nBlockSequenceId++;",
          "content_same": false
        },
        {
          "line": 2534,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "            if (chainActive.Tip() == NULL || !setBlockIndexCandidates.value_comp()(pindex, chainActive.Tip())) {",
          "new_line_content": "            while (range.first != range.second) {",
          "content_same": false
        },
        {
          "line": 2535,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setBlockIndexCandidates.insert(pindex)",
          "new_text": null,
          "old_line_content": "                setBlockIndexCandidates.insert(pindex);",
          "new_line_content": "                std::multimap<CBlockIndex*, CBlockIndex*>::iterator it = range.first;",
          "content_same": false
        },
        {
          "line": 2537,
          "old_api": "equal_range",
          "new_api": null,
          "old_text": "mapBlocksUnlinked.equal_range(pindex)",
          "new_text": null,
          "old_line_content": "            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex);",
          "new_line_content": "                range.first++;",
          "content_same": false
        },
        {
          "line": 2540,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "queue.push_back(it->second)",
          "new_text": null,
          "old_line_content": "                queue.push_back(it->second);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 495,
          "old_api": "size",
          "new_api": null,
          "old_text": "tx.vout.size()",
          "new_text": null,
          "old_line_content": "        for (size_t out = 0; out < tx.vout.size(); out++) {",
          "new_line_content": "        for (const CTxIn txin : tx.vin) {",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": "HaveCoin",
          "new_api": null,
          "old_text": "view.HaveCoin(outpoint)",
          "new_text": null,
          "old_line_content": "            if (view.HaveCoin(outpoint)) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2546,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "pindexNew->pprev->IsValid(BLOCK_VALID_TREE)",
          "new_text": null,
          "old_line_content": "        if (pindexNew->pprev && pindexNew->pprev->IsValid(BLOCK_VALID_TREE)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "coins_to_uncache.push_back(outpoint)",
          "new_text": null,
          "old_line_content": "                    coins_to_uncache.push_back(outpoint);",
          "new_line_content": "                // Are inputs missing because we already have the tx?",
          "content_same": false
        },
        {
          "line": 2547,
          "old_api": "std::make_pair(pindexNew->pprev, pindexNew)",
          "new_api": null,
          "old_text": "std::make_pair(pindexNew->pprev, pindexNew)",
          "new_text": null,
          "old_line_content": "            mapBlocksUnlinked.insert(std::make_pair(pindexNew->pprev, pindexNew));",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": "Invalid",
          "new_api": null,
          "old_text": "state.Invalid(false, REJECT_DUPLICATE, \"txn-already-known\")",
          "new_text": null,
          "old_line_content": "                return state.Invalid(false, REJECT_DUPLICATE, \"txn-already-known\");",
          "new_line_content": "                    // Optimistically just do efficient check of cache for outputs",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": "HaveCoinInCache",
          "new_api": null,
          "old_text": "pcoinsTip->HaveCoinInCache(txin.prevout)",
          "new_text": null,
          "old_line_content": "            if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {",
          "new_line_content": "                if (pfMissingInputs) {",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "coins_to_uncache.push_back(txin.prevout)",
          "new_text": null,
          "old_line_content": "                coins_to_uncache.push_back(txin.prevout);",
          "new_line_content": "                    *pfMissingInputs = true;",
          "content_same": false
        },
        {
          "line": 2559,
          "old_api": "size",
          "new_api": null,
          "old_text": "vinfoBlockFile.size()",
          "new_text": null,
          "old_line_content": "    if (vinfoBlockFile.size() <= nFile) {",
          "new_line_content": "    if (!fKnown) {",
          "content_same": false
        },
        {
          "line": 2560,
          "old_api": "resize",
          "new_api": null,
          "old_text": "vinfoBlockFile.resize(nFile + 1)",
          "new_text": null,
          "old_line_content": "        vinfoBlockFile.resize(nFile + 1);",
          "new_line_content": "        while (vinfoBlockFile[nFile].nSize + nAddSize >= MAX_BLOCKFILE_SIZE) {",
          "content_same": false
        },
        {
          "line": 511,
          "old_api": "HaveCoin",
          "new_api": null,
          "old_text": "view.HaveCoin(txin.prevout)",
          "new_text": null,
          "old_line_content": "            if (!view.HaveCoin(txin.prevout)) {",
          "new_line_content": "                return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()",
          "content_same": false
        },
        {
          "line": 2566,
          "old_api": "size",
          "new_api": null,
          "old_text": "vinfoBlockFile.size()",
          "new_text": null,
          "old_line_content": "            if (vinfoBlockFile.size() <= nFile) {",
          "new_line_content": "        pos.nFile = nFile;",
          "content_same": false
        },
        {
          "line": 2567,
          "old_api": "resize",
          "new_api": null,
          "old_text": "vinfoBlockFile.resize(nFile + 1)",
          "new_text": null,
          "old_line_content": "                vinfoBlockFile.resize(nFile + 1);",
          "new_line_content": "        pos.nPos = vinfoBlockFile[nFile].nSize;",
          "content_same": false
        },
        {
          "line": 520,
          "old_api": "GetBestBlock",
          "new_api": null,
          "old_text": "view.GetBestBlock()",
          "new_text": null,
          "old_line_content": "        view.GetBestBlock();",
          "new_line_content": "        // we have all inputs cached now, so switch back to dummy, so we don't need to keep lock on mempool",
          "content_same": false
        },
        {
          "line": 522,
          "old_api": "GetValueIn",
          "new_api": null,
          "old_text": "view.GetValueIn(tx)",
          "new_text": null,
          "old_line_content": "        nValueIn = view.GetValueIn(tx);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 525,
          "old_api": "SetBackend",
          "new_api": null,
          "old_text": "view.SetBackend(dummy)",
          "new_text": null,
          "old_line_content": "        view.SetBackend(dummy);",
          "new_line_content": "        // be mined yet.",
          "content_same": false
        },
        {
          "line": 2576,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "vinfoBlockFile[nLastBlockFile].ToString()",
          "new_text": null,
          "old_line_content": "            LogPrintf(\"Leaving block file %i: %s\\n\", nLastBlockFile, vinfoBlockFile[nLastBlockFile].ToString());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 532,
          "old_api": "CheckSequenceLocks",
          "new_api": null,
          "old_text": "CheckSequenceLocks(tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp)",
          "new_text": null,
          "old_line_content": "        if (!CheckSequenceLocks(tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))",
          "new_line_content": "        // Check for non-standard pay-to-script-hash in inputs",
          "content_same": false
        },
        {
          "line": 2582,
          "old_api": "AddBlock",
          "new_api": null,
          "old_text": "vinfoBlockFile[nFile].AddBlock(nHeight, nTime)",
          "new_text": null,
          "old_line_content": "    vinfoBlockFile[nFile].AddBlock(nHeight, nTime);",
          "new_line_content": "        vinfoBlockFile[nFile].nSize += nAddSize;",
          "content_same": false
        },
        {
          "line": 2584,
          "old_api": "std::max(pos.nPos + nAddSize, vinfoBlockFile[nFile].nSize)",
          "new_api": null,
          "old_text": "std::max(pos.nPos + nAddSize, vinfoBlockFile[nFile].nSize)",
          "new_text": null,
          "old_line_content": "        vinfoBlockFile[nFile].nSize = std::max(pos.nPos + nAddSize, vinfoBlockFile[nFile].nSize);",
          "new_line_content": "    if (!fKnown) {",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": "IsWitnessStandard",
          "new_api": null,
          "old_text": "IsWitnessStandard(tx, view)",
          "new_text": null,
          "old_line_content": "        if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": "GetTransactionSigOpCost",
          "new_api": null,
          "old_text": "GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS)",
          "new_text": null,
          "old_line_content": "        int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);",
          "new_line_content": "        // nModifiedFees includes any fee deltas from PrioritiseTransaction",
          "content_same": false
        },
        {
          "line": 2597,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"Pre-allocating up to position 0x%x in blk%05u.dat\\n\", nNewChunks * BLOCKFILE_CHUNK_SIZE, pos.nFile)",
          "new_text": null,
          "old_line_content": "                    LogPrintf(\"Pre-allocating up to position 0x%x in blk%05u.dat\\n\", nNewChunks * BLOCKFILE_CHUNK_SIZE, pos.nFile);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": "ApplyDelta",
          "new_api": null,
          "old_text": "pool.ApplyDelta(hash, nModifiedFees)",
          "new_text": null,
          "old_line_content": "        pool.ApplyDelta(hash, nModifiedFees);",
          "new_line_content": "        bool fSpendsCoinbase = false;",
          "content_same": false
        },
        {
          "line": 2598,
          "old_api": "AllocateFileRange",
          "new_api": null,
          "old_text": "AllocateFileRange(file, pos.nPos, nNewChunks * BLOCKFILE_CHUNK_SIZE - pos.nPos)",
          "new_text": null,
          "old_line_content": "                    AllocateFileRange(file, pos.nPos, nNewChunks * BLOCKFILE_CHUNK_SIZE - pos.nPos);",
          "new_line_content": "            else",
          "content_same": false
        },
        {
          "line": 556,
          "old_api": "AccessCoin",
          "new_api": null,
          "old_text": "view.AccessCoin(txin.prevout)",
          "new_text": null,
          "old_line_content": "            const Coin &coin = view.AccessCoin(txin.prevout);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": "IsCoinBase",
          "new_api": null,
          "old_text": "coin.IsCoinBase()",
          "new_text": null,
          "old_line_content": "            if (coin.IsCoinBase()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2607,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setDirtyFileInfo.insert(nFile)",
          "new_text": null,
          "old_line_content": "    setDirtyFileInfo.insert(nFile);",
          "new_line_content": "static bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigned int nAddSize)",
          "content_same": false
        },
        {
          "line": 563,
          "old_api": "Height",
          "new_api": null,
          "old_text": "chainActive.Height()",
          "new_text": null,
          "old_line_content": "        CTxMemPoolEntry entry(ptx, nFees, nAcceptTime, chainActive.Height(),",
          "new_line_content": "        // Check that the transaction doesn't have an excessive number of",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": "GetTxSize",
          "new_api": null,
          "old_text": "entry.GetTxSize()",
          "new_text": null,
          "old_line_content": "        unsigned int nSize = entry.GetTxSize();",
          "new_line_content": "        // itself can contain sigops MAX_STANDARD_TX_SIGOPS is less than",
          "content_same": false
        },
        {
          "line": 2615,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_LastBlockFile)",
          "new_text": null,
          "old_line_content": "    LOCK(cs_LastBlockFile);",
          "new_line_content": "    nNewSize = vinfoBlockFile[nFile].nUndoSize += nAddSize;",
          "content_same": false
        },
        {
          "line": 2620,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setDirtyFileInfo.insert(nFile)",
          "new_text": null,
          "old_line_content": "    setDirtyFileInfo.insert(nFile);",
          "new_line_content": "    if (nNewChunks > nOldChunks) {",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": "DoS",
          "new_api": null,
          "old_text": "state.DoS(0, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n                strprintf(\"%d\", nSigOpsCost))",
          "new_text": null,
          "old_line_content": "            return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,",
          "new_line_content": "        if (mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": "GetArg",
          "new_api": null,
          "old_text": "GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE)",
          "new_text": null,
          "old_line_content": "        CAmount mempoolRejectFee = pool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": "GetFee",
          "new_api": null,
          "old_text": "::minRelayTxFee.GetFee(nSize)",
          "new_text": null,
          "old_line_content": "        if (fLimitFree && nModifiedFees < ::minRelayTxFee.GetFee(nSize)) {",
          "new_line_content": "        if (nAbsurdFee && nFees > nAbsurdFee)",
          "content_same": false
        },
        {
          "line": 2630,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"Pre-allocating up to position 0x%x in rev%05u.dat\\n\", nNewChunks * UNDOFILE_CHUNK_SIZE, pos.nFile)",
          "new_text": null,
          "old_line_content": "                LogPrintf(\"Pre-allocating up to position 0x%x in rev%05u.dat\\n\", nNewChunks * UNDOFILE_CHUNK_SIZE, pos.nFile);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2631,
          "old_api": "AllocateFileRange",
          "new_api": null,
          "old_text": "AllocateFileRange(file, pos.nPos, nNewChunks * UNDOFILE_CHUNK_SIZE - pos.nPos)",
          "new_text": null,
          "old_line_content": "                AllocateFileRange(file, pos.nPos, nNewChunks * UNDOFILE_CHUNK_SIZE - pos.nPos);",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": "Invalid",
          "new_api": null,
          "old_text": "state.Invalid(false,\n                REJECT_HIGHFEE, \"absurdly-high-fee\",\n                strprintf(\"%d > %d\", nFees, nAbsurdFee))",
          "new_text": null,
          "old_line_content": "            return state.Invalid(false,",
          "new_line_content": "        // Calculate in-mempool ancestors, up to a limit.",
          "content_same": false
        },
        {
          "line": 2636,
          "old_api": "Error",
          "new_api": null,
          "old_text": "state.Error(\"out of disk space\")",
          "new_text": null,
          "old_line_content": "            return state.Error(\"out of disk space\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": "GetArg",
          "new_api": null,
          "old_text": "GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT)",
          "new_text": null,
          "old_line_content": "        size_t nLimitAncestors = GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);",
          "new_line_content": "        std::string errString;",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": "GetArg",
          "new_api": null,
          "old_text": "GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)",
          "new_text": null,
          "old_line_content": "        size_t nLimitDescendantSize = GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2645,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "block.GetHash()",
          "new_text": null,
          "old_line_content": "    if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": "CalculateMemPoolAncestors",
          "new_api": null,
          "old_text": "pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)",
          "new_text": null,
          "old_line_content": "        if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {",
          "new_line_content": "        // A transaction that spends outputs that would be replaced by it is invalid. Now",
          "content_same": false
        },
        {
          "line": 599,
          "old_api": "DoS",
          "new_api": null,
          "old_text": "state.DoS(0, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString)",
          "new_text": null,
          "old_line_content": "            return state.DoS(0, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);",
          "new_line_content": "        // that we have the set of all ancestors we can detect this",
          "content_same": false
        },
        {
          "line": 2646,
          "old_api": "DoS",
          "new_api": null,
          "old_text": "state.DoS(50, false, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\")",
          "new_text": null,
          "old_line_content": "        return state.DoS(50, false, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "ancestorIt->GetTx().GetHash()",
          "new_text": null,
          "old_line_content": "            const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();",
          "new_line_content": "                                 REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,",
          "content_same": false
        },
        {
          "line": 2660,
          "old_api": "CheckBlockHeader",
          "new_api": null,
          "old_text": "CheckBlockHeader(block, state, consensusParams, fCheckPOW)",
          "new_text": null,
          "old_line_content": "    if (!CheckBlockHeader(block, state, consensusParams, fCheckPOW))",
          "new_line_content": "    if (fCheckMerkleRoot) {",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "strprintf(\"%s spends conflicting transaction %s\",\n                                           hash.ToString(),\n                                           hashAncestor.ToString())",
          "new_text": null,
          "old_line_content": "                                 strprintf(\"%s spends conflicting transaction %s\",",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "hash.ToString()",
          "new_text": null,
          "old_line_content": "                                           hash.ToString(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 615,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "hashAncestor.ToString()",
          "new_text": null,
          "old_line_content": "                                           hashAncestor.ToString()));",
          "new_line_content": "        // Check if it's economically rational to mine this transaction rather",
          "content_same": false
        },
        {
          "line": 2666,
          "old_api": "BlockMerkleRoot",
          "new_api": null,
          "old_text": "BlockMerkleRoot(block, &mutated)",
          "new_text": null,
          "old_line_content": "        uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &mutated);",
          "new_line_content": "        // Check for merkle tree malleability (CVE-2012-2459): repeating sequences",
          "content_same": false
        },
        {
          "line": 2668,
          "old_api": "DoS",
          "new_api": null,
          "old_text": "state.DoS(100, false, REJECT_INVALID, \"bad-txnmrklroot\", true, \"hashMerkleRoot mismatch\")",
          "new_text": null,
          "old_line_content": "            return state.DoS(100, false, REJECT_INVALID, \"bad-txnmrklroot\", true, \"hashMerkleRoot mismatch\");",
          "new_line_content": "        // while still invalidating it.",
          "content_same": false
        },
        {
          "line": 2674,
          "old_api": "DoS",
          "new_api": null,
          "old_text": "state.DoS(100, false, REJECT_INVALID, \"bad-txns-duplicate\", true, \"duplicate transaction\")",
          "new_text": null,
          "old_line_content": "            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-duplicate\", true, \"duplicate transaction\");",
          "new_line_content": "    // transaction validation, as otherwise we may mark the header as invalid",
          "content_same": false
        },
        {
          "line": 629,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pool.cs)",
          "new_text": null,
          "old_line_content": "        LOCK(pool.cs);",
          "new_line_content": "            CFeeRate newFeeRate(nModifiedFees, nSize);",
          "content_same": false
        },
        {
          "line": 630,
          "old_api": "size",
          "new_api": null,
          "old_text": "setConflicts.size()",
          "new_text": null,
          "old_line_content": "        const bool fReplacementTransaction = setConflicts.size();",
          "new_line_content": "            std::set<uint256> setConflictsParents;",
          "content_same": false
        },
        {
          "line": 639,
          "old_api": "find",
          "new_api": null,
          "old_text": "pool.mapTx.find(hashConflicting)",
          "new_text": null,
          "old_line_content": "                CTxMemPool::txiter mi = pool.mapTx.find(hashConflicting);",
          "new_line_content": "                // Save these to avoid repeated lookups",
          "content_same": false
        },
        {
          "line": 2689,
          "old_api": "DoS",
          "new_api": null,
          "old_text": "state.DoS(100, false, REJECT_INVALID, \"bad-cb-missing\", false, \"first tx is not coinbase\")",
          "new_text": null,
          "old_line_content": "        return state.DoS(100, false, REJECT_INVALID, \"bad-cb-missing\", false, \"first tx is not coinbase\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2690,
          "old_api": "size",
          "new_api": null,
          "old_text": "block.vtx.size()",
          "new_text": null,
          "old_line_content": "    for (unsigned int i = 1; i < block.vtx.size(); i++)",
          "new_line_content": "    // Check transactions",
          "content_same": false
        },
        {
          "line": 2691,
          "old_api": "IsCoinBase",
          "new_api": null,
          "old_text": "block.vtx[i]->IsCoinBase()",
          "new_text": null,
          "old_line_content": "        if (block.vtx[i]->IsCoinBase())",
          "new_line_content": "    for (const auto& tx : block.vtx)",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setIterConflicting.insert(mi)",
          "new_text": null,
          "old_line_content": "                setIterConflicting.insert(mi);",
          "new_line_content": "                //",
          "content_same": false
        },
        {
          "line": 2696,
          "old_api": "CheckTransaction",
          "new_api": null,
          "old_text": "CheckTransaction(*tx, state, false)",
          "new_text": null,
          "old_line_content": "        if (!CheckTransaction(*tx, state, false))",
          "new_line_content": "    unsigned int nSigOps = 0;",
          "content_same": false
        },
        {
          "line": 2697,
          "old_api": "GetRejectReason",
          "new_api": null,
          "old_text": "state.GetRejectReason()",
          "new_text": null,
          "old_line_content": "            return state.Invalid(false, state.GetRejectCode(), state.GetRejectReason(),",
          "new_line_content": "    for (const auto& tx : block.vtx)",
          "content_same": false
        },
        {
          "line": 2698,
          "old_api": "GetDebugMessage",
          "new_api": null,
          "old_text": "state.GetDebugMessage()",
          "new_text": null,
          "old_line_content": "                                 strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2703,
          "old_api": "GetLegacySigOpCount",
          "new_api": null,
          "old_text": "GetLegacySigOpCount(*tx)",
          "new_text": null,
          "old_line_content": "        nSigOps += GetLegacySigOpCount(*tx);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2706,
          "old_api": "DoS",
          "new_api": null,
          "old_text": "state.DoS(100, false, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\")",
          "new_text": null,
          "old_line_content": "        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": "GetTxSize",
          "new_api": null,
          "old_text": "mi->GetTxSize()",
          "new_text": null,
          "old_line_content": "                CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());",
          "new_line_content": "                            REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                                  hash.ToString(),\n                                  newFeeRate.ToString(),\n                                  oldFeeRate.ToString())",
          "new_text": null,
          "old_line_content": "                            strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "hash.ToString()",
          "new_text": null,
          "old_line_content": "                                  hash.ToString(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2716,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "    if (*pindexPrev->phashBlock == chainparams.GetConsensus().hashGenesisBlock)",
          "new_line_content": "    // Don't accept any forks from the main chain prior to last checkpoint.",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "oldFeeRate.ToString()",
          "new_text": null,
          "old_line_content": "                                  oldFeeRate.ToString()));",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 673,
          "old_api": "GetTx",
          "new_api": null,
          "old_text": "mi->GetTx()",
          "new_text": null,
          "old_line_content": "                for (const CTxIn &txin : mi->GetTx().vin)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setConflictsParents.insert(txin.prevout.hash)",
          "new_text": null,
          "old_line_content": "                    setConflictsParents.insert(txin.prevout.hash);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2723,
          "old_api": "Checkpoints",
          "new_api": null,
          "old_text": "chainparams.Checkpoints()",
          "new_text": null,
          "old_line_content": "    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(chainparams.Checkpoints());",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 2725,
          "old_api": "error",
          "new_api": null,
          "old_text": "error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight)",
          "new_text": null,
          "old_line_content": "        return state.DoS(100, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": "GetCountWithDescendants",
          "new_api": null,
          "old_text": "mi->GetCountWithDescendants()",
          "new_text": null,
          "old_line_content": "                nConflictingCount += mi->GetCountWithDescendants();",
          "new_line_content": "            // work.",
          "content_same": false
        },
        {
          "line": 2732,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "// Compute at which vout of the block's coinbase transaction the witness",
          "content_same": false
        },
        {
          "line": 2733,
          "old_api": "VersionBitsState",
          "new_api": null,
          "old_text": "VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_SEGWIT, versionbitscache)",
          "new_text": null,
          "old_line_content": "    return (VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == THRESHOLD_ACTIVE);",
          "new_line_content": "// commitment occurs, or -1 if not found.",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": "GetTxSize",
          "new_api": null,
          "old_text": "it->GetTxSize()",
          "new_text": null,
          "old_line_content": "                    nConflictingSize += it->GetTxSize();",
          "new_line_content": "                        REJECT_NONSTANDARD, \"too many potential replacements\", false,",
          "content_same": false
        },
        {
          "line": 2741,
          "old_api": "empty",
          "new_api": null,
          "old_text": "block.vtx.empty()",
          "new_text": null,
          "old_line_content": "    if (!block.vtx.empty()) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": "DoS",
          "new_api": null,
          "old_text": "state.DoS(0, false,\n                        REJECT_NONSTANDARD, \"too many potential replacements\", false,\n                        strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                            hash.ToString(),\n                            nConflictingCount,\n                            maxDescendantsToVisit))",
          "new_text": null,
          "old_line_content": "                return state.DoS(0, false,",
          "new_line_content": "                            nConflictingCount,",
          "content_same": false
        },
        {
          "line": 2742,
          "old_api": "size",
          "new_api": null,
          "old_text": "block.vtx[0]->vout.size()",
          "new_text": null,
          "old_line_content": "        for (size_t o = 0; o < block.vtx[0]->vout.size(); o++) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 696,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                            hash.ToString(),\n                            nConflictingCount,\n                            maxDescendantsToVisit)",
          "new_text": null,
          "old_line_content": "                        strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 697,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "hash.ToString()",
          "new_text": null,
          "old_line_content": "                            hash.ToString(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2743,
          "old_api": "size",
          "new_api": null,
          "old_text": "block.vtx[0]->vout[o].scriptPubKey.size()",
          "new_text": null,
          "old_line_content": "            if (block.vtx[0]->vout[o].scriptPubKey.size() >= 38 && block.vtx[0]->vout[o].scriptPubKey[0] == OP_RETURN && block.vtx[0]->vout[o].scriptPubKey[1] == 0x24 && block.vtx[0]->vout[o].scriptPubKey[2] == 0xaa && block.vtx[0]->vout[o].scriptPubKey[3] == 0x21 && block.vtx[0]->vout[o].scriptPubKey[4] == 0xa9 && block.vtx[0]->vout[o].scriptPubKey[5] == 0xed) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": "size",
          "new_api": null,
          "old_text": "tx.vin.size()",
          "new_text": null,
          "old_line_content": "            for (unsigned int j = 0; j < tx.vin.size(); j++)",
          "new_line_content": "                // the ancestor feerates and make the decision based on that,",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": "count",
          "new_api": null,
          "old_text": "setConflictsParents.count(tx.vin[j].prevout.hash)",
          "new_text": null,
          "old_line_content": "                if (!setConflictsParents.count(tx.vin[j].prevout.hash))",
          "new_line_content": "                    // tx that's in the mempool.",
          "content_same": false
        },
        {
          "line": 2757,
          "old_api": "resize",
          "new_api": null,
          "old_text": "tx.vin[0].scriptWitness.stack.resize(1)",
          "new_text": null,
          "old_line_content": "        tx.vin[0].scriptWitness.stack.resize(1);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2759,
          "old_api": "std::move(tx)",
          "new_api": null,
          "old_text": "std::move(tx)",
          "new_text": null,
          "old_line_content": "        block.vtx[0] = MakeTransactionRef(std::move(tx));",
          "new_line_content": "std::vector<unsigned char> GenerateCoinbaseCommitment(CBlock& block, const CBlockIndex* pindexPrev, const Consensus::Params& consensusParams)",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": "DoS",
          "new_api": null,
          "old_text": "state.DoS(0, false,\n                                         REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\", false,\n                                         strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n                                                  hash.ToString(), j))",
          "new_text": null,
          "old_line_content": "                        return state.DoS(0, false,",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n                                                  hash.ToString(), j)",
          "new_text": null,
          "old_line_content": "                                         strprintf(\"replacement %s adds unconfirmed input, idx %d\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "hash.ToString()",
          "new_text": null,
          "old_line_content": "                                                  hash.ToString(), j));",
          "new_line_content": "            // The replacement must pay greater fees than the transactions it",
          "content_same": false
        },
        {
          "line": 2771,
          "old_api": "begin",
          "new_api": null,
          "old_text": "witnessroot.begin()",
          "new_text": null,
          "old_line_content": "            CHash256().Write(witnessroot.begin(), 32).Write(&ret[0], 32).Finalize(witnessroot.begin());",
          "new_line_content": "            out.scriptPubKey[0] = OP_RETURN;",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": "DoS",
          "new_api": null,
          "old_text": "state.DoS(0, false,\n                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n                                 strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                                          hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)))",
          "new_text": null,
          "old_line_content": "                return state.DoS(0, false,",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2774,
          "old_api": "resize",
          "new_api": null,
          "old_text": "out.scriptPubKey.resize(38)",
          "new_text": null,
          "old_line_content": "            out.scriptPubKey.resize(38);",
          "new_line_content": "            out.scriptPubKey[3] = 0x21;",
          "content_same": false
        },
        {
          "line": 728,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                                          hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees))",
          "new_text": null,
          "old_line_content": "                                 strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",",
          "new_line_content": "            // Finally in addition to paying more fees than the conflicts the",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": "FormatMoney",
          "new_api": null,
          "old_text": "FormatMoney(nConflictingFees)",
          "new_text": null,
          "old_line_content": "                                          hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));",
          "new_line_content": "            // new transaction must pay for its own bandwidth.",
          "content_same": false
        },
        {
          "line": 2782,
          "old_api": "end",
          "new_api": null,
          "old_text": "out.scriptPubKey.end()",
          "new_text": null,
          "old_line_content": "            commitment = std::vector<unsigned char>(out.scriptPubKey.begin(), out.scriptPubKey.end());",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2785,
          "old_api": "std::move(tx)",
          "new_api": null,
          "old_text": "std::move(tx)",
          "new_text": null,
          "old_line_content": "            block.vtx[0] = MakeTransactionRef(std::move(tx));",
          "new_line_content": "    return commitment;",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                              hash.ToString(),\n                              FormatMoney(nDeltaFees),\n                              FormatMoney(::incrementalRelayFee.GetFee(nSize)))",
          "new_text": null,
          "old_line_content": "                        strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "hash.ToString()",
          "new_text": null,
          "old_line_content": "                              hash.ToString(),",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": "FormatMoney",
          "new_api": null,
          "old_text": "FormatMoney(nDeltaFees)",
          "new_text": null,
          "old_line_content": "                              FormatMoney(nDeltaFees),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": "GetFee",
          "new_api": null,
          "old_text": "::incrementalRelayFee.GetFee(nSize)",
          "new_text": null,
          "old_line_content": "                              FormatMoney(::incrementalRelayFee.GetFee(nSize))));",
          "new_line_content": "        unsigned int scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;",
          "content_same": false
        },
        {
          "line": 2788,
          "old_api": "UpdateUncommittedBlockStructures",
          "new_api": null,
          "old_text": "UpdateUncommittedBlockStructures(block, pindexPrev, consensusParams)",
          "new_text": null,
          "old_line_content": "    UpdateUncommittedBlockStructures(block, pindexPrev, consensusParams);",
          "new_line_content": "/** Context-dependent validity checks.",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": "RequireStandard",
          "new_api": null,
          "old_text": "chainparams.RequireStandard()",
          "new_text": null,
          "old_line_content": "        if (!chainparams.RequireStandard()) {",
          "new_line_content": "        // Check against previous transactions",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": "GetArg",
          "new_api": null,
          "old_text": "GetArg(\"-promiscuousmempoolflags\", scriptVerifyFlags)",
          "new_text": null,
          "old_line_content": "            scriptVerifyFlags = GetArg(\"-promiscuousmempoolflags\", scriptVerifyFlags);",
          "new_line_content": "        // This is done last to help prevent CPU exhaustion denial-of-service attacks.",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": "CheckInputs",
          "new_api": null,
          "old_text": "CheckInputs(tx, state, view, true, scriptVerifyFlags, true, txdata)",
          "new_text": null,
          "old_line_content": "        if (!CheckInputs(tx, state, view, true, scriptVerifyFlags, true, txdata)) {",
          "new_line_content": "            CValidationState stateDummy; // Want reported failures to be from first CheckInputs",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": "CheckInputs",
          "new_api": null,
          "old_text": "CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, txdata)",
          "new_text": null,
          "old_line_content": "            if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, txdata) &&",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": "CheckInputs",
          "new_api": null,
          "old_text": "CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, txdata)",
          "new_text": null,
          "old_line_content": "                !CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, txdata)) {",
          "new_line_content": "            return false; // state filled in by CheckInputs",
          "content_same": false
        },
        {
          "line": 2808,
          "old_api": "GetBlockTime",
          "new_api": null,
          "old_text": "block.GetBlockTime()",
          "new_text": null,
          "old_line_content": "    if (block.GetBlockTime() > nAdjustedTime + MAX_FUTURE_BLOCK_TIME)",
          "new_line_content": "    // check for version 2, 3 and 4 upgrades",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": "SetCorruptionPossible",
          "new_api": null,
          "old_text": "state.SetCorruptionPossible()",
          "new_text": null,
          "old_line_content": "                state.SetCorruptionPossible();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2809,
          "old_api": "Invalid",
          "new_api": null,
          "old_text": "state.Invalid(false, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\")",
          "new_text": null,
          "old_line_content": "        return state.Invalid(false, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");",
          "new_line_content": "    if((block.nVersion < 2 && nHeight >= consensusParams.BIP34Height) ||",
          "content_same": false
        },
        {
          "line": 2816,
          "old_api": "strprintf",
          "new_api": null,
          "old_text": "strprintf(\"bad-version(0x%08x)\", block.nVersion)",
          "new_text": null,
          "old_line_content": "            return state.Invalid(false, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2817,
          "old_api": "strprintf",
          "new_api": null,
          "old_text": "strprintf(\"rejected nVersion=0x%08x block\", block.nVersion)",
          "new_text": null,
          "old_line_content": "                                 strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": "CheckInputs",
          "new_api": null,
          "old_text": "CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true, txdata)",
          "new_text": null,
          "old_line_content": "        if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true, txdata))",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 778,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "error(\"%s: BUG! PLEASE REPORT THIS! ConnectInputs failed against MANDATORY but not STANDARD flags %s, %s\",\n                __func__, hash.ToString(), FormatStateMessage(state))",
          "new_text": null,
          "old_line_content": "            return error(\"%s: BUG! PLEASE REPORT THIS! ConnectInputs failed against MANDATORY but not STANDARD flags %s, %s\",",
          "new_line_content": "        // Remove conflicting transactions from the mempool",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": "FormatStateMessage",
          "new_api": null,
          "old_text": "FormatStateMessage(state)",
          "new_text": null,
          "old_line_content": "                __func__, hash.ToString(), FormatStateMessage(state));",
          "new_line_content": "        for (const CTxMemPool::txiter it : allConflicting)",
          "content_same": false
        },
        {
          "line": 2828,
          "old_api": "VersionBitsState",
          "new_api": null,
          "old_text": "VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_CSV, versionbitscache)",
          "new_text": null,
          "old_line_content": "    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {",
          "new_line_content": "    int64_t nLockTimeCutoff = (nLockTimeFlags & LOCKTIME_MEDIAN_TIME_PAST)",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "LogPrint(BCLog::MEMPOOL, \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",\n                    it->GetTx().GetHash().ToString(),\n                    hash.ToString(),\n                    FormatMoney(nModifiedFees - nConflictingFees),\n                    (int)nSize - (int)nConflictingSize)",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::MEMPOOL, \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",",
          "new_line_content": "                    (int)nSize - (int)nConflictingSize);",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "it->GetTx().GetHash().ToString()",
          "new_text": null,
          "old_line_content": "                    it->GetTx().GetHash().ToString(),",
          "new_line_content": "            if (plTxnReplaced)",
          "content_same": false
        },
        {
          "line": 2833,
          "old_api": "GetMedianTimePast",
          "new_api": null,
          "old_text": "pindexPrev->GetMedianTimePast()",
          "new_text": null,
          "old_line_content": "                              ? pindexPrev->GetMedianTimePast()",
          "new_line_content": "    for (const auto& tx : block.vtx) {",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": "FormatMoney",
          "new_api": null,
          "old_text": "FormatMoney(nModifiedFees - nConflictingFees)",
          "new_text": null,
          "old_line_content": "                    FormatMoney(nModifiedFees - nConflictingFees),",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2838,
          "old_api": "IsFinalTx",
          "new_api": null,
          "old_text": "IsFinalTx(*tx, nHeight, nLockTimeCutoff)",
          "new_text": null,
          "old_line_content": "        if (!IsFinalTx(*tx, nHeight, nLockTimeCutoff)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": "GetSharedTx",
          "new_api": null,
          "old_text": "it->GetSharedTx()",
          "new_text": null,
          "old_line_content": "                plTxnReplaced->push_back(it->GetSharedTx());",
          "new_line_content": "        // This transaction should only count for fee estimation if it isn't a",
          "content_same": false
        },
        {
          "line": 2839,
          "old_api": "DoS",
          "new_api": null,
          "old_text": "state.DoS(10, false, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\")",
          "new_text": null,
          "old_line_content": "            return state.DoS(10, false, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\");",
          "new_line_content": "    // Enforce rule that the coinbase starts with serialized block height",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": "RemoveStaged",
          "new_api": null,
          "old_text": "pool.RemoveStaged(allConflicting, false, MemPoolRemovalReason::REPLACED)",
          "new_text": null,
          "old_line_content": "        pool.RemoveStaged(allConflicting, false, MemPoolRemovalReason::REPLACED);",
          "new_line_content": "        // node is not behind, and the transaction is not dependent on any other",
          "content_same": false
        },
        {
          "line": 2846,
          "old_api": "CScript",
          "new_api": null,
          "old_text": "CScript()",
          "new_text": null,
          "old_line_content": "        CScript expect = CScript() << nHeight;",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 799,
          "old_api": "HasNoInputsOf",
          "new_api": null,
          "old_text": "pool.HasNoInputsOf(tx)",
          "new_text": null,
          "old_line_content": "        bool validForFeeEstimation = !fReplacementTransaction && IsCurrentForFeeEstimation() && pool.HasNoInputsOf(tx);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2847,
          "old_api": "size",
          "new_api": null,
          "old_text": "expect.size()",
          "new_text": null,
          "old_line_content": "        if (block.vtx[0]->vin[0].scriptSig.size() < expect.size() ||",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2848,
          "old_api": "begin",
          "new_api": null,
          "old_text": "block.vtx[0]->vin[0].scriptSig.begin()",
          "new_text": null,
          "old_line_content": "            !std::equal(expect.begin(), expect.end(), block.vtx[0]->vin[0].scriptSig.begin())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2849,
          "old_api": "DoS",
          "new_api": null,
          "old_text": "state.DoS(100, false, REJECT_INVALID, \"bad-cb-height\", false, \"block height mismatch in coinbase\")",
          "new_text": null,
          "old_line_content": "            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-height\", false, \"block height mismatch in coinbase\");",
          "new_line_content": "    // Validation for witness commitments.",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": "GetArg",
          "new_api": null,
          "old_text": "GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY)",
          "new_text": null,
          "old_line_content": "            LimitMempoolSize(pool, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": "exists",
          "new_api": null,
          "old_text": "pool.exists(hash)",
          "new_text": null,
          "old_line_content": "            if (!pool.exists(hash))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": "TransactionAddedToMempool",
          "new_api": null,
          "old_text": "GetMainSignals().TransactionAddedToMempool(ptx)",
          "new_text": null,
          "old_line_content": "    GetMainSignals().TransactionAddedToMempool(ptx);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2863,
          "old_api": "GetWitnessCommitmentIndex",
          "new_api": null,
          "old_text": "GetWitnessCommitmentIndex(block)",
          "new_text": null,
          "old_line_content": "        int commitpos = GetWitnessCommitmentIndex(block);",
          "new_line_content": "            // The malleation check is ignored; as the transaction tree itself",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": "AcceptToMemoryPoolWorker",
          "new_api": null,
          "old_text": "AcceptToMemoryPoolWorker(chainparams, pool, state, tx, fLimitFree, pfMissingInputs, nAcceptTime, plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee, coins_to_uncache)",
          "new_text": null,
          "old_line_content": "    bool res = AcceptToMemoryPoolWorker(chainparams, pool, state, tx, fLimitFree, pfMissingInputs, nAcceptTime, plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee, coins_to_uncache);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2873,
          "old_api": "begin",
          "new_api": null,
          "old_text": "hashWitness.begin()",
          "new_text": null,
          "old_line_content": "            CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0]->vin[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());",
          "new_line_content": "            fHaveWitness = true;",
          "content_same": false
        },
        {
          "line": 2874,
          "old_api": "begin",
          "new_api": null,
          "old_text": "hashWitness.begin()",
          "new_text": null,
          "old_line_content": "            if (memcmp(hashWitness.begin(), &block.vtx[0]->vout[commitpos].scriptPubKey[6], 32)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2875,
          "old_api": "strprintf",
          "new_api": null,
          "old_text": "strprintf(\"%s : witness merkle commitment mismatch\", __func__)",
          "new_text": null,
          "old_line_content": "                return state.DoS(100, false, REJECT_INVALID, \"bad-witness-merkle-match\", true, strprintf(\"%s : witness merkle commitment mismatch\", __func__));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": "FlushStateToDisk",
          "new_api": null,
          "old_text": "FlushStateToDisk(chainparams, stateDummy, FLUSH_STATE_PERIODIC)",
          "new_text": null,
          "old_line_content": "    FlushStateToDisk(chainparams, stateDummy, FLUSH_STATE_PERIODIC);",
          "new_line_content": "bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx, bool fLimitFree,",
          "content_same": false
        },
        {
          "line": 2884,
          "old_api": "HasWitness",
          "new_api": null,
          "old_text": "tx->HasWitness()",
          "new_text": null,
          "old_line_content": "            if (tx->HasWitness()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2885,
          "old_api": "strprintf",
          "new_api": null,
          "old_text": "strprintf(\"%s : unexpected witness data found\", __func__)",
          "new_text": null,
          "old_line_content": "                return state.DoS(100, false, REJECT_INVALID, \"unexpected-witness\", true, strprintf(\"%s : unexpected witness data found\", __func__));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": "Params",
          "new_api": null,
          "old_text": "Params()",
          "new_text": null,
          "old_line_content": "    const CChainParams& chainparams = Params();",
          "new_line_content": "/** Return transaction in txOut, and if it was found inside a block, its hash is placed in hashBlock */",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": "GetTime",
          "new_api": null,
          "old_text": "GetTime()",
          "new_text": null,
          "old_line_content": "    return AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, fLimitFree, pfMissingInputs, GetTime(), plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee);",
          "new_line_content": "bool GetTransaction(const uint256 &hash, CTransactionRef &txOut, const Consensus::Params& consensusParams, uint256 &hashBlock, bool fAllowSlow)",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2896,
          "old_api": "GetBlockWeight",
          "new_api": null,
          "old_text": "GetBlockWeight(block)",
          "new_text": null,
          "old_line_content": "    if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": "get",
          "new_api": null,
          "old_text": "mempool.get(hash)",
          "new_text": null,
          "old_line_content": "    CTransactionRef ptx = mempool.get(hash);",
          "new_line_content": "        return true;",
          "content_same": false
        },
        {
          "line": 2897,
          "old_api": "strprintf",
          "new_api": null,
          "old_text": "strprintf(\"%s : weight limit failed\", __func__)",
          "new_text": null,
          "old_line_content": "        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-weight\", false, strprintf(\"%s : weight limit failed\", __func__));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2905,
          "old_api": "AssertLockHeld",
          "new_api": null,
          "old_text": "AssertLockHeld(cs_main)",
          "new_text": null,
          "old_line_content": "    AssertLockHeld(cs_main);",
          "new_line_content": "    CBlockIndex *pindex = NULL;",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": "ReadTxIndex",
          "new_api": null,
          "old_text": "pblocktree->ReadTxIndex(hash, postx)",
          "new_text": null,
          "old_line_content": "        if (pblocktree->ReadTxIndex(hash, postx)) {",
          "new_line_content": "            CBlockHeader header;",
          "content_same": false
        },
        {
          "line": 2907,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "block.GetHash()",
          "new_text": null,
          "old_line_content": "    uint256 hash = block.GetHash();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": "IsNull",
          "new_api": null,
          "old_text": "file.IsNull()",
          "new_text": null,
          "old_line_content": "            if (file.IsNull())",
          "new_line_content": "                file >> header;",
          "content_same": false
        },
        {
          "line": 2910,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "    if (hash != chainparams.GetConsensus().hashGenesisBlock) {",
          "new_line_content": "            pindex = miSelf->second;",
          "content_same": false
        },
        {
          "line": 2912,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapBlockIndex.end()",
          "new_text": null,
          "old_line_content": "        if (miSelf != mapBlockIndex.end()) {",
          "new_line_content": "                *ppindex = pindex;",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": "Get",
          "new_api": null,
          "old_text": "file.Get()",
          "new_text": null,
          "old_line_content": "                fseek(file.Get(), postx.nTxOffset, SEEK_CUR);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "header.GetHash()",
          "new_text": null,
          "old_line_content": "            hashBlock = header.GetHash();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "txOut->GetHash()",
          "new_text": null,
          "old_line_content": "            if (txOut->GetHash() != hash)",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": "error",
          "new_api": null,
          "old_text": "error(\"%s: txid mismatch\", __func__)",
          "new_text": null,
          "old_line_content": "                return error(\"%s: txid mismatch\", __func__);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2922,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "        if (!CheckBlockHeader(block, state, chainparams.GetConsensus()))",
          "new_line_content": "        CBlockIndex* pindexPrev = NULL;",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": "AccessByTxid",
          "new_api": null,
          "old_text": "AccessByTxid(*pcoinsTip, hash)",
          "new_text": null,
          "old_line_content": "        const Coin& coin = AccessByTxid(*pcoinsTip, hash);",
          "new_line_content": "    if (pindexSlow) {",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": "IsSpent",
          "new_api": null,
          "old_text": "coin.IsSpent()",
          "new_text": null,
          "old_line_content": "        if (!coin.IsSpent()) pindexSlow = chainActive[coin.nHeight];",
          "new_line_content": "        CBlock block;",
          "content_same": false
        },
        {
          "line": 2927,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapBlockIndex.find(block.hashPrevBlock)",
          "new_text": null,
          "old_line_content": "        BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);",
          "new_line_content": "        if (pindexPrev->nStatus & BLOCK_FAILED_MASK)",
          "content_same": false
        },
        {
          "line": 2929,
          "old_api": "error",
          "new_api": null,
          "old_text": "error(\"%s: prev block not found\", __func__)",
          "new_text": null,
          "old_line_content": "            return state.DoS(10, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "tx->GetHash()",
          "new_text": null,
          "old_line_content": "                if (tx->GetHash() == hash) {",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindexSlow->GetBlockHash()",
          "new_text": null,
          "old_line_content": "                    hashBlock = pindexSlow->GetBlockHash();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2936,
          "old_api": "GetRejectReason",
          "new_api": null,
          "old_text": "state.GetRejectReason().c_str()",
          "new_text": null,
          "old_line_content": "            return error(\"%s: CheckIndexAgainstCheckpoint(): %s\", __func__, state.GetRejectReason().c_str());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2939,
          "old_api": "FormatStateMessage",
          "new_api": null,
          "old_text": "FormatStateMessage(state)",
          "new_text": null,
          "old_line_content": "            return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2942,
          "old_api": "AddToBlockIndex",
          "new_api": null,
          "old_text": "AddToBlockIndex(block)",
          "new_text": null,
          "old_line_content": "        pindex = AddToBlockIndex(block);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2947,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "    CheckBlockIndex(chainparams.GetConsensus());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2956,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "        LOCK(cs_main);",
          "new_line_content": "                return false;",
          "content_same": false
        },
        {
          "line": 2959,
          "old_api": "AcceptBlockHeader",
          "new_api": null,
          "old_text": "AcceptBlockHeader(header, state, chainparams, &pindex)",
          "new_text": null,
          "old_line_content": "            if (!AcceptBlockHeader(header, state, chainparams, &pindex)) {",
          "new_line_content": "                *ppindex = pindex;",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": "FLATDATA",
          "new_api": null,
          "old_text": "FLATDATA(messageStart)",
          "new_text": null,
          "old_line_content": "    fileout << FLATDATA(messageStart) << nSize;",
          "new_line_content": "    if (fileOutPos < 0)",
          "content_same": false
        },
        {
          "line": 2967,
          "old_api": "NotifyHeaderTip",
          "new_api": null,
          "old_text": "NotifyHeaderTip()",
          "new_text": null,
          "old_line_content": "    NotifyHeaderTip();",
          "new_line_content": "/** Store block on disk. If dbp is non-NULL, the file is known to already reside on disk */",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": "Get",
          "new_api": null,
          "old_text": "fileout.Get()",
          "new_text": null,
          "old_line_content": "    long fileOutPos = ftell(fileout.Get());",
          "new_line_content": "    fileout << block;",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": "error",
          "new_api": null,
          "old_text": "error(\"WriteBlockToDisk: ftell failed\")",
          "new_text": null,
          "old_line_content": "        return error(\"WriteBlockToDisk: ftell failed\");",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 2977,
          "old_api": "AssertLockHeld",
          "new_api": null,
          "old_text": "AssertLockHeld(cs_main)",
          "new_text": null,
          "old_line_content": "    AssertLockHeld(cs_main);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2982,
          "old_api": "AcceptBlockHeader",
          "new_api": null,
          "old_text": "AcceptBlockHeader(block, state, chainparams, &pindex)",
          "new_text": null,
          "old_line_content": "    if (!AcceptBlockHeader(block, state, chainparams, &pindex))",
          "new_line_content": "    // process an unrequested block if it's new and has enough work to",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": "IsNull",
          "new_api": null,
          "old_text": "filein.IsNull()",
          "new_text": null,
          "old_line_content": "    if (filein.IsNull())",
          "new_line_content": "    try {",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "pos.ToString()",
          "new_text": null,
          "old_line_content": "        return error(\"ReadBlockFromDisk: OpenBlockFile failed for %s\", pos.ToString());",
          "new_line_content": "        filein >> block;",
          "content_same": false
        },
        {
          "line": 2989,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "    bool fHasMoreWork = (chainActive.Tip() ? pindex->nChainWork > chainActive.Tip()->nChainWork : true);",
          "new_line_content": "    // regardless of whether pruning is enabled; it should generally be safe to",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "block.GetHash()",
          "new_text": null,
          "old_line_content": "    if (!CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 948,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "pos.ToString()",
          "new_text": null,
          "old_line_content": "        return error(\"ReadBlockFromDisk: Errors in block header at %s\", pos.ToString());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2995,
          "old_api": "Height",
          "new_api": null,
          "old_text": "chainActive.Height()",
          "new_text": null,
          "old_line_content": "    bool fTooFarAhead = (pindex->nHeight > int(chainActive.Height() + MIN_BLOCKS_TO_KEEP));",
          "new_line_content": "    // block is in a chain leading to a candidate for best tip, despite not",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindex->GetBlockHash()",
          "new_text": null,
          "old_line_content": "    if (block.GetHash() != pindex->GetBlockHash())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "error(\"ReadBlockFromDisk(CBlock&, CBlockIndex*): GetHash() doesn't match index for %s at %s\",\n                pindex->ToString(), pindex->GetBlockPos().ToString())",
          "new_text": null,
          "old_line_content": "        return error(\"ReadBlockFromDisk(CBlock&, CBlockIndex*): GetHash() doesn't match index for %s at %s\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "pindex->GetBlockPos().ToString()",
          "new_text": null,
          "old_line_content": "                pindex->ToString(), pindex->GetBlockPos().ToString());",
          "new_line_content": "CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams)",
          "content_same": false
        },
        {
          "line": 3013,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "        !ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindex->pprev)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3016,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setDirtyBlockIndex.insert(pindex)",
          "new_text": null,
          "old_line_content": "            setDirtyBlockIndex.insert(pindex);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3018,
          "old_api": "FormatStateMessage",
          "new_api": null,
          "old_text": "FormatStateMessage(state)",
          "new_text": null,
          "old_line_content": "        return error(\"%s: %s\", __func__, FormatStateMessage(state));",
          "new_line_content": "    // (but if it does not build on our best tip, let the SendMessages loop relay it)",
          "content_same": false
        },
        {
          "line": 3023,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "    if (!IsInitialBlockDownload() && chainActive.Tip() == pindex->pprev)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3024,
          "old_api": "NewPoWValidBlock",
          "new_api": null,
          "old_text": "GetMainSignals().NewPoWValidBlock(pindex, pblock)",
          "new_text": null,
          "old_line_content": "        GetMainSignals().NewPoWValidBlock(pindex, pblock);",
          "new_line_content": "    // Write block to history file",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "Params",
          "new_api": null,
          "old_text": "Params()",
          "new_text": null,
          "old_line_content": "    const CChainParams& chainParams = Params();",
          "new_line_content": "    // Optimization: pre-test latch before taking the lock.",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "        return true;",
          "content_same": false
        },
        {
          "line": 3037,
          "old_api": "MessageStart",
          "new_api": null,
          "old_text": "chainparams.MessageStart()",
          "new_text": null,
          "old_line_content": "            if (!WriteBlockToDisk(block, blockPos, chainparams.MessageStart()))",
          "new_line_content": "    } catch (const std::runtime_error& e) {",
          "content_same": false
        },
        {
          "line": 3039,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "        if (!ReceivedBlockTransactions(block, state, pindex, blockPos, chainparams.GetConsensus()))",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3040,
          "old_api": "error",
          "new_api": null,
          "old_text": "error(\"AcceptBlock(): ReceivedBlockTransactions failed\")",
          "new_text": null,
          "old_line_content": "            return error(\"AcceptBlock(): ReceivedBlockTransactions failed\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": "GetTime",
          "new_api": null,
          "old_text": "GetTime()",
          "new_text": null,
          "old_line_content": "    if (chainActive.Tip()->GetBlockTime() < (GetTime() - nMaxTipAge))",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"Leaving InitialBlockDownload (latching to false)\\n\")",
          "new_text": null,
          "old_line_content": "    LogPrintf(\"Leaving InitialBlockDownload (latching to false)\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": "store",
          "new_api": null,
          "old_text": "latchToFalse.store(true, std::memory_order_relaxed)",
          "new_text": null,
          "old_line_content": "    latchToFalse.store(true, std::memory_order_relaxed);",
          "new_line_content": "CBlockIndex *pindexBestForkTip = NULL, *pindexBestForkBase = NULL;",
          "content_same": false
        },
        {
          "line": 3046,
          "old_api": "FlushStateToDisk",
          "new_api": null,
          "old_text": "FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE)",
          "new_text": null,
          "old_line_content": "        FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE); // we just allocated more disk space for block files",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": "NotifyAlertChanged",
          "new_api": null,
          "old_text": "uiInterface.NotifyAlertChanged()",
          "new_text": null,
          "old_line_content": "    uiInterface.NotifyAlertChanged();",
          "new_line_content": "    // Alert text should be plain ascii coming from a trusted source, but to",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": "GetArg",
          "new_api": null,
          "old_text": "GetArg(\"-alertnotify\", \"\")",
          "new_text": null,
          "old_line_content": "    std::string strCmd = GetArg(\"-alertnotify\", \"\");",
          "new_line_content": "    // be safe we first strip anything not in safeChars, then add single quotes around",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": "empty",
          "new_api": null,
          "old_text": "strCmd.empty()",
          "new_text": null,
          "old_line_content": "    if (strCmd.empty()) return;",
          "new_line_content": "    // the whole string before passing it to the shell:",
          "content_same": false
        },
        {
          "line": 3059,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "        bool ret = CheckBlock(*pblock, state, chainparams.GetConsensus());",
          "new_line_content": "        if (ret) {",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": "SanitizeString",
          "new_api": null,
          "old_text": "SanitizeString(strMessage)",
          "new_text": null,
          "old_line_content": "    std::string safeStatus = SanitizeString(strMessage);",
          "new_line_content": "    boost::thread t(runCommand, strCmd); // thread runs free",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": "boost::replace_all(strCmd, \"%s\", safeStatus)",
          "new_api": null,
          "old_text": "boost::replace_all(strCmd, \"%s\", safeStatus)",
          "new_text": null,
          "old_line_content": "    boost::replace_all(strCmd, \"%s\", safeStatus);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3067,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "        CheckBlockIndex(chainparams.GetConsensus());",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3069,
          "old_api": "BlockChecked",
          "new_api": null,
          "old_text": "GetMainSignals().BlockChecked(*pblock, state)",
          "new_text": null,
          "old_line_content": "            GetMainSignals().BlockChecked(*pblock, state);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": "AssertLockHeld",
          "new_api": null,
          "old_text": "AssertLockHeld(cs_main)",
          "new_text": null,
          "old_line_content": "    AssertLockHeld(cs_main);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": "IsInitialBlockDownload",
          "new_api": null,
          "old_text": "IsInitialBlockDownload()",
          "new_text": null,
          "old_line_content": "    if (IsInitialBlockDownload())",
          "new_line_content": "    // of our head, drop it",
          "content_same": false
        },
        {
          "line": 3077,
          "old_api": "ActivateBestChain",
          "new_api": null,
          "old_text": "ActivateBestChain(state, chainparams, pblock)",
          "new_text": null,
          "old_line_content": "    if (!ActivateBestChain(state, chainparams, pblock))",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3078,
          "old_api": "error",
          "new_api": null,
          "old_text": "error(\"%s: ActivateBestChain failed\", __func__)",
          "new_text": null,
          "old_line_content": "        return error(\"%s: ActivateBestChain failed\", __func__);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": "Height",
          "new_api": null,
          "old_text": "chainActive.Height()",
          "new_text": null,
          "old_line_content": "    if (pindexBestForkTip && chainActive.Height() - pindexBestForkTip->nHeight >= 72)",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3085,
          "old_api": "AssertLockHeld",
          "new_api": null,
          "old_text": "AssertLockHeld(cs_main)",
          "new_text": null,
          "old_line_content": "    AssertLockHeld(cs_main);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": "std::string(\"'Warning: Large-work fork detected, forking after block \")",
          "new_api": null,
          "old_text": "std::string(\"'Warning: Large-work fork detected, forking after block \")",
          "new_text": null,
          "old_line_content": "            std::string warning = std::string(\"'Warning: Large-work fork detected, forking after block \") +",
          "new_line_content": "        if (pindexBestForkTip && pindexBestForkBase)",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": "std::string(\"'\")",
          "new_api": null,
          "old_text": "std::string(\"'\")",
          "new_text": null,
          "old_line_content": "                pindexBestForkBase->phashBlock->ToString() + std::string(\"'\");",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 3086,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "    assert(pindexPrev && pindexPrev == chainActive.Tip());",
          "new_line_content": "    CCoinsViewCache viewNew(pcoinsTip);",
          "content_same": false
        },
        {
          "line": 3087,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "block.GetHash()",
          "new_text": null,
          "old_line_content": "    if (fCheckpointsEnabled && !CheckIndexAgainstCheckpoint(pindexPrev, state, chainparams, block.GetHash()))",
          "new_line_content": "    CBlockIndex indexDummy(block);",
          "content_same": false
        },
        {
          "line": 3088,
          "old_api": "GetRejectReason",
          "new_api": null,
          "old_text": "state.GetRejectReason().c_str()",
          "new_text": null,
          "old_line_content": "        return error(\"%s: CheckIndexAgainstCheckpoint(): %s\", __func__, state.GetRejectReason().c_str());",
          "new_line_content": "    indexDummy.pprev = pindexPrev;",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "LogPrintf(\"%s: Warning: Large valid fork found\\n  forking the chain at height %d (%s)\\n  lasting to height %d (%s).\\nChain state database corruption likely.\\n\", __func__,\n                   pindexBestForkBase->nHeight, pindexBestForkBase->phashBlock->ToString(),\n                   pindexBestForkTip->nHeight, pindexBestForkTip->phashBlock->ToString())",
          "new_text": null,
          "old_line_content": "            LogPrintf(\"%s: Warning: Large valid fork found\\n  forking the chain at height %d (%s)\\n  lasting to height %d (%s).\\nChain state database corruption likely.\\n\", __func__,",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1045,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "pindexBestForkBase->phashBlock->ToString()",
          "new_text": null,
          "old_line_content": "                   pindexBestForkBase->nHeight, pindexBestForkBase->phashBlock->ToString(),",
          "new_line_content": "        else",
          "content_same": false
        },
        {
          "line": 1046,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "pindexBestForkTip->phashBlock->ToString()",
          "new_text": null,
          "old_line_content": "                   pindexBestForkTip->nHeight, pindexBestForkTip->phashBlock->ToString());",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"%s: Warning: Found invalid chain at least ~6 blocks longer than our best chain.\\nChain state database corruption likely.\\n\", __func__)",
          "new_text": null,
          "old_line_content": "            LogPrintf(\"%s: Warning: Found invalid chain at least ~6 blocks longer than our best chain.\\nChain state database corruption likely.\\n\", __func__);",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 1052,
          "old_api": "SetfLargeWorkInvalidChainFound",
          "new_api": null,
          "old_text": "SetfLargeWorkInvalidChainFound(true)",
          "new_text": null,
          "old_line_content": "            SetfLargeWorkInvalidChainFound(true);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 3099,
          "old_api": "FormatStateMessage",
          "new_api": null,
          "old_text": "FormatStateMessage(state)",
          "new_text": null,
          "old_line_content": "        return error(\"%s: Consensus::CheckBlock: %s\", __func__, FormatStateMessage(state));",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 3101,
          "old_api": "FormatStateMessage",
          "new_api": null,
          "old_text": "FormatStateMessage(state)",
          "new_text": null,
          "old_line_content": "        return error(\"%s: Consensus::ContextualCheckBlock: %s\", __func__, FormatStateMessage(state));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3102,
          "old_api": "ConnectBlock",
          "new_api": null,
          "old_text": "ConnectBlock(block, state, &indexDummy, viewNew, chainparams, true)",
          "new_text": null,
          "old_line_content": "    if (!ConnectBlock(block, state, &indexDummy, viewNew, chainparams, true))",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 3104,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "state.IsValid()",
          "new_text": null,
          "old_line_content": "    assert(state.IsValid());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1057,
          "old_api": "SetfLargeWorkForkFound",
          "new_api": null,
          "old_text": "SetfLargeWorkForkFound(false)",
          "new_text": null,
          "old_line_content": "        SetfLargeWorkForkFound(false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": "SetfLargeWorkInvalidChainFound",
          "new_api": null,
          "old_text": "SetfLargeWorkInvalidChainFound(false)",
          "new_text": null,
          "old_line_content": "        SetfLargeWorkInvalidChainFound(false);",
          "new_line_content": "static void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)",
          "content_same": false
        },
        {
          "line": 1064,
          "old_api": "AssertLockHeld",
          "new_api": null,
          "old_text": "AssertLockHeld(cs_main)",
          "new_text": null,
          "old_line_content": "    AssertLockHeld(cs_main);",
          "new_line_content": "    while (pfork && pfork != plonger)",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "    CBlockIndex* plonger = chainActive.Tip();",
          "new_line_content": "            plonger = plonger->pprev;",
          "content_same": false
        },
        {
          "line": 3126,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapBlockIndex.end()",
          "new_text": null,
          "old_line_content": "    for (BlockMap::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); ++it) {",
          "new_line_content": "            pindex->nStatus &= ~BLOCK_HAVE_UNDO;",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": "GetBlockProof",
          "new_api": null,
          "old_text": "GetBlockProof(*pfork)",
          "new_text": null,
          "old_line_content": "            pindexNewForkTip->nChainWork - pfork->nChainWork > (GetBlockProof(*pfork) * 7) &&",
          "new_line_content": "        pindexBestForkBase = pfork;",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": "Height",
          "new_api": null,
          "old_text": "chainActive.Height()",
          "new_text": null,
          "old_line_content": "            chainActive.Height() - pindexNewForkTip->nHeight < 72)",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3134,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setDirtyBlockIndex.insert(pindex)",
          "new_text": null,
          "old_line_content": "            setDirtyBlockIndex.insert(pindex);",
          "new_line_content": "            // point it would be considered as a candidate for",
          "content_same": false
        },
        {
          "line": 1092,
          "old_api": "CheckForkWarningConditions",
          "new_api": null,
          "old_text": "CheckForkWarningConditions()",
          "new_text": null,
          "old_line_content": "    CheckForkWarningConditions();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3140,
          "old_api": "equal_range",
          "new_api": null,
          "old_text": "mapBlocksUnlinked.equal_range(pindex->pprev)",
          "new_text": null,
          "old_line_content": "            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex->pprev);",
          "new_line_content": "                if (_it->second == pindex) {",
          "content_same": false
        },
        {
          "line": 3145,
          "old_api": "erase",
          "new_api": null,
          "old_text": "mapBlocksUnlinked.erase(_it)",
          "new_text": null,
          "old_line_content": "                    mapBlocksUnlinked.erase(_it);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3151,
          "old_api": "SetNull",
          "new_api": null,
          "old_text": "vinfoBlockFile[fileNumber].SetNull()",
          "new_text": null,
          "old_line_content": "    vinfoBlockFile[fileNumber].SetNull();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3152,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setDirtyFileInfo.insert(fileNumber)",
          "new_text": null,
          "old_line_content": "    setDirtyFileInfo.insert(fileNumber);",
          "new_line_content": "void UnlinkPrunedFiles(const std::set<int>& setFilesToPrune)",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "LogPrintf(\"%s:  current best=%s  height=%d  log2_work=%.8g  date=%s\\n\", __func__,\n      tip->GetBlockHash().ToString(), chainActive.Height(), log(tip->nChainWork.getdouble())/log(2.0),\n      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", tip->GetBlockTime()))",
          "new_text": null,
          "old_line_content": "    LogPrintf(\"%s:  current best=%s  height=%d  log2_work=%.8g  date=%s\\n\", __func__,",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1107,
          "old_api": "log",
          "new_api": null,
          "old_text": "log(2.0)",
          "new_text": null,
          "old_line_content": "      tip->GetBlockHash().ToString(), chainActive.Height(), log(tip->nChainWork.getdouble())/log(2.0),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1108,
          "old_api": "GetBlockTime",
          "new_api": null,
          "old_text": "tip->GetBlockTime()",
          "new_text": null,
          "old_line_content": "      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", tip->GetBlockTime()));",
          "new_line_content": "void static InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state) {",
          "content_same": false
        },
        {
          "line": 3160,
          "old_api": "GetBlockPosFilename",
          "new_api": null,
          "old_text": "GetBlockPosFilename(pos, \"blk\")",
          "new_text": null,
          "old_line_content": "        fs::remove(GetBlockPosFilename(pos, \"blk\"));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3161,
          "old_api": "GetBlockPosFilename",
          "new_api": null,
          "old_text": "GetBlockPosFilename(pos, \"rev\")",
          "new_text": null,
          "old_line_content": "        fs::remove(GetBlockPosFilename(pos, \"rev\"));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3162,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"Prune: %s deleted blk/rev (%05u)\\n\", __func__, *it)",
          "new_text": null,
          "old_line_content": "        LogPrintf(\"Prune: %s deleted blk/rev (%05u)\\n\", __func__, *it);",
          "new_line_content": "/* Calculate the block/rev files to delete based on height specified by user with RPC command pruneblockchain */",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setDirtyBlockIndex.insert(pindex)",
          "new_text": null,
          "old_line_content": "        setDirtyBlockIndex.insert(pindex);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1116,
          "old_api": "erase",
          "new_api": null,
          "old_text": "setBlockIndexCandidates.erase(pindex)",
          "new_text": null,
          "old_line_content": "        setBlockIndexCandidates.erase(pindex);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1117,
          "old_api": "InvalidChainFound",
          "new_api": null,
          "old_text": "InvalidChainFound(pindex)",
          "new_text": null,
          "old_line_content": "        InvalidChainFound(pindex);",
          "new_line_content": "void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, CTxUndo &txundo, int nHeight)",
          "content_same": false
        },
        {
          "line": 3169,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(fPruneMode && nManualPruneHeight > 0)",
          "new_text": null,
          "old_line_content": "    assert(fPruneMode && nManualPruneHeight > 0);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 3171,
          "old_api": "LOCK2",
          "new_api": null,
          "old_text": "LOCK2(cs_main, cs_LastBlockFile)",
          "new_text": null,
          "old_line_content": "    LOCK2(cs_main, cs_LastBlockFile);",
          "new_line_content": "    // last block to prune is the lesser of (user-specified height, MIN_BLOCKS_TO_KEEP from the tip)",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "txundo.vprevout.emplace_back()",
          "new_text": null,
          "old_line_content": "            txundo.vprevout.emplace_back();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": "back",
          "new_api": null,
          "old_text": "txundo.vprevout.back()",
          "new_text": null,
          "old_line_content": "            bool is_spent = inputs.SpendCoin(txin.prevout, &txundo.vprevout.back());",
          "new_line_content": "    // add outputs",
          "content_same": false
        },
        {
          "line": 3176,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "    unsigned int nLastBlockWeCanPrune = std::min((unsigned)nManualPruneHeight, chainActive.Tip()->nHeight - MIN_BLOCKS_TO_KEEP);",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 1133,
          "old_api": "AddCoins",
          "new_api": null,
          "old_text": "AddCoins(inputs, tx, nHeight)",
          "new_text": null,
          "old_line_content": "    AddCoins(inputs, tx, nHeight);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3182,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setFilesToPrune.insert(fileNumber)",
          "new_text": null,
          "old_line_content": "        setFilesToPrune.insert(fileNumber);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3185,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"Prune (Manual): prune_height=%d removed %d blk/rev pairs\\n\", nLastBlockWeCanPrune, count)",
          "new_text": null,
          "old_line_content": "    LogPrintf(\"Prune (Manual): prune_height=%d removed %d blk/rev pairs\\n\", nLastBlockWeCanPrune, count);",
          "new_line_content": "void PruneBlockFilesManual(int nManualPruneHeight)",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": "UpdateCoins",
          "new_api": null,
          "old_text": "UpdateCoins(tx, inputs, txundo, nHeight)",
          "new_text": null,
          "old_line_content": "    UpdateCoins(tx, inputs, txundo, nHeight);",
          "new_line_content": "    const CScript &scriptSig = ptxTo->vin[nIn].scriptSig;",
          "content_same": false
        },
        {
          "line": 3192,
          "old_api": "Params",
          "new_api": null,
          "old_text": "Params()",
          "new_text": null,
          "old_line_content": "    const CChainParams& chainparams = Params();",
          "new_line_content": "/**",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": "CachingTransactionSignatureChecker",
          "new_api": null,
          "old_text": "CachingTransactionSignatureChecker(ptxTo, nIn, amount, cacheStore, *txdata)",
          "new_text": null,
          "old_line_content": "    return VerifyScript(scriptSig, scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, amount, cacheStore, *txdata), &error);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3193,
          "old_api": "FlushStateToDisk",
          "new_api": null,
          "old_text": "FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE, nManualPruneHeight)",
          "new_text": null,
          "old_line_content": "    FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE, nManualPruneHeight);",
          "new_line_content": " * Prune block and undo files (blk???.dat and undo???.dat) so that the disk space used is less than a user-defined target.",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1151,
          "old_api": "GetBestBlock",
          "new_api": null,
          "old_text": "inputs.GetBestBlock()",
          "new_text": null,
          "old_line_content": "    CBlockIndex* pindexPrev = mapBlockIndex.find(inputs.GetBestBlock())->second;",
          "new_line_content": "/**",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": "IsCoinBase",
          "new_api": null,
          "old_text": "tx.IsCoinBase()",
          "new_text": null,
          "old_line_content": "    if (!tx.IsCoinBase())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3214,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "    if (chainActive.Tip() == NULL || nPruneTarget == 0) {",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": "size",
          "new_api": null,
          "old_text": "tx.vin.size()",
          "new_text": null,
          "old_line_content": "            pvChecks->reserve(tx.vin.size());",
          "new_line_content": "        // Helps prevent CPU exhaustion attacks.",
          "content_same": false
        },
        {
          "line": 3221,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "    unsigned int nLastBlockWeCanPrune = chainActive.Tip()->nHeight - MIN_BLOCKS_TO_KEEP;",
          "new_line_content": "    // before the next pruning.",
          "content_same": false
        },
        {
          "line": 3222,
          "old_api": "CalculateCurrentUsage",
          "new_api": null,
          "old_text": "CalculateCurrentUsage()",
          "new_text": null,
          "old_line_content": "    uint64_t nCurrentUsage = CalculateCurrentUsage();",
          "new_line_content": "    uint64_t nBuffer = BLOCKFILE_CHUNK_SIZE + UNDOFILE_CHUNK_SIZE;",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": "size",
          "new_api": null,
          "old_text": "tx.vin.size()",
          "new_text": null,
          "old_line_content": "            for (unsigned int i = 0; i < tx.vin.size(); i++) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1182,
          "old_api": "AccessCoin",
          "new_api": null,
          "old_text": "inputs.AccessCoin(prevout)",
          "new_text": null,
          "old_line_content": "                const Coin& coin = inputs.AccessCoin(prevout);",
          "new_line_content": "                // are clearly committed to by tx' witness hash. This provides",
          "content_same": false
        },
        {
          "line": 1183,
          "old_api": "IsSpent",
          "new_api": null,
          "old_text": "coin.IsSpent()",
          "new_text": null,
          "old_line_content": "                assert(!coin.IsSpent());",
          "new_line_content": "                // a sanity check that our caching is not introducing consensus",
          "content_same": false
        },
        {
          "line": 1196,
          "old_api": "CScriptCheck",
          "new_api": null,
          "old_text": "CScriptCheck()",
          "new_text": null,
          "old_line_content": "                    pvChecks->push_back(CScriptCheck());",
          "new_line_content": "                        // Check whether the failure was caused by a",
          "content_same": false
        },
        {
          "line": 1197,
          "old_api": "back",
          "new_api": null,
          "old_text": "pvChecks->back()",
          "new_text": null,
          "old_line_content": "                    check.swap(pvChecks->back());",
          "new_line_content": "                        // non-mandatory script verification check, such as",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": "check",
          "new_api": null,
          "old_text": "check()",
          "new_text": null,
          "old_line_content": "                } else if (!check()) {",
          "new_line_content": "                        // non-standard DER encodings or non-null dummy",
          "content_same": false
        },
        {
          "line": 3244,
          "old_api": "PruneOneBlockFile",
          "new_api": null,
          "old_text": "PruneOneBlockFile(fileNumber)",
          "new_text": null,
          "old_line_content": "            PruneOneBlockFile(fileNumber);",
          "new_line_content": "            count++;",
          "content_same": false
        },
        {
          "line": 3246,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setFilesToPrune.insert(fileNumber)",
          "new_text": null,
          "old_line_content": "            setFilesToPrune.insert(fileNumber);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3252,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::PRUNE, \"Prune: target=%dMiB actual=%dMiB diff=%dMiB max_prune_height=%d removed %d blk/rev pairs\\n\",\n           nPruneTarget/1024/1024, nCurrentUsage/1024/1024,\n           ((int64_t)nPruneTarget - (int64_t)nCurrentUsage)/1024/1024,\n           nLastBlockWeCanPrune, count)",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::PRUNE, \"Prune: target=%dMiB actual=%dMiB diff=%dMiB max_prune_height=%d removed %d blk/rev pairs\\n\",",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1208,
          "old_api": "check2",
          "new_api": null,
          "old_text": "check2()",
          "new_text": null,
          "old_line_content": "                        if (check2())",
          "new_line_content": "                    // invalid in new blocks, e.g. an invalid P2SH. We DoS ban",
          "content_same": false
        },
        {
          "line": 1209,
          "old_api": "GetScriptError",
          "new_api": null,
          "old_text": "check.GetScriptError()",
          "new_text": null,
          "old_line_content": "                            return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));",
          "new_line_content": "                    // such nodes as they are not following the protocol. That",
          "content_same": false
        },
        {
          "line": 3264,
          "old_api": "_",
          "new_api": null,
          "old_text": "_(\"Error: Disk space is low!\")",
          "new_text": null,
          "old_line_content": "        return AbortNode(\"Disk space is low!\", _(\"Error: Disk space is low!\"));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1218,
          "old_api": "GetScriptError",
          "new_api": null,
          "old_text": "check.GetScriptError()",
          "new_text": null,
          "old_line_content": "                    return state.DoS(100,false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3274,
          "old_api": "parent_path",
          "new_api": null,
          "old_text": "path.parent_path()",
          "new_text": null,
          "old_line_content": "    fs::create_directories(path.parent_path());",
          "new_line_content": "    if (!file) {",
          "content_same": false
        },
        {
          "line": 3277,
          "old_api": "fsbridge::fopen(path, \"wb+\")",
          "new_api": null,
          "old_text": "fsbridge::fopen(path, \"wb+\")",
          "new_text": null,
          "old_line_content": "        file = fsbridge::fopen(path, \"wb+\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3283,
          "old_api": "fseek",
          "new_api": null,
          "old_text": "fseek(file, pos.nPos, SEEK_SET)",
          "new_text": null,
          "old_line_content": "        if (fseek(file, pos.nPos, SEEK_SET)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3284,
          "old_api": "string",
          "new_api": null,
          "old_text": "path.string()",
          "new_text": null,
          "old_line_content": "            LogPrintf(\"Unable to seek to position %u of %s\\n\", pos.nPos, path.string());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3285,
          "old_api": "fclose",
          "new_api": null,
          "old_text": "fclose(file)",
          "new_text": null,
          "old_line_content": "            fclose(file);",
          "new_line_content": "    return file;",
          "content_same": false
        },
        {
          "line": 1238,
          "old_api": "FLATDATA",
          "new_api": null,
          "old_text": "FLATDATA(messageStart)",
          "new_text": null,
          "old_line_content": "    fileout << FLATDATA(messageStart) << nSize;",
          "new_line_content": "    if (fileOutPos < 0)",
          "content_same": false
        },
        {
          "line": 1241,
          "old_api": "Get",
          "new_api": null,
          "old_text": "fileout.Get()",
          "new_text": null,
          "old_line_content": "    long fileOutPos = ftell(fileout.Get());",
          "new_line_content": "    fileout << blockundo;",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": "error",
          "new_api": null,
          "old_text": "error(\"%s: ftell failed\", __func__)",
          "new_text": null,
          "old_line_content": "        return error(\"%s: ftell failed\", __func__);",
          "new_line_content": "    // calculate & write checksum",
          "content_same": false
        },
        {
          "line": 3293,
          "old_api": "OpenDiskFile",
          "new_api": null,
          "old_text": "OpenDiskFile(pos, \"blk\", fReadOnly)",
          "new_text": null,
          "old_line_content": "    return OpenDiskFile(pos, \"blk\", fReadOnly);",
          "new_line_content": "static FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly) {",
          "content_same": false
        },
        {
          "line": 3298,
          "old_api": "OpenDiskFile",
          "new_api": null,
          "old_text": "OpenDiskFile(pos, \"rev\", fReadOnly)",
          "new_text": null,
          "old_line_content": "    return OpenDiskFile(pos, \"rev\", fReadOnly);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "hasher.GetHash()",
          "new_text": null,
          "old_line_content": "    fileout << hasher.GetHash();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3303,
          "old_api": "strprintf",
          "new_api": null,
          "old_text": "strprintf(\"%s%05u.dat\", prefix, pos.nFile)",
          "new_text": null,
          "old_line_content": "    return GetDataDir() / \"blocks\" / strprintf(\"%s%05u.dat\", prefix, pos.nFile);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": "IsNull",
          "new_api": null,
          "old_text": "filein.IsNull()",
          "new_text": null,
          "old_line_content": "    if (filein.IsNull())",
          "new_line_content": "    uint256 hashChecksum;",
          "content_same": false
        },
        {
          "line": 1261,
          "old_api": "error",
          "new_api": null,
          "old_text": "error(\"%s: OpenUndoFile failed\", __func__)",
          "new_text": null,
          "old_line_content": "        return error(\"%s: OpenUndoFile failed\", __func__);",
          "new_line_content": "    CHashVerifier<CAutoFile> verifier(&filein); // We need a CHashVerifier as reserializing may lose data",
          "content_same": false
        },
        {
          "line": 3312,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapBlockIndex.find(hash)",
          "new_text": null,
          "old_line_content": "    BlockMap::iterator mi = mapBlockIndex.find(hash);",
          "new_line_content": "    // Create new",
          "content_same": false
        },
        {
          "line": 3313,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapBlockIndex.end()",
          "new_text": null,
          "old_line_content": "    if (mi != mapBlockIndex.end())",
          "new_line_content": "    CBlockIndex* pindexNew = new CBlockIndex();",
          "content_same": false
        },
        {
          "line": 3319,
          "old_api": "std::string(__func__)",
          "new_api": null,
          "old_text": "std::string(__func__)",
          "new_text": null,
          "old_line_content": "        throw std::runtime_error(std::string(__func__) + \": new CBlockIndex failed\");",
          "new_line_content": "    return pindexNew;",
          "content_same": false
        },
        {
          "line": 3320,
          "old_api": "std::make_pair(hash, pindexNew)",
          "new_api": null,
          "old_text": "std::make_pair(hash, pindexNew)",
          "new_text": null,
          "old_line_content": "    mi = mapBlockIndex.insert(std::make_pair(hash, pindexNew)).first;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1276,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "verifier.GetHash()",
          "new_text": null,
          "old_line_content": "    if (hashChecksum != verifier.GetHash())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1277,
          "old_api": "error",
          "new_api": null,
          "old_text": "error(\"%s: Checksum mismatch\", __func__)",
          "new_text": null,
          "old_line_content": "        return error(\"%s: Checksum mismatch\", __func__);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3328,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "    if (!pblocktree->LoadBlockIndexGuts(chainparams.GetConsensus(), InsertBlockIndex))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": "SetMiscWarning",
          "new_api": null,
          "old_text": "SetMiscWarning(strMessage)",
          "new_text": null,
          "old_line_content": "    SetMiscWarning(strMessage);",
          "new_line_content": "        \"\", CClientUIInterface::MSG_ERROR);",
          "content_same": false
        },
        {
          "line": 1287,
          "old_api": "ThreadSafeMessageBox",
          "new_api": null,
          "old_text": "uiInterface.ThreadSafeMessageBox(\n        userMessage.empty() ? _(\"Error: A fatal internal error occurred, see debug.log for details\") : userMessage,\n        \"\", CClientUIInterface::MSG_ERROR)",
          "new_text": null,
          "old_line_content": "    uiInterface.ThreadSafeMessageBox(",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 1288,
          "old_api": "_",
          "new_api": null,
          "old_text": "_(\"Error: A fatal internal error occurred, see debug.log for details\")",
          "new_text": null,
          "old_line_content": "        userMessage.empty() ? _(\"Error: A fatal internal error occurred, see debug.log for details\") : userMessage,",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1290,
          "old_api": "StartShutdown",
          "new_api": null,
          "old_text": "StartShutdown()",
          "new_text": null,
          "old_line_content": "    StartShutdown();",
          "new_line_content": "bool AbortNode(CValidationState& state, const std::string& strMessage, const std::string& userMessage=\"\")",
          "content_same": false
        },
        {
          "line": 3339,
          "old_api": "std::make_pair(pindex->nHeight, pindex)",
          "new_api": null,
          "old_text": "std::make_pair(pindex->nHeight, pindex)",
          "new_text": null,
          "old_line_content": "        vSortedByHeight.push_back(std::make_pair(pindex->nHeight, pindex));",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1296,
          "old_api": "AbortNode",
          "new_api": null,
          "old_text": "AbortNode(strMessage, userMessage)",
          "new_text": null,
          "old_line_content": "    AbortNode(strMessage, userMessage);",
          "new_line_content": "} // namespace",
          "content_same": false
        },
        {
          "line": 1297,
          "old_api": "Error",
          "new_api": null,
          "old_text": "state.Error(strMessage)",
          "new_text": null,
          "old_line_content": "    return state.Error(strMessage);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3345,
          "old_api": "GetBlockProof",
          "new_api": null,
          "old_text": "GetBlockProof(*pindex)",
          "new_text": null,
          "old_line_content": "        pindex->nChainWork = (pindex->pprev ? pindex->pprev->nChainWork : 0) + GetBlockProof(*pindex);",
          "new_line_content": "        if (pindex->nTx > 0) {",
          "content_same": false
        },
        {
          "line": 3346,
          "old_api": "std::max(pindex->pprev->nTimeMax, pindex->nTime)",
          "new_api": null,
          "old_text": "std::max(pindex->pprev->nTimeMax, pindex->nTime)",
          "new_text": null,
          "old_line_content": "        pindex->nTimeMax = (pindex->pprev ? std::max(pindex->pprev->nTimeMax, pindex->nTime) : pindex->nTime);",
          "new_line_content": "            if (pindex->pprev) {",
          "content_same": false
        },
        {
          "line": 3355,
          "old_api": "std::make_pair(pindex->pprev, pindex)",
          "new_api": null,
          "old_text": "std::make_pair(pindex->pprev, pindex)",
          "new_text": null,
          "old_line_content": "                    mapBlocksUnlinked.insert(std::make_pair(pindex->pprev, pindex));",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3361,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "pindex->IsValid(BLOCK_VALID_TRANSACTIONS)",
          "new_text": null,
          "old_line_content": "        if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->nChainTx || pindex->pprev == NULL))",
          "new_line_content": "        if (pindex->pprev)",
          "content_same": false
        },
        {
          "line": 3366,
          "old_api": "BuildSkip",
          "new_api": null,
          "old_text": "pindex->BuildSkip()",
          "new_text": null,
          "old_line_content": "            pindex->BuildSkip();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3367,
          "old_api": "CBlockIndexWorkComparator",
          "new_api": null,
          "old_text": "CBlockIndexWorkComparator()(pindexBestHeader, pindex)",
          "new_text": null,
          "old_line_content": "        if (pindex->IsValid(BLOCK_VALID_TREE) && (pindexBestHeader == NULL || CBlockIndexWorkComparator()(pindexBestHeader, pindex)))",
          "new_line_content": "    // Load block file info",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": "HaveCoin",
          "new_api": null,
          "old_text": "view.HaveCoin(out)",
          "new_text": null,
          "old_line_content": "    if (view.HaveCoin(out)) fClean = false; // overwriting transaction output",
          "new_line_content": "        // information only in undo records for the last spend of a transactions'",
          "content_same": false
        },
        {
          "line": 3373,
          "old_api": "resize",
          "new_api": null,
          "old_text": "vinfoBlockFile.resize(nLastBlockFile + 1)",
          "new_text": null,
          "old_line_content": "    vinfoBlockFile.resize(nLastBlockFile + 1);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1326,
          "old_api": "AccessByTxid",
          "new_api": null,
          "old_text": "AccessByTxid(view, out.hash)",
          "new_text": null,
          "old_line_content": "        const Coin& alternate = AccessByTxid(view, out.hash);",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 1327,
          "old_api": "IsSpent",
          "new_api": null,
          "old_text": "alternate.IsSpent()",
          "new_text": null,
          "old_line_content": "        if (!alternate.IsSpent()) {",
          "new_line_content": "            return DISCONNECT_FAILED; // adding output for transaction without known metadata",
          "content_same": false
        },
        {
          "line": 3376,
          "old_api": "ReadBlockFileInfo",
          "new_api": null,
          "old_text": "pblocktree->ReadBlockFileInfo(nFile, vinfoBlockFile[nFile])",
          "new_text": null,
          "old_line_content": "        pblocktree->ReadBlockFileInfo(nFile, vinfoBlockFile[nFile]);",
          "new_line_content": "        CBlockFileInfo info;",
          "content_same": false
        },
        {
          "line": 3381,
          "old_api": "ReadBlockFileInfo",
          "new_api": null,
          "old_text": "pblocktree->ReadBlockFileInfo(nFile, info)",
          "new_text": null,
          "old_line_content": "        if (pblocktree->ReadBlockFileInfo(nFile, info)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": "std::move(undo)",
          "new_api": null,
          "old_text": "std::move(undo)",
          "new_text": null,
          "old_line_content": "    view.AddCoin(out, std::move(undo), undo.fCoinBase);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3382,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "vinfoBlockFile.push_back(info)",
          "new_text": null,
          "old_line_content": "            vinfoBlockFile.push_back(info);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3389,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"Checking all blk files are present...\\n\")",
          "new_text": null,
          "old_line_content": "    LogPrintf(\"Checking all blk files are present...\\n\");",
          "new_line_content": "        CBlockIndex* pindex = item.second;",
          "content_same": false
        },
        {
          "line": 1343,
          "old_api": "GetBestBlock",
          "new_api": null,
          "old_text": "view.GetBestBlock()",
          "new_text": null,
          "old_line_content": "    assert(pindex->GetBlockHash() == view.GetBestBlock());",
          "new_line_content": "    CBlockUndo blockUndo;",
          "content_same": false
        },
        {
          "line": 3395,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setBlkDataFiles.insert(pindex->nFile)",
          "new_text": null,
          "old_line_content": "            setBlkDataFiles.insert(pindex->nFile);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1348,
          "old_api": "GetUndoPos",
          "new_api": null,
          "old_text": "pindex->GetUndoPos()",
          "new_text": null,
          "old_line_content": "    CDiskBlockPos pos = pindex->GetUndoPos();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3398,
          "old_api": "end",
          "new_api": null,
          "old_text": "setBlkDataFiles.end()",
          "new_text": null,
          "old_line_content": "    for (std::set<int>::iterator it = setBlkDataFiles.begin(); it != setBlkDataFiles.end(); it++)",
          "new_line_content": "            return false;",
          "content_same": false
        },
        {
          "line": 1353,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindex->pprev->GetBlockHash()",
          "new_text": null,
          "old_line_content": "    if (!UndoReadFromDisk(blockUndo, pos, pindex->pprev->GetBlockHash())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3401,
          "old_api": "OpenBlockFile",
          "new_api": null,
          "old_text": "OpenBlockFile(pos, true)",
          "new_text": null,
          "old_line_content": "        if (CAutoFile(OpenBlockFile(pos, true), SER_DISK, CLIENT_VERSION).IsNull()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1358,
          "old_api": "size",
          "new_api": null,
          "old_text": "block.vtx.size()",
          "new_text": null,
          "old_line_content": "    if (blockUndo.vtxundo.size() + 1 != block.vtx.size()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1359,
          "old_api": "error",
          "new_api": null,
          "old_text": "error(\"DisconnectBlock(): block and undo data inconsistent\")",
          "new_text": null,
          "old_line_content": "        error(\"DisconnectBlock(): block and undo data inconsistent\");",
          "new_line_content": "    // undo transactions in reverse order",
          "content_same": false
        },
        {
          "line": 3407,
          "old_api": "ReadFlag",
          "new_api": null,
          "old_text": "pblocktree->ReadFlag(\"prunedblockfiles\", fHavePruned)",
          "new_text": null,
          "old_line_content": "    pblocktree->ReadFlag(\"prunedblockfiles\", fHavePruned);",
          "new_line_content": "    // Check whether we need to continue reindexing",
          "content_same": false
        },
        {
          "line": 1364,
          "old_api": "size",
          "new_api": null,
          "old_text": "block.vtx.size()",
          "new_text": null,
          "old_line_content": "    for (int i = block.vtx.size() - 1; i >= 0; i--) {",
          "new_line_content": "        // Check that all outputs are available and match the outputs in the block itself",
          "content_same": false
        },
        {
          "line": 1371,
          "old_api": "IsUnspendable",
          "new_api": null,
          "old_text": "tx.vout[o].scriptPubKey.IsUnspendable()",
          "new_text": null,
          "old_line_content": "            if (!tx.vout[o].scriptPubKey.IsUnspendable()) {",
          "new_line_content": "                if (!is_spent || tx.vout[o] != coin.out) {",
          "content_same": false
        },
        {
          "line": 3421,
          "old_api": "GetBestBlock",
          "new_api": null,
          "old_text": "pcoinsTip->GetBestBlock()",
          "new_text": null,
          "old_line_content": "    BlockMap::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1374,
          "old_api": "SpendCoin",
          "new_api": null,
          "old_text": "view.SpendCoin(out, &coin)",
          "new_text": null,
          "old_line_content": "                bool is_spent = view.SpendCoin(out, &coin);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3428,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "LogPrintf(\"%s: hashBestChain=%s height=%d date=%s progress=%f\\n\", __func__,\n        chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(),\n        DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()),\n        GuessVerificationProgress(chainparams.TxData(), chainActive.Tip()))",
          "new_text": null,
          "old_line_content": "    LogPrintf(\"%s: hashBestChain=%s height=%d date=%s progress=%f\\n\", __func__,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3429,
          "old_api": "Height",
          "new_api": null,
          "old_text": "chainActive.Height()",
          "new_text": null,
          "old_line_content": "        chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(),",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 3430,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()->GetBlockTime()",
          "new_text": null,
          "old_line_content": "        DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()),",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3431,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "        GuessVerificationProgress(chainparams.TxData(), chainActive.Tip()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1385,
          "old_api": "error",
          "new_api": null,
          "old_text": "error(\"DisconnectBlock(): transaction and undo data inconsistent\")",
          "new_text": null,
          "old_line_content": "                error(\"DisconnectBlock(): transaction and undo data inconsistent\");",
          "new_line_content": "                const COutPoint &out = tx.vin[j].prevout;",
          "content_same": false
        },
        {
          "line": 1388,
          "old_api": "size",
          "new_api": null,
          "old_text": "tx.vin.size()",
          "new_text": null,
          "old_line_content": "            for (unsigned int j = tx.vin.size(); j-- > 0;) {",
          "new_line_content": "                fClean = fClean && res != DISCONNECT_UNCLEAN;",
          "content_same": false
        },
        {
          "line": 1390,
          "old_api": "std::move(txundo.vprevout[j])",
          "new_api": null,
          "old_text": "std::move(txundo.vprevout[j])",
          "new_text": null,
          "old_line_content": "                int res = ApplyTxInUndo(std::move(txundo.vprevout[j]), view, out);",
          "new_line_content": "            // At this point, all of txundo.vprevout should have been moved out.",
          "content_same": false
        },
        {
          "line": 3438,
          "old_api": "_",
          "new_api": null,
          "old_text": "_(\"Verifying blocks...\")",
          "new_text": null,
          "old_line_content": "    uiInterface.ShowProgress(_(\"Verifying blocks...\"), 0);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3443,
          "old_api": "ShowProgress",
          "new_api": null,
          "old_text": "uiInterface.ShowProgress(\"\", 100)",
          "new_text": null,
          "old_line_content": "    uiInterface.ShowProgress(\"\", 100);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1399,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindex->pprev->GetBlockHash()",
          "new_text": null,
          "old_line_content": "    view.SetBestBlock(pindex->pprev->GetBlockHash());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3448,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "    // Verify blocks in the best chain",
          "content_same": false
        },
        {
          "line": 3449,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "    if (chainActive.Tip() == NULL || chainActive.Tip()->pprev == NULL)",
          "new_line_content": "    if (nCheckDepth <= 0)",
          "content_same": false
        },
        {
          "line": 3455,
          "old_api": "Height",
          "new_api": null,
          "old_text": "chainActive.Height()",
          "new_text": null,
          "old_line_content": "    if (nCheckDepth > chainActive.Height())",
          "new_line_content": "    CCoinsViewCache coins(coinsview);",
          "content_same": false
        },
        {
          "line": 3457,
          "old_api": "std::min(4, nCheckLevel)",
          "new_api": null,
          "old_text": "std::min(4, nCheckLevel)",
          "new_text": null,
          "old_line_content": "    nCheckLevel = std::max(0, std::min(4, nCheckLevel));",
          "new_line_content": "    CBlockIndex* pindexFailure = NULL;",
          "content_same": false
        },
        {
          "line": 3458,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel)",
          "new_text": null,
          "old_line_content": "    LogPrintf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);",
          "new_line_content": "    int nGoodTransactions = 0;",
          "content_same": false
        },
        {
          "line": 3460,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "    CBlockIndex* pindexState = chainActive.Tip();",
          "new_line_content": "    int reportDone = 0;",
          "content_same": false
        },
        {
          "line": 1413,
          "old_api": "TruncateFile",
          "new_api": null,
          "old_text": "TruncateFile(fileOld, vinfoBlockFile[nLastBlockFile].nSize)",
          "new_text": null,
          "old_line_content": "            TruncateFile(fileOld, vinfoBlockFile[nLastBlockFile].nSize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1415,
          "old_api": "fclose",
          "new_api": null,
          "old_text": "fclose(fileOld)",
          "new_text": null,
          "old_line_content": "        fclose(fileOld);",
          "new_line_content": "    if (fileOld) {",
          "content_same": false
        },
        {
          "line": 3466,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "    for (CBlockIndex* pindex = chainActive.Tip(); pindex && pindex->pprev; pindex = pindex->pprev)",
          "new_line_content": "        if (reportDone < percentageDone/10) {",
          "content_same": false
        },
        {
          "line": 1421,
          "old_api": "TruncateFile",
          "new_api": null,
          "old_text": "TruncateFile(fileOld, vinfoBlockFile[nLastBlockFile].nUndoSize)",
          "new_text": null,
          "old_line_content": "            TruncateFile(fileOld, vinfoBlockFile[nLastBlockFile].nUndoSize);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1422,
          "old_api": "FileCommit",
          "new_api": null,
          "old_text": "FileCommit(fileOld)",
          "new_text": null,
          "old_line_content": "        FileCommit(fileOld);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1423,
          "old_api": "fclose",
          "new_api": null,
          "old_text": "fclose(fileOld)",
          "new_text": null,
          "old_line_content": "        fclose(fileOld);",
          "new_line_content": "static bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigned int nAddSize);",
          "content_same": false
        },
        {
          "line": 3469,
          "old_api": "Height",
          "new_api": null,
          "old_text": "chainActive.Height()",
          "new_text": null,
          "old_line_content": "        int percentageDone = std::max(1, std::min(99, (int)(((double)(chainActive.Height() - pindex->nHeight)) / (double)nCheckDepth * (nCheckLevel >= 4 ? 50 : 100))));",
          "new_line_content": "            reportDone = percentageDone/10;",
          "content_same": false
        },
        {
          "line": 3475,
          "old_api": "_",
          "new_api": null,
          "old_text": "_(\"Verifying blocks...\")",
          "new_text": null,
          "old_line_content": "        uiInterface.ShowProgress(_(\"Verifying blocks...\"), percentageDone);",
          "new_line_content": "            // If pruning, only go back as far as we have data.",
          "content_same": false
        },
        {
          "line": 1432,
          "old_api": "RenameThread",
          "new_api": null,
          "old_text": "RenameThread(\"bitcoin-scriptch\")",
          "new_text": null,
          "old_line_content": "    RenameThread(\"bitcoin-scriptch\");",
          "new_line_content": "// Protected by cs_main",
          "content_same": false
        },
        {
          "line": 1433,
          "old_api": "Thread",
          "new_api": null,
          "old_text": "scriptcheckqueue.Thread()",
          "new_text": null,
          "old_line_content": "    scriptcheckqueue.Thread();",
          "new_line_content": "VersionBitsCache versionbitscache;",
          "content_same": false
        },
        {
          "line": 3480,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"VerifyDB(): block verification stopping at height %d (pruning, no data)\\n\", pindex->nHeight)",
          "new_text": null,
          "old_line_content": "            LogPrintf(\"VerifyDB(): block verification stopping at height %d (pruning, no data)\\n\", pindex->nHeight);",
          "new_line_content": "        // check level 0: read from disk",
          "content_same": false
        },
        {
          "line": 3488,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "        if (nCheckLevel >= 1 && !CheckBlock(block, state, chainparams.GetConsensus()))",
          "new_line_content": "        if (nCheckLevel >= 2 && pindex) {",
          "content_same": false
        },
        {
          "line": 3489,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "error(\"%s: *** found bad block at %d, hash=%s (%s)\\n\", __func__,\n                         pindex->nHeight, pindex->GetBlockHash().ToString(), FormatStateMessage(state))",
          "new_text": null,
          "old_line_content": "            return error(\"%s: *** found bad block at %d, hash=%s (%s)\\n\", __func__,",
          "new_line_content": "            CBlockUndo undo;",
          "content_same": false
        },
        {
          "line": 1445,
          "old_api": "VersionBitsState",
          "new_api": null,
          "old_text": "VersionBitsState(pindexPrev, params, (Consensus::DeploymentPos)i, versionbitscache)",
          "new_text": null,
          "old_line_content": "        ThresholdState state = VersionBitsState(pindexPrev, params, (Consensus::DeploymentPos)i, versionbitscache);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3494,
          "old_api": "GetUndoPos",
          "new_api": null,
          "old_text": "pindex->GetUndoPos()",
          "new_text": null,
          "old_line_content": "            CDiskBlockPos pos = pindex->GetUndoPos();",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1447,
          "old_api": "VersionBitsMask",
          "new_api": null,
          "old_text": "VersionBitsMask(params, (Consensus::DeploymentPos)i)",
          "new_text": null,
          "old_line_content": "            nVersion |= VersionBitsMask(params, (Consensus::DeploymentPos)i);",
          "new_line_content": "    return nVersion;",
          "content_same": false
        },
        {
          "line": 3495,
          "old_api": "IsNull",
          "new_api": null,
          "old_text": "pos.IsNull()",
          "new_text": null,
          "old_line_content": "            if (!pos.IsNull()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3496,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindex->pprev->GetBlockHash()",
          "new_text": null,
          "old_line_content": "                if (!UndoReadFromDisk(undo, pos, pindex->pprev->GetBlockHash()))",
          "new_line_content": "        // check level 3: check for inconsistencies during memory-only disconnect of tip blocks",
          "content_same": false
        },
        {
          "line": 3501,
          "old_api": "DynamicMemoryUsage",
          "new_api": null,
          "old_text": "pcoinsTip->DynamicMemoryUsage()",
          "new_text": null,
          "old_line_content": "        if (nCheckLevel >= 3 && pindex == pindexState && (coins.DynamicMemoryUsage() + pcoinsTip->DynamicMemoryUsage()) <= nCoinCacheUsage) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3502,
          "old_api": "DisconnectBlock",
          "new_api": null,
          "old_text": "DisconnectBlock(block, pindex, coins)",
          "new_text": null,
          "old_line_content": "            DisconnectResult res = DisconnectBlock(block, pindex, coins);",
          "new_line_content": "            pindexState = pindex->pprev;",
          "content_same": false
        },
        {
          "line": 3504,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "pindex->GetBlockHash().ToString()",
          "new_text": null,
          "old_line_content": "                return error(\"VerifyDB(): *** irrecoverable inconsistency in block data at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());",
          "new_line_content": "                nGoodTransactions = 0;",
          "content_same": false
        },
        {
          "line": 3511,
          "old_api": "size",
          "new_api": null,
          "old_text": "block.vtx.size()",
          "new_text": null,
          "old_line_content": "                nGoodTransactions += block.vtx.size();",
          "new_line_content": "            return true;",
          "content_same": false
        },
        {
          "line": 1466,
          "old_api": "std::numeric_limits<int64_t>::max()",
          "new_api": null,
          "old_text": "std::numeric_limits<int64_t>::max()",
          "new_text": null,
          "old_line_content": "    int64_t EndTime(const Consensus::Params& params) const { return std::numeric_limits<int64_t>::max(); }",
          "new_line_content": "    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const",
          "content_same": false
        },
        {
          "line": 3518,
          "old_api": "Height",
          "new_api": null,
          "old_text": "chainActive.Height()",
          "new_text": null,
          "old_line_content": "        return error(\"VerifyDB(): *** coin database inconsistencies found (last %i blocks, %i good transactions before that)\\n\", chainActive.Height() - pindexFailure->nHeight + 1, nGoodTransactions);",
          "new_line_content": "        CBlockIndex *pindex = pindexState;",
          "content_same": false
        },
        {
          "line": 1474,
          "old_api": "ComputeBlockVersion",
          "new_api": null,
          "old_text": "ComputeBlockVersion(pindex->pprev, params)",
          "new_text": null,
          "old_line_content": "               ((ComputeBlockVersion(pindex->pprev, params) >> bit) & 1) == 0;",
          "new_line_content": "// Protected by cs_main",
          "content_same": false
        },
        {
          "line": 3523,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "        while (pindex != chainActive.Tip()) {",
          "new_line_content": "            CBlock block;",
          "content_same": false
        },
        {
          "line": 3528,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "            if (!ReadBlockFromDisk(block, pindex, chainparams.GetConsensus()))",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3529,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "pindex->GetBlockHash().ToString()",
          "new_text": null,
          "old_line_content": "                return error(\"VerifyDB(): *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3530,
          "old_api": "ConnectBlock",
          "new_api": null,
          "old_text": "ConnectBlock(block, state, pindex, coins, chainparams)",
          "new_text": null,
          "old_line_content": "            if (!ConnectBlock(block, state, pindex, coins, chainparams))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3535,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"[DONE].\\n\")",
          "new_text": null,
          "old_line_content": "    LogPrintf(\"[DONE].\\n\");",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3536,
          "old_api": "Height",
          "new_api": null,
          "old_text": "chainActive.Height()",
          "new_text": null,
          "old_line_content": "    LogPrintf(\"No coin database inconsistencies in last %i blocks (%i transactions)\\n\", chainActive.Height() - pindexState->nHeight, nGoodTransactions);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1498,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "assert((pindex->phashBlock == NULL) ||\n           (*pindex->phashBlock == block.GetHash()))",
          "new_text": null,
          "old_line_content": "    assert((pindex->phashBlock == NULL) ||",
          "new_line_content": "    // Check it again in case a previous version let a bad block in",
          "content_same": false
        },
        {
          "line": 3546,
          "old_api": "Height",
          "new_api": null,
          "old_text": "chainActive.Height()",
          "new_text": null,
          "old_line_content": "    while (nHeight <= chainActive.Height()) {",
          "new_line_content": "        nHeight++;",
          "content_same": false
        },
        {
          "line": 3547,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "params.GetConsensus()",
          "new_text": null,
          "old_line_content": "        if (IsWitnessEnabled(chainActive[nHeight - 1], params.GetConsensus()) && !(chainActive[nHeight]->nStatus & BLOCK_OPT_WITNESS)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1507,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindex->pprev->GetBlockHash()",
          "new_text": null,
          "old_line_content": "    uint256 hashPrevBlock = pindex->pprev == NULL ? uint256() : pindex->pprev->GetBlockHash();",
          "new_line_content": "    // (its coinbase is unspendable)",
          "content_same": false
        },
        {
          "line": 3555,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "    CBlockIndex* pindex = chainActive.Tip();",
          "new_line_content": "            // since older blocks can't be served anyway, there's",
          "content_same": false
        },
        {
          "line": 3556,
          "old_api": "Height",
          "new_api": null,
          "old_text": "chainActive.Height()",
          "new_text": null,
          "old_line_content": "    while (chainActive.Height() >= nHeight) {",
          "new_line_content": "            // no need to walk further, and trying to DisconnectTip()",
          "content_same": false
        },
        {
          "line": 3557,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "        if (fPruneMode && !(chainActive.Tip()->nStatus & BLOCK_HAVE_DATA)) {",
          "new_line_content": "            // will fail (and require a needless reindex/redownload",
          "content_same": false
        },
        {
          "line": 1512,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "    if (block.GetHash() == chainparams.GetConsensus().hashGenesisBlock) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1514,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindex->GetBlockHash()",
          "new_text": null,
          "old_line_content": "            view.SetBestBlock(pindex->GetBlockHash());",
          "new_line_content": "    bool fScriptChecks = true;",
          "content_same": false
        },
        {
          "line": 3566,
          "old_api": "error",
          "new_api": null,
          "old_text": "error(\"RewindBlockIndex: unable to disconnect block at height %i\", pindex->nHeight)",
          "new_text": null,
          "old_line_content": "            return error(\"RewindBlockIndex: unable to disconnect block at height %i\", pindex->nHeight);",
          "new_line_content": "            return false;",
          "content_same": false
        },
        {
          "line": 1519,
          "old_api": "IsNull",
          "new_api": null,
          "old_text": "hashAssumeValid.IsNull()",
          "new_text": null,
          "old_line_content": "    if (!hashAssumeValid.IsNull()) {",
          "new_line_content": "        // This setting doesn't force the selection of any particular chain but makes validating some faster by",
          "content_same": false
        },
        {
          "line": 3569,
          "old_api": "FlushStateToDisk",
          "new_api": null,
          "old_text": "FlushStateToDisk(params, state, FLUSH_STATE_PERIODIC)",
          "new_text": null,
          "old_line_content": "        if (!FlushStateToDisk(params, state, FLUSH_STATE_PERIODIC))",
          "new_line_content": "    // Reduce validity flag and have-data flags.",
          "content_same": false
        },
        {
          "line": 1526,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapBlockIndex.end()",
          "new_text": null,
          "old_line_content": "        if (it != mapBlockIndex.end()) {",
          "new_line_content": "                // This block is a member of the assumed verified chain and an ancestor of the best header.",
          "content_same": false
        },
        {
          "line": 1527,
          "old_api": "GetAncestor",
          "new_api": null,
          "old_text": "it->second->GetAncestor(pindex->nHeight)",
          "new_text": null,
          "old_line_content": "            if (it->second->GetAncestor(pindex->nHeight) == pindex &&",
          "new_line_content": "                // The equivalent time check discourages hash power from extorting the network via DOS attack",
          "content_same": false
        },
        {
          "line": 1528,
          "old_api": "GetAncestor",
          "new_api": null,
          "old_text": "pindexBestHeader->GetAncestor(pindex->nHeight)",
          "new_text": null,
          "old_line_content": "                pindexBestHeader->GetAncestor(pindex->nHeight) == pindex &&",
          "new_line_content": "                //  into accepting an invalid block through telling users they must manually set assumevalid.",
          "content_same": false
        },
        {
          "line": 1529,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "                pindexBestHeader->nChainWork >= UintToArith256(chainparams.GetConsensus().nMinimumChainWork)) {",
          "new_line_content": "                //  Requiring a software change or burying the invalid block, regardless of the setting, makes",
          "content_same": false
        },
        {
          "line": 3576,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapBlockIndex.end()",
          "new_text": null,
          "old_line_content": "    for (BlockMap::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); it++) {",
          "new_line_content": "        // is on chainActive, it must be because we are a pruning node, and",
          "content_same": false
        },
        {
          "line": 3584,
          "old_api": "Contains",
          "new_api": null,
          "old_text": "chainActive.Contains(pindexIter)",
          "new_text": null,
          "old_line_content": "        if (IsWitnessEnabled(pindexIter->pprev, params.GetConsensus()) && !(pindexIter->nStatus & BLOCK_OPT_WITNESS) && !chainActive.Contains(pindexIter)) {",
          "new_line_content": "            pindexIter->nStatus &= ~(BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO);",
          "content_same": false
        },
        {
          "line": 3586,
          "old_api": "std::min<unsigned int>(pindexIter->nStatus & BLOCK_VALID_MASK, BLOCK_VALID_TREE)",
          "new_api": null,
          "old_text": "std::min<unsigned int>(pindexIter->nStatus & BLOCK_VALID_MASK, BLOCK_VALID_TREE)",
          "new_text": null,
          "old_line_content": "            pindexIter->nStatus = std::min<unsigned int>(pindexIter->nStatus & BLOCK_VALID_MASK, BLOCK_VALID_TREE) | (pindexIter->nStatus & ~BLOCK_VALID_MASK);",
          "new_line_content": "            pindexIter->nFile = 0;",
          "content_same": false
        },
        {
          "line": 1539,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "                fScriptChecks = (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, chainparams.GetConsensus()) <= 60 * 60 * 24 * 7 * 2);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1544,
          "old_api": "GetTimeMicros",
          "new_api": null,
          "old_text": "GetTimeMicros()",
          "new_text": null,
          "old_line_content": "    int64_t nTime1 = GetTimeMicros(); nTimeCheck += nTime1 - nTimeStart;",
          "new_line_content": "    // unless those are already completely spent.",
          "content_same": false
        },
        {
          "line": 1545,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::BENCH, \"    - Sanity checks: %.2fms [%.2fs]\\n\", 0.001 * (nTime1 - nTimeStart), nTimeCheck * 0.000001)",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::BENCH, \"    - Sanity checks: %.2fms [%.2fs]\\n\", 0.001 * (nTime1 - nTimeStart), nTimeCheck * 0.000001);",
          "new_line_content": "    // If such overwrites are allowed, coinbases and transactions depending upon those",
          "content_same": false
        },
        {
          "line": 3598,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setDirtyBlockIndex.insert(pindexIter)",
          "new_text": null,
          "old_line_content": "            setDirtyBlockIndex.insert(pindexIter);",
          "new_line_content": "            while (ret.first != ret.second) {",
          "content_same": false
        },
        {
          "line": 3601,
          "old_api": "equal_range",
          "new_api": null,
          "old_text": "mapBlocksUnlinked.equal_range(pindexIter->pprev)",
          "new_text": null,
          "old_line_content": "            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> ret = mapBlocksUnlinked.equal_range(pindexIter->pprev);",
          "new_line_content": "                } else {",
          "content_same": false
        },
        {
          "line": 3604,
          "old_api": "erase",
          "new_api": null,
          "old_text": "mapBlocksUnlinked.erase(ret.first++)",
          "new_text": null,
          "old_line_content": "                    mapBlocksUnlinked.erase(ret.first++);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1560,
          "old_api": "uint256S",
          "new_api": null,
          "old_text": "uint256S(\"0x00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec\")",
          "new_text": null,
          "old_line_content": "                          !((pindex->nHeight==91842 && pindex->GetBlockHash() == uint256S(\"0x00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec\")) ||",
          "new_line_content": "    // with the 2 existing duplicate coinbase pairs, not possible to create overwriting txs.  But by the",
          "content_same": false
        },
        {
          "line": 1561,
          "old_api": "uint256S",
          "new_api": null,
          "old_text": "uint256S(\"0x00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721\")",
          "new_text": null,
          "old_line_content": "                           (pindex->nHeight==91880 && pindex->GetBlockHash() == uint256S(\"0x00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721\")));",
          "new_line_content": "    // time BIP34 activated, in each of the existing pairs the duplicate coinbase had overwritten the first",
          "content_same": false
        },
        {
          "line": 3609,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "pindexIter->IsValid(BLOCK_VALID_TRANSACTIONS)",
          "new_text": null,
          "old_line_content": "        } else if (pindexIter->IsValid(BLOCK_VALID_TRANSACTIONS) && pindexIter->nChainTx) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3616,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "params.GetConsensus()",
          "new_text": null,
          "old_line_content": "    CheckBlockIndex(params.GetConsensus());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1569,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "    CBlockIndex *pindexBIP34height = pindex->pprev->GetAncestor(chainparams.GetConsensus().BIP34Height);",
          "new_line_content": "    if (fEnforceBIP30) {",
          "content_same": false
        },
        {
          "line": 3618,
          "old_api": "FlushStateToDisk",
          "new_api": null,
          "old_text": "FlushStateToDisk(params, state, FLUSH_STATE_ALWAYS)",
          "new_text": null,
          "old_line_content": "    if (!FlushStateToDisk(params, state, FLUSH_STATE_ALWAYS)) {",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 1575,
          "old_api": "size",
          "new_api": null,
          "old_text": "tx->vout.size()",
          "new_text": null,
          "old_line_content": "            for (size_t o = 0; o < tx->vout.size(); o++) {",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1576,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "tx->GetHash()",
          "new_text": null,
          "old_line_content": "                if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1577,
          "old_api": "error",
          "new_api": null,
          "old_text": "error(\"ConnectBlock(): tried to overwrite transaction\")",
          "new_text": null,
          "old_line_content": "                    return state.DoS(100, error(\"ConnectBlock(): tried to overwrite transaction\"),",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 3630,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "    pindexBestHeader = NULL;",
          "content_same": false
        },
        {
          "line": 1586,
          "old_api": "GetBlockTime",
          "new_api": null,
          "old_text": "pindex->GetBlockTime()",
          "new_text": null,
          "old_line_content": "    bool fStrictPayToScriptHash = (pindex->GetBlockTime() >= nBIP16SwitchTime);",
          "new_line_content": "    // Start enforcing the DERSIG (BIP66) rule",
          "content_same": false
        },
        {
          "line": 3635,
          "old_api": "clear",
          "new_api": null,
          "old_text": "mempool.clear()",
          "new_text": null,
          "old_line_content": "    mempool.clear();",
          "new_line_content": "    nBlockSequenceId = 1;",
          "content_same": false
        },
        {
          "line": 1591,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "    if (pindex->nHeight >= chainparams.GetConsensus().BIP66Height) {",
          "new_line_content": "    // Start enforcing CHECKLOCKTIMEVERIFY (BIP65) rule",
          "content_same": false
        },
        {
          "line": 3641,
          "old_api": "clear",
          "new_api": null,
          "old_text": "setDirtyFileInfo.clear()",
          "new_text": null,
          "old_line_content": "    setDirtyFileInfo.clear();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3642,
          "old_api": "Clear",
          "new_api": null,
          "old_text": "versionbitscache.Clear()",
          "new_text": null,
          "old_line_content": "    versionbitscache.Clear();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1596,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "    if (pindex->nHeight >= chainparams.GetConsensus().BIP65Height) {",
          "new_line_content": "    // Start enforcing BIP68 (sequence locks) and BIP112 (CHECKSEQUENCEVERIFY) using versionbits logic.",
          "content_same": false
        },
        {
          "line": 3644,
          "old_api": "clear",
          "new_api": null,
          "old_text": "warningcache[b].clear()",
          "new_text": null,
          "old_line_content": "        warningcache[b].clear();",
          "new_line_content": "        delete entry.second;",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "    if (VersionBitsState(pindex->pprev, chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3650,
          "old_api": "clear",
          "new_api": null,
          "old_text": "mapBlockIndex.clear()",
          "new_text": null,
          "old_line_content": "    mapBlockIndex.clear();",
          "new_line_content": "bool LoadBlockIndex(const CChainParams& chainparams)",
          "content_same": false
        },
        {
          "line": 1608,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "    if (IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3657,
          "old_api": "LoadBlockIndexDB",
          "new_api": null,
          "old_text": "LoadBlockIndexDB(chainparams)",
          "new_text": null,
          "old_line_content": "    if (!fReindex && !LoadBlockIndexDB(chainparams))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": "GetTimeMicros",
          "new_api": null,
          "old_text": "GetTimeMicros()",
          "new_text": null,
          "old_line_content": "    int64_t nTime2 = GetTimeMicros(); nTimeForks += nTime2 - nTime1;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1614,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::BENCH, \"    - Fork checks: %.2fms [%.2fs]\\n\", 0.001 * (nTime2 - nTime1), nTimeForks * 0.000001)",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::BENCH, \"    - Fork checks: %.2fms [%.2fs]\\n\", 0.001 * (nTime2 - nTime1), nTimeForks * 0.000001);",
          "new_line_content": "    CCheckQueueControl<CScriptCheck> control(fScriptChecks && nScriptCheckThreads ? &scriptcheckqueue : NULL);",
          "content_same": false
        },
        {
          "line": 3664,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "        return true;",
          "content_same": false
        },
        {
          "line": 3671,
          "old_api": "GetBoolArg",
          "new_api": null,
          "old_text": "GetBoolArg(\"-txindex\", DEFAULT_TXINDEX)",
          "new_text": null,
          "old_line_content": "    fTxIndex = GetBoolArg(\"-txindex\", DEFAULT_TXINDEX);",
          "new_line_content": "    // Only add the genesis block if not reindexing (in which case we reuse the one already on disk)",
          "content_same": false
        },
        {
          "line": 1624,
          "old_api": "size",
          "new_api": null,
          "old_text": "block.vtx.size()",
          "new_text": null,
          "old_line_content": "    CDiskTxPos pos(pindex->GetBlockPos(), GetSizeOfCompactSize(block.vtx.size()));",
          "new_line_content": "    std::vector<PrecomputedTransactionData> txdata;",
          "content_same": false
        },
        {
          "line": 3672,
          "old_api": "WriteFlag",
          "new_api": null,
          "old_text": "pblocktree->WriteFlag(\"txindex\", fTxIndex)",
          "new_text": null,
          "old_line_content": "    pblocktree->WriteFlag(\"txindex\", fTxIndex);",
          "new_line_content": "    if (!fReindex) {",
          "content_same": false
        },
        {
          "line": 3673,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"Initializing databases...\\n\")",
          "new_text": null,
          "old_line_content": "    LogPrintf(\"Initializing databases...\\n\");",
          "new_line_content": "        try {",
          "content_same": false
        },
        {
          "line": 1627,
          "old_api": "size",
          "new_api": null,
          "old_text": "block.vtx.size()",
          "new_text": null,
          "old_line_content": "    blockundo.vtxundo.reserve(block.vtx.size() - 1);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1629,
          "old_api": "size",
          "new_api": null,
          "old_text": "block.vtx.size()",
          "new_text": null,
          "old_line_content": "    txdata.reserve(block.vtx.size()); // Required so that pointers to individual PrecomputedTransactionData don't get invalidated",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3678,
          "old_api": "GenesisBlock",
          "new_api": null,
          "old_text": "chainparams.GenesisBlock()",
          "new_text": null,
          "old_line_content": "            CBlock &block = const_cast<CBlock&>(chainparams.GenesisBlock());",
          "new_line_content": "            CValidationState state;",
          "content_same": false
        },
        {
          "line": 1636,
          "old_api": "IsCoinBase",
          "new_api": null,
          "old_text": "tx.IsCoinBase()",
          "new_text": null,
          "old_line_content": "        if (!tx.IsCoinBase())",
          "new_line_content": "                                 REJECT_INVALID, \"bad-txns-inputs-missingorspent\");",
          "content_same": false
        },
        {
          "line": 1638,
          "old_api": "HaveInputs",
          "new_api": null,
          "old_text": "view.HaveInputs(tx)",
          "new_text": null,
          "old_line_content": "            if (!view.HaveInputs(tx))",
          "new_line_content": "            // Check that transaction is BIP68 final",
          "content_same": false
        },
        {
          "line": 1639,
          "old_api": "error",
          "new_api": null,
          "old_text": "error(\"ConnectBlock(): inputs missing/spent\")",
          "new_text": null,
          "old_line_content": "                return state.DoS(100, error(\"ConnectBlock(): inputs missing/spent\"),",
          "new_line_content": "            // BIP68 lock checks (as opposed to nLockTime checks) must",
          "content_same": false
        },
        {
          "line": 3686,
          "old_api": "error",
          "new_api": null,
          "old_text": "error(\"LoadBlockIndex(): writing genesis block to disk failed\")",
          "new_text": null,
          "old_line_content": "                return error(\"LoadBlockIndex(): writing genesis block to disk failed\");",
          "new_line_content": "            // Force a chainstate write so that when we VerifyDB in a moment, it doesn't check stale data",
          "content_same": false
        },
        {
          "line": 3688,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "            if (!ReceivedBlockTransactions(block, state, pindex, blockPos, chainparams.GetConsensus()))",
          "new_line_content": "        } catch (const std::runtime_error& e) {",
          "content_same": false
        },
        {
          "line": 3691,
          "old_api": "FlushStateToDisk",
          "new_api": null,
          "old_text": "FlushStateToDisk(chainparams, state, FLUSH_STATE_ALWAYS)",
          "new_text": null,
          "old_line_content": "            return FlushStateToDisk(chainparams, state, FLUSH_STATE_ALWAYS);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1645,
          "old_api": "size",
          "new_api": null,
          "old_text": "tx.vin.size()",
          "new_text": null,
          "old_line_content": "            prevheights.resize(tx.vin.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3693,
          "old_api": "what",
          "new_api": null,
          "old_text": "e.what()",
          "new_text": null,
          "old_line_content": "            return error(\"LoadBlockIndex(): failed to initialize block database: %s\", e.what());",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 1650,
          "old_api": "SequenceLocks",
          "new_api": null,
          "old_text": "SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)",
          "new_text": null,
          "old_line_content": "            if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1651,
          "old_api": "error",
          "new_api": null,
          "old_text": "error(\"%s: contains a non-BIP68-final transaction\", __func__)",
          "new_text": null,
          "old_line_content": "                return state.DoS(100, error(\"%s: contains a non-BIP68-final transaction\", __func__),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3704,
          "old_api": "GetTimeMillis",
          "new_api": null,
          "old_text": "GetTimeMillis()",
          "new_text": null,
          "old_line_content": "    int64_t nStart = GetTimeMillis();",
          "new_line_content": "        // This takes over fileIn and calls fclose() on it in the CBufferedFile destructor",
          "content_same": false
        },
        {
          "line": 1660,
          "old_api": "GetTransactionSigOpCost",
          "new_api": null,
          "old_text": "GetTransactionSigOpCost(tx, view, flags)",
          "new_text": null,
          "old_line_content": "        nSigOpsCost += GetTransactionSigOpCost(tx, view, flags);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3711,
          "old_api": "eof",
          "new_api": null,
          "old_text": "blkdat.eof()",
          "new_text": null,
          "old_line_content": "        while (!blkdat.eof()) {",
          "new_line_content": "            nRewind++; // start one byte further next time, in case of failure",
          "content_same": false
        },
        {
          "line": 1665,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "txdata.emplace_back(tx)",
          "new_text": null,
          "old_line_content": "        txdata.emplace_back(tx);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1666,
          "old_api": "IsCoinBase",
          "new_api": null,
          "old_text": "tx.IsCoinBase()",
          "new_text": null,
          "old_line_content": "        if (!tx.IsCoinBase())",
          "new_line_content": "            std::vector<CScriptCheck> vChecks;",
          "content_same": false
        },
        {
          "line": 3714,
          "old_api": "SetPos",
          "new_api": null,
          "old_text": "blkdat.SetPos(nRewind)",
          "new_text": null,
          "old_line_content": "            blkdat.SetPos(nRewind);",
          "new_line_content": "            try {",
          "content_same": false
        },
        {
          "line": 3716,
          "old_api": "SetLimit",
          "new_api": null,
          "old_text": "blkdat.SetLimit()",
          "new_text": null,
          "old_line_content": "            blkdat.SetLimit(); // remove former limit",
          "new_line_content": "                unsigned char buf[CMessageHeader::MESSAGE_START_SIZE];",
          "content_same": false
        },
        {
          "line": 1672,
          "old_api": "CheckInputs",
          "new_api": null,
          "old_text": "CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : NULL)",
          "new_text": null,
          "old_line_content": "            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : NULL))",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1673,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                    tx.GetHash().ToString(), FormatStateMessage(state))",
          "new_text": null,
          "old_line_content": "                return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1674,
          "old_api": "FormatStateMessage",
          "new_api": null,
          "old_text": "FormatStateMessage(state)",
          "new_text": null,
          "old_line_content": "                    tx.GetHash().ToString(), FormatStateMessage(state));",
          "new_line_content": "        CTxUndo undoDummy;",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": "Add",
          "new_api": null,
          "old_text": "control.Add(vChecks)",
          "new_text": null,
          "old_line_content": "            control.Add(vChecks);",
          "new_line_content": "        if (i > 0) {",
          "content_same": false
        },
        {
          "line": 3721,
          "old_api": "MessageStart",
          "new_api": null,
          "old_text": "chainparams.MessageStart()",
          "new_text": null,
          "old_line_content": "                blkdat.FindByte(chainparams.MessageStart()[0]);",
          "new_line_content": "                    continue;",
          "content_same": false
        },
        {
          "line": 3722,
          "old_api": "GetPos",
          "new_api": null,
          "old_text": "blkdat.GetPos()",
          "new_text": null,
          "old_line_content": "                nRewind = blkdat.GetPos()+1;",
          "new_line_content": "                // read size",
          "content_same": false
        },
        {
          "line": 3723,
          "old_api": "FLATDATA",
          "new_api": null,
          "old_text": "FLATDATA(buf)",
          "new_text": null,
          "old_line_content": "                blkdat >> FLATDATA(buf);",
          "new_line_content": "                blkdat >> nSize;",
          "content_same": false
        },
        {
          "line": 3724,
          "old_api": "MessageStart",
          "new_api": null,
          "old_text": "chainparams.MessageStart()",
          "new_text": null,
          "old_line_content": "                if (memcmp(buf, chainparams.MessageStart(), CMessageHeader::MESSAGE_START_SIZE))",
          "new_line_content": "                if (nSize < 80 || nSize > MAX_BLOCK_SERIALIZED_SIZE)",
          "content_same": false
        },
        {
          "line": 1682,
          "old_api": "back",
          "new_api": null,
          "old_text": "blockundo.vtxundo.back()",
          "new_text": null,
          "old_line_content": "        UpdateCoins(tx, view, i == 0 ? undoDummy : blockundo.vtxundo.back(), pindex->nHeight);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1685,
          "old_api": "::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION)",
          "new_api": null,
          "old_text": "::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION)",
          "new_text": null,
          "old_line_content": "        pos.nTxOffset += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1691,
          "old_api": "GetValueOut",
          "new_api": null,
          "old_text": "block.vtx[0]->GetValueOut()",
          "new_text": null,
          "old_line_content": "    if (block.vtx[0]->GetValueOut() > blockReward)",
          "new_line_content": "                               REJECT_INVALID, \"bad-cb-amount\");",
          "content_same": false
        },
        {
          "line": 1692,
          "old_api": "DoS",
          "new_api": null,
          "old_text": "state.DoS(100,\n                         error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n                               block.vtx[0]->GetValueOut(), blockReward),\n                               REJECT_INVALID, \"bad-cb-amount\")",
          "new_text": null,
          "old_line_content": "        return state.DoS(100,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3739,
          "old_api": "SetLimit",
          "new_api": null,
          "old_text": "blkdat.SetLimit(nBlockPos + nSize)",
          "new_text": null,
          "old_line_content": "                blkdat.SetLimit(nBlockPos + nSize);",
          "new_line_content": "                blkdat >> block;",
          "content_same": false
        },
        {
          "line": 3741,
          "old_api": "std::make_shared<CBlock>()",
          "new_api": null,
          "old_text": "std::make_shared<CBlock>()",
          "new_text": null,
          "old_line_content": "                std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1697,
          "old_api": "Wait",
          "new_api": null,
          "old_text": "control.Wait()",
          "new_text": null,
          "old_line_content": "    if (!control.Wait())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1698,
          "old_api": "error",
          "new_api": null,
          "old_text": "error(\"%s: CheckQueue failed\", __func__)",
          "new_text": null,
          "old_line_content": "        return state.DoS(100, error(\"%s: CheckQueue failed\", __func__), REJECT_INVALID, \"block-validation-failed\");",
          "new_line_content": "    if (fJustCheck)",
          "content_same": false
        },
        {
          "line": 1699,
          "old_api": "GetTimeMicros",
          "new_api": null,
          "old_text": "GetTimeMicros()",
          "new_text": null,
          "old_line_content": "    int64_t nTime4 = GetTimeMicros(); nTimeVerify += nTime4 - nTime2;",
          "new_line_content": "        return true;",
          "content_same": false
        },
        {
          "line": 1700,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::BENCH, \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs]\\n\", nInputs - 1, 0.001 * (nTime4 - nTime2), nInputs <= 1 ? 0 : 0.001 * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * 0.000001)",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::BENCH, \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs]\\n\", nInputs - 1, 0.001 * (nTime4 - nTime2), nInputs <= 1 ? 0 : 0.001 * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * 0.000001);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3747,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "block.GetHash()",
          "new_text": null,
          "old_line_content": "                uint256 hash = block.GetHash();",
          "new_line_content": "                    if (dbp)",
          "content_same": false
        },
        {
          "line": 3749,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "hash.ToString()",
          "new_text": null,
          "old_line_content": "                    LogPrint(BCLog::REINDEX, \"%s: Out of order block %s, parent %s not known\\n\", __func__, hash.ToString(),",
          "new_line_content": "                    continue;",
          "content_same": false
        },
        {
          "line": 3750,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "block.hashPrevBlock.ToString()",
          "new_text": null,
          "old_line_content": "                            block.hashPrevBlock.ToString());",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 3752,
          "old_api": "std::make_pair(block.hashPrevBlock, *dbp)",
          "new_api": null,
          "old_text": "std::make_pair(block.hashPrevBlock, *dbp)",
          "new_text": null,
          "old_line_content": "                        mapBlocksUnknownParent.insert(std::make_pair(block.hashPrevBlock, *dbp));",
          "new_line_content": "                // process in case the block isn't known yet",
          "content_same": false
        },
        {
          "line": 3757,
          "old_api": "count",
          "new_api": null,
          "old_text": "mapBlockIndex.count(hash)",
          "new_text": null,
          "old_line_content": "                if (mapBlockIndex.count(hash) == 0 || (mapBlockIndex[hash]->nStatus & BLOCK_HAVE_DATA) == 0) {",
          "new_line_content": "                        nLoaded++;",
          "content_same": false
        },
        {
          "line": 1710,
          "old_api": "::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION)",
          "new_api": null,
          "old_text": "::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION)",
          "new_text": null,
          "old_line_content": "            if (!FindUndoPos(state, pindex->nFile, _pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 40))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": "error",
          "new_api": null,
          "old_text": "error(\"ConnectBlock(): FindUndoPos failed\")",
          "new_text": null,
          "old_line_content": "                return error(\"ConnectBlock(): FindUndoPos failed\");",
          "new_line_content": "            // update nUndoPos in block index",
          "content_same": false
        },
        {
          "line": 1712,
          "old_api": "MessageStart",
          "new_api": null,
          "old_text": "chainparams.MessageStart()",
          "new_text": null,
          "old_line_content": "            if (!UndoWriteToDisk(blockundo, _pos, pindex->pprev->GetBlockHash(), chainparams.MessageStart()))",
          "new_line_content": "            pindex->nUndoPos = _pos.nPos;",
          "content_same": false
        },
        {
          "line": 1713,
          "old_api": "AbortNode",
          "new_api": null,
          "old_text": "AbortNode(state, \"Failed to write undo data\")",
          "new_text": null,
          "old_line_content": "                return AbortNode(state, \"Failed to write undo data\");",
          "new_line_content": "            pindex->nStatus |= BLOCK_HAVE_UNDO;",
          "content_same": false
        },
        {
          "line": 3762,
          "old_api": "IsError",
          "new_api": null,
          "old_text": "state.IsError()",
          "new_text": null,
          "old_line_content": "                    if (state.IsError())",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 3764,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "                } else if (hash != chainparams.GetConsensus().hashGenesisBlock && mapBlockIndex[hash]->nHeight % 1000 == 0) {",
          "new_line_content": "                // Activate the genesis block so normal node progress can continue",
          "content_same": false
        },
        {
          "line": 1720,
          "old_api": "RaiseValidity",
          "new_api": null,
          "old_text": "pindex->RaiseValidity(BLOCK_VALID_SCRIPTS)",
          "new_text": null,
          "old_line_content": "        pindex->RaiseValidity(BLOCK_VALID_SCRIPTS);",
          "new_line_content": "    if (fTxIndex)",
          "content_same": false
        },
        {
          "line": 3769,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "                if (hash == chainparams.GetConsensus().hashGenesisBlock) {",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 3771,
          "old_api": "ActivateBestChain",
          "new_api": null,
          "old_text": "ActivateBestChain(state, chainparams)",
          "new_text": null,
          "old_line_content": "                    if (!ActivateBestChain(state, chainparams)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1726,
          "old_api": "AbortNode",
          "new_api": null,
          "old_text": "AbortNode(state, \"Failed to write transaction index\")",
          "new_text": null,
          "old_line_content": "            return AbortNode(state, \"Failed to write transaction index\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1729,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindex->GetBlockHash()",
          "new_text": null,
          "old_line_content": "    view.SetBestBlock(pindex->GetBlockHash());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1732,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::BENCH, \"    - Index writing: %.2fms [%.2fs]\\n\", 0.001 * (nTime5 - nTime4), nTimeIndex * 0.000001)",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::BENCH, \"    - Index writing: %.2fms [%.2fs]\\n\", 0.001 * (nTime5 - nTime4), nTimeIndex * 0.000001);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3781,
          "old_api": "empty",
          "new_api": null,
          "old_text": "queue.empty()",
          "new_text": null,
          "old_line_content": "                while (!queue.empty()) {",
          "new_line_content": "                    while (range.first != range.second) {",
          "content_same": false
        },
        {
          "line": 1734,
          "old_api": "GetTimeMicros",
          "new_api": null,
          "old_text": "GetTimeMicros()",
          "new_text": null,
          "old_line_content": "    int64_t nTime6 = GetTimeMicros(); nTimeCallbacks += nTime6 - nTime5;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1735,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::BENCH, \"    - Callbacks: %.2fms [%.2fs]\\n\", 0.001 * (nTime6 - nTime5), nTimeCallbacks * 0.000001)",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::BENCH, \"    - Callbacks: %.2fms [%.2fs]\\n\", 0.001 * (nTime6 - nTime5), nTimeCallbacks * 0.000001);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3782,
          "old_api": "front",
          "new_api": null,
          "old_text": "queue.front()",
          "new_text": null,
          "old_line_content": "                    uint256 head = queue.front();",
          "new_line_content": "                        std::multimap<uint256, CDiskBlockPos>::iterator it = range.first;",
          "content_same": false
        },
        {
          "line": 3791,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "head.ToString()",
          "new_text": null,
          "old_line_content": "                                    head.ToString());",
          "new_line_content": "                            {",
          "content_same": false
        },
        {
          "line": 3792,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "                            LOCK(cs_main);",
          "new_line_content": "                                nLoaded++;",
          "content_same": false
        },
        {
          "line": 3794,
          "old_api": "AcceptBlock",
          "new_api": null,
          "old_text": "AcceptBlock(pblockrecursive, dummy, chainparams, NULL, true, &it->second, NULL)",
          "new_text": null,
          "old_line_content": "                            if (AcceptBlock(pblockrecursive, dummy, chainparams, NULL, true, &it->second, NULL))",
          "new_line_content": "                            }",
          "content_same": false
        },
        {
          "line": 1747,
          "old_api": "DynamicMemoryUsage",
          "new_api": null,
          "old_text": "mempool.DynamicMemoryUsage()",
          "new_text": null,
          "old_line_content": "    int64_t nMempoolUsage = mempool.DynamicMemoryUsage();",
          "new_line_content": "    static int64_t nLastSetChain = 0;",
          "content_same": false
        },
        {
          "line": 1748,
          "old_api": "LOCK2",
          "new_api": null,
          "old_text": "LOCK2(cs_main, cs_LastBlockFile)",
          "new_text": null,
          "old_line_content": "    LOCK2(cs_main, cs_LastBlockFile);",
          "new_line_content": "    std::set<int> setFilesToPrune;",
          "content_same": false
        },
        {
          "line": 3801,
          "old_api": "erase",
          "new_api": null,
          "old_text": "mapBlocksUnknownParent.erase(it)",
          "new_text": null,
          "old_line_content": "                        mapBlocksUnknownParent.erase(it);",
          "new_line_content": "            } catch (const std::exception& e) {",
          "content_same": false
        },
        {
          "line": 1757,
          "old_api": "FindFilesToPruneManual",
          "new_api": null,
          "old_text": "FindFilesToPruneManual(setFilesToPrune, nManualPruneHeight)",
          "new_text": null,
          "old_line_content": "            FindFilesToPruneManual(setFilesToPrune, nManualPruneHeight);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1759,
          "old_api": "PruneAfterHeight",
          "new_api": null,
          "old_text": "chainparams.PruneAfterHeight()",
          "new_text": null,
          "old_line_content": "            FindFilesToPrune(setFilesToPrune, chainparams.PruneAfterHeight());",
          "new_line_content": "            fFlushForPrune = true;",
          "content_same": false
        },
        {
          "line": 1762,
          "old_api": "empty",
          "new_api": null,
          "old_text": "setFilesToPrune.empty()",
          "new_text": null,
          "old_line_content": "        if (!setFilesToPrune.empty()) {",
          "new_line_content": "                fHavePruned = true;",
          "content_same": false
        },
        {
          "line": 3810,
          "old_api": "what",
          "new_api": null,
          "old_text": "e.what()",
          "new_text": null,
          "old_line_content": "        AbortNode(std::string(\"System error: \") + e.what());",
          "new_line_content": "    return nLoaded > 0;",
          "content_same": false
        },
        {
          "line": 1765,
          "old_api": "WriteFlag",
          "new_api": null,
          "old_text": "pblocktree->WriteFlag(\"prunedblockfiles\", true)",
          "new_text": null,
          "old_line_content": "                pblocktree->WriteFlag(\"prunedblockfiles\", true);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3813,
          "old_api": "GetTimeMillis",
          "new_api": null,
          "old_text": "GetTimeMillis()",
          "new_text": null,
          "old_line_content": "        LogPrintf(\"Loaded %i blocks from external file in %dms\\n\", nLoaded, GetTimeMillis() - nStart);",
          "new_line_content": "void static CheckBlockIndex(const Consensus::Params& consensusParams)",
          "content_same": false
        },
        {
          "line": 1770,
          "old_api": "GetTimeMicros",
          "new_api": null,
          "old_text": "GetTimeMicros()",
          "new_text": null,
          "old_line_content": "    int64_t nNow = GetTimeMicros();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3823,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "    // iterating the block tree require that chainActive has been initialized.)",
          "content_same": false
        },
        {
          "line": 3828,
          "old_api": "Height",
          "new_api": null,
          "old_text": "chainActive.Height()",
          "new_text": null,
          "old_line_content": "    if (chainActive.Height() < 0) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3829,
          "old_api": "size",
          "new_api": null,
          "old_text": "mapBlockIndex.size()",
          "new_text": null,
          "old_line_content": "        assert(mapBlockIndex.size() <= 1);",
          "new_line_content": "    // Build forward-pointing map of the entire block tree.",
          "content_same": false
        },
        {
          "line": 1782,
          "old_api": "DynamicMemoryUsage",
          "new_api": null,
          "old_text": "pcoinsTip->DynamicMemoryUsage()",
          "new_text": null,
          "old_line_content": "    int64_t cacheSize = pcoinsTip->DynamicMemoryUsage() * DB_PEAK_USAGE_FACTOR;",
          "new_line_content": "    // The cache is over the limit, we have to write now.",
          "content_same": false
        },
        {
          "line": 1783,
          "old_api": "std::max<int64_t>(nMempoolSizeMax - nMempoolUsage, 0)",
          "new_api": null,
          "old_text": "std::max<int64_t>(nMempoolSizeMax - nMempoolUsage, 0)",
          "new_text": null,
          "old_line_content": "    int64_t nTotalSpace = nCoinCacheUsage + std::max<int64_t>(nMempoolSizeMax - nMempoolUsage, 0);",
          "new_line_content": "    bool fCacheCritical = mode == FLUSH_STATE_IF_NEEDED && cacheSize > nTotalSpace;",
          "content_same": false
        },
        {
          "line": 1785,
          "old_api": "std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024)",
          "new_api": null,
          "old_text": "std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024)",
          "new_text": null,
          "old_line_content": "    bool fCacheLarge = mode == FLUSH_STATE_PERIODIC && cacheSize > std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024);",
          "new_line_content": "    bool fPeriodicWrite = mode == FLUSH_STATE_PERIODIC && nNow > nLastWrite + (int64_t)DATABASE_WRITE_INTERVAL * 1000000;",
          "content_same": false
        },
        {
          "line": 3836,
          "old_api": "std::make_pair(it->second->pprev, it->second)",
          "new_api": null,
          "old_text": "std::make_pair(it->second->pprev, it->second)",
          "new_text": null,
          "old_line_content": "        forward.insert(std::make_pair(it->second->pprev, it->second));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3839,
          "old_api": "size",
          "new_api": null,
          "old_text": "mapBlockIndex.size()",
          "new_text": null,
          "old_line_content": "    assert(forward.size() == mapBlockIndex.size());",
          "new_line_content": "    rangeGenesis.first++;",
          "content_same": false
        },
        {
          "line": 3841,
          "old_api": "equal_range",
          "new_api": null,
          "old_text": "forward.equal_range(NULL)",
          "new_text": null,
          "old_line_content": "    std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeGenesis = forward.equal_range(NULL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3844,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(rangeGenesis.first == rangeGenesis.second)",
          "new_text": null,
          "old_line_content": "    assert(rangeGenesis.first == rangeGenesis.second); // There is only one index entry with parent NULL.",
          "new_line_content": "    // block being explored which are the first to have certain properties.",
          "content_same": false
        },
        {
          "line": 1797,
          "old_api": "CheckDiskSpace",
          "new_api": null,
          "old_text": "CheckDiskSpace(0)",
          "new_text": null,
          "old_line_content": "        if (!CheckDiskSpace(0))",
          "new_line_content": "        // Then update all block file information (which may refer to block and undo files).",
          "content_same": false
        },
        {
          "line": 1798,
          "old_api": "Error",
          "new_api": null,
          "old_text": "state.Error(\"out of disk space\")",
          "new_text": null,
          "old_line_content": "            return state.Error(\"out of disk space\");",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1804,
          "old_api": "size",
          "new_api": null,
          "old_text": "setDirtyFileInfo.size()",
          "new_text": null,
          "old_line_content": "            vFiles.reserve(setDirtyFileInfo.size());",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1805,
          "old_api": "end",
          "new_api": null,
          "old_text": "setDirtyFileInfo.end()",
          "new_text": null,
          "old_line_content": "            for (std::set<int>::iterator it = setDirtyFileInfo.begin(); it != setDirtyFileInfo.end(); ) {",
          "new_line_content": "            std::vector<const CBlockIndex*> vBlocks;",
          "content_same": false
        },
        {
          "line": 1810,
          "old_api": "size",
          "new_api": null,
          "old_text": "setDirtyBlockIndex.size()",
          "new_text": null,
          "old_line_content": "            vBlocks.reserve(setDirtyBlockIndex.size());",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1813,
          "old_api": "erase",
          "new_api": null,
          "old_text": "setDirtyBlockIndex.erase(it++)",
          "new_text": null,
          "old_line_content": "                setDirtyBlockIndex.erase(it++);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1815,
          "old_api": "WriteBatchSync",
          "new_api": null,
          "old_text": "pblocktree->WriteBatchSync(vFiles, nLastBlockFile, vBlocks)",
          "new_text": null,
          "old_line_content": "            if (!pblocktree->WriteBatchSync(vFiles, nLastBlockFile, vBlocks)) {",
          "new_line_content": "        // Finally remove any pruned files",
          "content_same": false
        },
        {
          "line": 1816,
          "old_api": "AbortNode",
          "new_api": null,
          "old_text": "AbortNode(state, \"Failed to write to block index database\")",
          "new_text": null,
          "old_line_content": "                return AbortNode(state, \"Failed to write to block index database\");",
          "new_line_content": "        if (fFlushForPrune)",
          "content_same": false
        },
        {
          "line": 1821,
          "old_api": "UnlinkPrunedFiles",
          "new_api": null,
          "old_text": "UnlinkPrunedFiles(setFilesToPrune)",
          "new_text": null,
          "old_line_content": "            UnlinkPrunedFiles(setFilesToPrune);",
          "new_line_content": "    if (fDoFullFlush) {",
          "content_same": false
        },
        {
          "line": 3871,
          "old_api": "GetBlockHash",
          "new_api": null,
          "old_text": "pindex->GetBlockHash()",
          "new_text": null,
          "old_line_content": "            assert(pindex->GetBlockHash() == consensusParams.hashGenesisBlock); // Genesis block's hash must match.",
          "new_line_content": "        // VALID_TRANSACTIONS is equivalent to nTx > 0 for all nodes (whether or not pruning has occurred).",
          "content_same": false
        },
        {
          "line": 3872,
          "old_api": "Genesis",
          "new_api": null,
          "old_text": "chainActive.Genesis()",
          "new_text": null,
          "old_line_content": "            assert(pindex == chainActive.Genesis()); // The current active chain's genesis block must be this block.",
          "new_line_content": "        // HAVE_DATA is only equivalent to nTx > 0 (or VALID_TRANSACTIONS) if no pruning has occurred.",
          "content_same": false
        },
        {
          "line": 3874,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(pindex->nSequenceId <= 0)",
          "new_text": null,
          "old_line_content": "        if (pindex->nChainTx == 0) assert(pindex->nSequenceId <= 0);  // nSequenceId can't be set positive for blocks that aren't linked (negative is used for preciousblock)",
          "new_line_content": "            // If we've never pruned, then HAVE_DATA should be equivalent to nTx > 0",
          "content_same": false
        },
        {
          "line": 1832,
          "old_api": "Error",
          "new_api": null,
          "old_text": "state.Error(\"out of disk space\")",
          "new_text": null,
          "old_line_content": "            return state.Error(\"out of disk space\");",
          "new_line_content": "        nLastFlush = nNow;",
          "content_same": false
        },
        {
          "line": 3880,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(pindexFirstMissing == pindexFirstNeverProcessed)",
          "new_text": null,
          "old_line_content": "            assert(pindexFirstMissing == pindexFirstNeverProcessed);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1834,
          "old_api": "Flush",
          "new_api": null,
          "old_text": "pcoinsTip->Flush()",
          "new_text": null,
          "old_line_content": "        if (!pcoinsTip->Flush())",
          "new_line_content": "    if (fDoFullFlush || ((mode == FLUSH_STATE_ALWAYS || mode == FLUSH_STATE_PERIODIC) && nNow > nLastSetChain + (int64_t)DATABASE_WRITE_INTERVAL * 1000000)) {",
          "content_same": false
        },
        {
          "line": 1835,
          "old_api": "AbortNode",
          "new_api": null,
          "old_text": "AbortNode(state, \"Failed to write to coin database\")",
          "new_text": null,
          "old_line_content": "            return AbortNode(state, \"Failed to write to coin database\");",
          "new_line_content": "        // Update best block in wallet (so we can detect restored wallets).",
          "content_same": false
        },
        {
          "line": 3883,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(pindex->nTx > 0)",
          "new_text": null,
          "old_line_content": "            if (pindex->nStatus & BLOCK_HAVE_DATA) assert(pindex->nTx > 0);",
          "new_line_content": "        // All parents having had data (at some point) is equivalent to all parents being VALID_TRANSACTIONS, which is equivalent to nChainTx being set.",
          "content_same": false
        },
        {
          "line": 1844,
          "old_api": "what",
          "new_api": null,
          "old_text": "e.what()",
          "new_text": null,
          "old_line_content": "        return AbortNode(state, std::string(\"System error while flushing: \") + e.what());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3893,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(pindexFirstNotTreeValid == NULL)",
          "new_text": null,
          "old_line_content": "        assert(pindexFirstNotTreeValid == NULL); // All mapBlockIndex entries must at least be TREE valid",
          "new_line_content": "        if (pindexFirstInvalid == NULL) {",
          "content_same": false
        },
        {
          "line": 3894,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(pindexFirstNotTreeValid == NULL)",
          "new_text": null,
          "old_line_content": "        if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TREE) assert(pindexFirstNotTreeValid == NULL); // TREE valid implies all parents are TREE valid",
          "new_line_content": "            // Checks for not-invalid blocks.",
          "content_same": false
        },
        {
          "line": 3896,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(pindexFirstNotScriptsValid == NULL)",
          "new_text": null,
          "old_line_content": "        if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_SCRIPTS) assert(pindexFirstNotScriptsValid == NULL); // SCRIPTS valid implies all parents are SCRIPTS valid",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1851,
          "old_api": "Params",
          "new_api": null,
          "old_text": "Params()",
          "new_text": null,
          "old_line_content": "    const CChainParams& chainparams = Params();",
          "new_line_content": "void PruneAndFlush() {",
          "content_same": false
        },
        {
          "line": 1852,
          "old_api": "FlushStateToDisk",
          "new_api": null,
          "old_text": "FlushStateToDisk(chainparams, state, FLUSH_STATE_ALWAYS)",
          "new_text": null,
          "old_line_content": "    FlushStateToDisk(chainparams, state, FLUSH_STATE_ALWAYS);",
          "new_line_content": "    CValidationState state;",
          "content_same": false
        },
        {
          "line": 3899,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert((pindex->nStatus & BLOCK_FAILED_MASK) == 0)",
          "new_text": null,
          "old_line_content": "            assert((pindex->nStatus & BLOCK_FAILED_MASK) == 0); // The failed mask cannot be set for blocks without invalid parents.",
          "new_line_content": "                // If this block sorts at least as good as the current tip and",
          "content_same": false
        },
        {
          "line": 3901,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "        if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && pindexFirstNeverProcessed == NULL) {",
          "new_line_content": "                // setBlockIndexCandidates.  chainActive.Tip() must also be there",
          "content_same": false
        },
        {
          "line": 1858,
          "old_api": "Params",
          "new_api": null,
          "old_text": "Params()",
          "new_text": null,
          "old_line_content": "    const CChainParams& chainparams = Params();",
          "new_line_content": "static void DoWarning(const std::string& strWarning)",
          "content_same": false
        },
        {
          "line": 1859,
          "old_api": "FlushStateToDisk",
          "new_api": null,
          "old_text": "FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE)",
          "new_text": null,
          "old_line_content": "    FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3907,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "                if (pindexFirstMissing == NULL || pindex == chainActive.Tip()) {",
          "new_line_content": "                // setBlockIndexCandidates but had to be removed because of the missing data.",
          "content_same": false
        },
        {
          "line": 3908,
          "old_api": "count",
          "new_api": null,
          "old_text": "setBlockIndexCandidates.count(pindex)",
          "new_text": null,
          "old_line_content": "                    assert(setBlockIndexCandidates.count(pindex));",
          "new_line_content": "                // In this case it must be in mapBlocksUnlinked -- see test below.",
          "content_same": false
        },
        {
          "line": 1865,
          "old_api": "SetMiscWarning",
          "new_api": null,
          "old_text": "SetMiscWarning(strWarning)",
          "new_text": null,
          "old_line_content": "    SetMiscWarning(strWarning);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1867,
          "old_api": "AlertNotify",
          "new_api": null,
          "old_text": "AlertNotify(strWarning)",
          "new_text": null,
          "old_line_content": "        AlertNotify(strWarning);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3915,
          "old_api": "count",
          "new_api": null,
          "old_text": "setBlockIndexCandidates.count(pindex)",
          "new_text": null,
          "old_line_content": "            assert(setBlockIndexCandidates.count(pindex) == 0);",
          "new_line_content": "        bool foundInUnlinked = false;",
          "content_same": false
        },
        {
          "line": 3918,
          "old_api": "equal_range",
          "new_api": null,
          "old_text": "mapBlocksUnlinked.equal_range(pindex->pprev)",
          "new_text": null,
          "old_line_content": "        std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeUnlinked = mapBlocksUnlinked.equal_range(pindex->pprev);",
          "new_line_content": "            if (rangeUnlinked.first->second == pindex) {",
          "content_same": false
        },
        {
          "line": 3921,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(rangeUnlinked.first->first == pindex->pprev)",
          "new_text": null,
          "old_line_content": "            assert(rangeUnlinked.first->first == pindex->pprev);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1874,
          "old_api": "SetTip",
          "new_api": null,
          "old_text": "chainActive.SetTip(pindexNew)",
          "new_text": null,
          "old_line_content": "    chainActive.SetTip(pindexNew);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1877,
          "old_api": "AddTransactionsUpdated",
          "new_api": null,
          "old_text": "mempool.AddTransactionsUpdated(1)",
          "new_text": null,
          "old_line_content": "    mempool.AddTransactionsUpdated(1);",
          "new_line_content": "    std::vector<std::string> warningMessages;",
          "content_same": false
        },
        {
          "line": 1879,
          "old_api": "notify_all",
          "new_api": null,
          "old_text": "cvBlockChange.notify_all()",
          "new_text": null,
          "old_line_content": "    cvBlockChange.notify_all();",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1882,
          "old_api": "IsInitialBlockDownload",
          "new_api": null,
          "old_text": "IsInitialBlockDownload()",
          "new_text": null,
          "old_line_content": "    if (!IsInitialBlockDownload())",
          "new_line_content": "        for (int bit = 0; bit < VERSIONBITS_NUM_BITS; bit++) {",
          "content_same": false
        },
        {
          "line": 3930,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(foundInUnlinked)",
          "new_text": null,
          "old_line_content": "            assert(foundInUnlinked);",
          "new_line_content": "        if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed == NULL && pindexFirstMissing != NULL) {",
          "content_same": false
        },
        {
          "line": 1885,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "        const CBlockIndex* pindex = chainActive.Tip();",
          "new_line_content": "            if (state == THRESHOLD_ACTIVE || state == THRESHOLD_LOCKED_IN) {",
          "content_same": false
        },
        {
          "line": 3933,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(!foundInUnlinked)",
          "new_text": null,
          "old_line_content": "        if (pindexFirstMissing == NULL) assert(!foundInUnlinked); // We aren't missing data for any parent -- cannot be in mapBlocksUnlinked.",
          "new_line_content": "            // This block may have entered mapBlocksUnlinked if:",
          "content_same": false
        },
        {
          "line": 3936,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(fHavePruned)",
          "new_text": null,
          "old_line_content": "            assert(fHavePruned); // We must have pruned.",
          "new_line_content": "            //  - we tried switching to that descendant but were missing",
          "content_same": false
        },
        {
          "line": 1892,
          "old_api": "DoWarning",
          "new_api": null,
          "old_text": "DoWarning(strWarning)",
          "new_text": null,
          "old_line_content": "                    DoWarning(strWarning);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1894,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "warningMessages.push_back(strWarning)",
          "new_text": null,
          "old_line_content": "                    warningMessages.push_back(strWarning);",
          "new_line_content": "        // Check the version of the last 100 blocks to see if we need to upgrade:",
          "content_same": false
        },
        {
          "line": 3945,
          "old_api": "count",
          "new_api": null,
          "old_text": "setBlockIndexCandidates.count(pindex)",
          "new_text": null,
          "old_line_content": "            if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && setBlockIndexCandidates.count(pindex) == 0) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3947,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(foundInUnlinked)",
          "new_text": null,
          "old_line_content": "                    assert(foundInUnlinked);",
          "new_line_content": "        // assert(pindex->GetBlockHash() == pindex->GetBlockHeader().GetHash()); // Perhaps too slow",
          "content_same": false
        },
        {
          "line": 1901,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainParams.GetConsensus()",
          "new_text": null,
          "old_line_content": "            int32_t nExpectedVersion = ComputeBlockVersion(pindex->pprev, chainParams.GetConsensus());",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1907,
          "old_api": "_",
          "new_api": null,
          "old_text": "_(\"%d of last 100 blocks have unexpected version\")",
          "new_text": null,
          "old_line_content": "            warningMessages.push_back(strprintf(_(\"%d of last 100 blocks have unexpected version\"), nUpgraded));",
          "new_line_content": "            // notify GetWarnings(), called by Qt and the JSON-RPC code to warn the user:",
          "content_same": false
        },
        {
          "line": 3955,
          "old_api": "equal_range",
          "new_api": null,
          "old_text": "forward.equal_range(pindex)",
          "new_text": null,
          "old_line_content": "        std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> range = forward.equal_range(pindex);",
          "new_line_content": "            nHeight++;",
          "content_same": false
        },
        {
          "line": 1910,
          "old_api": "_",
          "new_api": null,
          "old_text": "_(\"Warning: Unknown block versions being mined! It's possible unknown rules are in effect\")",
          "new_text": null,
          "old_line_content": "            std::string strWarning = _(\"Warning: Unknown block versions being mined! It's possible unknown rules are in effect\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1919,
          "old_api": "GetCacheSize",
          "new_api": null,
          "old_text": "pcoinsTip->GetCacheSize()",
          "new_text": null,
          "old_line_content": "      GuessVerificationProgress(chainParams.TxData(), chainActive.Tip()), pcoinsTip->DynamicMemoryUsage() * (1.0 / (1<<20)), pcoinsTip->GetCacheSize());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1920,
          "old_api": "empty",
          "new_api": null,
          "old_text": "warningMessages.empty()",
          "new_text": null,
          "old_line_content": "    if (!warningMessages.empty())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1921,
          "old_api": "boost::algorithm::join(warningMessages, \", \")",
          "new_api": null,
          "old_text": "boost::algorithm::join(warningMessages, \", \")",
          "new_text": null,
          "old_line_content": "        LogPrintf(\" warning='%s'\", boost::algorithm::join(warningMessages, \", \"));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1922,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"\\n\")",
          "new_text": null,
          "old_line_content": "    LogPrintf(\"\\n\");",
          "new_line_content": "/** Disconnect chainActive's tip.",
          "content_same": false
        },
        {
          "line": 3977,
          "old_api": "equal_range",
          "new_api": null,
          "old_text": "forward.equal_range(pindexPar)",
          "new_text": null,
          "old_line_content": "            std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangePar = forward.equal_range(pindexPar);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 3979,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(rangePar.first != rangePar.second)",
          "new_text": null,
          "old_line_content": "                assert(rangePar.first != rangePar.second); // Our parent must have at least the node we're coming from as child.",
          "new_line_content": "            rangePar.first++;",
          "content_same": false
        },
        {
          "line": 1938,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "    CBlockIndex *pindexDelete = chainActive.Tip();",
          "new_line_content": "    CBlock& block = *pblock;",
          "content_same": false
        },
        {
          "line": 1941,
          "old_api": "std::make_shared<CBlock>()",
          "new_api": null,
          "old_text": "std::make_shared<CBlock>()",
          "new_text": null,
          "old_line_content": "    std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();",
          "new_line_content": "    // Apply the block atomically to the chain state.",
          "content_same": false
        },
        {
          "line": 1943,
          "old_api": "GetConsensus",
          "new_api": null,
          "old_text": "chainparams.GetConsensus()",
          "new_text": null,
          "old_line_content": "    if (!ReadBlockFromDisk(block, pindexDelete, chainparams.GetConsensus()))",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1944,
          "old_api": "AbortNode",
          "new_api": null,
          "old_text": "AbortNode(state, \"Failed to read block\")",
          "new_text": null,
          "old_line_content": "        return AbortNode(state, \"Failed to read block\");",
          "new_line_content": "        CCoinsViewCache view(pcoinsTip);",
          "content_same": false
        },
        {
          "line": 1949,
          "old_api": "DisconnectBlock",
          "new_api": null,
          "old_text": "DisconnectBlock(block, pindexDelete, view)",
          "new_text": null,
          "old_line_content": "        if (DisconnectBlock(block, pindexDelete, view) != DISCONNECT_OK)",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3998,
          "old_api": "size",
          "new_api": null,
          "old_text": "forward.size()",
          "new_text": null,
          "old_line_content": "    assert(nNodes == forward.size());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1951,
          "old_api": "Flush",
          "new_api": null,
          "old_text": "view.Flush()",
          "new_text": null,
          "old_line_content": "        bool flushed = view.Flush();",
          "new_line_content": "    // Write the chain state to disk, if necessary.",
          "content_same": false
        },
        {
          "line": 1954,
          "old_api": "GetTimeMicros",
          "new_api": null,
          "old_text": "GetTimeMicros()",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::BENCH, \"- Disconnect block: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4003,
          "old_api": "DateTimeStrFormat",
          "new_api": null,
          "old_text": "DateTimeStrFormat(\"%Y-%m-%d\", nTimeLast)",
          "new_text": null,
          "old_line_content": "    return strprintf(\"CBlockFileInfo(blocks=%u, size=%u, heights=%u...%u, time=%s...%s)\", nBlocks, nSize, nHeightFirst, nHeightLast, DateTimeStrFormat(\"%Y-%m-%d\", nTimeFirst), DateTimeStrFormat(\"%Y-%m-%d\", nTimeLast));",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1956,
          "old_api": "FlushStateToDisk",
          "new_api": null,
          "old_text": "FlushStateToDisk(chainparams, state, FLUSH_STATE_IF_NEEDED)",
          "new_text": null,
          "old_line_content": "    if (!FlushStateToDisk(chainparams, state, FLUSH_STATE_IF_NEEDED))",
          "new_line_content": "        // Save transactions to re-add to mempool at end of reorg",
          "content_same": false
        },
        {
          "line": 4008,
          "old_api": "at",
          "new_api": null,
          "old_text": "vinfoBlockFile.at(n)",
          "new_text": null,
          "old_line_content": "    return &vinfoBlockFile.at(n);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1961,
          "old_api": "rend",
          "new_api": null,
          "old_text": "block.vtx.rend()",
          "new_text": null,
          "old_line_content": "        for (auto it = block.vtx.rbegin(); it != block.vtx.rend(); ++it) {",
          "new_line_content": "            // Drop the earliest entry, and remove its children from the mempool.",
          "content_same": false
        },
        {
          "line": 4013,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "BIP9Stats VersionBitsTipStatistics(const Consensus::Params& params, Consensus::DeploymentPos pos)",
          "content_same": false
        },
        {
          "line": 1966,
          "old_api": "begin",
          "new_api": null,
          "old_text": "disconnectpool->queuedTx.get<insertion_order>().begin()",
          "new_text": null,
          "old_line_content": "            auto it = disconnectpool->queuedTx.get<insertion_order>().begin();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1967,
          "old_api": "removeRecursive",
          "new_api": null,
          "old_text": "mempool.removeRecursive(**it, MemPoolRemovalReason::REORG)",
          "new_text": null,
          "old_line_content": "            mempool.removeRecursive(**it, MemPoolRemovalReason::REORG);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1968,
          "old_api": "removeEntry",
          "new_api": null,
          "old_text": "disconnectpool->removeEntry(it)",
          "new_text": null,
          "old_line_content": "            disconnectpool->removeEntry(it);",
          "new_line_content": "    // Update chainActive and related variables.",
          "content_same": false
        },
        {
          "line": 4014,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "    return VersionBitsState(chainActive.Tip(), params, pos, versionbitscache);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 4019,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "int VersionBitsTipStateSinceHeight(const Consensus::Params& params, Consensus::DeploymentPos pos)",
          "content_same": false
        },
        {
          "line": 4020,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "    return VersionBitsStatistics(chainActive.Tip(), params, pos);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1973,
          "old_api": "UpdateTip",
          "new_api": null,
          "old_text": "UpdateTip(pindexDelete->pprev, chainparams)",
          "new_text": null,
          "old_line_content": "    UpdateTip(pindexDelete->pprev, chainparams);",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 1976,
          "old_api": "BlockDisconnected",
          "new_api": null,
          "old_text": "GetMainSignals().BlockDisconnected(pblock)",
          "new_text": null,
          "old_line_content": "    GetMainSignals().BlockDisconnected(pblock);",
          "new_line_content": "static int64_t nTimeReadFromDisk = 0;",
          "content_same": false
        },
        {
          "line": 4025,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "    LOCK(cs_main);",
          "new_line_content": "static const uint64_t MEMPOOL_DUMP_VERSION = 1;",
          "content_same": false
        },
        {
          "line": 4026,
          "old_api": "Tip",
          "new_api": null,
          "old_text": "chainActive.Tip()",
          "new_text": null,
          "old_line_content": "    return VersionBitsStateSinceHeight(chainActive.Tip(), params, pos, versionbitscache);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4035,
          "old_api": "GetDataDir",
          "new_api": null,
          "old_text": "GetDataDir()",
          "new_text": null,
          "old_line_content": "    FILE* filestr = fsbridge::fopen(GetDataDir() / \"mempool.dat\", \"rb\");",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 4037,
          "old_api": "IsNull",
          "new_api": null,
          "old_text": "file.IsNull()",
          "new_text": null,
          "old_line_content": "    if (file.IsNull()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1990,
          "old_api": "std::make_shared<std::vector<CTransactionRef>>()",
          "new_api": null,
          "old_text": "std::make_shared<std::vector<CTransactionRef>>()",
          "new_text": null,
          "old_line_content": "    PerBlockConnectTrace() : conflictedTxs(std::make_shared<std::vector<CTransactionRef>>()) {}",
          "new_line_content": " * part of a single ActivateBestChainStep call.",
          "content_same": false
        },
        {
          "line": 4038,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"Failed to open mempool file from disk. Continuing anyway.\\n\")",
          "new_text": null,
          "old_line_content": "        LogPrintf(\"Failed to open mempool file from disk. Continuing anyway.\\n\");",
          "new_line_content": "    int64_t count = 0;",
          "content_same": false
        },
        {
          "line": 4045,
          "old_api": "GetTime",
          "new_api": null,
          "old_text": "GetTime()",
          "new_text": null,
          "old_line_content": "    int64_t nNow = GetTime();",
          "new_line_content": "        file >> version;",
          "content_same": false
        },
        {
          "line": 4069,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs_main)",
          "new_text": null,
          "old_line_content": "                LOCK(cs_main);",
          "new_line_content": "                } else {",
          "content_same": false
        },
        {
          "line": 4070,
          "old_api": "AcceptToMemoryPoolWithTime",
          "new_api": null,
          "old_text": "AcceptToMemoryPoolWithTime(chainparams, mempool, state, tx, true, NULL, nTime, NULL, false, 0)",
          "new_text": null,
          "old_line_content": "                AcceptToMemoryPoolWithTime(chainparams, mempool, state, tx, true, NULL, nTime, NULL, false, 0);",
          "new_line_content": "                    ++failed;",
          "content_same": false
        },
        {
          "line": 4071,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "state.IsValid()",
          "new_text": null,
          "old_line_content": "                if (state.IsValid()) {",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 2025,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(pblock)",
          "new_text": null,
          "old_line_content": "        assert(pblock);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2026,
          "old_api": "back",
          "new_api": null,
          "old_text": "blocksConnected.back()",
          "new_text": null,
          "old_line_content": "        blocksConnected.back().pindex = pindex;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2027,
          "old_api": "std::move(pblock)",
          "new_api": null,
          "old_text": "std::move(pblock)",
          "new_text": null,
          "old_line_content": "        blocksConnected.back().pblock = std::move(pblock);",
          "new_line_content": "    std::vector<PerBlockConnectTrace>& GetBlocksConnected() {",
          "content_same": false
        },
        {
          "line": 2028,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "blocksConnected.emplace_back()",
          "new_text": null,
          "old_line_content": "        blocksConnected.emplace_back();",
          "new_line_content": "        // We always keep one extra block at the end of our list because",
          "content_same": false
        },
        {
          "line": 4079,
          "old_api": "ShutdownRequested",
          "new_api": null,
          "old_text": "ShutdownRequested()",
          "new_text": null,
          "old_line_content": "            if (ShutdownRequested())",
          "new_line_content": "        file >> mapDeltas;",
          "content_same": false
        },
        {
          "line": 2037,
          "old_api": "back",
          "new_api": null,
          "old_text": "blocksConnected.back()",
          "new_text": null,
          "old_line_content": "        assert(!blocksConnected.back().pindex);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2038,
          "old_api": "back",
          "new_api": null,
          "old_text": "blocksConnected.back().conflictedTxs->empty()",
          "new_text": null,
          "old_line_content": "        assert(blocksConnected.back().conflictedTxs->empty());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2039,
          "old_api": "pop_back",
          "new_api": null,
          "old_text": "blocksConnected.pop_back()",
          "new_text": null,
          "old_line_content": "        blocksConnected.pop_back();",
          "new_line_content": "    void NotifyEntryRemoved(CTransactionRef txRemoved, MemPoolRemovalReason reason) {",
          "content_same": false
        },
        {
          "line": 4086,
          "old_api": "PrioritiseTransaction",
          "new_api": null,
          "old_text": "mempool.PrioritiseTransaction(i.first, i.second)",
          "new_text": null,
          "old_line_content": "            mempool.PrioritiseTransaction(i.first, i.second);",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 2044,
          "old_api": "back",
          "new_api": null,
          "old_text": "blocksConnected.back()",
          "new_text": null,
          "old_line_content": "        assert(!blocksConnected.back().pindex);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4093,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"Imported mempool transactions from disk: %i successes, %i failed, %i expired\\n\", count, failed, skipped)",
          "new_text": null,
          "old_line_content": "    LogPrintf(\"Imported mempool transactions from disk: %i successes, %i failed, %i expired\\n\", count, failed, skipped);",
          "new_line_content": "void DumpMempool(void)",
          "content_same": false
        },
        {
          "line": 2046,
          "old_api": "std::move(txRemoved)",
          "new_api": null,
          "old_text": "std::move(txRemoved)",
          "new_text": null,
          "old_line_content": "            blocksConnected.back().conflictedTxs->emplace_back(std::move(txRemoved));",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 285,
      "total_additions": 728,
      "total_deletions": 730,
      "total_api_changes": 1743
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 14,
        "api_related_lines": 1743,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          505,
          506,
          507,
          494
        ]
      }
    },
    "api_calls_before": 1539,
    "api_calls_after": 1538,
    "diff_info": {
      "added_lines": 8,
      "removed_lines": 12,
      "total_diff_lines": 38
    }
  }
}