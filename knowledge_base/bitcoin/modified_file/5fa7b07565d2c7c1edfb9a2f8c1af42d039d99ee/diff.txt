diff --git a/modified_file.cpp b/modified_file.cpp
index 0000000..1111111 100644
--- a/modified_file.cpp
+++ b/modified_file.cpp
--- a/modified_file.cpp
+++ b/modified_file.cpp
@@ -25,12 +25,14 @@
         psz++;

     // Skip and count leading '1's.

     int zeroes = 0;

+    int length = 0;

     while (*psz == '1') {

         zeroes++;

         psz++;

     }

     // Allocate enough space in big-endian base256 representation.

-    std::vector<unsigned char> b256(strlen(psz) * 733 / 1000 + 1); // log(58) / log(256), rounded up.

+    int size = strlen(psz) * 733 /1000 + 1; // log(58) / log(256), rounded up.

+    std::vector<unsigned char> b256(size);

     // Process the characters.

     while (*psz && !isspace(*psz)) {

         // Decode base58 character

@@ -39,12 +41,14 @@
             return false;

         // Apply "b256 = b256 * 58 + ch".

         int carry = ch - pszBase58;

-        for (std::vector<unsigned char>::reverse_iterator it = b256.rbegin(); it != b256.rend(); it++) {

+        int i = 0;

+        for (std::vector<unsigned char>::reverse_iterator it = b256.rbegin(); (carry != 0 || i < length) && (it != b256.rend()); ++it, ++i) {

             carry += 58 * (*it);

             *it = carry % 256;

             carry /= 256;

         }

         assert(carry == 0);

+        length = i;

         psz++;

     }

     // Skip trailing spaces.

@@ -53,7 +57,7 @@
     if (*psz != 0)

         return false;

     // Skip leading zeroes in b256.

-    std::vector<unsigned char>::iterator it = b256.begin();

+    std::vector<unsigned char>::iterator it = b256.begin() + (size - length);

     while (it != b256.end() && *it == 0)

         it++;

     // Copy result into output vector.
