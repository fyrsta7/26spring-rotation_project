{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/5fa7b07565d2c7c1edfb9a2f8c1af42d039d99ee",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/5fa7b07565d2c7c1edfb9a2f8c1af42d039d99ee/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/5fa7b07565d2c7c1edfb9a2f8c1af42d039d99ee/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/5fa7b07565d2c7c1edfb9a2f8c1af42d039d99ee/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 37,
          "old_api": "strchr",
          "new_api": "isspace",
          "old_text": "strchr(pszBase58, *psz)",
          "new_text": "isspace(*psz)",
          "old_line_content": "        const char* ch = strchr(pszBase58, *psz);",
          "new_line_content": "    while (*psz && !isspace(*psz)) {",
          "content_same": false
        },
        {
          "line": 60,
          "old_api": "end",
          "new_api": "begin",
          "old_text": "b256.end()",
          "new_text": "b256.begin()",
          "old_line_content": "    vch.reserve(zeroes + (b256.end() - it));",
          "new_line_content": "    std::vector<unsigned char>::iterator it = b256.begin() + (size - length);",
          "content_same": false
        },
        {
          "line": 61,
          "old_api": "assign",
          "new_api": "end",
          "old_text": "vch.assign(zeroes, 0x00)",
          "new_text": "b256.end()",
          "old_line_content": "    vch.assign(zeroes, 0x00);",
          "new_line_content": "    while (it != b256.end() && *it == 0)",
          "content_same": false
        },
        {
          "line": 134,
          "old_api": "end",
          "new_api": "clear",
          "old_text": "vchRet.end()",
          "new_text": "vchRet.clear()",
          "old_line_content": "    uint256 hash = Hash(vchRet.begin(), vchRet.end() - 4);",
          "new_line_content": "        vchRet.clear();",
          "content_same": false
        },
        {
          "line": 139,
          "old_api": "size",
          "new_api": "end",
          "old_text": "vchRet.size()",
          "new_text": "vchRet.end()",
          "old_line_content": "    vchRet.resize(vchRet.size() - 4);",
          "new_line_content": "    if (memcmp(&hash, &vchRet.end()[-4], 4) != 0) {",
          "content_same": false
        },
        {
          "line": 176,
          "old_api": "begin",
          "new_api": "clear",
          "old_text": "vchTemp.begin()",
          "new_text": "vchData.clear()",
          "old_line_content": "    vchVersion.assign(vchTemp.begin(), vchTemp.begin() + nVersionBytes);",
          "new_line_content": "        vchData.clear();",
          "content_same": false
        },
        {
          "line": 177,
          "old_api": "size",
          "new_api": "clear",
          "old_text": "vchTemp.size()",
          "new_text": "vchVersion.clear()",
          "old_line_content": "    vchData.resize(vchTemp.size() - nVersionBytes);",
          "new_line_content": "        vchVersion.clear();",
          "content_same": false
        },
        {
          "line": 180,
          "old_api": "size",
          "new_api": "begin",
          "old_text": "vchTemp.size()",
          "new_text": "vchTemp.begin()",
          "old_line_content": "    memory_cleanse(&vchTemp[0], vchTemp.size());",
          "new_line_content": "    vchVersion.assign(vchTemp.begin(), vchTemp.begin() + nVersionBytes);",
          "content_same": false
        },
        {
          "line": 262,
          "old_api": "Base58Prefix",
          "new_api": "IsValid",
          "old_text": "Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS)",
          "new_text": "IsValid()",
          "old_line_content": "    if (vchVersion == Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS))",
          "new_line_content": "    if (!IsValid())",
          "content_same": false
        },
        {
          "line": 263,
          "old_api": "CKeyID",
          "new_api": "CNoDestination",
          "old_text": "CKeyID(id)",
          "new_text": "CNoDestination()",
          "old_line_content": "        return CKeyID(id);",
          "new_line_content": "        return CNoDestination();",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": "CScriptID",
          "new_api": "memcpy",
          "old_text": "CScriptID(id)",
          "new_text": "memcpy(&id, &vchData[0], 20)",
          "old_line_content": "        return CScriptID(id);",
          "new_line_content": "    memcpy(&id, &vchData[0], 20);",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": "CNoDestination",
          "new_api": "CKeyID",
          "old_text": "CNoDestination()",
          "new_text": "CKeyID(id)",
          "old_line_content": "        return CNoDestination();",
          "new_line_content": "        return CKeyID(id);",
          "content_same": false
        },
        {
          "line": 276,
          "old_api": "CKeyID",
          "new_api": "Base58Prefix",
          "old_text": "CKeyID(id)",
          "new_text": "Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS)",
          "old_line_content": "    keyID = CKeyID(id);",
          "new_line_content": "    if (!IsValid() || vchVersion != Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS))",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 256,
          "old_api": null,
          "new_api": "Base58Prefix",
          "old_text": null,
          "new_text": "params.Base58Prefix(CChainParams::SCRIPT_ADDRESS)",
          "old_line_content": "CTxDestination CBitcoinAddress::Get() const",
          "new_line_content": "                         vchVersion == params.Base58Prefix(CChainParams::SCRIPT_ADDRESS);",
          "content_same": false
        },
        {
          "line": 255,
          "old_api": null,
          "new_api": "Base58Prefix",
          "old_text": null,
          "new_text": "params.Base58Prefix(CChainParams::PUBKEY_ADDRESS)",
          "old_line_content": "",
          "new_line_content": "    bool fKnownVersion = vchVersion == params.Base58Prefix(CChainParams::PUBKEY_ADDRESS) ||",
          "content_same": false
        },
        {
          "line": 132,
          "old_api": null,
          "new_api": "DecodeBase58",
          "old_text": null,
          "new_text": "DecodeBase58(psz, vchRet)",
          "old_line_content": "    }",
          "new_line_content": "    if (!DecodeBase58(psz, vchRet) ||",
          "content_same": false
        },
        {
          "line": 133,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vchRet.size()",
          "old_line_content": "    // re-calculate the checksum, insure it matches the included 4-byte checksum",
          "new_line_content": "        (vchRet.size() < 4)) {",
          "content_same": false
        },
        {
          "line": 138,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "vchRet.end()",
          "old_line_content": "    }",
          "new_line_content": "    uint256 hash = Hash(vchRet.begin(), vchRet.end() - 4);",
          "content_same": false
        },
        {
          "line": 266,
          "old_api": null,
          "new_api": "Base58Prefix",
          "old_text": null,
          "new_text": "Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS)",
          "old_line_content": "    else",
          "new_line_content": "    if (vchVersion == Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS))",
          "content_same": false
        },
        {
          "line": 140,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "vchRet.clear()",
          "old_line_content": "    return true;",
          "new_line_content": "        vchRet.clear();",
          "content_same": false
        },
        {
          "line": 268,
          "old_api": null,
          "new_api": "Base58Prefix",
          "old_text": null,
          "new_text": "Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS)",
          "old_line_content": "}",
          "new_line_content": "    else if (vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS))",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": null,
          "new_api": "CScriptID",
          "old_text": null,
          "new_text": "CScriptID(id)",
          "old_line_content": "",
          "new_line_content": "        return CScriptID(id);",
          "content_same": false
        },
        {
          "line": 143,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vchRet.size()",
          "old_line_content": "bool DecodeBase58Check(const std::string& str, std::vector<unsigned char>& vchRet)",
          "new_line_content": "    vchRet.resize(vchRet.size() - 4);",
          "content_same": false
        },
        {
          "line": 271,
          "old_api": null,
          "new_api": "CNoDestination",
          "old_text": null,
          "new_text": "CNoDestination()",
          "old_line_content": "{",
          "new_line_content": "        return CNoDestination();",
          "content_same": false
        },
        {
          "line": 149,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "str.c_str()",
          "old_line_content": "{",
          "new_line_content": "    return DecodeBase58Check(str.c_str(), vchRet);",
          "content_same": false
        },
        {
          "line": 279,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(&id, &vchData[0], 20)",
          "old_line_content": "",
          "new_line_content": "    memcpy(&id, &vchData[0], 20);",
          "content_same": false
        },
        {
          "line": 280,
          "old_api": null,
          "new_api": "CKeyID",
          "old_text": null,
          "new_text": "CKeyID(id)",
          "old_line_content": "bool CBitcoinAddress::IsScript() const",
          "new_line_content": "    keyID = CKeyID(id);",
          "content_same": false
        },
        {
          "line": 154,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "vchVersion.clear()",
          "old_line_content": "void CBase58Data::SetData(const std::vector<unsigned char>& vchVersionIn, const void* pdata, size_t nSize)",
          "new_line_content": "    vchVersion.clear();",
          "content_same": false
        },
        {
          "line": 155,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "vchData.clear()",
          "old_line_content": "{",
          "new_line_content": "    vchData.clear();",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": null,
          "new_api": "Base58Prefix",
          "old_text": null,
          "new_text": "Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS)",
          "old_line_content": "{",
          "new_line_content": "    return IsValid() && vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS);",
          "content_same": false
        },
        {
          "line": 161,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "vchData.resize(nSize)",
          "old_line_content": "",
          "new_line_content": "    vchData.resize(nSize);",
          "content_same": false
        },
        {
          "line": 34,
          "old_api": null,
          "new_api": "strlen",
          "old_text": null,
          "new_text": "strlen(psz)",
          "old_line_content": "    // Process the characters.",
          "new_line_content": "    int size = strlen(psz) * 733 /1000 + 1; // log(58) / log(256), rounded up.",
          "content_same": false
        },
        {
          "line": 162,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "vchData.empty()",
          "old_line_content": "void CBase58Data::SetData(const std::vector<unsigned char>& vchVersionIn, const unsigned char* pbegin, const unsigned char* pend)",
          "new_line_content": "    if (!vchData.empty())",
          "content_same": false
        },
        {
          "line": 163,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(&vchData[0], pdata, nSize)",
          "old_line_content": "{",
          "new_line_content": "        memcpy(&vchData[0], pdata, nSize);",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "vchSecret.IsValid()",
          "old_line_content": "}",
          "new_line_content": "    assert(vchSecret.IsValid());",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vchSecret.size()",
          "old_line_content": "",
          "new_line_content": "    SetData(Params().Base58Prefix(CChainParams::SECRET_KEY), vchSecret.begin(), vchSecret.size());",
          "content_same": false
        },
        {
          "line": 39,
          "old_api": null,
          "new_api": "strchr",
          "old_text": null,
          "new_text": "strchr(pszBase58, *psz)",
          "old_line_content": "            return false;",
          "new_line_content": "        const char* ch = strchr(pszBase58, *psz);",
          "content_same": false
        },
        {
          "line": 168,
          "old_api": null,
          "new_api": "SetData",
          "old_text": null,
          "new_text": "SetData(vchVersionIn, (void*)pbegin, pend - pbegin)",
          "old_line_content": "{",
          "new_line_content": "    SetData(vchVersionIn, (void*)pbegin, pend - pbegin);",
          "content_same": false
        },
        {
          "line": 293,
          "old_api": null,
          "new_api": "IsCompressed",
          "old_text": null,
          "new_text": "vchSecret.IsCompressed()",
          "old_line_content": "CKey CBitcoinSecret::GetKey()",
          "new_line_content": "    if (vchSecret.IsCompressed())",
          "content_same": false
        },
        {
          "line": 294,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "vchData.push_back(1)",
          "old_line_content": "{",
          "new_line_content": "        vchData.push_back(1);",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vchData.size()",
          "old_line_content": "",
          "new_line_content": "    assert(vchData.size() >= 32);",
          "content_same": false
        },
        {
          "line": 45,
          "old_api": null,
          "new_api": "rend",
          "old_text": null,
          "new_text": "b256.rend()",
          "old_line_content": "            carry /= 256;",
          "new_line_content": "        for (std::vector<unsigned char>::reverse_iterator it = b256.rbegin(); (carry != 0 || i < length) && (it != b256.rend()); ++it, ++i) {",
          "content_same": false
        },
        {
          "line": 174,
          "old_api": null,
          "new_api": "DecodeBase58Check",
          "old_text": null,
          "new_text": "DecodeBase58Check(psz, vchTemp)",
          "old_line_content": "        return false;",
          "new_line_content": "    bool rc58 = DecodeBase58Check(psz, vchTemp);",
          "content_same": false
        },
        {
          "line": 175,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vchTemp.size()",
          "old_line_content": "    }",
          "new_line_content": "    if ((!rc58) || (vchTemp.size() < nVersionBytes)) {",
          "content_same": false
        },
        {
          "line": 301,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vchData.size()",
          "old_line_content": "bool CBitcoinSecret::IsValid() const",
          "new_line_content": "    ret.Set(vchData.begin(), vchData.begin() + 32, vchData.size() > 32 && vchData[32] == 1);",
          "content_same": false
        },
        {
          "line": 50,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(carry == 0)",
          "old_line_content": "    // Skip trailing spaces.",
          "new_line_content": "        assert(carry == 0);",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vchData.size()",
          "old_line_content": "",
          "new_line_content": "    bool fExpectedFormat = vchData.size() == 32 || (vchData.size() == 33 && vchData[32] == 1);",
          "content_same": false
        },
        {
          "line": 308,
          "old_api": null,
          "new_api": "Base58Prefix",
          "old_text": null,
          "new_text": "Params().Base58Prefix(CChainParams::SECRET_KEY)",
          "old_line_content": "bool CBitcoinSecret::SetString(const char* pszSecret)",
          "new_line_content": "    bool fCorrectVersion = vchVersion == Params().Base58Prefix(CChainParams::SECRET_KEY);",
          "content_same": false
        },
        {
          "line": 181,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vchTemp.size()",
          "old_line_content": "    return true;",
          "new_line_content": "    vchData.resize(vchTemp.size() - nVersionBytes);",
          "content_same": false
        },
        {
          "line": 182,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "vchData.empty()",
          "old_line_content": "}",
          "new_line_content": "    if (!vchData.empty())",
          "content_same": false
        },
        {
          "line": 55,
          "old_api": null,
          "new_api": "isspace",
          "old_text": null,
          "new_text": "isspace(*psz)",
          "old_line_content": "    // Skip leading zeroes in b256.",
          "new_line_content": "    while (isspace(*psz))",
          "content_same": false
        },
        {
          "line": 183,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vchData.size()",
          "old_line_content": "",
          "new_line_content": "        memcpy(&vchData[0], &vchTemp[nVersionBytes], vchData.size());",
          "content_same": false
        },
        {
          "line": 184,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vchTemp.size()",
          "old_line_content": "bool CBase58Data::SetString(const std::string& str)",
          "new_line_content": "    memory_cleanse(&vchTemp[0], vchTemp.size());",
          "content_same": false
        },
        {
          "line": 314,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "IsValid()",
          "old_line_content": "{",
          "new_line_content": "    return CBase58Data::SetString(pszSecret) && IsValid();",
          "content_same": false
        },
        {
          "line": 190,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "str.c_str()",
          "old_line_content": "{",
          "new_line_content": "    return SetString(str.c_str());",
          "content_same": false
        },
        {
          "line": 319,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "strSecret.c_str()",
          "old_line_content": "",
          "new_line_content": "    return SetString(strSecret.c_str());",
          "content_same": false
        },
        {
          "line": 64,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "b256.end()",
          "old_line_content": "    return true;",
          "new_line_content": "    vch.reserve(zeroes + (b256.end() - it));",
          "content_same": false
        },
        {
          "line": 65,
          "old_api": null,
          "new_api": "assign",
          "old_text": null,
          "new_text": "vch.assign(zeroes, 0x00)",
          "old_line_content": "}",
          "new_line_content": "    vch.assign(zeroes, 0x00);",
          "content_same": false
        },
        {
          "line": 66,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "b256.end()",
          "old_line_content": "",
          "new_line_content": "    while (it != b256.end())",
          "content_same": false
        },
        {
          "line": 67,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "vch.push_back(*(it++))",
          "old_line_content": "std::string EncodeBase58(const unsigned char* pbegin, const unsigned char* pend)",
          "new_line_content": "        vch.push_back(*(it++));",
          "content_same": false
        },
        {
          "line": 196,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "vchData.end()",
          "old_line_content": "int CBase58Data::CompareTo(const CBase58Data& b58) const",
          "new_line_content": "    vch.insert(vch.end(), vchData.begin(), vchData.end());",
          "content_same": false
        },
        {
          "line": 197,
          "old_api": null,
          "new_api": "EncodeBase58Check",
          "old_text": null,
          "new_text": "EncodeBase58Check(vch)",
          "old_line_content": "{",
          "new_line_content": "    return EncodeBase58Check(vch);",
          "content_same": false
        },
        {
          "line": 88,
          "old_api": null,
          "new_api": "rend",
          "old_text": null,
          "new_text": "b58.rend()",
          "old_line_content": "        }",
          "new_line_content": "        for (std::vector<unsigned char>::reverse_iterator it = b58.rbegin(); (carry != 0 || i < length) && (it != b58.rend()); it++, i++) {",
          "content_same": false
        },
        {
          "line": 94,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(carry == 0)",
          "old_line_content": "    // Skip leading zeroes in base58 result.",
          "new_line_content": "        assert(carry == 0);",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": null,
          "new_api": "Set",
          "old_text": null,
          "new_text": "addr->Set(id)",
          "old_line_content": "",
          "new_line_content": "    bool operator()(const CKeyID& id) const { return addr->Set(id); }",
          "content_same": false
        },
        {
          "line": 224,
          "old_api": null,
          "new_api": "Set",
          "old_text": null,
          "new_text": "addr->Set(id)",
          "old_line_content": "} // anon namespace",
          "new_line_content": "    bool operator()(const CScriptID& id) const { return addr->Set(id); }",
          "content_same": false
        },
        {
          "line": 99,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "b58.begin()",
          "old_line_content": "    std::string str;",
          "new_line_content": "    std::vector<unsigned char>::iterator it = b58.begin() + (size - length);",
          "content_same": false
        },
        {
          "line": 104,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "b58.end()",
          "old_line_content": "    return str;",
          "new_line_content": "    str.reserve(zeroes + (b58.end() - it));",
          "content_same": false
        },
        {
          "line": 105,
          "old_api": null,
          "new_api": "assign",
          "old_text": null,
          "new_text": "str.assign(zeroes, '1')",
          "old_line_content": "}",
          "new_line_content": "    str.assign(zeroes, '1');",
          "content_same": false
        },
        {
          "line": 106,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "b58.end()",
          "old_line_content": "",
          "new_line_content": "    while (it != b58.end())",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": null,
          "new_api": "Base58Prefix",
          "old_text": null,
          "new_text": "Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS)",
          "old_line_content": "bool CBitcoinAddress::Set(const CScriptID& id)",
          "new_line_content": "    SetData(Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS), &id, 20);",
          "content_same": false
        },
        {
          "line": 238,
          "old_api": null,
          "new_api": "Base58Prefix",
          "old_text": null,
          "new_text": "Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS)",
          "old_line_content": "bool CBitcoinAddress::Set(const CTxDestination& dest)",
          "new_line_content": "    SetData(Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS), &id, 20);",
          "content_same": false
        },
        {
          "line": 113,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vch.size()",
          "old_line_content": "{",
          "new_line_content": "    return EncodeBase58(&vch[0], &vch[0] + vch.size());",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": null,
          "new_api": "CBitcoinAddressVisitor",
          "old_text": null,
          "new_text": "CBitcoinAddressVisitor(this)",
          "old_line_content": "{",
          "new_line_content": "    return boost::apply_visitor(CBitcoinAddressVisitor(this), dest);",
          "content_same": false
        },
        {
          "line": 118,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "str.c_str()",
          "old_line_content": "{",
          "new_line_content": "    return DecodeBase58(str.c_str(), vchRet);",
          "content_same": false
        },
        {
          "line": 254,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "vchData.size()",
          "old_line_content": "}",
          "new_line_content": "    bool fCorrectSize = vchData.size() == 20;",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": null,
          "new_api": "Params",
          "old_text": null,
          "new_text": "Params()",
          "old_line_content": "{",
          "new_line_content": "    return IsValid(Params());",
          "content_same": false
        },
        {
          "line": 125,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "vch.end()",
          "old_line_content": "",
          "new_line_content": "    uint256 hash = Hash(vch.begin(), vch.end());",
          "content_same": false
        },
        {
          "line": 126,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "vch.end()",
          "old_line_content": "bool DecodeBase58Check(const char* psz, std::vector<unsigned char>& vchRet)",
          "new_line_content": "    vch.insert(vch.end(), (unsigned char*)&hash, (unsigned char*)&hash + 4);",
          "content_same": false
        },
        {
          "line": 127,
          "old_api": null,
          "new_api": "EncodeBase58",
          "old_text": null,
          "new_text": "EncodeBase58(vch)",
          "old_line_content": "{",
          "new_line_content": "    return EncodeBase58(vch);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 128,
          "old_api": "DecodeBase58",
          "new_api": null,
          "old_text": "DecodeBase58(psz, vchRet)",
          "new_text": null,
          "old_line_content": "    if (!DecodeBase58(psz, vchRet) ||",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 129,
          "old_api": "size",
          "new_api": null,
          "old_text": "vchRet.size()",
          "new_text": null,
          "old_line_content": "        (vchRet.size() < 4)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 130,
          "old_api": "clear",
          "new_api": null,
          "old_text": "vchRet.clear()",
          "new_text": null,
          "old_line_content": "        vchRet.clear();",
          "new_line_content": "bool DecodeBase58Check(const char* psz, std::vector<unsigned char>& vchRet)",
          "content_same": false
        },
        {
          "line": 258,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "IsValid()",
          "new_text": null,
          "old_line_content": "    if (!IsValid())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 259,
          "old_api": "CNoDestination",
          "new_api": null,
          "old_text": "CNoDestination()",
          "new_text": null,
          "old_line_content": "        return CNoDestination();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 261,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(&id, &vchData[0], 20)",
          "new_text": null,
          "old_line_content": "    memcpy(&id, &vchData[0], 20);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 135,
          "old_api": "end",
          "new_api": null,
          "old_text": "vchRet.end()",
          "new_text": null,
          "old_line_content": "    if (memcmp(&hash, &vchRet.end()[-4], 4) != 0) {",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 136,
          "old_api": "clear",
          "new_api": null,
          "old_text": "vchRet.clear()",
          "new_text": null,
          "old_line_content": "        vchRet.clear();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": "Base58Prefix",
          "new_api": null,
          "old_text": "Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS)",
          "new_text": null,
          "old_line_content": "    else if (vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS))",
          "new_line_content": "    uint160 id;",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": "Base58Prefix",
          "new_api": null,
          "old_text": "Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS)",
          "new_text": null,
          "old_line_content": "    if (!IsValid() || vchVersion != Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS))",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 145,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "str.c_str()",
          "new_text": null,
          "old_line_content": "    return DecodeBase58Check(str.c_str(), vchRet);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(&id, &vchData[0], 20)",
          "new_text": null,
          "old_line_content": "    memcpy(&id, &vchData[0], 20);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 150,
          "old_api": "clear",
          "new_api": null,
          "old_text": "vchVersion.clear()",
          "new_text": null,
          "old_line_content": "    vchVersion.clear();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 151,
          "old_api": "clear",
          "new_api": null,
          "old_text": "vchData.clear()",
          "new_text": null,
          "old_line_content": "    vchData.clear();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": "Base58Prefix",
          "new_api": null,
          "old_text": "Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS)",
          "new_text": null,
          "old_line_content": "    return IsValid() && vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 157,
          "old_api": "resize",
          "new_api": null,
          "old_text": "vchData.resize(nSize)",
          "new_text": null,
          "old_line_content": "    vchData.resize(nSize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 158,
          "old_api": "empty",
          "new_api": null,
          "old_text": "vchData.empty()",
          "new_text": null,
          "old_line_content": "    if (!vchData.empty())",
          "new_line_content": "void CBase58Data::SetData(const std::vector<unsigned char>& vchVersionIn, const void* pdata, size_t nSize)",
          "content_same": false
        },
        {
          "line": 159,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(&vchData[0], pdata, nSize)",
          "new_text": null,
          "old_line_content": "        memcpy(&vchData[0], pdata, nSize);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "vchSecret.IsValid()",
          "new_text": null,
          "old_line_content": "    assert(vchSecret.IsValid());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 33,
          "old_api": "strlen",
          "new_api": null,
          "old_text": "strlen(psz)",
          "new_text": null,
          "old_line_content": "    std::vector<unsigned char> b256(strlen(psz) * 733 / 1000 + 1); // log(58) / log(256), rounded up.",
          "new_line_content": "    // Allocate enough space in big-endian base256 representation.",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": "size",
          "new_api": null,
          "old_text": "vchSecret.size()",
          "new_text": null,
          "old_line_content": "    SetData(Params().Base58Prefix(CChainParams::SECRET_KEY), vchSecret.begin(), vchSecret.size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 35,
          "old_api": "isspace",
          "new_api": null,
          "old_text": "isspace(*psz)",
          "new_text": null,
          "old_line_content": "    while (*psz && !isspace(*psz)) {",
          "new_line_content": "    std::vector<unsigned char> b256(size);",
          "content_same": false
        },
        {
          "line": 164,
          "old_api": "SetData",
          "new_api": null,
          "old_text": "SetData(vchVersionIn, (void*)pbegin, pend - pbegin)",
          "new_text": null,
          "old_line_content": "    SetData(vchVersionIn, (void*)pbegin, pend - pbegin);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": "IsCompressed",
          "new_api": null,
          "old_text": "vchSecret.IsCompressed()",
          "new_text": null,
          "old_line_content": "    if (vchSecret.IsCompressed())",
          "new_line_content": "void CBitcoinSecret::SetKey(const CKey& vchSecret)",
          "content_same": false
        },
        {
          "line": 290,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "vchData.push_back(1)",
          "new_text": null,
          "old_line_content": "        vchData.push_back(1);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": "size",
          "new_api": null,
          "old_text": "vchData.size()",
          "new_text": null,
          "old_line_content": "    assert(vchData.size() >= 32);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 297,
          "old_api": "size",
          "new_api": null,
          "old_text": "vchData.size()",
          "new_text": null,
          "old_line_content": "    ret.Set(vchData.begin(), vchData.begin() + 32, vchData.size() > 32 && vchData[32] == 1);",
          "new_line_content": "CKey CBitcoinSecret::GetKey()",
          "content_same": false
        },
        {
          "line": 42,
          "old_api": "rend",
          "new_api": null,
          "old_text": "b256.rend()",
          "new_text": null,
          "old_line_content": "        for (std::vector<unsigned char>::reverse_iterator it = b256.rbegin(); it != b256.rend(); it++) {",
          "new_line_content": "        // Apply \"b256 = b256 * 58 + ch\".",
          "content_same": false
        },
        {
          "line": 170,
          "old_api": "DecodeBase58Check",
          "new_api": null,
          "old_text": "DecodeBase58Check(psz, vchTemp)",
          "new_text": null,
          "old_line_content": "    bool rc58 = DecodeBase58Check(psz, vchTemp);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 171,
          "old_api": "size",
          "new_api": null,
          "old_text": "vchTemp.size()",
          "new_text": null,
          "old_line_content": "    if ((!rc58) || (vchTemp.size() < nVersionBytes)) {",
          "new_line_content": "bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes)",
          "content_same": false
        },
        {
          "line": 172,
          "old_api": "clear",
          "new_api": null,
          "old_text": "vchData.clear()",
          "new_text": null,
          "old_line_content": "        vchData.clear();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 173,
          "old_api": "clear",
          "new_api": null,
          "old_text": "vchVersion.clear()",
          "new_text": null,
          "old_line_content": "        vchVersion.clear();",
          "new_line_content": "    std::vector<unsigned char> vchTemp;",
          "content_same": false
        },
        {
          "line": 47,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(carry == 0)",
          "new_text": null,
          "old_line_content": "        assert(carry == 0);",
          "new_line_content": "            *it = carry % 256;",
          "content_same": false
        },
        {
          "line": 303,
          "old_api": "size",
          "new_api": null,
          "old_text": "vchData.size()",
          "new_text": null,
          "old_line_content": "    bool fExpectedFormat = vchData.size() == 32 || (vchData.size() == 33 && vchData[32] == 1);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 304,
          "old_api": "Base58Prefix",
          "new_api": null,
          "old_text": "Params().Base58Prefix(CChainParams::SECRET_KEY)",
          "new_text": null,
          "old_line_content": "    bool fCorrectVersion = vchVersion == Params().Base58Prefix(CChainParams::SECRET_KEY);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 178,
          "old_api": "empty",
          "new_api": null,
          "old_text": "vchData.empty()",
          "new_text": null,
          "old_line_content": "    if (!vchData.empty())",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 51,
          "old_api": "isspace",
          "new_api": null,
          "old_text": "isspace(*psz)",
          "new_text": null,
          "old_line_content": "    while (isspace(*psz))",
          "new_line_content": "        length = i;",
          "content_same": false
        },
        {
          "line": 179,
          "old_api": "size",
          "new_api": null,
          "old_text": "vchData.size()",
          "new_text": null,
          "old_line_content": "        memcpy(&vchData[0], &vchTemp[nVersionBytes], vchData.size());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "IsValid()",
          "new_text": null,
          "old_line_content": "    return CBase58Data::SetString(pszSecret) && IsValid();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 56,
          "old_api": "begin",
          "new_api": null,
          "old_text": "b256.begin()",
          "new_text": null,
          "old_line_content": "    std::vector<unsigned char>::iterator it = b256.begin();",
          "new_line_content": "        psz++;",
          "content_same": false
        },
        {
          "line": 57,
          "old_api": "end",
          "new_api": null,
          "old_text": "b256.end()",
          "new_text": null,
          "old_line_content": "    while (it != b256.end() && *it == 0)",
          "new_line_content": "    if (*psz != 0)",
          "content_same": false
        },
        {
          "line": 186,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "str.c_str()",
          "new_text": null,
          "old_line_content": "    return SetString(str.c_str());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 315,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "strSecret.c_str()",
          "new_text": null,
          "old_line_content": "    return SetString(strSecret.c_str());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 62,
          "old_api": "end",
          "new_api": null,
          "old_text": "b256.end()",
          "new_text": null,
          "old_line_content": "    while (it != b256.end())",
          "new_line_content": "        it++;",
          "content_same": false
        },
        {
          "line": 63,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "vch.push_back(*(it++))",
          "new_text": null,
          "old_line_content": "        vch.push_back(*(it++));",
          "new_line_content": "    // Copy result into output vector.",
          "content_same": false
        },
        {
          "line": 192,
          "old_api": "end",
          "new_api": null,
          "old_text": "vchData.end()",
          "new_text": null,
          "old_line_content": "    vch.insert(vch.end(), vchData.begin(), vchData.end());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 193,
          "old_api": "EncodeBase58Check",
          "new_api": null,
          "old_text": "EncodeBase58Check(vch)",
          "new_text": null,
          "old_line_content": "    return EncodeBase58Check(vch);",
          "new_line_content": "std::string CBase58Data::ToString() const",
          "content_same": false
        },
        {
          "line": 84,
          "old_api": "rend",
          "new_api": null,
          "old_text": "b58.rend()",
          "new_text": null,
          "old_line_content": "        for (std::vector<unsigned char>::reverse_iterator it = b58.rbegin(); (carry != 0 || i < length) && (it != b58.rend()); it++, i++) {",
          "new_line_content": "    while (pbegin != pend) {",
          "content_same": false
        },
        {
          "line": 90,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(carry == 0)",
          "new_text": null,
          "old_line_content": "        assert(carry == 0);",
          "new_line_content": "            *it = carry % 58;",
          "content_same": false
        },
        {
          "line": 219,
          "old_api": "Set",
          "new_api": null,
          "old_text": "addr->Set(id)",
          "new_text": null,
          "old_line_content": "    bool operator()(const CKeyID& id) const { return addr->Set(id); }",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 220,
          "old_api": "Set",
          "new_api": null,
          "old_text": "addr->Set(id)",
          "new_text": null,
          "old_line_content": "    bool operator()(const CScriptID& id) const { return addr->Set(id); }",
          "new_line_content": "public:",
          "content_same": false
        },
        {
          "line": 95,
          "old_api": "begin",
          "new_api": null,
          "old_text": "b58.begin()",
          "new_text": null,
          "old_line_content": "    std::vector<unsigned char>::iterator it = b58.begin() + (size - length);",
          "new_line_content": "        length = i;",
          "content_same": false
        },
        {
          "line": 96,
          "old_api": "end",
          "new_api": null,
          "old_text": "b58.end()",
          "new_text": null,
          "old_line_content": "    while (it != b58.end() && *it == 0)",
          "new_line_content": "        pbegin++;",
          "content_same": false
        },
        {
          "line": 228,
          "old_api": "Base58Prefix",
          "new_api": null,
          "old_text": "Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS)",
          "new_text": null,
          "old_line_content": "    SetData(Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS), &id, 20);",
          "new_line_content": "} // anon namespace",
          "content_same": false
        },
        {
          "line": 101,
          "old_api": "assign",
          "new_api": null,
          "old_text": "str.assign(zeroes, '1')",
          "new_text": null,
          "old_line_content": "    str.assign(zeroes, '1');",
          "new_line_content": "        it++;",
          "content_same": false
        },
        {
          "line": 102,
          "old_api": "end",
          "new_api": null,
          "old_text": "b58.end()",
          "new_text": null,
          "old_line_content": "    while (it != b58.end())",
          "new_line_content": "    // Translate the result into a string.",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": "Base58Prefix",
          "new_api": null,
          "old_text": "Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS)",
          "new_text": null,
          "old_line_content": "    SetData(Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS), &id, 20);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 250,
          "old_api": "size",
          "new_api": null,
          "old_text": "vchData.size()",
          "new_text": null,
          "old_line_content": "    bool fCorrectSize = vchData.size() == 20;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 109,
          "old_api": "size",
          "new_api": null,
          "old_text": "vch.size()",
          "new_text": null,
          "old_line_content": "    return EncodeBase58(&vch[0], &vch[0] + vch.size());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 251,
          "old_api": "Base58Prefix",
          "new_api": null,
          "old_text": "params.Base58Prefix(CChainParams::PUBKEY_ADDRESS)",
          "new_text": null,
          "old_line_content": "    bool fKnownVersion = vchVersion == params.Base58Prefix(CChainParams::PUBKEY_ADDRESS) ||",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": "CBitcoinAddressVisitor",
          "new_api": null,
          "old_text": "CBitcoinAddressVisitor(this)",
          "new_text": null,
          "old_line_content": "    return boost::apply_visitor(CBitcoinAddressVisitor(this), dest);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 114,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "str.c_str()",
          "new_text": null,
          "old_line_content": "    return DecodeBase58(str.c_str(), vchRet);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": "Params",
          "new_api": null,
          "old_text": "Params()",
          "new_text": null,
          "old_line_content": "    return IsValid(Params());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 121,
          "old_api": "end",
          "new_api": null,
          "old_text": "vch.end()",
          "new_text": null,
          "old_line_content": "    uint256 hash = Hash(vch.begin(), vch.end());",
          "new_line_content": "std::string EncodeBase58Check(const std::vector<unsigned char>& vchIn)",
          "content_same": false
        },
        {
          "line": 122,
          "old_api": "end",
          "new_api": null,
          "old_text": "vch.end()",
          "new_text": null,
          "old_line_content": "    vch.insert(vch.end(), (unsigned char*)&hash, (unsigned char*)&hash + 4);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 123,
          "old_api": "EncodeBase58",
          "new_api": null,
          "old_text": "EncodeBase58(vch)",
          "new_text": null,
          "old_line_content": "    return EncodeBase58(vch);",
          "new_line_content": "    // add 4-byte hash check to the end",
          "content_same": false
        },
        {
          "line": 252,
          "old_api": "Base58Prefix",
          "new_api": null,
          "old_text": "params.Base58Prefix(CChainParams::SCRIPT_ADDRESS)",
          "new_text": null,
          "old_line_content": "                         vchVersion == params.Base58Prefix(CChainParams::SCRIPT_ADDRESS);",
          "new_line_content": "bool CBitcoinAddress::IsValid(const CChainParams& params) const",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 13,
      "total_additions": 67,
      "total_deletions": 67,
      "total_api_changes": 147
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 10,
        "api_related_lines": 147,
        "non_api_lines": 5,
        "non_api_line_numbers": [
          44,
          46,
          48,
          59,
          31
        ]
      }
    },
    "api_calls_before": 130,
    "api_calls_after": 130,
    "diff_info": {
      "added_lines": 8,
      "removed_lines": 4,
      "total_diff_lines": 85
    }
  }
}