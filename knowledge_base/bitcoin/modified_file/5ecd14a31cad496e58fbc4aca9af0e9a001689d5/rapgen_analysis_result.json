{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/5ecd14a31cad496e58fbc4aca9af0e9a001689d5",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/5ecd14a31cad496e58fbc4aca9af0e9a001689d5/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/5ecd14a31cad496e58fbc4aca9af0e9a001689d5/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/5ecd14a31cad496e58fbc4aca9af0e9a001689d5/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 837,
          "old_api": "size",
          "new_api": "GetTime<std::chrono::seconds>()",
          "old_text": "data.size()",
          "new_text": "GetTime<std::chrono::seconds>()",
          "old_line_content": "                node.nSendSize -= data.size();",
          "new_line_content": "            node.m_last_send = GetTime<std::chrono::seconds>();",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": "load",
          "new_api": "GetId",
          "old_text": "node->m_relays_txs.load()",
          "new_text": "node->GetId()",
          "old_line_content": "                .m_relay_txs = node->m_relays_txs.load(),",
          "new_line_content": "                .id = node->GetId(),",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": "HasPermission",
          "new_api": "load",
          "old_text": "node->HasPermission(NetPermissionFlags::NoBan)",
          "new_text": "node->m_relays_txs.load()",
          "old_line_content": "                .m_noban = node->HasPermission(NetPermissionFlags::NoBan),",
          "new_line_content": "                .m_relay_txs = node->m_relays_txs.load(),",
          "content_same": false
        },
        {
          "line": 902,
          "old_api": "std::move(vEvictionCandidates)",
          "new_api": "HasPermission",
          "old_text": "std::move(vEvictionCandidates)",
          "new_text": "node->HasPermission(NetPermissionFlags::NoBan)",
          "old_line_content": "    const std::optional<NodeId> node_id_to_evict = SelectNodeToEvict(std::move(vEvictionCandidates));",
          "new_line_content": "                .m_noban = node->HasPermission(NetPermissionFlags::NoBan),",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": "GetId",
          "new_api": "std::move(vEvictionCandidates)",
          "old_text": "pnode->GetId()",
          "new_text": "std::move(vEvictionCandidates)",
          "old_line_content": "        if (pnode->GetId() == *node_id_to_evict) {",
          "new_line_content": "    const std::optional<NodeId> node_id_to_evict = SelectNodeToEvict(std::move(vEvictionCandidates));",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": "NetworkErrorString",
          "new_api": "Accept",
          "old_text": "NetworkErrorString(nErr)",
          "new_text": "hListenSocket.sock->Accept((struct sockaddr*)&sockaddr, &len)",
          "old_line_content": "            LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));",
          "new_line_content": "    auto sock = hListenSocket.sock->Accept((struct sockaddr*)&sockaddr, &len);",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": "LogPrintLevel",
          "new_api": "NetworkErrorString",
          "old_text": "LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\")",
          "new_text": "NetworkErrorString(nErr)",
          "old_line_content": "        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");",
          "new_line_content": "            LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": "GetBindAddress",
          "new_api": "SetSockAddr",
          "old_text": "GetBindAddress(*sock)",
          "new_text": "addr.SetSockAddr((const struct sockaddr*)&sockaddr)",
          "old_line_content": "    const CAddress addr_bind{MaybeFlipIPv6toCJDNS(GetBindAddress(*sock)), NODE_NONE};",
          "new_line_content": "    if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": "AddSocketPermissionFlags",
          "new_api": "MaybeFlipIPv6toCJDNS",
          "old_text": "hListenSocket.AddSocketPermissionFlags(permission_flags)",
          "new_text": "MaybeFlipIPv6toCJDNS(addr)",
          "old_line_content": "    hListenSocket.AddSocketPermissionFlags(permission_flags);",
          "new_line_content": "        addr = CAddress{MaybeFlipIPv6toCJDNS(addr), NODE_NONE};",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": "NetPermissions::AddFlag(permission_flags, NetPermissionFlags::NoBan)",
          "new_api": "AddWhitelistPermissionFlags",
          "old_text": "NetPermissions::AddFlag(permission_flags, NetPermissionFlags::NoBan)",
          "new_text": "AddWhitelistPermissionFlags(permission_flags, addr)",
          "old_line_content": "        NetPermissions::AddFlag(permission_flags, NetPermissionFlags::NoBan);",
          "new_line_content": "    AddWhitelistPermissionFlags(permission_flags, addr);",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": "LOCK",
          "new_api": "NetPermissions::AddFlag(permission_flags, NetPermissionFlags::Relay)",
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": "NetPermissions::AddFlag(permission_flags, NetPermissionFlags::Relay)",
          "old_line_content": "        LOCK(m_nodes_mutex);",
          "new_line_content": "        if (gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)) NetPermissions::AddFlag(permission_flags, NetPermissionFlags::Relay);",
          "content_same": false
        },
        {
          "line": 965,
          "old_api": "IsInboundConn",
          "new_api": "NetPermissions::AddFlag(permission_flags, NetPermissionFlags::NoBan)",
          "old_text": "pnode->IsInboundConn()",
          "new_text": "NetPermissions::AddFlag(permission_flags, NetPermissionFlags::NoBan)",
          "old_line_content": "            if (pnode->IsInboundConn()) nInbound++;",
          "new_line_content": "        NetPermissions::AddFlag(permission_flags, NetPermissionFlags::NoBan);",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": "IsBanned",
          "new_api": "SetSockOpt",
          "old_text": "m_banman->IsBanned(addr)",
          "new_text": "sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on))",
          "old_line_content": "    bool banned = m_banman && m_banman->IsBanned(addr);",
          "new_line_content": "    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": "NetPermissions::HasFlag(permission_flags, NetPermissionFlags::NoBan)",
          "new_api": "ToString",
          "old_text": "NetPermissions::HasFlag(permission_flags, NetPermissionFlags::NoBan)",
          "new_text": "LogPrint(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n                 addr.ToString())",
          "old_line_content": "    if (!NetPermissions::HasFlag(permission_flags, NetPermissionFlags::NoBan) && banned)",
          "new_line_content": "        LogPrint(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": "NetPermissions::HasFlag(permission_flags, NetPermissionFlags::NoBan)",
          "new_api": "ToString",
          "old_text": "NetPermissions::HasFlag(permission_flags, NetPermissionFlags::NoBan)",
          "new_text": "addr.ToString()",
          "old_line_content": "    if (!NetPermissions::HasFlag(permission_flags, NetPermissionFlags::NoBan) && nInbound + 1 >= nMaxInbound && discouraged)",
          "new_line_content": "        LogPrint(BCLog::NET, \"connection from %s dropped (banned)\\n\", addr.ToString());",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": "AttemptToEvictConnection",
          "new_api": "ToString",
          "old_text": "AttemptToEvictConnection()",
          "new_text": "addr.ToString()",
          "old_line_content": "        if (!AttemptToEvictConnection()) {",
          "new_line_content": "        LogPrint(BCLog::NET, \"connection from %s dropped (discouraged)\\n\", addr.ToString());",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": "Write",
          "new_api": "LogPrint",
          "old_text": "GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize()",
          "new_text": "LogPrint(BCLog::NET, \"failed to find an eviction candidate - connection dropped (full)\\n\")",
          "old_line_content": "    uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();",
          "new_line_content": "            LogPrint(BCLog::NET, \"failed to find an eviction candidate - connection dropped (full)\\n\");",
          "content_same": false
        },
        {
          "line": 1022,
          "old_api": "std::move(sock)",
          "new_api": "NetPermissions::HasFlag(permission_flags, NetPermissionFlags::BloomFilter)",
          "old_text": "std::move(sock)",
          "new_text": "NetPermissions::HasFlag(permission_flags, NetPermissionFlags::BloomFilter)",
          "old_line_content": "                             std::move(sock),",
          "new_line_content": "    if (NetPermissions::HasFlag(permission_flags, NetPermissionFlags::BloomFilter)) {",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": "LOCK",
          "new_api": "AddRef",
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": "pnode->AddRef()",
          "old_line_content": "        LOCK(m_nodes_mutex);",
          "new_line_content": "    pnode->AddRef();",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": "push_back",
          "new_api": "InitializeNode",
          "old_text": "m_nodes.push_back(pnode)",
          "new_text": "m_msgproc->InitializeNode(*pnode, nodeServices)",
          "old_line_content": "        m_nodes.push_back(pnode);",
          "new_line_content": "    m_msgproc->InitializeNode(*pnode, nodeServices);",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": "GetId",
          "new_api": "LOCK",
          "old_text": "pnode->GetId()",
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "                    LogPrint(BCLog::NET, \"Network not active, dropping peer=%d\\n\", pnode->GetId());",
          "new_line_content": "        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1112,
          "old_api": "CloseSocketDisconnect",
          "new_api": "end",
          "old_text": "pnode->CloseSocketDisconnect()",
          "new_text": "m_nodes.end()",
          "old_line_content": "                pnode->CloseSocketDisconnect();",
          "new_line_content": "                m_nodes.erase(remove(m_nodes.begin(), m_nodes.end(), pnode), m_nodes.end());",
          "content_same": false
        },
        {
          "line": 1144,
          "old_api": "NotifyNumConnectionsChanged",
          "new_api": "LOCK",
          "old_text": "m_client_interface->NotifyNumConnectionsChanged(nodes_size)",
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "            m_client_interface->NotifyNumConnectionsChanged(nodes_size);",
          "new_line_content": "        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1164,
          "old_api": "count",
          "new_api": "GetTime<std::chrono::seconds>()",
          "old_text": "last_send.count()",
          "new_text": "GetTime<std::chrono::seconds>()",
          "old_line_content": "    if (last_recv.count() == 0 || last_send.count() == 0) {",
          "new_line_content": "    const auto now{GetTime<std::chrono::seconds>()};",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": "GetId",
          "new_api": "load",
          "old_text": "node.GetId()",
          "new_text": "node.m_last_send.load()",
          "old_line_content": "        LogPrint(BCLog::NET, \"socket no message in first %i seconds, %d %d peer=%d\\n\", count_seconds(m_peer_connect_timeout), last_recv.count() != 0, last_send.count() != 0, node.GetId());",
          "new_line_content": "    const auto last_send{node.m_last_send.load()};",
          "content_same": false
        },
        {
          "line": 1170,
          "old_api": "GetId",
          "new_api": "count",
          "old_text": "node.GetId()",
          "new_text": "last_send.count()",
          "old_line_content": "        LogPrint(BCLog::NET, \"socket sending timeout: %is peer=%d\\n\", count_seconds(now - last_send), node.GetId());",
          "new_line_content": "    if (last_recv.count() == 0 || last_send.count() == 0) {",
          "content_same": false
        },
        {
          "line": 1247,
          "old_api": "Nodes",
          "new_api": "std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS)",
          "old_text": "snap.Nodes()",
          "new_text": "std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS)",
          "old_line_content": "        events_per_sock = GenerateWaitSockets(snap.Nodes());",
          "new_line_content": "        const auto timeout = std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS);",
          "content_same": false
        },
        {
          "line": 1263,
          "old_api": "AssertLockNotHeld",
          "new_api": "SocketHandlerListening",
          "old_text": "AssertLockNotHeld(m_total_bytes_sent_mutex)",
          "new_text": "SocketHandlerListening(events_per_sock)",
          "old_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "new_line_content": "    SocketHandlerListening(events_per_sock);",
          "content_same": false
        },
        {
          "line": 1303,
          "old_api": "CloseSocketDisconnect",
          "new_api": "Recv",
          "old_text": "pnode->CloseSocketDisconnect()",
          "new_text": "pnode->m_sock->Recv(pchBuf, sizeof(pchBuf), MSG_DONTWAIT)",
          "old_line_content": "                    pnode->CloseSocketDisconnect();",
          "new_line_content": "                nBytes = pnode->m_sock->Recv(pchBuf, sizeof(pchBuf), MSG_DONTWAIT);",
          "content_same": false
        },
        {
          "line": 1339,
          "old_api": "CloseSocketDisconnect",
          "new_api": "WSAGetLastError",
          "old_text": "pnode->CloseSocketDisconnect()",
          "new_text": "WSAGetLastError()",
          "old_line_content": "                    pnode->CloseSocketDisconnect();",
          "new_line_content": "                int nErr = WSAGetLastError();",
          "content_same": false
        },
        {
          "line": 1375,
          "old_api": "NotifyNumConnectionsChanged",
          "new_api": "AssertLockNotHeld",
          "old_text": "NotifyNumConnectionsChanged()",
          "new_text": "AssertLockNotHeld(m_total_bytes_sent_mutex)",
          "old_line_content": "        NotifyNumConnectionsChanged();",
          "new_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "content_same": false
        },
        {
          "line": 1400,
          "old_api": "size",
          "new_api": "end",
          "old_text": "seeds.size()",
          "new_text": "seeds.end()",
          "old_line_content": "        seeds_right_now = seeds.size();",
          "new_line_content": "    Shuffle(seeds.begin(), seeds.end(), rng);",
          "content_same": false
        },
        {
          "line": 1433,
          "old_api": "std::min(DNSSEEDS_DELAY_FEW_PEERS, to_wait)",
          "new_api": "count",
          "old_text": "std::min(DNSSEEDS_DELAY_FEW_PEERS, to_wait)",
          "new_text": "seeds_wait_time.count()",
          "old_line_content": "                    std::chrono::seconds w = std::min(DNSSEEDS_DELAY_FEW_PEERS, to_wait);",
          "new_line_content": "                LogPrintf(\"Waiting %d seconds before querying DNS seeds.\\n\", seeds_wait_time.count());",
          "content_same": false
        },
        {
          "line": 1439,
          "old_api": "LOCK",
          "new_api": "std::min(DNSSEEDS_DELAY_FEW_PEERS, to_wait)",
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": "std::min(DNSSEEDS_DELAY_FEW_PEERS, to_wait)",
          "old_line_content": "                        LOCK(m_nodes_mutex);",
          "new_line_content": "                    std::chrono::seconds w = std::min(DNSSEEDS_DELAY_FEW_PEERS, to_wait);",
          "content_same": false
        },
        {
          "line": 1447,
          "old_api": "LogPrintf",
          "new_api": "IsFullOutboundConn",
          "old_text": "LogPrintf(\"P2P peers available. Finished DNS seeding.\\n\")",
          "new_text": "pnode->IsFullOutboundConn()",
          "old_line_content": "                            LogPrintf(\"P2P peers available. Finished DNS seeding.\\n\");",
          "new_line_content": "                            if (pnode->fSuccessfullyConnected && pnode->IsFullOutboundConn()) ++nRelevant;",
          "content_same": false
        },
        {
          "line": 1469,
          "old_api": "AddAddrFetch",
          "new_api": "sleep_for",
          "old_text": "AddAddrFetch(seed)",
          "new_text": "interruptNet.sleep_for(std::chrono::seconds{1})",
          "old_line_content": "            AddAddrFetch(seed);",
          "new_line_content": "                if (!interruptNet.sleep_for(std::chrono::seconds{1})) return;",
          "content_same": false
        },
        {
          "line": 1473,
          "old_api": "GetDesirableServiceFlags",
          "new_api": "LogPrintf",
          "old_text": "GetDesirableServiceFlags(NODE_NONE)",
          "new_text": "LogPrintf(\"Loading addresses from DNS seed %s\\n\", seed)",
          "old_line_content": "            ServiceFlags requiredServiceBits = GetDesirableServiceFlags(NODE_NONE);",
          "new_line_content": "        LogPrintf(\"Loading addresses from DNS seed %s\\n\", seed);",
          "content_same": false
        },
        {
          "line": 1474,
          "old_api": "strprintf",
          "new_api": "HaveNameProxy",
          "old_text": "strprintf(\"x%x.%s\", requiredServiceBits, seed)",
          "new_text": "HaveNameProxy()",
          "old_line_content": "            std::string host = strprintf(\"x%x.%s\", requiredServiceBits, seed);",
          "new_line_content": "        if (HaveNameProxy()) {",
          "content_same": false
        },
        {
          "line": 1480,
          "old_api": "LookupHost",
          "new_api": "strprintf",
          "old_text": "LookupHost(host, vIPs, nMaxIPs, true)",
          "new_text": "strprintf(\"x%x.%s\", requiredServiceBits, seed)",
          "old_line_content": "            if (LookupHost(host, vIPs, nMaxIPs, true)) {",
          "new_line_content": "            std::string host = strprintf(\"x%x.%s\", requiredServiceBits, seed);",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": "GetDefaultPort",
          "new_api": "SetInternal",
          "old_text": "Params().GetDefaultPort()",
          "new_text": "resolveSource.SetInternal(host)",
          "old_line_content": "                    CAddress addr = CAddress(CService(ip, Params().GetDefaultPort()), requiredServiceBits);",
          "new_line_content": "            if (!resolveSource.SetInternal(host)) {",
          "content_same": false
        },
        {
          "line": 1522,
          "old_api": "c_str",
          "new_api": "front",
          "old_text": "strDest.c_str()",
          "new_text": "m_addr_fetches.front()",
          "old_line_content": "        OpenNetworkConnection(addr, false, &grant, strDest.c_str(), ConnectionType::ADDR_FETCH);",
          "new_line_content": "        strDest = m_addr_fetches.front();",
          "content_same": false
        },
        {
          "line": 1616,
          "old_api": "GetTime<std::chrono::microseconds>()",
          "new_api": "std::chrono::milliseconds(500)",
          "old_text": "GetTime<std::chrono::microseconds>()",
          "new_text": "std::chrono::milliseconds(500)",
          "old_line_content": "    auto start = GetTime<std::chrono::microseconds>();",
          "new_line_content": "            if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))",
          "content_same": false
        },
        {
          "line": 1622,
          "old_api": "GetBoolArg",
          "new_api": "GetTime<std::chrono::microseconds>()",
          "old_text": "gArgs.GetBoolArg(\"-fixedseeds\", DEFAULT_FIXEDSEEDS)",
          "new_text": "GetTime<std::chrono::microseconds>()",
          "old_line_content": "    bool add_fixed_seeds = gArgs.GetBoolArg(\"-fixedseeds\", DEFAULT_FIXEDSEEDS);",
          "new_line_content": "    auto start = GetTime<std::chrono::microseconds>();",
          "content_same": false
        },
        {
          "line": 1625,
          "old_api": "LogPrintf",
          "new_api": "GetExponentialRand",
          "old_text": "LogPrintf(\"Fixed seeds are disabled\\n\")",
          "new_text": "GetExponentialRand(start, FEELER_INTERVAL)",
          "old_line_content": "        LogPrintf(\"Fixed seeds are disabled\\n\");",
          "new_line_content": "    auto next_feeler = GetExponentialRand(start, FEELER_INTERVAL);",
          "content_same": false
        },
        {
          "line": 1655,
          "old_api": "empty",
          "new_api": "LogPrintf",
          "old_text": "m_added_nodes.empty()",
          "new_text": "LogPrintf(\"Adding fixed seeds as 60 seconds have passed and addrman is empty for at least one reachable network\\n\")",
          "old_line_content": "                if (m_addr_fetches.empty() && m_added_nodes.empty()) {",
          "new_line_content": "                LogPrintf(\"Adding fixed seeds as 60 seconds have passed and addrman is empty for at least one reachable network\\n\");",
          "content_same": false
        },
        {
          "line": 1676,
          "old_api": "size",
          "new_api": "GetNetwork",
          "old_text": "seed_addrs.size()",
          "new_text": "addr.GetNetwork()",
          "old_line_content": "                LogPrintf(\"Added %d fixed seeds from reachable networks.\\n\", seed_addrs.size());",
          "new_line_content": "                                                [&fixed_seed_networks](const CAddress& addr) { return fixed_seed_networks.count(addr.GetNetwork()) == 0; }),",
          "content_same": false
        },
        {
          "line": 1715,
          "old_api": "GetTime<std::chrono::microseconds>()",
          "new_api": "GetGroup",
          "old_text": "GetTime<std::chrono::microseconds>()",
          "new_text": "m_netgroupman.GetGroup(pnode->addr)",
          "old_line_content": "        auto now = GetTime<std::chrono::microseconds>();",
          "new_line_content": "                        setConnected.insert(m_netgroupman.GetGroup(pnode->addr));",
          "content_same": false
        },
        {
          "line": 1778,
          "old_api": "empty",
          "new_api": "ResolveCollisions",
          "old_text": "m_anchors.empty()",
          "new_text": "addrman.ResolveCollisions()",
          "old_line_content": "            if (anchor && !m_anchors.empty()) {",
          "new_line_content": "        addrman.ResolveCollisions();",
          "content_same": false
        },
        {
          "line": 1780,
          "old_api": "pop_back",
          "new_api": "NodeClock::now()",
          "old_text": "m_anchors.pop_back()",
          "new_text": "NodeClock::now()",
          "old_line_content": "                m_anchors.pop_back();",
          "new_line_content": "        const auto current_time{NodeClock::now()};",
          "content_same": false
        },
        {
          "line": 1785,
          "old_api": "ToString",
          "new_api": "back",
          "old_text": "addrConnect.ToString()",
          "new_text": "m_anchors.back()",
          "old_line_content": "                LogPrint(BCLog::NET, \"Trying to make an anchor connection to %s\\n\", addrConnect.ToString());",
          "new_line_content": "                const CAddress addr = m_anchors.back();",
          "content_same": false
        },
        {
          "line": 1808,
          "old_api": "AlreadyConnectedToAddress",
          "new_api": "SelectTriedCollision",
          "old_text": "AlreadyConnectedToAddress(addr)",
          "new_text": "addrman.SelectTriedCollision()",
          "old_line_content": "                } else if (AlreadyConnectedToAddress(addr)) {",
          "new_line_content": "                std::tie(addr, addr_last_try) = addrman.SelectTriedCollision();",
          "content_same": false
        },
        {
          "line": 1814,
          "old_api": "Good",
          "new_api": "AlreadyConnectedToAddress",
          "old_text": "addrman.Good(addr)",
          "new_text": "AlreadyConnectedToAddress(addr)",
          "old_line_content": "                    addrman.Good(addr);",
          "new_line_content": "                } else if (AlreadyConnectedToAddress(addr)) {",
          "content_same": false
        },
        {
          "line": 1820,
          "old_api": "Select",
          "new_api": "Good",
          "old_text": "addrman.Select()",
          "new_text": "addrman.Good(addr)",
          "old_line_content": "                std::tie(addr, addr_last_try) = addrman.Select();",
          "new_line_content": "                    addrman.Good(addr);",
          "content_same": false
        },
        {
          "line": 1865,
          "old_api": "ToString",
          "new_api": "IsValid",
          "old_text": "addrConnect.ToString()",
          "new_text": "addrConnect.IsValid()",
          "old_line_content": "                LogPrint(BCLog::NET, \"Making feeler connection to %s\\n\", addrConnect.ToString());",
          "new_line_content": "        if (addrConnect.IsValid()) {",
          "content_same": false
        },
        {
          "line": 1868,
          "old_api": "std::min(nMaxConnections - 1, 2)",
          "new_api": "rng.rand_uniform_duration<CThreadInterrupt::Clock>(FEELER_SLEEP_WINDOW)",
          "old_text": "std::min(nMaxConnections - 1, 2)",
          "new_text": "rng.rand_uniform_duration<CThreadInterrupt::Clock>(FEELER_SLEEP_WINDOW)",
          "old_line_content": "            OpenNetworkConnection(addrConnect, (int)setConnected.size() >= std::min(nMaxConnections - 1, 2), &grant, nullptr, conn_type);",
          "new_line_content": "                if (!interruptNet.sleep_for(rng.rand_uniform_duration<CThreadInterrupt::Clock>(FEELER_SLEEP_WINDOW))) {",
          "content_same": false
        },
        {
          "line": 1908,
          "old_api": "empty",
          "new_api": "LOCK",
          "old_text": "addrName.empty()",
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "            if (!addrName.empty()) {",
          "new_line_content": "        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1915,
          "old_api": "GetDefaultPort",
          "new_api": "static_cast<const CService&>(pnode->addr)",
          "old_text": "Params().GetDefaultPort(strAddNode)",
          "new_text": "static_cast<const CService&>(pnode->addr)",
          "old_line_content": "        CService service(LookupNumeric(strAddNode, Params().GetDefaultPort(strAddNode)));",
          "new_line_content": "                mapConnectedByName[std::move(addrName)] = std::make_pair(pnode->IsInboundConn(), static_cast<const CService&>(pnode->addr));",
          "content_same": false
        },
        {
          "line": 1934,
          "old_api": "std::move(addedNode)",
          "new_api": "end",
          "old_text": "std::move(addedNode)",
          "new_text": "mapConnectedByName.end()",
          "old_line_content": "        ret.emplace_back(std::move(addedNode));",
          "new_line_content": "            if (it != mapConnectedByName.end()) {",
          "content_same": false
        },
        {
          "line": 1963,
          "old_api": "std::chrono::seconds(tried ? 60 : 2)",
          "new_api": "c_str",
          "old_text": "std::chrono::seconds(tried ? 60 : 2)",
          "new_text": "info.strAddedNode.c_str()",
          "old_line_content": "        if (!interruptNet.sleep_for(std::chrono::seconds(tried ? 60 : 2)))",
          "new_line_content": "                OpenNetworkConnection(addr, false, &grant, info.strAddedNode.c_str(), ConnectionType::MANUAL);",
          "content_same": false
        },
        {
          "line": 1990,
          "old_api": "ConnectNode",
          "new_api": "AlreadyConnectedToAddress",
          "old_text": "ConnectNode(addrConnect, pszDest, fCountFailure, conn_type)",
          "new_text": "AlreadyConnectedToAddress(addrConnect)",
          "old_line_content": "    CNode* pnode = ConnectNode(addrConnect, pszDest, fCountFailure, conn_type);",
          "new_line_content": "        if (IsLocal(addrConnect) || banned_or_discouraged || AlreadyConnectedToAddress(addrConnect)) {",
          "content_same": false
        },
        {
          "line": 2063,
          "old_api": "sleep_for",
          "new_api": "Listen",
          "old_text": "interruptNet.sleep_for(err_wait)",
          "new_text": "m_i2p_sam_session->Listen(conn)",
          "old_line_content": "            interruptNet.sleep_for(err_wait);",
          "new_line_content": "        if (!m_i2p_sam_session->Listen(conn)) {",
          "content_same": false
        },
        {
          "line": 2101,
          "old_api": "WSAGetLastError",
          "new_api": "LogPrintLevel",
          "old_text": "WSAGetLastError()",
          "new_text": "LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original)",
          "old_line_content": "        strError = strprintf(Untranslated(\"Couldn't open socket for incoming connections (socket returned error %s)\"), NetworkErrorString(WSAGetLastError()));",
          "new_line_content": "        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);",
          "content_same": false
        },
        {
          "line": 2108,
          "old_api": "SetSockOpt",
          "new_api": "LogPrintLevel",
          "old_text": "sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, (sockopt_arg_type)&nOne, sizeof(int))",
          "new_text": "LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original)",
          "old_line_content": "    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, (sockopt_arg_type)&nOne, sizeof(int)) == SOCKET_ERROR) {",
          "new_line_content": "        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);",
          "content_same": false
        },
        {
          "line": 2115,
          "old_api": "IsIPv6",
          "new_api": "WSAGetLastError",
          "old_text": "addrBind.IsIPv6()",
          "new_text": "WSAGetLastError()",
          "old_line_content": "    if (addrBind.IsIPv6()) {",
          "new_line_content": "        strError = strprintf(Untranslated(\"Error setting SO_REUSEADDR on socket: %s, continuing anyway\"), NetworkErrorString(WSAGetLastError()));",
          "content_same": false
        },
        {
          "line": 2124,
          "old_api": "SetSockOpt",
          "new_api": "WSAGetLastError",
          "old_text": "sock->SetSockOpt(IPPROTO_IPV6, IPV6_PROTECTION_LEVEL, (const char*)&nProtLevel, sizeof(int))",
          "new_text": "WSAGetLastError()",
          "old_line_content": "        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_PROTECTION_LEVEL, (const char*)&nProtLevel, sizeof(int)) == SOCKET_ERROR) {",
          "new_line_content": "            strError = strprintf(Untranslated(\"Error setting IPV6_V6ONLY on socket: %s, continuing anyway\"), NetworkErrorString(WSAGetLastError()));",
          "content_same": false
        },
        {
          "line": 2125,
          "old_api": "WSAGetLastError",
          "new_api": "LogPrintf",
          "old_text": "WSAGetLastError()",
          "new_text": "LogPrintf(\"%s\\n\", strError.original)",
          "old_line_content": "            strError = strprintf(Untranslated(\"Error setting IPV6_PROTECTION_LEVEL on socket: %s, continuing anyway\"), NetworkErrorString(WSAGetLastError()));",
          "new_line_content": "            LogPrintf(\"%s\\n\", strError.original);",
          "content_same": false
        },
        {
          "line": 2131,
          "old_api": "reinterpret_cast<struct sockaddr*>(&sockaddr)",
          "new_api": "WSAGetLastError",
          "old_text": "reinterpret_cast<struct sockaddr*>(&sockaddr)",
          "new_text": "WSAGetLastError()",
          "old_line_content": "    if (sock->Bind(reinterpret_cast<struct sockaddr*>(&sockaddr), len) == SOCKET_ERROR) {",
          "new_line_content": "            strError = strprintf(Untranslated(\"Error setting IPV6_PROTECTION_LEVEL on socket: %s, continuing anyway\"), NetworkErrorString(WSAGetLastError()));",
          "content_same": false
        },
        {
          "line": 2132,
          "old_api": "WSAGetLastError",
          "new_api": "LogPrintf",
          "old_text": "WSAGetLastError()",
          "new_text": "LogPrintf(\"%s\\n\", strError.original)",
          "old_line_content": "        int nErr = WSAGetLastError();",
          "new_line_content": "            LogPrintf(\"%s\\n\", strError.original);",
          "content_same": false
        },
        {
          "line": 2137,
          "old_api": "LogPrintLevel",
          "new_api": "reinterpret_cast<struct sockaddr*>(&sockaddr)",
          "old_text": "LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original)",
          "new_text": "reinterpret_cast<struct sockaddr*>(&sockaddr)",
          "old_line_content": "        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);",
          "new_line_content": "    if (sock->Bind(reinterpret_cast<struct sockaddr*>(&sockaddr), len) == SOCKET_ERROR) {",
          "content_same": false
        },
        {
          "line": 2143,
          "old_api": "Listen",
          "new_api": "LogPrintLevel",
          "old_text": "sock->Listen(SOMAXCONN)",
          "new_text": "LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original)",
          "old_line_content": "    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR)",
          "new_line_content": "        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);",
          "content_same": false
        },
        {
          "line": 2146,
          "old_api": "LogPrintLevel",
          "new_api": "ToString",
          "old_text": "LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original)",
          "new_text": "addrBind.ToString()",
          "old_line_content": "        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);",
          "new_line_content": "    LogPrintf(\"Bound to %s\\n\", addrBind.ToString());",
          "content_same": false
        },
        {
          "line": 2183,
          "old_api": "strcmp",
          "new_api": "getifaddrs",
          "old_text": "strcmp(ifa->ifa_name, \"lo\")",
          "new_text": "getifaddrs(&myaddrs)",
          "old_line_content": "            if (strcmp(ifa->ifa_name, \"lo\") == 0) continue;",
          "new_line_content": "    if (getifaddrs(&myaddrs) == 0)",
          "content_same": false
        },
        {
          "line": 2189,
          "old_api": "AddLocal",
          "new_api": "strcmp",
          "old_text": "AddLocal(addr, LOCAL_IF)",
          "new_text": "strcmp(ifa->ifa_name, \"lo\")",
          "old_line_content": "                if (AddLocal(addr, LOCAL_IF))",
          "new_line_content": "            if (strcmp(ifa->ifa_name, \"lo\") == 0) continue;",
          "content_same": false
        },
        {
          "line": 2190,
          "old_api": "ToString",
          "new_api": "strcmp",
          "old_text": "addr.ToString()",
          "new_text": "strcmp(ifa->ifa_name, \"lo0\")",
          "old_line_content": "                    LogPrintf(\"%s: IPv4 %s: %s\\n\", __func__, ifa->ifa_name, addr.ToString());",
          "new_line_content": "            if (strcmp(ifa->ifa_name, \"lo0\") == 0) continue;",
          "content_same": false
        },
        {
          "line": 2196,
          "old_api": "AddLocal",
          "new_api": "ToString",
          "old_text": "AddLocal(addr, LOCAL_IF)",
          "new_text": "addr.ToString()",
          "old_line_content": "                if (AddLocal(addr, LOCAL_IF))",
          "new_line_content": "                    LogPrintf(\"%s: IPv4 %s: %s\\n\", __func__, ifa->ifa_name, addr.ToString());",
          "content_same": false
        },
        {
          "line": 2236,
          "old_api": "fetch_add",
          "new_api": "Init",
          "old_text": "nLastNodeId.fetch_add(1, std::memory_order_relaxed)",
          "new_text": "Init(connOptions)",
          "old_line_content": "    return nLastNodeId.fetch_add(1, std::memory_order_relaxed);",
          "new_line_content": "    Init(connOptions);",
          "content_same": false
        },
        {
          "line": 2242,
          "old_api": "MaybeFlipIPv6toCJDNS",
          "new_api": "fetch_add",
          "old_text": "MaybeFlipIPv6toCJDNS(addr_)",
          "new_text": "nLastNodeId.fetch_add(1, std::memory_order_relaxed)",
          "old_line_content": "    const CService addr{MaybeFlipIPv6toCJDNS(addr_)};",
          "new_line_content": "    return nLastNodeId.fetch_add(1, std::memory_order_relaxed);",
          "content_same": false
        },
        {
          "line": 2253,
          "old_api": "AddLocal",
          "new_api": "ThreadSafeMessageBox",
          "old_text": "AddLocal(addr, LOCAL_BIND)",
          "new_text": "m_client_interface->ThreadSafeMessageBox(strError, \"\", CClientUIInterface::MSG_ERROR)",
          "old_line_content": "        AddLocal(addr, LOCAL_BIND);",
          "new_line_content": "            m_client_interface->ThreadSafeMessageBox(strError, \"\", CClientUIInterface::MSG_ERROR);",
          "content_same": false
        },
        {
          "line": 2275,
          "old_api": "GetListenPort",
          "new_api": "Bind",
          "old_text": "GetListenPort()",
          "new_text": "Bind(addr_bind, BF_DONT_ADVERTISE, NetPermissionFlags::None)",
          "old_line_content": "        fBound |= Bind(CService(inaddr6_any, GetListenPort()), BF_NONE, NetPermissionFlags::None);",
          "new_line_content": "        fBound |= Bind(addr_bind, BF_DONT_ADVERTISE, NetPermissionFlags::None);",
          "content_same": false
        },
        {
          "line": 2289,
          "old_api": "_",
          "new_api": "AssertLockNotHeld",
          "old_text": "_(\"Failed to listen on any port. Use -listen=0 if you want this.\")",
          "new_text": "AssertLockNotHeld(m_total_bytes_sent_mutex)",
          "old_line_content": "                _(\"Failed to listen on any port. Use -listen=0 if you want this.\"),",
          "new_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "content_same": false
        },
        {
          "line": 2302,
          "old_api": "AddAddrFetch",
          "new_api": "GetProxy",
          "old_text": "AddAddrFetch(strDest)",
          "new_text": "GetProxy(NET_I2P, i2p_sam)",
          "old_line_content": "        AddAddrFetch(strDest);",
          "new_line_content": "    if (GetProxy(NET_I2P, i2p_sam) && connOptions.m_i2p_accept_incoming) {",
          "content_same": false
        },
        {
          "line": 2308,
          "old_api": "size",
          "new_api": "AddAddrFetch",
          "old_text": "m_anchors.size()",
          "new_text": "AddAddrFetch(strDest)",
          "old_line_content": "        if (m_anchors.size() > MAX_BLOCK_RELAY_ONLY_ANCHORS) {",
          "new_line_content": "        AddAddrFetch(strDest);",
          "content_same": false
        },
        {
          "line": 2315,
          "old_api": "_",
          "new_api": "resize",
          "old_text": "_(\"Starting network threads…\").t",
          "new_text": "m_anchors.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS)",
          "old_line_content": "        m_client_interface->InitMessage(_(\"Starting network threads…\").translated);",
          "new_line_content": "            m_anchors.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);",
          "content_same": false
        },
        {
          "line": 2332,
          "old_api": "sert",
          "new_api": "d::make_unique<CSemaphore>(nMaxAddnode);",
          "old_text": "sert(m_msgproc);\n",
          "new_text": "d::make_unique<CSemaphore>(nMaxAddnode);\n",
          "old_line_content": "    assert(m_msgproc);",
          "new_line_content": "        semAddnode = std::make_unique<CSemaphore>(nMaxAddnode);",
          "content_same": false
        },
        {
          "line": 2338,
          "old_api": "CK",
          "new_api": "sert",
          "old_text": "CK(mutexMsgProc);\n",
          "new_text": "sert(m_msgproc);\n",
          "old_line_content": "        LOCK(mutexMsgProc);",
          "new_line_content": "    assert(m_msgproc);",
          "content_same": false
        },
        {
          "line": 2351,
          "old_api": "readOpenAddedConnections",
          "new_api": "GetBoolArg",
          "old_text": "readOpenAddedConnections(); ",
          "new_text": "rgs.GetBoolArg(\"-dnsseed\", DEFAULT_DNSSEED))\n",
          "old_line_content": "    threadOpenAddedConnections = std::thread(&util::TraceThread, \"addcon\", [this] { ThreadOpenAddedConnections(); });",
          "new_line_content": "    if (!gArgs.GetBoolArg(\"-dnsseed\", DEFAULT_DNSSEED))",
          "content_same": false
        },
        {
          "line": 2361,
          "old_api": "empty",
          "new_api": "ThreadSafeMessageBox",
          "old_text": "nnOptions.m_specified_outgoing.empty()) ",
          "new_text": "client_interface->ThreadSafeMessageBox(\n                _(\"Cannot provide specific connections and have addrman find outgoing connections at the same time.\"),\n                \"\", CClientUIInterface::MSG_ERROR);\n",
          "old_line_content": "    if (connOptions.m_use_addrman_outgoing || !connOptions.m_specified_outgoing.empty()) {",
          "new_line_content": "            m_client_interface->ThreadSafeMessageBox(",
          "content_same": false
        },
        {
          "line": 2362,
          "old_api": "d::thread(\n            &util::TraceThread, \"opencon\",\n            [this, connect = connOptions.m_specified_outgoing] { ThreadOpenConnections(connect); });",
          "new_api": "\"Cannot provide specific connections and have addrman find outgoing connections at the same time.\"),",
          "old_text": "d::thread(\n            &util::TraceThread, \"opencon\",\n            [this, connect = connOptions.m_specified_outgoing] { ThreadOpenConnections(connect); });\n",
          "new_text": "\"Cannot provide specific connections and have addrman find outgoing connections at the same time.\"),\n",
          "old_line_content": "        threadOpenConnections = std::thread(",
          "new_line_content": "                _(\"Cannot provide specific connections and have addrman find outgoing connections at the same time.\"),",
          "content_same": false
        },
        {
          "line": 2368,
          "old_api": "readMessageHandler",
          "new_api": "d::thread(\n            &util::TraceThread, \"opencon\",\n            [this, connect = connOptions.m_specified_outgoing] { ThreadOpenConnections(connect); });",
          "old_text": "readMessageHandler(); ",
          "new_text": "d::thread(\n            &util::TraceThread, \"opencon\",\n            [this, connect = connOptions.m_specified_outgoing] { ThreadOpenConnections(connect); });\n",
          "old_line_content": "    threadMessageHandler = std::thread(&util::TraceThread, \"msghand\", [this] { ThreadMessageHandler(); });",
          "new_line_content": "        threadOpenConnections = std::thread(",
          "content_same": false
        },
        {
          "line": 2405,
          "old_api": "terruptSocks5",
          "new_api": "CK",
          "old_text": "terruptSocks5(true);\n",
          "new_text": "CK(mutexMsgProc);\n",
          "old_line_content": "    InterruptSocks5(true);",
          "new_line_content": "        LOCK(mutexMsgProc);",
          "content_same": false
        },
        {
          "line": 2428,
          "old_api": "join",
          "new_api": "joinable",
          "old_text": "readOpenConnections.join();\n",
          "new_text": "readI2PAcceptIncoming.joinable()) ",
          "old_line_content": "        threadOpenConnections.join();",
          "new_line_content": "    if (threadI2PAcceptIncoming.joinable()) {",
          "content_same": false
        },
        {
          "line": 2429,
          "old_api": "joinable",
          "new_api": "join",
          "old_text": "readOpenAddedConnections.joinable())\n",
          "new_text": "readI2PAcceptIncoming.join();\n",
          "old_line_content": "    if (threadOpenAddedConnections.joinable())",
          "new_line_content": "        threadI2PAcceptIncoming.join();",
          "content_same": false
        },
        {
          "line": 2440,
          "old_api": "mpAddresses",
          "new_api": "join",
          "old_text": "mpAddresses();\n",
          "new_text": "readSocketHandler.join();\n",
          "old_line_content": "        DumpAddresses();",
          "new_line_content": "        threadSocketHandler.join();",
          "content_same": false
        },
        {
          "line": 2446,
          "old_api": "size",
          "new_api": "mpAddresses",
          "old_text": "chors_to_dump.size() >",
          "new_text": "mpAddresses();\n",
          "old_line_content": "            if (anchors_to_dump.size() > MAX_BLOCK_RELAY_ONLY_ANCHORS) {",
          "new_line_content": "        DumpAddresses();",
          "content_same": false
        },
        {
          "line": 2455,
          "old_api": "swap",
          "new_api": "GetDataDirNet",
          "old_text": "des.swap(m_nodes));",
          "new_text": "rgs.GetDataDirNet() /",
          "old_line_content": "    WITH_LOCK(m_nodes_mutex, nodes.swap(m_nodes));",
          "new_line_content": "            DumpAnchors(gArgs.GetDataDirNet() / ANCHORS_DATABASE_FILENAME, anchors_to_dump);",
          "content_same": false
        },
        {
          "line": 2464,
          "old_api": "clear",
          "new_api": "leteNode",
          "old_text": "nodes_disconnected.clear();\n",
          "new_text": "leteNode(pnode);\n",
          "old_line_content": "    m_nodes_disconnected.clear();",
          "new_line_content": "        DeleteNode(pnode);",
          "content_same": false
        },
        {
          "line": 2472,
          "old_api": "sert",
          "new_api": "reset",
          "old_text": "sert(pnode);\n",
          "new_text": "mOutbound.reset();\n",
          "old_line_content": "    assert(pnode);",
          "new_line_content": "    semOutbound.reset();",
          "content_same": false
        },
        {
          "line": 2473,
          "old_api": "FinalizeNode",
          "new_api": "reset",
          "old_text": "msgproc->FinalizeNode(*pnode);\n",
          "new_text": "mAddnode.reset();\n",
          "old_line_content": "    m_msgproc->FinalizeNode(*pnode);",
          "new_line_content": "    semAddnode.reset();",
          "content_same": false
        },
        {
          "line": 2479,
          "old_api": "terrupt",
          "new_api": "FinalizeNode",
          "old_text": "terrupt();\n",
          "new_text": "msgproc->FinalizeNode(*pnode);\n",
          "old_line_content": "    Interrupt();",
          "new_line_content": "    m_msgproc->FinalizeNode(*pnode);",
          "content_same": false
        },
        {
          "line": 2485,
          "old_api": "GetAddr",
          "new_api": "terrupt",
          "old_text": "drman.GetAddr(max_addresses, max_pct, network);\n",
          "new_text": "terrupt();\n",
          "old_line_content": "    std::vector<CAddress> addresses = addrman.GetAddr(max_addresses, max_pct, network);",
          "new_line_content": "    Interrupt();",
          "content_same": false
        },
        {
          "line": 2502,
          "old_api": "GetPort",
          "new_api": "GetAddrBytes",
          "old_text": "questor.addrBind.GetPort() :",
          "new_text": "questor.addrBind.GetAddrBytes();\n",
          "old_line_content": "        .Write(requestor.IsInboundConn() ? requestor.addrBind.GetPort() : 0)",
          "new_line_content": "    auto local_socket_bytes = requestor.addrBind.GetAddrBytes();",
          "content_same": false
        },
        {
          "line": 2504,
          "old_api": "tTime<std::chrono::microseconds>();",
          "new_api": "ConnectedThroughNetwork",
          "old_text": "tTime<std::chrono::microseconds>();\n",
          "new_text": "questor.ConnectedThroughNetwork())\n",
          "old_line_content": "    const auto current_time = GetTime<std::chrono::microseconds>();",
          "new_line_content": "        .Write(requestor.ConnectedThroughNetwork())",
          "content_same": false
        },
        {
          "line": 2505,
          "old_api": "emplace",
          "new_api": "size",
          "old_text": "addr_response_caches.emplace(cache_id, CachedAddrResponse{});\n",
          "new_text": "cal_socket_bytes.size())\n",
          "old_line_content": "    auto r = m_addr_response_caches.emplace(cache_id, CachedAddrResponse{});",
          "new_line_content": "        .Write(local_socket_bytes.data(), local_socket_bytes.size())",
          "content_same": false
        },
        {
          "line": 2508,
          "old_api": "tAddresses",
          "new_api": "GetPort",
          "old_text": "tAddresses(max_addresses, max_pct, /*network=*/std::nullopt);\n",
          "new_text": "questor.addrBind.GetPort() :",
          "old_line_content": "        cache_entry.m_addrs_response_cache = GetAddresses(max_addresses, max_pct, /*network=*/std::nullopt);",
          "new_line_content": "        .Write(requestor.IsInboundConn() ? requestor.addrBind.GetPort() : 0)",
          "content_same": false
        },
        {
          "line": 2551,
          "old_api": "CK",
          "new_api": "push_back",
          "old_text": "CK(m_added_nodes_mutex);\n",
          "new_text": "added_nodes.push_back(strNode);\n",
          "old_line_content": "    LOCK(m_added_nodes_mutex);",
          "new_line_content": "    m_added_nodes.push_back(strNode);",
          "content_same": false
        },
        {
          "line": 2569,
          "old_api": "IsInboundConn",
          "new_api": "CK",
          "old_text": "ode->IsInboundConn() ?",
          "new_text": "CK(m_nodes_mutex);\n",
          "old_line_content": "        if (flags & (pnode->IsInboundConn() ? ConnectionDirection::In : ConnectionDirection::Out)) {",
          "new_line_content": "    LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2585,
          "old_api": "GetMappedAS",
          "new_api": "clear",
          "old_text": "netgroupman.GetMappedAS(pnode->addr);\n",
          "new_text": "tats.clear();\n",
          "old_line_content": "        vstats.back().m_mapped_as = m_netgroupman.GetMappedAS(pnode->addr);",
          "new_line_content": "    vstats.clear();",
          "content_same": false
        },
        {
          "line": 2591,
          "old_api": "CK",
          "new_api": "GetMappedAS",
          "old_text": "CK(m_nodes_mutex);\n",
          "new_text": "netgroupman.GetMappedAS(pnode->addr);\n",
          "old_line_content": "    LOCK(m_nodes_mutex);",
          "new_line_content": "        vstats.back().m_mapped_as = m_netgroupman.GetMappedAS(pnode->addr);",
          "content_same": false
        },
        {
          "line": 2676,
          "old_api": "sertLockHeld",
          "new_api": "CK",
          "old_text": "sertLockHeld(m_total_bytes_sent_mutex);\n",
          "new_text": "CK(m_total_bytes_sent_mutex);\n",
          "old_line_content": "    AssertLockHeld(m_total_bytes_sent_mutex);",
          "new_line_content": "    LOCK(m_total_bytes_sent_mutex);",
          "content_same": false
        },
        {
          "line": 2691,
          "old_api": "sertLockNotHeld",
          "new_api": "tTime<std::chrono::seconds>();",
          "old_text": "sertLockNotHeld(m_total_bytes_sent_mutex);\n",
          "new_text": "tTime<std::chrono::seconds>();\n",
          "old_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "new_line_content": "    const auto now = GetTime<std::chrono::seconds>();",
          "content_same": false
        },
        {
          "line": 2756,
          "old_api": "ToStringIPPort",
          "new_api": "TransportSerializer",
          "old_text": "dr.ToStringIPPort() :",
          "new_text": "TransportSerializer())}",
          "old_line_content": "      m_addr_name{addrNameIn.empty() ? addr.ToStringIPPort() : addrNameIn},",
          "new_line_content": "      m_serializer{std::make_unique<V1TransportSerializer>(V1TransportSerializer())},",
          "content_same": false
        },
        {
          "line": 2792,
          "old_api": "c_str",
          "new_api": "size",
          "old_text": "ACE6(net, outbound_message,\n        pnode->GetId(),\n        pnode->m_addr_name.c_str(),\n        pnode->ConnectionTypeAsString().c_str(),\n        msg.m_type.c_str(),\n        msg.data.size(),\n        msg.data.data()\n    );\n",
          "new_text": "g.data.size();\n",
          "old_line_content": "    TRACE6(net, outbound_message,",
          "new_line_content": "    size_t nMessageSize = msg.data.size();",
          "content_same": false
        },
        {
          "line": 2794,
          "old_api": "c_str",
          "new_api": "GetBoolArg",
          "old_text": "ode->m_addr_name.c_str(),\n",
          "new_text": "rgs.GetBoolArg(\"-capturemessages\", false)) ",
          "old_line_content": "        pnode->m_addr_name.c_str(),",
          "new_line_content": "    if (gArgs.GetBoolArg(\"-capturemessages\", false)) {",
          "content_same": false
        },
        {
          "line": 2795,
          "old_api": "c_str",
          "new_api": "ptureMessage",
          "old_text": "ode->ConnectionTypeAsString().c_str(),\n",
          "new_text": "ptureMessage(pnode->addr, msg.m_type, msg.data, /*is_incoming=*/false);\n",
          "old_line_content": "        pnode->ConnectionTypeAsString().c_str(),",
          "new_line_content": "        CaptureMessage(pnode->addr, msg.m_type, msg.data, /*is_incoming=*/false);",
          "content_same": false
        },
        {
          "line": 2798,
          "old_api": "data",
          "new_api": "c_str",
          "old_text": "g.data.data()\n ",
          "new_text": "ACE6(net, outbound_message,\n        pnode->GetId(),\n        pnode->m_addr_name.c_str(),\n        pnode->ConnectionTypeAsString().c_str(),\n        msg.m_type.c_str(),\n        msg.data.size(),\n        msg.data.data()\n    );\n",
          "old_line_content": "        msg.data.data()",
          "new_line_content": "    TRACE6(net, outbound_message,",
          "content_same": false
        },
        {
          "line": 2803,
          "old_api": "prepareForTransport",
          "new_api": "size",
          "old_text": "ode->m_serializer->prepareForTransport(msg, serializedHeader);\n",
          "new_text": "g.data.size(),\n",
          "old_line_content": "    pnode->m_serializer->prepareForTransport(msg, serializedHeader);",
          "new_line_content": "        msg.data.size(),",
          "content_same": false
        },
        {
          "line": 2804,
          "old_api": "size",
          "new_api": "data",
          "old_text": "rializedHeader.size();\n",
          "new_text": "g.data.data()\n ",
          "old_line_content": "    size_t nTotalSize = nMessageSize + serializedHeader.size();",
          "new_line_content": "        msg.data.data()",
          "content_same": false
        },
        {
          "line": 2809,
          "old_api": "empty",
          "new_api": "prepareForTransport",
          "old_text": "ode->vSendMsg.empty());",
          "new_text": "ode->m_serializer->prepareForTransport(msg, serializedHeader);\n",
          "old_line_content": "        bool optimisticSend(pnode->vSendMsg.empty());",
          "new_line_content": "    pnode->m_serializer->prepareForTransport(msg, serializedHeader);",
          "content_same": false
        },
        {
          "line": 2822,
          "old_api": "cordBytesSent",
          "new_api": "d::move(serializedHeader));",
          "old_text": "cordBytesSent(nBytesSent);\n",
          "new_text": "d::move(serializedHeader));",
          "old_line_content": "    if (nBytesSent) RecordBytesSent(nBytesSent);",
          "new_line_content": "        pnode->vSendMsg.push_back(std::move(serializedHeader));",
          "content_same": false
        },
        {
          "line": 2828,
          "old_api": "CK",
          "new_api": "cordBytesSent",
          "old_text": "CK(m_nodes_mutex);\n",
          "new_text": "cordBytesSent(nBytesSent);\n",
          "old_line_content": "    LOCK(m_nodes_mutex);",
          "new_line_content": "    if (nBytesSent) RecordBytesSent(nBytesSent);",
          "content_same": false
        },
        {
          "line": 2865,
          "old_api": "::u8path(clean_addr);",
          "new_api": "tTime<std::chrono::microseconds>();",
          "old_text": "::u8path(clean_addr);\n",
          "new_text": "tTime<std::chrono::microseconds>();\n",
          "old_line_content": "    fs::path base_path = gArgs.GetDataDirNet() / \"message_capture\" / fs::u8path(clean_addr);",
          "new_line_content": "    auto now = GetTime<std::chrono::microseconds>();",
          "content_same": false
        },
        {
          "line": 2869,
          "old_api": "bridge::fopen(path, \"ab\")};",
          "new_api": "end",
          "old_text": "bridge::fopen(path, \"ab\")};",
          "new_text": "ean_addr.end(), ",
          "old_line_content": "    AutoFile f{fsbridge::fopen(path, \"ab\")};",
          "new_line_content": "    std::replace(clean_addr.begin(), clean_addr.end(), ':', '_');",
          "content_same": false
        },
        {
          "line": 2871,
          "old_api": "count",
          "new_api": "::u8path(clean_addr);",
          "old_text": "w.count());",
          "new_text": "::u8path(clean_addr);\n",
          "old_line_content": "    ser_writedata64(f, now.count());",
          "new_line_content": "    fs::path base_path = gArgs.GetDataDirNet() / \"message_capture\" / fs::u8path(clean_addr);",
          "content_same": false
        },
        {
          "line": 2872,
          "old_api": "keByteSpan",
          "new_api": "::create_directories(base_path);",
          "old_text": "keByteSpan(msg_type));",
          "new_text": "::create_directories(base_path);\n",
          "old_line_content": "    f.write(MakeByteSpan(msg_type));",
          "new_line_content": "    fs::create_directories(base_path);",
          "content_same": false
        },
        {
          "line": 2877,
          "old_api": "r_writedata32",
          "new_api": "count",
          "old_text": "r_writedata32(f, size);\n",
          "new_text": "w.count());",
          "old_line_content": "    ser_writedata32(f, size);",
          "new_line_content": "    ser_writedata64(f, now.count());",
          "content_same": false
        },
        {
          "line": 2878,
          "old_api": "Bytes",
          "new_api": "keByteSpan",
          "old_text": "Bytes(data));",
          "new_text": "keByteSpan(msg_type));",
          "old_line_content": "    f.write(AsBytes(data));",
          "new_line_content": "    f.write(MakeByteSpan(msg_type));",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2054,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "",
          "new_line_content": "    static constexpr auto err_wait_begin = 1s;",
          "content_same": false
        },
        {
          "line": 2055,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "    while (!interruptNet) {",
          "new_line_content": "    static constexpr auto err_wait_cap = 5min;",
          "content_same": false
        },
        {
          "line": 2064,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "conn.me.IsValid()",
          "old_line_content": "            if (err_wait < err_wait_cap) {",
          "new_line_content": "            if (advertising_listen_addr && conn.me.IsValid()) {",
          "content_same": false
        },
        {
          "line": 2065,
          "old_api": null,
          "new_api": "RemoveLocal",
          "old_text": null,
          "new_text": "RemoveLocal(conn.me)",
          "old_line_content": "                err_wait *= 2;",
          "new_line_content": "                RemoveLocal(conn.me);",
          "content_same": false
        },
        {
          "line": 2069,
          "old_api": null,
          "new_api": "sleep_for",
          "old_text": null,
          "new_text": "interruptNet.sleep_for(err_wait)",
          "old_line_content": "        }",
          "new_line_content": "            interruptNet.sleep_for(err_wait);",
          "content_same": false
        },
        {
          "line": 2078,
          "old_api": null,
          "new_api": "AddLocal",
          "old_text": null,
          "new_text": "AddLocal(conn.me, LOCAL_MANUAL)",
          "old_line_content": "        }",
          "new_line_content": "            AddLocal(conn.me, LOCAL_MANUAL);",
          "content_same": false
        },
        {
          "line": 2082,
          "old_api": null,
          "new_api": "Accept",
          "old_text": null,
          "new_text": "m_i2p_sam_session->Accept(conn)",
          "old_line_content": "    }",
          "new_line_content": "        if (!m_i2p_sam_session->Accept(conn)) {",
          "content_same": false
        },
        {
          "line": 2086,
          "old_api": null,
          "new_api": "std::move(conn.sock)",
          "old_text": null,
          "new_text": "std::move(conn.sock)",
          "old_line_content": "{",
          "new_line_content": "        CreateNodeFromAcceptedSocket(std::move(conn.sock), NetPermissionFlags::None,",
          "content_same": false
        },
        {
          "line": 2098,
          "old_api": null,
          "new_api": "GetSockAddr",
          "old_text": null,
          "new_text": "addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len)",
          "old_line_content": "",
          "new_line_content": "    if (!addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len))",
          "content_same": false
        },
        {
          "line": 2100,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "addrBind.ToString()",
          "old_line_content": "    if (!sock) {",
          "new_line_content": "        strError = strprintf(Untranslated(\"Bind address family for %s not supported\"), addrBind.ToString());",
          "content_same": false
        },
        {
          "line": 2105,
          "old_api": null,
          "new_api": "CreateSock",
          "old_text": null,
          "new_text": "CreateSock(addrBind)",
          "old_line_content": "",
          "new_line_content": "    std::unique_ptr<Sock> sock = CreateSock(addrBind);",
          "content_same": false
        },
        {
          "line": 2107,
          "old_api": null,
          "new_api": "WSAGetLastError",
          "old_text": null,
          "new_text": "WSAGetLastError()",
          "old_line_content": "    // the program was closed and restarted.",
          "new_line_content": "        strError = strprintf(Untranslated(\"Couldn't open socket for incoming connections (socket returned error %s)\"), NetworkErrorString(WSAGetLastError()));",
          "content_same": false
        },
        {
          "line": 2114,
          "old_api": null,
          "new_api": "SetSockOpt",
          "old_text": null,
          "new_text": "sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, (sockopt_arg_type)&nOne, sizeof(int))",
          "old_line_content": "    // and enable it by default or not. Try to enable it, if possible.",
          "new_line_content": "    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, (sockopt_arg_type)&nOne, sizeof(int)) == SOCKET_ERROR) {",
          "content_same": false
        },
        {
          "line": 2116,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"%s\\n\", strError.original)",
          "old_line_content": "#ifdef IPV6_V6ONLY",
          "new_line_content": "        LogPrintf(\"%s\\n\", strError.original);",
          "content_same": false
        },
        {
          "line": 2121,
          "old_api": null,
          "new_api": "IsIPv6",
          "old_text": null,
          "new_text": "addrBind.IsIPv6()",
          "old_line_content": "#endif",
          "new_line_content": "    if (addrBind.IsIPv6()) {",
          "content_same": false
        },
        {
          "line": 2123,
          "old_api": null,
          "new_api": "SetSockOpt",
          "old_text": null,
          "new_text": "sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_arg_type)&nOne, sizeof(int))",
          "old_line_content": "        int nProtLevel = PROTECTION_LEVEL_UNRESTRICTED;",
          "new_line_content": "        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_arg_type)&nOne, sizeof(int)) == SOCKET_ERROR) {",
          "content_same": false
        },
        {
          "line": 2130,
          "old_api": null,
          "new_api": "SetSockOpt",
          "old_text": null,
          "new_text": "sock->SetSockOpt(IPPROTO_IPV6, IPV6_PROTECTION_LEVEL, (const char*)&nProtLevel, sizeof(int))",
          "old_line_content": "",
          "new_line_content": "        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_PROTECTION_LEVEL, (const char*)&nProtLevel, sizeof(int)) == SOCKET_ERROR) {",
          "content_same": false
        },
        {
          "line": 2138,
          "old_api": null,
          "new_api": "WSAGetLastError",
          "old_text": null,
          "new_text": "WSAGetLastError()",
          "old_line_content": "        return false;",
          "new_line_content": "        int nErr = WSAGetLastError();",
          "content_same": false
        },
        {
          "line": 2142,
          "old_api": null,
          "new_api": "NetworkErrorString",
          "old_text": null,
          "new_text": "NetworkErrorString(nErr)",
          "old_line_content": "    // Listen for incoming connections",
          "new_line_content": "            strError = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"), addrBind.ToString(), NetworkErrorString(nErr));",
          "content_same": false
        },
        {
          "line": 2149,
          "old_api": null,
          "new_api": "Listen",
          "old_text": null,
          "new_text": "sock->Listen(SOMAXCONN)",
          "old_line_content": "",
          "new_line_content": "    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR)",
          "content_same": false
        },
        {
          "line": 2151,
          "old_api": null,
          "new_api": "WSAGetLastError",
          "old_text": null,
          "new_text": "WSAGetLastError()",
          "old_line_content": "    return true;",
          "new_line_content": "        strError = strprintf(_(\"Listening for incoming connections failed (listen returned error %s)\"), NetworkErrorString(WSAGetLastError()));",
          "content_same": false
        },
        {
          "line": 2152,
          "old_api": null,
          "new_api": "LogPrintLevel",
          "old_text": null,
          "new_text": "LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original)",
          "old_line_content": "}",
          "new_line_content": "        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);",
          "content_same": false
        },
        {
          "line": 2156,
          "old_api": null,
          "new_api": "std::move(sock)",
          "old_text": null,
          "new_text": "std::move(sock)",
          "old_line_content": "    if (!fDiscover)",
          "new_line_content": "    vhListenSocket.emplace_back(std::move(sock), permissions);",
          "content_same": false
        },
        {
          "line": 2168,
          "old_api": null,
          "new_api": "gethostname",
          "old_text": null,
          "new_text": "gethostname(pszHostName, sizeof(pszHostName))",
          "old_line_content": "            {",
          "new_line_content": "    if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR)",
          "content_same": false
        },
        {
          "line": 2171,
          "old_api": null,
          "new_api": "LookupHost",
          "old_text": null,
          "new_text": "LookupHost(pszHostName, vaddr, 0, true)",
          "old_line_content": "            }",
          "new_line_content": "        if (LookupHost(pszHostName, vaddr, 0, true))",
          "content_same": false
        },
        {
          "line": 2175,
          "old_api": null,
          "new_api": "AddLocal",
          "old_text": null,
          "new_text": "AddLocal(addr, LOCAL_IF)",
          "old_line_content": "    // Get local host ip",
          "new_line_content": "                if (AddLocal(addr, LOCAL_IF))",
          "content_same": false
        },
        {
          "line": 2176,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "addr.ToString()",
          "old_line_content": "    struct ifaddrs* myaddrs;",
          "new_line_content": "                    LogPrintf(\"%s: %s - %s\\n\", __func__, pszHostName, addr.ToString());",
          "content_same": false
        },
        {
          "line": 2195,
          "old_api": null,
          "new_api": "AddLocal",
          "old_text": null,
          "new_text": "AddLocal(addr, LOCAL_IF)",
          "old_line_content": "                CNetAddr addr(s6->sin6_addr);",
          "new_line_content": "                if (AddLocal(addr, LOCAL_IF))",
          "content_same": false
        },
        {
          "line": 2202,
          "old_api": null,
          "new_api": "AddLocal",
          "old_text": null,
          "new_text": "AddLocal(addr, LOCAL_IF)",
          "old_line_content": "#endif",
          "new_line_content": "                if (AddLocal(addr, LOCAL_IF))",
          "content_same": false
        },
        {
          "line": 2203,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "addr.ToString()",
          "old_line_content": "}",
          "new_line_content": "                    LogPrintf(\"%s: IPv6 %s: %s\\n\", __func__, ifa->ifa_name, addr.ToString());",
          "content_same": false
        },
        {
          "line": 2206,
          "old_api": null,
          "new_api": "freeifaddrs",
          "old_text": null,
          "new_text": "freeifaddrs(myaddrs)",
          "old_line_content": "{",
          "new_line_content": "        freeifaddrs(myaddrs);",
          "content_same": false
        },
        {
          "line": 2213,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"%s: %s\\n\", __func__, active)",
          "old_line_content": "    fNetworkActive = active;",
          "new_line_content": "    LogPrintf(\"%s: %s\\n\", __func__, active);",
          "content_same": false
        },
        {
          "line": 2222,
          "old_api": null,
          "new_api": "NotifyNetworkActiveChanged",
          "old_text": null,
          "new_text": "m_client_interface->NotifyNetworkActiveChanged(fNetworkActive)",
          "old_line_content": "    : addrman(addrman_in)",
          "new_line_content": "        m_client_interface->NotifyNetworkActiveChanged(fNetworkActive);",
          "content_same": false
        },
        {
          "line": 2233,
          "old_api": null,
          "new_api": "SetTryNewOutboundPeer",
          "old_text": null,
          "new_text": "SetTryNewOutboundPeer(false)",
          "old_line_content": "",
          "new_line_content": "    SetTryNewOutboundPeer(false);",
          "content_same": false
        },
        {
          "line": 2237,
          "old_api": null,
          "new_api": "SetNetworkActive",
          "old_text": null,
          "new_text": "SetNetworkActive(network_active)",
          "old_line_content": "}",
          "new_line_content": "    SetNetworkActive(network_active);",
          "content_same": false
        },
        {
          "line": 2248,
          "old_api": null,
          "new_api": "MaybeFlipIPv6toCJDNS",
          "old_text": null,
          "new_text": "MaybeFlipIPv6toCJDNS(addr_)",
          "old_line_content": "        }",
          "new_line_content": "    const CService addr{MaybeFlipIPv6toCJDNS(addr_)};",
          "content_same": false
        },
        {
          "line": 2251,
          "old_api": null,
          "new_api": "BindListenPort",
          "old_text": null,
          "new_text": "BindListenPort(addr, strError, permissions)",
          "old_line_content": "",
          "new_line_content": "    if (!BindListenPort(addr, strError, permissions)) {",
          "content_same": false
        },
        {
          "line": 2258,
          "old_api": null,
          "new_api": "NetPermissions::HasFlag(permissions, NetPermissionFlags::NoBan)",
          "old_text": null,
          "new_text": "NetPermissions::HasFlag(permissions, NetPermissionFlags::NoBan)",
          "old_line_content": "",
          "new_line_content": "    if (addr.IsRoutable() && fDiscover && !(flags & BF_DONT_ADVERTISE) && !NetPermissions::HasFlag(permissions, NetPermissionFlags::NoBan)) {",
          "content_same": false
        },
        {
          "line": 2259,
          "old_api": null,
          "new_api": "AddLocal",
          "old_text": null,
          "new_text": "AddLocal(addr, LOCAL_BIND)",
          "old_line_content": "bool CConnman::InitBinds(const Options& options)",
          "new_line_content": "        AddLocal(addr, LOCAL_BIND);",
          "content_same": false
        },
        {
          "line": 2272,
          "old_api": null,
          "new_api": "Bind",
          "old_text": null,
          "new_text": "Bind(addrBind.m_service, BF_REPORT_ERROR, addrBind.m_flags)",
          "old_line_content": "        struct in_addr inaddr_any;",
          "new_line_content": "        fBound |= Bind(addrBind.m_service, BF_REPORT_ERROR, addrBind.m_flags);",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": null,
          "new_api": "htonl",
          "old_text": null,
          "new_text": "htonl(INADDR_ANY)",
          "old_line_content": "}",
          "new_line_content": "        inaddr_any.s_addr = htonl(INADDR_ANY);",
          "content_same": false
        },
        {
          "line": 2281,
          "old_api": null,
          "new_api": "GetListenPort",
          "old_text": null,
          "new_text": "GetListenPort()",
          "old_line_content": "bool CConnman::Start(CScheduler& scheduler, const Options& connOptions)",
          "new_line_content": "        fBound |= Bind(CService(inaddr6_any, GetListenPort()), BF_NONE, NetPermissionFlags::None);",
          "content_same": false
        },
        {
          "line": 2282,
          "old_api": null,
          "new_api": "GetListenPort",
          "old_text": null,
          "new_text": "GetListenPort()",
          "old_line_content": "{",
          "new_line_content": "        fBound |= Bind(CService(inaddr_any, GetListenPort()), !fBound ? BF_REPORT_ERROR : BF_NONE, NetPermissionFlags::None);",
          "content_same": false
        },
        {
          "line": 2290,
          "old_api": null,
          "new_api": "Init",
          "old_text": null,
          "new_text": "Init(connOptions)",
          "old_line_content": "                \"\", CClientUIInterface::MSG_ERROR);",
          "new_line_content": "    Init(connOptions);",
          "content_same": false
        },
        {
          "line": 2292,
          "old_api": null,
          "new_api": "InitBinds",
          "old_text": null,
          "new_text": "InitBinds(connOptions)",
          "old_line_content": "        return false;",
          "new_line_content": "    if (fListen && !InitBinds(connOptions)) {",
          "content_same": false
        },
        {
          "line": 2294,
          "old_api": null,
          "new_api": "ThreadSafeMessageBox",
          "old_text": null,
          "new_text": "m_client_interface->ThreadSafeMessageBox(\n                _(\"Failed to listen on any port. Use -listen=0 if you want this.\"),\n                \"\", CClientUIInterface::MSG_ERROR)",
          "old_line_content": "",
          "new_line_content": "            m_client_interface->ThreadSafeMessageBox(",
          "content_same": false
        },
        {
          "line": 2295,
          "old_api": null,
          "new_api": "_",
          "old_text": null,
          "new_text": "_(\"Failed to listen on any port. Use -listen=0 if you want this.\")",
          "old_line_content": "    Proxy i2p_sam;",
          "new_line_content": "                _(\"Failed to listen on any port. Use -listen=0 if you want this.\"),",
          "content_same": false
        },
        {
          "line": 2303,
          "old_api": null,
          "new_api": "GetDataDirNet",
          "old_text": null,
          "new_text": "gArgs.GetDataDirNet()",
          "old_line_content": "    }",
          "new_line_content": "        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(gArgs.GetDataDirNet() / \"i2p_private_key\",",
          "content_same": false
        },
        {
          "line": 2313,
          "old_api": null,
          "new_api": "GetDataDirNet",
          "old_text": null,
          "new_text": "gArgs.GetDataDirNet()",
          "old_line_content": "",
          "new_line_content": "        m_anchors = ReadAnchors(gArgs.GetDataDirNet() / ANCHORS_DATABASE_FILENAME);",
          "content_same": false
        },
        {
          "line": 2314,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "m_anchors.size()",
          "old_line_content": "    if (m_client_interface) {",
          "new_line_content": "        if (m_anchors.size() > MAX_BLOCK_RELAY_ONLY_ANCHORS) {",
          "content_same": false
        },
        {
          "line": 2317,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "m_anchors.size()",
          "old_line_content": "",
          "new_line_content": "        LogPrintf(\"%i block-relay-only anchors will be tried for connections.\\n\", m_anchors.size());",
          "content_same": false
        },
        {
          "line": 2321,
          "old_api": null,
          "new_api": "_",
          "old_text": null,
          "new_text": "_(\"Starting network threads…\").t",
          "old_line_content": "        // initialize semaphore",
          "new_line_content": "        m_client_interface->InitMessage(_(\"Starting network threads…\").translated);",
          "content_same": false
        },
        {
          "line": 2328,
          "old_api": null,
          "new_api": "d::min(m_max_outbound, nMaxConnections));",
          "old_text": null,
          "new_text": "d::min(m_max_outbound, nMaxConnections));",
          "old_line_content": "",
          "new_line_content": "        semOutbound = std::make_unique<CSemaphore>(std::min(m_max_outbound, nMaxConnections));",
          "content_same": false
        },
        {
          "line": 2339,
          "old_api": null,
          "new_api": "terruptSocks5",
          "old_text": null,
          "new_text": "terruptSocks5(false);\n",
          "old_line_content": "        fMsgProcWake = false;",
          "new_line_content": "    InterruptSocks5(false);",
          "content_same": false
        },
        {
          "line": 2340,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "terruptNet.reset();\n",
          "old_line_content": "    }",
          "new_line_content": "    interruptNet.reset();",
          "content_same": false
        },
        {
          "line": 2344,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(mutexMsgProc);\n",
          "old_line_content": "",
          "new_line_content": "        LOCK(mutexMsgProc);",
          "content_same": false
        },
        {
          "line": 2349,
          "old_api": null,
          "new_api": "readSocketHandler",
          "old_text": null,
          "new_text": "readSocketHandler(); ",
          "old_line_content": "",
          "new_line_content": "    threadSocketHandler = std::thread(&util::TraceThread, \"net\", [this] { ThreadSocketHandler(); });",
          "content_same": false
        },
        {
          "line": 2352,
          "old_api": null,
          "new_api": "gPrintf",
          "old_text": null,
          "new_text": "gPrintf(\"DNS seeding disabled\\n\");\n",
          "old_line_content": "",
          "new_line_content": "        LogPrintf(\"DNS seeding disabled\\n\");",
          "content_same": false
        },
        {
          "line": 2354,
          "old_api": null,
          "new_api": "readDNSAddressSeed",
          "old_text": null,
          "new_text": "readDNSAddressSeed(); ",
          "old_line_content": "        if (m_client_interface) {",
          "new_line_content": "        threadDNSAddressSeed = std::thread(&util::TraceThread, \"dnsseed\", [this] { ThreadDNSAddressSeed(); });",
          "content_same": false
        },
        {
          "line": 2357,
          "old_api": null,
          "new_api": "readOpenAddedConnections",
          "old_text": null,
          "new_text": "readOpenAddedConnections(); ",
          "old_line_content": "                \"\", CClientUIInterface::MSG_ERROR);",
          "new_line_content": "    threadOpenAddedConnections = std::thread(&util::TraceThread, \"addcon\", [this] { ThreadOpenAddedConnections(); });",
          "content_same": false
        },
        {
          "line": 2359,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "nnOptions.m_specified_outgoing.empty()) ",
          "old_line_content": "        return false;",
          "new_line_content": "    if (connOptions.m_use_addrman_outgoing && !connOptions.m_specified_outgoing.empty()) {",
          "content_same": false
        },
        {
          "line": 2367,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "nnOptions.m_specified_outgoing.empty()) ",
          "old_line_content": "    // Process messages",
          "new_line_content": "    if (connOptions.m_use_addrman_outgoing || !connOptions.m_specified_outgoing.empty()) {",
          "content_same": false
        },
        {
          "line": 2370,
          "old_api": null,
          "new_api": "readOpenConnections",
          "old_text": null,
          "new_text": "readOpenConnections(connect); ",
          "old_line_content": "    if (m_i2p_sam_session) {",
          "new_line_content": "            [this, connect = connOptions.m_specified_outgoing] { ThreadOpenConnections(connect); });",
          "content_same": false
        },
        {
          "line": 2374,
          "old_api": null,
          "new_api": "readMessageHandler",
          "old_text": null,
          "new_text": "readMessageHandler(); ",
          "old_line_content": "",
          "new_line_content": "    threadMessageHandler = std::thread(&util::TraceThread, \"msghand\", [this] { ThreadMessageHandler(); });",
          "content_same": false
        },
        {
          "line": 2378,
          "old_api": null,
          "new_api": "readI2PAcceptIncoming",
          "old_text": null,
          "new_text": "readI2PAcceptIncoming(); ",
          "old_line_content": "    return true;",
          "new_line_content": "            std::thread(&util::TraceThread, \"i2paccept\", [this] { ThreadI2PAcceptIncoming(); });",
          "content_same": false
        },
        {
          "line": 2382,
          "old_api": null,
          "new_api": "mpAddresses",
          "old_text": null,
          "new_text": "mpAddresses(); ",
          "old_line_content": "{",
          "new_line_content": "    scheduler.scheduleEvery([this] { DumpAddresses(); }, DUMP_PEERS_INTERVAL);",
          "content_same": false
        },
        {
          "line": 2396,
          "old_api": null,
          "new_api": "ACleanup",
          "old_text": null,
          "new_text": "ACleanup();\n",
          "old_line_content": "void CConnman::Interrupt()",
          "new_line_content": "        WSACleanup();",
          "content_same": false
        },
        {
          "line": 2408,
          "old_api": null,
          "new_api": "notify_all",
          "old_text": null,
          "new_text": "ndMsgProc.notify_all();\n",
          "old_line_content": "        for (int i=0; i<m_max_outbound; i++) {",
          "new_line_content": "    condMsgProc.notify_all();",
          "content_same": false
        },
        {
          "line": 2410,
          "old_api": null,
          "new_api": "terruptNet",
          "old_text": null,
          "new_text": "terruptNet();\n",
          "old_line_content": "        }",
          "new_line_content": "    interruptNet();",
          "content_same": false
        },
        {
          "line": 2411,
          "old_api": null,
          "new_api": "terruptSocks5",
          "old_text": null,
          "new_text": "terruptSocks5(true);\n",
          "old_line_content": "    }",
          "new_line_content": "    InterruptSocks5(true);",
          "content_same": false
        },
        {
          "line": 2421,
          "old_api": null,
          "new_api": "post",
          "old_text": null,
          "new_text": "mAddnode->post();\n",
          "old_line_content": "{",
          "new_line_content": "            semAddnode->post();",
          "content_same": false
        },
        {
          "line": 2435,
          "old_api": null,
          "new_api": "joinable",
          "old_text": null,
          "new_text": "readOpenAddedConnections.joinable())\n",
          "old_line_content": "}",
          "new_line_content": "    if (threadOpenAddedConnections.joinable())",
          "content_same": false
        },
        {
          "line": 2436,
          "old_api": null,
          "new_api": "join",
          "old_text": null,
          "new_text": "readOpenAddedConnections.join();\n",
          "old_line_content": "",
          "new_line_content": "        threadOpenAddedConnections.join();",
          "content_same": false
        },
        {
          "line": 2437,
          "old_api": null,
          "new_api": "joinable",
          "old_text": null,
          "new_text": "readDNSAddressSeed.joinable())\n",
          "old_line_content": "void CConnman::StopNodes()",
          "new_line_content": "    if (threadDNSAddressSeed.joinable())",
          "content_same": false
        },
        {
          "line": 2438,
          "old_api": null,
          "new_api": "join",
          "old_text": null,
          "new_text": "readDNSAddressSeed.join();\n",
          "old_line_content": "{",
          "new_line_content": "        threadDNSAddressSeed.join();",
          "content_same": false
        },
        {
          "line": 2439,
          "old_api": null,
          "new_api": "joinable",
          "old_text": null,
          "new_text": "readSocketHandler.joinable())\n",
          "old_line_content": "    if (fAddressesInitialized) {",
          "new_line_content": "    if (threadSocketHandler.joinable())",
          "content_same": false
        },
        {
          "line": 2451,
          "old_api": null,
          "new_api": "tCurrentBlockRelayOnlyConns",
          "old_text": null,
          "new_text": "tCurrentBlockRelayOnlyConns();\n",
          "old_line_content": "    }",
          "new_line_content": "            std::vector<CAddress> anchors_to_dump = GetCurrentBlockRelayOnlyConns();",
          "content_same": false
        },
        {
          "line": 2452,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "chors_to_dump.size() >",
          "old_line_content": "",
          "new_line_content": "            if (anchors_to_dump.size() > MAX_BLOCK_RELAY_ONLY_ANCHORS) {",
          "content_same": false
        },
        {
          "line": 2453,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "chors_to_dump.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);\n",
          "old_line_content": "    // Delete peer connections.",
          "new_line_content": "                anchors_to_dump.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);",
          "content_same": false
        },
        {
          "line": 2461,
          "old_api": null,
          "new_api": "swap",
          "old_text": null,
          "new_text": "des.swap(m_nodes));",
          "old_line_content": "    for (CNode* pnode : m_nodes_disconnected) {",
          "new_line_content": "    WITH_LOCK(m_nodes_mutex, nodes.swap(m_nodes));",
          "content_same": false
        },
        {
          "line": 2463,
          "old_api": null,
          "new_api": "CloseSocketDisconnect",
          "old_text": null,
          "new_text": "ode->CloseSocketDisconnect();\n",
          "old_line_content": "    }",
          "new_line_content": "        pnode->CloseSocketDisconnect();",
          "content_same": false
        },
        {
          "line": 2468,
          "old_api": null,
          "new_api": "leteNode",
          "old_text": null,
          "new_text": "leteNode(pnode);\n",
          "old_line_content": "}",
          "new_line_content": "        DeleteNode(pnode);",
          "content_same": false
        },
        {
          "line": 2470,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "nodes_disconnected.clear();\n",
          "old_line_content": "void CConnman::DeleteNode(CNode* pnode)",
          "new_line_content": "    m_nodes_disconnected.clear();",
          "content_same": false
        },
        {
          "line": 2471,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "ListenSocket.clear();\n",
          "old_line_content": "{",
          "new_line_content": "    vhListenSocket.clear();",
          "content_same": false
        },
        {
          "line": 2478,
          "old_api": null,
          "new_api": "sert",
          "old_text": null,
          "new_text": "sert(pnode);\n",
          "old_line_content": "{",
          "new_line_content": "    assert(pnode);",
          "content_same": false
        },
        {
          "line": 2486,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "op();\n",
          "old_line_content": "    if (m_banman) {",
          "new_line_content": "    Stop();",
          "content_same": false
        },
        {
          "line": 2491,
          "old_api": null,
          "new_api": "GetAddr",
          "old_text": null,
          "new_text": "drman.GetAddr(max_addresses, max_pct, network);\n",
          "old_line_content": "    return addresses;",
          "new_line_content": "    std::vector<CAddress> addresses = addrman.GetAddr(max_addresses, max_pct, network);",
          "content_same": false
        },
        {
          "line": 2493,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "dresses.end(),\n",
          "old_line_content": "",
          "new_line_content": "        addresses.erase(std::remove_if(addresses.begin(), addresses.end(),",
          "content_same": false
        },
        {
          "line": 2494,
          "old_api": null,
          "new_api": "IsBanned",
          "old_text": null,
          "new_text": "banman->IsBanned(addr);}",
          "old_line_content": "std::vector<CAddress> CConnman::GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct)",
          "new_line_content": "                        [this](const CAddress& addr){return m_banman->IsDiscouraged(addr) || m_banman->IsBanned(addr);}),",
          "content_same": false
        },
        {
          "line": 2495,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "dresses.end());",
          "old_line_content": "{",
          "new_line_content": "                        addresses.end());",
          "content_same": false
        },
        {
          "line": 2503,
          "old_api": null,
          "new_api": "Write",
          "old_text": null,
          "new_text": "tDeterministicRandomizer(RANDOMIZER_ID_ADDRCACHE)\n        .Write(requestor.ConnectedThroughNetwork())\n        .Write(local_socket_bytes.data(), local_socket_bytes.size())\n        // For outbound connections, the port of the bound address is randomly\n        // assigned by the OS and would therefore not be useful for seeding.\n        .Write(requestor.IsInboundConn() ? requestor.addrBind.GetPort() : 0)\n        .Finalize();\n",
          "old_line_content": "        .Finalize();",
          "new_line_content": "    uint64_t cache_id = GetDeterministicRandomizer(RANDOMIZER_ID_ADDRCACHE)",
          "content_same": false
        },
        {
          "line": 2510,
          "old_api": null,
          "new_api": "tTime<std::chrono::microseconds>();",
          "old_text": null,
          "new_text": "tTime<std::chrono::microseconds>();\n",
          "old_line_content": "        // and the usefulness of ADDR responses to honest users.",
          "new_line_content": "    const auto current_time = GetTime<std::chrono::microseconds>();",
          "content_same": false
        },
        {
          "line": 2511,
          "old_api": null,
          "new_api": "emplace",
          "old_text": null,
          "new_text": "addr_response_caches.emplace(cache_id, CachedAddrResponse{});\n",
          "old_line_content": "        //",
          "new_line_content": "    auto r = m_addr_response_caches.emplace(cache_id, CachedAddrResponse{});",
          "content_same": false
        },
        {
          "line": 2514,
          "old_api": null,
          "new_api": "tAddresses",
          "old_text": null,
          "new_text": "tAddresses(max_addresses, max_pct, /*network=*/std::nullopt);\n",
          "old_line_content": "        // By the time an attacker scraped enough AddrMan records, most of",
          "new_line_content": "        cache_entry.m_addrs_response_cache = GetAddresses(max_addresses, max_pct, /*network=*/std::nullopt);",
          "content_same": false
        },
        {
          "line": 2539,
          "old_api": null,
          "new_api": "d::chrono::hours(6));",
          "old_text": null,
          "new_text": "d::chrono::hours(6));",
          "old_line_content": "{",
          "new_line_content": "        cache_entry.m_cache_entry_expiration = current_time + std::chrono::hours(21) + GetRandMillis(std::chrono::hours(6));",
          "content_same": false
        },
        {
          "line": 2546,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_added_nodes_mutex);\n",
          "old_line_content": "    return true;",
          "new_line_content": "    LOCK(m_added_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2557,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_added_nodes_mutex);\n",
          "old_line_content": "    }",
          "new_line_content": "    LOCK(m_added_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2558,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "added_nodes.end(); ",
          "old_line_content": "    return false;",
          "new_line_content": "    for(std::vector<std::string>::iterator it = m_added_nodes.begin(); it != m_added_nodes.end(); ++it) {",
          "content_same": false
        },
        {
          "line": 2560,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "added_nodes.erase(it);\n",
          "old_line_content": "",
          "new_line_content": "            m_added_nodes.erase(it);",
          "content_same": false
        },
        {
          "line": 2571,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "nodes.size();\n",
          "old_line_content": "        }",
          "new_line_content": "        return m_nodes.size();",
          "content_same": false
        },
        {
          "line": 2575,
          "old_api": null,
          "new_api": "IsInboundConn",
          "old_text": null,
          "new_text": "ode->IsInboundConn() ?",
          "old_line_content": "}",
          "new_line_content": "        if (flags & (pnode->IsInboundConn() ? ConnectionDirection::In : ConnectionDirection::Out)) {",
          "content_same": false
        },
        {
          "line": 2586,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_nodes_mutex);\n",
          "old_line_content": "    }",
          "new_line_content": "    LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2587,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "nodes.size());",
          "old_line_content": "}",
          "new_line_content": "    vstats.reserve(m_nodes.size());",
          "content_same": false
        },
        {
          "line": 2589,
          "old_api": null,
          "new_api": "emplace_back",
          "old_text": null,
          "new_text": "tats.emplace_back();\n",
          "old_line_content": "bool CConnman::DisconnectNode(const std::string& strNode)",
          "new_line_content": "        vstats.emplace_back();",
          "content_same": false
        },
        {
          "line": 2590,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "tats.back());",
          "old_line_content": "{",
          "new_line_content": "        pnode->CopyStats(vstats.back());",
          "content_same": false
        },
        {
          "line": 2597,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_nodes_mutex);\n",
          "old_line_content": "    return false;",
          "new_line_content": "    LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2598,
          "old_api": null,
          "new_api": "ndNode",
          "old_text": null,
          "new_text": "ndNode(strNode)) ",
          "old_line_content": "}",
          "new_line_content": "    if (CNode* pnode = FindNode(strNode)) {",
          "content_same": false
        },
        {
          "line": 2599,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "ode->GetId());",
          "old_line_content": "",
          "new_line_content": "        LogPrint(BCLog::NET, \"disconnect by address%s matched peer=%d; disconnecting\\n\", (fLogIPs ? strprintf(\"=%s\", strNode) : \"\"), pnode->GetId());",
          "content_same": false
        },
        {
          "line": 2609,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_nodes_mutex);\n",
          "old_line_content": "        }",
          "new_line_content": "    LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2611,
          "old_api": null,
          "new_api": "Match",
          "old_text": null,
          "new_text": "bnet.Match(pnode->addr)) ",
          "old_line_content": "    return disconnected;",
          "new_line_content": "        if (subnet.Match(pnode->addr)) {",
          "content_same": false
        },
        {
          "line": 2612,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "ode->GetId());",
          "old_line_content": "}",
          "new_line_content": "            LogPrint(BCLog::NET, \"disconnect by subnet%s matched peer=%d; disconnecting\\n\", (fLogIPs ? strprintf(\"=%s\", subnet.ToString()) : \"\"), pnode->GetId());",
          "content_same": false
        },
        {
          "line": 2622,
          "old_api": null,
          "new_api": "ubNet",
          "old_text": null,
          "new_text": "ubNet(addr));",
          "old_line_content": "    for(CNode* pnode : m_nodes) {",
          "new_line_content": "    return DisconnectNode(CSubNet(addr));",
          "content_same": false
        },
        {
          "line": 2627,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_nodes_mutex);\n",
          "old_line_content": "        }",
          "new_line_content": "    LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2629,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "ode->GetId()) ",
          "old_line_content": "    return false;",
          "new_line_content": "        if (id == pnode->GetId()) {",
          "content_same": false
        },
        {
          "line": 2630,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "ode->GetId());",
          "old_line_content": "}",
          "new_line_content": "            LogPrint(BCLog::NET, \"disconnect by id peer=%d; disconnecting\\n\", pnode->GetId());",
          "content_same": false
        },
        {
          "line": 2645,
          "old_api": null,
          "new_api": "sertLockNotHeld",
          "old_text": null,
          "new_text": "sertLockNotHeld(m_total_bytes_sent_mutex);\n",
          "old_line_content": "    if (nMaxOutboundCycleStartTime + MAX_UPLOAD_TIMEFRAME < now)",
          "new_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "content_same": false
        },
        {
          "line": 2646,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_total_bytes_sent_mutex);\n",
          "old_line_content": "    {",
          "new_line_content": "    LOCK(m_total_bytes_sent_mutex);",
          "content_same": false
        },
        {
          "line": 2650,
          "old_api": null,
          "new_api": "tTime<std::chrono::seconds>();",
          "old_text": null,
          "new_text": "tTime<std::chrono::seconds>();\n",
          "old_line_content": "    }",
          "new_line_content": "    const auto now = GetTime<std::chrono::seconds>();",
          "content_same": false
        },
        {
          "line": 2663,
          "old_api": null,
          "new_api": "sertLockNotHeld",
          "old_text": null,
          "new_text": "sertLockNotHeld(m_total_bytes_sent_mutex);\n",
          "old_line_content": "{",
          "new_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "content_same": false
        },
        {
          "line": 2664,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_total_bytes_sent_mutex);\n",
          "old_line_content": "    return MAX_UPLOAD_TIMEFRAME;",
          "new_line_content": "    LOCK(m_total_bytes_sent_mutex);",
          "content_same": false
        },
        {
          "line": 2675,
          "old_api": null,
          "new_api": "sertLockNotHeld",
          "old_text": null,
          "new_text": "sertLockNotHeld(m_total_bytes_sent_mutex);\n",
          "old_line_content": "{",
          "new_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "content_same": false
        },
        {
          "line": 2677,
          "old_api": null,
          "new_api": "tMaxOutboundTimeLeftInCycle_",
          "old_text": null,
          "new_text": "tMaxOutboundTimeLeftInCycle_();\n",
          "old_line_content": "",
          "new_line_content": "    return GetMaxOutboundTimeLeftInCycle_();",
          "content_same": false
        },
        {
          "line": 2682,
          "old_api": null,
          "new_api": "sertLockHeld",
          "old_text": null,
          "new_text": "sertLockHeld(m_total_bytes_sent_mutex);\n",
          "old_line_content": "        return MAX_UPLOAD_TIMEFRAME;",
          "new_line_content": "    AssertLockHeld(m_total_bytes_sent_mutex);",
          "content_same": false
        },
        {
          "line": 2687,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "axOutboundCycleStartTime.count() =",
          "old_line_content": "}",
          "new_line_content": "    if (nMaxOutboundCycleStartTime.count() == 0)",
          "content_same": false
        },
        {
          "line": 2697,
          "old_api": null,
          "new_api": "sertLockNotHeld",
          "old_text": null,
          "new_text": "sertLockNotHeld(m_total_bytes_sent_mutex);\n",
          "old_line_content": "    {",
          "new_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "content_same": false
        },
        {
          "line": 2698,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_total_bytes_sent_mutex);\n",
          "old_line_content": "        // keep a large enough buffer to at least relay each block once",
          "new_line_content": "    LOCK(m_total_bytes_sent_mutex);",
          "content_same": false
        },
        {
          "line": 2705,
          "old_api": null,
          "new_api": "tMaxOutboundTimeLeftInCycle_",
          "old_text": null,
          "new_text": "tMaxOutboundTimeLeftInCycle_();\n",
          "old_line_content": "        return true;",
          "new_line_content": "        const std::chrono::seconds timeLeftInCycle = GetMaxOutboundTimeLeftInCycle_();",
          "content_same": false
        },
        {
          "line": 2718,
          "old_api": null,
          "new_api": "sertLockNotHeld",
          "old_text": null,
          "new_text": "sertLockNotHeld(m_total_bytes_sent_mutex);\n",
          "old_line_content": "}",
          "new_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "content_same": false
        },
        {
          "line": 2719,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_total_bytes_sent_mutex);\n",
          "old_line_content": "",
          "new_line_content": "    LOCK(m_total_bytes_sent_mutex);",
          "content_same": false
        },
        {
          "line": 2733,
          "old_api": null,
          "new_api": "sertLockNotHeld",
          "old_text": null,
          "new_text": "sertLockNotHeld(m_total_bytes_sent_mutex);\n",
          "old_line_content": "{",
          "new_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "content_same": false
        },
        {
          "line": 2734,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_total_bytes_sent_mutex);\n",
          "old_line_content": "    return nLocalServices;",
          "new_line_content": "    LOCK(m_total_bytes_sent_mutex);",
          "content_same": false
        },
        {
          "line": 2755,
          "old_api": null,
          "new_api": "rams",
          "old_text": null,
          "new_text": "rams(), ",
          "old_line_content": "      addrBind{addrBindIn},",
          "new_line_content": "    : m_deserializer{std::make_unique<V1TransportDeserializer>(V1TransportDeserializer(Params(), idIn, SER_NETWORK, INIT_PROTO_VERSION))},",
          "content_same": false
        },
        {
          "line": 2759,
          "old_api": null,
          "new_api": "tTime<std::chrono::seconds>()},",
          "old_text": null,
          "new_text": "tTime<std::chrono::seconds>()},",
          "old_line_content": "      nKeyedNetGroup{nKeyedNetGroupIn},",
          "new_line_content": "      m_connected{GetTime<std::chrono::seconds>()},",
          "content_same": false
        },
        {
          "line": 2762,
          "old_api": null,
          "new_api": "ToStringIPPort",
          "old_text": null,
          "new_text": "dr.ToStringIPPort() :",
          "old_line_content": "      m_conn_type{conn_type_in},",
          "new_line_content": "      m_addr_name{addrNameIn.empty() ? addr.ToStringIPPort() : addrNameIn},",
          "content_same": false
        },
        {
          "line": 2769,
          "old_api": null,
          "new_api": "d::move(node_opts.i2p_sam_session)}",
          "old_text": null,
          "new_text": "d::move(node_opts.i2p_sam_session)}\n",
          "old_line_content": "    mapRecvBytesPerMsgType[NET_MESSAGE_TYPE_OTHER] = 0;",
          "new_line_content": "      m_i2p_sam_session{std::move(node_opts.i2p_sam_session)}",
          "content_same": false
        },
        {
          "line": 2771,
          "old_api": null,
          "new_api": "sert",
          "old_text": null,
          "new_text": "sert(conn_type_in == ConnectionType::INBOUND);\n",
          "old_line_content": "    if (fLogIPs) {",
          "new_line_content": "    if (inbound_onion) assert(conn_type_in == ConnectionType::INBOUND);",
          "content_same": false
        },
        {
          "line": 2773,
          "old_api": null,
          "new_api": "tAllNetMessageTypes",
          "old_text": null,
          "new_text": "tAllNetMessageTypes())\n",
          "old_line_content": "    } else {",
          "new_line_content": "    for (const std::string &msg : getAllNetMessageTypes())",
          "content_same": false
        },
        {
          "line": 2778,
          "old_api": null,
          "new_api": "gPrint",
          "old_text": null,
          "new_text": "gPrint(BCLog::NET, \"Added connection to %s peer=%d\\n\", m_addr_name, id);\n",
          "old_line_content": "bool CConnman::NodeFullyConnected(const CNode* pnode)",
          "new_line_content": "        LogPrint(BCLog::NET, \"Added connection to %s peer=%d\\n\", m_addr_name, id);",
          "content_same": false
        },
        {
          "line": 2780,
          "old_api": null,
          "new_api": "gPrint",
          "old_text": null,
          "new_text": "gPrint(BCLog::NET, \"Added connection peer=%d\\n\", id);\n",
          "old_line_content": "    return pnode && pnode->fSuccessfullyConnected && !pnode->fDisconnect;",
          "new_line_content": "        LogPrint(BCLog::NET, \"Added connection peer=%d\\n\", id);",
          "content_same": false
        },
        {
          "line": 2791,
          "old_api": null,
          "new_api": "sertLockNotHeld",
          "old_text": null,
          "new_text": "sertLockNotHeld(m_total_bytes_sent_mutex);\n",
          "old_line_content": "",
          "new_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "content_same": false
        },
        {
          "line": 2799,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "ode->GetId(),\n",
          "old_line_content": "    );",
          "new_line_content": "        pnode->GetId(),",
          "content_same": false
        },
        {
          "line": 2800,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "ode->m_addr_name.c_str(),\n",
          "old_line_content": "",
          "new_line_content": "        pnode->m_addr_name.c_str(),",
          "content_same": false
        },
        {
          "line": 2801,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "ode->ConnectionTypeAsString().c_str(),\n",
          "old_line_content": "    // make sure we use the appropriate network transport format",
          "new_line_content": "        pnode->ConnectionTypeAsString().c_str(),",
          "content_same": false
        },
        {
          "line": 2802,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "g.m_type.c_str(),\n",
          "old_line_content": "    std::vector<unsigned char> serializedHeader;",
          "new_line_content": "        msg.m_type.c_str(),",
          "content_same": false
        },
        {
          "line": 2810,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "rializedHeader.size();\n",
          "old_line_content": "",
          "new_line_content": "    size_t nTotalSize = nMessageSize + serializedHeader.size();",
          "content_same": false
        },
        {
          "line": 2814,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(pnode->cs_vSend);\n",
          "old_line_content": "",
          "new_line_content": "        LOCK(pnode->cs_vSend);",
          "content_same": false
        },
        {
          "line": 2815,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "ode->vSendMsg.empty());",
          "old_line_content": "        if (pnode->nSendSize > nSendBufferMaxSize) pnode->fPauseSend = true;",
          "new_line_content": "        bool optimisticSend(pnode->vSendMsg.empty());",
          "content_same": false
        },
        {
          "line": 2823,
          "old_api": null,
          "new_api": "d::move(msg.data));",
          "old_text": null,
          "new_text": "d::move(msg.data));",
          "old_line_content": "}",
          "new_line_content": "        if (nMessageSize) pnode->vSendMsg.push_back(std::move(msg.data));",
          "content_same": false
        },
        {
          "line": 2826,
          "old_api": null,
          "new_api": "cketSendData",
          "old_text": null,
          "new_text": "cketSendData(*pnode);\n",
          "old_line_content": "{",
          "new_line_content": "        if (optimisticSend) nBytesSent = SocketSendData(*pnode);",
          "content_same": false
        },
        {
          "line": 2834,
          "old_api": null,
          "new_api": "CK",
          "old_text": null,
          "new_text": "CK(m_nodes_mutex);\n",
          "old_line_content": "    }",
          "new_line_content": "    LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2836,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "ode->GetId() =",
          "old_line_content": "}",
          "new_line_content": "        if(pnode->GetId() == id) {",
          "content_same": false
        },
        {
          "line": 2841,
          "old_api": null,
          "new_api": "nc",
          "old_text": null,
          "new_text": "nc(found);\n",
          "old_line_content": "}",
          "new_line_content": "    return found != nullptr && NodeFullyConnected(found) && func(found);",
          "content_same": false
        },
        {
          "line": 2846,
          "old_api": null,
          "new_api": "Write",
          "old_text": null,
          "new_text": "ipHasher(nSeed0, nSeed1).Write(id);\n",
          "old_line_content": "",
          "new_line_content": "    return CSipHasher(nSeed0, nSeed1).Write(id);",
          "content_same": false
        },
        {
          "line": 2851,
          "old_api": null,
          "new_api": "GetGroup",
          "old_text": null,
          "new_text": "netgroupman.GetGroup(address));",
          "old_line_content": "                          const std::string& msg_type,",
          "new_line_content": "    std::vector<unsigned char> vchNetGroup(m_netgroupman.GetGroup(address));",
          "content_same": false
        },
        {
          "line": 2853,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "hNetGroup.size()).",
          "old_line_content": "                          bool is_incoming)",
          "new_line_content": "    return GetDeterministicRandomizer(RANDOMIZER_ID_NETGROUP).Write(vchNetGroup.data(), vchNetGroup.size()).Finalize();",
          "content_same": false
        },
        {
          "line": 2868,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "dr.ToString();\n",
          "old_line_content": "    fs::path path = base_path / (is_incoming ? \"msgs_recv.dat\" : \"msgs_sent.dat\");",
          "new_line_content": "    std::string clean_addr = addr.ToString();",
          "content_same": false
        },
        {
          "line": 2875,
          "old_api": null,
          "new_api": "bridge::fopen(path, \"ab\")};",
          "old_text": null,
          "new_text": "bridge::fopen(path, \"ab\")};",
          "old_line_content": "    }",
          "new_line_content": "    AutoFile f{fsbridge::fopen(path, \"ab\")};",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "node.vSendMsg.end()",
          "old_line_content": "        if (nBytes > 0) {",
          "new_line_content": "            if (it + 1 != node.vSendMsg.end()) {",
          "content_same": false
        },
        {
          "line": 2879,
          "old_api": null,
          "new_api": "length",
          "old_text": null,
          "new_text": "g_type.length(); ",
          "old_line_content": "}",
          "new_line_content": "    for (auto i = msg_type.length(); i < CMessageHeader::COMMAND_SIZE; ++i) {",
          "content_same": false
        },
        {
          "line": 834,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data.size()",
          "old_line_content": "            nSentSize += nBytes;",
          "new_line_content": "            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()) + node.nSendOffset, data.size() - node.nSendOffset, flags);",
          "content_same": false
        },
        {
          "line": 2882,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "ta.size();\n",
          "old_line_content": "                   const std::string& msg_type,",
          "new_line_content": "    uint32_t size = data.size();",
          "content_same": false
        },
        {
          "line": 2883,
          "old_api": null,
          "new_api": "r_writedata32",
          "old_text": null,
          "new_text": "r_writedata32(f, size);\n",
          "old_line_content": "                   Span<const unsigned char> data,",
          "new_line_content": "    ser_writedata32(f, size);",
          "content_same": false
        },
        {
          "line": 2884,
          "old_api": null,
          "new_api": "Bytes",
          "old_text": null,
          "new_text": "Bytes(data));",
          "old_line_content": "                   bool is_incoming)>",
          "new_line_content": "    f.write(AsBytes(data));",
          "content_same": false
        },
        {
          "line": 841,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data.size()",
          "old_line_content": "                // could not send full message; stop sending more",
          "new_line_content": "            if (node.nSendOffset == data.size()) {",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "data.size()",
          "old_line_content": "            }",
          "new_line_content": "                node.nSendSize -= data.size();",
          "content_same": false
        },
        {
          "line": 853,
          "old_api": null,
          "new_api": "WSAGetLastError",
          "old_text": null,
          "new_text": "WSAGetLastError()",
          "old_line_content": "            // couldn't send anything at all",
          "new_line_content": "                int nErr = WSAGetLastError();",
          "content_same": false
        },
        {
          "line": 855,
          "old_api": null,
          "new_api": "NetworkErrorString",
          "old_text": null,
          "new_text": "NetworkErrorString(nErr)",
          "old_line_content": "        }",
          "new_line_content": "                    LogPrint(BCLog::NET, \"socket send error for peer=%d: %s\\n\", node.GetId(), NetworkErrorString(nErr));",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": null,
          "new_api": "CloseSocketDisconnect",
          "old_text": null,
          "new_text": "node.CloseSocketDisconnect()",
          "old_line_content": "    }",
          "new_line_content": "                    node.CloseSocketDisconnect();",
          "content_same": false
        },
        {
          "line": 864,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "node.vSendMsg.end()",
          "old_line_content": "}",
          "new_line_content": "    if (it == node.vSendMsg.end()) {",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(node.nSendOffset == 0)",
          "old_line_content": "",
          "new_line_content": "        assert(node.nSendOffset == 0);",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(node.nSendSize == 0)",
          "old_line_content": "/** Try to find a connection to evict when the node is full.",
          "new_line_content": "        assert(node.nSendSize == 0);",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "node.vSendMsg.begin()",
          "old_line_content": " *   triggered network partitioning.",
          "new_line_content": "    node.vSendMsg.erase(node.vSendMsg.begin(), it);",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "                .m_connected = node->m_connected,",
          "new_line_content": "        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 897,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "node->m_bloom_filter_loaded.load()",
          "old_line_content": "                .m_conn_type = node->m_conn_type,",
          "new_line_content": "                .fBloomFilter = node->m_bloom_filter_loaded.load(),",
          "content_same": false
        },
        {
          "line": 900,
          "old_api": null,
          "new_api": "IsLocal",
          "old_text": null,
          "new_text": "node->addr.IsLocal()",
          "old_line_content": "        }",
          "new_line_content": "                .m_is_local = node->addr.IsLocal(),",
          "content_same": false
        },
        {
          "line": 901,
          "old_api": null,
          "new_api": "ConnectedThroughNetwork",
          "old_text": null,
          "new_text": "node->ConnectedThroughNetwork()",
          "old_line_content": "    }",
          "new_line_content": "                .m_network = node->ConnectedThroughNetwork(),",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "vEvictionCandidates.push_back(candidate)",
          "old_line_content": "    }",
          "new_line_content": "            vEvictionCandidates.push_back(candidate);",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "        }",
          "new_line_content": "    LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pnode->GetId()",
          "old_line_content": "    return false;",
          "new_line_content": "        if (pnode->GetId() == *node_id_to_evict) {",
          "content_same": false
        },
        {
          "line": 915,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pnode->GetId()",
          "old_line_content": "}",
          "new_line_content": "            LogPrint(BCLog::NET, \"selected %s connection for eviction peer=%d; disconnecting\\n\", pnode->ConnectionTypeAsString(), pnode->GetId());",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": null,
          "new_api": "WSAGetLastError",
          "old_text": null,
          "new_text": "WSAGetLastError()",
          "old_line_content": "",
          "new_line_content": "        const int nErr = WSAGetLastError();",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": null,
          "new_api": "LogPrintLevel",
          "old_text": null,
          "new_text": "LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\")",
          "old_line_content": "",
          "new_line_content": "        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": null,
          "new_api": "GetBindAddress",
          "old_text": null,
          "new_text": "GetBindAddress(*sock)",
          "old_line_content": "}",
          "new_line_content": "    const CAddress addr_bind{MaybeFlipIPv6toCJDNS(GetBindAddress(*sock)), NODE_NONE};",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": null,
          "new_api": "AddSocketPermissionFlags",
          "old_text": null,
          "new_text": "hListenSocket.AddSocketPermissionFlags(permission_flags)",
          "old_line_content": "                                            NetPermissionFlags permission_flags,",
          "new_line_content": "    hListenSocket.AddSocketPermissionFlags(permission_flags);",
          "content_same": false
        },
        {
          "line": 948,
          "old_api": null,
          "new_api": "std::move(sock)",
          "old_text": null,
          "new_text": "std::move(sock)",
          "old_line_content": "                                            const CAddress& addr)",
          "new_line_content": "    CreateNodeFromAcceptedSocket(std::move(sock), permission_flags, addr_bind, addr);",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": null,
          "new_api": "NetPermissions::HasFlag(permission_flags, NetPermissionFlags::Implicit)",
          "old_text": null,
          "new_text": "NetPermissions::HasFlag(permission_flags, NetPermissionFlags::Implicit)",
          "old_line_content": "    }",
          "new_line_content": "    if (NetPermissions::HasFlag(permission_flags, NetPermissionFlags::Implicit)) {",
          "content_same": false
        },
        {
          "line": 961,
          "old_api": null,
          "new_api": "NetPermissions::ClearFlag(permission_flags, NetPermissionFlags::Implicit)",
          "old_text": null,
          "new_text": "NetPermissions::ClearFlag(permission_flags, NetPermissionFlags::Implicit)",
          "old_line_content": "",
          "new_line_content": "        NetPermissions::ClearFlag(permission_flags, NetPermissionFlags::Implicit);",
          "content_same": false
        },
        {
          "line": 962,
          "old_api": null,
          "new_api": "NetPermissions::AddFlag(permission_flags, NetPermissionFlags::ForceRelay)",
          "old_text": null,
          "new_text": "NetPermissions::AddFlag(permission_flags, NetPermissionFlags::ForceRelay)",
          "old_line_content": "    {",
          "new_line_content": "        if (gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) NetPermissions::AddFlag(permission_flags, NetPermissionFlags::ForceRelay);",
          "content_same": false
        },
        {
          "line": 964,
          "old_api": null,
          "new_api": "NetPermissions::AddFlag(permission_flags, NetPermissionFlags::Mempool)",
          "old_text": null,
          "new_text": "NetPermissions::AddFlag(permission_flags, NetPermissionFlags::Mempool)",
          "old_line_content": "        for (const CNode* pnode : m_nodes) {",
          "new_line_content": "        NetPermissions::AddFlag(permission_flags, NetPermissionFlags::Mempool);",
          "content_same": false
        },
        {
          "line": 969,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "    if (!fNetworkActive) {",
          "new_line_content": "        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": null,
          "new_api": "IsInboundConn",
          "old_text": null,
          "new_text": "pnode->IsInboundConn()",
          "old_line_content": "        return;",
          "new_line_content": "            if (pnode->IsInboundConn()) nInbound++;",
          "content_same": false
        },
        {
          "line": 976,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "addr.ToString()",
          "old_line_content": "        return;",
          "new_line_content": "        LogPrint(BCLog::NET, \"connection from %s dropped: not accepting new connections\\n\", addr.ToString());",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": null,
          "new_api": "IsSelectable",
          "old_text": null,
          "new_text": "sock->IsSelectable()",
          "old_line_content": "    // on all platforms.  Set it again here just to be sure.",
          "new_line_content": "    if (!sock->IsSelectable()) {",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "addr.ToString()",
          "old_line_content": "    const int on{1};",
          "new_line_content": "        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", addr.ToString());",
          "content_same": false
        },
        {
          "line": 990,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "addr.ToString()",
          "old_line_content": "    {",
          "new_line_content": "                 addr.ToString());",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": null,
          "new_api": "IsBanned",
          "old_text": null,
          "new_text": "m_banman->IsBanned(addr)",
          "old_line_content": "",
          "new_line_content": "    bool banned = m_banman && m_banman->IsBanned(addr);",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": null,
          "new_api": "NetPermissions::HasFlag(permission_flags, NetPermissionFlags::NoBan)",
          "old_text": null,
          "new_text": "NetPermissions::HasFlag(permission_flags, NetPermissionFlags::NoBan)",
          "old_line_content": "    // Only accept connections from discouraged peers if our inbound slots aren't (almost) full.",
          "new_line_content": "    if (!NetPermissions::HasFlag(permission_flags, NetPermissionFlags::NoBan) && banned)",
          "content_same": false
        },
        {
          "line": 1002,
          "old_api": null,
          "new_api": "IsDiscouraged",
          "old_text": null,
          "new_text": "m_banman->IsDiscouraged(addr)",
          "old_line_content": "",
          "new_line_content": "    bool discouraged = m_banman && m_banman->IsDiscouraged(addr);",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": null,
          "new_api": "NetPermissions::HasFlag(permission_flags, NetPermissionFlags::NoBan)",
          "old_text": null,
          "new_text": "NetPermissions::HasFlag(permission_flags, NetPermissionFlags::NoBan)",
          "old_line_content": "    if (nInbound >= nMaxInbound)",
          "new_line_content": "    if (!NetPermissions::HasFlag(permission_flags, NetPermissionFlags::NoBan) && nInbound + 1 >= nMaxInbound && discouraged)",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": null,
          "new_api": "AttemptToEvictConnection",
          "old_text": null,
          "new_text": "AttemptToEvictConnection()",
          "old_line_content": "",
          "new_line_content": "        if (!AttemptToEvictConnection()) {",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": null,
          "new_api": "GetNewNodeId",
          "old_text": null,
          "new_text": "GetNewNodeId()",
          "old_line_content": "    }",
          "new_line_content": "    NodeId id = GetNewNodeId();",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": null,
          "new_api": "Write",
          "old_text": null,
          "new_text": "GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize()",
          "old_line_content": "",
          "new_line_content": "    uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": null,
          "new_api": "static_cast<ServiceFlags>(nodeServices | NODE_BLOOM)",
          "old_text": null,
          "new_text": "static_cast<ServiceFlags>(nodeServices | NODE_BLOOM)",
          "old_line_content": "                             addr,",
          "new_line_content": "        nodeServices = static_cast<ServiceFlags>(nodeServices | NODE_BLOOM);",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "m_onion_binds.end()",
          "old_line_content": "                             addr_bind,",
          "new_line_content": "    const bool inbound_onion = std::find(m_onion_binds.begin(), m_onion_binds.end(), addr_bind) != m_onion_binds.end();",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": null,
          "new_api": "std::move(sock)",
          "old_text": null,
          "new_text": "std::move(sock)",
          "old_line_content": "                             ConnectionType::INBOUND,",
          "new_line_content": "                             std::move(sock),",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": null,
          "new_api": "CalculateKeyedNetGroup",
          "old_text": null,
          "new_text": "CalculateKeyedNetGroup(addr)",
          "old_line_content": "                             CNodeOptions{",
          "new_line_content": "                             CalculateKeyedNetGroup(addr),",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "addr.ToString()",
          "old_line_content": "",
          "new_line_content": "    LogPrint(BCLog::NET, \"connection from %s accepted\\n\", addr.ToString());",
          "content_same": false
        },
        {
          "line": 1046,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "}",
          "new_line_content": "        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1047,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "m_nodes.push_back(pnode)",
          "old_line_content": "",
          "new_line_content": "        m_nodes.push_back(pnode);",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": null,
          "new_api": "RandAddEvent",
          "old_text": null,
          "new_text": "RandAddEvent((uint32_t)id)",
          "old_line_content": "    switch (conn_type) {",
          "new_line_content": "    RandAddEvent((uint32_t)id);",
          "content_same": false
        },
        {
          "line": 1076,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "WITH_LOCK(m_nodes_mutex,\n                                         return std::count_if(m_nodes.begin(), m_nodes.end(), [conn_type](CNode* node) { return node->m_conn_type == conn_type; });)",
          "old_line_content": "    // Max total outbound connections already exist",
          "new_line_content": "    int existing_connections = WITH_LOCK(m_nodes_mutex,",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "m_nodes.end()",
          "old_line_content": "    CSemaphoreGrant grant(*semOutbound, true);",
          "new_line_content": "                                         return std::count_if(m_nodes.begin(), m_nodes.end(), [conn_type](CNode* node) { return node->m_conn_type == conn_type; }););",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "address.c_str()",
          "old_line_content": "    {",
          "new_line_content": "    OpenNetworkConnection(CAddress(), false, &grant, address.c_str(), conn_type);",
          "content_same": false
        },
        {
          "line": 1099,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pnode->GetId()",
          "old_line_content": "        // Disconnect unused nodes",
          "new_line_content": "                    LogPrint(BCLog::NET, \"Network not active, dropping peer=%d\\n\", pnode->GetId());",
          "content_same": false
        },
        {
          "line": 1118,
          "old_api": null,
          "new_api": "CloseSocketDisconnect",
          "old_text": null,
          "new_text": "pnode->CloseSocketDisconnect()",
          "old_line_content": "        }",
          "new_line_content": "                pnode->CloseSocketDisconnect();",
          "content_same": false
        },
        {
          "line": 1121,
          "old_api": null,
          "new_api": "Release",
          "old_text": null,
          "new_text": "pnode->Release()",
          "old_line_content": "        // Delete disconnected nodes",
          "new_line_content": "                pnode->Release();",
          "content_same": false
        },
        {
          "line": 1122,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "m_nodes_disconnected.push_back(pnode)",
          "old_line_content": "        std::list<CNode*> nodes_disconnected_copy = m_nodes_disconnected;",
          "new_line_content": "                m_nodes_disconnected.push_back(pnode);",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": null,
          "new_api": "GetRefCount",
          "old_text": null,
          "new_text": "pnode->GetRefCount()",
          "old_line_content": "}",
          "new_line_content": "            if (pnode->GetRefCount() <= 0) {",
          "content_same": false
        },
        {
          "line": 1133,
          "old_api": null,
          "new_api": "remove",
          "old_text": null,
          "new_text": "m_nodes_disconnected.remove(pnode)",
          "old_line_content": "",
          "new_line_content": "                m_nodes_disconnected.remove(pnode);",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": null,
          "new_api": "DeleteNode",
          "old_text": null,
          "new_text": "DeleteNode(pnode)",
          "old_line_content": "void CConnman::NotifyNumConnectionsChanged()",
          "new_line_content": "                DeleteNode(pnode);",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "m_nodes.size()",
          "old_line_content": "        }",
          "new_line_content": "        nodes_size = m_nodes.size();",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": null,
          "new_api": "NotifyNumConnectionsChanged",
          "old_text": null,
          "new_text": "m_client_interface->NotifyNumConnectionsChanged(nodes_size)",
          "old_line_content": "{",
          "new_line_content": "            m_client_interface->NotifyNumConnectionsChanged(nodes_size);",
          "content_same": false
        },
        {
          "line": 1166,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "node.m_last_recv.load()",
          "old_line_content": "        return true;",
          "new_line_content": "    const auto last_recv{node.m_last_recv.load()};",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": null,
          "new_api": "ShouldRunInactivityChecks",
          "old_text": null,
          "new_text": "ShouldRunInactivityChecks(node, now)",
          "old_line_content": "",
          "new_line_content": "    if (!ShouldRunInactivityChecks(node, now)) return false;",
          "content_same": false
        },
        {
          "line": 1171,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "node.GetId()",
          "old_line_content": "        return true;",
          "new_line_content": "        LogPrint(BCLog::NET, \"socket no message in first %i seconds, %d %d peer=%d\\n\", count_seconds(m_peer_connect_timeout), last_recv.count() != 0, last_send.count() != 0, node.GetId());",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "node.GetId()",
          "old_line_content": "        return true;",
          "new_line_content": "        LogPrint(BCLog::NET, \"socket sending timeout: %is peer=%d\\n\", count_seconds(now - last_send), node.GetId());",
          "content_same": false
        },
        {
          "line": 1181,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "node.GetId()",
          "old_line_content": "        return true;",
          "new_line_content": "        LogPrint(BCLog::NET, \"socket receive timeout: %is peer=%d\\n\", count_seconds(now - last_recv), node.GetId());",
          "content_same": false
        },
        {
          "line": 1186,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "node.GetId()",
          "old_line_content": "",
          "new_line_content": "        LogPrint(BCLog::NET, \"version handshake timeout peer=%d\\n\", node.GetId());",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": null,
          "new_api": "emplace",
          "old_text": null,
          "new_text": "events_per_sock.emplace(hListenSocket.sock, Sock::Events{Sock::RECV})",
          "old_line_content": "        //   happens when optimistic write failed, we choose to first drain the",
          "new_line_content": "        events_per_sock.emplace(hListenSocket.sock, Sock::Events{Sock::RECV});",
          "content_same": false
        },
        {
          "line": 1216,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pnode->cs_vSend)",
          "old_line_content": "            continue;",
          "new_line_content": "            LOCK(pnode->cs_vSend);",
          "content_same": false
        },
        {
          "line": 1217,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "pnode->vSendMsg.empty()",
          "old_line_content": "        }",
          "new_line_content": "            select_send = !pnode->vSendMsg.empty();",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pnode->m_sock_mutex)",
          "old_line_content": "        if (select_send) {",
          "new_line_content": "        LOCK(pnode->m_sock_mutex);",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": null,
          "new_api": "emplace",
          "old_text": null,
          "new_text": "events_per_sock.emplace(pnode->m_sock, Sock::Events{requested})",
          "old_line_content": "void CConnman::SocketHandler()",
          "new_line_content": "        events_per_sock.emplace(pnode->m_sock, Sock::Events{requested});",
          "content_same": false
        },
        {
          "line": 1240,
          "old_api": null,
          "new_api": "AssertLockNotHeld",
          "old_text": null,
          "new_text": "AssertLockNotHeld(m_total_bytes_sent_mutex)",
          "old_line_content": "",
          "new_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "content_same": false
        },
        {
          "line": 1254,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "events_per_sock.begin()->first->WaitMany(timeout, events_per_sock)",
          "old_line_content": "    }",
          "new_line_content": "        if (events_per_sock.empty() || !events_per_sock.begin()->first->WaitMany(timeout, events_per_sock)) {",
          "content_same": false
        },
        {
          "line": 1255,
          "old_api": null,
          "new_api": "sleep_for",
          "old_text": null,
          "new_text": "interruptNet.sleep_for(timeout)",
          "old_line_content": "",
          "new_line_content": "            interruptNet.sleep_for(timeout);",
          "content_same": false
        },
        {
          "line": 1259,
          "old_api": null,
          "new_api": "Nodes",
          "old_text": null,
          "new_text": "snap.Nodes()",
          "old_line_content": "",
          "new_line_content": "        SocketHandlerConnected(snap.Nodes(), events_per_sock);",
          "content_same": false
        },
        {
          "line": 1269,
          "old_api": null,
          "new_api": "AssertLockNotHeld",
          "old_text": null,
          "new_text": "AssertLockNotHeld(m_total_bytes_sent_mutex)",
          "old_line_content": "        //",
          "new_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "content_same": false
        },
        {
          "line": 1282,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pnode->m_sock_mutex)",
          "old_line_content": "                recvSet = it->second.occurred & Sock::RECV;",
          "new_line_content": "            LOCK(pnode->m_sock_mutex);",
          "content_same": false
        },
        {
          "line": 1286,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "events_per_sock.find(pnode->m_sock)",
          "old_line_content": "        }",
          "new_line_content": "            const auto it = events_per_sock.find(pnode->m_sock);",
          "content_same": false
        },
        {
          "line": 1287,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "events_per_sock.end()",
          "old_line_content": "        if (recvSet || errorSet)",
          "new_line_content": "            if (it != events_per_sock.end()) {",
          "content_same": false
        },
        {
          "line": 1299,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pnode->m_sock_mutex)",
          "old_line_content": "            if (nBytes > 0)",
          "new_line_content": "                LOCK(pnode->m_sock_mutex);",
          "content_same": false
        },
        {
          "line": 1308,
          "old_api": null,
          "new_api": "ReceiveMsgBytes",
          "old_text": null,
          "new_text": "pnode->ReceiveMsgBytes({pchBuf, (size_t)nBytes}, notify)",
          "old_line_content": "                    for (const auto& msg : pnode->vRecvMsg) {",
          "new_line_content": "                if (!pnode->ReceiveMsgBytes({pchBuf, (size_t)nBytes}, notify)) {",
          "content_same": false
        },
        {
          "line": 1309,
          "old_api": null,
          "new_api": "CloseSocketDisconnect",
          "old_text": null,
          "new_text": "pnode->CloseSocketDisconnect()",
          "old_line_content": "                        // vRecvMsg contains only completed CNetMessage",
          "new_line_content": "                    pnode->CloseSocketDisconnect();",
          "content_same": false
        },
        {
          "line": 1311,
          "old_api": null,
          "new_api": "RecordBytesRecv",
          "old_text": null,
          "new_text": "RecordBytesRecv(nBytes)",
          "old_line_content": "                        nSizeAdded += msg.m_raw_message_size;",
          "new_line_content": "                RecordBytesRecv(nBytes);",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(pnode->cs_vProcessMsg)",
          "old_line_content": "                }",
          "new_line_content": "                        LOCK(pnode->cs_vProcessMsg);",
          "content_same": false
        },
        {
          "line": 1321,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "pnode->vProcessMsg.end()",
          "old_line_content": "            }",
          "new_line_content": "                        pnode->vProcessMsg.splice(pnode->vProcessMsg.end(), pnode->vRecvMsg);",
          "content_same": false
        },
        {
          "line": 1325,
          "old_api": null,
          "new_api": "WakeMessageHandler",
          "old_text": null,
          "new_text": "WakeMessageHandler()",
          "old_line_content": "                if (!pnode->fDisconnect) {",
          "new_line_content": "                    WakeMessageHandler();",
          "content_same": false
        },
        {
          "line": 1332,
          "old_api": null,
          "new_api": "GetId",
          "old_text": null,
          "new_text": "pnode->GetId()",
          "old_line_content": "                // error",
          "new_line_content": "                    LogPrint(BCLog::NET, \"socket closed for peer=%d\\n\", pnode->GetId());",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": null,
          "new_api": "CloseSocketDisconnect",
          "old_text": null,
          "new_text": "pnode->CloseSocketDisconnect()",
          "old_line_content": "                if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)",
          "new_line_content": "                pnode->CloseSocketDisconnect();",
          "content_same": false
        },
        {
          "line": 1343,
          "old_api": null,
          "new_api": "NetworkErrorString",
          "old_text": null,
          "new_text": "NetworkErrorString(nErr)",
          "old_line_content": "",
          "new_line_content": "                        LogPrint(BCLog::NET, \"socket recv error for peer=%d: %s\\n\", pnode->GetId(), NetworkErrorString(nErr));",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": null,
          "new_api": "CloseSocketDisconnect",
          "old_text": null,
          "new_text": "pnode->CloseSocketDisconnect()",
          "old_line_content": "            // Send data",
          "new_line_content": "                    pnode->CloseSocketDisconnect();",
          "content_same": false
        },
        {
          "line": 1352,
          "old_api": null,
          "new_api": "SocketSendData",
          "old_text": null,
          "new_text": "SocketSendData(*pnode)",
          "old_line_content": "}",
          "new_line_content": "            size_t bytes_sent = WITH_LOCK(pnode->cs_vSend, return SocketSendData(*pnode));",
          "content_same": false
        },
        {
          "line": 1353,
          "old_api": null,
          "new_api": "RecordBytesSent",
          "old_text": null,
          "new_text": "RecordBytesSent(bytes_sent)",
          "old_line_content": "",
          "new_line_content": "            if (bytes_sent) RecordBytesSent(bytes_sent);",
          "content_same": false
        },
        {
          "line": 1356,
          "old_api": null,
          "new_api": "InactivityCheck",
          "old_text": null,
          "new_text": "InactivityCheck(*pnode)",
          "old_line_content": "    for (const ListenSocket& listen_socket : vhListenSocket) {",
          "new_line_content": "        if (InactivityCheck(*pnode)) pnode->fDisconnect = true;",
          "content_same": false
        },
        {
          "line": 1366,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "events_per_sock.find(listen_socket.sock)",
          "old_line_content": "",
          "new_line_content": "        const auto it = events_per_sock.find(listen_socket.sock);",
          "content_same": false
        },
        {
          "line": 1367,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "events_per_sock.end()",
          "old_line_content": "void CConnman::ThreadSocketHandler()",
          "new_line_content": "        if (it != events_per_sock.end() && it->second.occurred & Sock::RECV) {",
          "content_same": false
        },
        {
          "line": 1368,
          "old_api": null,
          "new_api": "AcceptConnection",
          "old_text": null,
          "new_text": "AcceptConnection(listen_socket)",
          "old_line_content": "{",
          "new_line_content": "            AcceptConnection(listen_socket);",
          "content_same": false
        },
        {
          "line": 1377,
          "old_api": null,
          "new_api": "SetSyscallSandboxPolicy",
          "old_text": null,
          "new_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET)",
          "old_line_content": "    }",
          "new_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET);",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": null,
          "new_api": "DisconnectNodes",
          "old_text": null,
          "new_text": "DisconnectNodes()",
          "old_line_content": "void CConnman::WakeMessageHandler()",
          "new_line_content": "        DisconnectNodes();",
          "content_same": false
        },
        {
          "line": 1381,
          "old_api": null,
          "new_api": "NotifyNumConnectionsChanged",
          "old_text": null,
          "new_text": "NotifyNumConnectionsChanged()",
          "old_line_content": "{",
          "new_line_content": "        NotifyNumConnectionsChanged();",
          "content_same": false
        },
        {
          "line": 1382,
          "old_api": null,
          "new_api": "SocketHandler",
          "old_text": null,
          "new_text": "SocketHandler()",
          "old_line_content": "    {",
          "new_line_content": "        SocketHandler();",
          "content_same": false
        },
        {
          "line": 1389,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(mutexMsgProc)",
          "old_line_content": "void CConnman::ThreadDNSAddressSeed()",
          "new_line_content": "        LOCK(mutexMsgProc);",
          "content_same": false
        },
        {
          "line": 1392,
          "old_api": null,
          "new_api": "notify_one",
          "old_text": null,
          "new_text": "condMsgProc.notify_one()",
          "old_line_content": "    FastRandomContext rng;",
          "new_line_content": "    condMsgProc.notify_one();",
          "content_same": false
        },
        {
          "line": 1397,
          "old_api": null,
          "new_api": "SetSyscallSandboxPolicy",
          "old_text": null,
          "new_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::INITIALIZATION_DNS_SEED)",
          "old_line_content": "",
          "new_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::INITIALIZATION_DNS_SEED);",
          "content_same": false
        },
        {
          "line": 1399,
          "old_api": null,
          "new_api": "DNSSeeds",
          "old_text": null,
          "new_text": "Params().DNSSeeds()",
          "old_line_content": "        // When -forcednsseed is provided, query all.",
          "new_line_content": "    std::vector<std::string> seeds = Params().DNSSeeds();",
          "content_same": false
        },
        {
          "line": 1404,
          "old_api": null,
          "new_api": "GetBoolArg",
          "old_text": null,
          "new_text": "gArgs.GetBoolArg(\"-forcednsseed\", DEFAULT_FORCEDNSSEED)",
          "old_line_content": "        // deleted.",
          "new_line_content": "    if (gArgs.GetBoolArg(\"-forcednsseed\", DEFAULT_FORCEDNSSEED)) {",
          "content_same": false
        },
        {
          "line": 1406,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "seeds.size()",
          "old_line_content": "    }",
          "new_line_content": "        seeds_right_now = seeds.size();",
          "content_same": false
        },
        {
          "line": 1407,
          "old_api": null,
          "new_api": "Size",
          "old_text": null,
          "new_text": "addrman.Size()",
          "old_line_content": "",
          "new_line_content": "    } else if (addrman.Size() == 0) {",
          "content_same": false
        },
        {
          "line": 1411,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "seeds.size()",
          "old_line_content": "    //   creating fewer identifying DNS requests, reduces trust by",
          "new_line_content": "        seeds_right_now = seeds.size();",
          "content_same": false
        },
        {
          "line": 1432,
          "old_api": null,
          "new_api": "Size",
          "old_text": null,
          "new_text": "addrman.Size()",
          "old_line_content": "                    // this thread entirely freeing up its resources",
          "new_line_content": "            if (addrman.Size() > 0) {",
          "content_same": false
        },
        {
          "line": 1435,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "to_wait.count()",
          "old_line_content": "                    to_wait -= w;",
          "new_line_content": "                while (to_wait.count() > 0) {",
          "content_same": false
        },
        {
          "line": 1440,
          "old_api": null,
          "new_api": "sleep_for",
          "old_text": null,
          "new_text": "interruptNet.sleep_for(w)",
          "old_line_content": "                        for (const CNode* pnode : m_nodes) {",
          "new_line_content": "                    if (!interruptNet.sleep_for(w)) return;",
          "content_same": false
        },
        {
          "line": 1445,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "                        if (found > 0) {",
          "new_line_content": "                        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1452,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"%d addresses found from DNS seeds\\n\", found)",
          "old_line_content": "                    }",
          "new_line_content": "                            LogPrintf(\"%d addresses found from DNS seeds\\n\", found);",
          "content_same": false
        },
        {
          "line": 1453,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"P2P peers available. Finished DNS seeding.\\n\")",
          "old_line_content": "                }",
          "new_line_content": "                            LogPrintf(\"P2P peers available. Finished DNS seeding.\\n\");",
          "content_same": false
        },
        {
          "line": 1455,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"P2P peers available. Skipped DNS seeding.\\n\")",
          "old_line_content": "        }",
          "new_line_content": "                            LogPrintf(\"P2P peers available. Skipped DNS seeding.\\n\");",
          "content_same": false
        },
        {
          "line": 1475,
          "old_api": null,
          "new_api": "AddAddrFetch",
          "old_text": null,
          "new_text": "AddAddrFetch(seed)",
          "old_line_content": "            CNetAddr resolveSource;",
          "new_line_content": "            AddAddrFetch(seed);",
          "content_same": false
        },
        {
          "line": 1479,
          "old_api": null,
          "new_api": "GetDesirableServiceFlags",
          "old_text": null,
          "new_text": "GetDesirableServiceFlags(NODE_NONE)",
          "old_line_content": "            unsigned int nMaxIPs = 256; // Limits number of IPs learned from a DNS seed",
          "new_line_content": "            ServiceFlags requiredServiceBits = GetDesirableServiceFlags(NODE_NONE);",
          "content_same": false
        },
        {
          "line": 1486,
          "old_api": null,
          "new_api": "LookupHost",
          "old_text": null,
          "new_text": "LookupHost(host, vIPs, nMaxIPs, true)",
          "old_line_content": "                }",
          "new_line_content": "            if (LookupHost(host, vIPs, nMaxIPs, true)) {",
          "content_same": false
        },
        {
          "line": 1488,
          "old_api": null,
          "new_api": "GetDefaultPort",
          "old_text": null,
          "new_text": "Params().GetDefaultPort()",
          "old_line_content": "            } else {",
          "new_line_content": "                    CAddress addr = CAddress(CService(ip, Params().GetDefaultPort()), requiredServiceBits);",
          "content_same": false
        },
        {
          "line": 1489,
          "old_api": null,
          "new_api": "Now<NodeSeconds>()",
          "old_text": null,
          "new_text": "Now<NodeSeconds>()",
          "old_line_content": "                // We now avoid directly using results from DNS Seeds which do not support service bit filtering,",
          "new_line_content": "                    addr.nTime = rng.rand_uniform_delay(Now<NodeSeconds>() - 3 * 24h, -4 * 24h); // use a random age between 3 and 7 days old",
          "content_same": false
        },
        {
          "line": 1490,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "vAdd.push_back(addr)",
          "old_line_content": "                // instead using them as a addrfetch to get nodes with our desired service bits.",
          "new_line_content": "                    vAdd.push_back(addr);",
          "content_same": false
        },
        {
          "line": 1493,
          "old_api": null,
          "new_api": "Add",
          "old_text": null,
          "new_text": "addrman.Add(vAdd, resolveSource)",
          "old_line_content": "        }",
          "new_line_content": "                addrman.Add(vAdd, resolveSource);",
          "content_same": false
        },
        {
          "line": 1497,
          "old_api": null,
          "new_api": "AddAddrFetch",
          "old_text": null,
          "new_text": "AddAddrFetch(seed)",
          "old_line_content": "}",
          "new_line_content": "                AddAddrFetch(seed);",
          "content_same": false
        },
        {
          "line": 1502,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"%d addresses found from DNS seeds\\n\", found)",
          "old_line_content": "",
          "new_line_content": "    LogPrintf(\"%d addresses found from DNS seeds\\n\", found);",
          "content_same": false
        },
        {
          "line": 1507,
          "old_api": null,
          "new_api": "SteadyClock::now()",
          "old_text": null,
          "new_text": "SteadyClock::now()",
          "old_line_content": "}",
          "new_line_content": "    const auto start{SteadyClock::now()};",
          "content_same": false
        },
        {
          "line": 1509,
          "old_api": null,
          "new_api": "DumpPeerAddresses",
          "old_text": null,
          "new_text": "DumpPeerAddresses(::gArgs, addrman)",
          "old_line_content": "void CConnman::ProcessAddrFetch()",
          "new_line_content": "    DumpPeerAddresses(::gArgs, addrman);",
          "content_same": false
        },
        {
          "line": 1511,
          "old_api": null,
          "new_api": "Size",
          "old_text": null,
          "new_text": "LogPrint(BCLog::NET, \"Flushed %d addresses to peers.dat  %dms\\n\",\n             addrman.Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start))",
          "old_line_content": "    std::string strDest;",
          "new_line_content": "    LogPrint(BCLog::NET, \"Flushed %d addresses to peers.dat  %dms\\n\",",
          "content_same": false
        },
        {
          "line": 1512,
          "old_api": null,
          "new_api": "SteadyClock::now()",
          "old_text": null,
          "new_text": "SteadyClock::now()",
          "old_line_content": "    {",
          "new_line_content": "             addrman.Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));",
          "content_same": false
        },
        {
          "line": 1519,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_addr_fetches_mutex)",
          "old_line_content": "    CAddress addr;",
          "new_line_content": "        LOCK(m_addr_fetches_mutex);",
          "content_same": false
        },
        {
          "line": 1520,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "m_addr_fetches.empty()",
          "old_line_content": "    CSemaphoreGrant grant(*semOutbound, true);",
          "new_line_content": "        if (m_addr_fetches.empty())",
          "content_same": false
        },
        {
          "line": 1523,
          "old_api": null,
          "new_api": "pop_front",
          "old_text": null,
          "new_text": "m_addr_fetches.pop_front()",
          "old_line_content": "    }",
          "new_line_content": "        m_addr_fetches.pop_front();",
          "content_same": false
        },
        {
          "line": 1528,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "strDest.c_str()",
          "old_line_content": "    return m_try_another_outbound_peer;",
          "new_line_content": "        OpenNetworkConnection(addr, false, &grant, strDest.c_str(), ConnectionType::ADDR_FETCH);",
          "content_same": false
        },
        {
          "line": 1540,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::NET, \"setting try another outbound peer=%s\\n\", flag ? \"true\" : \"false\")",
          "old_line_content": "    m_start_extra_block_relay_peers = true;",
          "new_line_content": "    LogPrint(BCLog::NET, \"setting try another outbound peer=%s\\n\", flag ? \"true\" : \"false\");",
          "content_same": false
        },
        {
          "line": 1545,
          "old_api": null,
          "new_api": "LogPrint",
          "old_text": null,
          "new_text": "LogPrint(BCLog::NET, \"enabling extra block-relay-only peers\\n\")",
          "old_line_content": "// disconnected soon (eg ADDR_FETCH and FEELER)",
          "new_line_content": "    LogPrint(BCLog::NET, \"enabling extra block-relay-only peers\\n\");",
          "content_same": false
        },
        {
          "line": 1559,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "    }",
          "new_line_content": "        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1561,
          "old_api": null,
          "new_api": "IsFullOutboundConn",
          "old_text": null,
          "new_text": "pnode->IsFullOutboundConn()",
          "old_line_content": "}",
          "new_line_content": "            if (pnode->fSuccessfullyConnected && !pnode->fDisconnect && pnode->IsFullOutboundConn()) {",
          "content_same": false
        },
        {
          "line": 1566,
          "old_api": null,
          "new_api": "std::max(full_outbound_peers - m_max_outbound_full_relay, 0)",
          "old_text": null,
          "new_text": "std::max(full_outbound_peers - m_max_outbound_full_relay, 0)",
          "old_line_content": "    {",
          "new_line_content": "    return std::max(full_outbound_peers - m_max_outbound_full_relay, 0);",
          "content_same": false
        },
        {
          "line": 1573,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "    }",
          "new_line_content": "        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1575,
          "old_api": null,
          "new_api": "IsBlockOnlyConn",
          "old_text": null,
          "new_text": "pnode->IsBlockOnlyConn()",
          "old_line_content": "}",
          "new_line_content": "            if (pnode->fSuccessfullyConnected && !pnode->fDisconnect && pnode->IsBlockOnlyConn()) {",
          "content_same": false
        },
        {
          "line": 1580,
          "old_api": null,
          "new_api": "std::max(block_relay_peers - m_max_outbound_block_relay, 0)",
          "old_text": null,
          "new_text": "std::max(block_relay_peers - m_max_outbound_block_relay, 0)",
          "old_line_content": "    for (int n = 0; n < NET_MAX; n++) {",
          "new_line_content": "    return std::max(block_relay_peers - m_max_outbound_block_relay, 0);",
          "content_same": false
        },
        {
          "line": 1589,
          "old_api": null,
          "new_api": "Size",
          "old_text": null,
          "new_text": "addrman.Size(net, std::nullopt)",
          "old_line_content": "",
          "new_line_content": "        if (IsReachable(net) && addrman.Size(net, std::nullopt) == 0) {",
          "content_same": false
        },
        {
          "line": 1590,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "networks.insert(net)",
          "old_line_content": "void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)",
          "new_line_content": "            networks.insert(net);",
          "content_same": false
        },
        {
          "line": 1598,
          "old_api": null,
          "new_api": "SetSyscallSandboxPolicy",
          "old_text": null,
          "new_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET_OPEN_CONNECTION)",
          "old_line_content": "        {",
          "new_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET_OPEN_CONNECTION);",
          "content_same": false
        },
        {
          "line": 1601,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "connect.empty()",
          "old_line_content": "            {",
          "new_line_content": "    if (!connect.empty())",
          "content_same": false
        },
        {
          "line": 1605,
          "old_api": null,
          "new_api": "ProcessAddrFetch",
          "old_text": null,
          "new_text": "ProcessAddrFetch()",
          "old_line_content": "                {",
          "new_line_content": "            ProcessAddrFetch();",
          "content_same": false
        },
        {
          "line": 1609,
          "old_api": null,
          "new_api": "c_str",
          "old_text": null,
          "new_text": "strAddr.c_str()",
          "old_line_content": "            }",
          "new_line_content": "                OpenNetworkConnection(addr, false, nullptr, strAddr.c_str(), ConnectionType::MANUAL);",
          "content_same": false
        },
        {
          "line": 1612,
          "old_api": null,
          "new_api": "std::chrono::milliseconds(500)",
          "old_text": null,
          "new_text": "std::chrono::milliseconds(500)",
          "old_line_content": "        }",
          "new_line_content": "                    if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))",
          "content_same": false
        },
        {
          "line": 1626,
          "old_api": null,
          "new_api": "GetExponentialRand",
          "old_text": null,
          "new_text": "GetExponentialRand(start, EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL)",
          "old_line_content": "    }",
          "new_line_content": "    auto next_extra_block_relay = GetExponentialRand(start, EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL);",
          "content_same": false
        },
        {
          "line": 1627,
          "old_api": null,
          "new_api": "GetBoolArg",
          "old_text": null,
          "new_text": "gArgs.GetBoolArg(\"-dnsseed\", DEFAULT_DNSSEED)",
          "old_line_content": "",
          "new_line_content": "    const bool dnsseed = gArgs.GetBoolArg(\"-dnsseed\", DEFAULT_DNSSEED);",
          "content_same": false
        },
        {
          "line": 1628,
          "old_api": null,
          "new_api": "GetBoolArg",
          "old_text": null,
          "new_text": "gArgs.GetBoolArg(\"-fixedseeds\", DEFAULT_FIXEDSEEDS)",
          "old_line_content": "    while (!interruptNet)",
          "new_line_content": "    bool add_fixed_seeds = gArgs.GetBoolArg(\"-fixedseeds\", DEFAULT_FIXEDSEEDS);",
          "content_same": false
        },
        {
          "line": 1631,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"Fixed seeds are disabled\\n\")",
          "old_line_content": "",
          "new_line_content": "        LogPrintf(\"Fixed seeds are disabled\\n\");",
          "content_same": false
        },
        {
          "line": 1636,
          "old_api": null,
          "new_api": "ProcessAddrFetch",
          "old_text": null,
          "new_text": "ProcessAddrFetch()",
          "old_line_content": "        if (interruptNet)",
          "new_line_content": "        ProcessAddrFetch();",
          "content_same": false
        },
        {
          "line": 1638,
          "old_api": null,
          "new_api": "std::chrono::milliseconds(500)",
          "old_text": null,
          "new_text": "std::chrono::milliseconds(500)",
          "old_line_content": "",
          "new_line_content": "        if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))",
          "content_same": false
        },
        {
          "line": 1645,
          "old_api": null,
          "new_api": "GetReachableEmptyNetworks",
          "old_text": null,
          "new_text": "GetReachableEmptyNetworks()",
          "old_line_content": "            bool add_fixed_seeds_now = false;",
          "new_line_content": "        const std::unordered_set<Network> fixed_seed_networks{GetReachableEmptyNetworks()};",
          "content_same": false
        },
        {
          "line": 1646,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "fixed_seed_networks.empty()",
          "old_line_content": "            // It is cheapest to check if enough time has passed first.",
          "new_line_content": "        if (add_fixed_seeds && !fixed_seed_networks.empty()) {",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": null,
          "new_api": "GetTime<std::chrono::seconds>()",
          "old_text": null,
          "new_text": "GetTime<std::chrono::seconds>()",
          "old_line_content": "            if (!add_fixed_seeds_now && !dnsseed) {",
          "new_line_content": "            if (GetTime<std::chrono::seconds>() > start + std::chrono::minutes{1}) {",
          "content_same": false
        },
        {
          "line": 1660,
          "old_api": null,
          "new_api": "LOCK2",
          "old_text": null,
          "new_text": "LOCK2(m_addr_fetches_mutex, m_added_nodes_mutex)",
          "old_line_content": "",
          "new_line_content": "                LOCK2(m_addr_fetches_mutex, m_added_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1661,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "m_added_nodes.empty()",
          "old_line_content": "            if (add_fixed_seeds_now) {",
          "new_line_content": "                if (m_addr_fetches.empty() && m_added_nodes.empty()) {",
          "content_same": false
        },
        {
          "line": 1663,
          "old_api": null,
          "new_api": "LogPrintf",
          "old_text": null,
          "new_text": "LogPrintf(\"Adding fixed seeds as -dnsseed=0 (or IPv4/IPv6 connections are disabled via -onlynet), -addnode is not provided and all -seednode(s) attempted\\n\")",
          "old_line_content": "                // We will not make outgoing connections to peers that are unreachable",
          "new_line_content": "                    LogPrintf(\"Adding fixed seeds as -dnsseed=0 (or IPv4/IPv6 connections are disabled via -onlynet), -addnode is not provided and all -seednode(s) attempted\\n\");",
          "content_same": false
        },
        {
          "line": 1668,
          "old_api": null,
          "new_api": "FixedSeeds",
          "old_text": null,
          "new_text": "Params().FixedSeeds()",
          "old_line_content": "                // be loaded only for networks for which we have no addressses.",
          "new_line_content": "                std::vector<CAddress> seed_addrs{ConvertSeeds(Params().FixedSeeds())};",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "seed_addrs.end()",
          "old_line_content": "                add_fixed_seeds = false;",
          "new_line_content": "                seed_addrs.erase(std::remove_if(seed_addrs.begin(), seed_addrs.end(),",
          "content_same": false
        },
        {
          "line": 1677,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "seed_addrs.end()",
          "old_line_content": "            }",
          "new_line_content": "                                 seed_addrs.end());",
          "content_same": false
        },
        {
          "line": 1679,
          "old_api": null,
          "new_api": "SetInternal",
          "old_text": null,
          "new_text": "local.SetInternal(\"fixedseeds\")",
          "old_line_content": "",
          "new_line_content": "                local.SetInternal(\"fixedseeds\");",
          "content_same": false
        },
        {
          "line": 1680,
          "old_api": null,
          "new_api": "Add",
          "old_text": null,
          "new_text": "addrman.Add(seed_addrs, local)",
          "old_line_content": "        //",
          "new_line_content": "                addrman.Add(seed_addrs, local);",
          "content_same": false
        },
        {
          "line": 1682,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "seed_addrs.size()",
          "old_line_content": "        //",
          "new_line_content": "                LogPrintf(\"Added %d fixed seeds from reachable networks.\\n\", seed_addrs.size());",
          "content_same": false
        },
        {
          "line": 1697,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "                // is to not use multiple of our limited outbound slots on a single netgroup",
          "new_line_content": "            LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1699,
          "old_api": null,
          "new_api": "IsFullOutboundConn",
          "old_text": null,
          "new_text": "pnode->IsFullOutboundConn()",
          "old_line_content": "                // also have the added issue that they could be attacker controlled and used",
          "new_line_content": "                if (pnode->IsFullOutboundConn()) nOutboundFullRelay++;",
          "content_same": false
        },
        {
          "line": 1700,
          "old_api": null,
          "new_api": "IsBlockOnlyConn",
          "old_text": null,
          "new_text": "pnode->IsBlockOnlyConn()",
          "old_line_content": "                // to prevent us from connecting to particular hosts if we used them here.",
          "new_line_content": "                if (pnode->IsBlockOnlyConn()) nOutboundBlockRelay++;",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": null,
          "new_api": "GetTime<std::chrono::microseconds>()",
          "old_text": null,
          "new_text": "GetTime<std::chrono::microseconds>()",
          "old_line_content": "        // priority. Then we open OUTBOUND_FULL_RELAY priority until we",
          "new_line_content": "        auto now = GetTime<std::chrono::microseconds>();",
          "content_same": false
        },
        {
          "line": 1736,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "m_anchors.empty()",
          "old_line_content": "            conn_type = ConnectionType::BLOCK_RELAY;",
          "new_line_content": "        if (!m_anchors.empty() && (nOutboundBlockRelay < m_max_outbound_block_relay)) {",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": null,
          "new_api": "GetTryNewOutboundPeer",
          "old_text": null,
          "new_text": "GetTryNewOutboundPeer()",
          "old_line_content": "            //",
          "new_line_content": "        } else if (GetTryNewOutboundPeer()) {",
          "content_same": false
        },
        {
          "line": 1767,
          "old_api": null,
          "new_api": "GetExponentialRand",
          "old_text": null,
          "new_text": "GetExponentialRand(now, EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL)",
          "old_line_content": "        } else {",
          "new_line_content": "            next_extra_block_relay = GetExponentialRand(now, EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL);",
          "content_same": false
        },
        {
          "line": 1770,
          "old_api": null,
          "new_api": "GetExponentialRand",
          "old_text": null,
          "new_text": "GetExponentialRand(now, FEELER_INTERVAL)",
          "old_line_content": "        }",
          "new_line_content": "            next_feeler = GetExponentialRand(now, FEELER_INTERVAL);",
          "content_same": false
        },
        {
          "line": 1784,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "m_anchors.empty()",
          "old_line_content": "                addrConnect = addr;",
          "new_line_content": "            if (anchor && !m_anchors.empty()) {",
          "content_same": false
        },
        {
          "line": 1786,
          "old_api": null,
          "new_api": "pop_back",
          "old_text": null,
          "new_text": "m_anchors.pop_back()",
          "old_line_content": "                break;",
          "new_line_content": "                m_anchors.pop_back();",
          "content_same": false
        },
        {
          "line": 1787,
          "old_api": null,
          "new_api": "IsReachable",
          "old_text": null,
          "new_text": "IsReachable(addr)",
          "old_line_content": "            }",
          "new_line_content": "                if (!addr.IsValid() || IsLocal(addr) || !IsReachable(addr) ||",
          "content_same": false
        },
        {
          "line": 1788,
          "old_api": null,
          "new_api": "HasAllDesirableServiceFlags",
          "old_text": null,
          "new_text": "HasAllDesirableServiceFlags(addr.nServices)",
          "old_line_content": "",
          "new_line_content": "                    !HasAllDesirableServiceFlags(addr.nServices) ||",
          "content_same": false
        },
        {
          "line": 1789,
          "old_api": null,
          "new_api": "GetGroup",
          "old_text": null,
          "new_text": "m_netgroupman.GetGroup(addr)",
          "old_line_content": "            // If we didn't find an appropriate destination after trying 100 addresses fetched from addrman,",
          "new_line_content": "                    setConnected.count(m_netgroupman.GetGroup(addr))) continue;",
          "content_same": false
        },
        {
          "line": 1791,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "addrConnect.ToString()",
          "old_line_content": "            // already-connected network ranges, ...) before trying new addrman addresses.",
          "new_line_content": "                LogPrint(BCLog::NET, \"Trying to make an anchor connection to %s\\n\", addrConnect.ToString());",
          "content_same": false
        },
        {
          "line": 1810,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "addr.IsValid()",
          "old_line_content": "                    // peer that we're already connected to, just mark that",
          "new_line_content": "                if (!addr.IsValid()) {",
          "content_same": false
        },
        {
          "line": 1813,
          "old_api": null,
          "new_api": "Select",
          "old_text": null,
          "new_text": "addrman.Select(true)",
          "old_line_content": "                    // a currently-connected peer.",
          "new_line_content": "                    std::tie(addr, addr_last_try) = addrman.Select(true);",
          "content_same": false
        },
        {
          "line": 1822,
          "old_api": null,
          "new_api": "Select",
          "old_text": null,
          "new_text": "addrman.Select(true)",
          "old_line_content": "",
          "new_line_content": "                    std::tie(addr, addr_last_try) = addrman.Select(true);",
          "content_same": false
        },
        {
          "line": 1826,
          "old_api": null,
          "new_api": "Select",
          "old_text": null,
          "new_text": "addrman.Select()",
          "old_line_content": "            }",
          "new_line_content": "                std::tie(addr, addr_last_try) = addrman.Select();",
          "content_same": false
        },
        {
          "line": 1830,
          "old_api": null,
          "new_api": "GetGroup",
          "old_text": null,
          "new_text": "m_netgroupman.GetGroup(addr)",
          "old_line_content": "                break;",
          "new_line_content": "            if (!fFeeler && setConnected.count(m_netgroupman.GetGroup(addr))) {",
          "content_same": false
        },
        {
          "line": 1835,
          "old_api": null,
          "new_api": "IsLocal",
          "old_text": null,
          "new_text": "IsLocal(addr)",
          "old_line_content": "",
          "new_line_content": "            if (!addr.IsValid() || IsLocal(addr)) {",
          "content_same": false
        },
        {
          "line": 1839,
          "old_api": null,
          "new_api": "IsReachable",
          "old_text": null,
          "new_text": "IsReachable(addr)",
          "old_line_content": "            }",
          "new_line_content": "            if (!IsReachable(addr))",
          "content_same": false
        },
        {
          "line": 1850,
          "old_api": null,
          "new_api": "HasAllDesirableServiceFlags",
          "old_text": null,
          "new_text": "HasAllDesirableServiceFlags(addr.nServices)",
          "old_line_content": "            // Do not connect to bad ports, unless 50 invalid addresses have been selected already.",
          "new_line_content": "            if (!fFeeler && !HasAllDesirableServiceFlags(addr.nServices)) {",
          "content_same": false
        },
        {
          "line": 1852,
          "old_api": null,
          "new_api": "MayHaveUsefulAddressDB",
          "old_text": null,
          "new_text": "MayHaveUsefulAddressDB(addr.nServices)",
          "old_line_content": "                continue;",
          "new_line_content": "            } else if (fFeeler && !MayHaveUsefulAddressDB(addr.nServices)) {",
          "content_same": false
        },
        {
          "line": 1857,
          "old_api": null,
          "new_api": "GetPort",
          "old_text": null,
          "new_text": "addr.GetPort()",
          "old_line_content": "        }",
          "new_line_content": "            if (nTries < 50 && (addr.IsIPv4() || addr.IsIPv6()) && IsBadPort(addr.GetPort())) {",
          "content_same": false
        },
        {
          "line": 1871,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "addrConnect.ToString()",
          "old_line_content": "}",
          "new_line_content": "                LogPrint(BCLog::NET, \"Making feeler connection to %s\\n\", addrConnect.ToString());",
          "content_same": false
        },
        {
          "line": 1874,
          "old_api": null,
          "new_api": "std::min(nMaxConnections - 1, 2)",
          "old_text": null,
          "new_text": "std::min(nMaxConnections - 1, 2)",
          "old_line_content": "{",
          "new_line_content": "            OpenNetworkConnection(addrConnect, (int)setConnected.size() >= std::min(nMaxConnections - 1, 2), &grant, nullptr, conn_type);",
          "content_same": false
        },
        {
          "line": 1882,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "",
          "new_line_content": "    LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1884,
          "old_api": null,
          "new_api": "IsBlockOnlyConn",
          "old_text": null,
          "new_text": "pnode->IsBlockOnlyConn()",
          "old_line_content": "}",
          "new_line_content": "        if (pnode->IsBlockOnlyConn()) {",
          "content_same": false
        },
        {
          "line": 1885,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "ret.push_back(pnode->addr)",
          "old_line_content": "",
          "new_line_content": "            ret.push_back(pnode->addr);",
          "content_same": false
        },
        {
          "line": 1898,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_added_nodes_mutex)",
          "old_line_content": "    // Build a map of all already connected addresses (by IP:port and by name) to inbound/outbound and resolved CService",
          "new_line_content": "        LOCK(m_added_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 1899,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "m_added_nodes.size()",
          "old_line_content": "    std::map<CService, bool> mapConnected;",
          "new_line_content": "        ret.reserve(m_added_nodes.size());",
          "content_same": false
        },
        {
          "line": 1900,
          "old_api": null,
          "new_api": "std::back_inserter(lAddresses)",
          "old_text": null,
          "new_text": "std::back_inserter(lAddresses)",
          "old_line_content": "    std::map<std::string, std::pair<bool, CService>> mapConnectedByName;",
          "new_line_content": "        std::copy(m_added_nodes.cbegin(), m_added_nodes.cend(), std::back_inserter(lAddresses));",
          "content_same": false
        },
        {
          "line": 1910,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "pnode->addr.IsValid()",
          "old_line_content": "            }",
          "new_line_content": "            if (pnode->addr.IsValid()) {",
          "content_same": false
        },
        {
          "line": 1911,
          "old_api": null,
          "new_api": "IsInboundConn",
          "old_text": null,
          "new_text": "pnode->IsInboundConn()",
          "old_line_content": "        }",
          "new_line_content": "                mapConnected[pnode->addr] = pnode->IsInboundConn();",
          "content_same": false
        },
        {
          "line": 1914,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "addrName.empty()",
          "old_line_content": "    for (const std::string& strAddNode : lAddresses) {",
          "new_line_content": "            if (!addrName.empty()) {",
          "content_same": false
        },
        {
          "line": 1921,
          "old_api": null,
          "new_api": "GetDefaultPort",
          "old_text": null,
          "new_text": "Params().GetDefaultPort(strAddNode)",
          "old_line_content": "                addedNode.resolvedAddress = service;",
          "new_line_content": "        CService service(LookupNumeric(strAddNode, Params().GetDefaultPort(strAddNode)));",
          "content_same": false
        },
        {
          "line": 1922,
          "old_api": null,
          "new_api": "CService",
          "old_text": null,
          "new_text": "CService()",
          "old_line_content": "                addedNode.fConnected = true;",
          "new_line_content": "        AddedNodeInfo addedNode{strAddNode, CService(), false, false};",
          "content_same": false
        },
        {
          "line": 1923,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "service.IsValid()",
          "old_line_content": "                addedNode.fInbound = it->second;",
          "new_line_content": "        if (service.IsValid()) {",
          "content_same": false
        },
        {
          "line": 1925,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "mapConnected.find(service)",
          "old_line_content": "        } else {",
          "new_line_content": "            auto it = mapConnected.find(service);",
          "content_same": false
        },
        {
          "line": 1926,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapConnected.end()",
          "old_line_content": "            // strAddNode is a name",
          "new_line_content": "            if (it != mapConnected.end()) {",
          "content_same": false
        },
        {
          "line": 1933,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "mapConnectedByName.find(strAddNode)",
          "old_line_content": "        }",
          "new_line_content": "            auto it = mapConnectedByName.find(strAddNode);",
          "content_same": false
        },
        {
          "line": 1940,
          "old_api": null,
          "new_api": "std::move(addedNode)",
          "old_text": null,
          "new_text": "std::move(addedNode)",
          "old_line_content": "void CConnman::ThreadOpenAddedConnections()",
          "new_line_content": "        ret.emplace_back(std::move(addedNode));",
          "content_same": false
        },
        {
          "line": 1948,
          "old_api": null,
          "new_api": "SetSyscallSandboxPolicy",
          "old_text": null,
          "new_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET_ADD_CONNECTION)",
          "old_line_content": "        for (const AddedNodeInfo& info : vInfo) {",
          "new_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET_ADD_CONNECTION);",
          "content_same": false
        },
        {
          "line": 1952,
          "old_api": null,
          "new_api": "GetAddedNodeInfo",
          "old_text": null,
          "new_text": "GetAddedNodeInfo()",
          "old_line_content": "                    // the addednodeinfo state might change.",
          "new_line_content": "        std::vector<AddedNodeInfo> vInfo = GetAddedNodeInfo();",
          "content_same": false
        },
        {
          "line": 1956,
          "old_api": null,
          "new_api": "TryAcquire",
          "old_text": null,
          "new_text": "grant.TryAcquire()",
          "old_line_content": "                CAddress addr(CService(), NODE_NONE);",
          "new_line_content": "                if (!grant.TryAcquire()) {",
          "content_same": false
        },
        {
          "line": 1964,
          "old_api": null,
          "new_api": "std::chrono::milliseconds(500)",
          "old_text": null,
          "new_text": "std::chrono::milliseconds(500)",
          "old_line_content": "            return;",
          "new_line_content": "                if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))",
          "content_same": false
        },
        {
          "line": 1969,
          "old_api": null,
          "new_api": "std::chrono::seconds(tried ? 60 : 2)",
          "old_text": null,
          "new_text": "std::chrono::seconds(tried ? 60 : 2)",
          "old_line_content": "void CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, ConnectionType conn_type)",
          "new_line_content": "        if (!interruptNet.sleep_for(std::chrono::seconds(tried ? 60 : 2)))",
          "content_same": false
        },
        {
          "line": 1977,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(conn_type != ConnectionType::INBOUND)",
          "old_line_content": "        return;",
          "new_line_content": "    assert(conn_type != ConnectionType::INBOUND);",
          "content_same": false
        },
        {
          "line": 1989,
          "old_api": null,
          "new_api": "IsBanned",
          "old_text": null,
          "new_text": "m_banman->IsBanned(addrConnect)",
          "old_line_content": "",
          "new_line_content": "        bool banned_or_discouraged = m_banman && (m_banman->IsDiscouraged(addrConnect) || m_banman->IsBanned(addrConnect));",
          "content_same": false
        },
        {
          "line": 1993,
          "old_api": null,
          "new_api": "std::string(pszDest)",
          "old_text": null,
          "new_text": "std::string(pszDest)",
          "old_line_content": "        return;",
          "new_line_content": "    } else if (FindNode(std::string(pszDest)))",
          "content_same": false
        },
        {
          "line": 1996,
          "old_api": null,
          "new_api": "ConnectNode",
          "old_text": null,
          "new_text": "ConnectNode(addrConnect, pszDest, fCountFailure, conn_type)",
          "old_line_content": "",
          "new_line_content": "    CNode* pnode = ConnectNode(addrConnect, pszDest, fCountFailure, conn_type);",
          "content_same": false
        },
        {
          "line": 2001,
          "old_api": null,
          "new_api": "MoveTo",
          "old_text": null,
          "new_text": "grantOutbound->MoveTo(pnode->grantOutbound)",
          "old_line_content": "    }",
          "new_line_content": "        grantOutbound->MoveTo(pnode->grantOutbound);",
          "content_same": false
        },
        {
          "line": 2003,
          "old_api": null,
          "new_api": "InitializeNode",
          "old_text": null,
          "new_text": "m_msgproc->InitializeNode(*pnode, nLocalServices)",
          "old_line_content": "",
          "new_line_content": "    m_msgproc->InitializeNode(*pnode, nLocalServices);",
          "content_same": false
        },
        {
          "line": 2005,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(m_nodes_mutex)",
          "old_line_content": "",
          "new_line_content": "        LOCK(m_nodes_mutex);",
          "content_same": false
        },
        {
          "line": 2006,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "m_nodes.push_back(pnode)",
          "old_line_content": "void CConnman::ThreadMessageHandler()",
          "new_line_content": "        m_nodes.push_back(pnode);",
          "content_same": false
        },
        {
          "line": 2014,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(NetEventsInterface::g_msgproc_mutex)",
          "old_line_content": "",
          "new_line_content": "    LOCK(NetEventsInterface::g_msgproc_mutex);",
          "content_same": false
        },
        {
          "line": 2016,
          "old_api": null,
          "new_api": "SetSyscallSandboxPolicy",
          "old_text": null,
          "new_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::MESSAGE_HANDLER)",
          "old_line_content": "            // Randomize the order in which we process messages from/to our peers.",
          "new_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::MESSAGE_HANDLER);",
          "content_same": false
        },
        {
          "line": 2027,
          "old_api": null,
          "new_api": "Nodes",
          "old_text": null,
          "new_text": "snap.Nodes()",
          "old_line_content": "                fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend);",
          "new_line_content": "            for (CNode* pnode : snap.Nodes()) {",
          "content_same": false
        },
        {
          "line": 2032,
          "old_api": null,
          "new_api": "ProcessMessages",
          "old_text": null,
          "new_text": "m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc)",
          "old_line_content": "",
          "new_line_content": "                bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);",
          "content_same": false
        },
        {
          "line": 2037,
          "old_api": null,
          "new_api": "SendMessages",
          "old_text": null,
          "new_text": "m_msgproc->SendMessages(pnode)",
          "old_line_content": "",
          "new_line_content": "                m_msgproc->SendMessages(pnode);",
          "content_same": false
        },
        {
          "line": 2044,
          "old_api": null,
          "new_api": "WAIT_LOCK",
          "old_text": null,
          "new_text": "WAIT_LOCK(mutexMsgProc, lock)",
          "old_line_content": "}",
          "new_line_content": "        WAIT_LOCK(mutexMsgProc, lock);",
          "content_same": false
        },
        {
          "line": 2046,
          "old_api": null,
          "new_api": "std::chrono::milliseconds(100)",
          "old_text": null,
          "new_text": "std::chrono::milliseconds(100)",
          "old_line_content": "void CConnman::ThreadI2PAcceptIncoming()",
          "new_line_content": "            condMsgProc.wait_until(lock, std::chrono::steady_clock::now() + std::chrono::milliseconds(100), [this]() EXCLUSIVE_LOCKS_REQUIRED(mutexMsgProc) { return fMsgProcWake; });",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2048,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "    static constexpr auto err_wait_begin = 1s;",
          "new_line_content": "        fMsgProcWake = false;",
          "content_same": false
        },
        {
          "line": 2049,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "    static constexpr auto err_wait_cap = 5min;",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2057,
          "old_api": "Listen",
          "new_api": null,
          "old_text": "m_i2p_sam_session->Listen(conn)",
          "new_text": null,
          "old_line_content": "        if (!m_i2p_sam_session->Listen(conn)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2058,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "conn.me.IsValid()",
          "new_text": null,
          "old_line_content": "            if (advertising_listen_addr && conn.me.IsValid()) {",
          "new_line_content": "    bool advertising_listen_addr = false;",
          "content_same": false
        },
        {
          "line": 2059,
          "old_api": "RemoveLocal",
          "new_api": null,
          "old_text": "RemoveLocal(conn.me)",
          "new_text": null,
          "old_line_content": "                RemoveLocal(conn.me);",
          "new_line_content": "    i2p::Connection conn;",
          "content_same": false
        },
        {
          "line": 2072,
          "old_api": "AddLocal",
          "new_api": null,
          "old_text": "AddLocal(conn.me, LOCAL_MANUAL)",
          "new_text": null,
          "old_line_content": "            AddLocal(conn.me, LOCAL_MANUAL);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2076,
          "old_api": "Accept",
          "new_api": null,
          "old_text": "m_i2p_sam_session->Accept(conn)",
          "new_text": null,
          "old_line_content": "        if (!m_i2p_sam_session->Accept(conn)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2080,
          "old_api": "std::move(conn.sock)",
          "new_api": null,
          "old_text": "std::move(conn.sock)",
          "new_text": null,
          "old_line_content": "        CreateNodeFromAcceptedSocket(std::move(conn.sock), NetPermissionFlags::None,",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2092,
          "old_api": "GetSockAddr",
          "new_api": null,
          "old_text": "addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len)",
          "new_text": null,
          "old_line_content": "    if (!addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len))",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2094,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "addrBind.ToString()",
          "new_text": null,
          "old_line_content": "        strError = strprintf(Untranslated(\"Bind address family for %s not supported\"), addrBind.ToString());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2095,
          "old_api": "LogPrintLevel",
          "new_api": null,
          "old_text": "LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original)",
          "new_text": null,
          "old_line_content": "        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);",
          "new_line_content": "    // Create socket for listening for incoming connections",
          "content_same": false
        },
        {
          "line": 2099,
          "old_api": "CreateSock",
          "new_api": null,
          "old_text": "CreateSock(addrBind)",
          "new_text": null,
          "old_line_content": "    std::unique_ptr<Sock> sock = CreateSock(addrBind);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2102,
          "old_api": "LogPrintLevel",
          "new_api": null,
          "old_text": "LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original)",
          "new_text": null,
          "old_line_content": "        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 2109,
          "old_api": "WSAGetLastError",
          "new_api": null,
          "old_text": "WSAGetLastError()",
          "new_text": null,
          "old_line_content": "        strError = strprintf(Untranslated(\"Error setting SO_REUSEADDR on socket: %s, continuing anyway\"), NetworkErrorString(WSAGetLastError()));",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 2110,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"%s\\n\", strError.original)",
          "new_text": null,
          "old_line_content": "        LogPrintf(\"%s\\n\", strError.original);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2117,
          "old_api": "SetSockOpt",
          "new_api": null,
          "old_text": "sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_arg_type)&nOne, sizeof(int))",
          "new_text": null,
          "old_line_content": "        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_arg_type)&nOne, sizeof(int)) == SOCKET_ERROR) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2118,
          "old_api": "WSAGetLastError",
          "new_api": null,
          "old_text": "WSAGetLastError()",
          "new_text": null,
          "old_line_content": "            strError = strprintf(Untranslated(\"Error setting IPV6_V6ONLY on socket: %s, continuing anyway\"), NetworkErrorString(WSAGetLastError()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2119,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"%s\\n\", strError.original)",
          "new_text": null,
          "old_line_content": "            LogPrintf(\"%s\\n\", strError.original);",
          "new_line_content": "    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option",
          "content_same": false
        },
        {
          "line": 2126,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"%s\\n\", strError.original)",
          "new_text": null,
          "old_line_content": "            LogPrintf(\"%s\\n\", strError.original);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2134,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "addrBind.ToString()",
          "new_text": null,
          "old_line_content": "            strError = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"), addrBind.ToString(), PACKAGE_NAME);",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 2136,
          "old_api": "NetworkErrorString",
          "new_api": null,
          "old_text": "NetworkErrorString(nErr)",
          "new_text": null,
          "old_line_content": "            strError = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"), addrBind.ToString(), NetworkErrorString(nErr));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2145,
          "old_api": "WSAGetLastError",
          "new_api": null,
          "old_text": "WSAGetLastError()",
          "new_text": null,
          "old_line_content": "        strError = strprintf(_(\"Listening for incoming connections failed (listen returned error %s)\"), NetworkErrorString(WSAGetLastError()));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2150,
          "old_api": "std::move(sock)",
          "new_api": null,
          "old_text": "std::move(sock)",
          "new_text": null,
          "old_line_content": "    vhListenSocket.emplace_back(std::move(sock), permissions);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2162,
          "old_api": "gethostname",
          "new_api": null,
          "old_text": "gethostname(pszHostName, sizeof(pszHostName))",
          "new_text": null,
          "old_line_content": "    if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR)",
          "new_line_content": "    if (!fDiscover)",
          "content_same": false
        },
        {
          "line": 2165,
          "old_api": "LookupHost",
          "new_api": null,
          "old_text": "LookupHost(pszHostName, vaddr, 0, true)",
          "new_text": null,
          "old_line_content": "        if (LookupHost(pszHostName, vaddr, 0, true))",
          "new_line_content": "#ifdef WIN32",
          "content_same": false
        },
        {
          "line": 2169,
          "old_api": "AddLocal",
          "new_api": null,
          "old_text": "AddLocal(addr, LOCAL_IF)",
          "new_text": null,
          "old_line_content": "                if (AddLocal(addr, LOCAL_IF))",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2170,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "addr.ToString()",
          "new_text": null,
          "old_line_content": "                    LogPrintf(\"%s: %s - %s\\n\", __func__, pszHostName, addr.ToString());",
          "new_line_content": "        std::vector<CNetAddr> vaddr;",
          "content_same": false
        },
        {
          "line": 2177,
          "old_api": "getifaddrs",
          "new_api": null,
          "old_text": "getifaddrs(&myaddrs)",
          "new_text": null,
          "old_line_content": "    if (getifaddrs(&myaddrs) == 0)",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2184,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(ifa->ifa_name, \"lo0\")",
          "new_text": null,
          "old_line_content": "            if (strcmp(ifa->ifa_name, \"lo0\") == 0) continue;",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2197,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "addr.ToString()",
          "new_text": null,
          "old_line_content": "                    LogPrintf(\"%s: IPv6 %s: %s\\n\", __func__, ifa->ifa_name, addr.ToString());",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2200,
          "old_api": "freeifaddrs",
          "new_api": null,
          "old_text": "freeifaddrs(myaddrs)",
          "new_text": null,
          "old_line_content": "        freeifaddrs(myaddrs);",
          "new_line_content": "                struct sockaddr_in6* s6 = (struct sockaddr_in6*)(ifa->ifa_addr);",
          "content_same": false
        },
        {
          "line": 2207,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"%s: %s\\n\", __func__, active)",
          "new_text": null,
          "old_line_content": "    LogPrintf(\"%s: %s\\n\", __func__, active);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2216,
          "old_api": "NotifyNetworkActiveChanged",
          "new_api": null,
          "old_text": "m_client_interface->NotifyNetworkActiveChanged(fNetworkActive)",
          "new_text": null,
          "old_line_content": "        m_client_interface->NotifyNetworkActiveChanged(fNetworkActive);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 2227,
          "old_api": "SetTryNewOutboundPeer",
          "new_api": null,
          "old_text": "SetTryNewOutboundPeer(false)",
          "new_text": null,
          "old_line_content": "    SetTryNewOutboundPeer(false);",
          "new_line_content": "                   const NetGroupManager& netgroupman, bool network_active)",
          "content_same": false
        },
        {
          "line": 2230,
          "old_api": "Init",
          "new_api": null,
          "old_text": "Init(connOptions)",
          "new_text": null,
          "old_line_content": "    Init(connOptions);",
          "new_line_content": "    , nSeed0(nSeed0In)",
          "content_same": false
        },
        {
          "line": 2231,
          "old_api": "SetNetworkActive",
          "new_api": null,
          "old_text": "SetNetworkActive(network_active)",
          "new_text": null,
          "old_line_content": "    SetNetworkActive(network_active);",
          "new_line_content": "    , nSeed1(nSeed1In)",
          "content_same": false
        },
        {
          "line": 2245,
          "old_api": "BindListenPort",
          "new_api": null,
          "old_text": "BindListenPort(addr, strError, permissions)",
          "new_text": null,
          "old_line_content": "    if (!BindListenPort(addr, strError, permissions)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2247,
          "old_api": "ThreadSafeMessageBox",
          "new_api": null,
          "old_text": "m_client_interface->ThreadSafeMessageBox(strError, \"\", CClientUIInterface::MSG_ERROR)",
          "new_text": null,
          "old_line_content": "            m_client_interface->ThreadSafeMessageBox(strError, \"\", CClientUIInterface::MSG_ERROR);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2252,
          "old_api": "NetPermissions::HasFlag(permissions, NetPermissionFlags::NoBan)",
          "new_api": null,
          "old_text": "NetPermissions::HasFlag(permissions, NetPermissionFlags::NoBan)",
          "new_text": null,
          "old_line_content": "    if (addr.IsRoutable() && fDiscover && !(flags & BF_DONT_ADVERTISE) && !NetPermissions::HasFlag(permissions, NetPermissionFlags::NoBan)) {",
          "new_line_content": "        if ((flags & BF_REPORT_ERROR) && m_client_interface) {",
          "content_same": false
        },
        {
          "line": 2263,
          "old_api": "Bind",
          "new_api": null,
          "old_text": "Bind(addrBind, BF_REPORT_ERROR, NetPermissionFlags::None)",
          "new_text": null,
          "old_line_content": "        fBound |= Bind(addrBind, BF_REPORT_ERROR, NetPermissionFlags::None);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2266,
          "old_api": "Bind",
          "new_api": null,
          "old_text": "Bind(addrBind.m_service, BF_REPORT_ERROR, addrBind.m_flags)",
          "new_text": null,
          "old_line_content": "        fBound |= Bind(addrBind.m_service, BF_REPORT_ERROR, addrBind.m_flags);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2273,
          "old_api": "htonl",
          "new_api": null,
          "old_text": "htonl(INADDR_ANY)",
          "new_text": null,
          "old_line_content": "        inaddr_any.s_addr = htonl(INADDR_ANY);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2276,
          "old_api": "GetListenPort",
          "new_api": null,
          "old_text": "GetListenPort()",
          "new_text": null,
          "old_line_content": "        fBound |= Bind(CService(inaddr_any, GetListenPort()), !fBound ? BF_REPORT_ERROR : BF_NONE, NetPermissionFlags::None);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2283,
          "old_api": "AssertLockNotHeld",
          "new_api": null,
          "old_text": "AssertLockNotHeld(m_total_bytes_sent_mutex)",
          "new_text": null,
          "old_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2284,
          "old_api": "Init",
          "new_api": null,
          "old_text": "Init(connOptions)",
          "new_text": null,
          "old_line_content": "    Init(connOptions);",
          "new_line_content": "    return fBound;",
          "content_same": false
        },
        {
          "line": 2286,
          "old_api": "InitBinds",
          "new_api": null,
          "old_text": "InitBinds(connOptions)",
          "new_text": null,
          "old_line_content": "    if (fListen && !InitBinds(connOptions)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2288,
          "old_api": "ThreadSafeMessageBox",
          "new_api": null,
          "old_text": "m_client_interface->ThreadSafeMessageBox(\n                _(\"Failed to listen on any port. Use -listen=0 if you want this.\"),\n                \"\", CClientUIInterface::MSG_ERROR)",
          "new_text": null,
          "old_line_content": "            m_client_interface->ThreadSafeMessageBox(",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2296,
          "old_api": "GetProxy",
          "new_api": null,
          "old_text": "GetProxy(NET_I2P, i2p_sam)",
          "new_text": null,
          "old_line_content": "    if (GetProxy(NET_I2P, i2p_sam) && connOptions.m_i2p_accept_incoming) {",
          "new_line_content": "                \"\", CClientUIInterface::MSG_ERROR);",
          "content_same": false
        },
        {
          "line": 2297,
          "old_api": "GetDataDirNet",
          "new_api": null,
          "old_text": "gArgs.GetDataDirNet()",
          "new_text": null,
          "old_line_content": "        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(gArgs.GetDataDirNet() / \"i2p_private_key\",",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2307,
          "old_api": "GetDataDirNet",
          "new_api": null,
          "old_text": "gArgs.GetDataDirNet()",
          "new_text": null,
          "old_line_content": "        m_anchors = ReadAnchors(gArgs.GetDataDirNet() / ANCHORS_DATABASE_FILENAME);",
          "new_line_content": "    for (const auto& strDest : connOptions.vSeedNodes) {",
          "content_same": false
        },
        {
          "line": 2309,
          "old_api": "resize",
          "new_api": null,
          "old_text": "m_anchors.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS)",
          "new_text": null,
          "old_line_content": "            m_anchors.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2311,
          "old_api": "size",
          "new_api": null,
          "old_text": "m_anchors.size()",
          "new_text": null,
          "old_line_content": "        LogPrintf(\"%i block-relay-only anchors will be tried for connections.\\n\", m_anchors.size());",
          "new_line_content": "    if (m_use_addrman_outgoing) {",
          "content_same": false
        },
        {
          "line": 2322,
          "old_api": "d::min(m_max_outbound, nMaxConnections));",
          "new_api": null,
          "old_text": "d::min(m_max_outbound, nMaxConnections));",
          "new_text": null,
          "old_line_content": "        semOutbound = std::make_unique<CSemaphore>(std::min(m_max_outbound, nMaxConnections));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2326,
          "old_api": "d::make_unique<CSemaphore>(nMaxAddnode);",
          "new_api": null,
          "old_text": "d::make_unique<CSemaphore>(nMaxAddnode);\n",
          "new_text": null,
          "old_line_content": "        semAddnode = std::make_unique<CSemaphore>(nMaxAddnode);",
          "new_line_content": "    if (semOutbound == nullptr) {",
          "content_same": false
        },
        {
          "line": 2333,
          "old_api": "terruptSocks5",
          "new_api": null,
          "old_text": "terruptSocks5(false);\n",
          "new_text": null,
          "old_line_content": "    InterruptSocks5(false);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2334,
          "old_api": "reset",
          "new_api": null,
          "old_text": "terruptNet.reset();\n",
          "new_text": null,
          "old_line_content": "    interruptNet.reset();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2343,
          "old_api": "readSocketHandler",
          "new_api": null,
          "old_text": "readSocketHandler(); ",
          "new_text": null,
          "old_line_content": "    threadSocketHandler = std::thread(&util::TraceThread, \"net\", [this] { ThreadSocketHandler(); });",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2345,
          "old_api": "GetBoolArg",
          "new_api": null,
          "old_text": "rgs.GetBoolArg(\"-dnsseed\", DEFAULT_DNSSEED))\n",
          "new_text": null,
          "old_line_content": "    if (!gArgs.GetBoolArg(\"-dnsseed\", DEFAULT_DNSSEED))",
          "new_line_content": "        fMsgProcWake = false;",
          "content_same": false
        },
        {
          "line": 2346,
          "old_api": "gPrintf",
          "new_api": null,
          "old_text": "gPrintf(\"DNS seeding disabled\\n\");\n",
          "new_text": null,
          "old_line_content": "        LogPrintf(\"DNS seeding disabled\\n\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2348,
          "old_api": "readDNSAddressSeed",
          "new_api": null,
          "old_text": "readDNSAddressSeed(); ",
          "new_text": null,
          "old_line_content": "        threadDNSAddressSeed = std::thread(&util::TraceThread, \"dnsseed\", [this] { ThreadDNSAddressSeed(); });",
          "new_line_content": "    // Send and receive from sockets, accept connections",
          "content_same": false
        },
        {
          "line": 2353,
          "old_api": "empty",
          "new_api": null,
          "old_text": "nnOptions.m_specified_outgoing.empty()) ",
          "new_text": null,
          "old_line_content": "    if (connOptions.m_use_addrman_outgoing && !connOptions.m_specified_outgoing.empty()) {",
          "new_line_content": "    else",
          "content_same": false
        },
        {
          "line": 2355,
          "old_api": "ThreadSafeMessageBox",
          "new_api": null,
          "old_text": "client_interface->ThreadSafeMessageBox(\n                _(\"Cannot provide specific connections and have addrman find outgoing connections at the same time.\"),\n                \"\", CClientUIInterface::MSG_ERROR);\n",
          "new_text": null,
          "old_line_content": "            m_client_interface->ThreadSafeMessageBox(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2356,
          "old_api": "\"Cannot provide specific connections and have addrman find outgoing connections at the same time.\"),",
          "new_api": null,
          "old_text": "\"Cannot provide specific connections and have addrman find outgoing connections at the same time.\"),\n",
          "new_text": null,
          "old_line_content": "                _(\"Cannot provide specific connections and have addrman find outgoing connections at the same time.\"),",
          "new_line_content": "    // Initiate manual connections",
          "content_same": false
        },
        {
          "line": 2364,
          "old_api": "readOpenConnections",
          "new_api": null,
          "old_text": "readOpenConnections(connect); ",
          "new_text": null,
          "old_line_content": "            [this, connect = connOptions.m_specified_outgoing] { ThreadOpenConnections(connect); });",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2372,
          "old_api": "readI2PAcceptIncoming",
          "new_api": null,
          "old_text": "readI2PAcceptIncoming(); ",
          "new_text": null,
          "old_line_content": "            std::thread(&util::TraceThread, \"i2paccept\", [this] { ThreadI2PAcceptIncoming(); });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2376,
          "old_api": "mpAddresses",
          "new_api": null,
          "old_text": "mpAddresses(); ",
          "new_text": null,
          "old_line_content": "    scheduler.scheduleEvery([this] { DumpAddresses(); }, DUMP_PEERS_INTERVAL);",
          "new_line_content": "    if (m_i2p_sam_session) {",
          "content_same": false
        },
        {
          "line": 2390,
          "old_api": "ACleanup",
          "new_api": null,
          "old_text": "ACleanup();\n",
          "new_text": null,
          "old_line_content": "        WSACleanup();",
          "new_line_content": "    CNetCleanup() = default;",
          "content_same": false
        },
        {
          "line": 2399,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(mutexMsgProc);\n",
          "new_text": null,
          "old_line_content": "        LOCK(mutexMsgProc);",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 2402,
          "old_api": "notify_all",
          "new_api": null,
          "old_text": "ndMsgProc.notify_all();\n",
          "new_text": null,
          "old_line_content": "    condMsgProc.notify_all();",
          "new_line_content": "void CConnman::Interrupt()",
          "content_same": false
        },
        {
          "line": 2404,
          "old_api": "terruptNet",
          "new_api": null,
          "old_text": "terruptNet();\n",
          "new_text": null,
          "old_line_content": "    interruptNet();",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2409,
          "old_api": "post",
          "new_api": null,
          "old_text": "mOutbound->post();\n",
          "new_text": null,
          "old_line_content": "            semOutbound->post();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2422,
          "old_api": "joinable",
          "new_api": null,
          "old_text": "readI2PAcceptIncoming.joinable()) ",
          "new_text": null,
          "old_line_content": "    if (threadI2PAcceptIncoming.joinable()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2423,
          "old_api": "join",
          "new_api": null,
          "old_text": "readI2PAcceptIncoming.join();\n",
          "new_text": null,
          "old_line_content": "        threadI2PAcceptIncoming.join();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2425,
          "old_api": "joinable",
          "new_api": null,
          "old_text": "readMessageHandler.joinable())\n",
          "new_text": null,
          "old_line_content": "    if (threadMessageHandler.joinable())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2426,
          "old_api": "join",
          "new_api": null,
          "old_text": "readMessageHandler.join();\n",
          "new_text": null,
          "old_line_content": "        threadMessageHandler.join();",
          "new_line_content": "void CConnman::StopThreads()",
          "content_same": false
        },
        {
          "line": 2427,
          "old_api": "joinable",
          "new_api": null,
          "old_text": "readOpenConnections.joinable())\n",
          "new_text": null,
          "old_line_content": "    if (threadOpenConnections.joinable())",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2430,
          "old_api": "join",
          "new_api": null,
          "old_text": "readOpenAddedConnections.join();\n",
          "new_text": null,
          "old_line_content": "        threadOpenAddedConnections.join();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": "tCurrentBlockRelayOnlyConns",
          "new_api": null,
          "old_text": "tCurrentBlockRelayOnlyConns();\n",
          "new_text": null,
          "old_line_content": "            std::vector<CAddress> anchors_to_dump = GetCurrentBlockRelayOnlyConns();",
          "new_line_content": "    if (fAddressesInitialized) {",
          "content_same": false
        },
        {
          "line": 2447,
          "old_api": "resize",
          "new_api": null,
          "old_text": "chors_to_dump.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);\n",
          "new_text": null,
          "old_line_content": "                anchors_to_dump.resize(MAX_BLOCK_RELAY_ONLY_ANCHORS);",
          "new_line_content": "        fAddressesInitialized = false;",
          "content_same": false
        },
        {
          "line": 2449,
          "old_api": "GetDataDirNet",
          "new_api": null,
          "old_text": "rgs.GetDataDirNet() /",
          "new_text": null,
          "old_line_content": "            DumpAnchors(gArgs.GetDataDirNet() / ANCHORS_DATABASE_FILENAME, anchors_to_dump);",
          "new_line_content": "        if (m_use_addrman_outgoing) {",
          "content_same": false
        },
        {
          "line": 2457,
          "old_api": "CloseSocketDisconnect",
          "new_api": null,
          "old_text": "ode->CloseSocketDisconnect();\n",
          "new_text": null,
          "old_line_content": "        pnode->CloseSocketDisconnect();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2458,
          "old_api": "leteNode",
          "new_api": null,
          "old_text": "leteNode(pnode);\n",
          "new_text": null,
          "old_line_content": "        DeleteNode(pnode);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2462,
          "old_api": "leteNode",
          "new_api": null,
          "old_text": "leteNode(pnode);\n",
          "new_text": null,
          "old_line_content": "        DeleteNode(pnode);",
          "new_line_content": "    for (CNode* pnode : nodes) {",
          "content_same": false
        },
        {
          "line": 2465,
          "old_api": "clear",
          "new_api": null,
          "old_text": "ListenSocket.clear();\n",
          "new_text": null,
          "old_line_content": "    vhListenSocket.clear();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2466,
          "old_api": "reset",
          "new_api": null,
          "old_text": "mOutbound.reset();\n",
          "new_text": null,
          "old_line_content": "    semOutbound.reset();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2467,
          "old_api": "reset",
          "new_api": null,
          "old_text": "mAddnode.reset();\n",
          "new_text": null,
          "old_line_content": "    semAddnode.reset();",
          "new_line_content": "    for (CNode* pnode : m_nodes_disconnected) {",
          "content_same": false
        },
        {
          "line": 2480,
          "old_api": "op",
          "new_api": null,
          "old_text": "op();\n",
          "new_text": null,
          "old_line_content": "    Stop();",
          "new_line_content": "    delete pnode;",
          "content_same": false
        },
        {
          "line": 2487,
          "old_api": "end",
          "new_api": null,
          "old_text": "dresses.end(),\n",
          "new_text": null,
          "old_line_content": "        addresses.erase(std::remove_if(addresses.begin(), addresses.end(),",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2488,
          "old_api": "IsBanned",
          "new_api": null,
          "old_text": "banman->IsBanned(addr);}",
          "new_text": null,
          "old_line_content": "                        [this](const CAddress& addr){return m_banman->IsDiscouraged(addr) || m_banman->IsBanned(addr);}),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2489,
          "old_api": "end",
          "new_api": null,
          "old_text": "dresses.end());",
          "new_text": null,
          "old_line_content": "                        addresses.end());",
          "new_line_content": "std::vector<CAddress> CConnman::GetAddresses(size_t max_addresses, size_t max_pct, std::optional<Network> network) const",
          "content_same": false
        },
        {
          "line": 2496,
          "old_api": "GetAddrBytes",
          "new_api": null,
          "old_text": "questor.addrBind.GetAddrBytes();\n",
          "new_text": null,
          "old_line_content": "    auto local_socket_bytes = requestor.addrBind.GetAddrBytes();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2497,
          "old_api": "Write",
          "new_api": null,
          "old_text": "tDeterministicRandomizer(RANDOMIZER_ID_ADDRCACHE)\n        .Write(requestor.ConnectedThroughNetwork())\n        .Write(local_socket_bytes.data(), local_socket_bytes.size())\n        // For outbound connections, the port of the bound address is randomly\n        // assigned by the OS and would therefore not be useful for seeding.\n        .Write(requestor.IsInboundConn() ? requestor.addrBind.GetPort() : 0)\n        .Finalize();\n",
          "new_text": null,
          "old_line_content": "    uint64_t cache_id = GetDeterministicRandomizer(RANDOMIZER_ID_ADDRCACHE)",
          "new_line_content": "    return addresses;",
          "content_same": false
        },
        {
          "line": 2498,
          "old_api": "ConnectedThroughNetwork",
          "new_api": null,
          "old_text": "questor.ConnectedThroughNetwork())\n",
          "new_text": null,
          "old_line_content": "        .Write(requestor.ConnectedThroughNetwork())",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2499,
          "old_api": "size",
          "new_api": null,
          "old_text": "cal_socket_bytes.size())\n",
          "new_text": null,
          "old_line_content": "        .Write(local_socket_bytes.data(), local_socket_bytes.size())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2533,
          "old_api": "d::chrono::hours(6));",
          "new_api": null,
          "old_text": "d::chrono::hours(6));",
          "new_text": null,
          "old_line_content": "        cache_entry.m_cache_entry_expiration = current_time + std::chrono::hours(21) + GetRandMillis(std::chrono::hours(6));",
          "new_line_content": "        // in the ADDR response are no longer active.",
          "content_same": false
        },
        {
          "line": 2540,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(m_added_nodes_mutex);\n",
          "new_text": null,
          "old_line_content": "    LOCK(m_added_nodes_mutex);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2545,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "added_nodes.push_back(strNode);\n",
          "new_text": null,
          "old_line_content": "    m_added_nodes.push_back(strNode);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2552,
          "old_api": "end",
          "new_api": null,
          "old_text": "added_nodes.end(); ",
          "new_text": null,
          "old_line_content": "    for(std::vector<std::string>::iterator it = m_added_nodes.begin(); it != m_added_nodes.end(); ++it) {",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 2554,
          "old_api": "erase",
          "new_api": null,
          "old_text": "added_nodes.erase(it);\n",
          "new_text": null,
          "old_line_content": "            m_added_nodes.erase(it);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2563,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(m_nodes_mutex);\n",
          "new_text": null,
          "old_line_content": "    LOCK(m_nodes_mutex);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2565,
          "old_api": "size",
          "new_api": null,
          "old_text": "nodes.size();\n",
          "new_text": null,
          "old_line_content": "        return m_nodes.size();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2579,
          "old_api": "clear",
          "new_api": null,
          "old_text": "tats.clear();\n",
          "new_text": null,
          "old_line_content": "    vstats.clear();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2580,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(m_nodes_mutex);\n",
          "new_text": null,
          "old_line_content": "    LOCK(m_nodes_mutex);",
          "new_line_content": "    return nNum;",
          "content_same": false
        },
        {
          "line": 2581,
          "old_api": "size",
          "new_api": null,
          "old_text": "nodes.size());",
          "new_text": null,
          "old_line_content": "    vstats.reserve(m_nodes.size());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2583,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "tats.emplace_back();\n",
          "new_text": null,
          "old_line_content": "        vstats.emplace_back();",
          "new_line_content": "void CConnman::GetNodeStats(std::vector<CNodeStats>& vstats) const",
          "content_same": false
        },
        {
          "line": 2584,
          "old_api": "back",
          "new_api": null,
          "old_text": "tats.back());",
          "new_text": null,
          "old_line_content": "        pnode->CopyStats(vstats.back());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2592,
          "old_api": "ndNode",
          "new_api": null,
          "old_text": "ndNode(strNode)) ",
          "new_text": null,
          "old_line_content": "    if (CNode* pnode = FindNode(strNode)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2593,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "ode->GetId());",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"disconnect by address%s matched peer=%d; disconnecting\\n\", (fLogIPs ? strprintf(\"=%s\", strNode) : \"\"), pnode->GetId());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2603,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(m_nodes_mutex);\n",
          "new_text": null,
          "old_line_content": "    LOCK(m_nodes_mutex);",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 2605,
          "old_api": "Match",
          "new_api": null,
          "old_text": "bnet.Match(pnode->addr)) ",
          "new_text": null,
          "old_line_content": "        if (subnet.Match(pnode->addr)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2606,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "ode->GetId());",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"disconnect by subnet%s matched peer=%d; disconnecting\\n\", (fLogIPs ? strprintf(\"=%s\", subnet.ToString()) : \"\"), pnode->GetId());",
          "new_line_content": "bool CConnman::DisconnectNode(const CSubNet& subnet)",
          "content_same": false
        },
        {
          "line": 2616,
          "old_api": "ubNet",
          "new_api": null,
          "old_text": "ubNet(addr));",
          "new_text": null,
          "old_line_content": "    return DisconnectNode(CSubNet(addr));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2621,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(m_nodes_mutex);\n",
          "new_text": null,
          "old_line_content": "    LOCK(m_nodes_mutex);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2623,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "ode->GetId()) ",
          "new_text": null,
          "old_line_content": "        if (id == pnode->GetId()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2624,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "ode->GetId());",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"disconnect by id peer=%d; disconnecting\\n\", pnode->GetId());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2639,
          "old_api": "sertLockNotHeld",
          "new_api": null,
          "old_text": "sertLockNotHeld(m_total_bytes_sent_mutex);\n",
          "new_text": null,
          "old_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2640,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(m_total_bytes_sent_mutex);\n",
          "new_text": null,
          "old_line_content": "    LOCK(m_total_bytes_sent_mutex);",
          "new_line_content": "    nTotalBytesRecv += bytes;",
          "content_same": false
        },
        {
          "line": 2644,
          "old_api": "tTime<std::chrono::seconds>();",
          "new_api": null,
          "old_text": "tTime<std::chrono::seconds>();\n",
          "new_text": null,
          "old_line_content": "    const auto now = GetTime<std::chrono::seconds>();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2657,
          "old_api": "sertLockNotHeld",
          "new_api": null,
          "old_text": "sertLockNotHeld(m_total_bytes_sent_mutex);\n",
          "new_text": null,
          "old_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2658,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(m_total_bytes_sent_mutex);\n",
          "new_text": null,
          "old_line_content": "    LOCK(m_total_bytes_sent_mutex);",
          "new_line_content": "    nMaxOutboundTotalBytesSentInCycle += bytes;",
          "content_same": false
        },
        {
          "line": 2669,
          "old_api": "sertLockNotHeld",
          "new_api": null,
          "old_text": "sertLockNotHeld(m_total_bytes_sent_mutex);\n",
          "new_text": null,
          "old_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2670,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(m_total_bytes_sent_mutex);\n",
          "new_text": null,
          "old_line_content": "    LOCK(m_total_bytes_sent_mutex);",
          "new_line_content": "    return MAX_UPLOAD_TIMEFRAME;",
          "content_same": false
        },
        {
          "line": 2671,
          "old_api": "tMaxOutboundTimeLeftInCycle_",
          "new_api": null,
          "old_text": "tMaxOutboundTimeLeftInCycle_();\n",
          "new_text": null,
          "old_line_content": "    return GetMaxOutboundTimeLeftInCycle_();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2681,
          "old_api": "count",
          "new_api": null,
          "old_text": "axOutboundCycleStartTime.count() =",
          "new_text": null,
          "old_line_content": "    if (nMaxOutboundCycleStartTime.count() == 0)",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2685,
          "old_api": "tTime<std::chrono::seconds>();",
          "new_api": null,
          "old_text": "tTime<std::chrono::seconds>();\n",
          "new_text": null,
          "old_line_content": "    const auto now = GetTime<std::chrono::seconds>();",
          "new_line_content": "        return 0s;",
          "content_same": false
        },
        {
          "line": 2692,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(m_total_bytes_sent_mutex);\n",
          "new_text": null,
          "old_line_content": "    LOCK(m_total_bytes_sent_mutex);",
          "new_line_content": "    return (cycleEndTime < now) ? 0s : cycleEndTime - now;",
          "content_same": false
        },
        {
          "line": 2699,
          "old_api": "tMaxOutboundTimeLeftInCycle_",
          "new_api": null,
          "old_text": "tMaxOutboundTimeLeftInCycle_();\n",
          "new_text": null,
          "old_line_content": "        const std::chrono::seconds timeLeftInCycle = GetMaxOutboundTimeLeftInCycle_();",
          "new_line_content": "    if (nMaxOutboundLimit == 0)",
          "content_same": false
        },
        {
          "line": 2712,
          "old_api": "sertLockNotHeld",
          "new_api": null,
          "old_text": "sertLockNotHeld(m_total_bytes_sent_mutex);\n",
          "new_text": null,
          "old_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2713,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(m_total_bytes_sent_mutex);\n",
          "new_text": null,
          "old_line_content": "    LOCK(m_total_bytes_sent_mutex);",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 2727,
          "old_api": "sertLockNotHeld",
          "new_api": null,
          "old_text": "sertLockNotHeld(m_total_bytes_sent_mutex);\n",
          "new_text": null,
          "old_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2728,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(m_total_bytes_sent_mutex);\n",
          "new_text": null,
          "old_line_content": "    LOCK(m_total_bytes_sent_mutex);",
          "new_line_content": "    return nTotalBytesRecv;",
          "content_same": false
        },
        {
          "line": 2749,
          "old_api": "rams",
          "new_api": null,
          "old_text": "rams(), ",
          "new_text": null,
          "old_line_content": "    : m_deserializer{std::make_unique<V1TransportDeserializer>(V1TransportDeserializer(Params(), idIn, SER_NETWORK, INIT_PROTO_VERSION))},",
          "new_line_content": "             uint64_t nLocalHostNonceIn,",
          "content_same": false
        },
        {
          "line": 2750,
          "old_api": "TransportSerializer",
          "new_api": null,
          "old_text": "TransportSerializer())}",
          "new_text": null,
          "old_line_content": "      m_serializer{std::make_unique<V1TransportSerializer>(V1TransportSerializer())},",
          "new_line_content": "             const CAddress& addrBindIn,",
          "content_same": false
        },
        {
          "line": 2753,
          "old_api": "tTime<std::chrono::seconds>()},",
          "new_api": null,
          "old_text": "tTime<std::chrono::seconds>()},",
          "new_text": null,
          "old_line_content": "      m_connected{GetTime<std::chrono::seconds>()},",
          "new_line_content": "             bool inbound_onion,",
          "content_same": false
        },
        {
          "line": 2763,
          "old_api": "d::move(node_opts.i2p_sam_session)}",
          "new_api": null,
          "old_text": "d::move(node_opts.i2p_sam_session)}\n",
          "new_text": null,
          "old_line_content": "      m_i2p_sam_session{std::move(node_opts.i2p_sam_session)}",
          "new_line_content": "      m_inbound_onion{inbound_onion},",
          "content_same": false
        },
        {
          "line": 2765,
          "old_api": "sert",
          "new_api": null,
          "old_text": "sert(conn_type_in == ConnectionType::INBOUND);\n",
          "new_text": null,
          "old_line_content": "    if (inbound_onion) assert(conn_type_in == ConnectionType::INBOUND);",
          "new_line_content": "      nKeyedNetGroup{nKeyedNetGroupIn},",
          "content_same": false
        },
        {
          "line": 2767,
          "old_api": "tAllNetMessageTypes",
          "new_api": null,
          "old_text": "tAllNetMessageTypes())\n",
          "new_text": null,
          "old_line_content": "    for (const std::string &msg : getAllNetMessageTypes())",
          "new_line_content": "      nLocalHostNonce{nLocalHostNonceIn},",
          "content_same": false
        },
        {
          "line": 2772,
          "old_api": "gPrint",
          "new_api": null,
          "old_text": "gPrint(BCLog::NET, \"Added connection to %s peer=%d\\n\", m_addr_name, id);\n",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"Added connection to %s peer=%d\\n\", m_addr_name, id);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2774,
          "old_api": "gPrint",
          "new_api": null,
          "old_text": "gPrint(BCLog::NET, \"Added connection peer=%d\\n\", id);\n",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"Added connection peer=%d\\n\", id);",
          "new_line_content": "        mapRecvBytesPerMsgType[msg] = 0;",
          "content_same": false
        },
        {
          "line": 2785,
          "old_api": "sertLockNotHeld",
          "new_api": null,
          "old_text": "sertLockNotHeld(m_total_bytes_sent_mutex);\n",
          "new_text": null,
          "old_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2786,
          "old_api": "size",
          "new_api": null,
          "old_text": "g.data.size();\n",
          "new_text": null,
          "old_line_content": "    size_t nMessageSize = msg.data.size();",
          "new_line_content": "    return pnode && pnode->fSuccessfullyConnected && !pnode->fDisconnect;",
          "content_same": false
        },
        {
          "line": 2787,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "ode->GetId());",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\", msg.m_type, nMessageSize, pnode->GetId());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2788,
          "old_api": "GetBoolArg",
          "new_api": null,
          "old_text": "rgs.GetBoolArg(\"-capturemessages\", false)) ",
          "new_text": null,
          "old_line_content": "    if (gArgs.GetBoolArg(\"-capturemessages\", false)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2789,
          "old_api": "ptureMessage",
          "new_api": null,
          "old_text": "ptureMessage(pnode->addr, msg.m_type, msg.data, /*is_incoming=*/false);\n",
          "new_text": null,
          "old_line_content": "        CaptureMessage(pnode->addr, msg.m_type, msg.data, /*is_incoming=*/false);",
          "new_line_content": "void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)",
          "content_same": false
        },
        {
          "line": 2796,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "g.m_type.c_str(),\n",
          "new_text": null,
          "old_line_content": "        msg.m_type.c_str(),",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2797,
          "old_api": "size",
          "new_api": null,
          "old_text": "g.data.size(),\n",
          "new_text": null,
          "old_line_content": "        msg.data.size(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2808,
          "old_api": "CK",
          "new_api": null,
          "old_text": "CK(pnode->cs_vSend);\n",
          "new_text": null,
          "old_line_content": "        LOCK(pnode->cs_vSend);",
          "new_line_content": "    std::vector<unsigned char> serializedHeader;",
          "content_same": false
        },
        {
          "line": 2816,
          "old_api": "d::move(serializedHeader));",
          "new_api": null,
          "old_text": "d::move(serializedHeader));",
          "new_text": null,
          "old_line_content": "        pnode->vSendMsg.push_back(std::move(serializedHeader));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2817,
          "old_api": "d::move(msg.data));",
          "new_api": null,
          "old_text": "d::move(msg.data));",
          "new_text": null,
          "old_line_content": "        if (nMessageSize) pnode->vSendMsg.push_back(std::move(msg.data));",
          "new_line_content": "        //log total amount of bytes per message type",
          "content_same": false
        },
        {
          "line": 2820,
          "old_api": "cketSendData",
          "new_api": null,
          "old_text": "cketSendData(*pnode);\n",
          "new_text": null,
          "old_line_content": "        if (optimisticSend) nBytesSent = SocketSendData(*pnode);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2830,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "ode->GetId() =",
          "new_text": null,
          "old_line_content": "        if(pnode->GetId() == id) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2835,
          "old_api": "nc",
          "new_api": null,
          "old_text": "nc(found);\n",
          "new_text": null,
          "old_line_content": "    return found != nullptr && NodeFullyConnected(found) && func(found);",
          "new_line_content": "    for (auto&& pnode : m_nodes) {",
          "content_same": false
        },
        {
          "line": 2840,
          "old_api": "Write",
          "new_api": null,
          "old_text": "ipHasher(nSeed0, nSeed1).Write(id);\n",
          "new_text": null,
          "old_line_content": "    return CSipHasher(nSeed0, nSeed1).Write(id);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2845,
          "old_api": "GetGroup",
          "new_api": null,
          "old_text": "netgroupman.GetGroup(address));",
          "new_text": null,
          "old_line_content": "    std::vector<unsigned char> vchNetGroup(m_netgroupman.GetGroup(address));",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2847,
          "old_api": "size",
          "new_api": null,
          "old_text": "hNetGroup.size()).",
          "new_text": null,
          "old_line_content": "    return GetDeterministicRandomizer(RANDOMIZER_ID_NETGROUP).Write(vchNetGroup.data(), vchNetGroup.size()).Finalize();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2859,
          "old_api": "tTime<std::chrono::microseconds>();",
          "new_api": null,
          "old_text": "tTime<std::chrono::microseconds>();\n",
          "new_text": null,
          "old_line_content": "    auto now = GetTime<std::chrono::microseconds>();",
          "new_line_content": "                          bool is_incoming)",
          "content_same": false
        },
        {
          "line": 2862,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "dr.ToString();\n",
          "new_text": null,
          "old_line_content": "    std::string clean_addr = addr.ToString();",
          "new_line_content": "    // not at socket receive/send time.",
          "content_same": false
        },
        {
          "line": 2863,
          "old_api": "end",
          "new_api": null,
          "old_text": "ean_addr.end(), ",
          "new_text": null,
          "old_line_content": "    std::replace(clean_addr.begin(), clean_addr.end(), ':', '_');",
          "new_line_content": "    // This ensures that the messages are always in order from an application",
          "content_same": false
        },
        {
          "line": 2866,
          "old_api": "::create_directories(base_path);",
          "new_api": null,
          "old_text": "::create_directories(base_path);\n",
          "new_text": null,
          "old_line_content": "    fs::create_directories(base_path);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2873,
          "old_api": "length",
          "new_api": null,
          "old_text": "g_type.length(); ",
          "new_text": null,
          "old_line_content": "    for (auto i = msg_type.length(); i < CMessageHeader::COMMAND_SIZE; ++i) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 828,
          "old_api": "size",
          "new_api": null,
          "old_text": "data.size()",
          "new_text": null,
          "old_line_content": "            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()) + node.nSendOffset, data.size() - node.nSendOffset, MSG_NOSIGNAL | MSG_DONTWAIT);",
          "new_line_content": "            int flags = MSG_NOSIGNAL | MSG_DONTWAIT;",
          "content_same": false
        },
        {
          "line": 2876,
          "old_api": "size",
          "new_api": null,
          "old_text": "ta.size();\n",
          "new_text": null,
          "old_line_content": "    uint32_t size = data.size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": "GetTime<std::chrono::seconds>()",
          "new_api": null,
          "old_text": "GetTime<std::chrono::seconds>()",
          "new_text": null,
          "old_line_content": "            node.m_last_send = GetTime<std::chrono::seconds>();",
          "new_line_content": "                flags |= MSG_MORE;",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": "size",
          "new_api": null,
          "old_text": "data.size()",
          "new_text": null,
          "old_line_content": "            if (node.nSendOffset == data.size()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": "WSAGetLastError",
          "new_api": null,
          "old_text": "WSAGetLastError()",
          "new_text": null,
          "old_line_content": "                int nErr = WSAGetLastError();",
          "new_line_content": "                // could not send full message; stop sending more",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": "NetworkErrorString",
          "new_api": null,
          "old_text": "NetworkErrorString(nErr)",
          "new_text": null,
          "old_line_content": "                    LogPrint(BCLog::NET, \"socket send error for peer=%d: %s\\n\", node.GetId(), NetworkErrorString(nErr));",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 850,
          "old_api": "CloseSocketDisconnect",
          "new_api": null,
          "old_text": "node.CloseSocketDisconnect()",
          "new_text": null,
          "old_line_content": "                    node.CloseSocketDisconnect();",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": "end",
          "new_api": null,
          "old_text": "node.vSendMsg.end()",
          "new_text": null,
          "old_line_content": "    if (it == node.vSendMsg.end()) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(node.nSendOffset == 0)",
          "new_text": null,
          "old_line_content": "        assert(node.nSendOffset == 0);",
          "new_line_content": "            // couldn't send anything at all",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(node.nSendSize == 0)",
          "new_text": null,
          "old_line_content": "        assert(node.nSendSize == 0);",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": "begin",
          "new_api": null,
          "old_text": "node.vSendMsg.begin()",
          "new_text": null,
          "old_line_content": "    node.vSendMsg.erase(node.vSendMsg.begin(), it);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_nodes_mutex);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "node->GetId()",
          "new_text": null,
          "old_line_content": "                .id = node->GetId(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": "load",
          "new_api": null,
          "old_text": "node->m_bloom_filter_loaded.load()",
          "new_text": null,
          "old_line_content": "                .fBloomFilter = node->m_bloom_filter_loaded.load(),",
          "new_line_content": "                .m_connected = node->m_connected,",
          "content_same": false
        },
        {
          "line": 894,
          "old_api": "IsLocal",
          "new_api": null,
          "old_text": "node->addr.IsLocal()",
          "new_text": null,
          "old_line_content": "                .m_is_local = node->addr.IsLocal(),",
          "new_line_content": "                .m_last_tx_time = node->m_last_tx_time,",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": "ConnectedThroughNetwork",
          "new_api": null,
          "old_text": "node->ConnectedThroughNetwork()",
          "new_text": null,
          "old_line_content": "                .m_network = node->ConnectedThroughNetwork(),",
          "new_line_content": "                .fRelevantServices = node->m_has_all_wanted_services,",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "vEvictionCandidates.push_back(candidate)",
          "new_text": null,
          "old_line_content": "            vEvictionCandidates.push_back(candidate);",
          "new_line_content": "                .prefer_evict = node->m_prefer_evict,",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "    LOCK(m_nodes_mutex);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pnode->GetId()",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"selected %s connection for eviction peer=%d; disconnecting\\n\", pnode->ConnectionTypeAsString(), pnode->GetId());",
          "new_line_content": "    if (!node_id_to_evict) {",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": "Accept",
          "new_api": null,
          "old_text": "hListenSocket.sock->Accept((struct sockaddr*)&sockaddr, &len)",
          "new_text": null,
          "old_line_content": "    auto sock = hListenSocket.sock->Accept((struct sockaddr*)&sockaddr, &len);",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": "WSAGetLastError",
          "new_api": null,
          "old_text": "WSAGetLastError()",
          "new_text": null,
          "old_line_content": "        const int nErr = WSAGetLastError();",
          "new_line_content": "    struct sockaddr_storage sockaddr;",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": "SetSockAddr",
          "new_api": null,
          "old_text": "addr.SetSockAddr((const struct sockaddr*)&sockaddr)",
          "new_text": null,
          "old_line_content": "    if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {",
          "new_line_content": "        if (nErr != WSAEWOULDBLOCK) {",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "MaybeFlipIPv6toCJDNS",
          "new_api": null,
          "old_text": "MaybeFlipIPv6toCJDNS(addr)",
          "new_text": null,
          "old_line_content": "        addr = CAddress{MaybeFlipIPv6toCJDNS(addr), NODE_NONE};",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": "std::move(sock)",
          "new_api": null,
          "old_text": "std::move(sock)",
          "new_text": null,
          "old_line_content": "    CreateNodeFromAcceptedSocket(std::move(sock), permission_flags, addr_bind, addr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "AddWhitelistPermissionFlags",
          "new_api": null,
          "old_text": "AddWhitelistPermissionFlags(permission_flags, addr)",
          "new_text": null,
          "old_line_content": "    AddWhitelistPermissionFlags(permission_flags, addr);",
          "new_line_content": "                                            const CAddress& addr_bind,",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": "NetPermissions::HasFlag(permission_flags, NetPermissionFlags::Implicit)",
          "new_api": null,
          "old_text": "NetPermissions::HasFlag(permission_flags, NetPermissionFlags::Implicit)",
          "new_text": null,
          "old_line_content": "    if (NetPermissions::HasFlag(permission_flags, NetPermissionFlags::Implicit)) {",
          "new_line_content": "                                            const CAddress& addr)",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": "NetPermissions::ClearFlag(permission_flags, NetPermissionFlags::Implicit)",
          "new_api": null,
          "old_text": "NetPermissions::ClearFlag(permission_flags, NetPermissionFlags::Implicit)",
          "new_text": null,
          "old_line_content": "        NetPermissions::ClearFlag(permission_flags, NetPermissionFlags::Implicit);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": "NetPermissions::AddFlag(permission_flags, NetPermissionFlags::ForceRelay)",
          "new_api": null,
          "old_text": "NetPermissions::AddFlag(permission_flags, NetPermissionFlags::ForceRelay)",
          "new_text": null,
          "old_line_content": "        if (gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) NetPermissions::AddFlag(permission_flags, NetPermissionFlags::ForceRelay);",
          "new_line_content": "    int nInbound = 0;",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": "NetPermissions::AddFlag(permission_flags, NetPermissionFlags::Relay)",
          "new_api": null,
          "old_text": "NetPermissions::AddFlag(permission_flags, NetPermissionFlags::Relay)",
          "new_text": null,
          "old_line_content": "        if (gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)) NetPermissions::AddFlag(permission_flags, NetPermissionFlags::Relay);",
          "new_line_content": "    int nMaxInbound = nMaxConnections - m_max_outbound;",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": "NetPermissions::AddFlag(permission_flags, NetPermissionFlags::Mempool)",
          "new_api": null,
          "old_text": "NetPermissions::AddFlag(permission_flags, NetPermissionFlags::Mempool)",
          "new_text": null,
          "old_line_content": "        NetPermissions::AddFlag(permission_flags, NetPermissionFlags::Mempool);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "addr.ToString()",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"connection from %s dropped: not accepting new connections\\n\", addr.ToString());",
          "new_line_content": "        for (const CNode* pnode : m_nodes) {",
          "content_same": false
        },
        {
          "line": 974,
          "old_api": "IsSelectable",
          "new_api": null,
          "old_text": "sock->IsSelectable()",
          "new_text": null,
          "old_line_content": "    if (!sock->IsSelectable()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "addr.ToString()",
          "new_text": null,
          "old_line_content": "        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", addr.ToString());",
          "new_line_content": "    if (!fNetworkActive) {",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": "SetSockOpt",
          "new_api": null,
          "old_text": "sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on))",
          "new_text": null,
          "old_line_content": "    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "LogPrint(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n                 addr.ToString())",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "addr.ToString()",
          "new_text": null,
          "old_line_content": "                 addr.ToString());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "addr.ToString()",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"connection from %s dropped (banned)\\n\", addr.ToString());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": "IsDiscouraged",
          "new_api": null,
          "old_text": "m_banman->IsDiscouraged(addr)",
          "new_text": null,
          "old_line_content": "    bool discouraged = m_banman && m_banman->IsDiscouraged(addr);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "addr.ToString()",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"connection from %s dropped (discouraged)\\n\", addr.ToString());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::NET, \"failed to find an eviction candidate - connection dropped (full)\\n\")",
          "new_text": null,
          "old_line_content": "            LogPrint(BCLog::NET, \"failed to find an eviction candidate - connection dropped (full)\\n\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": "GetNewNodeId",
          "new_api": null,
          "old_text": "GetNewNodeId()",
          "new_text": null,
          "old_line_content": "    NodeId id = GetNewNodeId();",
          "new_line_content": "            // No connection to evict, disconnect the new connection",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": "NetPermissions::HasFlag(permission_flags, NetPermissionFlags::BloomFilter)",
          "new_api": null,
          "old_text": "NetPermissions::HasFlag(permission_flags, NetPermissionFlags::BloomFilter)",
          "new_text": null,
          "old_line_content": "    if (NetPermissions::HasFlag(permission_flags, NetPermissionFlags::BloomFilter)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1017,
          "old_api": "static_cast<ServiceFlags>(nodeServices | NODE_BLOOM)",
          "new_api": null,
          "old_text": "static_cast<ServiceFlags>(nodeServices | NODE_BLOOM)",
          "new_text": null,
          "old_line_content": "        nodeServices = static_cast<ServiceFlags>(nodeServices | NODE_BLOOM);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": "end",
          "new_api": null,
          "old_text": "m_onion_binds.end()",
          "new_text": null,
          "old_line_content": "    const bool inbound_onion = std::find(m_onion_binds.begin(), m_onion_binds.end(), addr_bind) != m_onion_binds.end();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1024,
          "old_api": "CalculateKeyedNetGroup",
          "new_api": null,
          "old_text": "CalculateKeyedNetGroup(addr)",
          "new_text": null,
          "old_line_content": "                             CalculateKeyedNetGroup(addr),",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": "AddRef",
          "new_api": null,
          "old_text": "pnode->AddRef()",
          "new_text": null,
          "old_line_content": "    pnode->AddRef();",
          "new_line_content": "                             ConnectionType::INBOUND,",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": "InitializeNode",
          "new_api": null,
          "old_text": "m_msgproc->InitializeNode(*pnode, nodeServices)",
          "new_text": null,
          "old_line_content": "    m_msgproc->InitializeNode(*pnode, nodeServices);",
          "new_line_content": "                             inbound_onion,",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "addr.ToString()",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::NET, \"connection from %s accepted\\n\", addr.ToString());",
          "new_line_content": "                               .permission_flags = permission_flags,",
          "content_same": false
        },
        {
          "line": 1045,
          "old_api": "RandAddEvent",
          "new_api": null,
          "old_text": "RandAddEvent((uint32_t)id)",
          "new_text": null,
          "old_line_content": "    RandAddEvent((uint32_t)id);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1070,
          "old_api": "begin",
          "new_api": null,
          "old_text": "WITH_LOCK(m_nodes_mutex,\n                                         return std::count_if(m_nodes.begin(), m_nodes.end(), [conn_type](CNode* node) { return node->m_conn_type == conn_type; });)",
          "new_text": null,
          "old_line_content": "    int existing_connections = WITH_LOCK(m_nodes_mutex,",
          "new_line_content": "    // no limit for FEELER connections since they're short-lived",
          "content_same": false
        },
        {
          "line": 1071,
          "old_api": "end",
          "new_api": null,
          "old_text": "m_nodes.end()",
          "new_text": null,
          "old_line_content": "                                         return std::count_if(m_nodes.begin(), m_nodes.end(), [conn_type](CNode* node) { return node->m_conn_type == conn_type; }););",
          "new_line_content": "    case ConnectionType::FEELER:",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "address.c_str()",
          "new_text": null,
          "old_line_content": "    OpenNetworkConnection(CAddress(), false, &grant, address.c_str(), conn_type);",
          "new_line_content": "    if (max_connections != std::nullopt && existing_connections >= max_connections) return false;",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_nodes_mutex);",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": "end",
          "new_api": null,
          "old_text": "m_nodes.end()",
          "new_text": null,
          "old_line_content": "                m_nodes.erase(remove(m_nodes.begin(), m_nodes.end(), pnode), m_nodes.end());",
          "new_line_content": "        std::vector<CNode*> nodes_copy = m_nodes;",
          "content_same": false
        },
        {
          "line": 1109,
          "old_api": "Release",
          "new_api": null,
          "old_text": "pnode->grantOutbound.Release()",
          "new_text": null,
          "old_line_content": "                pnode->grantOutbound.Release();",
          "new_line_content": "            if (pnode->fDisconnect)",
          "content_same": false
        },
        {
          "line": 1116,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "m_nodes_disconnected.push_back(pnode)",
          "new_text": null,
          "old_line_content": "                m_nodes_disconnected.push_back(pnode);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": "GetRefCount",
          "new_api": null,
          "old_text": "pnode->GetRefCount()",
          "new_text": null,
          "old_line_content": "            if (pnode->GetRefCount() <= 0) {",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": "remove",
          "new_api": null,
          "old_text": "m_nodes_disconnected.remove(pnode)",
          "new_text": null,
          "old_line_content": "                m_nodes_disconnected.remove(pnode);",
          "new_line_content": "        // Delete disconnected nodes",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": "DeleteNode",
          "new_api": null,
          "old_text": "DeleteNode(pnode)",
          "new_text": null,
          "old_line_content": "                DeleteNode(pnode);",
          "new_line_content": "        std::list<CNode*> nodes_disconnected_copy = m_nodes_disconnected;",
          "content_same": false
        },
        {
          "line": 1138,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_nodes_mutex);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": "size",
          "new_api": null,
          "old_text": "m_nodes.size()",
          "new_text": null,
          "old_line_content": "        nodes_size = m_nodes.size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1158,
          "old_api": "GetTime<std::chrono::seconds>()",
          "new_api": null,
          "old_text": "GetTime<std::chrono::seconds>()",
          "new_text": null,
          "old_line_content": "    const auto now{GetTime<std::chrono::seconds>()};",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": "load",
          "new_api": null,
          "old_text": "node.m_last_send.load()",
          "new_text": null,
          "old_line_content": "    const auto last_send{node.m_last_send.load()};",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": "load",
          "new_api": null,
          "old_text": "node.m_last_recv.load()",
          "new_text": null,
          "old_line_content": "    const auto last_recv{node.m_last_recv.load()};",
          "new_line_content": "bool CConnman::InactivityCheck(const CNode& node) const",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": "ShouldRunInactivityChecks",
          "new_api": null,
          "old_text": "ShouldRunInactivityChecks(node, now)",
          "new_text": null,
          "old_line_content": "    if (!ShouldRunInactivityChecks(node, now)) return false;",
          "new_line_content": "    // Tests that see disconnects after using mocktime can start nodes with a",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "node.GetId()",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"socket receive timeout: %is peer=%d\\n\", count_seconds(now - last_recv), node.GetId());",
          "new_line_content": "    if (now > last_send + TIMEOUT_INTERVAL) {",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "node.GetId()",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::NET, \"version handshake timeout peer=%d\\n\", node.GetId());",
          "new_line_content": "    if (now > last_recv + TIMEOUT_INTERVAL) {",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": "emplace",
          "new_api": null,
          "old_text": "events_per_sock.emplace(hListenSocket.sock, Sock::Events{Sock::RECV})",
          "new_text": null,
          "old_line_content": "        events_per_sock.emplace(hListenSocket.sock, Sock::Events{Sock::RECV});",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1210,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pnode->cs_vSend)",
          "new_text": null,
          "old_line_content": "            LOCK(pnode->cs_vSend);",
          "new_line_content": "        // * Hand off all complete messages to the processor, to be handled without",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": "empty",
          "new_api": null,
          "old_text": "pnode->vSendMsg.empty()",
          "new_text": null,
          "old_line_content": "            select_send = !pnode->vSendMsg.empty();",
          "new_line_content": "        //   blocking here.",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pnode->m_sock_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(pnode->m_sock_mutex);",
          "new_line_content": "        bool select_send;",
          "content_same": false
        },
        {
          "line": 1226,
          "old_api": "emplace",
          "new_api": null,
          "old_text": "events_per_sock.emplace(pnode->m_sock, Sock::Events{requested})",
          "new_text": null,
          "old_line_content": "        events_per_sock.emplace(pnode->m_sock, Sock::Events{requested});",
          "new_line_content": "        if (select_send) {",
          "content_same": false
        },
        {
          "line": 1234,
          "old_api": "AssertLockNotHeld",
          "new_api": null,
          "old_text": "AssertLockNotHeld(m_total_bytes_sent_mutex)",
          "new_text": null,
          "old_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1241,
          "old_api": "std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS)",
          "new_api": null,
          "old_text": "std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS)",
          "new_text": null,
          "old_line_content": "        const auto timeout = std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1248,
          "old_api": "begin",
          "new_api": null,
          "old_text": "events_per_sock.begin()->first->WaitMany(timeout, events_per_sock)",
          "new_text": null,
          "old_line_content": "        if (events_per_sock.empty() || !events_per_sock.begin()->first->WaitMany(timeout, events_per_sock)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": "sleep_for",
          "new_api": null,
          "old_text": "interruptNet.sleep_for(timeout)",
          "new_text": null,
          "old_line_content": "            interruptNet.sleep_for(timeout);",
          "new_line_content": "        // Check for the readiness of the already connected sockets and the",
          "content_same": false
        },
        {
          "line": 1257,
          "old_api": "SocketHandlerListening",
          "new_api": null,
          "old_text": "SocketHandlerListening(events_per_sock)",
          "new_text": null,
          "old_line_content": "    SocketHandlerListening(events_per_sock);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1276,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pnode->m_sock_mutex)",
          "new_text": null,
          "old_line_content": "            LOCK(pnode->m_sock_mutex);",
          "new_line_content": "        // Receive",
          "content_same": false
        },
        {
          "line": 1280,
          "old_api": "find",
          "new_api": null,
          "old_text": "events_per_sock.find(pnode->m_sock)",
          "new_text": null,
          "old_line_content": "            const auto it = events_per_sock.find(pnode->m_sock);",
          "new_line_content": "        bool errorSet = false;",
          "content_same": false
        },
        {
          "line": 1281,
          "old_api": "end",
          "new_api": null,
          "old_text": "events_per_sock.end()",
          "new_text": null,
          "old_line_content": "            if (it != events_per_sock.end()) {",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1293,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pnode->m_sock_mutex)",
          "new_text": null,
          "old_line_content": "                LOCK(pnode->m_sock_mutex);",
          "new_line_content": "        if (recvSet || errorSet)",
          "content_same": false
        },
        {
          "line": 1297,
          "old_api": "Recv",
          "new_api": null,
          "old_text": "pnode->m_sock->Recv(pchBuf, sizeof(pchBuf), MSG_DONTWAIT)",
          "new_text": null,
          "old_line_content": "                nBytes = pnode->m_sock->Recv(pchBuf, sizeof(pchBuf), MSG_DONTWAIT);",
          "new_line_content": "            int nBytes = 0;",
          "content_same": false
        },
        {
          "line": 1302,
          "old_api": "ReceiveMsgBytes",
          "new_api": null,
          "old_text": "pnode->ReceiveMsgBytes({pchBuf, (size_t)nBytes}, notify)",
          "new_text": null,
          "old_line_content": "                if (!pnode->ReceiveMsgBytes({pchBuf, (size_t)nBytes}, notify)) {",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1305,
          "old_api": "RecordBytesRecv",
          "new_api": null,
          "old_text": "RecordBytesRecv(nBytes)",
          "new_text": null,
          "old_line_content": "                RecordBytesRecv(nBytes);",
          "new_line_content": "            if (nBytes > 0)",
          "content_same": false
        },
        {
          "line": 1314,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pnode->cs_vProcessMsg)",
          "new_text": null,
          "old_line_content": "                        LOCK(pnode->cs_vProcessMsg);",
          "new_line_content": "                    for (const auto& msg : pnode->vRecvMsg) {",
          "content_same": false
        },
        {
          "line": 1315,
          "old_api": "end",
          "new_api": null,
          "old_text": "pnode->vProcessMsg.end()",
          "new_text": null,
          "old_line_content": "                        pnode->vProcessMsg.splice(pnode->vProcessMsg.end(), pnode->vRecvMsg);",
          "new_line_content": "                        // vRecvMsg contains only completed CNetMessage",
          "content_same": false
        },
        {
          "line": 1319,
          "old_api": "WakeMessageHandler",
          "new_api": null,
          "old_text": "WakeMessageHandler()",
          "new_text": null,
          "old_line_content": "                    WakeMessageHandler();",
          "new_line_content": "                    {",
          "content_same": false
        },
        {
          "line": 1326,
          "old_api": "GetId",
          "new_api": null,
          "old_text": "pnode->GetId()",
          "new_text": null,
          "old_line_content": "                    LogPrint(BCLog::NET, \"socket closed for peer=%d\\n\", pnode->GetId());",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1328,
          "old_api": "CloseSocketDisconnect",
          "new_api": null,
          "old_text": "pnode->CloseSocketDisconnect()",
          "new_text": null,
          "old_line_content": "                pnode->CloseSocketDisconnect();",
          "new_line_content": "            else if (nBytes == 0)",
          "content_same": false
        },
        {
          "line": 1333,
          "old_api": "WSAGetLastError",
          "new_api": null,
          "old_text": "WSAGetLastError()",
          "new_text": null,
          "old_line_content": "                int nErr = WSAGetLastError();",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1337,
          "old_api": "NetworkErrorString",
          "new_api": null,
          "old_text": "NetworkErrorString(nErr)",
          "new_text": null,
          "old_line_content": "                        LogPrint(BCLog::NET, \"socket recv error for peer=%d: %s\\n\", pnode->GetId(), NetworkErrorString(nErr));",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1346,
          "old_api": "SocketSendData",
          "new_api": null,
          "old_text": "SocketSendData(*pnode)",
          "new_text": null,
          "old_line_content": "            size_t bytes_sent = WITH_LOCK(pnode->cs_vSend, return SocketSendData(*pnode));",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1347,
          "old_api": "RecordBytesSent",
          "new_api": null,
          "old_text": "RecordBytesSent(bytes_sent)",
          "new_text": null,
          "old_line_content": "            if (bytes_sent) RecordBytesSent(bytes_sent);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1350,
          "old_api": "InactivityCheck",
          "new_api": null,
          "old_text": "InactivityCheck(*pnode)",
          "new_text": null,
          "old_line_content": "        if (InactivityCheck(*pnode)) pnode->fDisconnect = true;",
          "new_line_content": "        if (sendSet) {",
          "content_same": false
        },
        {
          "line": 1360,
          "old_api": "find",
          "new_api": null,
          "old_text": "events_per_sock.find(listen_socket.sock)",
          "new_text": null,
          "old_line_content": "        const auto it = events_per_sock.find(listen_socket.sock);",
          "new_line_content": "void CConnman::SocketHandlerListening(const Sock::EventsPerSock& events_per_sock)",
          "content_same": false
        },
        {
          "line": 1361,
          "old_api": "end",
          "new_api": null,
          "old_text": "events_per_sock.end()",
          "new_text": null,
          "old_line_content": "        if (it != events_per_sock.end() && it->second.occurred & Sock::RECV) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1362,
          "old_api": "AcceptConnection",
          "new_api": null,
          "old_text": "AcceptConnection(listen_socket)",
          "new_text": null,
          "old_line_content": "            AcceptConnection(listen_socket);",
          "new_line_content": "    for (const ListenSocket& listen_socket : vhListenSocket) {",
          "content_same": false
        },
        {
          "line": 1369,
          "old_api": "AssertLockNotHeld",
          "new_api": null,
          "old_text": "AssertLockNotHeld(m_total_bytes_sent_mutex)",
          "new_text": null,
          "old_line_content": "    AssertLockNotHeld(m_total_bytes_sent_mutex);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1371,
          "old_api": "SetSyscallSandboxPolicy",
          "new_api": null,
          "old_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET)",
          "new_text": null,
          "old_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1374,
          "old_api": "DisconnectNodes",
          "new_api": null,
          "old_text": "DisconnectNodes()",
          "new_text": null,
          "old_line_content": "        DisconnectNodes();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1376,
          "old_api": "SocketHandler",
          "new_api": null,
          "old_text": "SocketHandler()",
          "new_text": null,
          "old_line_content": "        SocketHandler();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1383,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(mutexMsgProc)",
          "new_text": null,
          "old_line_content": "        LOCK(mutexMsgProc);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1386,
          "old_api": "notify_one",
          "new_api": null,
          "old_text": "condMsgProc.notify_one()",
          "new_text": null,
          "old_line_content": "    condMsgProc.notify_one();",
          "new_line_content": "void CConnman::WakeMessageHandler()",
          "content_same": false
        },
        {
          "line": 1391,
          "old_api": "SetSyscallSandboxPolicy",
          "new_api": null,
          "old_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::INITIALIZATION_DNS_SEED)",
          "new_text": null,
          "old_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::INITIALIZATION_DNS_SEED);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1393,
          "old_api": "DNSSeeds",
          "new_api": null,
          "old_text": "Params().DNSSeeds()",
          "new_text": null,
          "old_line_content": "    std::vector<std::string> seeds = Params().DNSSeeds();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1394,
          "old_api": "end",
          "new_api": null,
          "old_text": "seeds.end()",
          "new_text": null,
          "old_line_content": "    Shuffle(seeds.begin(), seeds.end(), rng);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1398,
          "old_api": "GetBoolArg",
          "new_api": null,
          "old_text": "gArgs.GetBoolArg(\"-forcednsseed\", DEFAULT_FORCEDNSSEED)",
          "new_text": null,
          "old_line_content": "    if (gArgs.GetBoolArg(\"-forcednsseed\", DEFAULT_FORCEDNSSEED)) {",
          "new_line_content": "    FastRandomContext rng;",
          "content_same": false
        },
        {
          "line": 1401,
          "old_api": "Size",
          "new_api": null,
          "old_text": "addrman.Size()",
          "new_text": null,
          "old_line_content": "    } else if (addrman.Size() == 0) {",
          "new_line_content": "    int seeds_right_now = 0; // Number of seeds left before testing if we have enough connections",
          "content_same": false
        },
        {
          "line": 1405,
          "old_api": "size",
          "new_api": null,
          "old_text": "seeds.size()",
          "new_text": null,
          "old_line_content": "        seeds_right_now = seeds.size();",
          "new_line_content": "        // When -forcednsseed is provided, query all.",
          "content_same": false
        },
        {
          "line": 1420,
          "old_api": "Size",
          "new_api": null,
          "old_text": "addrman.Size()",
          "new_text": null,
          "old_line_content": "    const std::chrono::seconds seeds_wait_time = (addrman.Size() >= DNSSEEDS_DELAY_PEER_THRESHOLD ? DNSSEEDS_DELAY_MANY_PEERS : DNSSEEDS_DELAY_FEW_PEERS);",
          "new_line_content": "    // * When querying DNS seeds query a few at once, this ensures",
          "content_same": false
        },
        {
          "line": 1427,
          "old_api": "count",
          "new_api": null,
          "old_text": "seeds_wait_time.count()",
          "new_text": null,
          "old_line_content": "                LogPrintf(\"Waiting %d seconds before querying DNS seeds.\\n\", seeds_wait_time.count());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1429,
          "old_api": "count",
          "new_api": null,
          "old_text": "to_wait.count()",
          "new_text": null,
          "old_line_content": "                while (to_wait.count() > 0) {",
          "new_line_content": "        if (seeds_right_now == 0) {",
          "content_same": false
        },
        {
          "line": 1434,
          "old_api": "sleep_for",
          "new_api": null,
          "old_text": "interruptNet.sleep_for(w)",
          "new_text": null,
          "old_line_content": "                    if (!interruptNet.sleep_for(w)) return;",
          "new_line_content": "                std::chrono::seconds to_wait = seeds_wait_time;",
          "content_same": false
        },
        {
          "line": 1441,
          "old_api": "IsFullOutboundConn",
          "new_api": null,
          "old_text": "pnode->IsFullOutboundConn()",
          "new_text": null,
          "old_line_content": "                            if (pnode->fSuccessfullyConnected && pnode->IsFullOutboundConn()) ++nRelevant;",
          "new_line_content": "                    to_wait -= w;",
          "content_same": false
        },
        {
          "line": 1446,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"%d addresses found from DNS seeds\\n\", found)",
          "new_text": null,
          "old_line_content": "                            LogPrintf(\"%d addresses found from DNS seeds\\n\", found);",
          "new_line_content": "                        for (const CNode* pnode : m_nodes) {",
          "content_same": false
        },
        {
          "line": 1449,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"P2P peers available. Skipped DNS seeding.\\n\")",
          "new_text": null,
          "old_line_content": "                            LogPrintf(\"P2P peers available. Skipped DNS seeding.\\n\");",
          "new_line_content": "                    }",
          "content_same": false
        },
        {
          "line": 1461,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"Waiting for network to be reactivated before querying DNS seeds.\\n\")",
          "new_text": null,
          "old_line_content": "            LogPrintf(\"Waiting for network to be reactivated before querying DNS seeds.\\n\");",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1463,
          "old_api": "sleep_for",
          "new_api": null,
          "old_text": "interruptNet.sleep_for(std::chrono::seconds{1})",
          "new_text": null,
          "old_line_content": "                if (!interruptNet.sleep_for(std::chrono::seconds{1})) return;",
          "new_line_content": "        if (interruptNet) return;",
          "content_same": false
        },
        {
          "line": 1468,
          "old_api": "HaveNameProxy",
          "new_api": null,
          "old_text": "HaveNameProxy()",
          "new_text": null,
          "old_line_content": "        if (HaveNameProxy()) {",
          "new_line_content": "            do {",
          "content_same": false
        },
        {
          "line": 1476,
          "old_api": "SetInternal",
          "new_api": null,
          "old_text": "resolveSource.SetInternal(host)",
          "new_text": null,
          "old_line_content": "            if (!resolveSource.SetInternal(host)) {",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 1483,
          "old_api": "Now<NodeSeconds>()",
          "new_api": null,
          "old_text": "Now<NodeSeconds>()",
          "new_text": null,
          "old_line_content": "                    addr.nTime = rng.rand_uniform_delay(Now<NodeSeconds>() - 3 * 24h, -4 * 24h); // use a random age between 3 and 7 days old",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 1484,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "vAdd.push_back(addr)",
          "new_text": null,
          "old_line_content": "                    vAdd.push_back(addr);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1487,
          "old_api": "Add",
          "new_api": null,
          "old_text": "addrman.Add(vAdd, resolveSource)",
          "new_text": null,
          "old_line_content": "                addrman.Add(vAdd, resolveSource);",
          "new_line_content": "                for (const CNetAddr& ip : vIPs) {",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": "AddAddrFetch",
          "new_api": null,
          "old_text": "AddAddrFetch(seed)",
          "new_text": null,
          "old_line_content": "                AddAddrFetch(seed);",
          "new_line_content": "                    found++;",
          "content_same": false
        },
        {
          "line": 1496,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"%d addresses found from DNS seeds\\n\", found)",
          "new_text": null,
          "old_line_content": "    LogPrintf(\"%d addresses found from DNS seeds\\n\", found);",
          "new_line_content": "                // instead using them as a addrfetch to get nodes with our desired service bits.",
          "content_same": false
        },
        {
          "line": 1501,
          "old_api": "SteadyClock::now()",
          "new_api": null,
          "old_text": "SteadyClock::now()",
          "new_text": null,
          "old_line_content": "    const auto start{SteadyClock::now()};",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1503,
          "old_api": "DumpPeerAddresses",
          "new_api": null,
          "old_text": "DumpPeerAddresses(::gArgs, addrman)",
          "new_text": null,
          "old_line_content": "    DumpPeerAddresses(::gArgs, addrman);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1505,
          "old_api": "Size",
          "new_api": null,
          "old_text": "LogPrint(BCLog::NET, \"Flushed %d addresses to peers.dat  %dms\\n\",\n             addrman.Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start))",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::NET, \"Flushed %d addresses to peers.dat  %dms\\n\",",
          "new_line_content": "void CConnman::DumpAddresses()",
          "content_same": false
        },
        {
          "line": 1506,
          "old_api": "SteadyClock::now()",
          "new_api": null,
          "old_text": "SteadyClock::now()",
          "new_text": null,
          "old_line_content": "             addrman.Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1513,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_addr_fetches_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_addr_fetches_mutex);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1514,
          "old_api": "empty",
          "new_api": null,
          "old_text": "m_addr_fetches.empty()",
          "new_text": null,
          "old_line_content": "        if (m_addr_fetches.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1516,
          "old_api": "front",
          "new_api": null,
          "old_text": "m_addr_fetches.front()",
          "new_text": null,
          "old_line_content": "        strDest = m_addr_fetches.front();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1517,
          "old_api": "pop_front",
          "new_api": null,
          "old_text": "m_addr_fetches.pop_front()",
          "new_text": null,
          "old_line_content": "        m_addr_fetches.pop_front();",
          "new_line_content": "    std::string strDest;",
          "content_same": false
        },
        {
          "line": 1534,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::NET, \"setting try another outbound peer=%s\\n\", flag ? \"true\" : \"false\")",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::NET, \"setting try another outbound peer=%s\\n\", flag ? \"true\" : \"false\");",
          "new_line_content": "    return m_try_another_outbound_peer;",
          "content_same": false
        },
        {
          "line": 1539,
          "old_api": "LogPrint",
          "new_api": null,
          "old_text": "LogPrint(BCLog::NET, \"enabling extra block-relay-only peers\\n\")",
          "new_text": null,
          "old_line_content": "    LogPrint(BCLog::NET, \"enabling extra block-relay-only peers\\n\");",
          "new_line_content": "    m_try_another_outbound_peer = flag;",
          "content_same": false
        },
        {
          "line": 1553,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_nodes_mutex);",
          "new_line_content": "// (so that we don't decide we're over our desired connection limit, and then",
          "content_same": false
        },
        {
          "line": 1555,
          "old_api": "IsFullOutboundConn",
          "new_api": null,
          "old_text": "pnode->IsFullOutboundConn()",
          "new_text": null,
          "old_line_content": "            if (pnode->fSuccessfullyConnected && !pnode->fDisconnect && pnode->IsFullOutboundConn()) {",
          "new_line_content": "int CConnman::GetExtraFullOutboundCount() const",
          "content_same": false
        },
        {
          "line": 1560,
          "old_api": "std::max(full_outbound_peers - m_max_outbound_full_relay, 0)",
          "new_api": null,
          "old_text": "std::max(full_outbound_peers - m_max_outbound_full_relay, 0)",
          "new_text": null,
          "old_line_content": "    return std::max(full_outbound_peers - m_max_outbound_full_relay, 0);",
          "new_line_content": "        for (const CNode* pnode : m_nodes) {",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_nodes_mutex);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1569,
          "old_api": "IsBlockOnlyConn",
          "new_api": null,
          "old_text": "pnode->IsBlockOnlyConn()",
          "new_text": null,
          "old_line_content": "            if (pnode->fSuccessfullyConnected && !pnode->fDisconnect && pnode->IsBlockOnlyConn()) {",
          "new_line_content": "int CConnman::GetExtraBlockRelayCount() const",
          "content_same": false
        },
        {
          "line": 1574,
          "old_api": "std::max(block_relay_peers - m_max_outbound_block_relay, 0)",
          "new_api": null,
          "old_text": "std::max(block_relay_peers - m_max_outbound_block_relay, 0)",
          "new_text": null,
          "old_line_content": "    return std::max(block_relay_peers - m_max_outbound_block_relay, 0);",
          "new_line_content": "        for (const CNode* pnode : m_nodes) {",
          "content_same": false
        },
        {
          "line": 1583,
          "old_api": "Size",
          "new_api": null,
          "old_text": "addrman.Size(net, std::nullopt)",
          "new_text": null,
          "old_line_content": "        if (IsReachable(net) && addrman.Size(net, std::nullopt) == 0) {",
          "new_line_content": "std::unordered_set<Network> CConnman::GetReachableEmptyNetworks() const",
          "content_same": false
        },
        {
          "line": 1584,
          "old_api": "insert",
          "new_api": null,
          "old_text": "networks.insert(net)",
          "new_text": null,
          "old_line_content": "            networks.insert(net);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1592,
          "old_api": "SetSyscallSandboxPolicy",
          "new_api": null,
          "old_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET_OPEN_CONNECTION)",
          "new_text": null,
          "old_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET_OPEN_CONNECTION);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1595,
          "old_api": "empty",
          "new_api": null,
          "old_text": "connect.empty()",
          "new_text": null,
          "old_line_content": "    if (!connect.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": "ProcessAddrFetch",
          "new_api": null,
          "old_text": "ProcessAddrFetch()",
          "new_text": null,
          "old_line_content": "            ProcessAddrFetch();",
          "new_line_content": "    FastRandomContext rng;",
          "content_same": false
        },
        {
          "line": 1603,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "strAddr.c_str()",
          "new_text": null,
          "old_line_content": "                OpenNetworkConnection(addr, false, nullptr, strAddr.c_str(), ConnectionType::MANUAL);",
          "new_line_content": "        for (int64_t nLoop = 0;; nLoop++)",
          "content_same": false
        },
        {
          "line": 1606,
          "old_api": "std::chrono::milliseconds(500)",
          "new_api": null,
          "old_text": "std::chrono::milliseconds(500)",
          "new_text": null,
          "old_line_content": "                    if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))",
          "new_line_content": "            for (const std::string& strAddr : connect)",
          "content_same": false
        },
        {
          "line": 1610,
          "old_api": "std::chrono::milliseconds(500)",
          "new_api": null,
          "old_text": "std::chrono::milliseconds(500)",
          "new_text": null,
          "old_line_content": "            if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))",
          "new_line_content": "                for (int i = 0; i < 10 && i < nLoop; i++)",
          "content_same": false
        },
        {
          "line": 1619,
          "old_api": "GetExponentialRand",
          "new_api": null,
          "old_text": "GetExponentialRand(start, FEELER_INTERVAL)",
          "new_text": null,
          "old_line_content": "    auto next_feeler = GetExponentialRand(start, FEELER_INTERVAL);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1620,
          "old_api": "GetExponentialRand",
          "new_api": null,
          "old_text": "GetExponentialRand(start, EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL)",
          "new_text": null,
          "old_line_content": "    auto next_extra_block_relay = GetExponentialRand(start, EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1621,
          "old_api": "GetBoolArg",
          "new_api": null,
          "old_text": "gArgs.GetBoolArg(\"-dnsseed\", DEFAULT_DNSSEED)",
          "new_text": null,
          "old_line_content": "    const bool dnsseed = gArgs.GetBoolArg(\"-dnsseed\", DEFAULT_DNSSEED);",
          "new_line_content": "    // Initiate network connections",
          "content_same": false
        },
        {
          "line": 1630,
          "old_api": "ProcessAddrFetch",
          "new_api": null,
          "old_text": "ProcessAddrFetch()",
          "new_text": null,
          "old_line_content": "        ProcessAddrFetch();",
          "new_line_content": "    if (!add_fixed_seeds) {",
          "content_same": false
        },
        {
          "line": 1632,
          "old_api": "std::chrono::milliseconds(500)",
          "new_api": null,
          "old_text": "std::chrono::milliseconds(500)",
          "new_text": null,
          "old_line_content": "        if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1639,
          "old_api": "GetReachableEmptyNetworks",
          "new_api": null,
          "old_text": "GetReachableEmptyNetworks()",
          "new_text": null,
          "old_line_content": "        const std::unordered_set<Network> fixed_seed_networks{GetReachableEmptyNetworks()};",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 1640,
          "old_api": "empty",
          "new_api": null,
          "old_text": "fixed_seed_networks.empty()",
          "new_text": null,
          "old_line_content": "        if (add_fixed_seeds && !fixed_seed_networks.empty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1647,
          "old_api": "GetTime<std::chrono::seconds>()",
          "new_api": null,
          "old_text": "GetTime<std::chrono::seconds>()",
          "new_text": null,
          "old_line_content": "            if (GetTime<std::chrono::seconds>() > start + std::chrono::minutes{1}) {",
          "new_line_content": "            // When the node starts with an empty peers.dat, there are a few other sources of peers before",
          "content_same": false
        },
        {
          "line": 1649,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"Adding fixed seeds as 60 seconds have passed and addrman is empty for at least one reachable network\\n\")",
          "new_text": null,
          "old_line_content": "                LogPrintf(\"Adding fixed seeds as 60 seconds have passed and addrman is empty for at least one reachable network\\n\");",
          "new_line_content": "            // If none of those are available, we fallback on to fixed seeds immediately, else we allow",
          "content_same": false
        },
        {
          "line": 1654,
          "old_api": "LOCK2",
          "new_api": null,
          "old_text": "LOCK2(m_addr_fetches_mutex, m_added_nodes_mutex)",
          "new_text": null,
          "old_line_content": "                LOCK2(m_addr_fetches_mutex, m_added_nodes_mutex);",
          "new_line_content": "                add_fixed_seeds_now = true;",
          "content_same": false
        },
        {
          "line": 1657,
          "old_api": "LogPrintf",
          "new_api": null,
          "old_text": "LogPrintf(\"Adding fixed seeds as -dnsseed=0 (or IPv4/IPv6 connections are disabled via -onlynet), -addnode is not provided and all -seednode(s) attempted\\n\")",
          "new_text": null,
          "old_line_content": "                    LogPrintf(\"Adding fixed seeds as -dnsseed=0 (or IPv4/IPv6 connections are disabled via -onlynet), -addnode is not provided and all -seednode(s) attempted\\n\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1662,
          "old_api": "FixedSeeds",
          "new_api": null,
          "old_text": "Params().FixedSeeds()",
          "new_text": null,
          "old_line_content": "                std::vector<CAddress> seed_addrs{ConvertSeeds(Params().FixedSeeds())};",
          "new_line_content": "                    add_fixed_seeds_now = true;",
          "content_same": false
        },
        {
          "line": 1669,
          "old_api": "end",
          "new_api": null,
          "old_text": "seed_addrs.end()",
          "new_text": null,
          "old_line_content": "                seed_addrs.erase(std::remove_if(seed_addrs.begin(), seed_addrs.end(),",
          "new_line_content": "                // We will not make outgoing connections to peers that are unreachable",
          "content_same": false
        },
        {
          "line": 1670,
          "old_api": "GetNetwork",
          "new_api": null,
          "old_text": "addr.GetNetwork()",
          "new_text": null,
          "old_line_content": "                                                [&fixed_seed_networks](const CAddress& addr) { return fixed_seed_networks.count(addr.GetNetwork()) == 0; }),",
          "new_line_content": "                // (e.g. because of -onlynet configuration).",
          "content_same": false
        },
        {
          "line": 1671,
          "old_api": "end",
          "new_api": null,
          "old_text": "seed_addrs.end()",
          "new_text": null,
          "old_line_content": "                                 seed_addrs.end());",
          "new_line_content": "                // Therefore, we do not add them to addrman in the first place.",
          "content_same": false
        },
        {
          "line": 1673,
          "old_api": "SetInternal",
          "new_api": null,
          "old_text": "local.SetInternal(\"fixedseeds\")",
          "new_text": null,
          "old_line_content": "                local.SetInternal(\"fixedseeds\");",
          "new_line_content": "                // (e.g. in case of -onlynet changes by the user), fixed seeds will",
          "content_same": false
        },
        {
          "line": 1674,
          "old_api": "Add",
          "new_api": null,
          "old_text": "addrman.Add(seed_addrs, local)",
          "new_text": null,
          "old_line_content": "                addrman.Add(seed_addrs, local);",
          "new_line_content": "                // be loaded only for networks for which we have no addressses.",
          "content_same": false
        },
        {
          "line": 1691,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "            LOCK(m_nodes_mutex);",
          "new_line_content": "        // Only connect out to one peer per network group (/16 for IPv4).",
          "content_same": false
        },
        {
          "line": 1693,
          "old_api": "IsFullOutboundConn",
          "new_api": null,
          "old_text": "pnode->IsFullOutboundConn()",
          "new_text": null,
          "old_line_content": "                if (pnode->IsFullOutboundConn()) nOutboundFullRelay++;",
          "new_line_content": "        int nOutboundBlockRelay = 0;",
          "content_same": false
        },
        {
          "line": 1694,
          "old_api": "IsBlockOnlyConn",
          "new_api": null,
          "old_text": "pnode->IsBlockOnlyConn()",
          "new_text": null,
          "old_line_content": "                if (pnode->IsBlockOnlyConn()) nOutboundBlockRelay++;",
          "new_line_content": "        std::set<std::vector<unsigned char> > setConnected;",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": "GetGroup",
          "new_api": null,
          "old_text": "m_netgroupman.GetGroup(pnode->addr)",
          "new_text": null,
          "old_line_content": "                        setConnected.insert(m_netgroupman.GetGroup(pnode->addr));",
          "new_line_content": "                    case ConnectionType::MANUAL:",
          "content_same": false
        },
        {
          "line": 1730,
          "old_api": "empty",
          "new_api": null,
          "old_text": "m_anchors.empty()",
          "new_text": null,
          "old_line_content": "        if (!m_anchors.empty() && (nOutboundBlockRelay < m_max_outbound_block_relay)) {",
          "new_line_content": "        // GetTryNewOutboundPeer() gets set when a stale tip is detected, so we",
          "content_same": false
        },
        {
          "line": 1737,
          "old_api": "GetTryNewOutboundPeer",
          "new_api": null,
          "old_text": "GetTryNewOutboundPeer()",
          "new_text": null,
          "old_line_content": "        } else if (GetTryNewOutboundPeer()) {",
          "new_line_content": "            conn_type = ConnectionType::BLOCK_RELAY;",
          "content_same": false
        },
        {
          "line": 1761,
          "old_api": "GetExponentialRand",
          "new_api": null,
          "old_text": "GetExponentialRand(now, EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL)",
          "new_text": null,
          "old_line_content": "            next_extra_block_relay = GetExponentialRand(now, EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL);",
          "new_line_content": "            //   newest block-relay-only peer delivers a block more recently.",
          "content_same": false
        },
        {
          "line": 1764,
          "old_api": "GetExponentialRand",
          "new_api": null,
          "old_text": "GetExponentialRand(now, FEELER_INTERVAL)",
          "new_text": null,
          "old_line_content": "            next_feeler = GetExponentialRand(now, FEELER_INTERVAL);",
          "new_line_content": "            // Because we can promote these connections to block-relay-only",
          "content_same": false
        },
        {
          "line": 1772,
          "old_api": "ResolveCollisions",
          "new_api": null,
          "old_text": "addrman.ResolveCollisions()",
          "new_text": null,
          "old_line_content": "        addrman.ResolveCollisions();",
          "new_line_content": "            fFeeler = true;",
          "content_same": false
        },
        {
          "line": 1774,
          "old_api": "NodeClock::now()",
          "new_api": null,
          "old_text": "NodeClock::now()",
          "new_text": null,
          "old_line_content": "        const auto current_time{NodeClock::now()};",
          "new_line_content": "            // skip to next iteration of while loop",
          "content_same": false
        },
        {
          "line": 1779,
          "old_api": "back",
          "new_api": null,
          "old_text": "m_anchors.back()",
          "new_text": null,
          "old_line_content": "                const CAddress addr = m_anchors.back();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1781,
          "old_api": "IsReachable",
          "new_api": null,
          "old_text": "IsReachable(addr)",
          "new_text": null,
          "old_line_content": "                if (!addr.IsValid() || IsLocal(addr) || !IsReachable(addr) ||",
          "new_line_content": "        int nTries = 0;",
          "content_same": false
        },
        {
          "line": 1782,
          "old_api": "HasAllDesirableServiceFlags",
          "new_api": null,
          "old_text": "HasAllDesirableServiceFlags(addr.nServices)",
          "new_text": null,
          "old_line_content": "                    !HasAllDesirableServiceFlags(addr.nServices) ||",
          "new_line_content": "        while (!interruptNet)",
          "content_same": false
        },
        {
          "line": 1783,
          "old_api": "GetGroup",
          "new_api": null,
          "old_text": "m_netgroupman.GetGroup(addr)",
          "new_text": null,
          "old_line_content": "                    setConnected.count(m_netgroupman.GetGroup(addr))) continue;",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 1802,
          "old_api": "SelectTriedCollision",
          "new_api": null,
          "old_text": "addrman.SelectTriedCollision()",
          "new_text": null,
          "old_line_content": "                std::tie(addr, addr_last_try) = addrman.SelectTriedCollision();",
          "new_line_content": "            CAddress addr;",
          "content_same": false
        },
        {
          "line": 1804,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "addr.IsValid()",
          "new_text": null,
          "old_line_content": "                if (!addr.IsValid()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1807,
          "old_api": "Select",
          "new_api": null,
          "old_text": "addrman.Select(true)",
          "new_text": null,
          "old_line_content": "                    std::tie(addr, addr_last_try) = addrman.Select(true);",
          "new_line_content": "                // an empty (invalid) address if there are no collisions to try.",
          "content_same": false
        },
        {
          "line": 1816,
          "old_api": "Select",
          "new_api": null,
          "old_text": "addrman.Select(true)",
          "new_text": null,
          "old_line_content": "                    std::tie(addr, addr_last_try) = addrman.Select(true);",
          "new_line_content": "                    // peer that we're already connected to, just mark that",
          "content_same": false
        },
        {
          "line": 1824,
          "old_api": "GetGroup",
          "new_api": null,
          "old_text": "m_netgroupman.GetGroup(addr)",
          "new_text": null,
          "old_line_content": "            if (!fFeeler && setConnected.count(m_netgroupman.GetGroup(addr))) {",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 1829,
          "old_api": "IsLocal",
          "new_api": null,
          "old_text": "IsLocal(addr)",
          "new_text": null,
          "old_line_content": "            if (!addr.IsValid() || IsLocal(addr)) {",
          "new_line_content": "            // Require outbound connections, other than feelers, to be to distinct network groups",
          "content_same": false
        },
        {
          "line": 1833,
          "old_api": "IsReachable",
          "new_api": null,
          "old_text": "IsReachable(addr)",
          "new_text": null,
          "old_line_content": "            if (!IsReachable(addr))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1844,
          "old_api": "HasAllDesirableServiceFlags",
          "new_api": null,
          "old_text": "HasAllDesirableServiceFlags(addr.nServices)",
          "new_text": null,
          "old_line_content": "            if (!fFeeler && !HasAllDesirableServiceFlags(addr.nServices)) {",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 1846,
          "old_api": "MayHaveUsefulAddressDB",
          "new_api": null,
          "old_text": "MayHaveUsefulAddressDB(addr.nServices)",
          "new_text": null,
          "old_line_content": "            } else if (fFeeler && !MayHaveUsefulAddressDB(addr.nServices)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1851,
          "old_api": "GetPort",
          "new_api": null,
          "old_text": "addr.GetPort()",
          "new_text": null,
          "old_line_content": "            if (nTries < 50 && (addr.IsIPv4() || addr.IsIPv6()) && IsBadPort(addr.GetPort())) {",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 1859,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "addrConnect.IsValid()",
          "new_text": null,
          "old_line_content": "        if (addrConnect.IsValid()) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1862,
          "old_api": "rng.rand_uniform_duration<CThreadInterrupt::Clock>(FEELER_SLEEP_WINDOW)",
          "new_api": null,
          "old_text": "rng.rand_uniform_duration<CThreadInterrupt::Clock>(FEELER_SLEEP_WINDOW)",
          "new_text": null,
          "old_line_content": "                if (!interruptNet.sleep_for(rng.rand_uniform_duration<CThreadInterrupt::Clock>(FEELER_SLEEP_WINDOW))) {",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 1876,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "    LOCK(m_nodes_mutex);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1878,
          "old_api": "IsBlockOnlyConn",
          "new_api": null,
          "old_text": "pnode->IsBlockOnlyConn()",
          "new_text": null,
          "old_line_content": "        if (pnode->IsBlockOnlyConn()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1879,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "ret.push_back(pnode->addr)",
          "new_text": null,
          "old_line_content": "            ret.push_back(pnode->addr);",
          "new_line_content": "std::vector<CAddress> CConnman::GetCurrentBlockRelayOnlyConns() const",
          "content_same": false
        },
        {
          "line": 1892,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_added_nodes_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_added_nodes_mutex);",
          "new_line_content": "std::vector<AddedNodeInfo> CConnman::GetAddedNodeInfo() const",
          "content_same": false
        },
        {
          "line": 1893,
          "old_api": "size",
          "new_api": null,
          "old_text": "m_added_nodes.size()",
          "new_text": null,
          "old_line_content": "        ret.reserve(m_added_nodes.size());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1894,
          "old_api": "std::back_inserter(lAddresses)",
          "new_api": null,
          "old_text": "std::back_inserter(lAddresses)",
          "new_text": null,
          "old_line_content": "        std::copy(m_added_nodes.cbegin(), m_added_nodes.cend(), std::back_inserter(lAddresses));",
          "new_line_content": "    std::vector<AddedNodeInfo> ret;",
          "content_same": false
        },
        {
          "line": 1902,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_nodes_mutex);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1904,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "pnode->addr.IsValid()",
          "new_text": null,
          "old_line_content": "            if (pnode->addr.IsValid()) {",
          "new_line_content": "    // Build a map of all already connected addresses (by IP:port and by name) to inbound/outbound and resolved CService",
          "content_same": false
        },
        {
          "line": 1905,
          "old_api": "IsInboundConn",
          "new_api": null,
          "old_text": "pnode->IsInboundConn()",
          "new_text": null,
          "old_line_content": "                mapConnected[pnode->addr] = pnode->IsInboundConn();",
          "new_line_content": "    std::map<CService, bool> mapConnected;",
          "content_same": false
        },
        {
          "line": 1909,
          "old_api": "static_cast<const CService&>(pnode->addr)",
          "new_api": null,
          "old_text": "static_cast<const CService&>(pnode->addr)",
          "new_text": null,
          "old_line_content": "                mapConnectedByName[std::move(addrName)] = std::make_pair(pnode->IsInboundConn(), static_cast<const CService&>(pnode->addr));",
          "new_line_content": "        for (const CNode* pnode : m_nodes) {",
          "content_same": false
        },
        {
          "line": 1916,
          "old_api": "CService",
          "new_api": null,
          "old_text": "CService()",
          "new_text": null,
          "old_line_content": "        AddedNodeInfo addedNode{strAddNode, CService(), false, false};",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1917,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "service.IsValid()",
          "new_text": null,
          "old_line_content": "        if (service.IsValid()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1919,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapConnected.find(service)",
          "new_text": null,
          "old_line_content": "            auto it = mapConnected.find(service);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1920,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapConnected.end()",
          "new_text": null,
          "old_line_content": "            if (it != mapConnected.end()) {",
          "new_line_content": "    for (const std::string& strAddNode : lAddresses) {",
          "content_same": false
        },
        {
          "line": 1927,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapConnectedByName.find(strAddNode)",
          "new_text": null,
          "old_line_content": "            auto it = mapConnectedByName.find(strAddNode);",
          "new_line_content": "                addedNode.resolvedAddress = service;",
          "content_same": false
        },
        {
          "line": 1928,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapConnectedByName.end()",
          "new_text": null,
          "old_line_content": "            if (it != mapConnectedByName.end()) {",
          "new_line_content": "                addedNode.fConnected = true;",
          "content_same": false
        },
        {
          "line": 1942,
          "old_api": "SetSyscallSandboxPolicy",
          "new_api": null,
          "old_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET_ADD_CONNECTION)",
          "new_text": null,
          "old_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::NET_ADD_CONNECTION);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1946,
          "old_api": "GetAddedNodeInfo",
          "new_api": null,
          "old_text": "GetAddedNodeInfo()",
          "new_text": null,
          "old_line_content": "        std::vector<AddedNodeInfo> vInfo = GetAddedNodeInfo();",
          "new_line_content": "void CConnman::ThreadOpenAddedConnections()",
          "content_same": false
        },
        {
          "line": 1950,
          "old_api": "TryAcquire",
          "new_api": null,
          "old_text": "grant.TryAcquire()",
          "new_text": null,
          "old_line_content": "                if (!grant.TryAcquire()) {",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1957,
          "old_api": "c_str",
          "new_api": null,
          "old_text": "info.strAddedNode.c_str()",
          "new_text": null,
          "old_line_content": "                OpenNetworkConnection(addr, false, &grant, info.strAddedNode.c_str(), ConnectionType::MANUAL);",
          "new_line_content": "                    // If we've used up our semaphore and need a new one, let's not wait here since while we are waiting",
          "content_same": false
        },
        {
          "line": 1958,
          "old_api": "std::chrono::milliseconds(500)",
          "new_api": null,
          "old_text": "std::chrono::milliseconds(500)",
          "new_text": null,
          "old_line_content": "                if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))",
          "new_line_content": "                    // the addednodeinfo state might change.",
          "content_same": false
        },
        {
          "line": 1971,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(conn_type != ConnectionType::INBOUND)",
          "new_text": null,
          "old_line_content": "    assert(conn_type != ConnectionType::INBOUND);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1983,
          "old_api": "IsBanned",
          "new_api": null,
          "old_text": "m_banman->IsBanned(addrConnect)",
          "new_text": null,
          "old_line_content": "        bool banned_or_discouraged = m_banman && (m_banman->IsDiscouraged(addrConnect) || m_banman->IsBanned(addrConnect));",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 1984,
          "old_api": "AlreadyConnectedToAddress",
          "new_api": null,
          "old_text": "AlreadyConnectedToAddress(addrConnect)",
          "new_text": null,
          "old_line_content": "        if (IsLocal(addrConnect) || banned_or_discouraged || AlreadyConnectedToAddress(addrConnect)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1987,
          "old_api": "std::string(pszDest)",
          "new_api": null,
          "old_text": "std::string(pszDest)",
          "new_text": null,
          "old_line_content": "    } else if (FindNode(std::string(pszDest)))",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1995,
          "old_api": "MoveTo",
          "new_api": null,
          "old_text": "grantOutbound->MoveTo(pnode->grantOutbound)",
          "new_text": null,
          "old_line_content": "        grantOutbound->MoveTo(pnode->grantOutbound);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1997,
          "old_api": "InitializeNode",
          "new_api": null,
          "old_text": "m_msgproc->InitializeNode(*pnode, nLocalServices)",
          "new_text": null,
          "old_line_content": "    m_msgproc->InitializeNode(*pnode, nLocalServices);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1999,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(m_nodes_mutex)",
          "new_text": null,
          "old_line_content": "        LOCK(m_nodes_mutex);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 2000,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "m_nodes.push_back(pnode)",
          "new_text": null,
          "old_line_content": "        m_nodes.push_back(pnode);",
          "new_line_content": "    if (grantOutbound)",
          "content_same": false
        },
        {
          "line": 2008,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(NetEventsInterface::g_msgproc_mutex)",
          "new_text": null,
          "old_line_content": "    LOCK(NetEventsInterface::g_msgproc_mutex);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2010,
          "old_api": "SetSyscallSandboxPolicy",
          "new_api": null,
          "old_text": "SetSyscallSandboxPolicy(SyscallSandboxPolicy::MESSAGE_HANDLER)",
          "new_text": null,
          "old_line_content": "    SetSyscallSandboxPolicy(SyscallSandboxPolicy::MESSAGE_HANDLER);",
          "new_line_content": "Mutex NetEventsInterface::g_msgproc_mutex;",
          "content_same": false
        },
        {
          "line": 2021,
          "old_api": "Nodes",
          "new_api": null,
          "old_text": "snap.Nodes()",
          "new_text": null,
          "old_line_content": "            for (CNode* pnode : snap.Nodes()) {",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2026,
          "old_api": "ProcessMessages",
          "new_api": null,
          "old_text": "m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc)",
          "new_text": null,
          "old_line_content": "                bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2031,
          "old_api": "SendMessages",
          "new_api": null,
          "old_text": "m_msgproc->SendMessages(pnode)",
          "new_text": null,
          "old_line_content": "                m_msgproc->SendMessages(pnode);",
          "new_line_content": "                // Receive messages",
          "content_same": false
        },
        {
          "line": 2038,
          "old_api": "WAIT_LOCK",
          "new_api": null,
          "old_text": "WAIT_LOCK(mutexMsgProc, lock)",
          "new_text": null,
          "old_line_content": "        WAIT_LOCK(mutexMsgProc, lock);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2040,
          "old_api": "std::chrono::milliseconds(100)",
          "new_api": null,
          "old_text": "std::chrono::milliseconds(100)",
          "new_text": null,
          "old_line_content": "            condMsgProc.wait_until(lock, std::chrono::steady_clock::now() + std::chrono::milliseconds(100), [this]() EXCLUSIVE_LOCKS_REQUIRED(mutexMsgProc) { return fMsgProcWake; });",
          "new_line_content": "                    return;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 126,
      "total_additions": 389,
      "total_deletions": 388,
      "total_api_changes": 903
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 8,
        "api_related_lines": 903,
        "non_api_lines": 6,
        "non_api_line_numbers": [
          832,
          836,
          838,
          840,
          842,
          844
        ]
      }
    },
    "api_calls_before": 1012,
    "api_calls_after": 1013,
    "diff_info": {
      "added_lines": 8,
      "removed_lines": 2,
      "total_diff_lines": 35
    }
  }
}