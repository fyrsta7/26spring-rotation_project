{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/c2a4724642400bc9200aeef4c725b5c07eee9d90",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/c2a4724642400bc9200aeef4c725b5c07eee9d90/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/c2a4724642400bc9200aeef4c725b5c07eee9d90/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/c2a4724642400bc9200aeef4c725b5c07eee9d90/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": true,
    "api_changes": {
      "replacements": [],
      "additions": [],
      "deletions": [
        {
          "line": 4096,
          "api": "GetConsensus",
          "text": "chainparams.GetConsensus()",
          "line_content": "                } else if (hash != chainparams.GetConsensus().hashGenesisBlock && mapBlockIndex[hash]->nHeight % 1000 == 0) {"
        },
        {
          "line": 4097,
          "api": "ToString",
          "text": "hash.ToString()",
          "line_content": "                    LogPrint(\"reindex\", \"Block Import: already had block %s at height %d\\n\", hash.ToString(), mapBlockIndex[hash]->nHeight);"
        },
        {
          "line": 4101,
          "api": "GetConsensus",
          "text": "chainparams.GetConsensus()",
          "line_content": "                if (hash == chainparams.GetConsensus().hashGenesisBlock) {"
        },
        {
          "line": 4103,
          "api": "ActivateBestChain",
          "text": "ActivateBestChain(state, chainparams)",
          "line_content": "                    if (!ActivateBestChain(state, chainparams)) {"
        },
        {
          "line": 4108,
          "api": "NotifyHeaderTip",
          "text": "NotifyHeaderTip()",
          "line_content": "                NotifyHeaderTip();"
        },
        {
          "line": 4112,
          "api": "push_back",
          "text": "queue.push_back(hash)",
          "line_content": "                queue.push_back(hash);"
        },
        {
          "line": 4113,
          "api": "empty",
          "text": "queue.empty()",
          "line_content": "                while (!queue.empty()) {"
        },
        {
          "line": 4114,
          "api": "front",
          "text": "queue.front()",
          "line_content": "                    uint256 head = queue.front();"
        },
        {
          "line": 4115,
          "api": "pop_front",
          "text": "queue.pop_front()",
          "line_content": "                    queue.pop_front();"
        },
        {
          "line": 4116,
          "api": "equal_range",
          "text": "mapBlocksUnknownParent.equal_range(head)",
          "line_content": "                    std::pair<std::multimap<uint256, CDiskBlockPos>::iterator, std::multimap<uint256, CDiskBlockPos>::iterator> range = mapBlocksUnknownParent.equal_range(head);"
        },
        {
          "line": 4119,
          "api": "GetConsensus",
          "text": "chainparams.GetConsensus()",
          "line_content": "                        if (ReadBlockFromDisk(block, it->second, chainparams.GetConsensus()))"
        },
        {
          "line": 4121,
          "api": "GetHash",
          "text": "block.GetHash().ToString()",
          "line_content": "                            LogPrint(\"reindex\", \"%s: Processing out of order child %s of %s\\n\", __func__, block.GetHash().ToString(),"
        },
        {
          "line": 4122,
          "api": "ToString",
          "text": "head.ToString()",
          "line_content": "                                    head.ToString());"
        },
        {
          "line": 4123,
          "api": "LOCK",
          "text": "LOCK(cs_main)",
          "line_content": "                            LOCK(cs_main);"
        },
        {
          "line": 4125,
          "api": "AcceptBlock",
          "text": "AcceptBlock(block, dummy, chainparams, NULL, true, &it->second)",
          "line_content": "                            if (AcceptBlock(block, dummy, chainparams, NULL, true, &it->second))"
        },
        {
          "line": 4128,
          "api": "GetHash",
          "text": "block.GetHash()",
          "line_content": "                                queue.push_back(block.GetHash());"
        },
        {
          "line": 4132,
          "api": "erase",
          "text": "mapBlocksUnknownParent.erase(it)",
          "line_content": "                        mapBlocksUnknownParent.erase(it);"
        },
        {
          "line": 4133,
          "api": "NotifyHeaderTip",
          "text": "NotifyHeaderTip()",
          "line_content": "                        NotifyHeaderTip();"
        },
        {
          "line": 4137,
          "api": "what",
          "text": "e.what()",
          "line_content": "                LogPrintf(\"%s: Deserialize or I/O error - %s\\n\", __func__, e.what());"
        },
        {
          "line": 4141,
          "api": "what",
          "text": "e.what()",
          "line_content": "        AbortNode(std::string(\"System error: \") + e.what());"
        },
        {
          "line": 4144,
          "api": "GetTimeMillis",
          "text": "GetTimeMillis()",
          "line_content": "        LogPrintf(\"Loaded %i blocks from external file in %dms\\n\", nLoaded, GetTimeMillis() - nStart);"
        },
        {
          "line": 4154,
          "api": "LOCK",
          "text": "LOCK(cs_main)",
          "line_content": "    LOCK(cs_main);"
        },
        {
          "line": 4159,
          "api": "Height",
          "text": "chainActive.Height()",
          "line_content": "    if (chainActive.Height() < 0) {"
        },
        {
          "line": 4160,
          "api": "size",
          "text": "mapBlockIndex.size()",
          "line_content": "        assert(mapBlockIndex.size() <= 1);"
        },
        {
          "line": 4166,
          "api": "end",
          "text": "mapBlockIndex.end()",
          "line_content": "    for (BlockMap::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); it++) {"
        },
        {
          "line": 4167,
          "api": "std::make_pair(it->second->pprev, it->second)",
          "text": "std::make_pair(it->second->pprev, it->second)",
          "line_content": "        forward.insert(std::make_pair(it->second->pprev, it->second));"
        },
        {
          "line": 4170,
          "api": "size",
          "text": "mapBlockIndex.size()",
          "line_content": "    assert(forward.size() == mapBlockIndex.size());"
        },
        {
          "line": 4172,
          "api": "equal_range",
          "text": "forward.equal_range(NULL)",
          "line_content": "    std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeGenesis = forward.equal_range(NULL);"
        },
        {
          "line": 4175,
          "api": "assert",
          "text": "assert(rangeGenesis.first == rangeGenesis.second)",
          "line_content": "    assert(rangeGenesis.first == rangeGenesis.second); // There is only one index entry with parent NULL."
        },
        {
          "line": 84,
          "api": "CFeeRate",
          "text": "CFeeRate(DEFAULT_MIN_RELAY_TX_FEE)",
          "line_content": "CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE);"
        },
        {
          "line": 96,
          "api": "EXCLUSIVE_LOCKS_REQUIRED",
          "text": "EXCLUSIVE_LOCKS_REQUIRED(cs_main)",
          "line_content": "void EraseOrphansFor(NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(cs_main);"
        },
        {
          "line": 4202,
          "api": "GetBlockHash",
          "text": "pindex->GetBlockHash()",
          "line_content": "            assert(pindex->GetBlockHash() == consensusParams.hashGenesisBlock); // Genesis block's hash must match."
        },
        {
          "line": 4203,
          "api": "Genesis",
          "text": "chainActive.Genesis()",
          "line_content": "            assert(pindex == chainActive.Genesis()); // The current active chain's genesis block must be this block."
        },
        {
          "line": 4205,
          "api": "assert",
          "text": "assert(pindex->nSequenceId == 0)",
          "line_content": "        if (pindex->nChainTx == 0) assert(pindex->nSequenceId == 0);  // nSequenceId can't be set for blocks that aren't linked"
        },
        {
          "line": 4210,
          "api": "assert",
          "text": "assert(!(pindex->nStatus & BLOCK_HAVE_DATA) == (pindex->nTx == 0))",
          "line_content": "            assert(!(pindex->nStatus & BLOCK_HAVE_DATA) == (pindex->nTx == 0));"
        },
        {
          "line": 4211,
          "api": "assert",
          "text": "assert(pindexFirstMissing == pindexFirstNeverProcessed)",
          "line_content": "            assert(pindexFirstMissing == pindexFirstNeverProcessed);"
        },
        {
          "line": 4214,
          "api": "assert",
          "text": "assert(pindex->nTx > 0)",
          "line_content": "            if (pindex->nStatus & BLOCK_HAVE_DATA) assert(pindex->nTx > 0);"
        },
        {
          "line": 4216,
          "api": "assert",
          "text": "assert(pindex->nStatus & BLOCK_HAVE_DATA)",
          "line_content": "        if (pindex->nStatus & BLOCK_HAVE_UNDO) assert(pindex->nStatus & BLOCK_HAVE_DATA);"
        },
        {
          "line": 4217,
          "api": "assert",
          "text": "assert(((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TRANSACTIONS) == (pindex->nTx > 0))",
          "line_content": "        assert(((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TRANSACTIONS) == (pindex->nTx > 0)); // This is pruning-independent."
        },
        {
          "line": 4219,
          "api": "assert",
          "text": "assert((pindexFirstNeverProcessed != NULL) == (pindex->nChainTx == 0))",
          "line_content": "        assert((pindexFirstNeverProcessed != NULL) == (pindex->nChainTx == 0)); // nChainTx != 0 is used to signal that all parent blocks have been processed (but may have been pruned)."
        },
        {
          "line": 4220,
          "api": "assert",
          "text": "assert((pindexFirstNotTransactionsValid != NULL) == (pindex->nChainTx == 0))",
          "line_content": "        assert((pindexFirstNotTransactionsValid != NULL) == (pindex->nChainTx == 0));"
        },
        {
          "line": 4221,
          "api": "assert",
          "text": "assert(pindex->nHeight == nHeight)",
          "line_content": "        assert(pindex->nHeight == nHeight); // nHeight must be consistent."
        },
        {
          "line": 4222,
          "api": "assert",
          "text": "assert(pindex->pprev == NULL || pindex->nChainWork >= pindex->pprev->nChainWork)",
          "line_content": "        assert(pindex->pprev == NULL || pindex->nChainWork >= pindex->pprev->nChainWork); // For every block except the genesis block, the chainwork must be larger than the parent's."
        },
        {
          "line": 4223,
          "api": "assert",
          "text": "assert(nHeight < 2 || (pindex->pskip && (pindex->pskip->nHeight < nHeight)))",
          "line_content": "        assert(nHeight < 2 || (pindex->pskip && (pindex->pskip->nHeight < nHeight))); // The pskip pointer must point back for all but the first 2 blocks."
        },
        {
          "line": 4224,
          "api": "assert",
          "text": "assert(pindexFirstNotTreeValid == NULL)",
          "line_content": "        assert(pindexFirstNotTreeValid == NULL); // All mapBlockIndex entries must at least be TREE valid"
        },
        {
          "line": 4225,
          "api": "assert",
          "text": "assert(pindexFirstNotTreeValid == NULL)",
          "line_content": "        if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TREE) assert(pindexFirstNotTreeValid == NULL); // TREE valid implies all parents are TREE valid"
        },
        {
          "line": 4226,
          "api": "assert",
          "text": "assert(pindexFirstNotChainValid == NULL)",
          "line_content": "        if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_CHAIN) assert(pindexFirstNotChainValid == NULL); // CHAIN valid implies all parents are CHAIN valid"
        },
        {
          "line": 4227,
          "api": "assert",
          "text": "assert(pindexFirstNotScriptsValid == NULL)",
          "line_content": "        if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_SCRIPTS) assert(pindexFirstNotScriptsValid == NULL); // SCRIPTS valid implies all parents are SCRIPTS valid"
        },
        {
          "line": 4230,
          "api": "assert",
          "text": "assert((pindex->nStatus & BLOCK_FAILED_MASK) == 0)",
          "line_content": "            assert((pindex->nStatus & BLOCK_FAILED_MASK) == 0); // The failed mask cannot be set for blocks without invalid parents."
        },
        {
          "line": 4232,
          "api": "Tip",
          "text": "chainActive.Tip()",
          "line_content": "        if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && pindexFirstNeverProcessed == NULL) {"
        },
        {
          "line": 4238,
          "api": "Tip",
          "text": "chainActive.Tip()",
          "line_content": "                if (pindexFirstMissing == NULL || pindex == chainActive.Tip()) {"
        },
        {
          "line": 4239,
          "api": "count",
          "text": "setBlockIndexCandidates.count(pindex)",
          "line_content": "                    assert(setBlockIndexCandidates.count(pindex));"
        },
        {
          "line": 4246,
          "api": "count",
          "text": "setBlockIndexCandidates.count(pindex)",
          "line_content": "            assert(setBlockIndexCandidates.count(pindex) == 0);"
        },
        {
          "line": 4249,
          "api": "equal_range",
          "text": "mapBlocksUnlinked.equal_range(pindex->pprev)",
          "line_content": "        std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeUnlinked = mapBlocksUnlinked.equal_range(pindex->pprev);"
        },
        {
          "line": 4252,
          "api": "assert",
          "text": "assert(rangeUnlinked.first->first == pindex->pprev)",
          "line_content": "            assert(rangeUnlinked.first->first == pindex->pprev);"
        },
        {
          "line": 4261,
          "api": "assert",
          "text": "assert(foundInUnlinked)",
          "line_content": "            assert(foundInUnlinked);"
        },
        {
          "line": 4263,
          "api": "assert",
          "text": "assert(!foundInUnlinked)",
          "line_content": "        if (!(pindex->nStatus & BLOCK_HAVE_DATA)) assert(!foundInUnlinked); // Can't be in mapBlocksUnlinked if we don't HAVE_DATA"
        },
        {
          "line": 4264,
          "api": "assert",
          "text": "assert(!foundInUnlinked)",
          "line_content": "        if (pindexFirstMissing == NULL) assert(!foundInUnlinked); // We aren't missing data for any parent -- cannot be in mapBlocksUnlinked."
        },
        {
          "line": 4267,
          "api": "assert",
          "text": "assert(fHavePruned)",
          "line_content": "            assert(fHavePruned); // We must have pruned."
        },
        {
          "line": 4276,
          "api": "count",
          "text": "setBlockIndexCandidates.count(pindex)",
          "line_content": "            if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && setBlockIndexCandidates.count(pindex) == 0) {"
        },
        {
          "line": 4278,
          "api": "assert",
          "text": "assert(foundInUnlinked)",
          "line_content": "                    assert(foundInUnlinked);"
        },
        {
          "line": 4286,
          "api": "equal_range",
          "text": "forward.equal_range(pindex)",
          "line_content": "        std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> range = forward.equal_range(pindex);"
        },
        {
          "line": 4308,
          "api": "equal_range",
          "text": "forward.equal_range(pindexPar)",
          "line_content": "            std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangePar = forward.equal_range(pindexPar);"
        },
        {
          "line": 4310,
          "api": "assert",
          "text": "assert(rangePar.first != rangePar.second)",
          "line_content": "                assert(rangePar.first != rangePar.second); // Our parent must have at least the node we're coming from as child."
        },
        {
          "line": 4329,
          "api": "size",
          "text": "forward.size()",
          "line_content": "    assert(nNodes == forward.size());"
        },
        {
          "line": 4340,
          "api": "_",
          "text": "_(\"This is a pre-release test build - use at your own risk - do not use for mining or merchant applications\")",
          "line_content": "        strGUI = _(\"This is a pre-release test build - use at your own risk - do not use for mining or merchant applications\");"
        },
        {
          "line": 4343,
          "api": "GetBoolArg",
          "text": "GetBoolArg(\"-testsafemode\", DEFAULT_TESTSAFEMODE)",
          "line_content": "    if (GetBoolArg(\"-testsafemode\", DEFAULT_TESTSAFEMODE))"
        },
        {
          "line": 4355,
          "api": "_",
          "text": "_(\"Warning: The network does not appear to fully agree! Some miners appear to be experiencing issues.\")",
          "line_content": "        strGUI = _(\"Warning: The network does not appear to fully agree! Some miners appear to be experiencing issues.\");"
        },
        {
          "line": 4360,
          "api": "_",
          "text": "_(\"Warning: We do not appear to fully agree with our peers! You may need to upgrade, or other nodes may need to upgrade.\")",
          "line_content": "        strGUI = _(\"Warning: We do not appear to fully agree with our peers! You may need to upgrade, or other nodes may need to upgrade.\");"
        },
        {
          "line": 4369,
          "api": "assert",
          "text": "assert(!\"GetWarnings(): invalid parameter\")",
          "line_content": "    assert(!\"GetWarnings(): invalid parameter\");"
        },
        {
          "line": 282,
          "api": "SetNull",
          "text": "hashLastUnknownBlock.SetNull()",
          "line_content": "        hashLastUnknownBlock.SetNull();"
        },
        {
          "line": 4392,
          "api": "assert",
          "text": "assert(recentRejects)",
          "line_content": "            assert(recentRejects);"
        },
        {
          "line": 4393,
          "api": "Tip",
          "text": "chainActive.Tip()->GetBlockHash()",
          "line_content": "            if (chainActive.Tip()->GetBlockHash() != hashRecentRejectsChainTip)"
        },
        {
          "line": 300,
          "api": "find",
          "text": "mapNodeState.find(pnode)",
          "line_content": "    map<NodeId, CNodeState>::iterator it = mapNodeState.find(pnode);"
        },
        {
          "line": 301,
          "api": "end",
          "text": "mapNodeState.end()",
          "line_content": "    if (it == mapNodeState.end())"
        },
        {
          "line": 4399,
          "api": "Tip",
          "text": "chainActive.Tip()->GetBlockHash()",
          "line_content": "                hashRecentRejectsChainTip = chainActive.Tip()->GetBlockHash();"
        },
        {
          "line": 4400,
          "api": "reset",
          "text": "recentRejects->reset()",
          "line_content": "                recentRejects->reset();"
        },
        {
          "line": 308,
          "api": "LOCK",
          "text": "LOCK(cs_main)",
          "line_content": "    LOCK(cs_main);"
        },
        {
          "line": 309,
          "api": "Height",
          "text": "chainActive.Height()",
          "line_content": "    return chainActive.Height();"
        },
        {
          "line": 4405,
          "api": "contains",
          "text": "recentRejects->contains(inv.hash)",
          "line_content": "            return recentRejects->contains(inv.hash) ||"
        },
        {
          "line": 4406,
          "api": "exists",
          "text": "mempool.exists(inv.hash)",
          "line_content": "                   mempool.exists(inv.hash) ||"
        },
        {
          "line": 4407,
          "api": "count",
          "text": "mapOrphanTransactions.count(inv.hash)",
          "line_content": "                   mapOrphanTransactions.count(inv.hash) ||"
        },
        {
          "line": 4408,
          "api": "HaveCoinsInCache",
          "text": "pcoinsTip->HaveCoinsInCache(inv.hash)",
          "line_content": "                   pcoinsTip->HaveCoinsInCache(inv.hash);"
        },
        {
          "line": 4411,
          "api": "count",
          "text": "mapBlockIndex.count(inv.hash)",
          "line_content": "        return mapBlockIndex.count(inv.hash);"
        },
        {
          "line": 323,
          "api": "LOCK",
          "text": "LOCK(cs_main)",
          "line_content": "    LOCK(cs_main);"
        },
        {
          "line": 324,
          "api": "CNodeState",
          "text": "CNodeState()",
          "line_content": "    CNodeState &state = mapNodeState.insert(std::make_pair(nodeid, CNodeState())).first->second;"
        },
        {
          "line": 4419,
          "api": "begin",
          "text": "pfrom->vRecvGetData.begin()",
          "line_content": "    std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();"
        },
        {
          "line": 4423,
          "api": "LOCK",
          "text": "LOCK(cs_main)",
          "line_content": "    LOCK(cs_main);"
        },
        {
          "line": 4425,
          "api": "end",
          "text": "pfrom->vRecvGetData.end()",
          "line_content": "    while (it != pfrom->vRecvGetData.end()) {"
        },
        {
          "line": 330,
          "api": "LOCK",
          "text": "LOCK(cs_main)",
          "line_content": "    LOCK(cs_main);"
        },
        {
          "line": 331,
          "api": "State",
          "text": "State(nodeid)",
          "line_content": "    CNodeState *state = State(nodeid);"
        },
        {
          "line": 4427,
          "api": "SendBufferSize",
          "text": "SendBufferSize()",
          "line_content": "        if (pfrom->nSendSize >= SendBufferSize())"
        },
        {
          "line": 4432,
          "api": "boost::this_thread::interruption_point()",
          "text": "boost::this_thread::interruption_point()",
          "line_content": "            boost::this_thread::interruption_point();"
        },
        {
          "line": 337,
          "api": "AddressCurrentlyConnected",
          "text": "AddressCurrentlyConnected(state->address)",
          "line_content": "        AddressCurrentlyConnected(state->address);"
        },
        {
          "line": 341,
          "api": "erase",
          "text": "mapBlocksInFlight.erase(entry.hash)",
          "line_content": "        mapBlocksInFlight.erase(entry.hash);"
        },
        {
          "line": 4438,
          "api": "find",
          "text": "mapBlockIndex.find(inv.hash)",
          "line_content": "                BlockMap::iterator mi = mapBlockIndex.find(inv.hash);"
        },
        {
          "line": 343,
          "api": "EraseOrphansFor",
          "text": "EraseOrphansFor(nodeid)",
          "line_content": "    EraseOrphansFor(nodeid);"
        },
        {
          "line": 4439,
          "api": "end",
          "text": "mapBlockIndex.end()",
          "line_content": "                if (mi != mapBlockIndex.end())"
        },
        {
          "line": 4441,
          "api": "Contains",
          "text": "chainActive.Contains(mi->second)",
          "line_content": "                    if (chainActive.Contains(mi->second)) {"
        },
        {
          "line": 346,
          "api": "assert",
          "text": "assert(nPeersWithValidatedDownloads >= 0)",
          "line_content": 