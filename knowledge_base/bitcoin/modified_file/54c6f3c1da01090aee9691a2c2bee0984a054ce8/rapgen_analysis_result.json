{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/54c6f3c1da01090aee9691a2c2bee0984a054ce8",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/54c6f3c1da01090aee9691a2c2bee0984a054ce8/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/54c6f3c1da01090aee9691a2c2bee0984a054ce8/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/54c6f3c1da01090aee9691a2c2bee0984a054ce8/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 698,
          "old_api": "const_cast<CCoinsViewCache*>(&active_coins_tip)",
          "new_api": "CoinsTip",
          "old_text": "const_cast<CCoinsViewCache*>(&active_coins_tip)",
          "new_text": "active_chainstate.CoinsTip()",
          "old_line_content": "    CCoinsViewCache mempoolDuplicate(const_cast<CCoinsViewCache*>(&active_coins_tip));",
          "new_line_content": "    CCoinsViewCache& active_coins_tip = active_chainstate.CoinsTip();",
          "content_same": false
        },
        {
          "line": 699,
          "old_api": "Height",
          "new_api": "const_cast<CCoinsViewCache*>(&active_coins_tip)",
          "old_text": "active_chainstate.m_chain.Height()",
          "new_text": "const_cast<CCoinsViewCache*>(&active_coins_tip)",
          "old_line_content": "    const int64_t spendheight = active_chainstate.m_chain.Height() + 1;",
          "new_line_content": "    CCoinsViewCache mempoolDuplicate(const_cast<CCoinsViewCache*>(&active_coins_tip));",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": "GetFee",
          "new_api": "GetTxSize",
          "old_text": "it->GetFee()",
          "new_text": "it->GetTxSize()",
          "old_line_content": "        check_total_fee += it->GetFee();",
          "new_line_content": "        checkTotal += it->GetTxSize();",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": "DynamicMemoryUsage",
          "new_api": "GetFee",
          "old_text": "it->DynamicMemoryUsage()",
          "new_text": "it->GetFee()",
          "old_line_content": "        innerUsage += it->DynamicMemoryUsage();",
          "new_line_content": "        check_total_fee += it->GetFee();",
          "content_same": false
        },
        {
          "line": 707,
          "old_api": "GetTx",
          "new_api": "DynamicMemoryUsage",
          "old_text": "it->GetTx()",
          "new_text": "it->DynamicMemoryUsage()",
          "old_line_content": "        const CTransaction& tx = it->GetTx();",
          "new_line_content": "        innerUsage += it->DynamicMemoryUsage();",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": "GetMemPoolChildrenConst",
          "new_api": "GetTx",
          "old_text": "it->GetMemPoolChildrenConst()",
          "new_text": "it->GetTx()",
          "old_line_content": "        innerUsage += memusage::DynamicUsage(it->GetMemPoolParentsConst()) + memusage::DynamicUsage(it->GetMemPoolChildrenConst());",
          "new_line_content": "        const CTransaction& tx = it->GetTx();",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": "end",
          "new_api": "find",
          "old_text": "mapTx.end()",
          "new_text": "mapTx.find(txin.prevout.hash)",
          "old_line_content": "            if (it2 != mapTx.end()) {",
          "new_line_content": "            indexed_transaction_set::const_iterator it2 = mapTx.find(txin.prevout.hash);",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": "GetTx",
          "new_api": "end",
          "old_text": "it2->GetTx()",
          "new_text": "mapTx.end()",
          "old_line_content": "                const CTransaction& tx2 = it2->GetTx();",
          "new_line_content": "            if (it2 != mapTx.end()) {",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": "IsNull",
          "new_api": "GetTx",
          "old_text": "tx2.vout[txin.prevout.n].IsNull()",
          "new_text": "it2->GetTx()",
          "old_line_content": "                assert(tx2.vout.size() > txin.prevout.n && !tx2.vout[txin.prevout.n].IsNull());",
          "new_line_content": "                const CTransaction& tx2 = it2->GetTx();",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": "insert",
          "new_api": "HaveCoin",
          "old_text": "setParentCheck.insert(*it2)",
          "new_text": "mempoolDuplicate.HaveCoin(txin.prevout)",
          "old_line_content": "                setParentCheck.insert(*it2);",
          "new_line_content": "                if (!mempoolDuplicate.HaveCoin(txin.prevout)) fDependsWait = true;",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "end",
          "new_api": "find",
          "old_text": "mapNextTx.end()",
          "new_text": "mapNextTx.find(txin.prevout)",
          "old_line_content": "            assert(it3 != mapNextTx.end());",
          "new_line_content": "            auto it3 = mapNextTx.find(txin.prevout);",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": "assert",
          "new_api": "end",
          "old_text": "assert(it3->first == &txin.prevout)",
          "new_text": "mapNextTx.end()",
          "old_line_content": "            assert(it3->first == &txin.prevout);",
          "new_line_content": "            assert(it3 != mapNextTx.end());",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": "begin",
          "new_api": "size",
          "old_text": "it->GetMemPoolParentsConst().begin()",
          "new_text": "it->GetMemPoolParentsConst().size()",
          "old_line_content": "        assert(std::equal(setParentCheck.begin(), setParentCheck.end(), it->GetMemPoolParentsConst().begin(), comp));",
          "new_line_content": "        assert(setParentCheck.size() == it->GetMemPoolParentsConst().size());",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": "size",
          "new_api": "CalculateMemPoolAncestors",
          "old_text": "setAncestors.size()",
          "new_text": "CalculateMemPoolAncestors(*it, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy)",
          "old_line_content": "        uint64_t nCountCheck = setAncestors.size() + 1;",
          "new_line_content": "        CalculateMemPoolAncestors(*it, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy);",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": "GetTxSize",
          "new_api": "size",
          "old_text": "it->GetTxSize()",
          "new_text": "setAncestors.size()",
          "old_line_content": "        uint64_t nSizeCheck = it->GetTxSize();",
          "new_line_content": "        uint64_t nCountCheck = setAncestors.size() + 1;",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": "GetModifiedFee",
          "new_api": "GetTxSize",
          "old_text": "it->GetModifiedFee()",
          "new_text": "it->GetTxSize()",
          "old_line_content": "        CAmount nFeesCheck = it->GetModifiedFee();",
          "new_line_content": "        uint64_t nSizeCheck = it->GetTxSize();",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": "GetSigOpCost",
          "new_api": "GetModifiedFee",
          "old_text": "it->GetSigOpCost()",
          "new_text": "it->GetModifiedFee()",
          "old_line_content": "        int64_t nSigOpCheck = it->GetSigOpCost();",
          "new_line_content": "        CAmount nFeesCheck = it->GetModifiedFee();",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": "GetModifiedFee",
          "new_api": "GetTxSize",
          "old_text": "ancestorIt->GetModifiedFee()",
          "new_text": "ancestorIt->GetTxSize()",
          "old_line_content": "            nFeesCheck += ancestorIt->GetModifiedFee();",
          "new_line_content": "            nSizeCheck += ancestorIt->GetTxSize();",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": "GetSigOpCost",
          "new_api": "GetModifiedFee",
          "old_text": "ancestorIt->GetSigOpCost()",
          "new_text": "ancestorIt->GetModifiedFee()",
          "old_line_content": "            nSigOpCheck += ancestorIt->GetSigOpCost();",
          "new_line_content": "            nFeesCheck += ancestorIt->GetModifiedFee();",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": "GetSizeWithAncestors",
          "new_api": "GetCountWithAncestors",
          "old_text": "it->GetSizeWithAncestors()",
          "new_text": "it->GetCountWithAncestors()",
          "old_line_content": "        assert(it->GetSizeWithAncestors() == nSizeCheck);",
          "new_line_content": "        assert(it->GetCountWithAncestors() == nCountCheck);",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": "GetSigOpCostWithAncestors",
          "new_api": "GetSizeWithAncestors",
          "old_text": "it->GetSigOpCostWithAncestors()",
          "new_text": "it->GetSizeWithAncestors()",
          "old_line_content": "        assert(it->GetSigOpCostWithAncestors() == nSigOpCheck);",
          "new_line_content": "        assert(it->GetSizeWithAncestors() == nSizeCheck);",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": "GetModFeesWithAncestors",
          "new_api": "GetSigOpCostWithAncestors",
          "old_text": "it->GetModFeesWithAncestors()",
          "new_text": "it->GetSigOpCostWithAncestors()",
          "old_line_content": "        assert(it->GetModFeesWithAncestors() == nFeesCheck);",
          "new_line_content": "        assert(it->GetSigOpCostWithAncestors() == nSigOpCheck);",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": "GetHash",
          "new_api": "GetCountWithAncestors",
          "old_text": "it->GetTx().GetHash()",
          "new_text": "it->GetCountWithAncestors()",
          "old_line_content": "        auto iter = mapNextTx.lower_bound(COutPoint(it->GetTx().GetHash(), 0));",
          "new_line_content": "        prev_ancestor_count = it->GetCountWithAncestors();",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": "end",
          "new_api": "GetHash",
          "old_text": "mapTx.end()",
          "new_text": "it->GetTx().GetHash()",
          "old_line_content": "            assert(childit != mapTx.end()); // mapNextTx points to in-mempool transactions",
          "new_line_content": "        auto iter = mapNextTx.lower_bound(COutPoint(it->GetTx().GetHash(), 0));",
          "content_same": false
        },
        {
          "line": 763,
          "old_api": "GetTxSize",
          "new_api": "GetHash",
          "old_text": "childit->GetTxSize()",
          "new_text": "it->GetTx().GetHash()",
          "old_line_content": "                child_sizes += childit->GetTxSize();",
          "new_line_content": "        for (; iter != mapNextTx.end() && iter->first->hash == it->GetTx().GetHash(); ++iter) {",
          "content_same": false
        },
        {
          "line": 766,
          "old_api": "size",
          "new_api": "insert",
          "old_text": "it->GetMemPoolChildrenConst().size()",
          "new_text": "setChildrenCheck.insert(*childit)",
          "old_line_content": "        assert(setChildrenCheck.size() == it->GetMemPoolChildrenConst().size());",
          "new_line_content": "            if (setChildrenCheck.insert(*childit).second) {",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": "begin",
          "new_api": "GetTxSize",
          "old_text": "it->GetMemPoolChildrenConst().begin()",
          "new_text": "childit->GetTxSize()",
          "old_line_content": "        assert(std::equal(setChildrenCheck.begin(), setChildrenCheck.end(), it->GetMemPoolChildrenConst().begin(), comp));",
          "new_line_content": "                child_sizes += childit->GetTxSize();",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": "GetTxSize",
          "new_api": "size",
          "old_text": "it->GetTxSize()",
          "new_text": "it->GetMemPoolChildrenConst().size()",
          "old_line_content": "        assert(it->GetSizeWithDescendants() >= child_sizes + it->GetTxSize());",
          "new_line_content": "        assert(setChildrenCheck.size() == it->GetMemPoolChildrenConst().size());",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": "empty",
          "new_api": "CheckInputsAndUpdateCoins",
          "old_text": "waitingOnDependants.empty()",
          "new_text": "CheckInputsAndUpdateCoins(tx, mempoolDuplicate, spendheight)",
          "old_line_content": "    while (!waitingOnDependants.empty()) {",
          "new_line_content": "            CheckInputsAndUpdateCoins(tx, mempoolDuplicate, spendheight);",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": "push_back",
          "new_api": "empty",
          "old_text": "waitingOnDependants.push_back(entry)",
          "new_text": "waitingOnDependants.empty()",
          "old_line_content": "            waitingOnDependants.push_back(entry);",
          "new_line_content": "    while (!waitingOnDependants.empty()) {",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": "size",
          "new_api": "pop_front",
          "old_text": "waitingOnDependants.size()",
          "new_text": "waitingOnDependants.pop_front()",
          "old_line_content": "            assert(stepsSinceLastRemove < waitingOnDependants.size());",
          "new_line_content": "        waitingOnDependants.pop_front();",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": "GetTx",
          "new_api": "push_back",
          "old_text": "entry->GetTx()",
          "new_text": "waitingOnDependants.push_back(entry)",
          "old_line_content": "            CheckInputsAndUpdateCoins(entry->GetTx(), mempoolDuplicate, spendheight);",
          "new_line_content": "            waitingOnDependants.push_back(entry);",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": "cend",
          "new_api": "GetTx",
          "old_text": "mapNextTx.cend()",
          "new_text": "entry->GetTx()",
          "old_line_content": "    for (auto it = mapNextTx.cbegin(); it != mapNextTx.cend(); it++) {",
          "new_line_content": "            CheckInputsAndUpdateCoins(entry->GetTx(), mempoolDuplicate, spendheight);",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": "end",
          "new_api": "cend",
          "old_text": "mapTx.end()",
          "new_text": "mapNextTx.cend()",
          "old_line_content": "        assert(it2 != mapTx.end());",
          "new_line_content": "    for (auto it = mapNextTx.cbegin(); it != mapNextTx.cend(); it++) {",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": "assert",
          "new_api": "GetHash",
          "old_text": "assert(&tx == it->second)",
          "new_text": "it->second->GetHash()",
          "old_line_content": "        assert(&tx == it->second);",
          "new_line_content": "        uint256 hash = it->second->GetHash();",
          "content_same": false
        },
        {
          "line": 799,
          "old_api": "assert",
          "new_api": "end",
          "old_text": "assert(totalTxSize == checkTotal)",
          "new_text": "mapTx.end()",
          "old_line_content": "    assert(totalTxSize == checkTotal);",
          "new_line_content": "        assert(it2 != mapTx.end());",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": "end",
          "new_api": "LOCK",
          "old_text": "mapTx.end()",
          "new_text": "LOCK(cs)",
          "old_line_content": "    if (j == mapTx.end()) return true;",
          "new_line_content": "    LOCK(cs);",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": "GetCountWithAncestors",
          "new_api": "find",
          "old_text": "i->GetCountWithAncestors()",
          "new_text": "mapTx.find(hasha)",
          "old_line_content": "    uint64_t counta = i->GetCountWithAncestors();",
          "new_line_content": "    indexed_transaction_set::const_iterator i = wtxid ? get_iter_from_wtxid(hasha) : mapTx.find(hasha);",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": "GetCountWithAncestors",
          "new_api": "end",
          "old_text": "j->GetCountWithAncestors()",
          "new_text": "mapTx.end()",
          "old_line_content": "    uint64_t countb = j->GetCountWithAncestors();",
          "new_line_content": "    if (i == mapTx.end()) return false;",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": "CompareTxMemPoolEntryByScore",
          "new_api": "end",
          "old_text": "CompareTxMemPoolEntryByScore()(*i, *j)",
          "new_text": "mapTx.end()",
          "old_line_content": "        return CompareTxMemPoolEntryByScore()(*i, *j);",
          "new_line_content": "    if (j == mapTx.end()) return true;",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": "end",
          "new_api": "AssertLockHeld",
          "old_text": "mapTx.end()",
          "new_text": "AssertLockHeld(cs)",
          "old_line_content": "    for (indexed_transaction_set::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi) {",
          "new_line_content": "    AssertLockHeld(cs);",
          "content_same": false
        },
        {
          "line": 855,
          "old_api": "size",
          "new_api": "LOCK",
          "old_text": "mapTx.size()",
          "new_text": "LOCK(cs)",
          "old_line_content": "    vtxid.reserve(mapTx.size());",
          "new_line_content": "    LOCK(cs);",
          "content_same": false
        },
        {
          "line": 858,
          "old_api": "GetHash",
          "new_api": "clear",
          "old_text": "it->GetTx().GetHash()",
          "new_text": "vtxid.clear()",
          "old_line_content": "        vtxid.push_back(it->GetTx().GetHash());",
          "new_line_content": "    vtxid.clear();",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": "size",
          "new_api": "LOCK",
          "old_text": "mapTx.size()",
          "new_text": "LOCK(cs)",
          "old_line_content": "    ret.reserve(mapTx.size());",
          "new_line_content": "    LOCK(cs);",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": "GetSharedTx",
          "new_api": "LOCK",
          "old_text": "i->GetSharedTx()",
          "new_text": "LOCK(cs)",
          "old_line_content": "    return i->GetSharedTx();",
          "new_line_content": "    LOCK(cs);",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": "GetInfo",
          "new_api": "LOCK",
          "old_text": "GetInfo(i)",
          "new_text": "LOCK(cs)",
          "old_line_content": "    return GetInfo(i);",
          "new_line_content": "    LOCK(cs);",
          "content_same": false
        },
        {
          "line": 898,
          "old_api": "info",
          "new_api": "TxMempoolInfo",
          "old_text": "info(GenTxid{false, txid})",
          "new_text": "TxMempoolInfo()",
          "old_line_content": "TxMempoolInfo CTxMemPool::info(const uint256& txid) const { return info(GenTxid{false, txid}); }",
          "new_line_content": "        return TxMempoolInfo();",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": "end",
          "new_api": "LOCK",
          "old_text": "mapTx.end()",
          "new_text": "LOCK(cs)",
          "old_line_content": "        if (it != mapTx.end()) {",
          "new_line_content": "        LOCK(cs);",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": "std::numeric_limits<uint64_t>::max()",
          "new_api": "end",
          "old_text": "std::numeric_limits<uint64_t>::max()",
          "new_text": "mapTx.end()",
          "old_line_content": "            uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();",
          "new_line_content": "        if (it != mapTx.end()) {",
          "content_same": false
        },
        {
          "line": 915,
          "old_api": "update_descendant_state",
          "new_api": "std::numeric_limits<uint64_t>::max()",
          "old_text": "update_descendant_state(0, nFeeDelta, 0)",
          "new_text": "std::numeric_limits<uint64_t>::max()",
          "old_line_content": "                mapTx.modify(ancestorIt, update_descendant_state(0, nFeeDelta, 0));",
          "new_line_content": "            uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();",
          "content_same": false
        },
        {
          "line": 919,
          "old_api": "CalculateDescendants",
          "new_api": "update_descendant_state",
          "old_text": "CalculateDescendants(it, setDescendants)",
          "new_text": "update_descendant_state(0, nFeeDelta, 0)",
          "old_line_content": "            CalculateDescendants(it, setDescendants);",
          "new_line_content": "                mapTx.modify(ancestorIt, update_descendant_state(0, nFeeDelta, 0));",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": "LOCK",
          "new_api": "memusage::DynamicUsage(vTxHashes)",
          "old_text": "LOCK(cs)",
          "new_text": "memusage::DynamicUsage(vTxHashes)",
          "old_line_content": "    LOCK(cs);",
          "new_line_content": "    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 15 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + memusage::DynamicUsage(vTxHashes) + cachedInnerUsage;",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": "GetHex",
          "new_api": "LOCK",
          "old_text": "txid.GetHex()",
          "new_text": "LOCK(cs)",
          "old_line_content": "        LogPrint(BCLog::MEMPOOL, \"Removed %i from set of unbroadcast txns%s\\n\", txid.GetHex(), (unchecked ? \" before confirmation that txn was sent out\" : \"\"));",
          "new_line_content": "    LOCK(cs);",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": "mapTx.project<0>(it)",
          "new_api": "AssertLockHeld",
          "old_text": "mapTx.project<0>(it)",
          "new_text": "AssertLockHeld(cs)",
          "old_line_content": "        toremove.insert(mapTx.project<0>(it));",
          "new_line_content": "    AssertLockHeld(cs);",
          "content_same": false
        },
        {
          "line": 1064,
          "old_api": "erase",
          "new_api": "AssertLockHeld",
          "old_text": "entry->GetMemPoolChildren().erase(*child)",
          "new_text": "AssertLockHeld(cs)",
          "old_line_content": "    } else if (!add && entry->GetMemPoolChildren().erase(*child)) {",
          "new_line_content": "    AssertLockHeld(cs);",
          "content_same": false
        },
        {
          "line": 1075,
          "old_api": "erase",
          "new_api": "AssertLockHeld",
          "old_text": "entry->GetMemPoolParents().erase(*parent)",
          "new_text": "AssertLockHeld(cs)",
          "old_line_content": "    } else if (!add && entry->GetMemPoolParents().erase(*parent)) {",
          "new_line_content": "    AssertLockHeld(cs);",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": "GetTime",
          "new_api": "LOCK",
          "old_text": "GetTime()",
          "new_text": "LOCK(cs)",
          "old_line_content": "    int64_t time = GetTime();",
          "new_line_content": "    LOCK(cs);",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": "AssertLockHeld",
          "new_api": "llround",
          "old_text": "AssertLockHeld(cs)",
          "new_text": "llround(rollingMinimumFeeRate)",
          "old_line_content": "    AssertLockHeld(cs);",
          "new_line_content": "    return std::max(CFeeRate(llround(rollingMinimumFeeRate)), incrementalRelayFee);",
          "content_same": false
        },
        {
          "line": 1117,
          "old_api": "DynamicMemoryUsage",
          "new_api": "AssertLockHeld",
          "old_text": "DynamicMemoryUsage()",
          "new_text": "AssertLockHeld(cs)",
          "old_line_content": "    while (!mapTx.empty() && DynamicMemoryUsage() > sizelimit) {",
          "new_line_content": "    AssertLockHeld(cs);",
          "content_same": false
        },
        {
          "line": 1130,
          "old_api": "mapTx.project<0>(it)",
          "new_api": "trackPackageRemoved",
          "old_text": "mapTx.project<0>(it)",
          "new_text": "trackPackageRemoved(removed)",
          "old_line_content": "        CalculateDescendants(mapTx.project<0>(it), stage);",
          "new_line_content": "        trackPackageRemoved(removed);",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": "size",
          "new_api": "std::max(maxFeeRateRemoved, removed)",
          "old_text": "stage.size()",
          "new_text": "std::max(maxFeeRateRemoved, removed)",
          "old_line_content": "        nTxnRemoved += stage.size();",
          "new_line_content": "        maxFeeRateRemoved = std::max(maxFeeRateRemoved, removed);",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": "RemoveStaged",
          "new_api": "size",
          "old_text": "RemoveStaged(stage, false, MemPoolRemovalReason::SIZELIMIT)",
          "new_text": "stage.size()",
          "old_line_content": "        RemoveStaged(stage, false, MemPoolRemovalReason::SIZELIMIT);",
          "new_line_content": "            txn.reserve(stage.size());",
          "content_same": false
        },
        {
          "line": 1143,
          "old_api": "exists",
          "new_api": "RemoveStaged",
          "old_text": "exists(txin.prevout.hash)",
          "new_text": "RemoveStaged(stage, false, MemPoolRemovalReason::SIZELIMIT)",
          "old_line_content": "                    if (exists(txin.prevout.hash)) continue;",
          "new_line_content": "        RemoveStaged(stage, false, MemPoolRemovalReason::SIZELIMIT);",
          "content_same": false
        },
        {
          "line": 1163,
          "old_api": "pop_back",
          "new_api": "push_back",
          "old_text": "candidates.pop_back()",
          "new_text": "candidates.push_back(entry)",
          "old_line_content": "        candidates.pop_back();",
          "new_line_content": "    candidates.push_back(entry);",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": "GetMemPoolParentsConst",
          "new_api": "size",
          "old_text": "candidate->GetMemPoolParentsConst()",
          "new_text": "candidates.size()",
          "old_line_content": "        const CTxMemPoolEntry::Parents& parents = candidate->GetMemPoolParentsConst();",
          "new_line_content": "    while (candidates.size()) {",
          "content_same": false
        },
        {
          "line": 1166,
          "old_api": "size",
          "new_api": "back",
          "old_text": "parents.size()",
          "new_text": "candidates.back()",
          "old_line_content": "        if (parents.size() == 0) {",
          "new_line_content": "        txiter candidate = candidates.back();",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": "GetCountWithDescendants",
          "new_api": "pop_back",
          "old_text": "candidate->GetCountWithDescendants()",
          "new_text": "candidates.pop_back()",
          "old_line_content": "            maximum = std::max(maximum, candidate->GetCountWithDescendants());",
          "new_line_content": "        candidates.pop_back();",
          "content_same": false
        },
        {
          "line": 1170,
          "old_api": "iterator_to",
          "new_api": "size",
          "old_text": "mapTx.iterator_to(i)",
          "new_text": "parents.size()",
          "old_line_content": "                candidates.push_back(mapTx.iterator_to(i));",
          "new_line_content": "        if (parents.size() == 0) {",
          "content_same": false
        },
        {
          "line": 1182,
          "old_api": "GetCountWithAncestors",
          "new_api": "LOCK",
          "old_text": "it->GetCountWithAncestors()",
          "new_text": "LOCK(cs)",
          "old_line_content": "        ancestors = it->GetCountWithAncestors();",
          "new_line_content": "    LOCK(cs);",
          "content_same": false
        },
        {
          "line": 1183,
          "old_api": "GetSizeWithAncestors",
          "new_api": "find",
          "old_text": "it->GetSizeWithAncestors()",
          "new_text": "mapTx.find(txid)",
          "old_line_content": "        if (ancestorsize) *ancestorsize = it->GetSizeWithAncestors();",
          "new_line_content": "    auto it = mapTx.find(txid);",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": "CalculateDescendantMaximum",
          "new_api": "end",
          "old_text": "CalculateDescendantMaximum(it)",
          "new_text": "mapTx.end()",
          "old_line_content": "        descendants = CalculateDescendantMaximum(it);",
          "new_line_content": "    if (it != mapTx.end()) {",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1024,
          "old_api": null,
          "new_api": "GetHex",
          "old_text": null,
          "new_text": "txid.GetHex()",
          "old_line_content": "void CTxMemPool::RemoveStaged(setEntries &stage, bool updateDescendants, MemPoolRemovalReason reason) {",
          "new_line_content": "        LogPrint(BCLog::MEMPOOL, \"Removed %i from set of unbroadcast txns%s\\n\", txid.GetHex(), (unchecked ? \" before confirmation that txn was sent out\" : \"\"));",
          "content_same": false
        },
        {
          "line": 1029,
          "old_api": null,
          "new_api": "AssertLockHeld",
          "old_text": null,
          "new_text": "AssertLockHeld(cs)",
          "old_line_content": "    }",
          "new_line_content": "    AssertLockHeld(cs);",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": null,
          "new_api": "UpdateForRemoveFromMempool",
          "old_text": null,
          "new_text": "UpdateForRemoveFromMempool(stage, updateDescendants)",
          "old_line_content": "}",
          "new_line_content": "    UpdateForRemoveFromMempool(stage, updateDescendants);",
          "content_same": false
        },
        {
          "line": 1032,
          "old_api": null,
          "new_api": "removeUnchecked",
          "old_text": null,
          "new_text": "removeUnchecked(it, reason)",
          "old_line_content": "int CTxMemPool::Expire(std::chrono::seconds time)",
          "new_line_content": "        removeUnchecked(it, reason);",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "mapTx.get<entry_time>().begin()",
          "old_line_content": "        it++;",
          "new_line_content": "    indexed_transaction_set::index<entry_time>::type::iterator it = mapTx.get<entry_time>().begin();",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": null,
          "new_api": "GetTime",
          "old_text": null,
          "new_text": "it->GetTime()",
          "old_line_content": "    setEntries stage;",
          "new_line_content": "    while (it != mapTx.get<entry_time>().end() && it->GetTime() < time) {",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": null,
          "new_api": "mapTx.project<0>(it)",
          "old_text": null,
          "new_text": "mapTx.project<0>(it)",
          "old_line_content": "    for (txiter removeit : toremove) {",
          "new_line_content": "        toremove.insert(mapTx.project<0>(it));",
          "content_same": false
        },
        {
          "line": 1047,
          "old_api": null,
          "new_api": "CalculateDescendants",
          "old_text": null,
          "new_text": "CalculateDescendants(removeit, stage)",
          "old_line_content": "}",
          "new_line_content": "        CalculateDescendants(removeit, stage);",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": null,
          "new_api": "RemoveStaged",
          "old_text": null,
          "new_text": "RemoveStaged(stage, false, MemPoolRemovalReason::EXPIRY)",
          "old_line_content": "void CTxMemPool::addUnchecked(const CTxMemPoolEntry &entry, bool validFeeEstimate)",
          "new_line_content": "    RemoveStaged(stage, false, MemPoolRemovalReason::EXPIRY);",
          "content_same": false
        },
        {
          "line": 1050,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "stage.size()",
          "old_line_content": "{",
          "new_line_content": "    return stage.size();",
          "content_same": false
        },
        {
          "line": 1056,
          "old_api": null,
          "new_api": "std::numeric_limits<uint64_t>::max()",
          "old_text": null,
          "new_text": "std::numeric_limits<uint64_t>::max()",
          "old_line_content": "}",
          "new_line_content": "    uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": null,
          "new_api": "CalculateMemPoolAncestors",
          "old_text": null,
          "new_text": "CalculateMemPoolAncestors(entry, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy)",
          "old_line_content": "void CTxMemPool::UpdateChild(txiter entry, txiter child, bool add)",
          "new_line_content": "    CalculateMemPoolAncestors(entry, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy);",
          "content_same": false
        },
        {
          "line": 1059,
          "old_api": null,
          "new_api": "addUnchecked",
          "old_text": null,
          "new_text": "addUnchecked(entry, setAncestors, validFeeEstimate)",
          "old_line_content": "{",
          "new_line_content": "    return addUnchecked(entry, setAncestors, validFeeEstimate);",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "entry->GetMemPoolChildren().insert(*child)",
          "old_line_content": "    }",
          "new_line_content": "    if (add && entry->GetMemPoolChildren().insert(*child).second) {",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": null,
          "new_api": "memusage::IncrementalDynamicUsage(s)",
          "old_text": null,
          "new_text": "memusage::IncrementalDynamicUsage(s)",
          "old_line_content": "}",
          "new_line_content": "        cachedInnerUsage += memusage::IncrementalDynamicUsage(s);",
          "content_same": false
        },
        {
          "line": 1068,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "entry->GetMemPoolChildren().erase(*child)",
          "old_line_content": "",
          "new_line_content": "    } else if (!add && entry->GetMemPoolChildren().erase(*child)) {",
          "content_same": false
        },
        {
          "line": 1069,
          "old_api": null,
          "new_api": "memusage::IncrementalDynamicUsage(s)",
          "old_text": null,
          "new_text": "memusage::IncrementalDynamicUsage(s)",
          "old_line_content": "void CTxMemPool::UpdateParent(txiter entry, txiter parent, bool add)",
          "new_line_content": "        cachedInnerUsage -= memusage::IncrementalDynamicUsage(s);",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "entry->GetMemPoolParents().insert(*parent)",
          "old_line_content": "    }",
          "new_line_content": "    if (add && entry->GetMemPoolParents().insert(*parent).second) {",
          "content_same": false
        },
        {
          "line": 1078,
          "old_api": null,
          "new_api": "memusage::IncrementalDynamicUsage(s)",
          "old_text": null,
          "new_text": "memusage::IncrementalDynamicUsage(s)",
          "old_line_content": "}",
          "new_line_content": "        cachedInnerUsage += memusage::IncrementalDynamicUsage(s);",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "entry->GetMemPoolParents().erase(*parent)",
          "old_line_content": "",
          "new_line_content": "    } else if (!add && entry->GetMemPoolParents().erase(*parent)) {",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": null,
          "new_api": "memusage::IncrementalDynamicUsage(s)",
          "old_text": null,
          "new_text": "memusage::IncrementalDynamicUsage(s)",
          "old_line_content": "CFeeRate CTxMemPool::GetMinFee(size_t sizelimit) const {",
          "new_line_content": "        cachedInnerUsage -= memusage::IncrementalDynamicUsage(s);",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": null,
          "new_api": "llround",
          "old_text": null,
          "new_text": "llround(rollingMinimumFeeRate)",
          "old_line_content": "        double halflife = ROLLING_FEE_HALFLIFE;",
          "new_line_content": "        return CFeeRate(llround(rollingMinimumFeeRate));",
          "content_same": false
        },
        {
          "line": 1089,
          "old_api": null,
          "new_api": "GetTime",
          "old_text": null,
          "new_text": "GetTime()",
          "old_line_content": "            halflife /= 4;",
          "new_line_content": "    int64_t time = GetTime();",
          "content_same": false
        },
        {
          "line": 1092,
          "old_api": null,
          "new_api": "DynamicMemoryUsage",
          "old_text": null,
          "new_text": "DynamicMemoryUsage()",
          "old_line_content": "",
          "new_line_content": "        if (DynamicMemoryUsage() < sizelimit / 4)",
          "content_same": false
        },
        {
          "line": 1094,
          "old_api": null,
          "new_api": "DynamicMemoryUsage",
          "old_text": null,
          "new_text": "DynamicMemoryUsage()",
          "old_line_content": "        lastRollingFeeUpdate = time;",
          "new_line_content": "        else if (DynamicMemoryUsage() < sizelimit / 2)",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": null,
          "new_api": "pow",
          "old_text": null,
          "new_text": "pow(2.0, (time - lastRollingFeeUpdate) / halflife)",
          "old_line_content": "            rollingMinimumFeeRate = 0;",
          "new_line_content": "        rollingMinimumFeeRate = rollingMinimumFeeRate / pow(2.0, (time - lastRollingFeeUpdate) / halflife);",
          "content_same": false
        },
        {
          "line": 1100,
          "old_api": null,
          "new_api": "GetFeePerK",
          "old_text": null,
          "new_text": "incrementalRelayFee.GetFeePerK()",
          "old_line_content": "    }",
          "new_line_content": "        if (rollingMinimumFeeRate < (double)incrementalRelayFee.GetFeePerK() / 2) {",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": null,
          "new_api": "CFeeRate",
          "old_text": null,
          "new_text": "CFeeRate(0)",
          "old_line_content": "}",
          "new_line_content": "            return CFeeRate(0);",
          "content_same": false
        },
        {
          "line": 1109,
          "old_api": null,
          "new_api": "AssertLockHeld",
          "old_text": null,
          "new_text": "AssertLockHeld(cs)",
          "old_line_content": "    }",
          "new_line_content": "    AssertLockHeld(cs);",
          "content_same": false
        },
        {
          "line": 1110,
          "old_api": null,
          "new_api": "GetFeePerK",
          "old_text": null,
          "new_text": "rate.GetFeePerK()",
          "old_line_content": "}",
          "new_line_content": "    if (rate.GetFeePerK() > rollingMinimumFeeRate) {",
          "content_same": false
        },
        {
          "line": 1111,
          "old_api": null,
          "new_api": "GetFeePerK",
          "old_text": null,
          "new_text": "rate.GetFeePerK()",
          "old_line_content": "",
          "new_line_content": "        rollingMinimumFeeRate = rate.GetFeePerK();",
          "content_same": false
        },
        {
          "line": 1121,
          "old_api": null,
          "new_api": "DynamicMemoryUsage",
          "old_text": null,
          "new_text": "DynamicMemoryUsage()",
          "old_line_content": "        // \"minimum reasonable fee rate\" (ie some value under which we consider txn",
          "new_line_content": "    while (!mapTx.empty() && DynamicMemoryUsage() > sizelimit) {",
          "content_same": false
        },
        {
          "line": 1122,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "mapTx.get<descendant_score>().begin()",
          "old_line_content": "        // to have 0 fee). This way, we don't allow txn to enter mempool with feerate",
          "new_line_content": "        indexed_transaction_set::index<descendant_score>::type::iterator it = mapTx.get<descendant_score>().begin();",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": null,
          "new_api": "GetSizeWithDescendants",
          "old_text": null,
          "new_text": "it->GetSizeWithDescendants()",
          "old_line_content": "",
          "new_line_content": "        CFeeRate removed(it->GetModFeesWithDescendants(), it->GetSizeWithDescendants());",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": null,
          "new_api": "mapTx.project<0>(it)",
          "old_text": null,
          "new_text": "mapTx.project<0>(it)",
          "old_line_content": "        if (pvNoSpendsRemaining) {",
          "new_line_content": "        CalculateDescendants(mapTx.project<0>(it), stage);",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": null,
          "new_api": "GetTx",
          "old_text": null,
          "new_text": "iter->GetTx()",
          "old_line_content": "            for (const CTransaction& tx : txn) {",
          "new_line_content": "                txn.push_back(iter->GetTx());",
          "content_same": false
        },
        {
          "line": 1147,
          "old_api": null,
          "new_api": "exists",
          "old_text": null,
          "new_text": "exists(txin.prevout.hash)",
          "old_line_content": "        }",
          "new_line_content": "                    if (exists(txin.prevout.hash)) continue;",
          "content_same": false
        },
        {
          "line": 1148,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "pvNoSpendsRemaining->push_back(txin.prevout)",
          "old_line_content": "    }",
          "new_line_content": "                    pvNoSpendsRemaining->push_back(txin.prevout);",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": null,
          "new_api": "CFeeRate",
          "old_text": null,
          "new_text": "CFeeRate(0)",
          "old_line_content": "",
          "new_line_content": "    if (maxFeeRateRemoved > CFeeRate(0)) {",
          "content_same": false
        },
        {
          "line": 1155,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "maxFeeRateRemoved.ToString()",
          "old_line_content": "uint64_t CTxMemPool::CalculateDescendantMaximum(txiter entry) const {",
          "new_line_content": "        LogPrint(BCLog::MEMPOOL, \"Removed %u txn, rolling minimum fee bumped to %s\\n\", nTxnRemoved, maxFeeRateRemoved.ToString());",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "counted.insert(candidate)",
          "old_line_content": "        } else {",
          "new_line_content": "        if (!counted.insert(candidate).second) continue;",
          "content_same": false
        },
        {
          "line": 1169,
          "old_api": null,
          "new_api": "GetMemPoolParentsConst",
          "old_text": null,
          "new_text": "candidate->GetMemPoolParentsConst()",
          "old_line_content": "            for (const CTxMemPoolEntry& i : parents) {",
          "new_line_content": "        const CTxMemPoolEntry::Parents& parents = candidate->GetMemPoolParentsConst();",
          "content_same": false
        },
        {
          "line": 1171,
          "old_api": null,
          "new_api": "GetCountWithDescendants",
          "old_text": null,
          "new_text": "candidate->GetCountWithDescendants()",
          "old_line_content": "            }",
          "new_line_content": "            maximum = std::max(maximum, candidate->GetCountWithDescendants());",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": null,
          "new_api": "iterator_to",
          "old_text": null,
          "new_text": "mapTx.iterator_to(i)",
          "old_line_content": "    return maximum;",
          "new_line_content": "                candidates.push_back(mapTx.iterator_to(i));",
          "content_same": false
        },
        {
          "line": 1186,
          "old_api": null,
          "new_api": "GetCountWithAncestors",
          "old_text": null,
          "new_text": "it->GetCountWithAncestors()",
          "old_line_content": "    }",
          "new_line_content": "        ancestors = it->GetCountWithAncestors();",
          "content_same": false
        },
        {
          "line": 1187,
          "old_api": null,
          "new_api": "GetSizeWithAncestors",
          "old_text": null,
          "new_text": "it->GetSizeWithAncestors()",
          "old_line_content": "}",
          "new_line_content": "        if (ancestorsize) *ancestorsize = it->GetSizeWithAncestors();",
          "content_same": false
        },
        {
          "line": 1188,
          "old_api": null,
          "new_api": "GetModFeesWithAncestors",
          "old_text": null,
          "new_text": "it->GetModFeesWithAncestors()",
          "old_line_content": "",
          "new_line_content": "        if (ancestorfees) *ancestorfees = it->GetModFeesWithAncestors();",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": null,
          "new_api": "CalculateDescendantMaximum",
          "old_text": null,
          "new_text": "CalculateDescendantMaximum(it)",
          "old_line_content": "bool CTxMemPool::IsLoaded() const",
          "new_line_content": "        descendants = CalculateDescendantMaximum(it);",
          "content_same": false
        },
        {
          "line": 1195,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs)",
          "old_line_content": "void CTxMemPool::SetIsLoaded(bool loaded)",
          "new_line_content": "    LOCK(cs);",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs)",
          "old_line_content": "",
          "new_line_content": "    LOCK(cs);",
          "content_same": false
        },
        {
          "line": 700,
          "old_api": null,
          "new_api": "Height",
          "old_text": null,
          "new_text": "active_chainstate.m_chain.Height()",
          "old_line_content": "",
          "new_line_content": "    const int64_t spendheight = active_chainstate.m_chain.Height() + 1;",
          "content_same": false
        },
        {
          "line": 703,
          "old_api": null,
          "new_api": "GetSortedDepthAndScore",
          "old_text": null,
          "new_text": "GetSortedDepthAndScore()",
          "old_line_content": "        unsigned int i = 0;",
          "new_line_content": "    for (const auto& it : GetSortedDepthAndScore()) {",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": null,
          "new_api": "GetMemPoolChildrenConst",
          "old_text": null,
          "new_text": "it->GetMemPoolChildrenConst()",
          "old_line_content": "        bool fDependsWait = false;",
          "new_line_content": "        innerUsage += memusage::DynamicUsage(it->GetMemPoolParentsConst()) + memusage::DynamicUsage(it->GetMemPoolChildrenConst());",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": null,
          "new_api": "IsNull",
          "old_text": null,
          "new_text": "tx2.vout[txin.prevout.n].IsNull()",
          "old_line_content": "                fDependsWait = true;",
          "new_line_content": "                assert(tx2.vout.size() > txin.prevout.n && !tx2.vout[txin.prevout.n].IsNull());",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "setParentCheck.insert(*it2)",
          "old_line_content": "            } else {",
          "new_line_content": "                setParentCheck.insert(*it2);",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": null,
          "new_api": "HaveCoin",
          "old_text": null,
          "new_text": "active_coins_tip.HaveCoin(txin.prevout)",
          "old_line_content": "            }",
          "new_line_content": "                assert(active_coins_tip.HaveCoin(txin.prevout));",
          "content_same": false
        },
        {
          "line": 727,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(it3->second == &tx)",
          "old_line_content": "            i++;",
          "new_line_content": "            assert(it3->second == &tx);",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": null,
          "new_api": "GetTx",
          "old_text": null,
          "new_text": "b.GetTx().GetHash()",
          "old_line_content": "        };",
          "new_line_content": "            return a.GetTx().GetHash() == b.GetTx().GetHash();",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "it->GetMemPoolParentsConst().begin()",
          "old_line_content": "        // Verify ancestor state is correct.",
          "new_line_content": "        assert(std::equal(setParentCheck.begin(), setParentCheck.end(), it->GetMemPoolParentsConst().begin(), comp));",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": null,
          "new_api": "std::numeric_limits<uint64_t>::max()",
          "old_text": null,
          "new_text": "std::numeric_limits<uint64_t>::max()",
          "old_line_content": "        std::string dummy;",
          "new_line_content": "        uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": null,
          "new_api": "GetSigOpCost",
          "old_text": null,
          "new_text": "it->GetSigOpCost()",
          "old_line_content": "",
          "new_line_content": "        int64_t nSigOpCheck = it->GetSigOpCost();",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": null,
          "new_api": "GetSigOpCost",
          "old_text": null,
          "new_text": "ancestorIt->GetSigOpCost()",
          "old_line_content": "        }",
          "new_line_content": "            nSigOpCheck += ancestorIt->GetSigOpCost();",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": null,
          "new_api": "GetModFeesWithAncestors",
          "old_text": null,
          "new_text": "it->GetModFeesWithAncestors()",
          "old_line_content": "",
          "new_line_content": "        assert(it->GetModFeesWithAncestors() == nFeesCheck);",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": null,
          "new_api": "GetCountWithAncestors",
          "old_text": null,
          "new_text": "it->GetCountWithAncestors()",
          "old_line_content": "        CTxMemPoolEntry::Children setChildrenCheck;",
          "new_line_content": "        assert(prev_ancestor_count <= it->GetCountWithAncestors());",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "iter->second->GetHash()",
          "old_line_content": "            }",
          "new_line_content": "            txiter childit = mapTx.find(iter->second->GetHash());",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapTx.end()",
          "old_line_content": "        }",
          "new_line_content": "            assert(childit != mapTx.end()); // mapNextTx points to in-mempool transactions",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "it->GetMemPoolChildrenConst().begin()",
          "old_line_content": "",
          "new_line_content": "        assert(std::equal(setChildrenCheck.begin(), setChildrenCheck.end(), it->GetMemPoolChildrenConst().begin(), comp));",
          "content_same": false
        },
        {
          "line": 774,
          "old_api": null,
          "new_api": "GetTxSize",
          "old_text": null,
          "new_text": "it->GetTxSize()",
          "old_line_content": "        else {",
          "new_line_content": "        assert(it->GetSizeWithDescendants() >= child_sizes + it->GetTxSize());",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "waitingOnDependants.push_back(&(*it))",
          "old_line_content": "    }",
          "new_line_content": "            waitingOnDependants.push_back(&(*it));",
          "content_same": false
        },
        {
          "line": 784,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "waitingOnDependants.front()",
          "old_line_content": "            stepsSinceLastRemove++;",
          "new_line_content": "        const CTxMemPoolEntry* entry = waitingOnDependants.front();",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": null,
          "new_api": "GetTx",
          "old_text": null,
          "new_text": "entry->GetTx()",
          "old_line_content": "        } else {",
          "new_line_content": "        if (!mempoolDuplicate.HaveInputs(entry->GetTx())) {",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "waitingOnDependants.size()",
          "old_line_content": "        }",
          "new_line_content": "            assert(stepsSinceLastRemove < waitingOnDependants.size());",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "mapTx.find(hash)",
          "old_line_content": "    }",
          "new_line_content": "        indexed_transaction_set::const_iterator it2 = mapTx.find(hash);",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": null,
          "new_api": "GetTx",
          "old_text": null,
          "new_text": "it2->GetTx()",
          "old_line_content": "",
          "new_line_content": "        const CTransaction& tx = it2->GetTx();",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(totalTxSize == checkTotal)",
          "old_line_content": "",
          "new_line_content": "    assert(totalTxSize == checkTotal);",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(m_total_fee == check_total_fee)",
          "old_line_content": "bool CTxMemPool::CompareDepthAndScore(const uint256& hasha, const uint256& hashb, bool wtxid)",
          "new_line_content": "    assert(m_total_fee == check_total_fee);",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(innerUsage == cachedInnerUsage)",
          "old_line_content": "{",
          "new_line_content": "    assert(innerUsage == cachedInnerUsage);",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "mapTx.find(hashb)",
          "old_line_content": "    if (counta == countb) {",
          "new_line_content": "    indexed_transaction_set::const_iterator j = wtxid ? get_iter_from_wtxid(hashb) : mapTx.find(hashb);",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": null,
          "new_api": "GetCountWithAncestors",
          "old_text": null,
          "new_text": "i->GetCountWithAncestors()",
          "old_line_content": "    }",
          "new_line_content": "    uint64_t counta = i->GetCountWithAncestors();",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": null,
          "new_api": "GetCountWithAncestors",
          "old_text": null,
          "new_text": "j->GetCountWithAncestors()",
          "old_line_content": "    return counta < countb;",
          "new_line_content": "    uint64_t countb = j->GetCountWithAncestors();",
          "content_same": false
        },
        {
          "line": 818,
          "old_api": null,
          "new_api": "CompareTxMemPoolEntryByScore",
          "old_text": null,
          "new_text": "CompareTxMemPoolEntryByScore()(*i, *j)",
          "old_line_content": "",
          "new_line_content": "        return CompareTxMemPoolEntryByScore()(*i, *j);",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": null,
          "new_api": "GetCountWithAncestors",
          "old_text": null,
          "new_text": "a->GetCountWithAncestors()",
          "old_line_content": "        }",
          "new_line_content": "        uint64_t counta = a->GetCountWithAncestors();",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": null,
          "new_api": "GetCountWithAncestors",
          "old_text": null,
          "new_text": "b->GetCountWithAncestors()",
          "old_line_content": "        return counta < countb;",
          "new_line_content": "        uint64_t countb = b->GetCountWithAncestors();",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": null,
          "new_api": "CompareTxMemPoolEntryByScore",
          "old_text": null,
          "new_text": "CompareTxMemPoolEntryByScore()(*a, *b)",
          "old_line_content": "};",
          "new_line_content": "            return CompareTxMemPoolEntryByScore()(*a, *b);",
          "content_same": false
        },
        {
          "line": 844,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "mapTx.size()",
          "old_line_content": "    }",
          "new_line_content": "    iters.reserve(mapTx.size());",
          "content_same": false
        },
        {
          "line": 846,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapTx.end()",
          "old_line_content": "    return iters;",
          "new_line_content": "    for (indexed_transaction_set::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi) {",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "iters.push_back(mi)",
          "old_line_content": "}",
          "new_line_content": "        iters.push_back(mi);",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": null,
          "new_api": "DepthAndScoreComparator",
          "old_text": null,
          "new_text": "DepthAndScoreComparator()",
          "old_line_content": "void CTxMemPool::queryHashes(std::vector<uint256>& vtxid) const",
          "new_line_content": "    std::sort(iters.begin(), iters.end(), DepthAndScoreComparator());",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": null,
          "new_api": "GetSortedDepthAndScore",
          "old_text": null,
          "new_text": "GetSortedDepthAndScore()",
          "old_line_content": "",
          "new_line_content": "    auto iters = GetSortedDepthAndScore();",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "mapTx.size()",
          "old_line_content": "    }",
          "new_line_content": "    vtxid.reserve(mapTx.size());",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "it->GetTx().GetHash()",
          "old_line_content": "static TxMempoolInfo GetInfo(CTxMemPool::indexed_transaction_set::const_iterator it) {",
          "new_line_content": "        vtxid.push_back(it->GetTx().GetHash());",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": null,
          "new_api": "GetFee",
          "old_text": null,
          "new_text": "it->GetFee()",
          "old_line_content": "{",
          "new_line_content": "    return TxMempoolInfo{it->GetSharedTx(), it->GetTime(), it->GetFee(), it->GetTxSize(), it->GetModifiedFee() - it->GetFee()};",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": null,
          "new_api": "GetSortedDepthAndScore",
          "old_text": null,
          "new_text": "GetSortedDepthAndScore()",
          "old_line_content": "    for (auto it : iters) {",
          "new_line_content": "    auto iters = GetSortedDepthAndScore();",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "mapTx.size()",
          "old_line_content": "",
          "new_line_content": "    ret.reserve(mapTx.size());",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": null,
          "new_api": "GetInfo",
          "old_text": null,
          "new_text": "GetInfo(it)",
          "old_line_content": "}",
          "new_line_content": "        ret.push_back(GetInfo(it));",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "mapTx.find(hash)",
          "old_line_content": "}",
          "new_line_content": "    indexed_transaction_set::const_iterator i = mapTx.find(hash);",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapTx.end()",
          "old_line_content": "",
          "new_line_content": "    if (i == mapTx.end())",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": null,
          "new_api": "GetSharedTx",
          "old_text": null,
          "new_text": "i->GetSharedTx()",
          "old_line_content": "{",
          "new_line_content": "    return i->GetSharedTx();",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": null,
          "new_api": "GetHash",
          "old_text": null,
          "new_text": "gtxid.GetHash()",
          "old_line_content": "}",
          "new_line_content": "    indexed_transaction_set::const_iterator i = (gtxid.IsWtxid() ? get_iter_from_wtxid(gtxid.GetHash()) : mapTx.find(gtxid.GetHash()));",
          "content_same": false
        },
        {
          "line": 897,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapTx.end()",
          "old_line_content": "",
          "new_line_content": "    if (i == mapTx.end())",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": null,
          "new_api": "GetInfo",
          "old_text": null,
          "new_text": "GetInfo(i)",
          "old_line_content": "",
          "new_line_content": "    return GetInfo(i);",
          "content_same": false
        },
        {
          "line": 902,
          "old_api": null,
          "new_api": "info",
          "old_text": null,
          "new_text": "info(GenTxid{false, txid})",
          "old_line_content": "    {",
          "new_line_content": "TxMempoolInfo CTxMemPool::info(const uint256& txid) const { return info(GenTxid{false, txid}); }",
          "content_same": false
        },
        {
          "line": 910,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "mapTx.find(hash)",
          "old_line_content": "            setEntries setAncestors;",
          "new_line_content": "        txiter it = mapTx.find(hash);",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": null,
          "new_api": "update_fee_delta",
          "old_text": null,
          "new_text": "update_fee_delta(delta)",
          "old_line_content": "            std::string dummy;",
          "new_line_content": "            mapTx.modify(it, update_fee_delta(delta));",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": null,
          "new_api": "CalculateMemPoolAncestors",
          "old_text": null,
          "new_text": "CalculateMemPoolAncestors(*it, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, false)",
          "old_line_content": "            // Now update all descendants' modified fees with ancestors",
          "new_line_content": "            CalculateMemPoolAncestors(*it, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, false);",
          "content_same": false
        },
        {
          "line": 923,
          "old_api": null,
          "new_api": "CalculateDescendants",
          "old_text": null,
          "new_text": "CalculateDescendants(it, setDescendants)",
          "old_line_content": "            }",
          "new_line_content": "            CalculateDescendants(it, setDescendants);",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "setDescendants.erase(it)",
          "old_line_content": "            ++nTransactionsUpdated;",
          "new_line_content": "            setDescendants.erase(it);",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": null,
          "new_api": "update_ancestor_state",
          "old_text": null,
          "new_text": "update_ancestor_state(0, nFeeDelta, 0, 0)",
          "old_line_content": "    }",
          "new_line_content": "                mapTx.modify(descendantIt, update_ancestor_state(0, nFeeDelta, 0, 0));",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": null,
          "new_api": "FormatMoney",
          "old_text": null,
          "new_text": "FormatMoney(nFeeDelta)",
          "old_line_content": "{",
          "new_line_content": "    LogPrintf(\"PrioritiseTransaction: %s fee += %s\\n\", hash.ToString(), FormatMoney(nFeeDelta));",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": null,
          "new_api": "AssertLockHeld",
          "old_text": null,
          "new_text": "AssertLockHeld(cs)",
          "old_line_content": "    const CAmount &delta = pos->second;",
          "new_line_content": "    AssertLockHeld(cs);",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "mapDeltas.find(hash)",
          "old_line_content": "    nFeeDelta += delta;",
          "new_line_content": "    std::map<uint256, CAmount>::const_iterator pos = mapDeltas.find(hash);",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapDeltas.end()",
          "old_line_content": "}",
          "new_line_content": "    if (pos == mapDeltas.end())",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": null,
          "new_api": "AssertLockHeld",
          "old_text": null,
          "new_text": "AssertLockHeld(cs)",
          "old_line_content": "const CTransaction* CTxMemPool::GetConflictTx(const COutPoint& prevout) const",
          "new_line_content": "    AssertLockHeld(cs);",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "mapDeltas.erase(hash)",
          "old_line_content": "{",
          "new_line_content": "    mapDeltas.erase(hash);",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "mapNextTx.find(prevout)",
          "old_line_content": "std::optional<CTxMemPool::txiter> CTxMemPool::GetIter(const uint256& txid) const",
          "new_line_content": "    const auto it = mapNextTx.find(prevout);",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapNextTx.end()",
          "old_line_content": "{",
          "new_line_content": "    return it == mapNextTx.end() ? nullptr : it->second;",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "mapTx.find(txid)",
          "old_line_content": "",
          "new_line_content": "    auto it = mapTx.find(txid);",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "mapTx.end()",
          "old_line_content": "CTxMemPool::setEntries CTxMemPool::GetIterSet(const std::set<uint256>& hashes) const",
          "new_line_content": "    if (it != mapTx.end()) return it;",
          "content_same": false
        },
        {
          "line": 967,
          "old_api": null,
          "new_api": "GetIter",
          "old_text": null,
          "new_text": "GetIter(h)",
          "old_line_content": "}",
          "new_line_content": "        const auto mi = GetIter(h);",
          "content_same": false
        },
        {
          "line": 968,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "ret.insert(*mi)",
          "old_line_content": "",
          "new_line_content": "        if (mi) ret.insert(*mi);",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "tx.vin.size()",
          "old_line_content": "}",
          "new_line_content": "    for (unsigned int i = 0; i < tx.vin.size(); i++)",
          "content_same": false
        },
        {
          "line": 976,
          "old_api": null,
          "new_api": "exists",
          "old_text": null,
          "new_text": "exists(tx.vin[i].prevout.hash)",
          "old_line_content": "",
          "new_line_content": "        if (exists(tx.vin[i].prevout.hash))",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "m_temp_added.end()",
          "old_line_content": "",
          "new_line_content": "    if (auto it = m_temp_added.find(outpoint); it != m_temp_added.end()) {",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "mempool.get(outpoint.hash)",
          "old_line_content": "            return true;",
          "new_line_content": "    CTransactionRef ptx = mempool.get(outpoint.hash);",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "ptx->vout.size()",
          "old_line_content": "            return false;",
          "new_line_content": "        if (outpoint.n < ptx->vout.size()) {",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": null,
          "new_api": "Coin",
          "old_text": null,
          "new_text": "Coin(ptx->vout[outpoint.n], MEMPOOL_HEIGHT, false)",
          "old_line_content": "        }",
          "new_line_content": "            coin = Coin(ptx->vout[outpoint.n], MEMPOOL_HEIGHT, false);",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": null,
          "new_api": "GetCoin",
          "old_text": null,
          "new_text": "base->GetCoin(outpoint, coin)",
          "old_line_content": "{",
          "new_line_content": "    return base->GetCoin(outpoint, coin);",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "tx->vout.size()",
          "old_line_content": "",
          "new_line_content": "    for (unsigned int n = 0; n < tx->vout.size(); ++n) {",
          "content_same": false
        },
        {
          "line": 1009,
          "old_api": null,
          "new_api": "Coin",
          "old_text": null,
          "new_text": "Coin(tx->vout[n], MEMPOOL_HEIGHT, false)",
          "old_line_content": "size_t CTxMemPool::DynamicMemoryUsage() const {",
          "new_line_content": "        m_temp_added.emplace(COutPoint(tx->GetHash(), n), Coin(tx->vout[n], MEMPOOL_HEIGHT, false));",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": null,
          "new_api": "LOCK",
          "old_text": null,
          "new_text": "LOCK(cs)",
          "old_line_content": "",
          "new_line_content": "    LOCK(cs);",
          "content_same": false
        },
        {
          "line": 1022,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "m_unbroadcast_txids.erase(txid)",
          "old_line_content": "}",
          "new_line_content": "    if (m_unbroadcast_txids.erase(txid))",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1025,
          "old_api": "AssertLockHeld",
          "new_api": null,
          "old_text": "AssertLockHeld(cs)",
          "new_text": null,
          "old_line_content": "    AssertLockHeld(cs);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": "UpdateForRemoveFromMempool",
          "new_api": null,
          "old_text": "UpdateForRemoveFromMempool(stage, updateDescendants)",
          "new_text": null,
          "old_line_content": "    UpdateForRemoveFromMempool(stage, updateDescendants);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": "removeUnchecked",
          "new_api": null,
          "old_text": "removeUnchecked(it, reason)",
          "new_text": null,
          "old_line_content": "        removeUnchecked(it, reason);",
          "new_line_content": "void CTxMemPool::RemoveStaged(setEntries &stage, bool updateDescendants, MemPoolRemovalReason reason) {",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": "AssertLockHeld",
          "new_api": null,
          "old_text": "AssertLockHeld(cs)",
          "new_text": null,
          "old_line_content": "    AssertLockHeld(cs);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": "begin",
          "new_api": null,
          "old_text": "mapTx.get<entry_time>().begin()",
          "new_text": null,
          "old_line_content": "    indexed_transaction_set::index<entry_time>::type::iterator it = mapTx.get<entry_time>().begin();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1037,
          "old_api": "GetTime",
          "new_api": null,
          "old_text": "it->GetTime()",
          "new_text": null,
          "old_line_content": "    while (it != mapTx.get<entry_time>().end() && it->GetTime() < time) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": "CalculateDescendants",
          "new_api": null,
          "old_text": "CalculateDescendants(removeit, stage)",
          "new_text": null,
          "old_line_content": "        CalculateDescendants(removeit, stage);",
          "new_line_content": "        it++;",
          "content_same": false
        },
        {
          "line": 1045,
          "old_api": "RemoveStaged",
          "new_api": null,
          "old_text": "RemoveStaged(stage, false, MemPoolRemovalReason::EXPIRY)",
          "new_text": null,
          "old_line_content": "    RemoveStaged(stage, false, MemPoolRemovalReason::EXPIRY);",
          "new_line_content": "    setEntries stage;",
          "content_same": false
        },
        {
          "line": 1046,
          "old_api": "size",
          "new_api": null,
          "old_text": "stage.size()",
          "new_text": null,
          "old_line_content": "    return stage.size();",
          "new_line_content": "    for (txiter removeit : toremove) {",
          "content_same": false
        },
        {
          "line": 1052,
          "old_api": "std::numeric_limits<uint64_t>::max()",
          "new_api": null,
          "old_text": "std::numeric_limits<uint64_t>::max()",
          "new_text": null,
          "old_line_content": "    uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": "CalculateMemPoolAncestors",
          "new_api": null,
          "old_text": "CalculateMemPoolAncestors(entry, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy)",
          "new_text": null,
          "old_line_content": "    CalculateMemPoolAncestors(entry, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": "addUnchecked",
          "new_api": null,
          "old_text": "addUnchecked(entry, setAncestors, validFeeEstimate)",
          "new_text": null,
          "old_line_content": "    return addUnchecked(entry, setAncestors, validFeeEstimate);",
          "new_line_content": "    setEntries setAncestors;",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": "AssertLockHeld",
          "new_api": null,
          "old_text": "AssertLockHeld(cs)",
          "new_text": null,
          "old_line_content": "    AssertLockHeld(cs);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": "insert",
          "new_api": null,
          "old_text": "entry->GetMemPoolChildren().insert(*child)",
          "new_text": null,
          "old_line_content": "    if (add && entry->GetMemPoolChildren().insert(*child).second) {",
          "new_line_content": "void CTxMemPool::UpdateChild(txiter entry, txiter child, bool add)",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": "memusage::IncrementalDynamicUsage(s)",
          "new_api": null,
          "old_text": "memusage::IncrementalDynamicUsage(s)",
          "new_text": null,
          "old_line_content": "        cachedInnerUsage += memusage::IncrementalDynamicUsage(s);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1065,
          "old_api": "memusage::IncrementalDynamicUsage(s)",
          "new_api": null,
          "old_text": "memusage::IncrementalDynamicUsage(s)",
          "new_text": null,
          "old_line_content": "        cachedInnerUsage -= memusage::IncrementalDynamicUsage(s);",
          "new_line_content": "    CTxMemPoolEntry::Children s;",
          "content_same": false
        },
        {
          "line": 1071,
          "old_api": "AssertLockHeld",
          "new_api": null,
          "old_text": "AssertLockHeld(cs)",
          "new_text": null,
          "old_line_content": "    AssertLockHeld(cs);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1073,
          "old_api": "insert",
          "new_api": null,
          "old_text": "entry->GetMemPoolParents().insert(*parent)",
          "new_text": null,
          "old_line_content": "    if (add && entry->GetMemPoolParents().insert(*parent).second) {",
          "new_line_content": "void CTxMemPool::UpdateParent(txiter entry, txiter parent, bool add)",
          "content_same": false
        },
        {
          "line": 1074,
          "old_api": "memusage::IncrementalDynamicUsage(s)",
          "new_api": null,
          "old_text": "memusage::IncrementalDynamicUsage(s)",
          "new_text": null,
          "old_line_content": "        cachedInnerUsage += memusage::IncrementalDynamicUsage(s);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1076,
          "old_api": "memusage::IncrementalDynamicUsage(s)",
          "new_api": null,
          "old_text": "memusage::IncrementalDynamicUsage(s)",
          "new_text": null,
          "old_line_content": "        cachedInnerUsage -= memusage::IncrementalDynamicUsage(s);",
          "new_line_content": "    CTxMemPoolEntry::Parents s;",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs)",
          "new_text": null,
          "old_line_content": "    LOCK(cs);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1083,
          "old_api": "llround",
          "new_api": null,
          "old_text": "llround(rollingMinimumFeeRate)",
          "new_text": null,
          "old_line_content": "        return CFeeRate(llround(rollingMinimumFeeRate));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": "DynamicMemoryUsage",
          "new_api": null,
          "old_text": "DynamicMemoryUsage()",
          "new_text": null,
          "old_line_content": "        if (DynamicMemoryUsage() < sizelimit / 4)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1090,
          "old_api": "DynamicMemoryUsage",
          "new_api": null,
          "old_text": "DynamicMemoryUsage()",
          "new_text": null,
          "old_line_content": "        else if (DynamicMemoryUsage() < sizelimit / 2)",
          "new_line_content": "    if (time > lastRollingFeeUpdate + 10) {",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": "pow",
          "new_api": null,
          "old_text": "pow(2.0, (time - lastRollingFeeUpdate) / halflife)",
          "new_text": null,
          "old_line_content": "        rollingMinimumFeeRate = rollingMinimumFeeRate / pow(2.0, (time - lastRollingFeeUpdate) / halflife);",
          "new_line_content": "            halflife /= 4;",
          "content_same": false
        },
        {
          "line": 1096,
          "old_api": "GetFeePerK",
          "new_api": null,
          "old_text": "incrementalRelayFee.GetFeePerK()",
          "new_text": null,
          "old_line_content": "        if (rollingMinimumFeeRate < (double)incrementalRelayFee.GetFeePerK() / 2) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1098,
          "old_api": "CFeeRate",
          "new_api": null,
          "old_text": "CFeeRate(0)",
          "new_text": null,
          "old_line_content": "            return CFeeRate(0);",
          "new_line_content": "        lastRollingFeeUpdate = time;",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": "llround",
          "new_api": null,
          "old_text": "llround(rollingMinimumFeeRate)",
          "new_text": null,
          "old_line_content": "    return std::max(CFeeRate(llround(rollingMinimumFeeRate)), incrementalRelayFee);",
          "new_line_content": "            rollingMinimumFeeRate = 0;",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": "GetFeePerK",
          "new_api": null,
          "old_text": "rate.GetFeePerK()",
          "new_text": null,
          "old_line_content": "    if (rate.GetFeePerK() > rollingMinimumFeeRate) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1107,
          "old_api": "GetFeePerK",
          "new_api": null,
          "old_text": "rate.GetFeePerK()",
          "new_text": null,
          "old_line_content": "        rollingMinimumFeeRate = rate.GetFeePerK();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1113,
          "old_api": "AssertLockHeld",
          "new_api": null,
          "old_text": "AssertLockHeld(cs)",
          "new_text": null,
          "old_line_content": "    AssertLockHeld(cs);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1118,
          "old_api": "begin",
          "new_api": null,
          "old_text": "mapTx.get<descendant_score>().begin()",
          "new_text": null,
          "old_line_content": "        indexed_transaction_set::index<descendant_score>::type::iterator it = mapTx.get<descendant_score>().begin();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1124,
          "old_api": "GetSizeWithDescendants",
          "new_api": null,
          "old_text": "it->GetSizeWithDescendants()",
          "new_text": null,
          "old_line_content": "        CFeeRate removed(it->GetModFeesWithDescendants(), it->GetSizeWithDescendants());",
          "new_line_content": "        // We set the new mempool min fee to the feerate of the removed set, plus the",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": "trackPackageRemoved",
          "new_api": null,
          "old_text": "trackPackageRemoved(removed)",
          "new_text": null,
          "old_line_content": "        trackPackageRemoved(removed);",
          "new_line_content": "        // to have 0 fee). This way, we don't allow txn to enter mempool with feerate",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": "std::max(maxFeeRateRemoved, removed)",
          "new_api": null,
          "old_text": "std::max(maxFeeRateRemoved, removed)",
          "new_text": null,
          "old_line_content": "        maxFeeRateRemoved = std::max(maxFeeRateRemoved, removed);",
          "new_line_content": "        // equal to txn which were removed with no block in between.",
          "content_same": false
        },
        {
          "line": 1137,
          "old_api": "GetTx",
          "new_api": null,
          "old_text": "iter->GetTx()",
          "new_text": null,
          "old_line_content": "                txn.push_back(iter->GetTx());",
          "new_line_content": "        std::vector<CTransaction> txn;",
          "content_same": false
        },
        {
          "line": 1144,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "pvNoSpendsRemaining->push_back(txin.prevout)",
          "new_text": null,
          "old_line_content": "                    pvNoSpendsRemaining->push_back(txin.prevout);",
          "new_line_content": "        if (pvNoSpendsRemaining) {",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": "CFeeRate",
          "new_api": null,
          "old_text": "CFeeRate(0)",
          "new_text": null,
          "old_line_content": "    if (maxFeeRateRemoved > CFeeRate(0)) {",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1151,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "maxFeeRateRemoved.ToString()",
          "new_text": null,
          "old_line_content": "        LogPrint(BCLog::MEMPOOL, \"Removed %u txn, rolling minimum fee bumped to %s\\n\", nTxnRemoved, maxFeeRateRemoved.ToString());",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "candidates.push_back(entry)",
          "new_text": null,
          "old_line_content": "    candidates.push_back(entry);",
          "new_line_content": "uint64_t CTxMemPool::CalculateDescendantMaximum(txiter entry) const {",
          "content_same": false
        },
        {
          "line": 1161,
          "old_api": "size",
          "new_api": null,
          "old_text": "candidates.size()",
          "new_text": null,
          "old_line_content": "    while (candidates.size()) {",
          "new_line_content": "    std::vector<txiter> candidates;",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": "back",
          "new_api": null,
          "old_text": "candidates.back()",
          "new_text": null,
          "old_line_content": "        txiter candidate = candidates.back();",
          "new_line_content": "    setEntries counted;",
          "content_same": false
        },
        {
          "line": 1164,
          "old_api": "insert",
          "new_api": null,
          "old_text": "counted.insert(candidate)",
          "new_text": null,
          "old_line_content": "        if (!counted.insert(candidate).second) continue;",
          "new_line_content": "    uint64_t maximum = 0;",
          "content_same": false
        },
        {
          "line": 1178,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs)",
          "new_text": null,
          "old_line_content": "    LOCK(cs);",
          "new_line_content": "    return maximum;",
          "content_same": false
        },
        {
          "line": 1179,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapTx.find(txid)",
          "new_text": null,
          "old_line_content": "    auto it = mapTx.find(txid);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1181,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapTx.end()",
          "new_text": null,
          "old_line_content": "    if (it != mapTx.end()) {",
          "new_line_content": "void CTxMemPool::GetTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants, size_t* const ancestorsize, CAmount* const ancestorfees) const {",
          "content_same": false
        },
        {
          "line": 1184,
          "old_api": "GetModFeesWithAncestors",
          "new_api": null,
          "old_text": "it->GetModFeesWithAncestors()",
          "new_text": null,
          "old_line_content": "        if (ancestorfees) *ancestorfees = it->GetModFeesWithAncestors();",
          "new_line_content": "    ancestors = descendants = 0;",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs)",
          "new_text": null,
          "old_line_content": "    LOCK(cs);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1197,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs)",
          "new_text": null,
          "old_line_content": "    LOCK(cs);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 697,
          "old_api": "CoinsTip",
          "new_api": null,
          "old_text": "active_chainstate.CoinsTip()",
          "new_text": null,
          "old_line_content": "    CCoinsViewCache& active_coins_tip = active_chainstate.CoinsTip();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapTx.end()",
          "new_text": null,
          "old_line_content": "    for (indexed_transaction_set::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {",
          "new_line_content": "    std::list<const CTxMemPoolEntry*> waitingOnDependants;",
          "content_same": false
        },
        {
          "line": 704,
          "old_api": "GetTxSize",
          "new_api": null,
          "old_text": "it->GetTxSize()",
          "new_text": null,
          "old_line_content": "        checkTotal += it->GetTxSize();",
          "new_line_content": "        unsigned int i = 0;",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapTx.find(txin.prevout.hash)",
          "new_text": null,
          "old_line_content": "            indexed_transaction_set::const_iterator it2 = mapTx.find(txin.prevout.hash);",
          "new_line_content": "            // Check that every mempool transaction's inputs refer to available coins, or other mempool tx's.",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": "HaveCoin",
          "new_api": null,
          "old_text": "active_coins_tip.HaveCoin(txin.prevout)",
          "new_text": null,
          "old_line_content": "                assert(active_coins_tip.HaveCoin(txin.prevout));",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapNextTx.find(txin.prevout)",
          "new_text": null,
          "old_line_content": "            auto it3 = mapNextTx.find(txin.prevout);",
          "new_line_content": "            // Check whether its inputs are marked in mapNextTx.",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": "GetTx",
          "new_api": null,
          "old_text": "b.GetTx().GetHash()",
          "new_text": null,
          "old_line_content": "            return a.GetTx().GetHash() == b.GetTx().GetHash();",
          "new_line_content": "        auto comp = [](const CTxMemPoolEntry& a, const CTxMemPoolEntry& b) -> bool {",
          "content_same": false
        },
        {
          "line": 732,
          "old_api": "size",
          "new_api": null,
          "old_text": "it->GetMemPoolParentsConst().size()",
          "new_text": null,
          "old_line_content": "        assert(setParentCheck.size() == it->GetMemPoolParentsConst().size());",
          "new_line_content": "        };",
          "content_same": false
        },
        {
          "line": 736,
          "old_api": "std::numeric_limits<uint64_t>::max()",
          "new_api": null,
          "old_text": "std::numeric_limits<uint64_t>::max()",
          "new_text": null,
          "old_line_content": "        uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();",
          "new_line_content": "        setEntries setAncestors;",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": "CalculateMemPoolAncestors",
          "new_api": null,
          "old_text": "CalculateMemPoolAncestors(*it, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy)",
          "new_text": null,
          "old_line_content": "        CalculateMemPoolAncestors(*it, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy);",
          "new_line_content": "        std::string dummy;",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": "GetTxSize",
          "new_api": null,
          "old_text": "ancestorIt->GetTxSize()",
          "new_text": null,
          "old_line_content": "            nSizeCheck += ancestorIt->GetTxSize();",
          "new_line_content": "        for (txiter ancestorIt : setAncestors) {",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": "GetCountWithAncestors",
          "new_api": null,
          "old_text": "it->GetCountWithAncestors()",
          "new_text": null,
          "old_line_content": "        assert(it->GetCountWithAncestors() == nCountCheck);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "it->GetTx().GetHash()",
          "new_text": null,
          "old_line_content": "        for (; iter != mapNextTx.end() && iter->first->hash == it->GetTx().GetHash(); ++iter) {",
          "new_line_content": "        // Check children against mapNextTx",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "iter->second->GetHash()",
          "new_text": null,
          "old_line_content": "            txiter childit = mapTx.find(iter->second->GetHash());",
          "new_line_content": "        CTxMemPoolEntry::Children setChildrenCheck;",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": "insert",
          "new_api": null,
          "old_text": "setChildrenCheck.insert(*childit)",
          "new_text": null,
          "old_line_content": "            if (setChildrenCheck.insert(*childit).second) {",
          "new_line_content": "        uint64_t child_sizes = 0;",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "waitingOnDependants.push_back(&(*it))",
          "new_text": null,
          "old_line_content": "            waitingOnDependants.push_back(&(*it));",
          "new_line_content": "        // just a sanity check, not definitive that this calc is correct...",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": "CheckInputsAndUpdateCoins",
          "new_api": null,
          "old_text": "CheckInputsAndUpdateCoins(tx, mempoolDuplicate, spendheight)",
          "new_text": null,
          "old_line_content": "            CheckInputsAndUpdateCoins(tx, mempoolDuplicate, spendheight);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": "front",
          "new_api": null,
          "old_text": "waitingOnDependants.front()",
          "new_text": null,
          "old_line_content": "        const CTxMemPoolEntry* entry = waitingOnDependants.front();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": "pop_front",
          "new_api": null,
          "old_text": "waitingOnDependants.pop_front()",
          "new_text": null,
          "old_line_content": "        waitingOnDependants.pop_front();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 782,
          "old_api": "GetTx",
          "new_api": null,
          "old_text": "entry->GetTx()",
          "new_text": null,
          "old_line_content": "        if (!mempoolDuplicate.HaveInputs(entry->GetTx())) {",
          "new_line_content": "    unsigned int stepsSinceLastRemove = 0;",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "it->second->GetHash()",
          "new_text": null,
          "old_line_content": "        uint256 hash = it->second->GetHash();",
          "new_line_content": "            stepsSinceLastRemove = 0;",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapTx.find(hash)",
          "new_text": null,
          "old_line_content": "        indexed_transaction_set::const_iterator it2 = mapTx.find(hash);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 794,
          "old_api": "GetTx",
          "new_api": null,
          "old_text": "it2->GetTx()",
          "new_text": null,
          "old_line_content": "        const CTransaction& tx = it2->GetTx();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(innerUsage == cachedInnerUsage)",
          "new_text": null,
          "old_line_content": "    assert(innerUsage == cachedInnerUsage);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs)",
          "new_text": null,
          "old_line_content": "    LOCK(cs);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapTx.find(hasha)",
          "new_text": null,
          "old_line_content": "    indexed_transaction_set::const_iterator i = wtxid ? get_iter_from_wtxid(hasha) : mapTx.find(hasha);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapTx.end()",
          "new_text": null,
          "old_line_content": "    if (i == mapTx.end()) return false;",
          "new_line_content": "bool CTxMemPool::CompareDepthAndScore(const uint256& hasha, const uint256& hashb, bool wtxid)",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapTx.find(hashb)",
          "new_text": null,
          "old_line_content": "    indexed_transaction_set::const_iterator j = wtxid ? get_iter_from_wtxid(hashb) : mapTx.find(hashb);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": "GetCountWithAncestors",
          "new_api": null,
          "old_text": "a->GetCountWithAncestors()",
          "new_text": null,
          "old_line_content": "        uint64_t counta = a->GetCountWithAncestors();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": "GetCountWithAncestors",
          "new_api": null,
          "old_text": "b->GetCountWithAncestors()",
          "new_text": null,
          "old_line_content": "        uint64_t countb = b->GetCountWithAncestors();",
          "new_line_content": "public:",
          "content_same": false
        },
        {
          "line": 828,
          "old_api": "CompareTxMemPoolEntryByScore",
          "new_api": null,
          "old_text": "CompareTxMemPoolEntryByScore()(*a, *b)",
          "new_text": null,
          "old_line_content": "            return CompareTxMemPoolEntryByScore()(*a, *b);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": "AssertLockHeld",
          "new_api": null,
          "old_text": "AssertLockHeld(cs)",
          "new_text": null,
          "old_line_content": "    AssertLockHeld(cs);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": "size",
          "new_api": null,
          "old_text": "mapTx.size()",
          "new_text": null,
          "old_line_content": "    iters.reserve(mapTx.size());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "iters.push_back(mi)",
          "new_text": null,
          "old_line_content": "        iters.push_back(mi);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 845,
          "old_api": "DepthAndScoreComparator",
          "new_api": null,
          "old_text": "DepthAndScoreComparator()",
          "new_text": null,
          "old_line_content": "    std::sort(iters.begin(), iters.end(), DepthAndScoreComparator());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 851,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs)",
          "new_text": null,
          "old_line_content": "    LOCK(cs);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": "GetSortedDepthAndScore",
          "new_api": null,
          "old_text": "GetSortedDepthAndScore()",
          "new_text": null,
          "old_line_content": "    auto iters = GetSortedDepthAndScore();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 854,
          "old_api": "clear",
          "new_api": null,
          "old_text": "vtxid.clear()",
          "new_text": null,
          "old_line_content": "    vtxid.clear();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 863,
          "old_api": "GetFee",
          "new_api": null,
          "old_text": "it->GetFee()",
          "new_text": null,
          "old_line_content": "    return TxMempoolInfo{it->GetSharedTx(), it->GetTime(), it->GetFee(), it->GetTxSize(), it->GetModifiedFee() - it->GetFee()};",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs)",
          "new_text": null,
          "old_line_content": "    LOCK(cs);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": "GetSortedDepthAndScore",
          "new_api": null,
          "old_text": "GetSortedDepthAndScore()",
          "new_text": null,
          "old_line_content": "    auto iters = GetSortedDepthAndScore();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": "GetInfo",
          "new_api": null,
          "old_text": "GetInfo(it)",
          "new_text": null,
          "old_line_content": "        ret.push_back(GetInfo(it));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs)",
          "new_text": null,
          "old_line_content": "    LOCK(cs);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 883,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapTx.find(hash)",
          "new_text": null,
          "old_line_content": "    indexed_transaction_set::const_iterator i = mapTx.find(hash);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapTx.end()",
          "new_text": null,
          "old_line_content": "    if (i == mapTx.end())",
          "new_line_content": "CTransactionRef CTxMemPool::get(const uint256& hash) const",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs)",
          "new_text": null,
          "old_line_content": "    LOCK(cs);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": "GetHash",
          "new_api": null,
          "old_text": "gtxid.GetHash()",
          "new_text": null,
          "old_line_content": "    indexed_transaction_set::const_iterator i = (gtxid.IsWtxid() ? get_iter_from_wtxid(gtxid.GetHash()) : mapTx.find(gtxid.GetHash()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapTx.end()",
          "new_text": null,
          "old_line_content": "    if (i == mapTx.end())",
          "new_line_content": "TxMempoolInfo CTxMemPool::info(const GenTxid& gtxid) const",
          "content_same": false
        },
        {
          "line": 894,
          "old_api": "TxMempoolInfo",
          "new_api": null,
          "old_text": "TxMempoolInfo()",
          "new_text": null,
          "old_line_content": "        return TxMempoolInfo();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 903,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs)",
          "new_text": null,
          "old_line_content": "        LOCK(cs);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapTx.find(hash)",
          "new_text": null,
          "old_line_content": "        txiter it = mapTx.find(hash);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": "update_fee_delta",
          "new_api": null,
          "old_text": "update_fee_delta(delta)",
          "new_text": null,
          "old_line_content": "            mapTx.modify(it, update_fee_delta(delta));",
          "new_line_content": "        CAmount &delta = mapDeltas[hash];",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": "CalculateMemPoolAncestors",
          "new_api": null,
          "old_text": "CalculateMemPoolAncestors(*it, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, false)",
          "new_text": null,
          "old_line_content": "            CalculateMemPoolAncestors(*it, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, false);",
          "new_line_content": "            // Now update all ancestors' modified fees with descendants",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": "erase",
          "new_api": null,
          "old_text": "setDescendants.erase(it)",
          "new_text": null,
          "old_line_content": "            setDescendants.erase(it);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": "update_ancestor_state",
          "new_api": null,
          "old_text": "update_ancestor_state(0, nFeeDelta, 0, 0)",
          "new_text": null,
          "old_line_content": "                mapTx.modify(descendantIt, update_ancestor_state(0, nFeeDelta, 0, 0));",
          "new_line_content": "            setEntries setDescendants;",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": "FormatMoney",
          "new_api": null,
          "old_text": "FormatMoney(nFeeDelta)",
          "new_text": null,
          "old_line_content": "    LogPrintf(\"PrioritiseTransaction: %s fee += %s\\n\", hash.ToString(), FormatMoney(nFeeDelta));",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": "AssertLockHeld",
          "new_api": null,
          "old_text": "AssertLockHeld(cs)",
          "new_text": null,
          "old_line_content": "    AssertLockHeld(cs);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapDeltas.find(hash)",
          "new_text": null,
          "old_line_content": "    std::map<uint256, CAmount>::const_iterator pos = mapDeltas.find(hash);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapDeltas.end()",
          "new_text": null,
          "old_line_content": "    if (pos == mapDeltas.end())",
          "new_line_content": "void CTxMemPool::ApplyDelta(const uint256& hash, CAmount &nFeeDelta) const",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": "AssertLockHeld",
          "new_api": null,
          "old_text": "AssertLockHeld(cs)",
          "new_text": null,
          "old_line_content": "    AssertLockHeld(cs);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": "erase",
          "new_api": null,
          "old_text": "mapDeltas.erase(hash)",
          "new_text": null,
          "old_line_content": "    mapDeltas.erase(hash);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 948,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapNextTx.find(prevout)",
          "new_text": null,
          "old_line_content": "    const auto it = mapNextTx.find(prevout);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapNextTx.end()",
          "new_text": null,
          "old_line_content": "    return it == mapNextTx.end() ? nullptr : it->second;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": "find",
          "new_api": null,
          "old_text": "mapTx.find(txid)",
          "new_text": null,
          "old_line_content": "    auto it = mapTx.find(txid);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": "end",
          "new_api": null,
          "old_text": "mapTx.end()",
          "new_text": null,
          "old_line_content": "    if (it != mapTx.end()) return it;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": "GetIter",
          "new_api": null,
          "old_text": "GetIter(h)",
          "new_text": null,
          "old_line_content": "        const auto mi = GetIter(h);",
          "new_line_content": "CTxMemPool::setEntries CTxMemPool::GetIterSet(const std::set<uint256>& hashes) const",
          "content_same": false
        },
        {
          "line": 964,
          "old_api": "insert",
          "new_api": null,
          "old_text": "ret.insert(*mi)",
          "new_text": null,
          "old_line_content": "        if (mi) ret.insert(*mi);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": "size",
          "new_api": null,
          "old_text": "tx.vin.size()",
          "new_text": null,
          "old_line_content": "    for (unsigned int i = 0; i < tx.vin.size(); i++)",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": "exists",
          "new_api": null,
          "old_text": "exists(tx.vin[i].prevout.hash)",
          "new_text": null,
          "old_line_content": "        if (exists(tx.vin[i].prevout.hash))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": "end",
          "new_api": null,
          "old_text": "m_temp_added.end()",
          "new_text": null,
          "old_line_content": "    if (auto it = m_temp_added.find(outpoint); it != m_temp_added.end()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 990,
          "old_api": "get",
          "new_api": null,
          "old_text": "mempool.get(outpoint.hash)",
          "new_text": null,
          "old_line_content": "    CTransactionRef ptx = mempool.get(outpoint.hash);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": "size",
          "new_api": null,
          "old_text": "ptx->vout.size()",
          "new_text": null,
          "old_line_content": "        if (outpoint.n < ptx->vout.size()) {",
          "new_line_content": "    // conflict with the underlying cache, and it cannot have pruned entries (as it contains full)",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": "Coin",
          "new_api": null,
          "old_text": "Coin(ptx->vout[outpoint.n], MEMPOOL_HEIGHT, false)",
          "new_text": null,
          "old_line_content": "            coin = Coin(ptx->vout[outpoint.n], MEMPOOL_HEIGHT, false);",
          "new_line_content": "    // transactions. First checking the underlying cache risks returning a pruned entry instead.",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "GetCoin",
          "new_api": null,
          "old_text": "base->GetCoin(outpoint, coin)",
          "new_text": null,
          "old_line_content": "    return base->GetCoin(outpoint, coin);",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": "size",
          "new_api": null,
          "old_text": "tx->vout.size()",
          "new_text": null,
          "old_line_content": "    for (unsigned int n = 0; n < tx->vout.size(); ++n) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": "Coin",
          "new_api": null,
          "old_text": "Coin(tx->vout[n], MEMPOOL_HEIGHT, false)",
          "new_text": null,
          "old_line_content": "        m_temp_added.emplace(COutPoint(tx->GetHash(), n), Coin(tx->vout[n], MEMPOOL_HEIGHT, false));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(cs)",
          "new_text": null,
          "old_line_content": "    LOCK(cs);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": "memusage::DynamicUsage(vTxHashes)",
          "new_api": null,
          "old_text": "memusage::DynamicUsage(vTxHashes)",
          "new_text": null,
          "old_line_content": "    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 15 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + memusage::DynamicUsage(vTxHashes) + cachedInnerUsage;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": "erase",
          "new_api": null,
          "old_text": "m_unbroadcast_txids.erase(txid)",
          "new_text": null,
          "old_line_content": "    if (m_unbroadcast_txids.erase(txid))",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 71,
      "total_additions": 131,
      "total_deletions": 128,
      "total_api_changes": 330
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 8,
        "api_related_lines": 330,
        "non_api_lines": 2,
        "non_api_line_numbers": [
          696,
          755
        ]
      }
    },
    "api_calls_before": 573,
    "api_calls_after": 576,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 2,
      "total_diff_lines": 40
    }
  }
}