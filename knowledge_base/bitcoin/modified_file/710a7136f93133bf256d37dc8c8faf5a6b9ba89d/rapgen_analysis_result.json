{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/710a7136f93133bf256d37dc8c8faf5a6b9ba89d",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/710a7136f93133bf256d37dc8c8faf5a6b9ba89d/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/710a7136f93133bf256d37dc8c8faf5a6b9ba89d/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/bitcoin/modified_file/710a7136f93133bf256d37dc8c8faf5a6b9ba89d/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 3800,
          "old_api": "std::string(\"No addresses with label \" + label)",
          "new_api": "emplace",
          "old_text": "std::string(\"No addresses with label \" + label)",
          "new_text": "addresses.emplace(address)",
          "old_line_content": "        throw JSONRPCError(RPC_WALLET_INVALID_LABEL_NAME, std::string(\"No addresses with label \" + label));",
          "new_line_content": "            bool unique = addresses.emplace(address).second;",
          "content_same": false
        },
        {
          "line": 3811,
          "old_api": "EnsureWalletIsAvailable",
          "new_api": "std::string(\"No addresses with label \" + label)",
          "old_text": "EnsureWalletIsAvailable(pwallet, request.fHelp)",
          "new_text": "std::string(\"No addresses with label \" + label)",
          "old_line_content": "    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {",
          "new_line_content": "        throw JSONRPCError(RPC_WALLET_INVALID_LABEL_NAME, std::string(\"No addresses with label \" + label));",
          "content_same": false
        },
        {
          "line": 3843,
          "old_api": "isNull",
          "new_api": "HelpExampleCli",
          "old_text": "request.params[0].isNull()",
          "new_text": "HelpExampleCli(\"listlabels\", \"receive\")",
          "old_line_content": "    if (!request.params[0].isNull()) {",
          "new_line_content": "            + HelpExampleCli(\"listlabels\", \"receive\") +",
          "content_same": false
        },
        {
          "line": 3851,
          "old_api": "insert",
          "new_api": "LOCK",
          "old_text": "label_set.insert(entry.second.name)",
          "new_text": "LOCK(pwallet->cs_wallet)",
          "old_line_content": "            label_set.insert(entry.second.name);",
          "new_line_content": "    LOCK(pwallet->cs_wallet);",
          "content_same": false
        },
        {
          "line": 3868,
          "old_api": "EnsureWalletIsAvailable",
          "new_api": "push_back",
          "old_text": "EnsureWalletIsAvailable(pwallet, request.fHelp)",
          "new_text": "ret.push_back(name)",
          "old_line_content": "    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {",
          "new_line_content": "        ret.push_back(name);",
          "content_same": false
        },
        {
          "line": 3889,
          "old_api": "HelpExampleCli",
          "new_api": "HelpRequiringPassphrase",
          "old_text": "HelpExampleCli(\"sethdseed\", \"\")",
          "new_text": "HelpRequiringPassphrase(pwallet)",
          "old_line_content": "                    HelpExampleCli(\"sethdseed\", \"\")",
          "new_line_content": "                    HelpRequiringPassphrase(pwallet) + \"\\n\",",
          "content_same": false
        },
        {
          "line": 3901,
          "old_api": "IsWalletFlagSet",
          "new_api": "HelpExampleCli",
          "old_text": "pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)",
          "new_text": "HelpExampleCli(\"sethdseed\", \"false\")",
          "old_line_content": "    if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {",
          "new_line_content": "            + HelpExampleCli(\"sethdseed\", \"false\")",
          "content_same": false
        },
        {
          "line": 3902,
          "old_api": "JSONRPCError",
          "new_api": "HelpExampleCli",
          "old_text": "JSONRPCError(RPC_WALLET_ERROR, \"Cannot set a HD seed to a wallet with private keys disabled\")",
          "new_text": "HelpExampleCli(\"sethdseed\", \"true \\\"wifkey\\\"\")",
          "old_line_content": "        throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot set a HD seed to a wallet with private keys disabled\");",
          "new_line_content": "            + HelpExampleCli(\"sethdseed\", \"true \\\"wifkey\\\"\")",
          "content_same": false
        },
        {
          "line": 3909,
          "old_api": "CanSupportFeature",
          "new_api": "JSONRPCError",
          "old_text": "pwallet->CanSupportFeature(FEATURE_HD)",
          "new_text": "JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, \"Cannot set a new HD seed while still in Initial Block Download\")",
          "old_line_content": "    if (!pwallet->CanSupportFeature(FEATURE_HD)) {",
          "new_line_content": "        throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, \"Cannot set a new HD seed while still in Initial Block Download\");",
          "content_same": false
        },
        {
          "line": 3913,
          "old_api": "EnsureWalletIsUnlocked",
          "new_api": "JSONRPCError",
          "old_text": "EnsureWalletIsUnlocked(pwallet)",
          "new_text": "JSONRPCError(RPC_WALLET_ERROR, \"Cannot set a HD seed to a wallet with private keys disabled\")",
          "old_line_content": "    EnsureWalletIsUnlocked(pwallet);",
          "new_line_content": "        throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot set a HD seed to a wallet with private keys disabled\");",
          "content_same": false
        },
        {
          "line": 3916,
          "old_api": "isNull",
          "new_api": "lock",
          "old_text": "request.params[0].isNull()",
          "new_text": "pwallet->chain().lock()",
          "old_line_content": "    if (!request.params[0].isNull()) {",
          "new_line_content": "    auto locked_chain = pwallet->chain().lock();",
          "content_same": false
        },
        {
          "line": 3917,
          "old_api": "get_bool",
          "new_api": "LOCK",
          "old_text": "request.params[0].get_bool()",
          "new_text": "LOCK(pwallet->cs_wallet)",
          "old_line_content": "        flush_key_pool = request.params[0].get_bool();",
          "new_line_content": "    LOCK(pwallet->cs_wallet);",
          "content_same": false
        },
        {
          "line": 3921,
          "old_api": "isNull",
          "new_api": "JSONRPCError",
          "old_text": "request.params[1].isNull()",
          "new_text": "JSONRPCError(RPC_WALLET_ERROR, \"Cannot set a HD seed on a non-HD wallet. Start with -upgradewallet in order to upgrade a non-HD wallet to HD\")",
          "old_line_content": "    if (request.params[1].isNull()) {",
          "new_line_content": "        throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot set a HD seed on a non-HD wallet. Start with -upgradewallet in order to upgrade a non-HD wallet to HD\");",
          "content_same": false
        },
        {
          "line": 3924,
          "old_api": "get_str",
          "new_api": "EnsureWalletIsUnlocked",
          "old_text": "request.params[1].get_str()",
          "new_text": "EnsureWalletIsUnlocked(pwallet)",
          "old_line_content": "        CKey key = DecodeSecret(request.params[1].get_str());",
          "new_line_content": "    EnsureWalletIsUnlocked(pwallet);",
          "content_same": false
        },
        {
          "line": 3933,
          "old_api": "DeriveNewSeed",
          "new_api": "GenerateNewSeed",
          "old_text": "pwallet->DeriveNewSeed(key)",
          "new_text": "pwallet->GenerateNewSeed()",
          "old_line_content": "        master_pub_key = pwallet->DeriveNewSeed(key);",
          "new_line_content": "        master_pub_key = pwallet->GenerateNewSeed();",
          "content_same": false
        },
        {
          "line": 3936,
          "old_api": "SetHDSeed",
          "new_api": "IsValid",
          "old_text": "pwallet->SetHDSeed(master_pub_key)",
          "new_text": "key.IsValid()",
          "old_line_content": "    pwallet->SetHDSeed(master_pub_key);",
          "new_line_content": "        if (!key.IsValid()) {",
          "content_same": false
        },
        {
          "line": 3937,
          "old_api": "NewKeyPool",
          "new_api": "JSONRPCError",
          "old_text": "pwallet->NewKeyPool()",
          "new_text": "JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key\")",
          "old_line_content": "    if (flush_key_pool) pwallet->NewKeyPool();",
          "new_line_content": "            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key\");",
          "content_same": false
        },
        {
          "line": 3960,
          "old_api": "EnsureWalletIsAvailable",
          "new_api": "GetKeyOrigin",
          "old_text": "EnsureWalletIsAvailable(pwallet, request.fHelp)",
          "new_text": "pwallet->GetKeyOrigin(keyID, info)",
          "old_line_content": "    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {",
          "new_line_content": "    if (!pwallet->GetKeyOrigin(keyID, info)) {",
          "content_same": false
        },
        {
          "line": 3969,
          "old_api": "HelpRequiringPassphrase",
          "new_api": "get",
          "old_text": "HelpRequiringPassphrase(pwallet)",
          "new_text": "wallet.get()",
          "old_line_content": "                    HelpRequiringPassphrase(pwallet) + \"\\n\",",
          "new_line_content": "    CWallet* const pwallet = wallet.get();",
          "content_same": false
        },
        {
          "line": 4011,
          "old_api": "FillPSBT",
          "new_api": "strprintf",
          "old_text": "FillPSBT(pwallet, psbtx, err, complete, nHashType, sign, bip32derivs)",
          "new_text": "strprintf(\"TX decode failed %s\", error)",
          "old_line_content": "    if (!FillPSBT(pwallet, psbtx, err, complete, nHashType, sign, bip32derivs)) {",
          "new_line_content": "        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));",
          "content_same": false
        },
        {
          "line": 4018,
          "old_api": "str",
          "new_api": "get_bool",
          "old_text": "ssTx.str()",
          "new_text": "request.params[1].get_bool()",
          "old_line_content": "    result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));",
          "new_line_content": "    bool sign = request.params[1].isNull() ? true : request.params[1].get_bool();",
          "content_same": false
        },
        {
          "line": 4019,
          "old_api": "pushKV",
          "new_api": "get_bool",
          "old_text": "result.pushKV(\"complete\", complete)",
          "new_text": "request.params[3].get_bool()",
          "old_line_content": "    result.pushKV(\"complete\", complete);",
          "new_line_content": "    bool bip32derivs = request.params[3].isNull() ? false : request.params[3].get_bool();",
          "content_same": false
        },
        {
          "line": 4029,
          "old_api": "EnsureWalletIsAvailable",
          "new_api": "str",
          "old_text": "EnsureWalletIsAvailable(pwallet, request.fHelp)",
          "new_text": "ssTx.str()",
          "old_line_content": "    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {",
          "new_line_content": "    result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));",
          "content_same": false
        },
        {
          "line": 4119,
          "old_api": "ConstructTransaction",
          "new_api": "RPCTypeCheck",
          "old_text": "ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3][\"replaceable\"])",
          "new_text": "RPCTypeCheck(request.params, {\n        UniValue::VARR,\n        UniValueType(), // ARR or OBJ, checked later\n        UniValue::VNUM,\n        UniValue::VOBJ,\n        UniValue::VBOOL\n        }, true\n    )",
          "old_line_content": "    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3][\"replaceable\"]);",
          "new_line_content": "    RPCTypeCheck(request.params, {",
          "content_same": false
        },
        {
          "line": 4130,
          "old_api": "JSONRPCTransactionError",
          "new_api": "ConstructTransaction",
          "old_text": "JSONRPCTransactionError(err)",
          "new_text": "ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3][\"replaceable\"])",
          "old_line_content": "        throw JSONRPCTransactionError(err);",
          "new_line_content": "    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3][\"replaceable\"]);",
          "content_same": false
        },
        {
          "line": 4140,
          "old_api": "pushKV",
          "new_api": "FillPSBT",
          "old_text": "result.pushKV(\"changepos\", change_position)",
          "new_text": "FillPSBT(pwallet, psbtx, err, complete, 1, false, bip32derivs)",
          "old_line_content": "    result.pushKV(\"changepos\", change_position);",
          "new_line_content": "    if (!FillPSBT(pwallet, psbtx, err, complete, 1, false, bip32derivs)) {",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 3968,
          "old_api": null,
          "new_api": "GetWalletForJSONRPCRequest",
          "old_text": null,
          "new_text": "GetWalletForJSONRPCRequest(request)",
          "old_line_content": "                \"that we can sign for.\" +",
          "new_line_content": "    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);",
          "content_same": false
        },
        {
          "line": 3841,
          "old_api": null,
          "new_api": "HelpExampleCli",
          "old_text": null,
          "new_text": "HelpExampleCli(\"listlabels\", \"\")",
          "old_line_content": "",
          "new_line_content": "            + HelpExampleCli(\"listlabels\", \"\") +",
          "content_same": false
        },
        {
          "line": 3971,
          "old_api": null,
          "new_api": "EnsureWalletIsAvailable",
          "old_text": null,
          "new_text": "EnsureWalletIsAvailable(pwallet, request.fHelp)",
          "old_line_content": "                    {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The transaction base64 string\"},",
          "new_line_content": "    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {",
          "content_same": false
        },
        {
          "line": 3845,
          "old_api": null,
          "new_api": "HelpExampleCli",
          "old_text": null,
          "new_text": "HelpExampleCli(\"listlabels\", \"send\")",
          "old_line_content": "    }",
          "new_line_content": "            + HelpExampleCli(\"listlabels\", \"send\") +",
          "content_same": false
        },
        {
          "line": 3847,
          "old_api": null,
          "new_api": "HelpExampleRpc",
          "old_text": null,
          "new_text": "HelpExampleRpc(\"listlabels\", \"receive\")",
          "old_line_content": "    // Add to a set to sort by label name, then insert into Univalue array",
          "new_line_content": "            + HelpExampleRpc(\"listlabels\", \"receive\")",
          "content_same": false
        },
        {
          "line": 3975,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "request.params.size()",
          "old_line_content": "            \"       \\\"NONE\\\"\\n\"",
          "new_line_content": "    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)",
          "content_same": false
        },
        {
          "line": 3976,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "std::runtime_error(\n            RPCHelpMan{\"walletprocesspsbt\",\n                \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n                \"that we can sign for.\" +\n                    HelpRequiringPassphrase(pwallet) + \"\\n\",\n                {\n                    {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The transaction base64 string\"},\n                    {\"sign\", RPCArg::Type::BOOL, /* default */ \"true\", \"Also sign the transaction when updating\"},\n                    {\"sighashtype\", RPCArg::Type::STR, /* default */ \"ALL\", \"The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n            \"       \\\"ALL\\\"\\n\"\n            \"       \\\"NONE\\\"\\n\"\n            \"       \\\"SINGLE\\\"\\n\"\n            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n            \"       \\\"SINGLE|ANYONECANPAY\\\"\"},\n                    {\"bip32derivs\", RPCArg::Type::BOOL, /* default */ \"false\", \"If true, includes the BIP 32 derivation paths for public keys if we know them\"},\n                },\n                RPCResult{\n            \"{\\n\"\n            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n            \"  ]\\n\"\n            \"}\\n\"\n                },\n                RPCExamples{\n                    HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")\n                },\n            }.ToString())",
          "old_line_content": "            \"       \\\"SINGLE\\\"\\n\"",
          "new_line_content": "        throw std::runtime_error(",
          "content_same": false
        },
        {
          "line": 3977,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "RPCHelpMan{\"walletprocesspsbt\",\n                \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n                \"that we can sign for.\" +\n                    HelpRequiringPassphrase(pwallet) + \"\\n\",\n                {\n                    {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The transaction base64 string\"},\n                    {\"sign\", RPCArg::Type::BOOL, /* default */ \"true\", \"Also sign the transaction when updating\"},\n                    {\"sighashtype\", RPCArg::Type::STR, /* default */ \"ALL\", \"The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n            \"       \\\"ALL\\\"\\n\"\n            \"       \\\"NONE\\\"\\n\"\n            \"       \\\"SINGLE\\\"\\n\"\n            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n            \"       \\\"SINGLE|ANYONECANPAY\\\"\"},\n                    {\"bip32derivs\", RPCArg::Type::BOOL, /* default */ \"false\", \"If true, includes the BIP 32 derivation paths for public keys if we know them\"},\n                },\n                RPCResult{\n            \"{\\n\"\n            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n            \"  ]\\n\"\n            \"}\\n\"\n                },\n                RPCExamples{\n                    HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")\n                },\n            }.ToString()",
          "old_line_content": "            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"",
          "new_line_content": "            RPCHelpMan{\"walletprocesspsbt\",",
          "content_same": false
        },
        {
          "line": 4231,
          "old_api": null,
          "new_api": "ARRAYLEN",
          "old_text": null,
          "new_text": "ARRAYLEN(commands)",
          "old_line_content": "",
          "new_line_content": "    for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); vcidx++)",
          "content_same": false
        },
        {
          "line": 3980,
          "old_api": null,
          "new_api": "HelpRequiringPassphrase",
          "old_text": null,
          "new_text": "HelpRequiringPassphrase(pwallet)",
          "old_line_content": "                    {\"bip32derivs\", RPCArg::Type::BOOL, /* default */ \"false\", \"If true, includes the BIP 32 derivation paths for public keys if we know them\"},",
          "new_line_content": "                    HelpRequiringPassphrase(pwallet) + \"\\n\",",
          "content_same": false
        },
        {
          "line": 4232,
          "old_api": null,
          "new_api": "appendCommand",
          "old_text": null,
          "new_text": "t.appendCommand(commands[vcidx].name, &commands[vcidx])",
          "old_line_content": "",
          "new_line_content": "        t.appendCommand(commands[vcidx].name, &commands[vcidx]);",
          "content_same": false
        },
        {
          "line": 3854,
          "old_api": null,
          "new_api": "isNull",
          "old_text": null,
          "new_text": "request.params[0].isNull()",
          "old_line_content": "",
          "new_line_content": "    if (!request.params[0].isNull()) {",
          "content_same": false
        },
        {
          "line": 3855,
          "old_api": null,
          "new_api": "get_str",
          "old_text": null,
          "new_text": "request.params[0].get_str()",
          "old_line_content": "    UniValue ret(UniValue::VARR);",
          "new_line_content": "        purpose = request.params[0].get_str();",
          "content_same": false
        },
        {
          "line": 4115,
          "old_api": null,
          "new_api": "HelpExampleCli",
          "old_text": null,
          "new_text": "HelpExampleCli(\"walletcreatefundedpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")",
          "old_line_content": "    );",
          "new_line_content": "                            + HelpExampleCli(\"walletcreatefundedpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")",
          "content_same": false
        },
        {
          "line": 3861,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "purpose.empty()",
          "old_line_content": "}",
          "new_line_content": "        if (purpose.empty() || entry.second.purpose == purpose) {",
          "content_same": false
        },
        {
          "line": 3862,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "label_set.insert(entry.second.name)",
          "old_line_content": "",
          "new_line_content": "            label_set.insert(entry.second.name);",
          "content_same": false
        },
        {
          "line": 4121,
          "old_api": null,
          "new_api": "UniValueType",
          "old_text": null,
          "new_text": "UniValueType()",
          "old_line_content": "",
          "new_line_content": "        UniValueType(), // ARR or OBJ, checked later",
          "content_same": false
        },
        {
          "line": 4001,
          "old_api": null,
          "new_api": "HelpExampleCli",
          "old_text": null,
          "new_text": "HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")",
          "old_line_content": "    }",
          "new_line_content": "                    HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")",
          "content_same": false
        },
        {
          "line": 4131,
          "old_api": null,
          "new_api": "FundTransaction",
          "old_text": null,
          "new_text": "FundTransaction(pwallet, rawTx, fee, change_position, request.params[3])",
          "old_line_content": "    }",
          "new_line_content": "    FundTransaction(pwallet, rawTx, fee, change_position, request.params[3]);",
          "content_same": false
        },
        {
          "line": 3876,
          "old_api": null,
          "new_api": "GetWalletForJSONRPCRequest",
          "old_text": null,
          "new_text": "GetWalletForJSONRPCRequest(request)",
          "old_line_content": "                \"HD will have a new HD seed set so that new keys added to the keypool will be derived from this new seed.\\n\"",
          "new_line_content": "    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);",
          "content_same": false
        },
        {
          "line": 3877,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "wallet.get()",
          "old_line_content": "                \"\\nNote that you will need to MAKE A NEW BACKUP of your wallet after setting the HD wallet seed.\" +",
          "new_line_content": "    CWallet* const pwallet = wallet.get();",
          "content_same": false
        },
        {
          "line": 4005,
          "old_api": null,
          "new_api": "RPCTypeCheck",
          "old_text": null,
          "new_text": "RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VSTR})",
          "old_line_content": "",
          "new_line_content": "    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VSTR});",
          "content_same": false
        },
        {
          "line": 3879,
          "old_api": null,
          "new_api": "EnsureWalletIsAvailable",
          "old_text": null,
          "new_text": "EnsureWalletIsAvailable(pwallet, request.fHelp)",
          "old_line_content": "                {",
          "new_line_content": "    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {",
          "content_same": false
        },
        {
          "line": 4137,
          "old_api": null,
          "new_api": "get_bool",
          "old_text": null,
          "new_text": "request.params[4].get_bool()",
          "old_line_content": "    UniValue result(UniValue::VOBJ);",
          "new_line_content": "    bool bip32derivs = request.params[4].isNull() ? false : request.params[4].get_bool();",
          "content_same": false
        },
        {
          "line": 4010,
          "old_api": null,
          "new_api": "get_str",
          "old_text": null,
          "new_text": "request.params[0].get_str()",
          "old_line_content": "    TransactionError err;",
          "new_line_content": "    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {",
          "content_same": false
        },
        {
          "line": 3883,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "request.params.size()",
          "old_line_content": "            \"                             keypool will be used until it has been depleted.\"},",
          "new_line_content": "    if (request.fHelp || request.params.size() > 2) {",
          "content_same": false
        },
        {
          "line": 3884,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "std::runtime_error(\n            RPCHelpMan{\"sethdseed\",\n                \"\\nSet or generate a new HD wallet seed. Non-HD wallets will not be upgraded to being a HD wallet. Wallets that are already\\n\"\n                \"HD will have a new HD seed set so that new keys added to the keypool will be derived from this new seed.\\n\"\n                \"\\nNote that you will need to MAKE A NEW BACKUP of your wallet after setting the HD wallet seed.\" +\n                    HelpRequiringPassphrase(pwallet) + \"\\n\",\n                {\n                    {\"newkeypool\", RPCArg::Type::BOOL, /* default */ \"true\", \"Whether to flush old unused addresses, including change addresses, from the keypool and regenerate it.\\n\"\n            \"                             If true, the next address from getnewaddress and change address from getrawchangeaddress will be from this new seed.\\n\"\n            \"                             If false, addresses (including change addresses if the wallet already had HD Chain Split enabled) from the existing\\n\"\n            \"                             keypool will be used until it has been depleted.\"},\n                    {\"seed\", RPCArg::Type::STR, /* default */ \"random seed\", \"The WIF private key to use as the new HD seed.\\n\"\n            \"                             The seed value can be retrieved using the dumpwallet command. It is the private key marked hdseed=1\"},\n                },\n                RPCResults{},\n                RPCExamples{\n                    HelpExampleCli(\"sethdseed\", \"\")\n            + HelpExampleCli(\"sethdseed\", \"false\")\n            + HelpExampleCli(\"sethdseed\", \"true \\\"wifkey\\\"\")\n            + HelpExampleRpc(\"sethdseed\", \"true, \\\"wifkey\\\"\")\n                },\n            }.ToString())",
          "old_line_content": "                    {\"seed\", RPCArg::Type::STR, /* default */ \"random seed\", \"The WIF private key to use as the new HD seed.\\n\"",
          "new_line_content": "        throw std::runtime_error(",
          "content_same": false
        },
        {
          "line": 3885,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "RPCHelpMan{\"sethdseed\",\n                \"\\nSet or generate a new HD wallet seed. Non-HD wallets will not be upgraded to being a HD wallet. Wallets that are already\\n\"\n                \"HD will have a new HD seed set so that new keys added to the keypool will be derived from this new seed.\\n\"\n                \"\\nNote that you will need to MAKE A NEW BACKUP of your wallet after setting the HD wallet seed.\" +\n                    HelpRequiringPassphrase(pwallet) + \"\\n\",\n                {\n                    {\"newkeypool\", RPCArg::Type::BOOL, /* default */ \"true\", \"Whether to flush old unused addresses, including change addresses, from the keypool and regenerate it.\\n\"\n            \"                             If true, the next address from getnewaddress and change address from getrawchangeaddress will be from this new seed.\\n\"\n            \"                             If false, addresses (including change addresses if the wallet already had HD Chain Split enabled) from the existing\\n\"\n            \"                             keypool will be used until it has been depleted.\"},\n                    {\"seed\", RPCArg::Type::STR, /* default */ \"random seed\", \"The WIF private key to use as the new HD seed.\\n\"\n            \"                             The seed value can be retrieved using the dumpwallet command. It is the private key marked hdseed=1\"},\n                },\n                RPCResults{},\n                RPCExamples{\n                    HelpExampleCli(\"sethdseed\", \"\")\n            + HelpExampleCli(\"sethdseed\", \"false\")\n            + HelpExampleCli(\"sethdseed\", \"true \\\"wifkey\\\"\")\n            + HelpExampleRpc(\"sethdseed\", \"true, \\\"wifkey\\\"\")\n                },\n            }.ToString()",
          "old_line_content": "            \"                             The seed value can be retrieved using the dumpwallet command. It is the private key marked hdseed=1\"},",
          "new_line_content": "            RPCHelpMan{\"sethdseed\",",
          "content_same": false
        },
        {
          "line": 4141,
          "old_api": null,
          "new_api": "JSONRPCTransactionError",
          "old_text": null,
          "new_text": "JSONRPCTransactionError(err)",
          "old_line_content": "    return result;",
          "new_line_content": "        throw JSONRPCTransactionError(err);",
          "content_same": false
        },
        {
          "line": 4015,
          "old_api": null,
          "new_api": "ParseSighashString",
          "old_text": null,
          "new_text": "ParseSighashString(request.params[2])",
          "old_line_content": "    UniValue result(UniValue::VOBJ);",
          "new_line_content": "    int nHashType = ParseSighashString(request.params[2]);",
          "content_same": false
        },
        {
          "line": 4149,
          "old_api": null,
          "new_api": "str",
          "old_text": null,
          "new_text": "ssTx.str()",
          "old_line_content": "UniValue dumpwallet(const JSONRPCRequest& request);",
          "new_line_content": "    result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));",
          "content_same": false
        },
        {
          "line": 4022,
          "old_api": null,
          "new_api": "FillPSBT",
          "old_text": null,
          "new_text": "FillPSBT(pwallet, psbtx, err, complete, nHashType, sign, bip32derivs)",
          "old_line_content": "}",
          "new_line_content": "    if (!FillPSBT(pwallet, psbtx, err, complete, nHashType, sign, bip32derivs)) {",
          "content_same": false
        },
        {
          "line": 4023,
          "old_api": null,
          "new_api": "JSONRPCTransactionError",
          "old_text": null,
          "new_text": "JSONRPCTransactionError(err)",
          "old_line_content": "",
          "new_line_content": "        throw JSONRPCTransactionError(err);",
          "content_same": false
        },
        {
          "line": 4150,
          "old_api": null,
          "new_api": "ValueFromAmount",
          "old_text": null,
          "new_text": "ValueFromAmount(fee)",
          "old_line_content": "UniValue importwallet(const JSONRPCRequest& request);",
          "new_line_content": "    result.pushKV(\"fee\", ValueFromAmount(fee));",
          "content_same": false
        },
        {
          "line": 4151,
          "old_api": null,
          "new_api": "pushKV",
          "old_text": null,
          "new_text": "result.pushKV(\"changepos\", change_position)",
          "old_line_content": "UniValue importprunedfunds(const JSONRPCRequest& request);",
          "new_line_content": "    result.pushKV(\"changepos\", change_position);",
          "content_same": false
        },
        {
          "line": 3900,
          "old_api": null,
          "new_api": "HelpExampleCli",
          "old_text": null,
          "new_text": "HelpExampleCli(\"sethdseed\", \"\")",
          "old_line_content": "",
          "new_line_content": "                    HelpExampleCli(\"sethdseed\", \"\")",
          "content_same": false
        },
        {
          "line": 4030,
          "old_api": null,
          "new_api": "pushKV",
          "old_text": null,
          "new_text": "result.pushKV(\"complete\", complete)",
          "old_line_content": "        return NullUniValue;",
          "new_line_content": "    result.pushKV(\"complete\", complete);",
          "content_same": false
        },
        {
          "line": 3903,
          "old_api": null,
          "new_api": "HelpExampleRpc",
          "old_text": null,
          "new_text": "HelpExampleRpc(\"sethdseed\", \"true, \\\"wifkey\\\"\")",
          "old_line_content": "    }",
          "new_line_content": "            + HelpExampleRpc(\"sethdseed\", \"true, \\\"wifkey\\\"\")",
          "content_same": false
        },
        {
          "line": 3908,
          "old_api": null,
          "new_api": "IsInitialBlockDownload",
          "old_text": null,
          "new_text": "IsInitialBlockDownload()",
          "old_line_content": "    // Do not do anything to non-HD wallets",
          "new_line_content": "    if (IsInitialBlockDownload()) {",
          "content_same": false
        },
        {
          "line": 4037,
          "old_api": null,
          "new_api": "GetWalletForJSONRPCRequest",
          "old_text": null,
          "new_text": "GetWalletForJSONRPCRequest(request)",
          "old_line_content": "                \"Implements the Creator and Updater roles.\\n\",",
          "new_line_content": "    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);",
          "content_same": false
        },
        {
          "line": 4038,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "wallet.get()",
          "old_line_content": "                {",
          "new_line_content": "    CWallet* const pwallet = wallet.get();",
          "content_same": false
        },
        {
          "line": 3912,
          "old_api": null,
          "new_api": "IsWalletFlagSet",
          "old_text": null,
          "new_text": "pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)",
          "old_line_content": "",
          "new_line_content": "    if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {",
          "content_same": false
        },
        {
          "line": 4040,
          "old_api": null,
          "new_api": "EnsureWalletIsAvailable",
          "old_text": null,
          "new_text": "EnsureWalletIsAvailable(pwallet, request.fHelp)",
          "old_line_content": "                        {",
          "new_line_content": "    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {",
          "content_same": false
        },
        {
          "line": 4044,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "request.params.size()",
          "old_line_content": "                                    {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},",
          "new_line_content": "    if (request.fHelp || request.params.size() < 2 || request.params.size() > 5)",
          "content_same": false
        },
        {
          "line": 4045,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "std::runtime_error(\n            RPCHelpMan{\"walletcreatefundedpsbt\",\n                \"\\nCreates and funds a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n                \"Implements the Creator and Updater roles.\\n\",\n                {\n                    {\"inputs\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"A json array of json objects\",\n                        {\n                            {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"\",\n                                {\n                                    {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n                                    {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n                                    {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n                                },\n                            },\n                        },\n                        },\n                    {\"outputs\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"a json array with outputs (key-value pairs), where none of the keys are duplicated.\\n\"\n                            \"That is, each address can only appear once and there can only be one 'data' object.\\n\"\n                            \"For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n                            \"                             accepted as second parameter.\",\n                        {\n                            {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"\",\n                                {\n                                    {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n                                },\n                                },\n                            {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"\",\n                                {\n                                    {\"data\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"A key-value pair. The key must be \\\"data\\\", the value is hex-encoded data\"},\n                                },\n                            },\n                        },\n                    },\n                    {\"locktime\", RPCArg::Type::NUM, /* default */ \"0\", \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n                    {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n                        {\n                            {\"changeAddress\", RPCArg::Type::STR_HEX, /* default */ \"pool address\", \"The bitcoin address to receive the change\"},\n                            {\"changePosition\", RPCArg::Type::NUM, /* default */ \"random\", \"The index of the change output\"},\n                            {\"change_type\", RPCArg::Type::STR, /* default */ \"set by -changetype\", \"The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n                            {\"includeWatching\", RPCArg::Type::BOOL, /* default */ \"false\", \"Also select inputs which are watch only\"},\n                            {\"lockUnspents\", RPCArg::Type::BOOL, /* default */ \"false\", \"Lock selected unspent outputs\"},\n                            {\"feeRate\", RPCArg::Type::AMOUNT, /* default */ \"not set: makes wallet determine the fee\", \"Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\"},\n                            {\"subtractFeeFromOutputs\", RPCArg::Type::ARR, /* default */ \"empty array\", \"A json array of integers.\\n\"\n                            \"                              The fee will be equally deducted from the amount of each specified output.\\n\"\n                            \"                              Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n                            \"                              If no outputs are specified here, the sender pays the fee.\",\n                                {\n                                    {\"vout_index\", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, \"The zero-based output index, before a change output is added.\"},\n                                },\n                            },\n                            {\"replaceable\", RPCArg::Type::BOOL, /* default */ \"false\", \"Marks this transaction as BIP125 replaceable.\\n\"\n                            \"                              Allows this transaction to be replaced by a transaction with higher fees\"},\n                            {\"conf_target\", RPCArg::Type::NUM, /* default */ \"Fallback to wallet's confirmation target\", \"Confirmation target (in blocks)\"},\n                            {\"estimate_mode\", RPCArg::Type::STR, /* default */ \"UNSET\", \"The fee estimate mode, must be one of:\\n\"\n                            \"         \\\"UNSET\\\"\\n\"\n                            \"         \\\"ECONOMICAL\\\"\\n\"\n                            \"         \\\"CONSERVATIVE\\\"\"},\n                        },\n                        \"options\"},\n                    {\"bip32derivs\", RPCArg::Type::BOOL, /* default */ \"false\", \"If true, includes the BIP 32 derivation paths for public keys if we know them\"},\n                },\n                RPCResult{\n                            \"{\\n\"\n                            \"  \\\"psbt\\\": \\\"value\\\",        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n                            \"  \\\"fee\\\":       n,         (numeric) Fee in \" + CURRENCY_UNIT + \" the resulting transaction pays\\n\"\n                            \"  \\\"changepos\\\": n          (numeric) The position of the added change output, or -1\\n\"\n                            \"}\\n\"\n                                },\n                                RPCExamples{\n                            \"\\nCreate a transaction with no inputs\\n\"\n                            + HelpExampleCli(\"walletcreatefundedpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n                                },\n                            }.ToString())",
          "old_line_content": "                                    {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},",
          "new_line_content": "        throw std::runtime_error(",
          "content_same": false
        },
        {
          "line": 4046,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "RPCHelpMan{\"walletcreatefundedpsbt\",\n                \"\\nCreates and funds a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n                \"Implements the Creator and Updater roles.\\n\",\n                {\n                    {\"inputs\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"A json array of json objects\",\n                        {\n                            {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"\",\n                                {\n                                    {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n                                    {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n                                    {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n                                },\n                            },\n                        },\n                        },\n                    {\"outputs\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"a json array with outputs (key-value pairs), where none of the keys are duplicated.\\n\"\n                            \"That is, each address can only appear once and there can only be one 'data' object.\\n\"\n                            \"For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n                            \"                             accepted as second parameter.\",\n                        {\n                            {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"\",\n                                {\n                                    {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n                                },\n                                },\n                            {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"\",\n                                {\n                                    {\"data\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"A key-value pair. The key must be \\\"data\\\", the value is hex-encoded data\"},\n                                },\n                            },\n                        },\n                    },\n                    {\"locktime\", RPCArg::Type::NUM, /* default */ \"0\", \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n                    {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n                        {\n                            {\"changeAddress\", RPCArg::Type::STR_HEX, /* default */ \"pool address\", \"The bitcoin address to receive the change\"},\n                            {\"changePosition\", RPCArg::Type::NUM, /* default */ \"random\", \"The index of the change output\"},\n                            {\"change_type\", RPCArg::Type::STR, /* default */ \"set by -changetype\", \"The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n                            {\"includeWatching\", RPCArg::Type::BOOL, /* default */ \"false\", \"Also select inputs which are watch only\"},\n                            {\"lockUnspents\", RPCArg::Type::BOOL, /* default */ \"false\", \"Lock selected unspent outputs\"},\n                            {\"feeRate\", RPCArg::Type::AMOUNT, /* default */ \"not set: makes wallet determine the fee\", \"Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\"},\n                            {\"subtractFeeFromOutputs\", RPCArg::Type::ARR, /* default */ \"empty array\", \"A json array of integers.\\n\"\n                            \"                              The fee will be equally deducted from the amount of each specified output.\\n\"\n                            \"                              Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n                            \"                              If no outputs are specified here, the sender pays the fee.\",\n                                {\n                                    {\"vout_index\", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, \"The zero-based output index, before a change output is added.\"},\n                                },\n                            },\n                            {\"replaceable\", RPCArg::Type::BOOL, /* default */ \"false\", \"Marks this transaction as BIP125 replaceable.\\n\"\n                            \"                              Allows this transaction to be replaced by a transaction with higher fees\"},\n                            {\"conf_target\", RPCArg::Type::NUM, /* default */ \"Fallback to wallet's confirmation target\", \"Confirmation target (in blocks)\"},\n                            {\"estimate_mode\", RPCArg::Type::STR, /* default */ \"UNSET\", \"The fee estimate mode, must be one of:\\n\"\n                            \"         \\\"UNSET\\\"\\n\"\n                            \"         \\\"ECONOMICAL\\\"\\n\"\n                            \"         \\\"CONSERVATIVE\\\"\"},\n                        },\n                        \"options\"},\n                    {\"bip32derivs\", RPCArg::Type::BOOL, /* default */ \"false\", \"If true, includes the BIP 32 derivation paths for public keys if we know them\"},\n                },\n                RPCResult{\n                            \"{\\n\"\n                            \"  \\\"psbt\\\": \\\"value\\\",        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n                            \"  \\\"fee\\\":       n,         (numeric) Fee in \" + CURRENCY_UNIT + \" the resulting transaction pays\\n\"\n                            \"  \\\"changepos\\\": n          (numeric) The position of the added change output, or -1\\n\"\n                            \"}\\n\"\n                                },\n                                RPCExamples{\n                            \"\\nCreate a transaction with no inputs\\n\"\n                            + HelpExampleCli(\"walletcreatefundedpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n                                },\n                            }.ToString()",
          "old_line_content": "                                },",
          "new_line_content": "            RPCHelpMan{\"walletcreatefundedpsbt\",",
          "content_same": false
        },
        {
          "line": 3920,
          "old_api": null,
          "new_api": "CanSupportFeature",
          "old_text": null,
          "new_text": "pwallet->CanSupportFeature(FEATURE_HD)",
          "old_line_content": "    CPubKey master_pub_key;",
          "new_line_content": "    if (!pwallet->CanSupportFeature(FEATURE_HD)) {",
          "content_same": false
        },
        {
          "line": 3796,
          "old_api": null,
          "new_api": "EncodeDestination",
          "old_text": null,
          "new_text": "EncodeDestination(item.first)",
          "old_line_content": "        }",
          "new_line_content": "            std::string address = EncodeDestination(item.first);",
          "content_same": false
        },
        {
          "line": 3927,
          "old_api": null,
          "new_api": "isNull",
          "old_text": null,
          "new_text": "request.params[0].isNull()",
          "old_line_content": "        }",
          "new_line_content": "    if (!request.params[0].isNull()) {",
          "content_same": false
        },
        {
          "line": 3928,
          "old_api": null,
          "new_api": "get_bool",
          "old_text": null,
          "new_text": "request.params[0].get_bool()",
          "old_line_content": "",
          "new_line_content": "        flush_key_pool = request.params[0].get_bool();",
          "content_same": false
        },
        {
          "line": 3801,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(unique)",
          "old_line_content": "    }",
          "new_line_content": "            assert(unique);",
          "content_same": false
        },
        {
          "line": 3932,
          "old_api": null,
          "new_api": "isNull",
          "old_text": null,
          "new_text": "request.params[1].isNull()",
          "old_line_content": "",
          "new_line_content": "    if (request.params[1].isNull()) {",
          "content_same": false
        },
        {
          "line": 3806,
          "old_api": null,
          "new_api": "AddressBookDataToJSON",
          "old_text": null,
          "new_text": "AddressBookDataToJSON(item.second, false)",
          "old_line_content": "static UniValue listlabels(const JSONRPCRequest& request)",
          "new_line_content": "            ret.__pushKV(address, AddressBookDataToJSON(item.second, false));",
          "content_same": false
        },
        {
          "line": 3935,
          "old_api": null,
          "new_api": "get_str",
          "old_text": null,
          "new_text": "request.params[1].get_str()",
          "old_line_content": "",
          "new_line_content": "        CKey key = DecodeSecret(request.params[1].get_str());",
          "content_same": false
        },
        {
          "line": 3810,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "ret.empty()",
          "old_line_content": "",
          "new_line_content": "    if (ret.empty()) {",
          "content_same": false
        },
        {
          "line": 3940,
          "old_api": null,
          "new_api": "HaveKey",
          "old_text": null,
          "new_text": "HaveKey(*pwallet, key)",
          "old_line_content": "}",
          "new_line_content": "        if (HaveKey(*pwallet, key)) {",
          "content_same": false
        },
        {
          "line": 3941,
          "old_api": null,
          "new_api": "JSONRPCError",
          "old_text": null,
          "new_text": "JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key (either as an HD seed or as a loose private key)\")",
          "old_line_content": "",
          "new_line_content": "            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key (either as an HD seed or as a loose private key)\");",
          "content_same": false
        },
        {
          "line": 3944,
          "old_api": null,
          "new_api": "DeriveNewSeed",
          "old_text": null,
          "new_text": "pwallet->DeriveNewSeed(key)",
          "old_line_content": "    CPubKey vchPubKey;",
          "new_line_content": "        master_pub_key = pwallet->DeriveNewSeed(key);",
          "content_same": false
        },
        {
          "line": 3819,
          "old_api": null,
          "new_api": "GetWalletForJSONRPCRequest",
          "old_text": null,
          "new_text": "GetWalletForJSONRPCRequest(request)",
          "old_line_content": "                {",
          "new_line_content": "    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);",
          "content_same": false
        },
        {
          "line": 3820,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "wallet.get()",
          "old_line_content": "                    {\"purpose\", RPCArg::Type::STR, RPCArg::Optional::OMITTED_NAMED_ARG, \"Address purpose to list labels for ('send','receive'). An empty string is the same as not providing this argument.\"},",
          "new_line_content": "    CWallet* const pwallet = wallet.get();",
          "content_same": false
        },
        {
          "line": 3947,
          "old_api": null,
          "new_api": "SetHDSeed",
          "old_text": null,
          "new_text": "pwallet->SetHDSeed(master_pub_key)",
          "old_line_content": "    }",
          "new_line_content": "    pwallet->SetHDSeed(master_pub_key);",
          "content_same": false
        },
        {
          "line": 3822,
          "old_api": null,
          "new_api": "EnsureWalletIsAvailable",
          "old_text": null,
          "new_text": "EnsureWalletIsAvailable(pwallet, request.fHelp)",
          "old_line_content": "                RPCResult{",
          "new_line_content": "    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {",
          "content_same": false
        },
        {
          "line": 3948,
          "old_api": null,
          "new_api": "NewKeyPool",
          "old_text": null,
          "new_text": "pwallet->NewKeyPool()",
          "old_line_content": "    KeyOriginInfo info;",
          "new_line_content": "    if (flush_key_pool) pwallet->NewKeyPool();",
          "content_same": false
        },
        {
          "line": 3826,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "request.params.size()",
          "old_line_content": "            \"]\\n\"",
          "new_line_content": "    if (request.fHelp || request.params.size() > 1)",
          "content_same": false
        },
        {
          "line": 3827,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "std::runtime_error(\n            RPCHelpMan{\"listlabels\",\n                \"\\nReturns the list of all labels, or labels that are assigned to addresses with a specific purpose.\\n\",\n                {\n                    {\"purpose\", RPCArg::Type::STR, RPCArg::Optional::OMITTED_NAMED_ARG, \"Address purpose to list labels for ('send','receive'). An empty string is the same as not providing this argument.\"},\n                },\n                RPCResult{\n            \"[               (json array of string)\\n\"\n            \"  \\\"label\\\",      (string) Label name\\n\"\n            \"  ...\\n\"\n            \"]\\n\"\n                },\n                RPCExamples{\n            \"\\nList all labels\\n\"\n            + HelpExampleCli(\"listlabels\", \"\") +\n            \"\\nList labels that have receiving addresses\\n\"\n            + HelpExampleCli(\"listlabels\", \"receive\") +\n            \"\\nList labels that have sending addresses\\n\"\n            + HelpExampleCli(\"listlabels\", \"send\") +\n            \"\\nAs a JSON-RPC call\\n\"\n            + HelpExampleRpc(\"listlabels\", \"receive\")\n                },\n            }.ToString())",
          "old_line_content": "                },",
          "new_line_content": "        throw std::runtime_error(",
          "content_same": false
        },
        {
          "line": 3828,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "RPCHelpMan{\"listlabels\",\n                \"\\nReturns the list of all labels, or labels that are assigned to addresses with a specific purpose.\\n\",\n                {\n                    {\"purpose\", RPCArg::Type::STR, RPCArg::Optional::OMITTED_NAMED_ARG, \"Address purpose to list labels for ('send','receive'). An empty string is the same as not providing this argument.\"},\n                },\n                RPCResult{\n            \"[               (json array of string)\\n\"\n            \"  \\\"label\\\",      (string) Label name\\n\"\n            \"  ...\\n\"\n            \"]\\n\"\n                },\n                RPCExamples{\n            \"\\nList all labels\\n\"\n            + HelpExampleCli(\"listlabels\", \"\") +\n            \"\\nList labels that have receiving addresses\\n\"\n            + HelpExampleCli(\"listlabels\", \"receive\") +\n            \"\\nList labels that have sending addresses\\n\"\n            + HelpExampleCli(\"listlabels\", \"send\") +\n            \"\\nAs a JSON-RPC call\\n\"\n            + HelpExampleRpc(\"listlabels\", \"receive\")\n                },\n            }.ToString()",
          "old_line_content": "                RPCExamples{",
          "new_line_content": "            RPCHelpMan{\"listlabels\",",
          "content_same": false
        },
        {
          "line": 3956,
          "old_api": null,
          "new_api": "GetPubKey",
          "old_text": null,
          "new_text": "pwallet->GetPubKey(keyID, vchPubKey)",
          "old_line_content": "{",
          "new_line_content": "    if (!pwallet->GetPubKey(keyID, vchPubKey)) {",
          "content_same": false
        },
        {
          "line": 3961,
          "old_api": null,
          "new_api": "JSONRPCError",
          "old_text": null,
          "new_text": "JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\")",
          "old_line_content": "        return NullUniValue;",
          "new_line_content": "        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");",
          "content_same": false
        },
        {
          "line": 3963,
          "old_api": null,
          "new_api": "std::move(info)",
          "old_text": null,
          "new_text": "std::move(info)",
          "old_line_content": "",
          "new_line_content": "    hd_keypaths.emplace(vchPubKey, std::move(info));",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 3840,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pwallet->cs_wallet)",
          "new_text": null,
          "old_line_content": "    LOCK(pwallet->cs_wallet);",
          "new_line_content": "            \"\\nList all labels\\n\"",
          "content_same": false
        },
        {
          "line": 3844,
          "old_api": "get_str",
          "new_api": null,
          "old_text": "request.params[0].get_str()",
          "new_text": null,
          "old_line_content": "        purpose = request.params[0].get_str();",
          "new_line_content": "            \"\\nList labels that have sending addresses\\n\"",
          "content_same": false
        },
        {
          "line": 4104,
          "old_api": "HelpExampleCli",
          "new_api": null,
          "old_text": "HelpExampleCli(\"walletcreatefundedpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")",
          "new_text": null,
          "old_line_content": "                            + HelpExampleCli(\"walletcreatefundedpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")",
          "new_line_content": "                    {\"bip32derivs\", RPCArg::Type::BOOL, /* default */ \"false\", \"If true, includes the BIP 32 derivation paths for public keys if we know them\"},",
          "content_same": false
        },
        {
          "line": 3850,
          "old_api": "empty",
          "new_api": null,
          "old_text": "purpose.empty()",
          "new_text": null,
          "old_line_content": "        if (purpose.empty() || entry.second.purpose == purpose) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4108,
          "old_api": "RPCTypeCheck",
          "new_api": null,
          "old_text": "RPCTypeCheck(request.params, {\n        UniValue::VARR,\n        UniValueType(), // ARR or OBJ, checked later\n        UniValue::VNUM,\n        UniValue::VOBJ,\n        UniValue::VBOOL\n        }, true\n    )",
          "new_text": null,
          "old_line_content": "    RPCTypeCheck(request.params, {",
          "new_line_content": "                            \"  \\\"psbt\\\": \\\"value\\\",        (string)  The resulting raw transaction (base64-encoded string)\\n\"",
          "content_same": false
        },
        {
          "line": 4110,
          "old_api": "UniValueType",
          "new_api": null,
          "old_text": "UniValueType()",
          "new_text": null,
          "old_line_content": "        UniValueType(), // ARR or OBJ, checked later",
          "new_line_content": "                            \"  \\\"changepos\\\": n          (numeric) The position of the added change output, or -1\\n\"",
          "content_same": false
        },
        {
          "line": 3857,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "ret.push_back(name)",
          "new_text": null,
          "old_line_content": "        ret.push_back(name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3990,
          "old_api": "HelpExampleCli",
          "new_api": null,
          "old_text": "HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")",
          "new_text": null,
          "old_line_content": "                    HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")",
          "new_line_content": "            \"       \\\"SINGLE|ANYONECANPAY\\\"\"},",
          "content_same": false
        },
        {
          "line": 4120,
          "old_api": "FundTransaction",
          "new_api": null,
          "old_text": "FundTransaction(pwallet, rawTx, fee, change_position, request.params[3])",
          "new_text": null,
          "old_line_content": "    FundTransaction(pwallet, rawTx, fee, change_position, request.params[3]);",
          "new_line_content": "        UniValue::VARR,",
          "content_same": false
        },
        {
          "line": 3865,
          "old_api": "GetWalletForJSONRPCRequest",
          "new_api": null,
          "old_text": "GetWalletForJSONRPCRequest(request)",
          "new_text": null,
          "old_line_content": "    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3866,
          "old_api": "get",
          "new_api": null,
          "old_text": "wallet.get()",
          "new_text": null,
          "old_line_content": "    CWallet* const pwallet = wallet.get();",
          "new_line_content": "    UniValue ret(UniValue::VARR);",
          "content_same": false
        },
        {
          "line": 3994,
          "old_api": "RPCTypeCheck",
          "new_api": null,
          "old_text": "RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VSTR})",
          "new_text": null,
          "old_line_content": "    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VSTR});",
          "new_line_content": "            \"{\\n\"",
          "content_same": false
        },
        {
          "line": 4126,
          "old_api": "get_bool",
          "new_api": null,
          "old_text": "request.params[4].get_bool()",
          "new_text": null,
          "old_line_content": "    bool bip32derivs = request.params[4].isNull() ? false : request.params[4].get_bool();",
          "new_line_content": "    );",
          "content_same": false
        },
        {
          "line": 3999,
          "old_api": "get_str",
          "new_api": null,
          "old_text": "request.params[0].get_str()",
          "new_text": null,
          "old_line_content": "    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {",
          "new_line_content": "                },",
          "content_same": false
        },
        {
          "line": 3872,
          "old_api": "size",
          "new_api": null,
          "old_text": "request.params.size()",
          "new_text": null,
          "old_line_content": "    if (request.fHelp || request.params.size() > 2) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3873,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "std::runtime_error(\n            RPCHelpMan{\"sethdseed\",\n                \"\\nSet or generate a new HD wallet seed. Non-HD wallets will not be upgraded to being a HD wallet. Wallets that are already\\n\"\n                \"HD will have a new HD seed set so that new keys added to the keypool will be derived from this new seed.\\n\"\n                \"\\nNote that you will need to MAKE A NEW BACKUP of your wallet after setting the HD wallet seed.\" +\n                    HelpRequiringPassphrase(pwallet) + \"\\n\",\n                {\n                    {\"newkeypool\", RPCArg::Type::BOOL, /* default */ \"true\", \"Whether to flush old unused addresses, including change addresses, from the keypool and regenerate it.\\n\"\n            \"                             If true, the next address from getnewaddress and change address from getrawchangeaddress will be from this new seed.\\n\"\n            \"                             If false, addresses (including change addresses if the wallet already had HD Chain Split enabled) from the existing\\n\"\n            \"                             keypool will be used until it has been depleted.\"},\n                    {\"seed\", RPCArg::Type::STR, /* default */ \"random seed\", \"The WIF private key to use as the new HD seed.\\n\"\n            \"                             The seed value can be retrieved using the dumpwallet command. It is the private key marked hdseed=1\"},\n                },\n                RPCResults{},\n                RPCExamples{\n                    HelpExampleCli(\"sethdseed\", \"\")\n            + HelpExampleCli(\"sethdseed\", \"false\")\n            + HelpExampleCli(\"sethdseed\", \"true \\\"wifkey\\\"\")\n            + HelpExampleRpc(\"sethdseed\", \"true, \\\"wifkey\\\"\")\n                },\n            }.ToString())",
          "new_text": null,
          "old_line_content": "        throw std::runtime_error(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3874,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "RPCHelpMan{\"sethdseed\",\n                \"\\nSet or generate a new HD wallet seed. Non-HD wallets will not be upgraded to being a HD wallet. Wallets that are already\\n\"\n                \"HD will have a new HD seed set so that new keys added to the keypool will be derived from this new seed.\\n\"\n                \"\\nNote that you will need to MAKE A NEW BACKUP of your wallet after setting the HD wallet seed.\" +\n                    HelpRequiringPassphrase(pwallet) + \"\\n\",\n                {\n                    {\"newkeypool\", RPCArg::Type::BOOL, /* default */ \"true\", \"Whether to flush old unused addresses, including change addresses, from the keypool and regenerate it.\\n\"\n            \"                             If true, the next address from getnewaddress and change address from getrawchangeaddress will be from this new seed.\\n\"\n            \"                             If false, addresses (including change addresses if the wallet already had HD Chain Split enabled) from the existing\\n\"\n            \"                             keypool will be used until it has been depleted.\"},\n                    {\"seed\", RPCArg::Type::STR, /* default */ \"random seed\", \"The WIF private key to use as the new HD seed.\\n\"\n            \"                             The seed value can be retrieved using the dumpwallet command. It is the private key marked hdseed=1\"},\n                },\n                RPCResults{},\n                RPCExamples{\n                    HelpExampleCli(\"sethdseed\", \"\")\n            + HelpExampleCli(\"sethdseed\", \"false\")\n            + HelpExampleCli(\"sethdseed\", \"true \\\"wifkey\\\"\")\n            + HelpExampleRpc(\"sethdseed\", \"true, \\\"wifkey\\\"\")\n                },\n            }.ToString()",
          "new_text": null,
          "old_line_content": "            RPCHelpMan{\"sethdseed\",",
          "new_line_content": "UniValue sethdseed(const JSONRPCRequest& request)",
          "content_same": false
        },
        {
          "line": 4000,
          "old_api": "strprintf",
          "new_api": null,
          "old_text": "strprintf(\"TX decode failed %s\", error)",
          "new_text": null,
          "old_line_content": "        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));",
          "new_line_content": "                RPCExamples{",
          "content_same": false
        },
        {
          "line": 4004,
          "old_api": "ParseSighashString",
          "new_api": null,
          "old_text": "ParseSighashString(request.params[2])",
          "new_text": null,
          "old_line_content": "    int nHashType = ParseSighashString(request.params[2]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4129,
          "old_api": "FillPSBT",
          "new_api": null,
          "old_text": "FillPSBT(pwallet, psbtx, err, complete, 1, false, bip32derivs)",
          "new_text": null,
          "old_line_content": "    if (!FillPSBT(pwallet, psbtx, err, complete, 1, false, bip32derivs)) {",
          "new_line_content": "    int change_position;",
          "content_same": false
        },
        {
          "line": 3878,
          "old_api": "HelpRequiringPassphrase",
          "new_api": null,
          "old_text": "HelpRequiringPassphrase(pwallet)",
          "new_text": null,
          "old_line_content": "                    HelpRequiringPassphrase(pwallet) + \"\\n\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4007,
          "old_api": "get_bool",
          "new_api": null,
          "old_text": "request.params[1].get_bool()",
          "new_text": null,
          "old_line_content": "    bool sign = request.params[1].isNull() ? true : request.params[1].get_bool();",
          "new_line_content": "    // Unserialize the transaction",
          "content_same": false
        },
        {
          "line": 4008,
          "old_api": "get_bool",
          "new_api": null,
          "old_text": "request.params[3].get_bool()",
          "new_text": null,
          "old_line_content": "    bool bip32derivs = request.params[3].isNull() ? false : request.params[3].get_bool();",
          "new_line_content": "    PartiallySignedTransaction psbtx;",
          "content_same": false
        },
        {
          "line": 4138,
          "old_api": "str",
          "new_api": null,
          "old_text": "ssTx.str()",
          "new_text": null,
          "old_line_content": "    result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));",
          "new_line_content": "    bool complete = true;",
          "content_same": false
        },
        {
          "line": 4139,
          "old_api": "ValueFromAmount",
          "new_api": null,
          "old_text": "ValueFromAmount(fee)",
          "new_text": null,
          "old_line_content": "    result.pushKV(\"fee\", ValueFromAmount(fee));",
          "new_line_content": "    TransactionError err;",
          "content_same": false
        },
        {
          "line": 4012,
          "old_api": "JSONRPCTransactionError",
          "new_api": null,
          "old_text": "JSONRPCTransactionError(err)",
          "new_text": null,
          "old_line_content": "        throw JSONRPCTransactionError(err);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3890,
          "old_api": "HelpExampleCli",
          "new_api": null,
          "old_text": "HelpExampleCli(\"sethdseed\", \"false\")",
          "new_text": null,
          "old_line_content": "            + HelpExampleCli(\"sethdseed\", \"false\")",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 3891,
          "old_api": "HelpExampleCli",
          "new_api": null,
          "old_text": "HelpExampleCli(\"sethdseed\", \"true \\\"wifkey\\\"\")",
          "new_text": null,
          "old_line_content": "            + HelpExampleCli(\"sethdseed\", \"true \\\"wifkey\\\"\")",
          "new_line_content": "                    {\"newkeypool\", RPCArg::Type::BOOL, /* default */ \"true\", \"Whether to flush old unused addresses, including change addresses, from the keypool and regenerate it.\\n\"",
          "content_same": false
        },
        {
          "line": 3892,
          "old_api": "HelpExampleRpc",
          "new_api": null,
          "old_text": "HelpExampleRpc(\"sethdseed\", \"true, \\\"wifkey\\\"\")",
          "new_text": null,
          "old_line_content": "            + HelpExampleRpc(\"sethdseed\", \"true, \\\"wifkey\\\"\")",
          "new_line_content": "            \"                             If true, the next address from getnewaddress and change address from getrawchangeaddress will be from this new seed.\\n\"",
          "content_same": false
        },
        {
          "line": 3897,
          "old_api": "IsInitialBlockDownload",
          "new_api": null,
          "old_text": "IsInitialBlockDownload()",
          "new_text": null,
          "old_line_content": "    if (IsInitialBlockDownload()) {",
          "new_line_content": "                },",
          "content_same": false
        },
        {
          "line": 3898,
          "old_api": "JSONRPCError",
          "new_api": null,
          "old_text": "JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, \"Cannot set a new HD seed while still in Initial Block Download\")",
          "new_text": null,
          "old_line_content": "        throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, \"Cannot set a new HD seed while still in Initial Block Download\");",
          "new_line_content": "                RPCResults{},",
          "content_same": false
        },
        {
          "line": 4026,
          "old_api": "GetWalletForJSONRPCRequest",
          "new_api": null,
          "old_text": "GetWalletForJSONRPCRequest(request)",
          "new_text": null,
          "old_line_content": "    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);",
          "new_line_content": "    UniValue result(UniValue::VOBJ);",
          "content_same": false
        },
        {
          "line": 4027,
          "old_api": "get",
          "new_api": null,
          "old_text": "wallet.get()",
          "new_text": null,
          "old_line_content": "    CWallet* const pwallet = wallet.get();",
          "new_line_content": "    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);",
          "content_same": false
        },
        {
          "line": 3905,
          "old_api": "lock",
          "new_api": null,
          "old_text": "pwallet->chain().lock()",
          "new_text": null,
          "old_line_content": "    auto locked_chain = pwallet->chain().lock();",
          "new_line_content": "            }.ToString());",
          "content_same": false
        },
        {
          "line": 3906,
          "old_api": "LOCK",
          "new_api": null,
          "old_text": "LOCK(pwallet->cs_wallet)",
          "new_text": null,
          "old_line_content": "    LOCK(pwallet->cs_wallet);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 4033,
          "old_api": "size",
          "new_api": null,
          "old_text": "request.params.size()",
          "new_text": null,
          "old_line_content": "    if (request.fHelp || request.params.size() < 2 || request.params.size() > 5)",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 4034,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "std::runtime_error(\n            RPCHelpMan{\"walletcreatefundedpsbt\",\n                \"\\nCreates and funds a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n                \"Implements the Creator and Updater roles.\\n\",\n                {\n                    {\"inputs\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"A json array of json objects\",\n                        {\n                            {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"\",\n                                {\n                                    {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n                                    {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n                                    {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n                                },\n                            },\n                        },\n                        },\n                    {\"outputs\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"a json array with outputs (key-value pairs), where none of the keys are duplicated.\\n\"\n                            \"That is, each address can only appear once and there can only be one 'data' object.\\n\"\n                            \"For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n                            \"                             accepted as second parameter.\",\n                        {\n                            {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"\",\n                                {\n                                    {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n                                },\n                                },\n                            {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"\",\n                                {\n                                    {\"data\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"A key-value pair. The key must be \\\"data\\\", the value is hex-encoded data\"},\n                                },\n                            },\n                        },\n                    },\n                    {\"locktime\", RPCArg::Type::NUM, /* default */ \"0\", \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n                    {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n                        {\n                            {\"changeAddress\", RPCArg::Type::STR_HEX, /* default */ \"pool address\", \"The bitcoin address to receive the change\"},\n                            {\"changePosition\", RPCArg::Type::NUM, /* default */ \"random\", \"The index of the change output\"},\n                            {\"change_type\", RPCArg::Type::STR, /* default */ \"set by -changetype\", \"The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n                            {\"includeWatching\", RPCArg::Type::BOOL, /* default */ \"false\", \"Also select inputs which are watch only\"},\n                            {\"lockUnspents\", RPCArg::Type::BOOL, /* default */ \"false\", \"Lock selected unspent outputs\"},\n                            {\"feeRate\", RPCArg::Type::AMOUNT, /* default */ \"not set: makes wallet determine the fee\", \"Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\"},\n                            {\"subtractFeeFromOutputs\", RPCArg::Type::ARR, /* default */ \"empty array\", \"A json array of integers.\\n\"\n                            \"                              The fee will be equally deducted from the amount of each specified output.\\n\"\n                            \"                              Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n                            \"                              If no outputs are specified here, the sender pays the fee.\",\n                                {\n                                    {\"vout_index\", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, \"The zero-based output index, before a change output is added.\"},\n                                },\n                            },\n                            {\"replaceable\", RPCArg::Type::BOOL, /* default */ \"false\", \"Marks this transaction as BIP125 replaceable.\\n\"\n                            \"                              Allows this transaction to be replaced by a transaction with higher fees\"},\n                            {\"conf_target\", RPCArg::Type::NUM, /* default */ \"Fallback to wallet's confirmation target\", \"Confirmation target (in blocks)\"},\n                            {\"estimate_mode\", RPCArg::Type::STR, /* default */ \"UNSET\", \"The fee estimate mode, must be one of:\\n\"\n                            \"         \\\"UNSET\\\"\\n\"\n                            \"         \\\"ECONOMICAL\\\"\\n\"\n                            \"         \\\"CONSERVATIVE\\\"\"},\n                        },\n                        \"options\"},\n                    {\"bip32derivs\", RPCArg::Type::BOOL, /* default */ \"false\", \"If true, includes the BIP 32 derivation paths for public keys if we know them\"},\n                },\n                RPCResult{\n                            \"{\\n\"\n                            \"  \\\"psbt\\\": \\\"value\\\",        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n                            \"  \\\"fee\\\":       n,         (numeric) Fee in \" + CURRENCY_UNIT + \" the resulting transaction pays\\n\"\n                            \"  \\\"changepos\\\": n          (numeric) The position of the added change output, or -1\\n\"\n                            \"}\\n\"\n                                },\n                                RPCExamples{\n                            \"\\nCreate a transaction with no inputs\\n\"\n                            + HelpExampleCli(\"walletcreatefundedpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n                                },\n                            }.ToString())",
          "new_text": null,
          "old_line_content": "        throw std::runtime_error(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4035,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "RPCHelpMan{\"walletcreatefundedpsbt\",\n                \"\\nCreates and funds a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n                \"Implements the Creator and Updater roles.\\n\",\n                {\n                    {\"inputs\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"A json array of json objects\",\n                        {\n                            {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"\",\n                                {\n                                    {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n                                    {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n                                    {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n                                },\n                            },\n                        },\n                        },\n                    {\"outputs\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"a json array with outputs (key-value pairs), where none of the keys are duplicated.\\n\"\n                            \"That is, each address can only appear once and there can only be one 'data' object.\\n\"\n                            \"For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n                            \"                             accepted as second parameter.\",\n                        {\n                            {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"\",\n                                {\n                                    {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n                                },\n                                },\n                            {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"\",\n                                {\n                                    {\"data\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"A key-value pair. The key must be \\\"data\\\", the value is hex-encoded data\"},\n                                },\n                            },\n                        },\n                    },\n                    {\"locktime\", RPCArg::Type::NUM, /* default */ \"0\", \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n                    {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n                        {\n                            {\"changeAddress\", RPCArg::Type::STR_HEX, /* default */ \"pool address\", \"The bitcoin address to receive the change\"},\n                            {\"changePosition\", RPCArg::Type::NUM, /* default */ \"random\", \"The index of the change output\"},\n                            {\"change_type\", RPCArg::Type::STR, /* default */ \"set by -changetype\", \"The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n                            {\"includeWatching\", RPCArg::Type::BOOL, /* default */ \"false\", \"Also select inputs which are watch only\"},\n                            {\"lockUnspents\", RPCArg::Type::BOOL, /* default */ \"false\", \"Lock selected unspent outputs\"},\n                            {\"feeRate\", RPCArg::Type::AMOUNT, /* default */ \"not set: makes wallet determine the fee\", \"Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\"},\n                            {\"subtractFeeFromOutputs\", RPCArg::Type::ARR, /* default */ \"empty array\", \"A json array of integers.\\n\"\n                            \"                              The fee will be equally deducted from the amount of each specified output.\\n\"\n                            \"                              Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n                            \"                              If no outputs are specified here, the sender pays the fee.\",\n                                {\n                                    {\"vout_index\", RPCArg::Type::NUM, RPCArg::Optional::OMITTED, \"The zero-based output index, before a change output is added.\"},\n                                },\n                            },\n                            {\"replaceable\", RPCArg::Type::BOOL, /* default */ \"false\", \"Marks this transaction as BIP125 replaceable.\\n\"\n                            \"                              Allows this transaction to be replaced by a transaction with higher fees\"},\n                            {\"conf_target\", RPCArg::Type::NUM, /* default */ \"Fallback to wallet's confirmation target\", \"Confirmation target (in blocks)\"},\n                            {\"estimate_mode\", RPCArg::Type::STR, /* default */ \"UNSET\", \"The fee estimate mode, must be one of:\\n\"\n                            \"         \\\"UNSET\\\"\\n\"\n                            \"         \\\"ECONOMICAL\\\"\\n\"\n                            \"         \\\"CONSERVATIVE\\\"\"},\n                        },\n                        \"options\"},\n                    {\"bip32derivs\", RPCArg::Type::BOOL, /* default */ \"false\", \"If true, includes the BIP 32 derivation paths for public keys if we know them\"},\n                },\n                RPCResult{\n                            \"{\\n\"\n                            \"  \\\"psbt\\\": \\\"value\\\",        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n                            \"  \\\"fee\\\":       n,         (numeric) Fee in \" + CURRENCY_UNIT + \" the resulting transaction pays\\n\"\n                            \"  \\\"changepos\\\": n          (numeric) The position of the added change output, or -1\\n\"\n                            \"}\\n\"\n                                },\n                                RPCExamples{\n                            \"\\nCreate a transaction with no inputs\\n\"\n                            + HelpExampleCli(\"walletcreatefundedpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n                                },\n                            }.ToString()",
          "new_text": null,
          "old_line_content": "            RPCHelpMan{\"walletcreatefundedpsbt\",",
          "new_line_content": "UniValue walletcreatefundedpsbt(const JSONRPCRequest& request)",
          "content_same": false
        },
        {
          "line": 3910,
          "old_api": "JSONRPCError",
          "new_api": null,
          "old_text": "JSONRPCError(RPC_WALLET_ERROR, \"Cannot set a HD seed on a non-HD wallet. Start with -upgradewallet in order to upgrade a non-HD wallet to HD\")",
          "new_text": null,
          "old_line_content": "        throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot set a HD seed on a non-HD wallet. Start with -upgradewallet in order to upgrade a non-HD wallet to HD\");",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3922,
          "old_api": "GenerateNewSeed",
          "new_api": null,
          "old_text": "pwallet->GenerateNewSeed()",
          "new_text": null,
          "old_line_content": "        master_pub_key = pwallet->GenerateNewSeed();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3795,
          "old_api": "AddressBookDataToJSON",
          "new_api": null,
          "old_text": "AddressBookDataToJSON(item.second, false)",
          "new_text": null,
          "old_line_content": "            ret.pushKV(EncodeDestination(item.first), AddressBookDataToJSON(item.second, false));",
          "new_line_content": "        if (item.second.name == label) {",
          "content_same": false
        },
        {
          "line": 3925,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "key.IsValid()",
          "new_text": null,
          "old_line_content": "        if (!key.IsValid()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3926,
          "old_api": "JSONRPCError",
          "new_api": null,
          "old_text": "JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key\")",
          "new_text": null,
          "old_line_content": "            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key\");",
          "new_line_content": "    bool flush_key_pool = true;",
          "content_same": false
        },
        {
          "line": 3799,
          "old_api": "empty",
          "new_api": null,
          "old_text": "ret.empty()",
          "new_text": null,
          "old_line_content": "    if (ret.empty()) {",
          "new_line_content": "            // case it does.",
          "content_same": false
        },
        {
          "line": 3929,
          "old_api": "HaveKey",
          "new_api": null,
          "old_text": "HaveKey(*pwallet, key)",
          "new_text": null,
          "old_line_content": "        if (HaveKey(*pwallet, key)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3930,
          "old_api": "JSONRPCError",
          "new_api": null,
          "old_text": "JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key (either as an HD seed or as a loose private key)\")",
          "new_text": null,
          "old_line_content": "            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key (either as an HD seed or as a loose private key)\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3808,
          "old_api": "GetWalletForJSONRPCRequest",
          "new_api": null,
          "old_text": "GetWalletForJSONRPCRequest(request)",
          "new_text": null,
          "old_line_content": "    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3809,
          "old_api": "get",
          "new_api": null,
          "old_text": "wallet.get()",
          "new_text": null,
          "old_line_content": "    CWallet* const pwallet = wallet.get();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3815,
          "old_api": "size",
          "new_api": null,
          "old_text": "request.params.size()",
          "new_text": null,
          "old_line_content": "    if (request.fHelp || request.params.size() > 1)",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3816,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "std::runtime_error(\n            RPCHelpMan{\"listlabels\",\n                \"\\nReturns the list of all labels, or labels that are assigned to addresses with a specific purpose.\\n\",\n                {\n                    {\"purpose\", RPCArg::Type::STR, RPCArg::Optional::OMITTED_NAMED_ARG, \"Address purpose to list labels for ('send','receive'). An empty string is the same as not providing this argument.\"},\n                },\n                RPCResult{\n            \"[               (json array of string)\\n\"\n            \"  \\\"label\\\",      (string) Label name\\n\"\n            \"  ...\\n\"\n            \"]\\n\"\n                },\n                RPCExamples{\n            \"\\nList all labels\\n\"\n            + HelpExampleCli(\"listlabels\", \"\") +\n            \"\\nList labels that have receiving addresses\\n\"\n            + HelpExampleCli(\"listlabels\", \"receive\") +\n            \"\\nList labels that have sending addresses\\n\"\n            + HelpExampleCli(\"listlabels\", \"send\") +\n            \"\\nAs a JSON-RPC call\\n\"\n            + HelpExampleRpc(\"listlabels\", \"receive\")\n                },\n            }.ToString())",
          "new_text": null,
          "old_line_content": "        throw std::runtime_error(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3817,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "RPCHelpMan{\"listlabels\",\n                \"\\nReturns the list of all labels, or labels that are assigned to addresses with a specific purpose.\\n\",\n                {\n                    {\"purpose\", RPCArg::Type::STR, RPCArg::Optional::OMITTED_NAMED_ARG, \"Address purpose to list labels for ('send','receive'). An empty string is the same as not providing this argument.\"},\n                },\n                RPCResult{\n            \"[               (json array of string)\\n\"\n            \"  \\\"label\\\",      (string) Label name\\n\"\n            \"  ...\\n\"\n            \"]\\n\"\n                },\n                RPCExamples{\n            \"\\nList all labels\\n\"\n            + HelpExampleCli(\"listlabels\", \"\") +\n            \"\\nList labels that have receiving addresses\\n\"\n            + HelpExampleCli(\"listlabels\", \"receive\") +\n            \"\\nList labels that have sending addresses\\n\"\n            + HelpExampleCli(\"listlabels\", \"send\") +\n            \"\\nAs a JSON-RPC call\\n\"\n            + HelpExampleRpc(\"listlabels\", \"receive\")\n                },\n            }.ToString()",
          "new_text": null,
          "old_line_content": "            RPCHelpMan{\"listlabels\",",
          "new_line_content": "static UniValue listlabels(const JSONRPCRequest& request)",
          "content_same": false
        },
        {
          "line": 3945,
          "old_api": "GetPubKey",
          "new_api": null,
          "old_text": "pwallet->GetPubKey(keyID, vchPubKey)",
          "new_text": null,
          "old_line_content": "    if (!pwallet->GetPubKey(keyID, vchPubKey)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3964,
          "old_api": "size",
          "new_api": null,
          "old_text": "request.params.size()",
          "new_text": null,
          "old_line_content": "    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3949,
          "old_api": "GetKeyOrigin",
          "new_api": null,
          "old_text": "pwallet->GetKeyOrigin(keyID, info)",
          "new_text": null,
          "old_line_content": "    if (!pwallet->GetKeyOrigin(keyID, info)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3950,
          "old_api": "JSONRPCError",
          "new_api": null,
          "old_text": "JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\")",
          "new_text": null,
          "old_line_content": "        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");",
          "new_line_content": "    return NullUniValue;",
          "content_same": false
        },
        {
          "line": 3952,
          "old_api": "std::move(info)",
          "new_api": null,
          "old_text": "std::move(info)",
          "new_text": null,
          "old_line_content": "    hd_keypaths.emplace(vchPubKey, std::move(info));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4220,
          "old_api": "ARRAYLEN",
          "new_api": null,
          "old_text": "ARRAYLEN(commands)",
          "new_text": null,
          "old_line_content": "    for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); vcidx++)",
          "new_line_content": "    { \"wallet\",             \"unloadwallet\",                     &unloadwallet,                  {\"wallet_name\"} },",
          "content_same": false
        },
        {
          "line": 3957,
          "old_api": "GetWalletForJSONRPCRequest",
          "new_api": null,
          "old_text": "GetWalletForJSONRPCRequest(request)",
          "new_text": null,
          "old_line_content": "    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 3830,
          "old_api": "HelpExampleCli",
          "new_api": null,
          "old_text": "HelpExampleCli(\"listlabels\", \"\")",
          "new_text": null,
          "old_line_content": "            + HelpExampleCli(\"listlabels\", \"\") +",
          "new_line_content": "                {",
          "content_same": false
        },
        {
          "line": 3958,
          "old_api": "get",
          "new_api": null,
          "old_text": "wallet.get()",
          "new_text": null,
          "old_line_content": "    CWallet* const pwallet = wallet.get();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3832,
          "old_api": "HelpExampleCli",
          "new_api": null,
          "old_text": "HelpExampleCli(\"listlabels\", \"receive\")",
          "new_text": null,
          "old_line_content": "            + HelpExampleCli(\"listlabels\", \"receive\") +",
          "new_line_content": "                },",
          "content_same": false
        },
        {
          "line": 4221,
          "old_api": "appendCommand",
          "new_api": null,
          "old_text": "t.appendCommand(commands[vcidx].name, &commands[vcidx])",
          "new_text": null,
          "old_line_content": "        t.appendCommand(commands[vcidx].name, &commands[vcidx]);",
          "new_line_content": "    { \"wallet\",             \"walletcreatefundedpsbt\",           &walletcreatefundedpsbt,        {\"inputs\",\"outputs\",\"locktime\",\"options\",\"bip32derivs\"} },",
          "content_same": false
        },
        {
          "line": 3834,
          "old_api": "HelpExampleCli",
          "new_api": null,
          "old_text": "HelpExampleCli(\"listlabels\", \"send\")",
          "new_text": null,
          "old_line_content": "            + HelpExampleCli(\"listlabels\", \"send\") +",
          "new_line_content": "            \"[               (json array of string)\\n\"",
          "content_same": false
        },
        {
          "line": 3836,
          "old_api": "HelpExampleRpc",
          "new_api": null,
          "old_text": "HelpExampleRpc(\"listlabels\", \"receive\")",
          "new_text": null,
          "old_line_content": "            + HelpExampleRpc(\"listlabels\", \"receive\")",
          "new_line_content": "            \"  ...\\n\"",
          "content_same": false
        },
        {
          "line": 3965,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "std::runtime_error(\n            RPCHelpMan{\"walletprocesspsbt\",\n                \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n                \"that we can sign for.\" +\n                    HelpRequiringPassphrase(pwallet) + \"\\n\",\n                {\n                    {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The transaction base64 string\"},\n                    {\"sign\", RPCArg::Type::BOOL, /* default */ \"true\", \"Also sign the transaction when updating\"},\n                    {\"sighashtype\", RPCArg::Type::STR, /* default */ \"ALL\", \"The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n            \"       \\\"ALL\\\"\\n\"\n            \"       \\\"NONE\\\"\\n\"\n            \"       \\\"SINGLE\\\"\\n\"\n            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n            \"       \\\"SINGLE|ANYONECANPAY\\\"\"},\n                    {\"bip32derivs\", RPCArg::Type::BOOL, /* default */ \"false\", \"If true, includes the BIP 32 derivation paths for public keys if we know them\"},\n                },\n                RPCResult{\n            \"{\\n\"\n            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n            \"  ]\\n\"\n            \"}\\n\"\n                },\n                RPCExamples{\n                    HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")\n                },\n            }.ToString())",
          "new_text": null,
          "old_line_content": "        throw std::runtime_error(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3966,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "RPCHelpMan{\"walletprocesspsbt\",\n                \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n                \"that we can sign for.\" +\n                    HelpRequiringPassphrase(pwallet) + \"\\n\",\n                {\n                    {\"psbt\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The transaction base64 string\"},\n                    {\"sign\", RPCArg::Type::BOOL, /* default */ \"true\", \"Also sign the transaction when updating\"},\n                    {\"sighashtype\", RPCArg::Type::STR, /* default */ \"ALL\", \"The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n            \"       \\\"ALL\\\"\\n\"\n            \"       \\\"NONE\\\"\\n\"\n            \"       \\\"SINGLE\\\"\\n\"\n            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n            \"       \\\"SINGLE|ANYONECANPAY\\\"\"},\n                    {\"bip32derivs\", RPCArg::Type::BOOL, /* default */ \"false\", \"If true, includes the BIP 32 derivation paths for public keys if we know them\"},\n                },\n                RPCResult{\n            \"{\\n\"\n            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n            \"  ]\\n\"\n            \"}\\n\"\n                },\n                RPCExamples{\n                    HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")\n                },\n            }.ToString()",
          "new_text": null,
          "old_line_content": "            RPCHelpMan{\"walletprocesspsbt\",",
          "new_line_content": "UniValue walletprocesspsbt(const JSONRPCRequest& request)",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 26,
      "total_additions": 69,
      "total_deletions": 66,
      "total_api_changes": 161
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 13,
        "api_related_lines": 161,
        "non_api_lines": 7,
        "non_api_line_numbers": [
          3793,
          3797,
          3798,
          3802,
          3803,
          3804,
          3805
        ]
      }
    },
    "api_calls_before": 1635,
    "api_calls_after": 1637,
    "diff_info": {
      "added_lines": 12,
      "removed_lines": 1,
      "total_diff_lines": 27
    }
  }
}