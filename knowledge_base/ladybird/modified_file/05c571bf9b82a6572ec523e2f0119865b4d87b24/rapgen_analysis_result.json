{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/05c571bf9b82a6572ec523e2f0119865b4d87b24",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/05c571bf9b82a6572ec523e2f0119865b4d87b24/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/05c571bf9b82a6572ec523e2f0119865b4d87b24/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ladybird/modified_file/05c571bf9b82a6572ec523e2f0119865b4d87b24/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 35,
          "old_api": "Bindings::ensure_web_prototype<Bindings::PerformancePrototype>(realm, \"Performance\"_fly_string)",
          "new_api": "Base::initialize(realm)",
          "old_text": "Bindings::ensure_web_prototype<Bindings::PerformancePrototype>(realm, \"Performance\"_fly_string)",
          "new_text": "Base::initialize(realm)",
          "old_line_content": "    set_prototype(&Bindings::ensure_web_prototype<Bindings::PerformancePrototype>(realm, \"Performance\"_fly_string));",
          "new_line_content": "    Base::initialize(realm);",
          "content_same": false
        },
        {
          "line": 41,
          "old_api": "visit",
          "new_api": "Base::visit_edges(visitor)",
          "old_text": "visitor.visit(m_window)",
          "new_text": "Base::visit_edges(visitor)",
          "old_line_content": "    visitor.visit(m_window);",
          "new_line_content": "    Base::visit_edges(visitor);",
          "content_same": false
        },
        {
          "line": 67,
          "old_api": "VERIFY",
          "new_api": "global_object",
          "old_text": "VERIFY(window_or_worker)",
          "new_text": "realm.global_object()",
          "old_line_content": "    VERIFY(window_or_worker);",
          "new_line_content": "    auto* window_or_worker = dynamic_cast<HTML::WindowOrWorkerGlobalScopeMixin*>(&realm.global_object());",
          "content_same": false
        },
        {
          "line": 68,
          "old_api": "queue_performance_entry",
          "new_api": "VERIFY",
          "old_text": "window_or_worker->queue_performance_entry(entry)",
          "new_text": "VERIFY(window_or_worker)",
          "old_line_content": "    window_or_worker->queue_performance_entry(entry);",
          "new_line_content": "    VERIFY(window_or_worker);",
          "content_same": false
        },
        {
          "line": 80,
          "old_api": "global_object",
          "new_api": "realm",
          "old_text": "realm.global_object()",
          "new_text": "this->realm()",
          "old_line_content": "    auto* window_or_worker = dynamic_cast<HTML::WindowOrWorkerGlobalScopeMixin*>(&realm.global_object());",
          "new_line_content": "    auto& realm = this->realm();",
          "content_same": false
        },
        {
          "line": 81,
          "old_api": "VERIFY",
          "new_api": "global_object",
          "old_text": "VERIFY(window_or_worker)",
          "new_text": "realm.global_object()",
          "old_line_content": "    VERIFY(window_or_worker);",
          "new_line_content": "    auto* window_or_worker = dynamic_cast<HTML::WindowOrWorkerGlobalScopeMixin*>(&realm.global_object());",
          "content_same": false
        },
        {
          "line": 85,
          "old_api": "clear_performance_entry_buffer",
          "new_api": "has_value",
          "old_text": "window_or_worker->clear_performance_entry_buffer({}, PerformanceTimeline::EntryTypes::mark)",
          "new_text": "mark_name.has_value()",
          "old_line_content": "        window_or_worker->clear_performance_entry_buffer({}, PerformanceTimeline::EntryTypes::mark);",
          "new_line_content": "    if (!mark_name.has_value()) {",
          "content_same": false
        },
        {
          "line": 101,
          "old_api": "String::formatted(\"'{}' is an attribute in the PerformanceTiming interface and thus can only be used in a Window context\", name)",
          "new_api": "global_object",
          "old_text": "String::formatted(\"'{}' is an attribute in the PerformanceTiming interface and thus can only be used in a Window context\", name)",
          "new_text": "realm.global_object()",
          "old_line_content": "        return WebIDL::SimpleException { WebIDL::SimpleExceptionType::TypeError, TRY_OR_THROW_OOM(vm, String::formatted(\"'{}' is an attribute in the PerformanceTiming interface and thus can only be used in a Window context\", name)) };",
          "new_line_content": "    if (!is<HTML::Window>(realm.global_object()))",
          "content_same": false
        },
        {
          "line": 108,
          "old_api": "VERIFY",
          "new_api": "timing",
          "old_text": "VERIFY(timing_interface)",
          "new_text": "timing()",
          "old_line_content": "    VERIFY(timing_interface);",
          "new_line_content": "    auto timing_interface = timing();",
          "content_same": false
        },
        {
          "line": 134,
          "old_api": "mark.get<String>()",
          "new_api": "mark.has<String>()",
          "old_text": "mark.get<String>()",
          "new_text": "mark.has<String>()",
          "old_line_content": "        auto const& mark_string = mark.get<String>();",
          "new_line_content": "    if (mark.has<String>()) {",
          "content_same": false
        },
        {
          "line": 148,
          "old_api": "VERIFY",
          "new_api": "global_object",
          "old_text": "VERIFY(window_or_worker)",
          "new_text": "realm.global_object()",
          "old_line_content": "        VERIFY(window_or_worker);",
          "new_line_content": "        auto* window_or_worker = dynamic_cast<HTML::WindowOrWorkerGlobalScopeMixin*>(&realm.global_object());",
          "content_same": false
        },
        {
          "line": 154,
          "old_api": "name",
          "new_api": "last_matching",
          "old_text": "entry->name()",
          "new_text": "performance_entry_buffer.last_matching([&mark_string](JS::Handle<PerformanceTimeline::PerformanceEntry> const& entry) {\n            return entry->name() == mark_string;\n        })",
          "old_line_content": "            return entry->name() == mark_string;",
          "new_line_content": "        auto maybe_entry = performance_entry_buffer.last_matching([&mark_string](JS::Handle<PerformanceTimeline::PerformanceEntry> const& entry) {",
          "content_same": false
        },
        {
          "line": 158,
          "old_api": "String::formatted(\"No PerformanceMark object with name '{}' found in the performance timeline\", mark_string)",
          "new_api": "has_value",
          "old_text": "String::formatted(\"No PerformanceMark object with name '{}' found in the performance timeline\", mark_string)",
          "new_text": "maybe_entry.has_value()",
          "old_line_content": "            return WebIDL::SyntaxError::create(realm, MUST(String::formatted(\"No PerformanceMark object with name '{}' found in the performance timeline\", mark_string)));",
          "new_line_content": "        if (!maybe_entry.has_value())",
          "content_same": false
        },
        {
          "line": 178,
          "old_api": "global_object",
          "new_api": "realm",
          "old_text": "realm.global_object()",
          "new_text": "this->realm()",
          "old_line_content": "    auto* window_or_worker = dynamic_cast<HTML::WindowOrWorkerGlobalScopeMixin*>(&realm.global_object());",
          "new_line_content": "    auto& realm = this->realm();",
          "content_same": false
        },
        {
          "line": 179,
          "old_api": "VERIFY",
          "new_api": "global_object",
          "old_text": "VERIFY(window_or_worker)",
          "new_text": "realm.global_object()",
          "old_line_content": "    VERIFY(window_or_worker);",
          "new_line_content": "    auto* window_or_worker = dynamic_cast<HTML::WindowOrWorkerGlobalScopeMixin*>(&realm.global_object());",
          "content_same": false
        },
        {
          "line": 180,
          "old_api": "vm",
          "new_api": "VERIFY",
          "old_text": "this->vm()",
          "new_text": "VERIFY(window_or_worker)",
          "old_line_content": "    auto& vm = this->vm();",
          "new_line_content": "    VERIFY(window_or_worker);",
          "content_same": false
        },
        {
          "line": 189,
          "old_api": "is_undefined",
          "new_api": "has_value",
          "old_text": "start_or_measure_options_dictionary_object->detail.is_undefined()",
          "new_text": "start_or_measure_options_dictionary_object->duration.has_value()",
          "old_line_content": "            || !start_or_measure_options_dictionary_object->detail.is_undefined())) {",
          "new_line_content": "            || start_or_measure_options_dictionary_object->duration.has_value()",
          "content_same": false
        },
        {
          "line": 209,
          "old_api": "value",
          "new_api": "has_value",
          "old_text": "end_mark.value()",
          "new_text": "end_mark.has_value()",
          "old_line_content": "        end_time = TRY(convert_mark_to_timestamp(realm, end_mark.value()));",
          "new_line_content": "    if (end_mark.has_value()) {",
          "content_same": false
        },
        {
          "line": 214,
          "old_api": "value",
          "new_api": "has_value",
          "old_text": "start_or_measure_options_dictionary_object->end.value()",
          "new_text": "start_or_measure_options_dictionary_object->end.has_value()",
          "old_line_content": "        end_time = TRY(convert_mark_to_timestamp(realm, start_or_measure_options_dictionary_object->end.value()));",
          "new_line_content": "    else if (start_or_measure_options_dictionary_object && start_or_measure_options_dictionary_object->end.has_value()) {",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": "value",
          "new_api": "has_value",
          "old_text": "start_or_measure_options_dictionary_object->start.value()",
          "new_text": "start_or_measure_options_dictionary_object->start.has_value()",
          "old_line_content": "        start_time = TRY(convert_mark_to_timestamp(realm, start_or_measure_options_dictionary_object->start.value()));",
          "new_line_content": "    if (start_or_measure_options_dictionary_object && start_or_measure_options_dictionary_object->start.has_value()) {",
          "content_same": false
        },
        {
          "line": 257,
          "old_api": "start_or_measure_options.get<String>()",
          "new_api": "start_or_measure_options.has<String>()",
          "old_text": "start_or_measure_options.get<String>()",
          "new_text": "start_or_measure_options.has<String>()",
          "old_line_content": "        start_time = TRY(convert_mark_to_timestamp(realm, start_or_measure_options.get<String>()));",
          "new_line_content": "    else if (start_or_measure_options.has<String>()) {",
          "content_same": false
        },
        {
          "line": 311,
          "old_api": "global_object",
          "new_api": "realm",
          "old_text": "realm.global_object()",
          "new_text": "this->realm()",
          "old_line_content": "    auto* window_or_worker = dynamic_cast<HTML::WindowOrWorkerGlobalScopeMixin*>(&realm.global_object());",
          "new_line_content": "    auto& realm = this->realm();",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": "VERIFY",
          "new_api": "global_object",
          "old_text": "VERIFY(window_or_worker)",
          "new_text": "realm.global_object()",
          "old_line_content": "    VERIFY(window_or_worker);",
          "new_line_content": "    auto* window_or_worker = dynamic_cast<HTML::WindowOrWorkerGlobalScopeMixin*>(&realm.global_object());",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": "clear_performance_entry_buffer",
          "new_api": "has_value",
          "old_text": "window_or_worker->clear_performance_entry_buffer({}, PerformanceTimeline::EntryTypes::measure)",
          "new_text": "measure_name.has_value()",
          "old_line_content": "        window_or_worker->clear_performance_entry_buffer({}, PerformanceTimeline::EntryTypes::measure);",
          "new_line_content": "    if (!measure_name.has_value()) {",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": "vm",
          "new_api": "realm",
          "old_text": "this->vm()",
          "new_text": "this->realm()",
          "old_line_content": "    auto& vm = this->vm();",
          "new_line_content": "    auto& realm = this->realm();",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": "global_object",
          "new_api": "vm",
          "old_text": "realm.global_object()",
          "new_text": "this->vm()",
          "old_line_content": "    auto* window_or_worker = dynamic_cast<HTML::WindowOrWorkerGlobalScopeMixin*>(&realm.global_object());",
          "new_line_content": "    auto& vm = this->vm();",
          "content_same": false
        },
        {
          "line": 332,
          "old_api": "VERIFY",
          "new_api": "global_object",
          "old_text": "VERIFY(window_or_worker)",
          "new_text": "realm.global_object()",
          "old_line_content": "    VERIFY(window_or_worker);",
          "new_line_content": "    auto* window_or_worker = dynamic_cast<HTML::WindowOrWorkerGlobalScopeMixin*>(&realm.global_object());",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": "vm",
          "new_api": "realm",
          "old_text": "this->vm()",
          "new_text": "this->realm()",
          "old_line_content": "    auto& vm = this->vm();",
          "new_line_content": "    auto& realm = this->realm();",
          "content_same": false
        },
        {
          "line": 344,
          "old_api": "global_object",
          "new_api": "vm",
          "old_text": "realm.global_object()",
          "new_text": "this->vm()",
          "old_line_content": "    auto* window_or_worker = dynamic_cast<HTML::WindowOrWorkerGlobalScopeMixin*>(&realm.global_object());",
          "new_line_content": "    auto& vm = this->vm();",
          "content_same": false
        },
        {
          "line": 345,
          "old_api": "VERIFY",
          "new_api": "global_object",
          "old_text": "VERIFY(window_or_worker)",
          "new_text": "realm.global_object()",
          "old_line_content": "    VERIFY(window_or_worker);",
          "new_line_content": "    auto* window_or_worker = dynamic_cast<HTML::WindowOrWorkerGlobalScopeMixin*>(&realm.global_object());",
          "content_same": false
        },
        {
          "line": 356,
          "old_api": "vm",
          "new_api": "realm",
          "old_text": "this->vm()",
          "new_text": "this->realm()",
          "old_line_content": "    auto& vm = this->vm();",
          "new_line_content": "    auto& realm = this->realm();",
          "content_same": false
        },
        {
          "line": 357,
          "old_api": "global_object",
          "new_api": "vm",
          "old_text": "realm.global_object()",
          "new_text": "this->vm()",
          "old_line_content": "    auto* window_or_worker = dynamic_cast<HTML::WindowOrWorkerGlobalScopeMixin*>(&realm.global_object());",
          "new_line_content": "    auto& vm = this->vm();",
          "content_same": false
        },
        {
          "line": 358,
          "old_api": "VERIFY",
          "new_api": "global_object",
          "old_text": "VERIFY(window_or_worker)",
          "new_text": "realm.global_object()",
          "old_line_content": "    VERIFY(window_or_worker);",
          "new_line_content": "    auto* window_or_worker = dynamic_cast<HTML::WindowOrWorkerGlobalScopeMixin*>(&realm.global_object());",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 128,
          "old_api": null,
          "new_api": "static_cast<HighResolutionTime::DOMHighResTimeStamp>(end_time - start_time)",
          "old_text": null,
          "new_text": "static_cast<HighResolutionTime::DOMHighResTimeStamp>(end_time - start_time)",
          "old_line_content": "}",
          "new_line_content": "    return static_cast<HighResolutionTime::DOMHighResTimeStamp>(end_time - start_time);",
          "content_same": false
        },
        {
          "line": 258,
          "old_api": null,
          "new_api": "start_or_measure_options.get<String>()",
          "old_text": null,
          "new_text": "start_or_measure_options.get<String>()",
          "old_line_content": "    }",
          "new_line_content": "        start_time = TRY(convert_mark_to_timestamp(realm, start_or_measure_options.get<String>()));",
          "content_same": false
        },
        {
          "line": 135,
          "old_api": null,
          "new_api": "mark.get<String>()",
          "old_text": null,
          "new_text": "mark.get<String>()",
          "old_line_content": "",
          "new_line_content": "        auto const& mark_string = mark.get<String>();",
          "content_same": false
        },
        {
          "line": 149,
          "old_api": null,
          "new_api": "VERIFY",
          "old_text": null,
          "new_text": "VERIFY(window_or_worker)",
          "old_line_content": "",
          "new_line_content": "        VERIFY(window_or_worker);",
          "content_same": false
        },
        {
          "line": 151,
          "old_api": null,
          "new_api": "relevant_performance_entry_tuple",
          "old_text": null,
          "new_text": "window_or_worker->relevant_performance_entry_tuple(PerformanceTimeline::EntryTypes::mark)",
          "old_line_content": "        auto& performance_entry_buffer = tuple.performance_entry_buffer;",
          "new_line_content": "        auto& tuple = window_or_worker->relevant_performance_entry_tuple(PerformanceTimeline::EntryTypes::mark);",
          "content_same": false
        },
        {
          "line": 281,
          "old_api": null,
          "new_api": "JS::js_null()",
          "old_text": null,
          "new_text": "JS::js_null()",
          "old_line_content": "",
          "new_line_content": "    JS::Value detail { JS::js_null() };",
          "content_same": false
        },
        {
          "line": 155,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "entry->name()",
          "old_line_content": "        });",
          "new_line_content": "            return entry->name() == mark_string;",
          "content_same": false
        },
        {
          "line": 28,
          "old_api": null,
          "new_api": "start",
          "old_text": null,
          "new_text": "m_timer.start()",
          "old_line_content": "}",
          "new_line_content": "    m_timer.start();",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": null,
          "new_api": "is_undefined",
          "old_text": null,
          "new_text": "start_or_measure_options_dictionary_object->detail.is_undefined()",
          "old_line_content": "        // 1. Let record be the result of calling the StructuredSerialize algorithm on startOrMeasureOptions's detail.",
          "new_line_content": "    if (start_or_measure_options_dictionary_object && !start_or_measure_options_dictionary_object->detail.is_undefined()) {",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": null,
          "new_api": "HTML::structured_serialize(vm, start_or_measure_options_dictionary_object->detail)",
          "old_text": null,
          "new_text": "HTML::structured_serialize(vm, start_or_measure_options_dictionary_object->detail)",
          "old_line_content": "",
          "new_line_content": "        auto record = TRY(HTML::structured_serialize(vm, start_or_measure_options_dictionary_object->detail));",
          "content_same": false
        },
        {
          "line": 159,
          "old_api": null,
          "new_api": "String::formatted(\"No PerformanceMark object with name '{}' found in the performance timeline\", mark_string)",
          "old_text": null,
          "new_text": "String::formatted(\"No PerformanceMark object with name '{}' found in the performance timeline\", mark_string)",
          "old_line_content": "",
          "new_line_content": "            return WebIDL::SyntaxError::create(realm, MUST(String::formatted(\"No PerformanceMark object with name '{}' found in the performance timeline\", mark_string)));",
          "content_same": false
        },
        {
          "line": 161,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "maybe_entry.value()->start_time()",
          "old_line_content": "    }",
          "new_line_content": "        return maybe_entry.value()->start_time();",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": null,
          "new_api": "HTML::structured_deserialize(vm, record, realm, Optional<HTML::DeserializationMemory> {})",
          "old_text": null,
          "new_text": "HTML::structured_deserialize(vm, record, realm, Optional<HTML::DeserializationMemory> {})",
          "old_line_content": "    }",
          "new_line_content": "        detail = TRY(HTML::structured_deserialize(vm, record, realm, Optional<HTML::DeserializationMemory> {}));",
          "content_same": false
        },
        {
          "line": 36,
          "old_api": null,
          "new_api": "Bindings::ensure_web_prototype<Bindings::PerformancePrototype>(realm, \"Performance\"_fly_string)",
          "old_text": null,
          "new_text": "Bindings::ensure_web_prototype<Bindings::PerformancePrototype>(realm, \"Performance\"_fly_string)",
          "old_line_content": "}",
          "new_line_content": "    set_prototype(&Bindings::ensure_web_prototype<Bindings::PerformancePrototype>(realm, \"Performance\"_fly_string));",
          "content_same": false
        },
        {
          "line": 165,
          "old_api": null,
          "new_api": "mark.get<HighResolutionTime::DOMHighResTimeStamp>()",
          "old_text": null,
          "new_text": "mark.get<HighResolutionTime::DOMHighResTimeStamp>()",
          "old_line_content": "",
          "new_line_content": "    auto mark_time_stamp = mark.get<HighResolutionTime::DOMHighResTimeStamp>();",
          "content_same": false
        },
        {
          "line": 296,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "realm.heap().allocate<UserTiming::PerformanceMeasure>(realm, realm, measure_name, start_time, duration, detail)",
          "old_line_content": "",
          "new_line_content": "    auto entry = realm.heap().allocate<UserTiming::PerformanceMeasure>(realm, realm, measure_name, start_time, duration, detail);",
          "content_same": false
        },
        {
          "line": 43,
          "old_api": null,
          "new_api": "visit",
          "old_text": null,
          "new_text": "visitor.visit(m_timing)",
          "old_line_content": "}",
          "new_line_content": "    visitor.visit(m_timing);",
          "content_same": false
        },
        {
          "line": 299,
          "old_api": null,
          "new_api": "queue_performance_entry",
          "old_text": null,
          "new_text": "window_or_worker->queue_performance_entry(entry)",
          "old_line_content": "",
          "new_line_content": "    window_or_worker->queue_performance_entry(entry);",
          "content_same": false
        },
        {
          "line": 49,
          "old_api": null,
          "new_api": "realm",
          "old_text": null,
          "new_text": "realm()",
          "old_line_content": "    return m_timing;",
          "new_line_content": "        m_timing = heap().allocate<NavigationTiming::PerformanceTiming>(realm(), *m_window);",
          "content_same": false
        },
        {
          "line": 181,
          "old_api": null,
          "new_api": "vm",
          "old_text": null,
          "new_text": "this->vm()",
          "old_line_content": "",
          "new_line_content": "    auto& vm = this->vm();",
          "content_same": false
        },
        {
          "line": 55,
          "old_api": null,
          "new_api": "origin_time",
          "old_text": null,
          "new_text": "m_timer.origin_time().milliseconds()",
          "old_line_content": "}",
          "new_line_content": "    return static_cast<double>(m_timer.origin_time().milliseconds());",
          "content_same": false
        },
        {
          "line": 185,
          "old_api": null,
          "new_api": "start_or_measure_options.get_pointer<UserTiming::PerformanceMeasureOptions>()",
          "old_text": null,
          "new_text": "start_or_measure_options.get_pointer<UserTiming::PerformanceMeasureOptions>()",
          "old_line_content": "    if (start_or_measure_options_dictionary_object",
          "new_line_content": "    auto const* start_or_measure_options_dictionary_object = start_or_measure_options.get_pointer<UserTiming::PerformanceMeasureOptions>();",
          "content_same": false
        },
        {
          "line": 313,
          "old_api": null,
          "new_api": "VERIFY",
          "old_text": null,
          "new_text": "VERIFY(window_or_worker)",
          "old_line_content": "",
          "new_line_content": "    VERIFY(window_or_worker);",
          "content_same": false
        },
        {
          "line": 61,
          "old_api": null,
          "new_api": "realm",
          "old_text": null,
          "new_text": "this->realm()",
          "old_line_content": "",
          "new_line_content": "    auto& realm = this->realm();",
          "content_same": false
        },
        {
          "line": 190,
          "old_api": null,
          "new_api": "is_undefined",
          "old_text": null,
          "new_text": "start_or_measure_options_dictionary_object->detail.is_undefined()",
          "old_line_content": "        // 1. If endMark is given, throw a TypeError.",
          "new_line_content": "            || !start_or_measure_options_dictionary_object->detail.is_undefined())) {",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": null,
          "new_api": "clear_performance_entry_buffer",
          "old_text": null,
          "new_text": "window_or_worker->clear_performance_entry_buffer({}, PerformanceTimeline::EntryTypes::measure)",
          "old_line_content": "        return;",
          "new_line_content": "        window_or_worker->clear_performance_entry_buffer({}, PerformanceTimeline::EntryTypes::measure);",
          "content_same": false
        },
        {
          "line": 64,
          "old_api": null,
          "new_api": "UserTiming::PerformanceMark::construct_impl(realm, mark_name, mark_options)",
          "old_text": null,
          "new_text": "UserTiming::PerformanceMark::construct_impl(realm, mark_name, mark_options)",
          "old_line_content": "",
          "new_line_content": "    auto entry = TRY(UserTiming::PerformanceMark::construct_impl(realm, mark_name, mark_options));",
          "content_same": false
        },
        {
          "line": 192,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "end_mark.has_value()",
          "old_line_content": "            return WebIDL::SimpleException { WebIDL::SimpleExceptionType::TypeError, \"Cannot provide PerformanceMeasureOptions and endMark at the same time\"sv };",
          "new_line_content": "        if (end_mark.has_value())",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "measure_name.value()",
          "old_line_content": "",
          "new_line_content": "    window_or_worker->remove_entries_from_performance_entry_buffer({}, PerformanceTimeline::EntryTypes::measure, measure_name.value());",
          "content_same": false
        },
        {
          "line": 196,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "start_or_measure_options_dictionary_object->end.has_value()",
          "old_line_content": "            return WebIDL::SimpleException { WebIDL::SimpleExceptionType::TypeError, \"PerformanceMeasureOptions must contain one or both of 'start' and 'end'\"sv };",
          "new_line_content": "        if (!start_or_measure_options_dictionary_object->start.has_value() && !start_or_measure_options_dictionary_object->end.has_value())",
          "content_same": false
        },
        {
          "line": 69,
          "old_api": null,
          "new_api": "queue_performance_entry",
          "old_text": null,
          "new_text": "window_or_worker->queue_performance_entry(entry)",
          "old_line_content": "",
          "new_line_content": "    window_or_worker->queue_performance_entry(entry);",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "start_or_measure_options_dictionary_object->duration.has_value()",
          "old_line_content": "            return WebIDL::SimpleException { WebIDL::SimpleExceptionType::TypeError, \"PerformanceMeasureOptions cannot contain 'start', 'duration' and 'end' properties all at once\"sv };",
          "new_line_content": "        if (start_or_measure_options_dictionary_object->start.has_value() && start_or_measure_options_dictionary_object->end.has_value() && start_or_measure_options_dictionary_object->duration.has_value())",
          "content_same": false
        },
        {
          "line": 333,
          "old_api": null,
          "new_api": "VERIFY",
          "old_text": null,
          "new_text": "VERIFY(window_or_worker)",
          "old_line_content": "",
          "new_line_content": "    VERIFY(window_or_worker);",
          "content_same": false
        },
        {
          "line": 337,
          "old_api": null,
          "new_api": "filter_buffer_map_by_name_and_type",
          "old_text": null,
          "new_text": "window_or_worker->filter_buffer_map_by_name_and_type(/* name= */ Optional<String> {}, /* type= */ Optional<String> {})",
          "old_line_content": "}",
          "new_line_content": "    return TRY_OR_THROW_OOM(vm, window_or_worker->filter_buffer_map_by_name_and_type(/* name= */ Optional<String> {}, /* type= */ Optional<String> {}));",
          "content_same": false
        },
        {
          "line": 82,
          "old_api": null,
          "new_api": "VERIFY",
          "old_text": null,
          "new_text": "VERIFY(window_or_worker)",
          "old_line_content": "",
          "new_line_content": "    VERIFY(window_or_worker);",
          "content_same": false
        },
        {
          "line": 210,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "end_mark.value()",
          "old_line_content": "    }",
          "new_line_content": "        end_time = TRY(convert_mark_to_timestamp(realm, end_mark.value()));",
          "content_same": false
        },
        {
          "line": 86,
          "old_api": null,
          "new_api": "clear_performance_entry_buffer",
          "old_text": null,
          "new_text": "window_or_worker->clear_performance_entry_buffer({}, PerformanceTimeline::EntryTypes::mark)",
          "old_line_content": "        return;",
          "new_line_content": "        window_or_worker->clear_performance_entry_buffer({}, PerformanceTimeline::EntryTypes::mark);",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "start_or_measure_options_dictionary_object->end.value()",
          "old_line_content": "    }",
          "new_line_content": "        end_time = TRY(convert_mark_to_timestamp(realm, start_or_measure_options_dictionary_object->end.value()));",
          "content_same": false
        },
        {
          "line": 346,
          "old_api": null,
          "new_api": "VERIFY",
          "old_text": null,
          "new_text": "VERIFY(window_or_worker)",
          "old_line_content": "",
          "new_line_content": "    VERIFY(window_or_worker);",
          "content_same": false
        },
        {
          "line": 91,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "mark_name.value()",
          "old_line_content": "",
          "new_line_content": "    window_or_worker->remove_entries_from_performance_entry_buffer({}, PerformanceTimeline::EntryTypes::mark, mark_name.value());",
          "content_same": false
        },
        {
          "line": 219,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "start_or_measure_options_dictionary_object->duration.has_value()",
          "old_line_content": "        // 1. Let start be the value returned by running the convert a mark to a timestamp algorithm passing in start.",
          "new_line_content": "    else if (start_or_measure_options_dictionary_object && start_or_measure_options_dictionary_object->start.has_value() && start_or_measure_options_dictionary_object->duration.has_value()) {",
          "content_same": false
        },
        {
          "line": 221,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "start_or_measure_options_dictionary_object->start.value()",
          "old_line_content": "",
          "new_line_content": "        auto start = TRY(convert_mark_to_timestamp(realm, start_or_measure_options_dictionary_object->start.value()));",
          "content_same": false
        },
        {
          "line": 350,
          "old_api": null,
          "new_api": "filter_buffer_map_by_name_and_type",
          "old_text": null,
          "new_text": "window_or_worker->filter_buffer_map_by_name_and_type(/* name= */ Optional<String> {}, type)",
          "old_line_content": "}",
          "new_line_content": "    return TRY_OR_THROW_OOM(vm, window_or_worker->filter_buffer_map_by_name_and_type(/* name= */ Optional<String> {}, type));",
          "content_same": false
        },
        {
          "line": 224,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "start_or_measure_options_dictionary_object->duration.value()",
          "old_line_content": "",
          "new_line_content": "        auto duration = TRY(convert_mark_to_timestamp(realm, start_or_measure_options_dictionary_object->duration.value()));",
          "content_same": false
        },
        {
          "line": 98,
          "old_api": null,
          "new_api": "vm",
          "old_text": null,
          "new_text": "realm.vm()",
          "old_line_content": "",
          "new_line_content": "    auto& vm = realm.vm();",
          "content_same": false
        },
        {
          "line": 102,
          "old_api": null,
          "new_api": "String::formatted(\"'{}' is an attribute in the PerformanceTiming interface and thus can only be used in a Window context\", name)",
          "old_text": null,
          "new_text": "String::formatted(\"'{}' is an attribute in the PerformanceTiming interface and thus can only be used in a Window context\", name)",
          "old_line_content": "",
          "new_line_content": "        return WebIDL::SimpleException { WebIDL::SimpleExceptionType::TypeError, TRY_OR_THROW_OOM(vm, String::formatted(\"'{}' is an attribute in the PerformanceTiming interface and thus can only be used in a Window context\", name)) };",
          "content_same": false
        },
        {
          "line": 359,
          "old_api": null,
          "new_api": "VERIFY",
          "old_text": null,
          "new_text": "VERIFY(window_or_worker)",
          "old_line_content": "",
          "new_line_content": "    VERIFY(window_or_worker);",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": null,
          "new_api": "HighResolutionTime::unsafe_shared_current_time()",
          "old_text": null,
          "new_text": "HighResolutionTime::unsafe_shared_current_time()",
          "old_line_content": "    }",
          "new_line_content": "        end_time = HighResolutionTime::unsafe_shared_current_time();",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": null,
          "new_api": "filter_buffer_map_by_name_and_type",
          "old_text": null,
          "new_text": "window_or_worker->filter_buffer_map_by_name_and_type(name, type)",
          "old_line_content": "}",
          "new_line_content": "    return TRY_OR_THROW_OOM(vm, window_or_worker->filter_buffer_map_by_name_and_type(name, type));",
          "content_same": false
        },
        {
          "line": 109,
          "old_api": null,
          "new_api": "VERIFY",
          "old_text": null,
          "new_text": "VERIFY(timing_interface)",
          "old_line_content": "",
          "new_line_content": "    VERIFY(timing_interface);",
          "content_same": false
        },
        {
          "line": 112,
          "old_api": null,
          "new_api": "navigation_start",
          "old_text": null,
          "new_text": "timing_interface->navigation_start()",
          "old_line_content": "",
          "new_line_content": "    auto start_time = timing_interface->navigation_start();",
          "content_same": false
        },
        {
          "line": 241,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "start_or_measure_options_dictionary_object->start.value()",
          "old_line_content": "    }",
          "new_line_content": "        start_time = TRY(convert_mark_to_timestamp(realm, start_or_measure_options_dictionary_object->start.value()));",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "start_or_measure_options_dictionary_object->end.has_value()",
          "old_line_content": "        // 1. Let duration be the value returned by running the convert a mark to a timestamp algorithm passing in duration.",
          "new_line_content": "    else if (start_or_measure_options_dictionary_object && start_or_measure_options_dictionary_object->duration.has_value() && start_or_measure_options_dictionary_object->end.has_value()) {",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "start_or_measure_options_dictionary_object->duration.value()",
          "old_line_content": "",
          "new_line_content": "        auto duration = TRY(convert_mark_to_timestamp(realm, start_or_measure_options_dictionary_object->duration.value()));",
          "content_same": false
        },
        {
          "line": 250,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "start_or_measure_options_dictionary_object->end.value()",
          "old_line_content": "",
          "new_line_content": "        auto end = TRY(convert_mark_to_timestamp(realm, start_or_measure_options_dictionary_object->end.value()));",
          "content_same": false
        },
        {
          "line": 125,
          "old_api": null,
          "new_api": "String::formatted(\"The '{}' entry in the PerformanceTiming interface is equal to 0, meaning it hasn't happened yet\", name)",
          "old_text": null,
          "new_text": "String::formatted(\"The '{}' entry in the PerformanceTiming interface is equal to 0, meaning it hasn't happened yet\", name)",
          "old_line_content": "",
          "new_line_content": "        return WebIDL::InvalidAccessError::create(realm, MUST(String::formatted(\"The '{}' entry in the PerformanceTiming interface is equal to 0, meaning it hasn't happened yet\", name)));",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 256,
          "old_api": "start_or_measure_options.has<String>()",
          "new_api": null,
          "old_text": "start_or_measure_options.has<String>()",
          "new_text": null,
          "old_line_content": "    else if (start_or_measure_options.has<String>()) {",
          "new_line_content": "    //    to a timestamp algorithm passing in startOrMeasureOptions.",
          "content_same": false
        },
        {
          "line": 133,
          "old_api": "mark.has<String>()",
          "new_api": null,
          "old_text": "mark.has<String>()",
          "new_text": null,
          "old_line_content": "    if (mark.has<String>()) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 147,
          "old_api": "global_object",
          "new_api": null,
          "old_text": "realm.global_object()",
          "new_text": null,
          "old_line_content": "        auto* window_or_worker = dynamic_cast<HTML::WindowOrWorkerGlobalScopeMixin*>(&realm.global_object());",
          "new_line_content": "        //    SyntaxError.",
          "content_same": false
        },
        {
          "line": 150,
          "old_api": "relevant_performance_entry_tuple",
          "new_api": null,
          "old_text": "window_or_worker->relevant_performance_entry_tuple(PerformanceTimeline::EntryTypes::mark)",
          "new_text": null,
          "old_line_content": "        auto& tuple = window_or_worker->relevant_performance_entry_tuple(PerformanceTimeline::EntryTypes::mark);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 280,
          "old_api": "JS::js_null()",
          "new_api": null,
          "old_text": "JS::js_null()",
          "new_text": null,
          "old_line_content": "    JS::Value detail { JS::js_null() };",
          "new_line_content": "    // 9. Set entry's detail attribute as follows:",
          "content_same": false
        },
        {
          "line": 153,
          "old_api": "last_matching",
          "new_api": null,
          "old_text": "performance_entry_buffer.last_matching([&mark_string](JS::Handle<PerformanceTimeline::PerformanceEntry> const& entry) {\n            return entry->name() == mark_string;\n        })",
          "new_text": null,
          "old_line_content": "        auto maybe_entry = performance_entry_buffer.last_matching([&mark_string](JS::Handle<PerformanceTimeline::PerformanceEntry> const& entry) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 27,
          "old_api": "start",
          "new_api": null,
          "old_text": "m_timer.start()",
          "new_text": null,
          "old_line_content": "    m_timer.start();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": "is_undefined",
          "new_api": null,
          "old_text": "start_or_measure_options_dictionary_object->detail.is_undefined()",
          "new_text": null,
          "old_line_content": "    if (start_or_measure_options_dictionary_object && !start_or_measure_options_dictionary_object->detail.is_undefined()) {",
          "new_line_content": "    // 1. If startOrMeasureOptions is a PerformanceMeasureOptions object and startOrMeasureOptions's detail member is present:",
          "content_same": false
        },
        {
          "line": 157,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "maybe_entry.has_value()",
          "new_text": null,
          "old_line_content": "        if (!maybe_entry.has_value())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": "HTML::structured_serialize(vm, start_or_measure_options_dictionary_object->detail)",
          "new_api": null,
          "old_text": "HTML::structured_serialize(vm, start_or_measure_options_dictionary_object->detail)",
          "new_text": null,
          "old_line_content": "        auto record = TRY(HTML::structured_serialize(vm, start_or_measure_options_dictionary_object->detail));",
          "new_line_content": "        // 1. Let record be the result of calling the StructuredSerialize algorithm on startOrMeasureOptions's detail.",
          "content_same": false
        },
        {
          "line": 160,
          "old_api": "value",
          "new_api": null,
          "old_text": "maybe_entry.value()->start_time()",
          "new_text": null,
          "old_line_content": "        return maybe_entry.value()->start_time();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": "HTML::structured_deserialize(vm, record, realm, Optional<HTML::DeserializationMemory> {})",
          "new_api": null,
          "old_text": "HTML::structured_deserialize(vm, record, realm, Optional<HTML::DeserializationMemory> {})",
          "new_text": null,
          "old_line_content": "        detail = TRY(HTML::structured_deserialize(vm, record, realm, Optional<HTML::DeserializationMemory> {}));",
          "new_line_content": "        // 2. Set entry's detail to the result of calling the StructuredDeserialize algorithm on record and the current realm.",
          "content_same": false
        },
        {
          "line": 34,
          "old_api": "Base::initialize(realm)",
          "new_api": null,
          "old_text": "Base::initialize(realm)",
          "new_text": null,
          "old_line_content": "    Base::initialize(realm);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 164,
          "old_api": "mark.get<HighResolutionTime::DOMHighResTimeStamp>()",
          "new_api": null,
          "old_text": "mark.get<HighResolutionTime::DOMHighResTimeStamp>()",
          "new_text": null,
          "old_line_content": "    auto mark_time_stamp = mark.get<HighResolutionTime::DOMHighResTimeStamp>();",
          "new_line_content": "    // 3. Otherwise, if mark is a DOMHighResTimeStamp:",
          "content_same": false
        },
        {
          "line": 295,
          "old_api": "heap",
          "new_api": null,
          "old_text": "realm.heap().allocate<UserTiming::PerformanceMeasure>(realm, realm, measure_name, start_time, duration, detail)",
          "new_text": null,
          "old_line_content": "    auto entry = realm.heap().allocate<UserTiming::PerformanceMeasure>(realm, realm, measure_name, start_time, duration, detail);",
          "new_line_content": "    // 4. Create a new PerformanceMeasure object (entry) with this's relevant realm.",
          "content_same": false
        },
        {
          "line": 40,
          "old_api": "Base::visit_edges(visitor)",
          "new_api": null,
          "old_text": "Base::visit_edges(visitor)",
          "new_text": null,
          "old_line_content": "    Base::visit_edges(visitor);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": "queue_performance_entry",
          "new_api": null,
          "old_text": "window_or_worker->queue_performance_entry(entry)",
          "new_text": null,
          "old_line_content": "    window_or_worker->queue_performance_entry(entry);",
          "new_line_content": "    // 10. Queue entry.",
          "content_same": false
        },
        {
          "line": 48,
          "old_api": "realm",
          "new_api": null,
          "old_text": "realm()",
          "new_text": null,
          "old_line_content": "        m_timing = heap().allocate<NavigationTiming::PerformanceTiming>(realm(), *m_window);",
          "new_line_content": "    if (!m_timing)",
          "content_same": false
        },
        {
          "line": 177,
          "old_api": "realm",
          "new_api": null,
          "old_text": "this->realm()",
          "new_text": null,
          "old_line_content": "    auto& realm = this->realm();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 54,
          "old_api": "origin_time",
          "new_api": null,
          "old_text": "m_timer.origin_time().milliseconds()",
          "new_text": null,
          "old_line_content": "    return static_cast<double>(m_timer.origin_time().milliseconds());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": "realm",
          "new_api": null,
          "old_text": "this->realm()",
          "new_text": null,
          "old_line_content": "    auto& realm = this->realm();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 184,
          "old_api": "start_or_measure_options.get_pointer<UserTiming::PerformanceMeasureOptions>()",
          "new_api": null,
          "old_text": "start_or_measure_options.get_pointer<UserTiming::PerformanceMeasureOptions>()",
          "new_text": null,
          "old_line_content": "    auto const* start_or_measure_options_dictionary_object = start_or_measure_options.get_pointer<UserTiming::PerformanceMeasureOptions>();",
          "new_line_content": "    //    are present, run the following checks:",
          "content_same": false
        },
        {
          "line": 186,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "start_or_measure_options_dictionary_object->start.has_value()",
          "new_text": null,
          "old_line_content": "        && (start_or_measure_options_dictionary_object->start.has_value()",
          "new_line_content": "    if (start_or_measure_options_dictionary_object",
          "content_same": false
        },
        {
          "line": 315,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "measure_name.has_value()",
          "new_text": null,
          "old_line_content": "    if (!measure_name.has_value()) {",
          "new_line_content": "    // 1. If measureName is omitted, remove all PerformanceMeasure objects in the performance entry buffer.",
          "content_same": false
        },
        {
          "line": 60,
          "old_api": "realm",
          "new_api": null,
          "old_text": "this->realm()",
          "new_text": null,
          "old_line_content": "    auto& realm = this->realm();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 63,
          "old_api": "UserTiming::PerformanceMark::construct_impl(realm, mark_name, mark_options)",
          "new_api": null,
          "old_text": "UserTiming::PerformanceMark::construct_impl(realm, mark_name, mark_options)",
          "new_text": null,
          "old_line_content": "    auto entry = TRY(UserTiming::PerformanceMark::construct_impl(realm, mark_name, mark_options));",
          "new_line_content": "    // 1. Run the PerformanceMark constructor and let entry be the newly created object.",
          "content_same": false
        },
        {
          "line": 191,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "end_mark.has_value()",
          "new_text": null,
          "old_line_content": "        if (end_mark.has_value())",
          "new_line_content": "        // 1. If endMark is given, throw a TypeError.",
          "content_same": false
        },
        {
          "line": 321,
          "old_api": "value",
          "new_api": null,
          "old_text": "measure_name.value()",
          "new_text": null,
          "old_line_content": "    window_or_worker->remove_entries_from_performance_entry_buffer({}, PerformanceTimeline::EntryTypes::measure, measure_name.value());",
          "new_line_content": "    // 2. Otherwise remove all PerformanceMeasure objects listed in the performance entry buffer whose name is measureName.",
          "content_same": false
        },
        {
          "line": 66,
          "old_api": "global_object",
          "new_api": null,
          "old_text": "realm.global_object()",
          "new_text": null,
          "old_line_content": "    auto* window_or_worker = dynamic_cast<HTML::WindowOrWorkerGlobalScopeMixin*>(&realm.global_object());",
          "new_line_content": "    // 2. Queue entry.",
          "content_same": false
        },
        {
          "line": 195,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "start_or_measure_options_dictionary_object->end.has_value()",
          "new_text": null,
          "old_line_content": "        if (!start_or_measure_options_dictionary_object->start.has_value() && !start_or_measure_options_dictionary_object->end.has_value())",
          "new_line_content": "        // 2. If startOrMeasureOptions's start and end members are both omitted, throw a TypeError.",
          "content_same": false
        },
        {
          "line": 199,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "start_or_measure_options_dictionary_object->duration.has_value()",
          "new_text": null,
          "old_line_content": "        if (start_or_measure_options_dictionary_object->start.has_value() && start_or_measure_options_dictionary_object->end.has_value() && start_or_measure_options_dictionary_object->duration.has_value())",
          "new_line_content": "        // 3. If startOrMeasureOptions's start, duration, and end members are all present, throw a TypeError.",
          "content_same": false
        },
        {
          "line": 329,
          "old_api": "realm",
          "new_api": null,
          "old_text": "this->realm()",
          "new_text": null,
          "old_line_content": "    auto& realm = this->realm();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 79,
          "old_api": "realm",
          "new_api": null,
          "old_text": "this->realm()",
          "new_text": null,
          "old_line_content": "    auto& realm = this->realm();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 208,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "end_mark.has_value()",
          "new_text": null,
          "old_line_content": "    if (end_mark.has_value()) {",
          "new_line_content": "    //    in endMark.",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": "filter_buffer_map_by_name_and_type",
          "new_api": null,
          "old_text": "window_or_worker->filter_buffer_map_by_name_and_type(/* name= */ Optional<String> {}, /* type= */ Optional<String> {})",
          "new_text": null,
          "old_line_content": "    return TRY_OR_THROW_OOM(vm, window_or_worker->filter_buffer_map_by_name_and_type(/* name= */ Optional<String> {}, /* type= */ Optional<String> {}));",
          "new_line_content": "    // type set to null.",
          "content_same": false
        },
        {
          "line": 84,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "mark_name.has_value()",
          "new_text": null,
          "old_line_content": "    if (!mark_name.has_value()) {",
          "new_line_content": "    // 1. If markName is omitted, remove all PerformanceMark objects from the performance entry buffer.",
          "content_same": false
        },
        {
          "line": 213,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "start_or_measure_options_dictionary_object->end.has_value()",
          "new_text": null,
          "old_line_content": "    else if (start_or_measure_options_dictionary_object && start_or_measure_options_dictionary_object->end.has_value()) {",
          "new_line_content": "    //    time be the value returned by running the convert a mark to a timestamp algorithm passing in startOrMeasureOptions's end.",
          "content_same": false
        },
        {
          "line": 342,
          "old_api": "realm",
          "new_api": null,
          "old_text": "this->realm()",
          "new_text": null,
          "old_line_content": "    auto& realm = this->realm();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 90,
          "old_api": "value",
          "new_api": null,
          "old_text": "mark_name.value()",
          "new_text": null,
          "old_line_content": "    window_or_worker->remove_entries_from_performance_entry_buffer({}, PerformanceTimeline::EntryTypes::mark, mark_name.value());",
          "new_line_content": "    // 2. Otherwise, remove all PerformanceMark objects listed in the performance entry buffer whose name is markName.",
          "content_same": false
        },
        {
          "line": 218,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "start_or_measure_options_dictionary_object->duration.has_value()",
          "new_text": null,
          "old_line_content": "    else if (start_or_measure_options_dictionary_object && start_or_measure_options_dictionary_object->start.has_value() && start_or_measure_options_dictionary_object->duration.has_value()) {",
          "new_line_content": "    //    both present:",
          "content_same": false
        },
        {
          "line": 220,
          "old_api": "value",
          "new_api": null,
          "old_text": "start_or_measure_options_dictionary_object->start.value()",
          "new_text": null,
          "old_line_content": "        auto start = TRY(convert_mark_to_timestamp(realm, start_or_measure_options_dictionary_object->start.value()));",
          "new_line_content": "        // 1. Let start be the value returned by running the convert a mark to a timestamp algorithm passing in start.",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": "filter_buffer_map_by_name_and_type",
          "new_api": null,
          "old_text": "window_or_worker->filter_buffer_map_by_name_and_type(/* name= */ Optional<String> {}, type)",
          "new_text": null,
          "old_line_content": "    return TRY_OR_THROW_OOM(vm, window_or_worker->filter_buffer_map_by_name_and_type(/* name= */ Optional<String> {}, type));",
          "new_line_content": "    // and type set to the method's input type parameter.",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": "value",
          "new_api": null,
          "old_text": "start_or_measure_options_dictionary_object->duration.value()",
          "new_text": null,
          "old_line_content": "        auto duration = TRY(convert_mark_to_timestamp(realm, start_or_measure_options_dictionary_object->duration.value()));",
          "new_line_content": "        // 2. Let duration be the value returned by running the convert a mark to a timestamp algorithm passing in duration.",
          "content_same": false
        },
        {
          "line": 97,
          "old_api": "vm",
          "new_api": null,
          "old_text": "realm.vm()",
          "new_text": null,
          "old_line_content": "    auto& vm = realm.vm();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 355,
          "old_api": "realm",
          "new_api": null,
          "old_text": "this->realm()",
          "new_text": null,
          "old_line_content": "    auto& realm = this->realm();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 100,
          "old_api": "global_object",
          "new_api": null,
          "old_text": "realm.global_object()",
          "new_text": null,
          "old_line_content": "    if (!is<HTML::Window>(realm.global_object()))",
          "new_line_content": "    // 1. If the global object is not a Window object, throw a TypeError.",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": "HighResolutionTime::unsafe_shared_current_time()",
          "new_api": null,
          "old_text": "HighResolutionTime::unsafe_shared_current_time()",
          "new_text": null,
          "old_line_content": "        end_time = HighResolutionTime::unsafe_shared_current_time();",
          "new_line_content": "        // FIXME: Performance#now doesn't currently use TimeOrigin's functions, update this and Performance#now to match Performance#now's specification.",
          "content_same": false
        },
        {
          "line": 107,
          "old_api": "timing",
          "new_api": null,
          "old_text": "timing()",
          "new_text": null,
          "old_line_content": "    auto timing_interface = timing();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 363,
          "old_api": "filter_buffer_map_by_name_and_type",
          "new_api": null,
          "old_text": "window_or_worker->filter_buffer_map_by_name_and_type(name, type)",
          "new_text": null,
          "old_line_content": "    return TRY_OR_THROW_OOM(vm, window_or_worker->filter_buffer_map_by_name_and_type(name, type));",
          "new_line_content": "    // parameter otherwise.",
          "content_same": false
        },
        {
          "line": 111,
          "old_api": "navigation_start",
          "new_api": null,
          "old_text": "timing_interface->navigation_start()",
          "new_text": null,
          "old_line_content": "    auto start_time = timing_interface->navigation_start();",
          "new_line_content": "    // 3. Let startTime be the value of navigationStart in the PerformanceTiming interface.",
          "content_same": false
        },
        {
          "line": 239,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "start_or_measure_options_dictionary_object->start.has_value()",
          "new_text": null,
          "old_line_content": "    if (start_or_measure_options_dictionary_object && start_or_measure_options_dictionary_object->start.has_value()) {",
          "new_line_content": "    //    the value returned by running the convert a mark to a timestamp algorithm passing in startOrMeasureOptions's start.",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "start_or_measure_options_dictionary_object->end.has_value()",
          "new_text": null,
          "old_line_content": "    else if (start_or_measure_options_dictionary_object && start_or_measure_options_dictionary_object->duration.has_value() && start_or_measure_options_dictionary_object->end.has_value()) {",
          "new_line_content": "    //    both present:",
          "content_same": false
        },
        {
          "line": 246,
          "old_api": "value",
          "new_api": null,
          "old_text": "start_or_measure_options_dictionary_object->duration.value()",
          "new_text": null,
          "old_line_content": "        auto duration = TRY(convert_mark_to_timestamp(realm, start_or_measure_options_dictionary_object->duration.value()));",
          "new_line_content": "        // 1. Let duration be the value returned by running the convert a mark to a timestamp algorithm passing in duration.",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": "value",
          "new_api": null,
          "old_text": "start_or_measure_options_dictionary_object->end.value()",
          "new_text": null,
          "old_line_content": "        auto end = TRY(convert_mark_to_timestamp(realm, start_or_measure_options_dictionary_object->end.value()));",
          "new_line_content": "        // 2. Let end be the value returned by running the convert a mark to a timestamp algorithm passing in end.",
          "content_same": false
        },
        {
          "line": 124,
          "old_api": "String::formatted(\"The '{}' entry in the PerformanceTiming interface is equal to 0, meaning it hasn't happened yet\", name)",
          "new_api": null,
          "old_text": "String::formatted(\"The '{}' entry in the PerformanceTiming interface is equal to 0, meaning it hasn't happened yet\", name)",
          "new_text": null,
          "old_line_content": "        return WebIDL::InvalidAccessError::create(realm, MUST(String::formatted(\"The '{}' entry in the PerformanceTiming interface is equal to 0, meaning it hasn't happened yet\", name)));",
          "new_line_content": "    if (end_time == 0)",
          "content_same": false
        },
        {
          "line": 127,
          "old_api": "static_cast<HighResolutionTime::DOMHighResTimeStamp>(end_time - start_time)",
          "new_api": null,
          "old_text": "static_cast<HighResolutionTime::DOMHighResTimeStamp>(end_time - start_time)",
          "new_text": null,
          "old_line_content": "    return static_cast<HighResolutionTime::DOMHighResTimeStamp>(end_time - start_time);",
          "new_line_content": "    // 6. Return result of subtracting startTime from endTime.",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 33,
      "total_additions": 56,
      "total_deletions": 56,
      "total_api_changes": 145
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 1,
        "api_related_lines": 145,
        "non_api_lines": 1,
        "non_api_line_numbers": [
          26
        ]
      }
    },
    "api_calls_before": 144,
    "api_calls_after": 144,
    "diff_info": {
      "added_lines": 1,
      "removed_lines": 0,
      "total_diff_lines": 13
    }
  }
}